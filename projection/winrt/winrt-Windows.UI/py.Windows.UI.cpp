// WARNING: Please don't edit this file. It was generated by Python/WinRT v3.0.0

#include "py.Windows.UI.h"

namespace py::cpp::Windows::UI
{
    // ----- ColorHelper class --------------------

    static PyObject* _new_ColorHelper(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::ColorHelper>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::ColorHelper>::type_name);
        return nullptr;
    }

    static void _dealloc_ColorHelper(py::wrapper::Windows::UI::ColorHelper* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ColorHelper_FromArgb(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 4)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.ColorHelper", L"FromArgb", 4);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(4);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint8_t>(args, 0);
                auto param1 = py::convert_to<uint8_t>(args, 1);
                auto param2 = py::convert_to<uint8_t>(args, 2);
                auto param3 = py::convert_to<uint8_t>(args, 3);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::UI::ColorHelper::FromArgb(param0, param1, param2, param3);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ColorHelper_ToDisplayName(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.ColorHelper", L"ToDisplayName", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Color>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::UI::ColorHelper::ToDisplayName(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_ColorHelper(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::ColorHelper>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ColorHelper(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::ColorHelper>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ColorHelper[] = {
        { "_assign_array_", _assign_array_ColorHelper, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ColorHelper), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_ColorHelper[] = {
        { }};

    static PyType_Slot _type_slots_ColorHelper[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ColorHelper) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ColorHelper) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ColorHelper) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ColorHelper) },
        { }};

    static PyType_Spec type_spec_ColorHelper = {
        "winrt._winrt_windows_ui.ColorHelper",
        sizeof(py::wrapper::Windows::UI::ColorHelper),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ColorHelper};

    static PyGetSetDef getset_ColorHelper_Static[] = {
        { }};

    static PyMethodDef methods_ColorHelper_Static[] = {
        { "from_argb", reinterpret_cast<PyCFunction>(ColorHelper_FromArgb), METH_VARARGS, nullptr },
        { "to_display_name", reinterpret_cast<PyCFunction>(ColorHelper_ToDisplayName), METH_VARARGS, nullptr },
        { }};

    static PyType_Slot type_slots_ColorHelper_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_ColorHelper_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_ColorHelper_Static) },
        { }
    };

    static PyType_Spec type_spec_ColorHelper_Static = {
        "winrt._winrt_windows_ui.ColorHelper_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_ColorHelper_Static};

    // ----- Colors class --------------------

    static PyObject* _new_Colors(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Colors>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Colors>::type_name);
        return nullptr;
    }

    static void _dealloc_Colors(py::wrapper::Windows::UI::Colors* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* Colors_get_AliceBlue(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Colors", L"AliceBlue");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::UI::Colors::AliceBlue();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Colors_get_AntiqueWhite(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Colors", L"AntiqueWhite");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::UI::Colors::AntiqueWhite();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Colors_get_Aqua(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Colors", L"Aqua");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::UI::Colors::Aqua();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Colors_get_Aquamarine(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Colors", L"Aquamarine");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::UI::Colors::Aquamarine();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Colors_get_Azure(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Colors", L"Azure");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::UI::Colors::Azure();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Colors_get_Beige(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Colors", L"Beige");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::UI::Colors::Beige();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Colors_get_Bisque(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Colors", L"Bisque");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::UI::Colors::Bisque();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Colors_get_Black(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Colors", L"Black");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::UI::Colors::Black();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Colors_get_BlanchedAlmond(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Colors", L"BlanchedAlmond");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::UI::Colors::BlanchedAlmond();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Colors_get_Blue(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Colors", L"Blue");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::UI::Colors::Blue();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Colors_get_BlueViolet(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Colors", L"BlueViolet");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::UI::Colors::BlueViolet();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Colors_get_Brown(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Colors", L"Brown");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::UI::Colors::Brown();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Colors_get_BurlyWood(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Colors", L"BurlyWood");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::UI::Colors::BurlyWood();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Colors_get_CadetBlue(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Colors", L"CadetBlue");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::UI::Colors::CadetBlue();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Colors_get_Chartreuse(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Colors", L"Chartreuse");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::UI::Colors::Chartreuse();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Colors_get_Chocolate(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Colors", L"Chocolate");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::UI::Colors::Chocolate();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Colors_get_Coral(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Colors", L"Coral");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::UI::Colors::Coral();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Colors_get_CornflowerBlue(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Colors", L"CornflowerBlue");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::UI::Colors::CornflowerBlue();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Colors_get_Cornsilk(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Colors", L"Cornsilk");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::UI::Colors::Cornsilk();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Colors_get_Crimson(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Colors", L"Crimson");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::UI::Colors::Crimson();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Colors_get_Cyan(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Colors", L"Cyan");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::UI::Colors::Cyan();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Colors_get_DarkBlue(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Colors", L"DarkBlue");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::UI::Colors::DarkBlue();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Colors_get_DarkCyan(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Colors", L"DarkCyan");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::UI::Colors::DarkCyan();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Colors_get_DarkGoldenrod(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Colors", L"DarkGoldenrod");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::UI::Colors::DarkGoldenrod();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Colors_get_DarkGray(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Colors", L"DarkGray");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::UI::Colors::DarkGray();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Colors_get_DarkGreen(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Colors", L"DarkGreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::UI::Colors::DarkGreen();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Colors_get_DarkKhaki(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Colors", L"DarkKhaki");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::UI::Colors::DarkKhaki();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Colors_get_DarkMagenta(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Colors", L"DarkMagenta");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::UI::Colors::DarkMagenta();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Colors_get_DarkOliveGreen(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Colors", L"DarkOliveGreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::UI::Colors::DarkOliveGreen();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Colors_get_DarkOrange(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Colors", L"DarkOrange");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::UI::Colors::DarkOrange();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Colors_get_DarkOrchid(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Colors", L"DarkOrchid");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::UI::Colors::DarkOrchid();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Colors_get_DarkRed(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Colors", L"DarkRed");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::UI::Colors::DarkRed();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Colors_get_DarkSalmon(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Colors", L"DarkSalmon");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::UI::Colors::DarkSalmon();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Colors_get_DarkSeaGreen(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Colors", L"DarkSeaGreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::UI::Colors::DarkSeaGreen();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Colors_get_DarkSlateBlue(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Colors", L"DarkSlateBlue");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::UI::Colors::DarkSlateBlue();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Colors_get_DarkSlateGray(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Colors", L"DarkSlateGray");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::UI::Colors::DarkSlateGray();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Colors_get_DarkTurquoise(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Colors", L"DarkTurquoise");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::UI::Colors::DarkTurquoise();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Colors_get_DarkViolet(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Colors", L"DarkViolet");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::UI::Colors::DarkViolet();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Colors_get_DeepPink(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Colors", L"DeepPink");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::UI::Colors::DeepPink();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Colors_get_DeepSkyBlue(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Colors", L"DeepSkyBlue");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::UI::Colors::DeepSkyBlue();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Colors_get_DimGray(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Colors", L"DimGray");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::UI::Colors::DimGray();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Colors_get_DodgerBlue(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Colors", L"DodgerBlue");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::UI::Colors::DodgerBlue();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Colors_get_Firebrick(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Colors", L"Firebrick");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::UI::Colors::Firebrick();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Colors_get_FloralWhite(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Colors", L"FloralWhite");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::UI::Colors::FloralWhite();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Colors_get_ForestGreen(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Colors", L"ForestGreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::UI::Colors::ForestGreen();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Colors_get_Fuchsia(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Colors", L"Fuchsia");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::UI::Colors::Fuchsia();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Colors_get_Gainsboro(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Colors", L"Gainsboro");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::UI::Colors::Gainsboro();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Colors_get_GhostWhite(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Colors", L"GhostWhite");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::UI::Colors::GhostWhite();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Colors_get_Gold(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Colors", L"Gold");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::UI::Colors::Gold();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Colors_get_Goldenrod(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Colors", L"Goldenrod");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::UI::Colors::Goldenrod();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Colors_get_Gray(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Colors", L"Gray");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::UI::Colors::Gray();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Colors_get_Green(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Colors", L"Green");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::UI::Colors::Green();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Colors_get_GreenYellow(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Colors", L"GreenYellow");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::UI::Colors::GreenYellow();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Colors_get_Honeydew(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Colors", L"Honeydew");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::UI::Colors::Honeydew();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Colors_get_HotPink(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Colors", L"HotPink");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::UI::Colors::HotPink();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Colors_get_IndianRed(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Colors", L"IndianRed");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::UI::Colors::IndianRed();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Colors_get_Indigo(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Colors", L"Indigo");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::UI::Colors::Indigo();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Colors_get_Ivory(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Colors", L"Ivory");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::UI::Colors::Ivory();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Colors_get_Khaki(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Colors", L"Khaki");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::UI::Colors::Khaki();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Colors_get_Lavender(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Colors", L"Lavender");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::UI::Colors::Lavender();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Colors_get_LavenderBlush(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Colors", L"LavenderBlush");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::UI::Colors::LavenderBlush();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Colors_get_LawnGreen(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Colors", L"LawnGreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::UI::Colors::LawnGreen();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Colors_get_LemonChiffon(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Colors", L"LemonChiffon");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::UI::Colors::LemonChiffon();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Colors_get_LightBlue(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Colors", L"LightBlue");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::UI::Colors::LightBlue();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Colors_get_LightCoral(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Colors", L"LightCoral");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::UI::Colors::LightCoral();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Colors_get_LightCyan(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Colors", L"LightCyan");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::UI::Colors::LightCyan();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Colors_get_LightGoldenrodYellow(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Colors", L"LightGoldenrodYellow");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::UI::Colors::LightGoldenrodYellow();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Colors_get_LightGray(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Colors", L"LightGray");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::UI::Colors::LightGray();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Colors_get_LightGreen(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Colors", L"LightGreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::UI::Colors::LightGreen();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Colors_get_LightPink(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Colors", L"LightPink");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::UI::Colors::LightPink();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Colors_get_LightSalmon(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Colors", L"LightSalmon");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::UI::Colors::LightSalmon();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Colors_get_LightSeaGreen(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Colors", L"LightSeaGreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::UI::Colors::LightSeaGreen();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Colors_get_LightSkyBlue(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Colors", L"LightSkyBlue");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::UI::Colors::LightSkyBlue();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Colors_get_LightSlateGray(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Colors", L"LightSlateGray");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::UI::Colors::LightSlateGray();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Colors_get_LightSteelBlue(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Colors", L"LightSteelBlue");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::UI::Colors::LightSteelBlue();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Colors_get_LightYellow(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Colors", L"LightYellow");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::UI::Colors::LightYellow();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Colors_get_Lime(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Colors", L"Lime");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::UI::Colors::Lime();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Colors_get_LimeGreen(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Colors", L"LimeGreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::UI::Colors::LimeGreen();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Colors_get_Linen(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Colors", L"Linen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::UI::Colors::Linen();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Colors_get_Magenta(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Colors", L"Magenta");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::UI::Colors::Magenta();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Colors_get_Maroon(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Colors", L"Maroon");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::UI::Colors::Maroon();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Colors_get_MediumAquamarine(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Colors", L"MediumAquamarine");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::UI::Colors::MediumAquamarine();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Colors_get_MediumBlue(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Colors", L"MediumBlue");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::UI::Colors::MediumBlue();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Colors_get_MediumOrchid(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Colors", L"MediumOrchid");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::UI::Colors::MediumOrchid();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Colors_get_MediumPurple(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Colors", L"MediumPurple");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::UI::Colors::MediumPurple();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Colors_get_MediumSeaGreen(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Colors", L"MediumSeaGreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::UI::Colors::MediumSeaGreen();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Colors_get_MediumSlateBlue(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Colors", L"MediumSlateBlue");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::UI::Colors::MediumSlateBlue();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Colors_get_MediumSpringGreen(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Colors", L"MediumSpringGreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::UI::Colors::MediumSpringGreen();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Colors_get_MediumTurquoise(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Colors", L"MediumTurquoise");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::UI::Colors::MediumTurquoise();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Colors_get_MediumVioletRed(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Colors", L"MediumVioletRed");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::UI::Colors::MediumVioletRed();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Colors_get_MidnightBlue(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Colors", L"MidnightBlue");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::UI::Colors::MidnightBlue();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Colors_get_MintCream(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Colors", L"MintCream");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::UI::Colors::MintCream();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Colors_get_MistyRose(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Colors", L"MistyRose");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::UI::Colors::MistyRose();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Colors_get_Moccasin(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Colors", L"Moccasin");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::UI::Colors::Moccasin();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Colors_get_NavajoWhite(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Colors", L"NavajoWhite");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::UI::Colors::NavajoWhite();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Colors_get_Navy(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Colors", L"Navy");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::UI::Colors::Navy();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Colors_get_OldLace(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Colors", L"OldLace");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::UI::Colors::OldLace();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Colors_get_Olive(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Colors", L"Olive");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::UI::Colors::Olive();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Colors_get_OliveDrab(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Colors", L"OliveDrab");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::UI::Colors::OliveDrab();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Colors_get_Orange(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Colors", L"Orange");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::UI::Colors::Orange();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Colors_get_OrangeRed(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Colors", L"OrangeRed");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::UI::Colors::OrangeRed();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Colors_get_Orchid(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Colors", L"Orchid");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::UI::Colors::Orchid();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Colors_get_PaleGoldenrod(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Colors", L"PaleGoldenrod");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::UI::Colors::PaleGoldenrod();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Colors_get_PaleGreen(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Colors", L"PaleGreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::UI::Colors::PaleGreen();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Colors_get_PaleTurquoise(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Colors", L"PaleTurquoise");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::UI::Colors::PaleTurquoise();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Colors_get_PaleVioletRed(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Colors", L"PaleVioletRed");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::UI::Colors::PaleVioletRed();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Colors_get_PapayaWhip(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Colors", L"PapayaWhip");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::UI::Colors::PapayaWhip();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Colors_get_PeachPuff(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Colors", L"PeachPuff");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::UI::Colors::PeachPuff();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Colors_get_Peru(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Colors", L"Peru");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::UI::Colors::Peru();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Colors_get_Pink(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Colors", L"Pink");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::UI::Colors::Pink();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Colors_get_Plum(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Colors", L"Plum");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::UI::Colors::Plum();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Colors_get_PowderBlue(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Colors", L"PowderBlue");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::UI::Colors::PowderBlue();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Colors_get_Purple(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Colors", L"Purple");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::UI::Colors::Purple();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Colors_get_Red(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Colors", L"Red");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::UI::Colors::Red();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Colors_get_RosyBrown(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Colors", L"RosyBrown");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::UI::Colors::RosyBrown();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Colors_get_RoyalBlue(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Colors", L"RoyalBlue");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::UI::Colors::RoyalBlue();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Colors_get_SaddleBrown(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Colors", L"SaddleBrown");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::UI::Colors::SaddleBrown();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Colors_get_Salmon(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Colors", L"Salmon");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::UI::Colors::Salmon();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Colors_get_SandyBrown(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Colors", L"SandyBrown");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::UI::Colors::SandyBrown();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Colors_get_SeaGreen(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Colors", L"SeaGreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::UI::Colors::SeaGreen();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Colors_get_SeaShell(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Colors", L"SeaShell");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::UI::Colors::SeaShell();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Colors_get_Sienna(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Colors", L"Sienna");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::UI::Colors::Sienna();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Colors_get_Silver(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Colors", L"Silver");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::UI::Colors::Silver();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Colors_get_SkyBlue(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Colors", L"SkyBlue");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::UI::Colors::SkyBlue();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Colors_get_SlateBlue(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Colors", L"SlateBlue");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::UI::Colors::SlateBlue();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Colors_get_SlateGray(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Colors", L"SlateGray");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::UI::Colors::SlateGray();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Colors_get_Snow(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Colors", L"Snow");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::UI::Colors::Snow();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Colors_get_SpringGreen(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Colors", L"SpringGreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::UI::Colors::SpringGreen();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Colors_get_SteelBlue(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Colors", L"SteelBlue");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::UI::Colors::SteelBlue();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Colors_get_Tan(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Colors", L"Tan");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::UI::Colors::Tan();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Colors_get_Teal(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Colors", L"Teal");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::UI::Colors::Teal();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Colors_get_Thistle(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Colors", L"Thistle");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::UI::Colors::Thistle();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Colors_get_Tomato(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Colors", L"Tomato");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::UI::Colors::Tomato();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Colors_get_Transparent(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Colors", L"Transparent");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::UI::Colors::Transparent();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Colors_get_Turquoise(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Colors", L"Turquoise");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::UI::Colors::Turquoise();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Colors_get_Violet(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Colors", L"Violet");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::UI::Colors::Violet();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Colors_get_Wheat(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Colors", L"Wheat");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::UI::Colors::Wheat();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Colors_get_White(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Colors", L"White");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::UI::Colors::White();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Colors_get_WhiteSmoke(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Colors", L"WhiteSmoke");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::UI::Colors::WhiteSmoke();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Colors_get_Yellow(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Colors", L"Yellow");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::UI::Colors::Yellow();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Colors_get_YellowGreen(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Colors", L"YellowGreen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::UI::Colors::YellowGreen();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_Colors(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Colors>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_Colors(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Colors>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_Colors[] = {
        { "_assign_array_", _assign_array_Colors, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_Colors), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_Colors[] = {
        { }};

    static PyType_Slot _type_slots_Colors[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_Colors) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_Colors) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_Colors) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_Colors) },
        { }};

    static PyType_Spec type_spec_Colors = {
        "winrt._winrt_windows_ui.Colors",
        sizeof(py::wrapper::Windows::UI::Colors),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_Colors};

    static PyGetSetDef getset_Colors_Static[] = {
        { "alice_blue", reinterpret_cast<getter>(Colors_get_AliceBlue), nullptr, nullptr, nullptr },
        { "antique_white", reinterpret_cast<getter>(Colors_get_AntiqueWhite), nullptr, nullptr, nullptr },
        { "aqua", reinterpret_cast<getter>(Colors_get_Aqua), nullptr, nullptr, nullptr },
        { "aquamarine", reinterpret_cast<getter>(Colors_get_Aquamarine), nullptr, nullptr, nullptr },
        { "azure", reinterpret_cast<getter>(Colors_get_Azure), nullptr, nullptr, nullptr },
        { "beige", reinterpret_cast<getter>(Colors_get_Beige), nullptr, nullptr, nullptr },
        { "bisque", reinterpret_cast<getter>(Colors_get_Bisque), nullptr, nullptr, nullptr },
        { "black", reinterpret_cast<getter>(Colors_get_Black), nullptr, nullptr, nullptr },
        { "blanched_almond", reinterpret_cast<getter>(Colors_get_BlanchedAlmond), nullptr, nullptr, nullptr },
        { "blue", reinterpret_cast<getter>(Colors_get_Blue), nullptr, nullptr, nullptr },
        { "blue_violet", reinterpret_cast<getter>(Colors_get_BlueViolet), nullptr, nullptr, nullptr },
        { "brown", reinterpret_cast<getter>(Colors_get_Brown), nullptr, nullptr, nullptr },
        { "burly_wood", reinterpret_cast<getter>(Colors_get_BurlyWood), nullptr, nullptr, nullptr },
        { "cadet_blue", reinterpret_cast<getter>(Colors_get_CadetBlue), nullptr, nullptr, nullptr },
        { "chartreuse", reinterpret_cast<getter>(Colors_get_Chartreuse), nullptr, nullptr, nullptr },
        { "chocolate", reinterpret_cast<getter>(Colors_get_Chocolate), nullptr, nullptr, nullptr },
        { "coral", reinterpret_cast<getter>(Colors_get_Coral), nullptr, nullptr, nullptr },
        { "cornflower_blue", reinterpret_cast<getter>(Colors_get_CornflowerBlue), nullptr, nullptr, nullptr },
        { "cornsilk", reinterpret_cast<getter>(Colors_get_Cornsilk), nullptr, nullptr, nullptr },
        { "crimson", reinterpret_cast<getter>(Colors_get_Crimson), nullptr, nullptr, nullptr },
        { "cyan", reinterpret_cast<getter>(Colors_get_Cyan), nullptr, nullptr, nullptr },
        { "dark_blue", reinterpret_cast<getter>(Colors_get_DarkBlue), nullptr, nullptr, nullptr },
        { "dark_cyan", reinterpret_cast<getter>(Colors_get_DarkCyan), nullptr, nullptr, nullptr },
        { "dark_goldenrod", reinterpret_cast<getter>(Colors_get_DarkGoldenrod), nullptr, nullptr, nullptr },
        { "dark_gray", reinterpret_cast<getter>(Colors_get_DarkGray), nullptr, nullptr, nullptr },
        { "dark_green", reinterpret_cast<getter>(Colors_get_DarkGreen), nullptr, nullptr, nullptr },
        { "dark_khaki", reinterpret_cast<getter>(Colors_get_DarkKhaki), nullptr, nullptr, nullptr },
        { "dark_magenta", reinterpret_cast<getter>(Colors_get_DarkMagenta), nullptr, nullptr, nullptr },
        { "dark_olive_green", reinterpret_cast<getter>(Colors_get_DarkOliveGreen), nullptr, nullptr, nullptr },
        { "dark_orange", reinterpret_cast<getter>(Colors_get_DarkOrange), nullptr, nullptr, nullptr },
        { "dark_orchid", reinterpret_cast<getter>(Colors_get_DarkOrchid), nullptr, nullptr, nullptr },
        { "dark_red", reinterpret_cast<getter>(Colors_get_DarkRed), nullptr, nullptr, nullptr },
        { "dark_salmon", reinterpret_cast<getter>(Colors_get_DarkSalmon), nullptr, nullptr, nullptr },
        { "dark_sea_green", reinterpret_cast<getter>(Colors_get_DarkSeaGreen), nullptr, nullptr, nullptr },
        { "dark_slate_blue", reinterpret_cast<getter>(Colors_get_DarkSlateBlue), nullptr, nullptr, nullptr },
        { "dark_slate_gray", reinterpret_cast<getter>(Colors_get_DarkSlateGray), nullptr, nullptr, nullptr },
        { "dark_turquoise", reinterpret_cast<getter>(Colors_get_DarkTurquoise), nullptr, nullptr, nullptr },
        { "dark_violet", reinterpret_cast<getter>(Colors_get_DarkViolet), nullptr, nullptr, nullptr },
        { "deep_pink", reinterpret_cast<getter>(Colors_get_DeepPink), nullptr, nullptr, nullptr },
        { "deep_sky_blue", reinterpret_cast<getter>(Colors_get_DeepSkyBlue), nullptr, nullptr, nullptr },
        { "dim_gray", reinterpret_cast<getter>(Colors_get_DimGray), nullptr, nullptr, nullptr },
        { "dodger_blue", reinterpret_cast<getter>(Colors_get_DodgerBlue), nullptr, nullptr, nullptr },
        { "firebrick", reinterpret_cast<getter>(Colors_get_Firebrick), nullptr, nullptr, nullptr },
        { "floral_white", reinterpret_cast<getter>(Colors_get_FloralWhite), nullptr, nullptr, nullptr },
        { "forest_green", reinterpret_cast<getter>(Colors_get_ForestGreen), nullptr, nullptr, nullptr },
        { "fuchsia", reinterpret_cast<getter>(Colors_get_Fuchsia), nullptr, nullptr, nullptr },
        { "gainsboro", reinterpret_cast<getter>(Colors_get_Gainsboro), nullptr, nullptr, nullptr },
        { "ghost_white", reinterpret_cast<getter>(Colors_get_GhostWhite), nullptr, nullptr, nullptr },
        { "gold", reinterpret_cast<getter>(Colors_get_Gold), nullptr, nullptr, nullptr },
        { "goldenrod", reinterpret_cast<getter>(Colors_get_Goldenrod), nullptr, nullptr, nullptr },
        { "gray", reinterpret_cast<getter>(Colors_get_Gray), nullptr, nullptr, nullptr },
        { "green", reinterpret_cast<getter>(Colors_get_Green), nullptr, nullptr, nullptr },
        { "green_yellow", reinterpret_cast<getter>(Colors_get_GreenYellow), nullptr, nullptr, nullptr },
        { "honeydew", reinterpret_cast<getter>(Colors_get_Honeydew), nullptr, nullptr, nullptr },
        { "hot_pink", reinterpret_cast<getter>(Colors_get_HotPink), nullptr, nullptr, nullptr },
        { "indian_red", reinterpret_cast<getter>(Colors_get_IndianRed), nullptr, nullptr, nullptr },
        { "indigo", reinterpret_cast<getter>(Colors_get_Indigo), nullptr, nullptr, nullptr },
        { "ivory", reinterpret_cast<getter>(Colors_get_Ivory), nullptr, nullptr, nullptr },
        { "khaki", reinterpret_cast<getter>(Colors_get_Khaki), nullptr, nullptr, nullptr },
        { "lavender", reinterpret_cast<getter>(Colors_get_Lavender), nullptr, nullptr, nullptr },
        { "lavender_blush", reinterpret_cast<getter>(Colors_get_LavenderBlush), nullptr, nullptr, nullptr },
        { "lawn_green", reinterpret_cast<getter>(Colors_get_LawnGreen), nullptr, nullptr, nullptr },
        { "lemon_chiffon", reinterpret_cast<getter>(Colors_get_LemonChiffon), nullptr, nullptr, nullptr },
        { "light_blue", reinterpret_cast<getter>(Colors_get_LightBlue), nullptr, nullptr, nullptr },
        { "light_coral", reinterpret_cast<getter>(Colors_get_LightCoral), nullptr, nullptr, nullptr },
        { "light_cyan", reinterpret_cast<getter>(Colors_get_LightCyan), nullptr, nullptr, nullptr },
        { "light_goldenrod_yellow", reinterpret_cast<getter>(Colors_get_LightGoldenrodYellow), nullptr, nullptr, nullptr },
        { "light_gray", reinterpret_cast<getter>(Colors_get_LightGray), nullptr, nullptr, nullptr },
        { "light_green", reinterpret_cast<getter>(Colors_get_LightGreen), nullptr, nullptr, nullptr },
        { "light_pink", reinterpret_cast<getter>(Colors_get_LightPink), nullptr, nullptr, nullptr },
        { "light_salmon", reinterpret_cast<getter>(Colors_get_LightSalmon), nullptr, nullptr, nullptr },
        { "light_sea_green", reinterpret_cast<getter>(Colors_get_LightSeaGreen), nullptr, nullptr, nullptr },
        { "light_sky_blue", reinterpret_cast<getter>(Colors_get_LightSkyBlue), nullptr, nullptr, nullptr },
        { "light_slate_gray", reinterpret_cast<getter>(Colors_get_LightSlateGray), nullptr, nullptr, nullptr },
        { "light_steel_blue", reinterpret_cast<getter>(Colors_get_LightSteelBlue), nullptr, nullptr, nullptr },
        { "light_yellow", reinterpret_cast<getter>(Colors_get_LightYellow), nullptr, nullptr, nullptr },
        { "lime", reinterpret_cast<getter>(Colors_get_Lime), nullptr, nullptr, nullptr },
        { "lime_green", reinterpret_cast<getter>(Colors_get_LimeGreen), nullptr, nullptr, nullptr },
        { "linen", reinterpret_cast<getter>(Colors_get_Linen), nullptr, nullptr, nullptr },
        { "magenta", reinterpret_cast<getter>(Colors_get_Magenta), nullptr, nullptr, nullptr },
        { "maroon", reinterpret_cast<getter>(Colors_get_Maroon), nullptr, nullptr, nullptr },
        { "medium_aquamarine", reinterpret_cast<getter>(Colors_get_MediumAquamarine), nullptr, nullptr, nullptr },
        { "medium_blue", reinterpret_cast<getter>(Colors_get_MediumBlue), nullptr, nullptr, nullptr },
        { "medium_orchid", reinterpret_cast<getter>(Colors_get_MediumOrchid), nullptr, nullptr, nullptr },
        { "medium_purple", reinterpret_cast<getter>(Colors_get_MediumPurple), nullptr, nullptr, nullptr },
        { "medium_sea_green", reinterpret_cast<getter>(Colors_get_MediumSeaGreen), nullptr, nullptr, nullptr },
        { "medium_slate_blue", reinterpret_cast<getter>(Colors_get_MediumSlateBlue), nullptr, nullptr, nullptr },
        { "medium_spring_green", reinterpret_cast<getter>(Colors_get_MediumSpringGreen), nullptr, nullptr, nullptr },
        { "medium_turquoise", reinterpret_cast<getter>(Colors_get_MediumTurquoise), nullptr, nullptr, nullptr },
        { "medium_violet_red", reinterpret_cast<getter>(Colors_get_MediumVioletRed), nullptr, nullptr, nullptr },
        { "midnight_blue", reinterpret_cast<getter>(Colors_get_MidnightBlue), nullptr, nullptr, nullptr },
        { "mint_cream", reinterpret_cast<getter>(Colors_get_MintCream), nullptr, nullptr, nullptr },
        { "misty_rose", reinterpret_cast<getter>(Colors_get_MistyRose), nullptr, nullptr, nullptr },
        { "moccasin", reinterpret_cast<getter>(Colors_get_Moccasin), nullptr, nullptr, nullptr },
        { "navajo_white", reinterpret_cast<getter>(Colors_get_NavajoWhite), nullptr, nullptr, nullptr },
        { "navy", reinterpret_cast<getter>(Colors_get_Navy), nullptr, nullptr, nullptr },
        { "old_lace", reinterpret_cast<getter>(Colors_get_OldLace), nullptr, nullptr, nullptr },
        { "olive", reinterpret_cast<getter>(Colors_get_Olive), nullptr, nullptr, nullptr },
        { "olive_drab", reinterpret_cast<getter>(Colors_get_OliveDrab), nullptr, nullptr, nullptr },
        { "orange", reinterpret_cast<getter>(Colors_get_Orange), nullptr, nullptr, nullptr },
        { "orange_red", reinterpret_cast<getter>(Colors_get_OrangeRed), nullptr, nullptr, nullptr },
        { "orchid", reinterpret_cast<getter>(Colors_get_Orchid), nullptr, nullptr, nullptr },
        { "pale_goldenrod", reinterpret_cast<getter>(Colors_get_PaleGoldenrod), nullptr, nullptr, nullptr },
        { "pale_green", reinterpret_cast<getter>(Colors_get_PaleGreen), nullptr, nullptr, nullptr },
        { "pale_turquoise", reinterpret_cast<getter>(Colors_get_PaleTurquoise), nullptr, nullptr, nullptr },
        { "pale_violet_red", reinterpret_cast<getter>(Colors_get_PaleVioletRed), nullptr, nullptr, nullptr },
        { "papaya_whip", reinterpret_cast<getter>(Colors_get_PapayaWhip), nullptr, nullptr, nullptr },
        { "peach_puff", reinterpret_cast<getter>(Colors_get_PeachPuff), nullptr, nullptr, nullptr },
        { "peru", reinterpret_cast<getter>(Colors_get_Peru), nullptr, nullptr, nullptr },
        { "pink", reinterpret_cast<getter>(Colors_get_Pink), nullptr, nullptr, nullptr },
        { "plum", reinterpret_cast<getter>(Colors_get_Plum), nullptr, nullptr, nullptr },
        { "powder_blue", reinterpret_cast<getter>(Colors_get_PowderBlue), nullptr, nullptr, nullptr },
        { "purple", reinterpret_cast<getter>(Colors_get_Purple), nullptr, nullptr, nullptr },
        { "red", reinterpret_cast<getter>(Colors_get_Red), nullptr, nullptr, nullptr },
        { "rosy_brown", reinterpret_cast<getter>(Colors_get_RosyBrown), nullptr, nullptr, nullptr },
        { "royal_blue", reinterpret_cast<getter>(Colors_get_RoyalBlue), nullptr, nullptr, nullptr },
        { "saddle_brown", reinterpret_cast<getter>(Colors_get_SaddleBrown), nullptr, nullptr, nullptr },
        { "salmon", reinterpret_cast<getter>(Colors_get_Salmon), nullptr, nullptr, nullptr },
        { "sandy_brown", reinterpret_cast<getter>(Colors_get_SandyBrown), nullptr, nullptr, nullptr },
        { "sea_green", reinterpret_cast<getter>(Colors_get_SeaGreen), nullptr, nullptr, nullptr },
        { "sea_shell", reinterpret_cast<getter>(Colors_get_SeaShell), nullptr, nullptr, nullptr },
        { "sienna", reinterpret_cast<getter>(Colors_get_Sienna), nullptr, nullptr, nullptr },
        { "silver", reinterpret_cast<getter>(Colors_get_Silver), nullptr, nullptr, nullptr },
        { "sky_blue", reinterpret_cast<getter>(Colors_get_SkyBlue), nullptr, nullptr, nullptr },
        { "slate_blue", reinterpret_cast<getter>(Colors_get_SlateBlue), nullptr, nullptr, nullptr },
        { "slate_gray", reinterpret_cast<getter>(Colors_get_SlateGray), nullptr, nullptr, nullptr },
        { "snow", reinterpret_cast<getter>(Colors_get_Snow), nullptr, nullptr, nullptr },
        { "spring_green", reinterpret_cast<getter>(Colors_get_SpringGreen), nullptr, nullptr, nullptr },
        { "steel_blue", reinterpret_cast<getter>(Colors_get_SteelBlue), nullptr, nullptr, nullptr },
        { "tan", reinterpret_cast<getter>(Colors_get_Tan), nullptr, nullptr, nullptr },
        { "teal", reinterpret_cast<getter>(Colors_get_Teal), nullptr, nullptr, nullptr },
        { "thistle", reinterpret_cast<getter>(Colors_get_Thistle), nullptr, nullptr, nullptr },
        { "tomato", reinterpret_cast<getter>(Colors_get_Tomato), nullptr, nullptr, nullptr },
        { "transparent", reinterpret_cast<getter>(Colors_get_Transparent), nullptr, nullptr, nullptr },
        { "turquoise", reinterpret_cast<getter>(Colors_get_Turquoise), nullptr, nullptr, nullptr },
        { "violet", reinterpret_cast<getter>(Colors_get_Violet), nullptr, nullptr, nullptr },
        { "wheat", reinterpret_cast<getter>(Colors_get_Wheat), nullptr, nullptr, nullptr },
        { "white", reinterpret_cast<getter>(Colors_get_White), nullptr, nullptr, nullptr },
        { "white_smoke", reinterpret_cast<getter>(Colors_get_WhiteSmoke), nullptr, nullptr, nullptr },
        { "yellow", reinterpret_cast<getter>(Colors_get_Yellow), nullptr, nullptr, nullptr },
        { "yellow_green", reinterpret_cast<getter>(Colors_get_YellowGreen), nullptr, nullptr, nullptr },
        { }};

    static PyMethodDef methods_Colors_Static[] = {
        { }};

    static PyType_Slot type_slots_Colors_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_Colors_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_Colors_Static) },
        { }
    };

    static PyType_Spec type_spec_Colors_Static = {
        "winrt._winrt_windows_ui.Colors_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_Colors_Static};

    // ----- UIContentRoot class --------------------

    static PyObject* _new_UIContentRoot(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::UIContentRoot>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::UIContentRoot>::type_name);
        return nullptr;
    }

    static void _dealloc_UIContentRoot(py::wrapper::Windows::UI::UIContentRoot* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* UIContentRoot_get_UIContext(py::wrapper::Windows::UI::UIContentRoot* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.UIContentRoot", L"UIContext");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.UIContext();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_UIContentRoot(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::UIContentRoot>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_UIContentRoot(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::UIContentRoot>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_UIContentRoot[] = {
        { "_assign_array_", _assign_array_UIContentRoot, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_UIContentRoot), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_UIContentRoot[] = {
        { "ui_context", reinterpret_cast<getter>(UIContentRoot_get_UIContext), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_UIContentRoot[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_UIContentRoot) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_UIContentRoot) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_UIContentRoot) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_UIContentRoot) },
        { }};

    static PyType_Spec type_spec_UIContentRoot = {
        "winrt._winrt_windows_ui.UIContentRoot",
        sizeof(py::wrapper::Windows::UI::UIContentRoot),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_UIContentRoot};

    // ----- UIContext class --------------------

    static PyObject* _new_UIContext(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::UIContext>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::UIContext>::type_name);
        return nullptr;
    }

    static void _dealloc_UIContext(py::wrapper::Windows::UI::UIContext* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_UIContext(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::UIContext>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_UIContext(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::UIContext>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_UIContext[] = {
        { "_assign_array_", _assign_array_UIContext, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_UIContext), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_UIContext[] = {
        { }};

    static PyType_Slot _type_slots_UIContext[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_UIContext) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_UIContext) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_UIContext) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_UIContext) },
        { }};

    static PyType_Spec type_spec_UIContext = {
        "winrt._winrt_windows_ui.UIContext",
        sizeof(py::wrapper::Windows::UI::UIContext),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_UIContext};

    // ----- Color struct --------------------

    winrt::Windows::UI::Color Color_from_tuple(PyObject* tuple)
    {
        if (PyTuple_GET_SIZE(tuple) != 4)
        {
            PyErr_SetString(PyExc_TypeError, "Incorrect number of fields");
            throw python_exception();
        }

        winrt::Windows::UI::Color result{};

        result.A = py::convert_to<uint8_t>(tuple, 0);
        result.R = py::convert_to<uint8_t>(tuple, 1);
        result.G = py::convert_to<uint8_t>(tuple, 2);
        result.B = py::convert_to<uint8_t>(tuple, 3);

        return result;
    }

    PyObject* _new_Color(PyTypeObject* subclass, PyObject* args, PyObject* kwds) noexcept
    {
        pyobj_handle self_obj{(subclass->tp_alloc(subclass, 0))};
        if (!self_obj)
        {
            return nullptr;
        }

        auto self = reinterpret_cast<winrt_struct_wrapper<winrt::Windows::UI::Color>*>(self_obj.get());
        std::construct_at(&self->obj);

        auto tuple_size = PyTuple_GET_SIZE(args);
        if ((tuple_size == 0) && (!kwds))
        {
            return self_obj.detach();
        }

        uint8_t _A{};
        uint8_t _R{};
        uint8_t _G{};
        uint8_t _B{};

        static const char* kwlist[] = {"a", "r", "g", "b", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "|BBBB", const_cast<char**>(kwlist), &_A, &_R, &_G, &_B))
        {
            return nullptr;
        }

        try
        {
            self->obj.A = _A;
            self->obj.R = _R;
            self->obj.G = _G;
            self->obj.B = _B;

            return self_obj.detach();
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static void _dealloc_Color(py::wrapper::Windows::UI::Color* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_Color(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Color>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    PyObject* _replace_Color(py::wrapper::Windows::UI::Color* self, PyObject* args, PyObject* kwds) noexcept
    {
        try
        {
            uint8_t _A{self->obj.A};
            uint8_t _R{self->obj.R};
            uint8_t _G{self->obj.G};
            uint8_t _B{self->obj.B};

            static const char* kwlist[] = {"a", "r", "g", "b", nullptr};
            if (!PyArg_ParseTupleAndKeywords(args, kwds, "|$BBBB", const_cast<char**>(kwlist), &_A, &_R, &_G, &_B))
            {
                return nullptr;
            }

            auto copy = self->obj;
            copy.A = _A;
            copy.R = _R;
            copy.G = _G;
            copy.B = _B;

            return convert(copy);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    PyObject* unpack_Color(py::wrapper::Windows::UI::Color* self, PyObject* /*unused*/) noexcept
    {
        py::pyobj_handle A{convert(self->obj.A)};
        if (!A)
        {
            return nullptr;
        }

        py::pyobj_handle R{convert(self->obj.R)};
        if (!R)
        {
            return nullptr;
        }

        py::pyobj_handle G{convert(self->obj.G)};
        if (!G)
        {
            return nullptr;
        }

        py::pyobj_handle B{convert(self->obj.B)};
        if (!B)
        {
            return nullptr;
        }

        pyobj_handle tuple{PyTuple_New(4)};
        if (!tuple)
        {
            return nullptr;
        }

        PyTuple_SET_ITEM(tuple.get(), 0, A.detach());
        PyTuple_SET_ITEM(tuple.get(), 1, R.detach());
        PyTuple_SET_ITEM(tuple.get(), 2, G.detach());
        PyTuple_SET_ITEM(tuple.get(), 3, B.detach());

        return tuple.detach();
    }

    static PyMethodDef _methods_Color[] = {
        { "_assign_array_", _assign_array_Color, METH_O | METH_STATIC, nullptr },
        { "__replace__", reinterpret_cast<PyCFunction>(reinterpret_cast<void*>(_replace_Color)), METH_VARARGS | METH_KEYWORDS, nullptr },
        { "unpack", reinterpret_cast<PyCFunction>(unpack_Color), METH_NOARGS, nullptr },
        { }};

    static PyObject* Color_get_A(py::wrapper::Windows::UI::Color* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.A);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Color_get_R(py::wrapper::Windows::UI::Color* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.R);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Color_get_G(py::wrapper::Windows::UI::Color* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.G);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Color_get_B(py::wrapper::Windows::UI::Color* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.B);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyGetSetDef _getset_Color[] = {
        { "a", reinterpret_cast<getter>(Color_get_A), nullptr, nullptr, nullptr },
        { "r", reinterpret_cast<getter>(Color_get_R), nullptr, nullptr, nullptr },
        { "g", reinterpret_cast<getter>(Color_get_G), nullptr, nullptr, nullptr },
        { "b", reinterpret_cast<getter>(Color_get_B), nullptr, nullptr, nullptr },
        { }};

    static PyObject* _richcompare_Color(py::wrapper::Windows::UI::Color* self, PyObject* other, int op) noexcept
    {
        try
        {
            auto _other = py::convert_to<winrt::Windows::UI::Color>(other);

            if (op == Py_EQ)
            {
                if (self->obj == _other)
                {
                    Py_RETURN_TRUE;
                }

                Py_RETURN_FALSE;
            }

            if (op == Py_NE)
            {
                if (self->obj != _other)
                {
                    Py_RETURN_TRUE;
                }

                Py_RETURN_FALSE;
            }

            Py_RETURN_NOTIMPLEMENTED;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _repr_Color(PyObject* self) noexcept
    {
        py::pyobj_handle A{PyObject_GetAttrString(self, "a")};
        if (!A)
        {
            return nullptr;
        }

        py::pyobj_handle R{PyObject_GetAttrString(self, "r")};
        if (!R)
        {
            return nullptr;
        }

        py::pyobj_handle G{PyObject_GetAttrString(self, "g")};
        if (!G)
        {
            return nullptr;
        }

        py::pyobj_handle B{PyObject_GetAttrString(self, "b")};
        if (!B)
        {
            return nullptr;
        }

        return PyUnicode_FromFormat("Color(a=%R, r=%R, g=%R, b=%R)", A.get(), R.get(), G.get(), B.get());
    }

    static PyType_Slot _type_slots_Color[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_Color) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_Color) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_Color) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_Color) },
        { Py_tp_richcompare, reinterpret_cast<void*>(_richcompare_Color) },
        { Py_tp_repr, reinterpret_cast<void*>(_repr_Color) },
        { }};

    static PyType_Spec type_spec_Color = {
        "winrt._winrt_windows_ui.Color",
        sizeof(py::wrapper::Windows::UI::Color),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_Color};

    // ----- WindowId struct --------------------

    winrt::Windows::UI::WindowId WindowId_from_tuple(PyObject* tuple)
    {
        if (PyTuple_GET_SIZE(tuple) != 1)
        {
            PyErr_SetString(PyExc_TypeError, "Incorrect number of fields");
            throw python_exception();
        }

        winrt::Windows::UI::WindowId result{};

        result.Value = py::convert_to<uint64_t>(tuple, 0);

        return result;
    }

    PyObject* _new_WindowId(PyTypeObject* subclass, PyObject* args, PyObject* kwds) noexcept
    {
        pyobj_handle self_obj{(subclass->tp_alloc(subclass, 0))};
        if (!self_obj)
        {
            return nullptr;
        }

        auto self = reinterpret_cast<winrt_struct_wrapper<winrt::Windows::UI::WindowId>*>(self_obj.get());
        std::construct_at(&self->obj);

        auto tuple_size = PyTuple_GET_SIZE(args);
        if ((tuple_size == 0) && (!kwds))
        {
            return self_obj.detach();
        }

        uint64_t _Value{};

        static const char* kwlist[] = {"value", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "|K", const_cast<char**>(kwlist), &_Value))
        {
            return nullptr;
        }

        try
        {
            self->obj.Value = _Value;

            return self_obj.detach();
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static void _dealloc_WindowId(py::wrapper::Windows::UI::WindowId* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_WindowId(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::WindowId>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    PyObject* _replace_WindowId(py::wrapper::Windows::UI::WindowId* self, PyObject* args, PyObject* kwds) noexcept
    {
        try
        {
            uint64_t _Value{self->obj.Value};

            static const char* kwlist[] = {"value", nullptr};
            if (!PyArg_ParseTupleAndKeywords(args, kwds, "|$K", const_cast<char**>(kwlist), &_Value))
            {
                return nullptr;
            }

            auto copy = self->obj;
            copy.Value = _Value;

            return convert(copy);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WindowId[] = {
        { "_assign_array_", _assign_array_WindowId, METH_O | METH_STATIC, nullptr },
        { "__replace__", reinterpret_cast<PyCFunction>(reinterpret_cast<void*>(_replace_WindowId)), METH_VARARGS | METH_KEYWORDS, nullptr },
        { }};

    static PyObject* WindowId_get_Value(py::wrapper::Windows::UI::WindowId* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Value);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyGetSetDef _getset_WindowId[] = {
        { "value", reinterpret_cast<getter>(WindowId_get_Value), nullptr, nullptr, nullptr },
        { }};

    static PyObject* _richcompare_WindowId(py::wrapper::Windows::UI::WindowId* self, PyObject* other, int op) noexcept
    {
        try
        {
            auto _other = py::convert_to<winrt::Windows::UI::WindowId>(other);

            if (op == Py_EQ)
            {
                if (self->obj == _other)
                {
                    Py_RETURN_TRUE;
                }

                Py_RETURN_FALSE;
            }

            if (op == Py_NE)
            {
                if (self->obj != _other)
                {
                    Py_RETURN_TRUE;
                }

                Py_RETURN_FALSE;
            }

            Py_RETURN_NOTIMPLEMENTED;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _repr_WindowId(PyObject* self) noexcept
    {
        py::pyobj_handle Value{PyObject_GetAttrString(self, "value")};
        if (!Value)
        {
            return nullptr;
        }

        return PyUnicode_FromFormat("WindowId(value=%R)", Value.get());
    }

    static PyType_Slot _type_slots_WindowId[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_WindowId) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_WindowId) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_WindowId) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_WindowId) },
        { Py_tp_richcompare, reinterpret_cast<void*>(_richcompare_WindowId) },
        { Py_tp_repr, reinterpret_cast<void*>(_repr_WindowId) },
        { }};

    static PyType_Spec type_spec_WindowId = {
        "winrt._winrt_windows_ui.WindowId",
        sizeof(py::wrapper::Windows::UI::WindowId),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WindowId};

    // ----- Windows.UI Initialization --------------------

    PyDoc_STRVAR(module_doc, "Windows.UI");

    static PyModuleDef module_def = {
        PyModuleDef_HEAD_INIT,
        "_winrt_windows_ui",
        module_doc,
        0,
        nullptr,
        nullptr,
        nullptr,
        nullptr,
        nullptr};
} // py::cpp::Windows::UI

PyMODINIT_FUNC PyInit__winrt_windows_ui(void) noexcept
{
    using namespace py::cpp::Windows::UI;

    if (py::import_winrt_runtime() == -1)
    {
        return nullptr;
    }

    py::pyobj_handle module{PyModule_Create(&module_def)};

    if (!module)
    {
        return nullptr;
    }

    auto inspectable_meta_type = py::get_inspectable_meta_type();
    if (!inspectable_meta_type)
    {
        return nullptr;
    }

    auto object_type = py::get_object_type();
    if (!object_type)
    {
        return nullptr;
    }

    py::pyobj_handle object_bases{PyTuple_Pack(1, object_type)};

    if (!object_bases)
    {
        return nullptr;
    }

    py::pyobj_handle ColorHelper_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(inspectable_meta_type))};
    if (!ColorHelper_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_ColorHelper_Static{PyType_FromSpecWithBases(&type_spec_ColorHelper_Static, ColorHelper_Static_bases.get())};
    if (!type_ColorHelper_Static)
    {
        return nullptr;
    }

    py::pytype_handle ColorHelper_type{py::register_python_type(module.get(), &type_spec_ColorHelper, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_ColorHelper_Static.get()))};
    if (!ColorHelper_type)
    {
        return nullptr;
    }

    py::pyobj_handle Colors_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(inspectable_meta_type))};
    if (!Colors_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_Colors_Static{PyType_FromSpecWithBases(&type_spec_Colors_Static, Colors_Static_bases.get())};
    if (!type_Colors_Static)
    {
        return nullptr;
    }

    py::pytype_handle Colors_type{py::register_python_type(module.get(), &type_spec_Colors, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_Colors_Static.get()))};
    if (!Colors_type)
    {
        return nullptr;
    }

    py::pytype_handle UIContentRoot_type{py::register_python_type(module.get(), &type_spec_UIContentRoot, object_bases.get(), inspectable_meta_type)};
    if (!UIContentRoot_type)
    {
        return nullptr;
    }

    py::pytype_handle UIContext_type{py::register_python_type(module.get(), &type_spec_UIContext, object_bases.get(), inspectable_meta_type)};
    if (!UIContext_type)
    {
        return nullptr;
    }

    py::pytype_handle Color_type{py::register_python_type(module.get(), &type_spec_Color, nullptr, nullptr)};
    if (!Color_type)
    {
        return nullptr;
    }

    py::pyobj_handle Color_from_tuple_capsule{PyCapsule_New(reinterpret_cast<void*>(Color_from_tuple),"winrt._winrt_windows_ui.Color_from_tuple", nullptr)};
    if (!Color_from_tuple_capsule)
    {
        return nullptr;
    }

    if (PyModule_AddObjectRef(module.get(), "Color_from_tuple", Color_from_tuple_capsule.get()) == -1)
    {
        return nullptr;
    }
    py::pytype_handle WindowId_type{py::register_python_type(module.get(), &type_spec_WindowId, nullptr, nullptr)};
    if (!WindowId_type)
    {
        return nullptr;
    }

    py::pyobj_handle WindowId_from_tuple_capsule{PyCapsule_New(reinterpret_cast<void*>(WindowId_from_tuple),"winrt._winrt_windows_ui.WindowId_from_tuple", nullptr)};
    if (!WindowId_from_tuple_capsule)
    {
        return nullptr;
    }

    if (PyModule_AddObjectRef(module.get(), "WindowId_from_tuple", WindowId_from_tuple_capsule.get()) == -1)
    {
        return nullptr;
    }

    return module.detach();
}
