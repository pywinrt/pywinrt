// WARNING: Please don't edit this file. It was generated by Python/WinRT v3.2.1

#include "py.Windows.UI.ViewManagement.Core.h"

namespace py::cpp::Windows::UI::ViewManagement::Core
{
    // ----- CoreFrameworkInputView class --------------------

    static PyObject* _new_CoreFrameworkInputView(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::ViewManagement::Core::CoreFrameworkInputView>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::ViewManagement::Core::CoreFrameworkInputView>::type_name);
        return nullptr;
    }

    static void _dealloc_CoreFrameworkInputView(py::wrapper::Windows::UI::ViewManagement::Core::CoreFrameworkInputView* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CoreFrameworkInputView_GetForCurrentView(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.ViewManagement.Core.CoreFrameworkInputView", L"GetForCurrentView", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::UI::ViewManagement::Core::CoreFrameworkInputView::GetForCurrentView();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CoreFrameworkInputView_GetForUIContext(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.ViewManagement.Core.CoreFrameworkInputView", L"GetForUIContext", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::UIContext>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::UI::ViewManagement::Core::CoreFrameworkInputView::GetForUIContext(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CoreFrameworkInputView_add_OcclusionsChanged(py::wrapper::Windows::UI::ViewManagement::Core::CoreFrameworkInputView* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.ViewManagement.Core.CoreFrameworkInputView", L"OcclusionsChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::ViewManagement::Core::CoreFrameworkInputView, winrt::Windows::UI::ViewManagement::Core::CoreFrameworkInputViewOcclusionsChangedEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.OcclusionsChanged(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreFrameworkInputView_remove_OcclusionsChanged(py::wrapper::Windows::UI::ViewManagement::Core::CoreFrameworkInputView* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.ViewManagement.Core.CoreFrameworkInputView", L"OcclusionsChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.OcclusionsChanged(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreFrameworkInputView_add_PrimaryViewAnimationStarting(py::wrapper::Windows::UI::ViewManagement::Core::CoreFrameworkInputView* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.ViewManagement.Core.CoreFrameworkInputView", L"PrimaryViewAnimationStarting");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::ViewManagement::Core::CoreFrameworkInputView, winrt::Windows::UI::ViewManagement::Core::CoreFrameworkInputViewAnimationStartingEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PrimaryViewAnimationStarting(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreFrameworkInputView_remove_PrimaryViewAnimationStarting(py::wrapper::Windows::UI::ViewManagement::Core::CoreFrameworkInputView* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.ViewManagement.Core.CoreFrameworkInputView", L"PrimaryViewAnimationStarting");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.PrimaryViewAnimationStarting(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CoreFrameworkInputView(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::ViewManagement::Core::CoreFrameworkInputView>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CoreFrameworkInputView(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::ViewManagement::Core::CoreFrameworkInputView>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CoreFrameworkInputView[] = {
        { "add_occlusions_changed", reinterpret_cast<PyCFunction>(CoreFrameworkInputView_add_OcclusionsChanged), METH_O, nullptr },
        { "remove_occlusions_changed", reinterpret_cast<PyCFunction>(CoreFrameworkInputView_remove_OcclusionsChanged), METH_O, nullptr },
        { "add_primary_view_animation_starting", reinterpret_cast<PyCFunction>(CoreFrameworkInputView_add_PrimaryViewAnimationStarting), METH_O, nullptr },
        { "remove_primary_view_animation_starting", reinterpret_cast<PyCFunction>(CoreFrameworkInputView_remove_PrimaryViewAnimationStarting), METH_O, nullptr },
        { "_assign_array_", _assign_array_CoreFrameworkInputView, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CoreFrameworkInputView), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_CoreFrameworkInputView[] = {
        { }};

    static PyType_Slot _type_slots_CoreFrameworkInputView[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_CoreFrameworkInputView) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CoreFrameworkInputView) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CoreFrameworkInputView) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CoreFrameworkInputView) },
        { }};

    static PyType_Spec type_spec_CoreFrameworkInputView = {
        "winrt._winrt_windows_ui_viewmanagement_core.CoreFrameworkInputView",
        sizeof(py::wrapper::Windows::UI::ViewManagement::Core::CoreFrameworkInputView),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CoreFrameworkInputView};

    static PyGetSetDef getset_CoreFrameworkInputView_Static[] = {
        { }};

    static PyMethodDef methods_CoreFrameworkInputView_Static[] = {
        { "get_for_current_view", reinterpret_cast<PyCFunction>(CoreFrameworkInputView_GetForCurrentView), METH_VARARGS, nullptr },
        { "get_for_ui_context", reinterpret_cast<PyCFunction>(CoreFrameworkInputView_GetForUIContext), METH_VARARGS, nullptr },
        { }};

    static PyType_Slot type_slots_CoreFrameworkInputView_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_CoreFrameworkInputView_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_CoreFrameworkInputView_Static) },
        { }
    };

    static PyType_Spec type_spec_CoreFrameworkInputView_Static = {
        "winrt._winrt_windows_ui_viewmanagement_core.CoreFrameworkInputView_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_CoreFrameworkInputView_Static};

    // ----- CoreFrameworkInputViewAnimationStartingEventArgs class --------------------

    static PyObject* _new_CoreFrameworkInputViewAnimationStartingEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::ViewManagement::Core::CoreFrameworkInputViewAnimationStartingEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::ViewManagement::Core::CoreFrameworkInputViewAnimationStartingEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_CoreFrameworkInputViewAnimationStartingEventArgs(py::wrapper::Windows::UI::ViewManagement::Core::CoreFrameworkInputViewAnimationStartingEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CoreFrameworkInputViewAnimationStartingEventArgs_get_AnimationDuration(py::wrapper::Windows::UI::ViewManagement::Core::CoreFrameworkInputViewAnimationStartingEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.ViewManagement.Core.CoreFrameworkInputViewAnimationStartingEventArgs", L"AnimationDuration");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.AnimationDuration();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreFrameworkInputViewAnimationStartingEventArgs_get_FrameworkAnimationRecommended(py::wrapper::Windows::UI::ViewManagement::Core::CoreFrameworkInputViewAnimationStartingEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.ViewManagement.Core.CoreFrameworkInputViewAnimationStartingEventArgs", L"FrameworkAnimationRecommended");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.FrameworkAnimationRecommended();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreFrameworkInputViewAnimationStartingEventArgs_get_Occlusions(py::wrapper::Windows::UI::ViewManagement::Core::CoreFrameworkInputViewAnimationStartingEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.ViewManagement.Core.CoreFrameworkInputViewAnimationStartingEventArgs", L"Occlusions");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Occlusions();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CoreFrameworkInputViewAnimationStartingEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::ViewManagement::Core::CoreFrameworkInputViewAnimationStartingEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CoreFrameworkInputViewAnimationStartingEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::ViewManagement::Core::CoreFrameworkInputViewAnimationStartingEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CoreFrameworkInputViewAnimationStartingEventArgs[] = {
        { "_assign_array_", _assign_array_CoreFrameworkInputViewAnimationStartingEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CoreFrameworkInputViewAnimationStartingEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_CoreFrameworkInputViewAnimationStartingEventArgs[] = {
        { "animation_duration", reinterpret_cast<getter>(CoreFrameworkInputViewAnimationStartingEventArgs_get_AnimationDuration), nullptr, nullptr, nullptr },
        { "framework_animation_recommended", reinterpret_cast<getter>(CoreFrameworkInputViewAnimationStartingEventArgs_get_FrameworkAnimationRecommended), nullptr, nullptr, nullptr },
        { "occlusions", reinterpret_cast<getter>(CoreFrameworkInputViewAnimationStartingEventArgs_get_Occlusions), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_CoreFrameworkInputViewAnimationStartingEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_CoreFrameworkInputViewAnimationStartingEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CoreFrameworkInputViewAnimationStartingEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CoreFrameworkInputViewAnimationStartingEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CoreFrameworkInputViewAnimationStartingEventArgs) },
        { }};

    static PyType_Spec type_spec_CoreFrameworkInputViewAnimationStartingEventArgs = {
        "winrt._winrt_windows_ui_viewmanagement_core.CoreFrameworkInputViewAnimationStartingEventArgs",
        sizeof(py::wrapper::Windows::UI::ViewManagement::Core::CoreFrameworkInputViewAnimationStartingEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CoreFrameworkInputViewAnimationStartingEventArgs};

    // ----- CoreFrameworkInputViewOcclusionsChangedEventArgs class --------------------

    static PyObject* _new_CoreFrameworkInputViewOcclusionsChangedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::ViewManagement::Core::CoreFrameworkInputViewOcclusionsChangedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::ViewManagement::Core::CoreFrameworkInputViewOcclusionsChangedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_CoreFrameworkInputViewOcclusionsChangedEventArgs(py::wrapper::Windows::UI::ViewManagement::Core::CoreFrameworkInputViewOcclusionsChangedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CoreFrameworkInputViewOcclusionsChangedEventArgs_get_Handled(py::wrapper::Windows::UI::ViewManagement::Core::CoreFrameworkInputViewOcclusionsChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.ViewManagement.Core.CoreFrameworkInputViewOcclusionsChangedEventArgs", L"Handled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Handled();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreFrameworkInputViewOcclusionsChangedEventArgs_get_Occlusions(py::wrapper::Windows::UI::ViewManagement::Core::CoreFrameworkInputViewOcclusionsChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.ViewManagement.Core.CoreFrameworkInputViewOcclusionsChangedEventArgs", L"Occlusions");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Occlusions();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CoreFrameworkInputViewOcclusionsChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::ViewManagement::Core::CoreFrameworkInputViewOcclusionsChangedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CoreFrameworkInputViewOcclusionsChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::ViewManagement::Core::CoreFrameworkInputViewOcclusionsChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CoreFrameworkInputViewOcclusionsChangedEventArgs[] = {
        { "_assign_array_", _assign_array_CoreFrameworkInputViewOcclusionsChangedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CoreFrameworkInputViewOcclusionsChangedEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_CoreFrameworkInputViewOcclusionsChangedEventArgs[] = {
        { "handled", reinterpret_cast<getter>(CoreFrameworkInputViewOcclusionsChangedEventArgs_get_Handled), nullptr, nullptr, nullptr },
        { "occlusions", reinterpret_cast<getter>(CoreFrameworkInputViewOcclusionsChangedEventArgs_get_Occlusions), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_CoreFrameworkInputViewOcclusionsChangedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_CoreFrameworkInputViewOcclusionsChangedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CoreFrameworkInputViewOcclusionsChangedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CoreFrameworkInputViewOcclusionsChangedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CoreFrameworkInputViewOcclusionsChangedEventArgs) },
        { }};

    static PyType_Spec type_spec_CoreFrameworkInputViewOcclusionsChangedEventArgs = {
        "winrt._winrt_windows_ui_viewmanagement_core.CoreFrameworkInputViewOcclusionsChangedEventArgs",
        sizeof(py::wrapper::Windows::UI::ViewManagement::Core::CoreFrameworkInputViewOcclusionsChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CoreFrameworkInputViewOcclusionsChangedEventArgs};

    // ----- CoreInputView class --------------------

    static PyObject* _new_CoreInputView(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::ViewManagement::Core::CoreInputView>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::ViewManagement::Core::CoreInputView>::type_name);
        return nullptr;
    }

    static void _dealloc_CoreInputView(py::wrapper::Windows::UI::ViewManagement::Core::CoreInputView* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CoreInputView_GetCoreInputViewOcclusions(py::wrapper::Windows::UI::ViewManagement::Core::CoreInputView* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.ViewManagement.Core.CoreInputView", L"GetCoreInputViewOcclusions", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetCoreInputViewOcclusions();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CoreInputView_GetForCurrentView(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.ViewManagement.Core.CoreInputView", L"GetForCurrentView", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::UI::ViewManagement::Core::CoreInputView::GetForCurrentView();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CoreInputView_GetForUIContext(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.ViewManagement.Core.CoreInputView", L"GetForUIContext", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::UIContext>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::UI::ViewManagement::Core::CoreInputView::GetForUIContext(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CoreInputView_IsKindSupported(py::wrapper::Windows::UI::ViewManagement::Core::CoreInputView* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.ViewManagement.Core.CoreInputView", L"IsKindSupported", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::ViewManagement::Core::CoreInputViewKind>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.IsKindSupported(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CoreInputView_TryHide(py::wrapper::Windows::UI::ViewManagement::Core::CoreInputView* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.ViewManagement.Core.CoreInputView", L"TryHide", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.TryHide();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CoreInputView_TryHidePrimaryView(py::wrapper::Windows::UI::ViewManagement::Core::CoreInputView* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.ViewManagement.Core.CoreInputView", L"TryHidePrimaryView", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.TryHidePrimaryView();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CoreInputView_TryShow(py::wrapper::Windows::UI::ViewManagement::Core::CoreInputView* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.ViewManagement.Core.CoreInputView", L"TryShow", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.TryShow();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CoreInputView_TryShowPrimaryView(py::wrapper::Windows::UI::ViewManagement::Core::CoreInputView* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.ViewManagement.Core.CoreInputView", L"TryShowPrimaryView", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.TryShowPrimaryView();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CoreInputView_TryShowWithKind(py::wrapper::Windows::UI::ViewManagement::Core::CoreInputView* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.ViewManagement.Core.CoreInputView", L"TryShow", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::ViewManagement::Core::CoreInputViewKind>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.TryShow(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CoreInputView_TryTransferXYFocusToPrimaryView(py::wrapper::Windows::UI::ViewManagement::Core::CoreInputView* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.ViewManagement.Core.CoreInputView", L"TryTransferXYFocusToPrimaryView", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Rect>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::ViewManagement::Core::CoreInputViewXYFocusTransferDirection>(args, 1);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.TryTransferXYFocusToPrimaryView(param0, param1);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CoreInputView_add_OcclusionsChanged(py::wrapper::Windows::UI::ViewManagement::Core::CoreInputView* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.ViewManagement.Core.CoreInputView", L"OcclusionsChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::ViewManagement::Core::CoreInputView, winrt::Windows::UI::ViewManagement::Core::CoreInputViewOcclusionsChangedEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.OcclusionsChanged(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreInputView_remove_OcclusionsChanged(py::wrapper::Windows::UI::ViewManagement::Core::CoreInputView* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.ViewManagement.Core.CoreInputView", L"OcclusionsChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.OcclusionsChanged(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreInputView_add_XYFocusTransferredToPrimaryView(py::wrapper::Windows::UI::ViewManagement::Core::CoreInputView* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.ViewManagement.Core.CoreInputView", L"XYFocusTransferredToPrimaryView");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::ViewManagement::Core::CoreInputView, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.XYFocusTransferredToPrimaryView(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreInputView_remove_XYFocusTransferredToPrimaryView(py::wrapper::Windows::UI::ViewManagement::Core::CoreInputView* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.ViewManagement.Core.CoreInputView", L"XYFocusTransferredToPrimaryView");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.XYFocusTransferredToPrimaryView(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreInputView_add_XYFocusTransferringFromPrimaryView(py::wrapper::Windows::UI::ViewManagement::Core::CoreInputView* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.ViewManagement.Core.CoreInputView", L"XYFocusTransferringFromPrimaryView");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::ViewManagement::Core::CoreInputView, winrt::Windows::UI::ViewManagement::Core::CoreInputViewTransferringXYFocusEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.XYFocusTransferringFromPrimaryView(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreInputView_remove_XYFocusTransferringFromPrimaryView(py::wrapper::Windows::UI::ViewManagement::Core::CoreInputView* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.ViewManagement.Core.CoreInputView", L"XYFocusTransferringFromPrimaryView");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.XYFocusTransferringFromPrimaryView(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreInputView_add_PrimaryViewHiding(py::wrapper::Windows::UI::ViewManagement::Core::CoreInputView* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.ViewManagement.Core.CoreInputView", L"PrimaryViewHiding");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::ViewManagement::Core::CoreInputView, winrt::Windows::UI::ViewManagement::Core::CoreInputViewHidingEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PrimaryViewHiding(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreInputView_remove_PrimaryViewHiding(py::wrapper::Windows::UI::ViewManagement::Core::CoreInputView* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.ViewManagement.Core.CoreInputView", L"PrimaryViewHiding");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.PrimaryViewHiding(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreInputView_add_PrimaryViewShowing(py::wrapper::Windows::UI::ViewManagement::Core::CoreInputView* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.ViewManagement.Core.CoreInputView", L"PrimaryViewShowing");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::ViewManagement::Core::CoreInputView, winrt::Windows::UI::ViewManagement::Core::CoreInputViewShowingEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PrimaryViewShowing(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreInputView_remove_PrimaryViewShowing(py::wrapper::Windows::UI::ViewManagement::Core::CoreInputView* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.ViewManagement.Core.CoreInputView", L"PrimaryViewShowing");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.PrimaryViewShowing(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreInputView_add_PrimaryViewAnimationStarting(py::wrapper::Windows::UI::ViewManagement::Core::CoreInputView* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.ViewManagement.Core.CoreInputView", L"PrimaryViewAnimationStarting");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::ViewManagement::Core::CoreInputView, winrt::Windows::UI::ViewManagement::Core::CoreInputViewAnimationStartingEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PrimaryViewAnimationStarting(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreInputView_remove_PrimaryViewAnimationStarting(py::wrapper::Windows::UI::ViewManagement::Core::CoreInputView* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.ViewManagement.Core.CoreInputView", L"PrimaryViewAnimationStarting");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.PrimaryViewAnimationStarting(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreInputView_add_SupportedKindsChanged(py::wrapper::Windows::UI::ViewManagement::Core::CoreInputView* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.ViewManagement.Core.CoreInputView", L"SupportedKindsChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::ViewManagement::Core::CoreInputView, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SupportedKindsChanged(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreInputView_remove_SupportedKindsChanged(py::wrapper::Windows::UI::ViewManagement::Core::CoreInputView* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.ViewManagement.Core.CoreInputView", L"SupportedKindsChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.SupportedKindsChanged(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CoreInputView(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::ViewManagement::Core::CoreInputView>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CoreInputView(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::ViewManagement::Core::CoreInputView>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CoreInputView[] = {
        { "get_core_input_view_occlusions", reinterpret_cast<PyCFunction>(CoreInputView_GetCoreInputViewOcclusions), METH_VARARGS, nullptr },
        { "is_kind_supported", reinterpret_cast<PyCFunction>(CoreInputView_IsKindSupported), METH_VARARGS, nullptr },
        { "try_hide", reinterpret_cast<PyCFunction>(CoreInputView_TryHide), METH_VARARGS, nullptr },
        { "try_hide_primary_view", reinterpret_cast<PyCFunction>(CoreInputView_TryHidePrimaryView), METH_VARARGS, nullptr },
        { "try_show", reinterpret_cast<PyCFunction>(CoreInputView_TryShow), METH_VARARGS, nullptr },
        { "try_show_primary_view", reinterpret_cast<PyCFunction>(CoreInputView_TryShowPrimaryView), METH_VARARGS, nullptr },
        { "try_show_with_kind", reinterpret_cast<PyCFunction>(CoreInputView_TryShowWithKind), METH_VARARGS, nullptr },
        { "try_transfer_x_y_focus_to_primary_view", reinterpret_cast<PyCFunction>(CoreInputView_TryTransferXYFocusToPrimaryView), METH_VARARGS, nullptr },
        { "add_occlusions_changed", reinterpret_cast<PyCFunction>(CoreInputView_add_OcclusionsChanged), METH_O, nullptr },
        { "remove_occlusions_changed", reinterpret_cast<PyCFunction>(CoreInputView_remove_OcclusionsChanged), METH_O, nullptr },
        { "add_x_y_focus_transferred_to_primary_view", reinterpret_cast<PyCFunction>(CoreInputView_add_XYFocusTransferredToPrimaryView), METH_O, nullptr },
        { "remove_x_y_focus_transferred_to_primary_view", reinterpret_cast<PyCFunction>(CoreInputView_remove_XYFocusTransferredToPrimaryView), METH_O, nullptr },
        { "add_x_y_focus_transferring_from_primary_view", reinterpret_cast<PyCFunction>(CoreInputView_add_XYFocusTransferringFromPrimaryView), METH_O, nullptr },
        { "remove_x_y_focus_transferring_from_primary_view", reinterpret_cast<PyCFunction>(CoreInputView_remove_XYFocusTransferringFromPrimaryView), METH_O, nullptr },
        { "add_primary_view_hiding", reinterpret_cast<PyCFunction>(CoreInputView_add_PrimaryViewHiding), METH_O, nullptr },
        { "remove_primary_view_hiding", reinterpret_cast<PyCFunction>(CoreInputView_remove_PrimaryViewHiding), METH_O, nullptr },
        { "add_primary_view_showing", reinterpret_cast<PyCFunction>(CoreInputView_add_PrimaryViewShowing), METH_O, nullptr },
        { "remove_primary_view_showing", reinterpret_cast<PyCFunction>(CoreInputView_remove_PrimaryViewShowing), METH_O, nullptr },
        { "add_primary_view_animation_starting", reinterpret_cast<PyCFunction>(CoreInputView_add_PrimaryViewAnimationStarting), METH_O, nullptr },
        { "remove_primary_view_animation_starting", reinterpret_cast<PyCFunction>(CoreInputView_remove_PrimaryViewAnimationStarting), METH_O, nullptr },
        { "add_supported_kinds_changed", reinterpret_cast<PyCFunction>(CoreInputView_add_SupportedKindsChanged), METH_O, nullptr },
        { "remove_supported_kinds_changed", reinterpret_cast<PyCFunction>(CoreInputView_remove_SupportedKindsChanged), METH_O, nullptr },
        { "_assign_array_", _assign_array_CoreInputView, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CoreInputView), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_CoreInputView[] = {
        { }};

    static PyType_Slot _type_slots_CoreInputView[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_CoreInputView) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CoreInputView) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CoreInputView) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CoreInputView) },
        { }};

    static PyType_Spec type_spec_CoreInputView = {
        "winrt._winrt_windows_ui_viewmanagement_core.CoreInputView",
        sizeof(py::wrapper::Windows::UI::ViewManagement::Core::CoreInputView),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CoreInputView};

    static PyGetSetDef getset_CoreInputView_Static[] = {
        { }};

    static PyMethodDef methods_CoreInputView_Static[] = {
        { "get_for_current_view", reinterpret_cast<PyCFunction>(CoreInputView_GetForCurrentView), METH_VARARGS, nullptr },
        { "get_for_ui_context", reinterpret_cast<PyCFunction>(CoreInputView_GetForUIContext), METH_VARARGS, nullptr },
        { }};

    static PyType_Slot type_slots_CoreInputView_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_CoreInputView_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_CoreInputView_Static) },
        { }
    };

    static PyType_Spec type_spec_CoreInputView_Static = {
        "winrt._winrt_windows_ui_viewmanagement_core.CoreInputView_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_CoreInputView_Static};

    // ----- CoreInputViewAnimationStartingEventArgs class --------------------

    static PyObject* _new_CoreInputViewAnimationStartingEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::ViewManagement::Core::CoreInputViewAnimationStartingEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::ViewManagement::Core::CoreInputViewAnimationStartingEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_CoreInputViewAnimationStartingEventArgs(py::wrapper::Windows::UI::ViewManagement::Core::CoreInputViewAnimationStartingEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CoreInputViewAnimationStartingEventArgs_get_Handled(py::wrapper::Windows::UI::ViewManagement::Core::CoreInputViewAnimationStartingEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.ViewManagement.Core.CoreInputViewAnimationStartingEventArgs", L"Handled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Handled();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CoreInputViewAnimationStartingEventArgs_put_Handled(py::wrapper::Windows::UI::ViewManagement::Core::CoreInputViewAnimationStartingEventArgs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.ViewManagement.Core.CoreInputViewAnimationStartingEventArgs", L"Handled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.Handled(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CoreInputViewAnimationStartingEventArgs_get_AnimationDuration(py::wrapper::Windows::UI::ViewManagement::Core::CoreInputViewAnimationStartingEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.ViewManagement.Core.CoreInputViewAnimationStartingEventArgs", L"AnimationDuration");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.AnimationDuration();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreInputViewAnimationStartingEventArgs_get_Occlusions(py::wrapper::Windows::UI::ViewManagement::Core::CoreInputViewAnimationStartingEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.ViewManagement.Core.CoreInputViewAnimationStartingEventArgs", L"Occlusions");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Occlusions();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CoreInputViewAnimationStartingEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::ViewManagement::Core::CoreInputViewAnimationStartingEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CoreInputViewAnimationStartingEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::ViewManagement::Core::CoreInputViewAnimationStartingEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CoreInputViewAnimationStartingEventArgs[] = {
        { "_assign_array_", _assign_array_CoreInputViewAnimationStartingEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CoreInputViewAnimationStartingEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_CoreInputViewAnimationStartingEventArgs[] = {
        { "handled", reinterpret_cast<getter>(CoreInputViewAnimationStartingEventArgs_get_Handled), reinterpret_cast<setter>(CoreInputViewAnimationStartingEventArgs_put_Handled), nullptr, nullptr },
        { "animation_duration", reinterpret_cast<getter>(CoreInputViewAnimationStartingEventArgs_get_AnimationDuration), nullptr, nullptr, nullptr },
        { "occlusions", reinterpret_cast<getter>(CoreInputViewAnimationStartingEventArgs_get_Occlusions), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_CoreInputViewAnimationStartingEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_CoreInputViewAnimationStartingEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CoreInputViewAnimationStartingEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CoreInputViewAnimationStartingEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CoreInputViewAnimationStartingEventArgs) },
        { }};

    static PyType_Spec type_spec_CoreInputViewAnimationStartingEventArgs = {
        "winrt._winrt_windows_ui_viewmanagement_core.CoreInputViewAnimationStartingEventArgs",
        sizeof(py::wrapper::Windows::UI::ViewManagement::Core::CoreInputViewAnimationStartingEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CoreInputViewAnimationStartingEventArgs};

    // ----- CoreInputViewHidingEventArgs class --------------------

    static PyObject* _new_CoreInputViewHidingEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::ViewManagement::Core::CoreInputViewHidingEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::ViewManagement::Core::CoreInputViewHidingEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_CoreInputViewHidingEventArgs(py::wrapper::Windows::UI::ViewManagement::Core::CoreInputViewHidingEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CoreInputViewHidingEventArgs_TryCancel(py::wrapper::Windows::UI::ViewManagement::Core::CoreInputViewHidingEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.ViewManagement.Core.CoreInputViewHidingEventArgs", L"TryCancel", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.TryCancel();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_CoreInputViewHidingEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::ViewManagement::Core::CoreInputViewHidingEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CoreInputViewHidingEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::ViewManagement::Core::CoreInputViewHidingEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CoreInputViewHidingEventArgs[] = {
        { "try_cancel", reinterpret_cast<PyCFunction>(CoreInputViewHidingEventArgs_TryCancel), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_CoreInputViewHidingEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CoreInputViewHidingEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_CoreInputViewHidingEventArgs[] = {
        { }};

    static PyType_Slot _type_slots_CoreInputViewHidingEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_CoreInputViewHidingEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CoreInputViewHidingEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CoreInputViewHidingEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CoreInputViewHidingEventArgs) },
        { }};

    static PyType_Spec type_spec_CoreInputViewHidingEventArgs = {
        "winrt._winrt_windows_ui_viewmanagement_core.CoreInputViewHidingEventArgs",
        sizeof(py::wrapper::Windows::UI::ViewManagement::Core::CoreInputViewHidingEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CoreInputViewHidingEventArgs};

    // ----- CoreInputViewOcclusion class --------------------

    static PyObject* _new_CoreInputViewOcclusion(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::ViewManagement::Core::CoreInputViewOcclusion>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::ViewManagement::Core::CoreInputViewOcclusion>::type_name);
        return nullptr;
    }

    static void _dealloc_CoreInputViewOcclusion(py::wrapper::Windows::UI::ViewManagement::Core::CoreInputViewOcclusion* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CoreInputViewOcclusion_get_OccludingRect(py::wrapper::Windows::UI::ViewManagement::Core::CoreInputViewOcclusion* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.ViewManagement.Core.CoreInputViewOcclusion", L"OccludingRect");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.OccludingRect();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreInputViewOcclusion_get_OcclusionKind(py::wrapper::Windows::UI::ViewManagement::Core::CoreInputViewOcclusion* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.ViewManagement.Core.CoreInputViewOcclusion", L"OcclusionKind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.OcclusionKind();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CoreInputViewOcclusion(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::ViewManagement::Core::CoreInputViewOcclusion>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CoreInputViewOcclusion(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::ViewManagement::Core::CoreInputViewOcclusion>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CoreInputViewOcclusion[] = {
        { "_assign_array_", _assign_array_CoreInputViewOcclusion, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CoreInputViewOcclusion), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_CoreInputViewOcclusion[] = {
        { "occluding_rect", reinterpret_cast<getter>(CoreInputViewOcclusion_get_OccludingRect), nullptr, nullptr, nullptr },
        { "occlusion_kind", reinterpret_cast<getter>(CoreInputViewOcclusion_get_OcclusionKind), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_CoreInputViewOcclusion[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_CoreInputViewOcclusion) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CoreInputViewOcclusion) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CoreInputViewOcclusion) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CoreInputViewOcclusion) },
        { }};

    static PyType_Spec type_spec_CoreInputViewOcclusion = {
        "winrt._winrt_windows_ui_viewmanagement_core.CoreInputViewOcclusion",
        sizeof(py::wrapper::Windows::UI::ViewManagement::Core::CoreInputViewOcclusion),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CoreInputViewOcclusion};

    // ----- CoreInputViewOcclusionsChangedEventArgs class --------------------

    static PyObject* _new_CoreInputViewOcclusionsChangedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::ViewManagement::Core::CoreInputViewOcclusionsChangedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::ViewManagement::Core::CoreInputViewOcclusionsChangedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_CoreInputViewOcclusionsChangedEventArgs(py::wrapper::Windows::UI::ViewManagement::Core::CoreInputViewOcclusionsChangedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CoreInputViewOcclusionsChangedEventArgs_get_Handled(py::wrapper::Windows::UI::ViewManagement::Core::CoreInputViewOcclusionsChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.ViewManagement.Core.CoreInputViewOcclusionsChangedEventArgs", L"Handled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Handled();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CoreInputViewOcclusionsChangedEventArgs_put_Handled(py::wrapper::Windows::UI::ViewManagement::Core::CoreInputViewOcclusionsChangedEventArgs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.ViewManagement.Core.CoreInputViewOcclusionsChangedEventArgs", L"Handled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.Handled(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CoreInputViewOcclusionsChangedEventArgs_get_Occlusions(py::wrapper::Windows::UI::ViewManagement::Core::CoreInputViewOcclusionsChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.ViewManagement.Core.CoreInputViewOcclusionsChangedEventArgs", L"Occlusions");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Occlusions();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CoreInputViewOcclusionsChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::ViewManagement::Core::CoreInputViewOcclusionsChangedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CoreInputViewOcclusionsChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::ViewManagement::Core::CoreInputViewOcclusionsChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CoreInputViewOcclusionsChangedEventArgs[] = {
        { "_assign_array_", _assign_array_CoreInputViewOcclusionsChangedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CoreInputViewOcclusionsChangedEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_CoreInputViewOcclusionsChangedEventArgs[] = {
        { "handled", reinterpret_cast<getter>(CoreInputViewOcclusionsChangedEventArgs_get_Handled), reinterpret_cast<setter>(CoreInputViewOcclusionsChangedEventArgs_put_Handled), nullptr, nullptr },
        { "occlusions", reinterpret_cast<getter>(CoreInputViewOcclusionsChangedEventArgs_get_Occlusions), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_CoreInputViewOcclusionsChangedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_CoreInputViewOcclusionsChangedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CoreInputViewOcclusionsChangedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CoreInputViewOcclusionsChangedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CoreInputViewOcclusionsChangedEventArgs) },
        { }};

    static PyType_Spec type_spec_CoreInputViewOcclusionsChangedEventArgs = {
        "winrt._winrt_windows_ui_viewmanagement_core.CoreInputViewOcclusionsChangedEventArgs",
        sizeof(py::wrapper::Windows::UI::ViewManagement::Core::CoreInputViewOcclusionsChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CoreInputViewOcclusionsChangedEventArgs};

    // ----- CoreInputViewShowingEventArgs class --------------------

    static PyObject* _new_CoreInputViewShowingEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::ViewManagement::Core::CoreInputViewShowingEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::ViewManagement::Core::CoreInputViewShowingEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_CoreInputViewShowingEventArgs(py::wrapper::Windows::UI::ViewManagement::Core::CoreInputViewShowingEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CoreInputViewShowingEventArgs_TryCancel(py::wrapper::Windows::UI::ViewManagement::Core::CoreInputViewShowingEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.ViewManagement.Core.CoreInputViewShowingEventArgs", L"TryCancel", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.TryCancel();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_CoreInputViewShowingEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::ViewManagement::Core::CoreInputViewShowingEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CoreInputViewShowingEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::ViewManagement::Core::CoreInputViewShowingEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CoreInputViewShowingEventArgs[] = {
        { "try_cancel", reinterpret_cast<PyCFunction>(CoreInputViewShowingEventArgs_TryCancel), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_CoreInputViewShowingEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CoreInputViewShowingEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_CoreInputViewShowingEventArgs[] = {
        { }};

    static PyType_Slot _type_slots_CoreInputViewShowingEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_CoreInputViewShowingEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CoreInputViewShowingEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CoreInputViewShowingEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CoreInputViewShowingEventArgs) },
        { }};

    static PyType_Spec type_spec_CoreInputViewShowingEventArgs = {
        "winrt._winrt_windows_ui_viewmanagement_core.CoreInputViewShowingEventArgs",
        sizeof(py::wrapper::Windows::UI::ViewManagement::Core::CoreInputViewShowingEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CoreInputViewShowingEventArgs};

    // ----- CoreInputViewTransferringXYFocusEventArgs class --------------------

    static PyObject* _new_CoreInputViewTransferringXYFocusEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::ViewManagement::Core::CoreInputViewTransferringXYFocusEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::ViewManagement::Core::CoreInputViewTransferringXYFocusEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_CoreInputViewTransferringXYFocusEventArgs(py::wrapper::Windows::UI::ViewManagement::Core::CoreInputViewTransferringXYFocusEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CoreInputViewTransferringXYFocusEventArgs_get_TransferHandled(py::wrapper::Windows::UI::ViewManagement::Core::CoreInputViewTransferringXYFocusEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.ViewManagement.Core.CoreInputViewTransferringXYFocusEventArgs", L"TransferHandled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.TransferHandled();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CoreInputViewTransferringXYFocusEventArgs_put_TransferHandled(py::wrapper::Windows::UI::ViewManagement::Core::CoreInputViewTransferringXYFocusEventArgs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.ViewManagement.Core.CoreInputViewTransferringXYFocusEventArgs", L"TransferHandled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.TransferHandled(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CoreInputViewTransferringXYFocusEventArgs_get_KeepPrimaryViewVisible(py::wrapper::Windows::UI::ViewManagement::Core::CoreInputViewTransferringXYFocusEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.ViewManagement.Core.CoreInputViewTransferringXYFocusEventArgs", L"KeepPrimaryViewVisible");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.KeepPrimaryViewVisible();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CoreInputViewTransferringXYFocusEventArgs_put_KeepPrimaryViewVisible(py::wrapper::Windows::UI::ViewManagement::Core::CoreInputViewTransferringXYFocusEventArgs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.ViewManagement.Core.CoreInputViewTransferringXYFocusEventArgs", L"KeepPrimaryViewVisible");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.KeepPrimaryViewVisible(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CoreInputViewTransferringXYFocusEventArgs_get_Direction(py::wrapper::Windows::UI::ViewManagement::Core::CoreInputViewTransferringXYFocusEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.ViewManagement.Core.CoreInputViewTransferringXYFocusEventArgs", L"Direction");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Direction();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreInputViewTransferringXYFocusEventArgs_get_Origin(py::wrapper::Windows::UI::ViewManagement::Core::CoreInputViewTransferringXYFocusEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.ViewManagement.Core.CoreInputViewTransferringXYFocusEventArgs", L"Origin");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Origin();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CoreInputViewTransferringXYFocusEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::ViewManagement::Core::CoreInputViewTransferringXYFocusEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CoreInputViewTransferringXYFocusEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::ViewManagement::Core::CoreInputViewTransferringXYFocusEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CoreInputViewTransferringXYFocusEventArgs[] = {
        { "_assign_array_", _assign_array_CoreInputViewTransferringXYFocusEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CoreInputViewTransferringXYFocusEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_CoreInputViewTransferringXYFocusEventArgs[] = {
        { "transfer_handled", reinterpret_cast<getter>(CoreInputViewTransferringXYFocusEventArgs_get_TransferHandled), reinterpret_cast<setter>(CoreInputViewTransferringXYFocusEventArgs_put_TransferHandled), nullptr, nullptr },
        { "keep_primary_view_visible", reinterpret_cast<getter>(CoreInputViewTransferringXYFocusEventArgs_get_KeepPrimaryViewVisible), reinterpret_cast<setter>(CoreInputViewTransferringXYFocusEventArgs_put_KeepPrimaryViewVisible), nullptr, nullptr },
        { "direction", reinterpret_cast<getter>(CoreInputViewTransferringXYFocusEventArgs_get_Direction), nullptr, nullptr, nullptr },
        { "origin", reinterpret_cast<getter>(CoreInputViewTransferringXYFocusEventArgs_get_Origin), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_CoreInputViewTransferringXYFocusEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_CoreInputViewTransferringXYFocusEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CoreInputViewTransferringXYFocusEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CoreInputViewTransferringXYFocusEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CoreInputViewTransferringXYFocusEventArgs) },
        { }};

    static PyType_Spec type_spec_CoreInputViewTransferringXYFocusEventArgs = {
        "winrt._winrt_windows_ui_viewmanagement_core.CoreInputViewTransferringXYFocusEventArgs",
        sizeof(py::wrapper::Windows::UI::ViewManagement::Core::CoreInputViewTransferringXYFocusEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CoreInputViewTransferringXYFocusEventArgs};

    // ----- UISettingsController class --------------------

    static PyObject* _new_UISettingsController(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::ViewManagement::Core::UISettingsController>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::ViewManagement::Core::UISettingsController>::type_name);
        return nullptr;
    }

    static void _dealloc_UISettingsController(py::wrapper::Windows::UI::ViewManagement::Core::UISettingsController* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* UISettingsController_RequestDefaultAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.ViewManagement.Core.UISettingsController", L"RequestDefaultAsync", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::UI::ViewManagement::Core::UISettingsController::RequestDefaultAsync();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* UISettingsController_SetAdvancedEffectsEnabled(py::wrapper::Windows::UI::ViewManagement::Core::UISettingsController* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.ViewManagement.Core.UISettingsController", L"SetAdvancedEffectsEnabled", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<bool>(args, 0);

                {
                    auto _gil = release_gil();
                    self->obj.SetAdvancedEffectsEnabled(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* UISettingsController_SetAnimationsEnabled(py::wrapper::Windows::UI::ViewManagement::Core::UISettingsController* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.ViewManagement.Core.UISettingsController", L"SetAnimationsEnabled", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<bool>(args, 0);

                {
                    auto _gil = release_gil();
                    self->obj.SetAnimationsEnabled(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* UISettingsController_SetAutoHideScrollBars(py::wrapper::Windows::UI::ViewManagement::Core::UISettingsController* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.ViewManagement.Core.UISettingsController", L"SetAutoHideScrollBars", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<bool>(args, 0);

                {
                    auto _gil = release_gil();
                    self->obj.SetAutoHideScrollBars(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* UISettingsController_SetMessageDuration(py::wrapper::Windows::UI::ViewManagement::Core::UISettingsController* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.ViewManagement.Core.UISettingsController", L"SetMessageDuration", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint32_t>(args, 0);

                {
                    auto _gil = release_gil();
                    self->obj.SetMessageDuration(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* UISettingsController_SetTextScaleFactor(py::wrapper::Windows::UI::ViewManagement::Core::UISettingsController* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.ViewManagement.Core.UISettingsController", L"SetTextScaleFactor", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<double>(args, 0);

                {
                    auto _gil = release_gil();
                    self->obj.SetTextScaleFactor(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_UISettingsController(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::ViewManagement::Core::UISettingsController>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_UISettingsController(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::ViewManagement::Core::UISettingsController>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_UISettingsController[] = {
        { "set_advanced_effects_enabled", reinterpret_cast<PyCFunction>(UISettingsController_SetAdvancedEffectsEnabled), METH_VARARGS, nullptr },
        { "set_animations_enabled", reinterpret_cast<PyCFunction>(UISettingsController_SetAnimationsEnabled), METH_VARARGS, nullptr },
        { "set_auto_hide_scroll_bars", reinterpret_cast<PyCFunction>(UISettingsController_SetAutoHideScrollBars), METH_VARARGS, nullptr },
        { "set_message_duration", reinterpret_cast<PyCFunction>(UISettingsController_SetMessageDuration), METH_VARARGS, nullptr },
        { "set_text_scale_factor", reinterpret_cast<PyCFunction>(UISettingsController_SetTextScaleFactor), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_UISettingsController, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_UISettingsController), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_UISettingsController[] = {
        { }};

    static PyType_Slot _type_slots_UISettingsController[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_UISettingsController) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_UISettingsController) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_UISettingsController) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_UISettingsController) },
        { }};

    static PyType_Spec type_spec_UISettingsController = {
        "winrt._winrt_windows_ui_viewmanagement_core.UISettingsController",
        sizeof(py::wrapper::Windows::UI::ViewManagement::Core::UISettingsController),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_UISettingsController};

    static PyGetSetDef getset_UISettingsController_Static[] = {
        { }};

    static PyMethodDef methods_UISettingsController_Static[] = {
        { "request_default_async", reinterpret_cast<PyCFunction>(UISettingsController_RequestDefaultAsync), METH_VARARGS, nullptr },
        { }};

    static PyType_Slot type_slots_UISettingsController_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_UISettingsController_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_UISettingsController_Static) },
        { }
    };

    static PyType_Spec type_spec_UISettingsController_Static = {
        "winrt._winrt_windows_ui_viewmanagement_core.UISettingsController_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_UISettingsController_Static};

    // ----- Windows.UI.ViewManagement.Core Initialization --------------------

    PyDoc_STRVAR(module_doc, "Windows.UI.ViewManagement.Core");

    static PyModuleDef module_def = {
        PyModuleDef_HEAD_INIT,
        "_winrt_windows_ui_viewmanagement_core",
        module_doc,
        0,
        nullptr,
        nullptr,
        nullptr,
        nullptr,
        nullptr};
} // py::cpp::Windows::UI::ViewManagement::Core

PyMODINIT_FUNC PyInit__winrt_windows_ui_viewmanagement_core(void) noexcept
{
    using namespace py::cpp::Windows::UI::ViewManagement::Core;

    if (py::import_winrt_runtime() == -1)
    {
        return nullptr;
    }

    py::pyobj_handle module{PyModule_Create(&module_def)};

    if (!module)
    {
        return nullptr;
    }

    auto inspectable_meta_type = py::get_inspectable_meta_type();
    if (!inspectable_meta_type)
    {
        return nullptr;
    }

    auto object_type = py::get_object_type();
    if (!object_type)
    {
        return nullptr;
    }

    py::pyobj_handle object_bases{PyTuple_Pack(1, object_type)};

    if (!object_bases)
    {
        return nullptr;
    }

    py::pyobj_handle CoreFrameworkInputView_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(inspectable_meta_type))};
    if (!CoreFrameworkInputView_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_CoreFrameworkInputView_Static{PyType_FromSpecWithBases(&type_spec_CoreFrameworkInputView_Static, CoreFrameworkInputView_Static_bases.get())};
    if (!type_CoreFrameworkInputView_Static)
    {
        return nullptr;
    }

    py::pytype_handle CoreFrameworkInputView_type{py::register_python_type(module.get(), &type_spec_CoreFrameworkInputView, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_CoreFrameworkInputView_Static.get()))};
    if (!CoreFrameworkInputView_type)
    {
        return nullptr;
    }

    py::pytype_handle CoreFrameworkInputViewAnimationStartingEventArgs_type{py::register_python_type(module.get(), &type_spec_CoreFrameworkInputViewAnimationStartingEventArgs, object_bases.get(), inspectable_meta_type)};
    if (!CoreFrameworkInputViewAnimationStartingEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle CoreFrameworkInputViewOcclusionsChangedEventArgs_type{py::register_python_type(module.get(), &type_spec_CoreFrameworkInputViewOcclusionsChangedEventArgs, object_bases.get(), inspectable_meta_type)};
    if (!CoreFrameworkInputViewOcclusionsChangedEventArgs_type)
    {
        return nullptr;
    }

    py::pyobj_handle CoreInputView_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(inspectable_meta_type))};
    if (!CoreInputView_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_CoreInputView_Static{PyType_FromSpecWithBases(&type_spec_CoreInputView_Static, CoreInputView_Static_bases.get())};
    if (!type_CoreInputView_Static)
    {
        return nullptr;
    }

    py::pytype_handle CoreInputView_type{py::register_python_type(module.get(), &type_spec_CoreInputView, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_CoreInputView_Static.get()))};
    if (!CoreInputView_type)
    {
        return nullptr;
    }

    py::pytype_handle CoreInputViewAnimationStartingEventArgs_type{py::register_python_type(module.get(), &type_spec_CoreInputViewAnimationStartingEventArgs, object_bases.get(), inspectable_meta_type)};
    if (!CoreInputViewAnimationStartingEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle CoreInputViewHidingEventArgs_type{py::register_python_type(module.get(), &type_spec_CoreInputViewHidingEventArgs, object_bases.get(), inspectable_meta_type)};
    if (!CoreInputViewHidingEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle CoreInputViewOcclusion_type{py::register_python_type(module.get(), &type_spec_CoreInputViewOcclusion, object_bases.get(), inspectable_meta_type)};
    if (!CoreInputViewOcclusion_type)
    {
        return nullptr;
    }

    py::pytype_handle CoreInputViewOcclusionsChangedEventArgs_type{py::register_python_type(module.get(), &type_spec_CoreInputViewOcclusionsChangedEventArgs, object_bases.get(), inspectable_meta_type)};
    if (!CoreInputViewOcclusionsChangedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle CoreInputViewShowingEventArgs_type{py::register_python_type(module.get(), &type_spec_CoreInputViewShowingEventArgs, object_bases.get(), inspectable_meta_type)};
    if (!CoreInputViewShowingEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle CoreInputViewTransferringXYFocusEventArgs_type{py::register_python_type(module.get(), &type_spec_CoreInputViewTransferringXYFocusEventArgs, object_bases.get(), inspectable_meta_type)};
    if (!CoreInputViewTransferringXYFocusEventArgs_type)
    {
        return nullptr;
    }

    py::pyobj_handle UISettingsController_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(inspectable_meta_type))};
    if (!UISettingsController_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_UISettingsController_Static{PyType_FromSpecWithBases(&type_spec_UISettingsController_Static, UISettingsController_Static_bases.get())};
    if (!type_UISettingsController_Static)
    {
        return nullptr;
    }

    py::pytype_handle UISettingsController_type{py::register_python_type(module.get(), &type_spec_UISettingsController, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_UISettingsController_Static.get()))};
    if (!UISettingsController_type)
    {
        return nullptr;
    }


    return module.detach();
}
