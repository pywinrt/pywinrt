// WARNING: Please don't edit this file. It was generated by Python/WinRT v3.2.1

#include "py.Windows.Management.Update.h"

namespace py::cpp::Windows::Management::Update
{
    // ----- PreviewBuildsManager class --------------------

    static PyObject* _new_PreviewBuildsManager(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Management::Update::PreviewBuildsManager>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Management::Update::PreviewBuildsManager>::type_name);
        return nullptr;
    }

    static void _dealloc_PreviewBuildsManager(py::wrapper::Windows::Management::Update::PreviewBuildsManager* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PreviewBuildsManager_GetCurrentState(py::wrapper::Windows::Management::Update::PreviewBuildsManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Management.Update.PreviewBuildsManager", L"GetCurrentState", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetCurrentState();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PreviewBuildsManager_GetDefault(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Management.Update.PreviewBuildsManager", L"GetDefault", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::Management::Update::PreviewBuildsManager::GetDefault();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PreviewBuildsManager_IsSupported(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Management.Update.PreviewBuildsManager", L"IsSupported", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::Management::Update::PreviewBuildsManager::IsSupported();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PreviewBuildsManager_SyncAsync(py::wrapper::Windows::Management::Update::PreviewBuildsManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Management.Update.PreviewBuildsManager", L"SyncAsync", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.SyncAsync();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PreviewBuildsManager_get_ArePreviewBuildsAllowed(py::wrapper::Windows::Management::Update::PreviewBuildsManager* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Update.PreviewBuildsManager", L"ArePreviewBuildsAllowed");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ArePreviewBuildsAllowed();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PreviewBuildsManager_put_ArePreviewBuildsAllowed(py::wrapper::Windows::Management::Update::PreviewBuildsManager* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Update.PreviewBuildsManager", L"ArePreviewBuildsAllowed");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.ArePreviewBuildsAllowed(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_PreviewBuildsManager(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Management::Update::PreviewBuildsManager>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PreviewBuildsManager(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Management::Update::PreviewBuildsManager>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PreviewBuildsManager[] = {
        { "get_current_state", reinterpret_cast<PyCFunction>(PreviewBuildsManager_GetCurrentState), METH_VARARGS, nullptr },
        { "sync_async", reinterpret_cast<PyCFunction>(PreviewBuildsManager_SyncAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_PreviewBuildsManager, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PreviewBuildsManager), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_PreviewBuildsManager[] = {
        { "are_preview_builds_allowed", reinterpret_cast<getter>(PreviewBuildsManager_get_ArePreviewBuildsAllowed), reinterpret_cast<setter>(PreviewBuildsManager_put_ArePreviewBuildsAllowed), nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_PreviewBuildsManager[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PreviewBuildsManager) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PreviewBuildsManager) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PreviewBuildsManager) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PreviewBuildsManager) },
        { }};

    static PyType_Spec type_spec_PreviewBuildsManager = {
        "winrt._winrt_windows_management_update.PreviewBuildsManager",
        sizeof(py::wrapper::Windows::Management::Update::PreviewBuildsManager),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PreviewBuildsManager};

    static PyGetSetDef getset_PreviewBuildsManager_Static[] = {
        { }};

    static PyMethodDef methods_PreviewBuildsManager_Static[] = {
        { "get_default", reinterpret_cast<PyCFunction>(PreviewBuildsManager_GetDefault), METH_VARARGS, nullptr },
        { "is_supported", reinterpret_cast<PyCFunction>(PreviewBuildsManager_IsSupported), METH_VARARGS, nullptr },
        { }};

    static PyType_Slot type_slots_PreviewBuildsManager_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_PreviewBuildsManager_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_PreviewBuildsManager_Static) },
        { }
    };

    static PyType_Spec type_spec_PreviewBuildsManager_Static = {
        "winrt._winrt_windows_management_update.PreviewBuildsManager_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_PreviewBuildsManager_Static};

    // ----- PreviewBuildsState class --------------------

    static PyObject* _new_PreviewBuildsState(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Management::Update::PreviewBuildsState>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Management::Update::PreviewBuildsState>::type_name);
        return nullptr;
    }

    static void _dealloc_PreviewBuildsState(py::wrapper::Windows::Management::Update::PreviewBuildsState* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PreviewBuildsState_get_Properties(py::wrapper::Windows::Management::Update::PreviewBuildsState* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Update.PreviewBuildsState", L"Properties");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Properties();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PreviewBuildsState(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Management::Update::PreviewBuildsState>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PreviewBuildsState(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Management::Update::PreviewBuildsState>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PreviewBuildsState[] = {
        { "_assign_array_", _assign_array_PreviewBuildsState, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PreviewBuildsState), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_PreviewBuildsState[] = {
        { "properties", reinterpret_cast<getter>(PreviewBuildsState_get_Properties), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_PreviewBuildsState[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PreviewBuildsState) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PreviewBuildsState) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PreviewBuildsState) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PreviewBuildsState) },
        { }};

    static PyType_Spec type_spec_PreviewBuildsState = {
        "winrt._winrt_windows_management_update.PreviewBuildsState",
        sizeof(py::wrapper::Windows::Management::Update::PreviewBuildsState),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PreviewBuildsState};

    // ----- WindowsUpdate class --------------------

    static PyObject* _new_WindowsUpdate(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Management::Update::WindowsUpdate>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Management::Update::WindowsUpdate>::type_name);
        return nullptr;
    }

    static void _dealloc_WindowsUpdate(py::wrapper::Windows::Management::Update::WindowsUpdate* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* WindowsUpdate_AcceptEula(py::wrapper::Windows::Management::Update::WindowsUpdate* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Management.Update.WindowsUpdate", L"AcceptEula", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.AcceptEula();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* WindowsUpdate_GetPropertyValue(py::wrapper::Windows::Management::Update::WindowsUpdate* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Management.Update.WindowsUpdate", L"GetPropertyValue", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetPropertyValue(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* WindowsUpdate_get_ActionProgress(py::wrapper::Windows::Management::Update::WindowsUpdate* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Update.WindowsUpdate", L"ActionProgress");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ActionProgress();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WindowsUpdate_get_ActionResult(py::wrapper::Windows::Management::Update::WindowsUpdate* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Update.WindowsUpdate", L"ActionResult");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ActionResult();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WindowsUpdate_get_AttentionRequiredInfo(py::wrapper::Windows::Management::Update::WindowsUpdate* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Update.WindowsUpdate", L"AttentionRequiredInfo");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.AttentionRequiredInfo();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WindowsUpdate_get_CurrentAction(py::wrapper::Windows::Management::Update::WindowsUpdate* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Update.WindowsUpdate", L"CurrentAction");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.CurrentAction();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WindowsUpdate_get_Deadline(py::wrapper::Windows::Management::Update::WindowsUpdate* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Update.WindowsUpdate", L"Deadline");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Deadline();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WindowsUpdate_get_Description(py::wrapper::Windows::Management::Update::WindowsUpdate* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Update.WindowsUpdate", L"Description");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Description();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WindowsUpdate_get_EulaText(py::wrapper::Windows::Management::Update::WindowsUpdate* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Update.WindowsUpdate", L"EulaText");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.EulaText();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WindowsUpdate_get_IsCritical(py::wrapper::Windows::Management::Update::WindowsUpdate* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Update.WindowsUpdate", L"IsCritical");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsCritical();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WindowsUpdate_get_IsDriver(py::wrapper::Windows::Management::Update::WindowsUpdate* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Update.WindowsUpdate", L"IsDriver");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsDriver();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WindowsUpdate_get_IsEulaAccepted(py::wrapper::Windows::Management::Update::WindowsUpdate* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Update.WindowsUpdate", L"IsEulaAccepted");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsEulaAccepted();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WindowsUpdate_get_IsFeatureUpdate(py::wrapper::Windows::Management::Update::WindowsUpdate* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Update.WindowsUpdate", L"IsFeatureUpdate");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsFeatureUpdate();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WindowsUpdate_get_IsForOS(py::wrapper::Windows::Management::Update::WindowsUpdate* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Update.WindowsUpdate", L"IsForOS");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsForOS();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WindowsUpdate_get_IsMandatory(py::wrapper::Windows::Management::Update::WindowsUpdate* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Update.WindowsUpdate", L"IsMandatory");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsMandatory();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WindowsUpdate_get_IsMinorImpact(py::wrapper::Windows::Management::Update::WindowsUpdate* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Update.WindowsUpdate", L"IsMinorImpact");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsMinorImpact();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WindowsUpdate_get_IsSecurity(py::wrapper::Windows::Management::Update::WindowsUpdate* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Update.WindowsUpdate", L"IsSecurity");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsSecurity();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WindowsUpdate_get_IsSeeker(py::wrapper::Windows::Management::Update::WindowsUpdate* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Update.WindowsUpdate", L"IsSeeker");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsSeeker();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WindowsUpdate_get_IsUrgent(py::wrapper::Windows::Management::Update::WindowsUpdate* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Update.WindowsUpdate", L"IsUrgent");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsUrgent();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WindowsUpdate_get_MoreInfoUrl(py::wrapper::Windows::Management::Update::WindowsUpdate* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Update.WindowsUpdate", L"MoreInfoUrl");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.MoreInfoUrl();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WindowsUpdate_get_ProviderId(py::wrapper::Windows::Management::Update::WindowsUpdate* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Update.WindowsUpdate", L"ProviderId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ProviderId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WindowsUpdate_get_SupportUrl(py::wrapper::Windows::Management::Update::WindowsUpdate* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Update.WindowsUpdate", L"SupportUrl");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SupportUrl();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WindowsUpdate_get_Title(py::wrapper::Windows::Management::Update::WindowsUpdate* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Update.WindowsUpdate", L"Title");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Title();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WindowsUpdate_get_UpdateId(py::wrapper::Windows::Management::Update::WindowsUpdate* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Update.WindowsUpdate", L"UpdateId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.UpdateId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_WindowsUpdate(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Management::Update::WindowsUpdate>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_WindowsUpdate(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Management::Update::WindowsUpdate>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WindowsUpdate[] = {
        { "accept_eula", reinterpret_cast<PyCFunction>(WindowsUpdate_AcceptEula), METH_VARARGS, nullptr },
        { "get_property_value", reinterpret_cast<PyCFunction>(WindowsUpdate_GetPropertyValue), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_WindowsUpdate, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_WindowsUpdate), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_WindowsUpdate[] = {
        { "action_progress", reinterpret_cast<getter>(WindowsUpdate_get_ActionProgress), nullptr, nullptr, nullptr },
        { "action_result", reinterpret_cast<getter>(WindowsUpdate_get_ActionResult), nullptr, nullptr, nullptr },
        { "attention_required_info", reinterpret_cast<getter>(WindowsUpdate_get_AttentionRequiredInfo), nullptr, nullptr, nullptr },
        { "current_action", reinterpret_cast<getter>(WindowsUpdate_get_CurrentAction), nullptr, nullptr, nullptr },
        { "deadline", reinterpret_cast<getter>(WindowsUpdate_get_Deadline), nullptr, nullptr, nullptr },
        { "description", reinterpret_cast<getter>(WindowsUpdate_get_Description), nullptr, nullptr, nullptr },
        { "eula_text", reinterpret_cast<getter>(WindowsUpdate_get_EulaText), nullptr, nullptr, nullptr },
        { "is_critical", reinterpret_cast<getter>(WindowsUpdate_get_IsCritical), nullptr, nullptr, nullptr },
        { "is_driver", reinterpret_cast<getter>(WindowsUpdate_get_IsDriver), nullptr, nullptr, nullptr },
        { "is_eula_accepted", reinterpret_cast<getter>(WindowsUpdate_get_IsEulaAccepted), nullptr, nullptr, nullptr },
        { "is_feature_update", reinterpret_cast<getter>(WindowsUpdate_get_IsFeatureUpdate), nullptr, nullptr, nullptr },
        { "is_for_os", reinterpret_cast<getter>(WindowsUpdate_get_IsForOS), nullptr, nullptr, nullptr },
        { "is_mandatory", reinterpret_cast<getter>(WindowsUpdate_get_IsMandatory), nullptr, nullptr, nullptr },
        { "is_minor_impact", reinterpret_cast<getter>(WindowsUpdate_get_IsMinorImpact), nullptr, nullptr, nullptr },
        { "is_security", reinterpret_cast<getter>(WindowsUpdate_get_IsSecurity), nullptr, nullptr, nullptr },
        { "is_seeker", reinterpret_cast<getter>(WindowsUpdate_get_IsSeeker), nullptr, nullptr, nullptr },
        { "is_urgent", reinterpret_cast<getter>(WindowsUpdate_get_IsUrgent), nullptr, nullptr, nullptr },
        { "more_info_url", reinterpret_cast<getter>(WindowsUpdate_get_MoreInfoUrl), nullptr, nullptr, nullptr },
        { "provider_id", reinterpret_cast<getter>(WindowsUpdate_get_ProviderId), nullptr, nullptr, nullptr },
        { "support_url", reinterpret_cast<getter>(WindowsUpdate_get_SupportUrl), nullptr, nullptr, nullptr },
        { "title", reinterpret_cast<getter>(WindowsUpdate_get_Title), nullptr, nullptr, nullptr },
        { "update_id", reinterpret_cast<getter>(WindowsUpdate_get_UpdateId), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_WindowsUpdate[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_WindowsUpdate) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_WindowsUpdate) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_WindowsUpdate) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_WindowsUpdate) },
        { }};

    static PyType_Spec type_spec_WindowsUpdate = {
        "winrt._winrt_windows_management_update.WindowsUpdate",
        sizeof(py::wrapper::Windows::Management::Update::WindowsUpdate),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WindowsUpdate};

    // ----- WindowsUpdateActionCompletedEventArgs class --------------------

    static PyObject* _new_WindowsUpdateActionCompletedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Management::Update::WindowsUpdateActionCompletedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Management::Update::WindowsUpdateActionCompletedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_WindowsUpdateActionCompletedEventArgs(py::wrapper::Windows::Management::Update::WindowsUpdateActionCompletedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* WindowsUpdateActionCompletedEventArgs_get_Action(py::wrapper::Windows::Management::Update::WindowsUpdateActionCompletedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Update.WindowsUpdateActionCompletedEventArgs", L"Action");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Action();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WindowsUpdateActionCompletedEventArgs_get_ExtendedError(py::wrapper::Windows::Management::Update::WindowsUpdateActionCompletedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Update.WindowsUpdateActionCompletedEventArgs", L"ExtendedError");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ExtendedError();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WindowsUpdateActionCompletedEventArgs_get_Succeeded(py::wrapper::Windows::Management::Update::WindowsUpdateActionCompletedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Update.WindowsUpdateActionCompletedEventArgs", L"Succeeded");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Succeeded();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WindowsUpdateActionCompletedEventArgs_get_Update(py::wrapper::Windows::Management::Update::WindowsUpdateActionCompletedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Update.WindowsUpdateActionCompletedEventArgs", L"Update");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Update();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_WindowsUpdateActionCompletedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Management::Update::WindowsUpdateActionCompletedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_WindowsUpdateActionCompletedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Management::Update::WindowsUpdateActionCompletedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WindowsUpdateActionCompletedEventArgs[] = {
        { "_assign_array_", _assign_array_WindowsUpdateActionCompletedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_WindowsUpdateActionCompletedEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_WindowsUpdateActionCompletedEventArgs[] = {
        { "action", reinterpret_cast<getter>(WindowsUpdateActionCompletedEventArgs_get_Action), nullptr, nullptr, nullptr },
        { "extended_error", reinterpret_cast<getter>(WindowsUpdateActionCompletedEventArgs_get_ExtendedError), nullptr, nullptr, nullptr },
        { "succeeded", reinterpret_cast<getter>(WindowsUpdateActionCompletedEventArgs_get_Succeeded), nullptr, nullptr, nullptr },
        { "update", reinterpret_cast<getter>(WindowsUpdateActionCompletedEventArgs_get_Update), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_WindowsUpdateActionCompletedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_WindowsUpdateActionCompletedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_WindowsUpdateActionCompletedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_WindowsUpdateActionCompletedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_WindowsUpdateActionCompletedEventArgs) },
        { }};

    static PyType_Spec type_spec_WindowsUpdateActionCompletedEventArgs = {
        "winrt._winrt_windows_management_update.WindowsUpdateActionCompletedEventArgs",
        sizeof(py::wrapper::Windows::Management::Update::WindowsUpdateActionCompletedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WindowsUpdateActionCompletedEventArgs};

    // ----- WindowsUpdateActionProgress class --------------------

    static PyObject* _new_WindowsUpdateActionProgress(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Management::Update::WindowsUpdateActionProgress>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Management::Update::WindowsUpdateActionProgress>::type_name);
        return nullptr;
    }

    static void _dealloc_WindowsUpdateActionProgress(py::wrapper::Windows::Management::Update::WindowsUpdateActionProgress* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* WindowsUpdateActionProgress_get_Action(py::wrapper::Windows::Management::Update::WindowsUpdateActionProgress* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Update.WindowsUpdateActionProgress", L"Action");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Action();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WindowsUpdateActionProgress_get_Progress(py::wrapper::Windows::Management::Update::WindowsUpdateActionProgress* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Update.WindowsUpdateActionProgress", L"Progress");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Progress();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_WindowsUpdateActionProgress(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Management::Update::WindowsUpdateActionProgress>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_WindowsUpdateActionProgress(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Management::Update::WindowsUpdateActionProgress>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WindowsUpdateActionProgress[] = {
        { "_assign_array_", _assign_array_WindowsUpdateActionProgress, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_WindowsUpdateActionProgress), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_WindowsUpdateActionProgress[] = {
        { "action", reinterpret_cast<getter>(WindowsUpdateActionProgress_get_Action), nullptr, nullptr, nullptr },
        { "progress", reinterpret_cast<getter>(WindowsUpdateActionProgress_get_Progress), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_WindowsUpdateActionProgress[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_WindowsUpdateActionProgress) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_WindowsUpdateActionProgress) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_WindowsUpdateActionProgress) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_WindowsUpdateActionProgress) },
        { }};

    static PyType_Spec type_spec_WindowsUpdateActionProgress = {
        "winrt._winrt_windows_management_update.WindowsUpdateActionProgress",
        sizeof(py::wrapper::Windows::Management::Update::WindowsUpdateActionProgress),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WindowsUpdateActionProgress};

    // ----- WindowsUpdateActionResult class --------------------

    static PyObject* _new_WindowsUpdateActionResult(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Management::Update::WindowsUpdateActionResult>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Management::Update::WindowsUpdateActionResult>::type_name);
        return nullptr;
    }

    static void _dealloc_WindowsUpdateActionResult(py::wrapper::Windows::Management::Update::WindowsUpdateActionResult* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* WindowsUpdateActionResult_get_Action(py::wrapper::Windows::Management::Update::WindowsUpdateActionResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Update.WindowsUpdateActionResult", L"Action");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Action();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WindowsUpdateActionResult_get_ExtendedError(py::wrapper::Windows::Management::Update::WindowsUpdateActionResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Update.WindowsUpdateActionResult", L"ExtendedError");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ExtendedError();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WindowsUpdateActionResult_get_Succeeded(py::wrapper::Windows::Management::Update::WindowsUpdateActionResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Update.WindowsUpdateActionResult", L"Succeeded");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Succeeded();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WindowsUpdateActionResult_get_Timestamp(py::wrapper::Windows::Management::Update::WindowsUpdateActionResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Update.WindowsUpdateActionResult", L"Timestamp");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Timestamp();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_WindowsUpdateActionResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Management::Update::WindowsUpdateActionResult>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_WindowsUpdateActionResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Management::Update::WindowsUpdateActionResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WindowsUpdateActionResult[] = {
        { "_assign_array_", _assign_array_WindowsUpdateActionResult, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_WindowsUpdateActionResult), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_WindowsUpdateActionResult[] = {
        { "action", reinterpret_cast<getter>(WindowsUpdateActionResult_get_Action), nullptr, nullptr, nullptr },
        { "extended_error", reinterpret_cast<getter>(WindowsUpdateActionResult_get_ExtendedError), nullptr, nullptr, nullptr },
        { "succeeded", reinterpret_cast<getter>(WindowsUpdateActionResult_get_Succeeded), nullptr, nullptr, nullptr },
        { "timestamp", reinterpret_cast<getter>(WindowsUpdateActionResult_get_Timestamp), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_WindowsUpdateActionResult[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_WindowsUpdateActionResult) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_WindowsUpdateActionResult) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_WindowsUpdateActionResult) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_WindowsUpdateActionResult) },
        { }};

    static PyType_Spec type_spec_WindowsUpdateActionResult = {
        "winrt._winrt_windows_management_update.WindowsUpdateActionResult",
        sizeof(py::wrapper::Windows::Management::Update::WindowsUpdateActionResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WindowsUpdateActionResult};

    // ----- WindowsUpdateAdministrator class --------------------

    static PyObject* _new_WindowsUpdateAdministrator(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Management::Update::WindowsUpdateAdministrator>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Management::Update::WindowsUpdateAdministrator>::type_name);
        return nullptr;
    }

    static void _dealloc_WindowsUpdateAdministrator(py::wrapper::Windows::Management::Update::WindowsUpdateAdministrator* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* WindowsUpdateAdministrator_ApproveWindowsUpdate(py::wrapper::Windows::Management::Update::WindowsUpdateAdministrator* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Management.Update.WindowsUpdateAdministrator", L"ApproveWindowsUpdate", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Management::Update::WindowsUpdateApprovalData>(args, 1);

                {
                    auto _gil = release_gil();
                    self->obj.ApproveWindowsUpdate(param0, param1);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* WindowsUpdateAdministrator_ApproveWindowsUpdateAction(py::wrapper::Windows::Management::Update::WindowsUpdateAdministrator* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Management.Update.WindowsUpdateAdministrator", L"ApproveWindowsUpdateAction", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                {
                    auto _gil = release_gil();
                    self->obj.ApproveWindowsUpdateAction(param0, param1);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* WindowsUpdateAdministrator_CancelRestartRequest(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Management.Update.WindowsUpdateAdministrator", L"CancelRestartRequest", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                {
                    auto _gil = release_gil();
                    winrt::Windows::Management::Update::WindowsUpdateAdministrator::CancelRestartRequest(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* WindowsUpdateAdministrator_GetRegisteredAdministrator(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Management.Update.WindowsUpdateAdministrator", L"GetRegisteredAdministrator", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::Management::Update::WindowsUpdateAdministrator::GetRegisteredAdministrator(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* WindowsUpdateAdministrator_GetRegisteredAdministratorName(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Management.Update.WindowsUpdateAdministrator", L"GetRegisteredAdministratorName", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::Management::Update::WindowsUpdateAdministrator::GetRegisteredAdministratorName();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* WindowsUpdateAdministrator_GetUpdates(py::wrapper::Windows::Management::Update::WindowsUpdateAdministrator* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Management.Update.WindowsUpdateAdministrator", L"GetUpdates", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetUpdates();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* WindowsUpdateAdministrator_RegisterForAdministration(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Management.Update.WindowsUpdateAdministrator", L"RegisterForAdministration", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Management::Update::WindowsUpdateAdministratorOptions>(args, 1);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::Management::Update::WindowsUpdateAdministrator::RegisterForAdministration(param0, param1);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* WindowsUpdateAdministrator_RequestRestart(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Management.Update.WindowsUpdateAdministrator", L"RequestRestart", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Management::Update::WindowsUpdateRestartRequestOptions>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::Management::Update::WindowsUpdateAdministrator::RequestRestart(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* WindowsUpdateAdministrator_RevokeWindowsUpdateActionApproval(py::wrapper::Windows::Management::Update::WindowsUpdateAdministrator* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Management.Update.WindowsUpdateAdministrator", L"RevokeWindowsUpdateActionApproval", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                {
                    auto _gil = release_gil();
                    self->obj.RevokeWindowsUpdateActionApproval(param0, param1);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* WindowsUpdateAdministrator_RevokeWindowsUpdateApproval(py::wrapper::Windows::Management::Update::WindowsUpdateAdministrator* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Management.Update.WindowsUpdateAdministrator", L"RevokeWindowsUpdateApproval", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                {
                    auto _gil = release_gil();
                    self->obj.RevokeWindowsUpdateApproval(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* WindowsUpdateAdministrator_StartAdministratorScan(py::wrapper::Windows::Management::Update::WindowsUpdateAdministrator* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Management.Update.WindowsUpdateAdministrator", L"StartAdministratorScan", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.StartAdministratorScan();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* WindowsUpdateAdministrator_UnregisterForAdministration(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Management.Update.WindowsUpdateAdministrator", L"UnregisterForAdministration", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::Management::Update::WindowsUpdateAdministrator::UnregisterForAdministration(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_WindowsUpdateAdministrator(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Management::Update::WindowsUpdateAdministrator>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_WindowsUpdateAdministrator(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Management::Update::WindowsUpdateAdministrator>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WindowsUpdateAdministrator[] = {
        { "approve_windows_update", reinterpret_cast<PyCFunction>(WindowsUpdateAdministrator_ApproveWindowsUpdate), METH_VARARGS, nullptr },
        { "approve_windows_update_action", reinterpret_cast<PyCFunction>(WindowsUpdateAdministrator_ApproveWindowsUpdateAction), METH_VARARGS, nullptr },
        { "get_updates", reinterpret_cast<PyCFunction>(WindowsUpdateAdministrator_GetUpdates), METH_VARARGS, nullptr },
        { "revoke_windows_update_action_approval", reinterpret_cast<PyCFunction>(WindowsUpdateAdministrator_RevokeWindowsUpdateActionApproval), METH_VARARGS, nullptr },
        { "revoke_windows_update_approval", reinterpret_cast<PyCFunction>(WindowsUpdateAdministrator_RevokeWindowsUpdateApproval), METH_VARARGS, nullptr },
        { "start_administrator_scan", reinterpret_cast<PyCFunction>(WindowsUpdateAdministrator_StartAdministratorScan), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_WindowsUpdateAdministrator, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_WindowsUpdateAdministrator), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_WindowsUpdateAdministrator[] = {
        { }};

    static PyType_Slot _type_slots_WindowsUpdateAdministrator[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_WindowsUpdateAdministrator) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_WindowsUpdateAdministrator) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_WindowsUpdateAdministrator) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_WindowsUpdateAdministrator) },
        { }};

    static PyType_Spec type_spec_WindowsUpdateAdministrator = {
        "winrt._winrt_windows_management_update.WindowsUpdateAdministrator",
        sizeof(py::wrapper::Windows::Management::Update::WindowsUpdateAdministrator),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WindowsUpdateAdministrator};

    static PyGetSetDef getset_WindowsUpdateAdministrator_Static[] = {
        { }};

    static PyMethodDef methods_WindowsUpdateAdministrator_Static[] = {
        { "cancel_restart_request", reinterpret_cast<PyCFunction>(WindowsUpdateAdministrator_CancelRestartRequest), METH_VARARGS, nullptr },
        { "get_registered_administrator", reinterpret_cast<PyCFunction>(WindowsUpdateAdministrator_GetRegisteredAdministrator), METH_VARARGS, nullptr },
        { "get_registered_administrator_name", reinterpret_cast<PyCFunction>(WindowsUpdateAdministrator_GetRegisteredAdministratorName), METH_VARARGS, nullptr },
        { "register_for_administration", reinterpret_cast<PyCFunction>(WindowsUpdateAdministrator_RegisterForAdministration), METH_VARARGS, nullptr },
        { "request_restart", reinterpret_cast<PyCFunction>(WindowsUpdateAdministrator_RequestRestart), METH_VARARGS, nullptr },
        { "unregister_for_administration", reinterpret_cast<PyCFunction>(WindowsUpdateAdministrator_UnregisterForAdministration), METH_VARARGS, nullptr },
        { }};

    static PyType_Slot type_slots_WindowsUpdateAdministrator_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_WindowsUpdateAdministrator_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_WindowsUpdateAdministrator_Static) },
        { }
    };

    static PyType_Spec type_spec_WindowsUpdateAdministrator_Static = {
        "winrt._winrt_windows_management_update.WindowsUpdateAdministrator_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_WindowsUpdateAdministrator_Static};

    // ----- WindowsUpdateApprovalData class --------------------

    static PyObject* _new_WindowsUpdateApprovalData(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Management::Update::WindowsUpdateApprovalData instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_WindowsUpdateApprovalData(py::wrapper::Windows::Management::Update::WindowsUpdateApprovalData* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* WindowsUpdateApprovalData_get_Seeker(py::wrapper::Windows::Management::Update::WindowsUpdateApprovalData* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Update.WindowsUpdateApprovalData", L"Seeker");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Seeker();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int WindowsUpdateApprovalData_put_Seeker(py::wrapper::Windows::Management::Update::WindowsUpdateApprovalData* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Update.WindowsUpdateApprovalData", L"Seeker");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<bool>>(arg);

            {
                auto _gil = release_gil();
                self->obj.Seeker(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* WindowsUpdateApprovalData_get_OptOutOfAutoReboot(py::wrapper::Windows::Management::Update::WindowsUpdateApprovalData* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Update.WindowsUpdateApprovalData", L"OptOutOfAutoReboot");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.OptOutOfAutoReboot();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int WindowsUpdateApprovalData_put_OptOutOfAutoReboot(py::wrapper::Windows::Management::Update::WindowsUpdateApprovalData* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Update.WindowsUpdateApprovalData", L"OptOutOfAutoReboot");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<bool>>(arg);

            {
                auto _gil = release_gil();
                self->obj.OptOutOfAutoReboot(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* WindowsUpdateApprovalData_get_ComplianceGracePeriodInDays(py::wrapper::Windows::Management::Update::WindowsUpdateApprovalData* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Update.WindowsUpdateApprovalData", L"ComplianceGracePeriodInDays");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ComplianceGracePeriodInDays();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int WindowsUpdateApprovalData_put_ComplianceGracePeriodInDays(py::wrapper::Windows::Management::Update::WindowsUpdateApprovalData* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Update.WindowsUpdateApprovalData", L"ComplianceGracePeriodInDays");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<int32_t>>(arg);

            {
                auto _gil = release_gil();
                self->obj.ComplianceGracePeriodInDays(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* WindowsUpdateApprovalData_get_ComplianceDeadlineInDays(py::wrapper::Windows::Management::Update::WindowsUpdateApprovalData* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Update.WindowsUpdateApprovalData", L"ComplianceDeadlineInDays");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ComplianceDeadlineInDays();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int WindowsUpdateApprovalData_put_ComplianceDeadlineInDays(py::wrapper::Windows::Management::Update::WindowsUpdateApprovalData* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Update.WindowsUpdateApprovalData", L"ComplianceDeadlineInDays");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<int32_t>>(arg);

            {
                auto _gil = release_gil();
                self->obj.ComplianceDeadlineInDays(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* WindowsUpdateApprovalData_get_AllowDownloadOnMetered(py::wrapper::Windows::Management::Update::WindowsUpdateApprovalData* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Update.WindowsUpdateApprovalData", L"AllowDownloadOnMetered");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.AllowDownloadOnMetered();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int WindowsUpdateApprovalData_put_AllowDownloadOnMetered(py::wrapper::Windows::Management::Update::WindowsUpdateApprovalData* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Update.WindowsUpdateApprovalData", L"AllowDownloadOnMetered");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<bool>>(arg);

            {
                auto _gil = release_gil();
                self->obj.AllowDownloadOnMetered(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_WindowsUpdateApprovalData(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Management::Update::WindowsUpdateApprovalData>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_WindowsUpdateApprovalData(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Management::Update::WindowsUpdateApprovalData>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WindowsUpdateApprovalData[] = {
        { "_assign_array_", _assign_array_WindowsUpdateApprovalData, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_WindowsUpdateApprovalData), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_WindowsUpdateApprovalData[] = {
        { "seeker", reinterpret_cast<getter>(WindowsUpdateApprovalData_get_Seeker), reinterpret_cast<setter>(WindowsUpdateApprovalData_put_Seeker), nullptr, nullptr },
        { "opt_out_of_auto_reboot", reinterpret_cast<getter>(WindowsUpdateApprovalData_get_OptOutOfAutoReboot), reinterpret_cast<setter>(WindowsUpdateApprovalData_put_OptOutOfAutoReboot), nullptr, nullptr },
        { "compliance_grace_period_in_days", reinterpret_cast<getter>(WindowsUpdateApprovalData_get_ComplianceGracePeriodInDays), reinterpret_cast<setter>(WindowsUpdateApprovalData_put_ComplianceGracePeriodInDays), nullptr, nullptr },
        { "compliance_deadline_in_days", reinterpret_cast<getter>(WindowsUpdateApprovalData_get_ComplianceDeadlineInDays), reinterpret_cast<setter>(WindowsUpdateApprovalData_put_ComplianceDeadlineInDays), nullptr, nullptr },
        { "allow_download_on_metered", reinterpret_cast<getter>(WindowsUpdateApprovalData_get_AllowDownloadOnMetered), reinterpret_cast<setter>(WindowsUpdateApprovalData_put_AllowDownloadOnMetered), nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_WindowsUpdateApprovalData[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_WindowsUpdateApprovalData) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_WindowsUpdateApprovalData) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_WindowsUpdateApprovalData) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_WindowsUpdateApprovalData) },
        { }};

    static PyType_Spec type_spec_WindowsUpdateApprovalData = {
        "winrt._winrt_windows_management_update.WindowsUpdateApprovalData",
        sizeof(py::wrapper::Windows::Management::Update::WindowsUpdateApprovalData),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WindowsUpdateApprovalData};

    // ----- WindowsUpdateAttentionRequiredInfo class --------------------

    static PyObject* _new_WindowsUpdateAttentionRequiredInfo(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Management::Update::WindowsUpdateAttentionRequiredInfo>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Management::Update::WindowsUpdateAttentionRequiredInfo>::type_name);
        return nullptr;
    }

    static void _dealloc_WindowsUpdateAttentionRequiredInfo(py::wrapper::Windows::Management::Update::WindowsUpdateAttentionRequiredInfo* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* WindowsUpdateAttentionRequiredInfo_get_Reason(py::wrapper::Windows::Management::Update::WindowsUpdateAttentionRequiredInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Update.WindowsUpdateAttentionRequiredInfo", L"Reason");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Reason();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WindowsUpdateAttentionRequiredInfo_get_Timestamp(py::wrapper::Windows::Management::Update::WindowsUpdateAttentionRequiredInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Update.WindowsUpdateAttentionRequiredInfo", L"Timestamp");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Timestamp();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_WindowsUpdateAttentionRequiredInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Management::Update::WindowsUpdateAttentionRequiredInfo>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_WindowsUpdateAttentionRequiredInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Management::Update::WindowsUpdateAttentionRequiredInfo>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WindowsUpdateAttentionRequiredInfo[] = {
        { "_assign_array_", _assign_array_WindowsUpdateAttentionRequiredInfo, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_WindowsUpdateAttentionRequiredInfo), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_WindowsUpdateAttentionRequiredInfo[] = {
        { "reason", reinterpret_cast<getter>(WindowsUpdateAttentionRequiredInfo_get_Reason), nullptr, nullptr, nullptr },
        { "timestamp", reinterpret_cast<getter>(WindowsUpdateAttentionRequiredInfo_get_Timestamp), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_WindowsUpdateAttentionRequiredInfo[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_WindowsUpdateAttentionRequiredInfo) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_WindowsUpdateAttentionRequiredInfo) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_WindowsUpdateAttentionRequiredInfo) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_WindowsUpdateAttentionRequiredInfo) },
        { }};

    static PyType_Spec type_spec_WindowsUpdateAttentionRequiredInfo = {
        "winrt._winrt_windows_management_update.WindowsUpdateAttentionRequiredInfo",
        sizeof(py::wrapper::Windows::Management::Update::WindowsUpdateAttentionRequiredInfo),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WindowsUpdateAttentionRequiredInfo};

    // ----- WindowsUpdateAttentionRequiredReasonChangedEventArgs class --------------------

    static PyObject* _new_WindowsUpdateAttentionRequiredReasonChangedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Management::Update::WindowsUpdateAttentionRequiredReasonChangedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Management::Update::WindowsUpdateAttentionRequiredReasonChangedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_WindowsUpdateAttentionRequiredReasonChangedEventArgs(py::wrapper::Windows::Management::Update::WindowsUpdateAttentionRequiredReasonChangedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* WindowsUpdateAttentionRequiredReasonChangedEventArgs_get_Reason(py::wrapper::Windows::Management::Update::WindowsUpdateAttentionRequiredReasonChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Update.WindowsUpdateAttentionRequiredReasonChangedEventArgs", L"Reason");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Reason();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WindowsUpdateAttentionRequiredReasonChangedEventArgs_get_Update(py::wrapper::Windows::Management::Update::WindowsUpdateAttentionRequiredReasonChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Update.WindowsUpdateAttentionRequiredReasonChangedEventArgs", L"Update");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Update();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_WindowsUpdateAttentionRequiredReasonChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Management::Update::WindowsUpdateAttentionRequiredReasonChangedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_WindowsUpdateAttentionRequiredReasonChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Management::Update::WindowsUpdateAttentionRequiredReasonChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WindowsUpdateAttentionRequiredReasonChangedEventArgs[] = {
        { "_assign_array_", _assign_array_WindowsUpdateAttentionRequiredReasonChangedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_WindowsUpdateAttentionRequiredReasonChangedEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_WindowsUpdateAttentionRequiredReasonChangedEventArgs[] = {
        { "reason", reinterpret_cast<getter>(WindowsUpdateAttentionRequiredReasonChangedEventArgs_get_Reason), nullptr, nullptr, nullptr },
        { "update", reinterpret_cast<getter>(WindowsUpdateAttentionRequiredReasonChangedEventArgs_get_Update), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_WindowsUpdateAttentionRequiredReasonChangedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_WindowsUpdateAttentionRequiredReasonChangedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_WindowsUpdateAttentionRequiredReasonChangedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_WindowsUpdateAttentionRequiredReasonChangedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_WindowsUpdateAttentionRequiredReasonChangedEventArgs) },
        { }};

    static PyType_Spec type_spec_WindowsUpdateAttentionRequiredReasonChangedEventArgs = {
        "winrt._winrt_windows_management_update.WindowsUpdateAttentionRequiredReasonChangedEventArgs",
        sizeof(py::wrapper::Windows::Management::Update::WindowsUpdateAttentionRequiredReasonChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WindowsUpdateAttentionRequiredReasonChangedEventArgs};

    // ----- WindowsUpdateGetAdministratorResult class --------------------

    static PyObject* _new_WindowsUpdateGetAdministratorResult(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Management::Update::WindowsUpdateGetAdministratorResult>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Management::Update::WindowsUpdateGetAdministratorResult>::type_name);
        return nullptr;
    }

    static void _dealloc_WindowsUpdateGetAdministratorResult(py::wrapper::Windows::Management::Update::WindowsUpdateGetAdministratorResult* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* WindowsUpdateGetAdministratorResult_get_Administrator(py::wrapper::Windows::Management::Update::WindowsUpdateGetAdministratorResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Update.WindowsUpdateGetAdministratorResult", L"Administrator");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Administrator();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WindowsUpdateGetAdministratorResult_get_Status(py::wrapper::Windows::Management::Update::WindowsUpdateGetAdministratorResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Update.WindowsUpdateGetAdministratorResult", L"Status");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Status();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_WindowsUpdateGetAdministratorResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Management::Update::WindowsUpdateGetAdministratorResult>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_WindowsUpdateGetAdministratorResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Management::Update::WindowsUpdateGetAdministratorResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WindowsUpdateGetAdministratorResult[] = {
        { "_assign_array_", _assign_array_WindowsUpdateGetAdministratorResult, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_WindowsUpdateGetAdministratorResult), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_WindowsUpdateGetAdministratorResult[] = {
        { "administrator", reinterpret_cast<getter>(WindowsUpdateGetAdministratorResult_get_Administrator), nullptr, nullptr, nullptr },
        { "status", reinterpret_cast<getter>(WindowsUpdateGetAdministratorResult_get_Status), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_WindowsUpdateGetAdministratorResult[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_WindowsUpdateGetAdministratorResult) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_WindowsUpdateGetAdministratorResult) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_WindowsUpdateGetAdministratorResult) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_WindowsUpdateGetAdministratorResult) },
        { }};

    static PyType_Spec type_spec_WindowsUpdateGetAdministratorResult = {
        "winrt._winrt_windows_management_update.WindowsUpdateGetAdministratorResult",
        sizeof(py::wrapper::Windows::Management::Update::WindowsUpdateGetAdministratorResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WindowsUpdateGetAdministratorResult};

    // ----- WindowsUpdateItem class --------------------

    static PyObject* _new_WindowsUpdateItem(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Management::Update::WindowsUpdateItem>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Management::Update::WindowsUpdateItem>::type_name);
        return nullptr;
    }

    static void _dealloc_WindowsUpdateItem(py::wrapper::Windows::Management::Update::WindowsUpdateItem* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* WindowsUpdateItem_get_Category(py::wrapper::Windows::Management::Update::WindowsUpdateItem* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Update.WindowsUpdateItem", L"Category");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Category();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WindowsUpdateItem_get_Description(py::wrapper::Windows::Management::Update::WindowsUpdateItem* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Update.WindowsUpdateItem", L"Description");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Description();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WindowsUpdateItem_get_MoreInfoUrl(py::wrapper::Windows::Management::Update::WindowsUpdateItem* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Update.WindowsUpdateItem", L"MoreInfoUrl");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.MoreInfoUrl();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WindowsUpdateItem_get_Operation(py::wrapper::Windows::Management::Update::WindowsUpdateItem* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Update.WindowsUpdateItem", L"Operation");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Operation();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WindowsUpdateItem_get_ProviderId(py::wrapper::Windows::Management::Update::WindowsUpdateItem* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Update.WindowsUpdateItem", L"ProviderId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ProviderId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WindowsUpdateItem_get_Timestamp(py::wrapper::Windows::Management::Update::WindowsUpdateItem* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Update.WindowsUpdateItem", L"Timestamp");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Timestamp();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WindowsUpdateItem_get_Title(py::wrapper::Windows::Management::Update::WindowsUpdateItem* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Update.WindowsUpdateItem", L"Title");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Title();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WindowsUpdateItem_get_UpdateId(py::wrapper::Windows::Management::Update::WindowsUpdateItem* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Update.WindowsUpdateItem", L"UpdateId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.UpdateId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_WindowsUpdateItem(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Management::Update::WindowsUpdateItem>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_WindowsUpdateItem(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Management::Update::WindowsUpdateItem>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WindowsUpdateItem[] = {
        { "_assign_array_", _assign_array_WindowsUpdateItem, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_WindowsUpdateItem), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_WindowsUpdateItem[] = {
        { "category", reinterpret_cast<getter>(WindowsUpdateItem_get_Category), nullptr, nullptr, nullptr },
        { "description", reinterpret_cast<getter>(WindowsUpdateItem_get_Description), nullptr, nullptr, nullptr },
        { "more_info_url", reinterpret_cast<getter>(WindowsUpdateItem_get_MoreInfoUrl), nullptr, nullptr, nullptr },
        { "operation", reinterpret_cast<getter>(WindowsUpdateItem_get_Operation), nullptr, nullptr, nullptr },
        { "provider_id", reinterpret_cast<getter>(WindowsUpdateItem_get_ProviderId), nullptr, nullptr, nullptr },
        { "timestamp", reinterpret_cast<getter>(WindowsUpdateItem_get_Timestamp), nullptr, nullptr, nullptr },
        { "title", reinterpret_cast<getter>(WindowsUpdateItem_get_Title), nullptr, nullptr, nullptr },
        { "update_id", reinterpret_cast<getter>(WindowsUpdateItem_get_UpdateId), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_WindowsUpdateItem[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_WindowsUpdateItem) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_WindowsUpdateItem) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_WindowsUpdateItem) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_WindowsUpdateItem) },
        { }};

    static PyType_Spec type_spec_WindowsUpdateItem = {
        "winrt._winrt_windows_management_update.WindowsUpdateItem",
        sizeof(py::wrapper::Windows::Management::Update::WindowsUpdateItem),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WindowsUpdateItem};

    // ----- WindowsUpdateManager class --------------------

    static PyObject* _new_WindowsUpdateManager(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                winrt::Windows::Management::Update::WindowsUpdateManager instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_WindowsUpdateManager(py::wrapper::Windows::Management::Update::WindowsUpdateManager* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* WindowsUpdateManager_GetApplicableUpdates(py::wrapper::Windows::Management::Update::WindowsUpdateManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Management.Update.WindowsUpdateManager", L"GetApplicableUpdates", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetApplicableUpdates();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* WindowsUpdateManager_GetMostRecentCompletedUpdates(py::wrapper::Windows::Management::Update::WindowsUpdateManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Management.Update.WindowsUpdateManager", L"GetMostRecentCompletedUpdates", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<int32_t>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetMostRecentCompletedUpdates(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* WindowsUpdateManager_GetMostRecentCompletedUpdatesAsync(py::wrapper::Windows::Management::Update::WindowsUpdateManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Management.Update.WindowsUpdateManager", L"GetMostRecentCompletedUpdatesAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<int32_t>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetMostRecentCompletedUpdatesAsync(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* WindowsUpdateManager_StartScan(py::wrapper::Windows::Management::Update::WindowsUpdateManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Management.Update.WindowsUpdateManager", L"StartScan", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<bool>(args, 0);

                {
                    auto _gil = release_gil();
                    self->obj.StartScan(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* WindowsUpdateManager_get_IsScanning(py::wrapper::Windows::Management::Update::WindowsUpdateManager* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Update.WindowsUpdateManager", L"IsScanning");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsScanning();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WindowsUpdateManager_get_IsWorking(py::wrapper::Windows::Management::Update::WindowsUpdateManager* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Update.WindowsUpdateManager", L"IsWorking");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsWorking();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WindowsUpdateManager_get_LastSuccessfulScanTimestamp(py::wrapper::Windows::Management::Update::WindowsUpdateManager* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Update.WindowsUpdateManager", L"LastSuccessfulScanTimestamp");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.LastSuccessfulScanTimestamp();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WindowsUpdateManager_add_ActionCompleted(py::wrapper::Windows::Management::Update::WindowsUpdateManager* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Management.Update.WindowsUpdateManager", L"ActionCompleted");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Management::Update::WindowsUpdateManager, winrt::Windows::Management::Update::WindowsUpdateActionCompletedEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ActionCompleted(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WindowsUpdateManager_remove_ActionCompleted(py::wrapper::Windows::Management::Update::WindowsUpdateManager* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Management.Update.WindowsUpdateManager", L"ActionCompleted");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.ActionCompleted(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WindowsUpdateManager_add_AttentionRequiredReasonChanged(py::wrapper::Windows::Management::Update::WindowsUpdateManager* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Management.Update.WindowsUpdateManager", L"AttentionRequiredReasonChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Management::Update::WindowsUpdateManager, winrt::Windows::Management::Update::WindowsUpdateAttentionRequiredReasonChangedEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.AttentionRequiredReasonChanged(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WindowsUpdateManager_remove_AttentionRequiredReasonChanged(py::wrapper::Windows::Management::Update::WindowsUpdateManager* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Management.Update.WindowsUpdateManager", L"AttentionRequiredReasonChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.AttentionRequiredReasonChanged(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WindowsUpdateManager_add_ProgressChanged(py::wrapper::Windows::Management::Update::WindowsUpdateManager* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Management.Update.WindowsUpdateManager", L"ProgressChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Management::Update::WindowsUpdateManager, winrt::Windows::Management::Update::WindowsUpdateProgressChangedEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ProgressChanged(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WindowsUpdateManager_remove_ProgressChanged(py::wrapper::Windows::Management::Update::WindowsUpdateManager* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Management.Update.WindowsUpdateManager", L"ProgressChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.ProgressChanged(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WindowsUpdateManager_add_ScanCompleted(py::wrapper::Windows::Management::Update::WindowsUpdateManager* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Management.Update.WindowsUpdateManager", L"ScanCompleted");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Management::Update::WindowsUpdateManager, winrt::Windows::Management::Update::WindowsUpdateScanCompletedEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ScanCompleted(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WindowsUpdateManager_remove_ScanCompleted(py::wrapper::Windows::Management::Update::WindowsUpdateManager* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Management.Update.WindowsUpdateManager", L"ScanCompleted");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.ScanCompleted(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WindowsUpdateManager_add_ScanningStateChanged(py::wrapper::Windows::Management::Update::WindowsUpdateManager* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Management.Update.WindowsUpdateManager", L"ScanningStateChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Management::Update::WindowsUpdateManager, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ScanningStateChanged(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WindowsUpdateManager_remove_ScanningStateChanged(py::wrapper::Windows::Management::Update::WindowsUpdateManager* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Management.Update.WindowsUpdateManager", L"ScanningStateChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.ScanningStateChanged(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WindowsUpdateManager_add_WorkingStateChanged(py::wrapper::Windows::Management::Update::WindowsUpdateManager* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Management.Update.WindowsUpdateManager", L"WorkingStateChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Management::Update::WindowsUpdateManager, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.WorkingStateChanged(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WindowsUpdateManager_remove_WorkingStateChanged(py::wrapper::Windows::Management::Update::WindowsUpdateManager* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Management.Update.WindowsUpdateManager", L"WorkingStateChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.WorkingStateChanged(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_WindowsUpdateManager(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Management::Update::WindowsUpdateManager>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_WindowsUpdateManager(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Management::Update::WindowsUpdateManager>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WindowsUpdateManager[] = {
        { "get_applicable_updates", reinterpret_cast<PyCFunction>(WindowsUpdateManager_GetApplicableUpdates), METH_VARARGS, nullptr },
        { "get_most_recent_completed_updates", reinterpret_cast<PyCFunction>(WindowsUpdateManager_GetMostRecentCompletedUpdates), METH_VARARGS, nullptr },
        { "get_most_recent_completed_updates_async", reinterpret_cast<PyCFunction>(WindowsUpdateManager_GetMostRecentCompletedUpdatesAsync), METH_VARARGS, nullptr },
        { "start_scan", reinterpret_cast<PyCFunction>(WindowsUpdateManager_StartScan), METH_VARARGS, nullptr },
        { "add_action_completed", reinterpret_cast<PyCFunction>(WindowsUpdateManager_add_ActionCompleted), METH_O, nullptr },
        { "remove_action_completed", reinterpret_cast<PyCFunction>(WindowsUpdateManager_remove_ActionCompleted), METH_O, nullptr },
        { "add_attention_required_reason_changed", reinterpret_cast<PyCFunction>(WindowsUpdateManager_add_AttentionRequiredReasonChanged), METH_O, nullptr },
        { "remove_attention_required_reason_changed", reinterpret_cast<PyCFunction>(WindowsUpdateManager_remove_AttentionRequiredReasonChanged), METH_O, nullptr },
        { "add_progress_changed", reinterpret_cast<PyCFunction>(WindowsUpdateManager_add_ProgressChanged), METH_O, nullptr },
        { "remove_progress_changed", reinterpret_cast<PyCFunction>(WindowsUpdateManager_remove_ProgressChanged), METH_O, nullptr },
        { "add_scan_completed", reinterpret_cast<PyCFunction>(WindowsUpdateManager_add_ScanCompleted), METH_O, nullptr },
        { "remove_scan_completed", reinterpret_cast<PyCFunction>(WindowsUpdateManager_remove_ScanCompleted), METH_O, nullptr },
        { "add_scanning_state_changed", reinterpret_cast<PyCFunction>(WindowsUpdateManager_add_ScanningStateChanged), METH_O, nullptr },
        { "remove_scanning_state_changed", reinterpret_cast<PyCFunction>(WindowsUpdateManager_remove_ScanningStateChanged), METH_O, nullptr },
        { "add_working_state_changed", reinterpret_cast<PyCFunction>(WindowsUpdateManager_add_WorkingStateChanged), METH_O, nullptr },
        { "remove_working_state_changed", reinterpret_cast<PyCFunction>(WindowsUpdateManager_remove_WorkingStateChanged), METH_O, nullptr },
        { "_assign_array_", _assign_array_WindowsUpdateManager, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_WindowsUpdateManager), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_WindowsUpdateManager[] = {
        { "is_scanning", reinterpret_cast<getter>(WindowsUpdateManager_get_IsScanning), nullptr, nullptr, nullptr },
        { "is_working", reinterpret_cast<getter>(WindowsUpdateManager_get_IsWorking), nullptr, nullptr, nullptr },
        { "last_successful_scan_timestamp", reinterpret_cast<getter>(WindowsUpdateManager_get_LastSuccessfulScanTimestamp), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_WindowsUpdateManager[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_WindowsUpdateManager) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_WindowsUpdateManager) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_WindowsUpdateManager) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_WindowsUpdateManager) },
        { }};

    static PyType_Spec type_spec_WindowsUpdateManager = {
        "winrt._winrt_windows_management_update.WindowsUpdateManager",
        sizeof(py::wrapper::Windows::Management::Update::WindowsUpdateManager),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WindowsUpdateManager};

    // ----- WindowsUpdateProgressChangedEventArgs class --------------------

    static PyObject* _new_WindowsUpdateProgressChangedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Management::Update::WindowsUpdateProgressChangedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Management::Update::WindowsUpdateProgressChangedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_WindowsUpdateProgressChangedEventArgs(py::wrapper::Windows::Management::Update::WindowsUpdateProgressChangedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* WindowsUpdateProgressChangedEventArgs_get_ActionProgress(py::wrapper::Windows::Management::Update::WindowsUpdateProgressChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Update.WindowsUpdateProgressChangedEventArgs", L"ActionProgress");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ActionProgress();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WindowsUpdateProgressChangedEventArgs_get_Update(py::wrapper::Windows::Management::Update::WindowsUpdateProgressChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Update.WindowsUpdateProgressChangedEventArgs", L"Update");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Update();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_WindowsUpdateProgressChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Management::Update::WindowsUpdateProgressChangedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_WindowsUpdateProgressChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Management::Update::WindowsUpdateProgressChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WindowsUpdateProgressChangedEventArgs[] = {
        { "_assign_array_", _assign_array_WindowsUpdateProgressChangedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_WindowsUpdateProgressChangedEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_WindowsUpdateProgressChangedEventArgs[] = {
        { "action_progress", reinterpret_cast<getter>(WindowsUpdateProgressChangedEventArgs_get_ActionProgress), nullptr, nullptr, nullptr },
        { "update", reinterpret_cast<getter>(WindowsUpdateProgressChangedEventArgs_get_Update), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_WindowsUpdateProgressChangedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_WindowsUpdateProgressChangedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_WindowsUpdateProgressChangedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_WindowsUpdateProgressChangedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_WindowsUpdateProgressChangedEventArgs) },
        { }};

    static PyType_Spec type_spec_WindowsUpdateProgressChangedEventArgs = {
        "winrt._winrt_windows_management_update.WindowsUpdateProgressChangedEventArgs",
        sizeof(py::wrapper::Windows::Management::Update::WindowsUpdateProgressChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WindowsUpdateProgressChangedEventArgs};

    // ----- WindowsUpdateRestartRequestOptions class --------------------

    static PyObject* _new_WindowsUpdateRestartRequestOptions(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);
        if (arg_count == 5)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 2);
                auto param3 = py::convert_to<int32_t>(args, 3);
                auto param4 = py::convert_to<int32_t>(args, 4);

                winrt::Windows::Management::Update::WindowsUpdateRestartRequestOptions instance{param0, param1, param2, param3, param4};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Management::Update::WindowsUpdateRestartRequestOptions instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_WindowsUpdateRestartRequestOptions(py::wrapper::Windows::Management::Update::WindowsUpdateRestartRequestOptions* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* WindowsUpdateRestartRequestOptions_get_Title(py::wrapper::Windows::Management::Update::WindowsUpdateRestartRequestOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Update.WindowsUpdateRestartRequestOptions", L"Title");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Title();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int WindowsUpdateRestartRequestOptions_put_Title(py::wrapper::Windows::Management::Update::WindowsUpdateRestartRequestOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Update.WindowsUpdateRestartRequestOptions", L"Title");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            {
                auto _gil = release_gil();
                self->obj.Title(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* WindowsUpdateRestartRequestOptions_get_OrganizationName(py::wrapper::Windows::Management::Update::WindowsUpdateRestartRequestOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Update.WindowsUpdateRestartRequestOptions", L"OrganizationName");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.OrganizationName();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int WindowsUpdateRestartRequestOptions_put_OrganizationName(py::wrapper::Windows::Management::Update::WindowsUpdateRestartRequestOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Update.WindowsUpdateRestartRequestOptions", L"OrganizationName");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            {
                auto _gil = release_gil();
                self->obj.OrganizationName(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* WindowsUpdateRestartRequestOptions_get_OptOutOfAutoReboot(py::wrapper::Windows::Management::Update::WindowsUpdateRestartRequestOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Update.WindowsUpdateRestartRequestOptions", L"OptOutOfAutoReboot");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.OptOutOfAutoReboot();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int WindowsUpdateRestartRequestOptions_put_OptOutOfAutoReboot(py::wrapper::Windows::Management::Update::WindowsUpdateRestartRequestOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Update.WindowsUpdateRestartRequestOptions", L"OptOutOfAutoReboot");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.OptOutOfAutoReboot(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* WindowsUpdateRestartRequestOptions_get_MoreInfoUrl(py::wrapper::Windows::Management::Update::WindowsUpdateRestartRequestOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Update.WindowsUpdateRestartRequestOptions", L"MoreInfoUrl");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.MoreInfoUrl();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int WindowsUpdateRestartRequestOptions_put_MoreInfoUrl(py::wrapper::Windows::Management::Update::WindowsUpdateRestartRequestOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Update.WindowsUpdateRestartRequestOptions", L"MoreInfoUrl");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(arg);

            {
                auto _gil = release_gil();
                self->obj.MoreInfoUrl(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* WindowsUpdateRestartRequestOptions_get_Description(py::wrapper::Windows::Management::Update::WindowsUpdateRestartRequestOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Update.WindowsUpdateRestartRequestOptions", L"Description");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Description();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int WindowsUpdateRestartRequestOptions_put_Description(py::wrapper::Windows::Management::Update::WindowsUpdateRestartRequestOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Update.WindowsUpdateRestartRequestOptions", L"Description");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            {
                auto _gil = release_gil();
                self->obj.Description(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* WindowsUpdateRestartRequestOptions_get_ComplianceGracePeriodInDays(py::wrapper::Windows::Management::Update::WindowsUpdateRestartRequestOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Update.WindowsUpdateRestartRequestOptions", L"ComplianceGracePeriodInDays");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ComplianceGracePeriodInDays();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int WindowsUpdateRestartRequestOptions_put_ComplianceGracePeriodInDays(py::wrapper::Windows::Management::Update::WindowsUpdateRestartRequestOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Update.WindowsUpdateRestartRequestOptions", L"ComplianceGracePeriodInDays");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<int32_t>(arg);

            {
                auto _gil = release_gil();
                self->obj.ComplianceGracePeriodInDays(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* WindowsUpdateRestartRequestOptions_get_ComplianceDeadlineInDays(py::wrapper::Windows::Management::Update::WindowsUpdateRestartRequestOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Update.WindowsUpdateRestartRequestOptions", L"ComplianceDeadlineInDays");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ComplianceDeadlineInDays();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int WindowsUpdateRestartRequestOptions_put_ComplianceDeadlineInDays(py::wrapper::Windows::Management::Update::WindowsUpdateRestartRequestOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Update.WindowsUpdateRestartRequestOptions", L"ComplianceDeadlineInDays");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<int32_t>(arg);

            {
                auto _gil = release_gil();
                self->obj.ComplianceDeadlineInDays(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_WindowsUpdateRestartRequestOptions(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Management::Update::WindowsUpdateRestartRequestOptions>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_WindowsUpdateRestartRequestOptions(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Management::Update::WindowsUpdateRestartRequestOptions>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WindowsUpdateRestartRequestOptions[] = {
        { "_assign_array_", _assign_array_WindowsUpdateRestartRequestOptions, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_WindowsUpdateRestartRequestOptions), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_WindowsUpdateRestartRequestOptions[] = {
        { "title", reinterpret_cast<getter>(WindowsUpdateRestartRequestOptions_get_Title), reinterpret_cast<setter>(WindowsUpdateRestartRequestOptions_put_Title), nullptr, nullptr },
        { "organization_name", reinterpret_cast<getter>(WindowsUpdateRestartRequestOptions_get_OrganizationName), reinterpret_cast<setter>(WindowsUpdateRestartRequestOptions_put_OrganizationName), nullptr, nullptr },
        { "opt_out_of_auto_reboot", reinterpret_cast<getter>(WindowsUpdateRestartRequestOptions_get_OptOutOfAutoReboot), reinterpret_cast<setter>(WindowsUpdateRestartRequestOptions_put_OptOutOfAutoReboot), nullptr, nullptr },
        { "more_info_url", reinterpret_cast<getter>(WindowsUpdateRestartRequestOptions_get_MoreInfoUrl), reinterpret_cast<setter>(WindowsUpdateRestartRequestOptions_put_MoreInfoUrl), nullptr, nullptr },
        { "description", reinterpret_cast<getter>(WindowsUpdateRestartRequestOptions_get_Description), reinterpret_cast<setter>(WindowsUpdateRestartRequestOptions_put_Description), nullptr, nullptr },
        { "compliance_grace_period_in_days", reinterpret_cast<getter>(WindowsUpdateRestartRequestOptions_get_ComplianceGracePeriodInDays), reinterpret_cast<setter>(WindowsUpdateRestartRequestOptions_put_ComplianceGracePeriodInDays), nullptr, nullptr },
        { "compliance_deadline_in_days", reinterpret_cast<getter>(WindowsUpdateRestartRequestOptions_get_ComplianceDeadlineInDays), reinterpret_cast<setter>(WindowsUpdateRestartRequestOptions_put_ComplianceDeadlineInDays), nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_WindowsUpdateRestartRequestOptions[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_WindowsUpdateRestartRequestOptions) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_WindowsUpdateRestartRequestOptions) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_WindowsUpdateRestartRequestOptions) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_WindowsUpdateRestartRequestOptions) },
        { }};

    static PyType_Spec type_spec_WindowsUpdateRestartRequestOptions = {
        "winrt._winrt_windows_management_update.WindowsUpdateRestartRequestOptions",
        sizeof(py::wrapper::Windows::Management::Update::WindowsUpdateRestartRequestOptions),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WindowsUpdateRestartRequestOptions};

    // ----- WindowsUpdateScanCompletedEventArgs class --------------------

    static PyObject* _new_WindowsUpdateScanCompletedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Management::Update::WindowsUpdateScanCompletedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Management::Update::WindowsUpdateScanCompletedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_WindowsUpdateScanCompletedEventArgs(py::wrapper::Windows::Management::Update::WindowsUpdateScanCompletedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* WindowsUpdateScanCompletedEventArgs_get_ExtendedError(py::wrapper::Windows::Management::Update::WindowsUpdateScanCompletedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Update.WindowsUpdateScanCompletedEventArgs", L"ExtendedError");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ExtendedError();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WindowsUpdateScanCompletedEventArgs_get_ProviderId(py::wrapper::Windows::Management::Update::WindowsUpdateScanCompletedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Update.WindowsUpdateScanCompletedEventArgs", L"ProviderId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ProviderId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WindowsUpdateScanCompletedEventArgs_get_Succeeded(py::wrapper::Windows::Management::Update::WindowsUpdateScanCompletedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Update.WindowsUpdateScanCompletedEventArgs", L"Succeeded");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Succeeded();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WindowsUpdateScanCompletedEventArgs_get_Updates(py::wrapper::Windows::Management::Update::WindowsUpdateScanCompletedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Management.Update.WindowsUpdateScanCompletedEventArgs", L"Updates");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Updates();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_WindowsUpdateScanCompletedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Management::Update::WindowsUpdateScanCompletedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_WindowsUpdateScanCompletedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Management::Update::WindowsUpdateScanCompletedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WindowsUpdateScanCompletedEventArgs[] = {
        { "_assign_array_", _assign_array_WindowsUpdateScanCompletedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_WindowsUpdateScanCompletedEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_WindowsUpdateScanCompletedEventArgs[] = {
        { "extended_error", reinterpret_cast<getter>(WindowsUpdateScanCompletedEventArgs_get_ExtendedError), nullptr, nullptr, nullptr },
        { "provider_id", reinterpret_cast<getter>(WindowsUpdateScanCompletedEventArgs_get_ProviderId), nullptr, nullptr, nullptr },
        { "succeeded", reinterpret_cast<getter>(WindowsUpdateScanCompletedEventArgs_get_Succeeded), nullptr, nullptr, nullptr },
        { "updates", reinterpret_cast<getter>(WindowsUpdateScanCompletedEventArgs_get_Updates), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_WindowsUpdateScanCompletedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_WindowsUpdateScanCompletedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_WindowsUpdateScanCompletedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_WindowsUpdateScanCompletedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_WindowsUpdateScanCompletedEventArgs) },
        { }};

    static PyType_Spec type_spec_WindowsUpdateScanCompletedEventArgs = {
        "winrt._winrt_windows_management_update.WindowsUpdateScanCompletedEventArgs",
        sizeof(py::wrapper::Windows::Management::Update::WindowsUpdateScanCompletedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WindowsUpdateScanCompletedEventArgs};

    // ----- Windows.Management.Update Initialization --------------------

    PyDoc_STRVAR(module_doc, "Windows.Management.Update");

    static PyModuleDef module_def = {
        PyModuleDef_HEAD_INIT,
        "_winrt_windows_management_update",
        module_doc,
        0,
        nullptr,
        nullptr,
        nullptr,
        nullptr,
        nullptr};
} // py::cpp::Windows::Management::Update

PyMODINIT_FUNC PyInit__winrt_windows_management_update(void) noexcept
{
    using namespace py::cpp::Windows::Management::Update;

    if (py::import_winrt_runtime() == -1)
    {
        return nullptr;
    }

    py::pyobj_handle module{PyModule_Create(&module_def)};

    if (!module)
    {
        return nullptr;
    }

    auto inspectable_meta_type = py::get_inspectable_meta_type();
    if (!inspectable_meta_type)
    {
        return nullptr;
    }

    auto object_type = py::get_object_type();
    if (!object_type)
    {
        return nullptr;
    }

    py::pyobj_handle object_bases{PyTuple_Pack(1, object_type)};

    if (!object_bases)
    {
        return nullptr;
    }

    py::pyobj_handle PreviewBuildsManager_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(inspectable_meta_type))};
    if (!PreviewBuildsManager_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_PreviewBuildsManager_Static{PyType_FromSpecWithBases(&type_spec_PreviewBuildsManager_Static, PreviewBuildsManager_Static_bases.get())};
    if (!type_PreviewBuildsManager_Static)
    {
        return nullptr;
    }

    py::pytype_handle PreviewBuildsManager_type{py::register_python_type(module.get(), &type_spec_PreviewBuildsManager, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_PreviewBuildsManager_Static.get()))};
    if (!PreviewBuildsManager_type)
    {
        return nullptr;
    }

    py::pytype_handle PreviewBuildsState_type{py::register_python_type(module.get(), &type_spec_PreviewBuildsState, object_bases.get(), inspectable_meta_type)};
    if (!PreviewBuildsState_type)
    {
        return nullptr;
    }

    py::pytype_handle WindowsUpdate_type{py::register_python_type(module.get(), &type_spec_WindowsUpdate, object_bases.get(), inspectable_meta_type)};
    if (!WindowsUpdate_type)
    {
        return nullptr;
    }

    py::pytype_handle WindowsUpdateActionCompletedEventArgs_type{py::register_python_type(module.get(), &type_spec_WindowsUpdateActionCompletedEventArgs, object_bases.get(), inspectable_meta_type)};
    if (!WindowsUpdateActionCompletedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle WindowsUpdateActionProgress_type{py::register_python_type(module.get(), &type_spec_WindowsUpdateActionProgress, object_bases.get(), inspectable_meta_type)};
    if (!WindowsUpdateActionProgress_type)
    {
        return nullptr;
    }

    py::pytype_handle WindowsUpdateActionResult_type{py::register_python_type(module.get(), &type_spec_WindowsUpdateActionResult, object_bases.get(), inspectable_meta_type)};
    if (!WindowsUpdateActionResult_type)
    {
        return nullptr;
    }

    py::pyobj_handle WindowsUpdateAdministrator_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(inspectable_meta_type))};
    if (!WindowsUpdateAdministrator_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_WindowsUpdateAdministrator_Static{PyType_FromSpecWithBases(&type_spec_WindowsUpdateAdministrator_Static, WindowsUpdateAdministrator_Static_bases.get())};
    if (!type_WindowsUpdateAdministrator_Static)
    {
        return nullptr;
    }

    py::pytype_handle WindowsUpdateAdministrator_type{py::register_python_type(module.get(), &type_spec_WindowsUpdateAdministrator, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_WindowsUpdateAdministrator_Static.get()))};
    if (!WindowsUpdateAdministrator_type)
    {
        return nullptr;
    }

    py::pytype_handle WindowsUpdateApprovalData_type{py::register_python_type(module.get(), &type_spec_WindowsUpdateApprovalData, object_bases.get(), inspectable_meta_type)};
    if (!WindowsUpdateApprovalData_type)
    {
        return nullptr;
    }

    py::pytype_handle WindowsUpdateAttentionRequiredInfo_type{py::register_python_type(module.get(), &type_spec_WindowsUpdateAttentionRequiredInfo, object_bases.get(), inspectable_meta_type)};
    if (!WindowsUpdateAttentionRequiredInfo_type)
    {
        return nullptr;
    }

    py::pytype_handle WindowsUpdateAttentionRequiredReasonChangedEventArgs_type{py::register_python_type(module.get(), &type_spec_WindowsUpdateAttentionRequiredReasonChangedEventArgs, object_bases.get(), inspectable_meta_type)};
    if (!WindowsUpdateAttentionRequiredReasonChangedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle WindowsUpdateGetAdministratorResult_type{py::register_python_type(module.get(), &type_spec_WindowsUpdateGetAdministratorResult, object_bases.get(), inspectable_meta_type)};
    if (!WindowsUpdateGetAdministratorResult_type)
    {
        return nullptr;
    }

    py::pytype_handle WindowsUpdateItem_type{py::register_python_type(module.get(), &type_spec_WindowsUpdateItem, object_bases.get(), inspectable_meta_type)};
    if (!WindowsUpdateItem_type)
    {
        return nullptr;
    }

    py::pytype_handle WindowsUpdateManager_type{py::register_python_type(module.get(), &type_spec_WindowsUpdateManager, object_bases.get(), inspectable_meta_type)};
    if (!WindowsUpdateManager_type)
    {
        return nullptr;
    }

    py::pytype_handle WindowsUpdateProgressChangedEventArgs_type{py::register_python_type(module.get(), &type_spec_WindowsUpdateProgressChangedEventArgs, object_bases.get(), inspectable_meta_type)};
    if (!WindowsUpdateProgressChangedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle WindowsUpdateRestartRequestOptions_type{py::register_python_type(module.get(), &type_spec_WindowsUpdateRestartRequestOptions, object_bases.get(), inspectable_meta_type)};
    if (!WindowsUpdateRestartRequestOptions_type)
    {
        return nullptr;
    }

    py::pytype_handle WindowsUpdateScanCompletedEventArgs_type{py::register_python_type(module.get(), &type_spec_WindowsUpdateScanCompletedEventArgs, object_bases.get(), inspectable_meta_type)};
    if (!WindowsUpdateScanCompletedEventArgs_type)
    {
        return nullptr;
    }


    return module.detach();
}
