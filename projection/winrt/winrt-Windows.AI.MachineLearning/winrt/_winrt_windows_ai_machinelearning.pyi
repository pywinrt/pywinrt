# WARNING: Please don't edit this file. It was generated by Python/WinRT v3.2.1

import datetime
import sys
import types
import typing
import uuid as _uuid
from builtins import property as _property
from abc import abstractmethod

import winrt._winrt
import winrt.system
import winrt.windows.foundation as windows_foundation
import winrt.windows.foundation.collections as windows_foundation_collections
import winrt.windows.graphics as windows_graphics
import winrt.windows.graphics.directx.direct3d11 as windows_graphics_directx_direct3d11
import winrt.windows.graphics.imaging as windows_graphics_imaging
import winrt.windows.media as windows_media
import winrt.windows.storage as windows_storage
import winrt.windows.storage.streams as windows_storage_streams

from winrt.windows.ai.machinelearning import LearningModelDeviceKind, LearningModelFeatureKind, LearningModelPixelRange, TensorKind

Self = typing.TypeVar('Self')

@typing.final
class ImageFeatureDescriptor(winrt.system.Object, ILearningModelFeatureDescriptor):
    # Windows.Graphics.Imaging.BitmapAlphaMode Windows.AI.MachineLearning.ImageFeatureDescriptor::get_BitmapAlphaMode()
    @_property
    def bitmap_alpha_mode(self) -> windows_graphics_imaging.BitmapAlphaMode: ...
    # Windows.Graphics.Imaging.BitmapPixelFormat Windows.AI.MachineLearning.ImageFeatureDescriptor::get_BitmapPixelFormat()
    @_property
    def bitmap_pixel_format(self) -> windows_graphics_imaging.BitmapPixelFormat: ...
    # System.UInt32 Windows.AI.MachineLearning.ImageFeatureDescriptor::get_Height()
    @_property
    def height(self) -> winrt.system.UInt32: ...
    # System.UInt32 Windows.AI.MachineLearning.ImageFeatureDescriptor::get_Width()
    @_property
    def width(self) -> winrt.system.UInt32: ...
    # Windows.AI.MachineLearning.LearningModelPixelRange Windows.AI.MachineLearning.ImageFeatureDescriptor::get_PixelRange()
    @_property
    def pixel_range(self) -> LearningModelPixelRange: ...
    # System.String Windows.AI.MachineLearning.ImageFeatureDescriptor::get_Description()
    @_property
    def description(self) -> str: ...
    # System.Boolean Windows.AI.MachineLearning.ImageFeatureDescriptor::get_IsRequired()
    @_property
    def is_required(self) -> bool: ...
    # Windows.AI.MachineLearning.LearningModelFeatureKind Windows.AI.MachineLearning.ImageFeatureDescriptor::get_Kind()
    @_property
    def kind(self) -> LearningModelFeatureKind: ...
    # System.String Windows.AI.MachineLearning.ImageFeatureDescriptor::get_Name()
    @_property
    def name(self) -> str: ...

@typing.final
class ImageFeatureValue_Static(winrt._winrt.IInspectable_Static):
    # Windows.AI.MachineLearning.ImageFeatureValue Windows.AI.MachineLearning.ImageFeatureValue::CreateFromVideoFrame(Windows.Media.VideoFrame)
    def create_from_video_frame(cls, image: windows_media.VideoFrame, /) -> ImageFeatureValue: ...

@typing.final
class ImageFeatureValue(winrt.system.Object, ILearningModelFeatureValue, metaclass=ImageFeatureValue_Static):
    # Windows.Media.VideoFrame Windows.AI.MachineLearning.ImageFeatureValue::get_VideoFrame()
    @_property
    def video_frame(self) -> windows_media.VideoFrame: ...
    # Windows.AI.MachineLearning.LearningModelFeatureKind Windows.AI.MachineLearning.ImageFeatureValue::get_Kind()
    @_property
    def kind(self) -> LearningModelFeatureKind: ...

@typing.final
class LearningModel_Static(winrt._winrt.IInspectable_Static):
    # Windows.AI.MachineLearning.LearningModel Windows.AI.MachineLearning.LearningModel::LoadFromFilePath(System.String)
    def load_from_file_path(cls, file_path: str, /) -> LearningModel: ...
    # Windows.AI.MachineLearning.LearningModel Windows.AI.MachineLearning.LearningModel::LoadFromFilePath(System.String,Windows.AI.MachineLearning.ILearningModelOperatorProvider)
    def load_from_file_path_with_operator_provider(cls, file_path: str, operator_provider: ILearningModelOperatorProvider, /) -> LearningModel: ...
    # Windows.Foundation.IAsyncOperation`1<Windows.AI.MachineLearning.LearningModel> Windows.AI.MachineLearning.LearningModel::LoadFromStorageFileAsync(Windows.Storage.IStorageFile)
    def load_from_storage_file_async(cls, model_file: windows_storage.IStorageFile, /) -> windows_foundation.IAsyncOperation[LearningModel]: ...
    # Windows.Foundation.IAsyncOperation`1<Windows.AI.MachineLearning.LearningModel> Windows.AI.MachineLearning.LearningModel::LoadFromStorageFileAsync(Windows.Storage.IStorageFile,Windows.AI.MachineLearning.ILearningModelOperatorProvider)
    def load_from_storage_file_with_operator_provider_async(cls, model_file: windows_storage.IStorageFile, operator_provider: ILearningModelOperatorProvider, /) -> windows_foundation.IAsyncOperation[LearningModel]: ...
    # Windows.AI.MachineLearning.LearningModel Windows.AI.MachineLearning.LearningModel::LoadFromStream(Windows.Storage.Streams.IRandomAccessStreamReference)
    def load_from_stream(cls, model_stream: windows_storage_streams.IRandomAccessStreamReference, /) -> LearningModel: ...
    # Windows.Foundation.IAsyncOperation`1<Windows.AI.MachineLearning.LearningModel> Windows.AI.MachineLearning.LearningModel::LoadFromStreamAsync(Windows.Storage.Streams.IRandomAccessStreamReference)
    def load_from_stream_async(cls, model_stream: windows_storage_streams.IRandomAccessStreamReference, /) -> windows_foundation.IAsyncOperation[LearningModel]: ...
    # Windows.AI.MachineLearning.LearningModel Windows.AI.MachineLearning.LearningModel::LoadFromStream(Windows.Storage.Streams.IRandomAccessStreamReference,Windows.AI.MachineLearning.ILearningModelOperatorProvider)
    def load_from_stream_with_operator_provider(cls, model_stream: windows_storage_streams.IRandomAccessStreamReference, operator_provider: ILearningModelOperatorProvider, /) -> LearningModel: ...
    # Windows.Foundation.IAsyncOperation`1<Windows.AI.MachineLearning.LearningModel> Windows.AI.MachineLearning.LearningModel::LoadFromStreamAsync(Windows.Storage.Streams.IRandomAccessStreamReference,Windows.AI.MachineLearning.ILearningModelOperatorProvider)
    def load_from_stream_with_operator_provider_async(cls, model_stream: windows_storage_streams.IRandomAccessStreamReference, operator_provider: ILearningModelOperatorProvider, /) -> windows_foundation.IAsyncOperation[LearningModel]: ...

@typing.final
class LearningModel(winrt.system.Object, windows_foundation.IClosable, metaclass=LearningModel_Static):
    def __enter__(self: Self) -> Self: ...
    def __exit__(self, exc_type: typing.Optional[typing.Type[BaseException]], exc_value: typing.Optional[BaseException], traceback: typing.Optional[types.TracebackType]) -> None: ...
    # System.Void Windows.AI.MachineLearning.LearningModel::Close()
    def close(self) -> None: ...
    # System.String Windows.AI.MachineLearning.LearningModel::get_Author()
    @_property
    def author(self) -> str: ...
    # System.String Windows.AI.MachineLearning.LearningModel::get_Description()
    @_property
    def description(self) -> str: ...
    # System.String Windows.AI.MachineLearning.LearningModel::get_Domain()
    @_property
    def domain(self) -> str: ...
    # Windows.Foundation.Collections.IVectorView`1<Windows.AI.MachineLearning.ILearningModelFeatureDescriptor> Windows.AI.MachineLearning.LearningModel::get_InputFeatures()
    @_property
    def input_features(self) -> typing.Sequence[ILearningModelFeatureDescriptor]: ...
    # Windows.Foundation.Collections.IMapView`2<System.String,System.String> Windows.AI.MachineLearning.LearningModel::get_Metadata()
    @_property
    def metadata(self) -> typing.Mapping[str, str]: ...
    # System.String Windows.AI.MachineLearning.LearningModel::get_Name()
    @_property
    def name(self) -> str: ...
    # Windows.Foundation.Collections.IVectorView`1<Windows.AI.MachineLearning.ILearningModelFeatureDescriptor> Windows.AI.MachineLearning.LearningModel::get_OutputFeatures()
    @_property
    def output_features(self) -> typing.Sequence[ILearningModelFeatureDescriptor]: ...
    # System.Int64 Windows.AI.MachineLearning.LearningModel::get_Version()
    @_property
    def version(self) -> winrt.system.Int64: ...

@typing.final
class LearningModelBinding(winrt.system.Object, winrt._winrt.Mapping[str, winrt.system.Object]):
    def __len__(self) -> int: ...
    def __iter__(self) -> typing.Iterator[str]: ...
    def __contains__(self, key: object) -> bool: ...
    def __getitem__(self, key: str) -> winrt.system.Object: ...
    def __new__(cls: typing.Type[Self], session: LearningModelSession) -> Self: ...
    # System.Void Windows.AI.MachineLearning.LearningModelBinding::Bind(System.String,System.Object)
    def bind(self, name: str, value: winrt.system.Object, /) -> None: ...
    # System.Void Windows.AI.MachineLearning.LearningModelBinding::Bind(System.String,System.Object,Windows.Foundation.Collections.IPropertySet)
    def bind_with_properties(self, name: str, value: winrt.system.Object, props: windows_foundation_collections.IPropertySet, /) -> None: ...
    # System.Void Windows.AI.MachineLearning.LearningModelBinding::Clear()
    def clear(self) -> None: ...
    # Windows.Foundation.Collections.IIterator`1<Windows.Foundation.Collections.IKeyValuePair`2<System.String,System.Object>> Windows.AI.MachineLearning.LearningModelBinding::First()
    def first(self) -> windows_foundation_collections.IIterator[windows_foundation_collections.IKeyValuePair[str, winrt.system.Object]]: ...
    # System.Boolean Windows.AI.MachineLearning.LearningModelBinding::HasKey(System.String)
    def has_key(self, key: str, /) -> bool: ...
    # System.Object Windows.AI.MachineLearning.LearningModelBinding::Lookup(System.String)
    def lookup(self, key: str, /) -> winrt.system.Object: ...
    # System.Void Windows.AI.MachineLearning.LearningModelBinding::Split(Windows.Foundation.Collections.IMapView`2<System.String,System.Object>&,Windows.Foundation.Collections.IMapView`2<System.String,System.Object>&)
    def split(self) -> typing.Tuple[typing.Mapping[str, winrt.system.Object], typing.Mapping[str, winrt.system.Object]]: ...
    # System.UInt32 Windows.AI.MachineLearning.LearningModelBinding::get_Size()
    @_property
    def size(self) -> winrt.system.UInt32: ...

@typing.final
class LearningModelDevice_Static(winrt._winrt.IInspectable_Static):
    # Windows.AI.MachineLearning.LearningModelDevice Windows.AI.MachineLearning.LearningModelDevice::CreateFromDirect3D11Device(Windows.Graphics.DirectX.Direct3D11.IDirect3DDevice)
    def create_from_direct3d11_device(cls, device: windows_graphics_directx_direct3d11.IDirect3DDevice, /) -> LearningModelDevice: ...

@typing.final
class LearningModelDevice(winrt.system.Object, metaclass=LearningModelDevice_Static):
    def __new__(cls: typing.Type[Self], device_kind: LearningModelDeviceKind) -> Self: ...
    # Windows.Graphics.DisplayAdapterId Windows.AI.MachineLearning.LearningModelDevice::get_AdapterId()
    @_property
    def adapter_id(self) -> windows_graphics.DisplayAdapterId: ...
    # Windows.Graphics.DirectX.Direct3D11.IDirect3DDevice Windows.AI.MachineLearning.LearningModelDevice::get_Direct3D11Device()
    @_property
    def direct3d11_device(self) -> windows_graphics_directx_direct3d11.IDirect3DDevice: ...

@typing.final
class LearningModelEvaluationResult(winrt.system.Object):
    # System.String Windows.AI.MachineLearning.LearningModelEvaluationResult::get_CorrelationId()
    @_property
    def correlation_id(self) -> str: ...
    # System.Int32 Windows.AI.MachineLearning.LearningModelEvaluationResult::get_ErrorStatus()
    @_property
    def error_status(self) -> winrt.system.Int32: ...
    # Windows.Foundation.Collections.IMapView`2<System.String,System.Object> Windows.AI.MachineLearning.LearningModelEvaluationResult::get_Outputs()
    @_property
    def outputs(self) -> typing.Mapping[str, winrt.system.Object]: ...
    # System.Boolean Windows.AI.MachineLearning.LearningModelEvaluationResult::get_Succeeded()
    @_property
    def succeeded(self) -> bool: ...

@typing.final
class LearningModelSession(winrt.system.Object, windows_foundation.IClosable):
    def __enter__(self: Self) -> Self: ...
    def __exit__(self, exc_type: typing.Optional[typing.Type[BaseException]], exc_value: typing.Optional[BaseException], traceback: typing.Optional[types.TracebackType]) -> None: ...
    @typing.overload
    def __new__(cls: typing.Type[Self], model: LearningModel, device_to_run_on: LearningModelDevice, learning_model_session_options: LearningModelSessionOptions) -> Self: ...
    @typing.overload
    def __new__(cls: typing.Type[Self], model: LearningModel) -> Self: ...
    @typing.overload
    def __new__(cls: typing.Type[Self], model: LearningModel, device_to_run_on: LearningModelDevice) -> Self: ...
    # System.Void Windows.AI.MachineLearning.LearningModelSession::Close()
    def close(self) -> None: ...
    # Windows.AI.MachineLearning.LearningModelEvaluationResult Windows.AI.MachineLearning.LearningModelSession::Evaluate(Windows.AI.MachineLearning.LearningModelBinding,System.String)
    def evaluate(self, bindings: LearningModelBinding, correlation_id: str, /) -> LearningModelEvaluationResult: ...
    # Windows.Foundation.IAsyncOperation`1<Windows.AI.MachineLearning.LearningModelEvaluationResult> Windows.AI.MachineLearning.LearningModelSession::EvaluateAsync(Windows.AI.MachineLearning.LearningModelBinding,System.String)
    def evaluate_async(self, bindings: LearningModelBinding, correlation_id: str, /) -> windows_foundation.IAsyncOperation[LearningModelEvaluationResult]: ...
    # Windows.AI.MachineLearning.LearningModelEvaluationResult Windows.AI.MachineLearning.LearningModelSession::EvaluateFeatures(Windows.Foundation.Collections.IMap`2<System.String,System.Object>,System.String)
    def evaluate_features(self, features: typing.MutableMapping[str, winrt.system.Object], correlation_id: str, /) -> LearningModelEvaluationResult: ...
    # Windows.Foundation.IAsyncOperation`1<Windows.AI.MachineLearning.LearningModelEvaluationResult> Windows.AI.MachineLearning.LearningModelSession::EvaluateFeaturesAsync(Windows.Foundation.Collections.IMap`2<System.String,System.Object>,System.String)
    def evaluate_features_async(self, features: typing.MutableMapping[str, winrt.system.Object], correlation_id: str, /) -> windows_foundation.IAsyncOperation[LearningModelEvaluationResult]: ...
    # Windows.AI.MachineLearning.LearningModelDevice Windows.AI.MachineLearning.LearningModelSession::get_Device()
    @_property
    def device(self) -> LearningModelDevice: ...
    # Windows.Foundation.Collections.IPropertySet Windows.AI.MachineLearning.LearningModelSession::get_EvaluationProperties()
    @_property
    def evaluation_properties(self) -> windows_foundation_collections.IPropertySet: ...
    # Windows.AI.MachineLearning.LearningModel Windows.AI.MachineLearning.LearningModelSession::get_Model()
    @_property
    def model(self) -> LearningModel: ...

@typing.final
class LearningModelSessionOptions(winrt.system.Object):
    def __new__(cls: typing.Type[Self]) -> Self: ...
    # System.Void Windows.AI.MachineLearning.LearningModelSessionOptions::OverrideNamedDimension(System.String,System.UInt32)
    def override_named_dimension(self, name: str, dimension: winrt.system.UInt32, /) -> None: ...
    # System.UInt32 Windows.AI.MachineLearning.LearningModelSessionOptions::get_BatchSizeOverride()
    @_property
    def batch_size_override(self) -> winrt.system.UInt32: ...
    # System.Void Windows.AI.MachineLearning.LearningModelSessionOptions::put_BatchSizeOverride(System.UInt32)
    @batch_size_override.setter
    def batch_size_override(self, value: winrt.system.UInt32) -> None: ...
    # System.Boolean Windows.AI.MachineLearning.LearningModelSessionOptions::get_CloseModelOnSessionCreation()
    @_property
    def close_model_on_session_creation(self) -> bool: ...
    # System.Void Windows.AI.MachineLearning.LearningModelSessionOptions::put_CloseModelOnSessionCreation(System.Boolean)
    @close_model_on_session_creation.setter
    def close_model_on_session_creation(self, value: bool) -> None: ...

@typing.final
class MapFeatureDescriptor(winrt.system.Object, ILearningModelFeatureDescriptor):
    # System.String Windows.AI.MachineLearning.MapFeatureDescriptor::get_Description()
    @_property
    def description(self) -> str: ...
    # System.Boolean Windows.AI.MachineLearning.MapFeatureDescriptor::get_IsRequired()
    @_property
    def is_required(self) -> bool: ...
    # Windows.AI.MachineLearning.LearningModelFeatureKind Windows.AI.MachineLearning.MapFeatureDescriptor::get_Kind()
    @_property
    def kind(self) -> LearningModelFeatureKind: ...
    # System.String Windows.AI.MachineLearning.MapFeatureDescriptor::get_Name()
    @_property
    def name(self) -> str: ...
    # Windows.AI.MachineLearning.TensorKind Windows.AI.MachineLearning.MapFeatureDescriptor::get_KeyKind()
    @_property
    def key_kind(self) -> TensorKind: ...
    # Windows.AI.MachineLearning.ILearningModelFeatureDescriptor Windows.AI.MachineLearning.MapFeatureDescriptor::get_ValueDescriptor()
    @_property
    def value_descriptor(self) -> ILearningModelFeatureDescriptor: ...

@typing.final
class SequenceFeatureDescriptor(winrt.system.Object, ILearningModelFeatureDescriptor):
    # System.String Windows.AI.MachineLearning.SequenceFeatureDescriptor::get_Description()
    @_property
    def description(self) -> str: ...
    # System.Boolean Windows.AI.MachineLearning.SequenceFeatureDescriptor::get_IsRequired()
    @_property
    def is_required(self) -> bool: ...
    # Windows.AI.MachineLearning.LearningModelFeatureKind Windows.AI.MachineLearning.SequenceFeatureDescriptor::get_Kind()
    @_property
    def kind(self) -> LearningModelFeatureKind: ...
    # System.String Windows.AI.MachineLearning.SequenceFeatureDescriptor::get_Name()
    @_property
    def name(self) -> str: ...
    # Windows.AI.MachineLearning.ILearningModelFeatureDescriptor Windows.AI.MachineLearning.SequenceFeatureDescriptor::get_ElementDescriptor()
    @_property
    def element_descriptor(self) -> ILearningModelFeatureDescriptor: ...

@typing.final
class TensorBoolean_Static(winrt._winrt.IInspectable_Static):
    # Windows.AI.MachineLearning.TensorBoolean Windows.AI.MachineLearning.TensorBoolean::Create()
    def create(cls) -> TensorBoolean: ...
    # Windows.AI.MachineLearning.TensorBoolean Windows.AI.MachineLearning.TensorBoolean::Create(Windows.Foundation.Collections.IIterable`1<System.Int64>)
    def create2(cls, shape: typing.Iterable[winrt.system.Int64], /) -> TensorBoolean: ...
    # Windows.AI.MachineLearning.TensorBoolean Windows.AI.MachineLearning.TensorBoolean::CreateFromArray(Windows.Foundation.Collections.IIterable`1<System.Int64>,System.Boolean[])
    def create_from_array(cls, shape: typing.Iterable[winrt.system.Int64], data: typing.Union[winrt.system.Array[bool], winrt.system.ReadableBuffer], /) -> TensorBoolean: ...
    # Windows.AI.MachineLearning.TensorBoolean Windows.AI.MachineLearning.TensorBoolean::CreateFromBuffer(System.Int64[],Windows.Storage.Streams.IBuffer)
    def create_from_buffer(cls, shape: typing.Union[winrt.system.Array[winrt.system.Int64], winrt.system.ReadableBuffer], buffer: winrt.system.Buffer, /) -> TensorBoolean: ...
    # Windows.AI.MachineLearning.TensorBoolean Windows.AI.MachineLearning.TensorBoolean::CreateFromIterable(Windows.Foundation.Collections.IIterable`1<System.Int64>,Windows.Foundation.Collections.IIterable`1<System.Boolean>)
    def create_from_iterable(cls, shape: typing.Iterable[winrt.system.Int64], data: typing.Iterable[bool], /) -> TensorBoolean: ...
    # Windows.AI.MachineLearning.TensorBoolean Windows.AI.MachineLearning.TensorBoolean::CreateFromShapeArrayAndDataArray(System.Int64[],System.Boolean[])
    def create_from_shape_array_and_data_array(cls, shape: typing.Union[winrt.system.Array[winrt.system.Int64], winrt.system.ReadableBuffer], data: typing.Union[winrt.system.Array[bool], winrt.system.ReadableBuffer], /) -> TensorBoolean: ...

@typing.final
class TensorBoolean(winrt.system.Object, windows_foundation.IMemoryBuffer, windows_foundation.IClosable, ITensor, ILearningModelFeatureValue, metaclass=TensorBoolean_Static):
    def __enter__(self: Self) -> Self: ...
    def __exit__(self, exc_type: typing.Optional[typing.Type[BaseException]], exc_value: typing.Optional[BaseException], traceback: typing.Optional[types.TracebackType]) -> None: ...
    # System.Void Windows.AI.MachineLearning.TensorBoolean::Close()
    def close(self) -> None: ...
    # Windows.Foundation.IMemoryBufferReference Windows.AI.MachineLearning.TensorBoolean::CreateReference()
    def create_reference(self) -> windows_foundation.IMemoryBufferReference: ...
    # Windows.Foundation.Collections.IVectorView`1<System.Boolean> Windows.AI.MachineLearning.TensorBoolean::GetAsVectorView()
    def get_as_vector_view(self) -> typing.Sequence[bool]: ...
    # Windows.AI.MachineLearning.LearningModelFeatureKind Windows.AI.MachineLearning.TensorBoolean::get_Kind()
    @_property
    def kind(self) -> LearningModelFeatureKind: ...
    # Windows.Foundation.Collections.IVectorView`1<System.Int64> Windows.AI.MachineLearning.TensorBoolean::get_Shape()
    @_property
    def shape(self) -> typing.Sequence[winrt.system.Int64]: ...
    # Windows.AI.MachineLearning.TensorKind Windows.AI.MachineLearning.TensorBoolean::get_TensorKind()
    @_property
    def tensor_kind(self) -> TensorKind: ...

@typing.final
class TensorDouble_Static(winrt._winrt.IInspectable_Static):
    # Windows.AI.MachineLearning.TensorDouble Windows.AI.MachineLearning.TensorDouble::Create()
    def create(cls) -> TensorDouble: ...
    # Windows.AI.MachineLearning.TensorDouble Windows.AI.MachineLearning.TensorDouble::Create(Windows.Foundation.Collections.IIterable`1<System.Int64>)
    def create2(cls, shape: typing.Iterable[winrt.system.Int64], /) -> TensorDouble: ...
    # Windows.AI.MachineLearning.TensorDouble Windows.AI.MachineLearning.TensorDouble::CreateFromArray(Windows.Foundation.Collections.IIterable`1<System.Int64>,System.Double[])
    def create_from_array(cls, shape: typing.Iterable[winrt.system.Int64], data: typing.Union[winrt.system.Array[winrt.system.Double], winrt.system.ReadableBuffer], /) -> TensorDouble: ...
    # Windows.AI.MachineLearning.TensorDouble Windows.AI.MachineLearning.TensorDouble::CreateFromBuffer(System.Int64[],Windows.Storage.Streams.IBuffer)
    def create_from_buffer(cls, shape: typing.Union[winrt.system.Array[winrt.system.Int64], winrt.system.ReadableBuffer], buffer: winrt.system.Buffer, /) -> TensorDouble: ...
    # Windows.AI.MachineLearning.TensorDouble Windows.AI.MachineLearning.TensorDouble::CreateFromIterable(Windows.Foundation.Collections.IIterable`1<System.Int64>,Windows.Foundation.Collections.IIterable`1<System.Double>)
    def create_from_iterable(cls, shape: typing.Iterable[winrt.system.Int64], data: typing.Iterable[winrt.system.Double], /) -> TensorDouble: ...
    # Windows.AI.MachineLearning.TensorDouble Windows.AI.MachineLearning.TensorDouble::CreateFromShapeArrayAndDataArray(System.Int64[],System.Double[])
    def create_from_shape_array_and_data_array(cls, shape: typing.Union[winrt.system.Array[winrt.system.Int64], winrt.system.ReadableBuffer], data: typing.Union[winrt.system.Array[winrt.system.Double], winrt.system.ReadableBuffer], /) -> TensorDouble: ...

@typing.final
class TensorDouble(winrt.system.Object, windows_foundation.IMemoryBuffer, windows_foundation.IClosable, ITensor, ILearningModelFeatureValue, metaclass=TensorDouble_Static):
    def __enter__(self: Self) -> Self: ...
    def __exit__(self, exc_type: typing.Optional[typing.Type[BaseException]], exc_value: typing.Optional[BaseException], traceback: typing.Optional[types.TracebackType]) -> None: ...
    # System.Void Windows.AI.MachineLearning.TensorDouble::Close()
    def close(self) -> None: ...
    # Windows.Foundation.IMemoryBufferReference Windows.AI.MachineLearning.TensorDouble::CreateReference()
    def create_reference(self) -> windows_foundation.IMemoryBufferReference: ...
    # Windows.Foundation.Collections.IVectorView`1<System.Double> Windows.AI.MachineLearning.TensorDouble::GetAsVectorView()
    def get_as_vector_view(self) -> typing.Sequence[winrt.system.Double]: ...
    # Windows.AI.MachineLearning.LearningModelFeatureKind Windows.AI.MachineLearning.TensorDouble::get_Kind()
    @_property
    def kind(self) -> LearningModelFeatureKind: ...
    # Windows.Foundation.Collections.IVectorView`1<System.Int64> Windows.AI.MachineLearning.TensorDouble::get_Shape()
    @_property
    def shape(self) -> typing.Sequence[winrt.system.Int64]: ...
    # Windows.AI.MachineLearning.TensorKind Windows.AI.MachineLearning.TensorDouble::get_TensorKind()
    @_property
    def tensor_kind(self) -> TensorKind: ...

@typing.final
class TensorFeatureDescriptor(winrt.system.Object, ILearningModelFeatureDescriptor):
    # System.String Windows.AI.MachineLearning.TensorFeatureDescriptor::get_Description()
    @_property
    def description(self) -> str: ...
    # System.Boolean Windows.AI.MachineLearning.TensorFeatureDescriptor::get_IsRequired()
    @_property
    def is_required(self) -> bool: ...
    # Windows.AI.MachineLearning.LearningModelFeatureKind Windows.AI.MachineLearning.TensorFeatureDescriptor::get_Kind()
    @_property
    def kind(self) -> LearningModelFeatureKind: ...
    # System.String Windows.AI.MachineLearning.TensorFeatureDescriptor::get_Name()
    @_property
    def name(self) -> str: ...
    # Windows.Foundation.Collections.IVectorView`1<System.Int64> Windows.AI.MachineLearning.TensorFeatureDescriptor::get_Shape()
    @_property
    def shape(self) -> typing.Sequence[winrt.system.Int64]: ...
    # Windows.AI.MachineLearning.TensorKind Windows.AI.MachineLearning.TensorFeatureDescriptor::get_TensorKind()
    @_property
    def tensor_kind(self) -> TensorKind: ...

@typing.final
class TensorFloat_Static(winrt._winrt.IInspectable_Static):
    # Windows.AI.MachineLearning.TensorFloat Windows.AI.MachineLearning.TensorFloat::Create()
    def create(cls) -> TensorFloat: ...
    # Windows.AI.MachineLearning.TensorFloat Windows.AI.MachineLearning.TensorFloat::Create(Windows.Foundation.Collections.IIterable`1<System.Int64>)
    def create2(cls, shape: typing.Iterable[winrt.system.Int64], /) -> TensorFloat: ...
    # Windows.AI.MachineLearning.TensorFloat Windows.AI.MachineLearning.TensorFloat::CreateFromArray(Windows.Foundation.Collections.IIterable`1<System.Int64>,System.Single[])
    def create_from_array(cls, shape: typing.Iterable[winrt.system.Int64], data: typing.Union[winrt.system.Array[winrt.system.Single], winrt.system.ReadableBuffer], /) -> TensorFloat: ...
    # Windows.AI.MachineLearning.TensorFloat Windows.AI.MachineLearning.TensorFloat::CreateFromBuffer(System.Int64[],Windows.Storage.Streams.IBuffer)
    def create_from_buffer(cls, shape: typing.Union[winrt.system.Array[winrt.system.Int64], winrt.system.ReadableBuffer], buffer: winrt.system.Buffer, /) -> TensorFloat: ...
    # Windows.AI.MachineLearning.TensorFloat Windows.AI.MachineLearning.TensorFloat::CreateFromIterable(Windows.Foundation.Collections.IIterable`1<System.Int64>,Windows.Foundation.Collections.IIterable`1<System.Single>)
    def create_from_iterable(cls, shape: typing.Iterable[winrt.system.Int64], data: typing.Iterable[winrt.system.Single], /) -> TensorFloat: ...
    # Windows.AI.MachineLearning.TensorFloat Windows.AI.MachineLearning.TensorFloat::CreateFromShapeArrayAndDataArray(System.Int64[],System.Single[])
    def create_from_shape_array_and_data_array(cls, shape: typing.Union[winrt.system.Array[winrt.system.Int64], winrt.system.ReadableBuffer], data: typing.Union[winrt.system.Array[winrt.system.Single], winrt.system.ReadableBuffer], /) -> TensorFloat: ...

@typing.final
class TensorFloat(winrt.system.Object, windows_foundation.IMemoryBuffer, windows_foundation.IClosable, ITensor, ILearningModelFeatureValue, metaclass=TensorFloat_Static):
    def __enter__(self: Self) -> Self: ...
    def __exit__(self, exc_type: typing.Optional[typing.Type[BaseException]], exc_value: typing.Optional[BaseException], traceback: typing.Optional[types.TracebackType]) -> None: ...
    # System.Void Windows.AI.MachineLearning.TensorFloat::Close()
    def close(self) -> None: ...
    # Windows.Foundation.IMemoryBufferReference Windows.AI.MachineLearning.TensorFloat::CreateReference()
    def create_reference(self) -> windows_foundation.IMemoryBufferReference: ...
    # Windows.Foundation.Collections.IVectorView`1<System.Single> Windows.AI.MachineLearning.TensorFloat::GetAsVectorView()
    def get_as_vector_view(self) -> typing.Sequence[winrt.system.Single]: ...
    # Windows.AI.MachineLearning.LearningModelFeatureKind Windows.AI.MachineLearning.TensorFloat::get_Kind()
    @_property
    def kind(self) -> LearningModelFeatureKind: ...
    # Windows.Foundation.Collections.IVectorView`1<System.Int64> Windows.AI.MachineLearning.TensorFloat::get_Shape()
    @_property
    def shape(self) -> typing.Sequence[winrt.system.Int64]: ...
    # Windows.AI.MachineLearning.TensorKind Windows.AI.MachineLearning.TensorFloat::get_TensorKind()
    @_property
    def tensor_kind(self) -> TensorKind: ...

@typing.final
class TensorFloat16Bit_Static(winrt._winrt.IInspectable_Static):
    # Windows.AI.MachineLearning.TensorFloat16Bit Windows.AI.MachineLearning.TensorFloat16Bit::Create()
    def create(cls) -> TensorFloat16Bit: ...
    # Windows.AI.MachineLearning.TensorFloat16Bit Windows.AI.MachineLearning.TensorFloat16Bit::Create(Windows.Foundation.Collections.IIterable`1<System.Int64>)
    def create2(cls, shape: typing.Iterable[winrt.system.Int64], /) -> TensorFloat16Bit: ...
    # Windows.AI.MachineLearning.TensorFloat16Bit Windows.AI.MachineLearning.TensorFloat16Bit::CreateFromArray(Windows.Foundation.Collections.IIterable`1<System.Int64>,System.Single[])
    def create_from_array(cls, shape: typing.Iterable[winrt.system.Int64], data: typing.Union[winrt.system.Array[winrt.system.Single], winrt.system.ReadableBuffer], /) -> TensorFloat16Bit: ...
    # Windows.AI.MachineLearning.TensorFloat16Bit Windows.AI.MachineLearning.TensorFloat16Bit::CreateFromBuffer(System.Int64[],Windows.Storage.Streams.IBuffer)
    def create_from_buffer(cls, shape: typing.Union[winrt.system.Array[winrt.system.Int64], winrt.system.ReadableBuffer], buffer: winrt.system.Buffer, /) -> TensorFloat16Bit: ...
    # Windows.AI.MachineLearning.TensorFloat16Bit Windows.AI.MachineLearning.TensorFloat16Bit::CreateFromIterable(Windows.Foundation.Collections.IIterable`1<System.Int64>,Windows.Foundation.Collections.IIterable`1<System.Single>)
    def create_from_iterable(cls, shape: typing.Iterable[winrt.system.Int64], data: typing.Iterable[winrt.system.Single], /) -> TensorFloat16Bit: ...
    # Windows.AI.MachineLearning.TensorFloat16Bit Windows.AI.MachineLearning.TensorFloat16Bit::CreateFromShapeArrayAndDataArray(System.Int64[],System.Single[])
    def create_from_shape_array_and_data_array(cls, shape: typing.Union[winrt.system.Array[winrt.system.Int64], winrt.system.ReadableBuffer], data: typing.Union[winrt.system.Array[winrt.system.Single], winrt.system.ReadableBuffer], /) -> TensorFloat16Bit: ...

@typing.final
class TensorFloat16Bit(winrt.system.Object, windows_foundation.IMemoryBuffer, windows_foundation.IClosable, ITensor, ILearningModelFeatureValue, metaclass=TensorFloat16Bit_Static):
    def __enter__(self: Self) -> Self: ...
    def __exit__(self, exc_type: typing.Optional[typing.Type[BaseException]], exc_value: typing.Optional[BaseException], traceback: typing.Optional[types.TracebackType]) -> None: ...
    # System.Void Windows.AI.MachineLearning.TensorFloat16Bit::Close()
    def close(self) -> None: ...
    # Windows.Foundation.IMemoryBufferReference Windows.AI.MachineLearning.TensorFloat16Bit::CreateReference()
    def create_reference(self) -> windows_foundation.IMemoryBufferReference: ...
    # Windows.Foundation.Collections.IVectorView`1<System.Single> Windows.AI.MachineLearning.TensorFloat16Bit::GetAsVectorView()
    def get_as_vector_view(self) -> typing.Sequence[winrt.system.Single]: ...
    # Windows.AI.MachineLearning.LearningModelFeatureKind Windows.AI.MachineLearning.TensorFloat16Bit::get_Kind()
    @_property
    def kind(self) -> LearningModelFeatureKind: ...
    # Windows.Foundation.Collections.IVectorView`1<System.Int64> Windows.AI.MachineLearning.TensorFloat16Bit::get_Shape()
    @_property
    def shape(self) -> typing.Sequence[winrt.system.Int64]: ...
    # Windows.AI.MachineLearning.TensorKind Windows.AI.MachineLearning.TensorFloat16Bit::get_TensorKind()
    @_property
    def tensor_kind(self) -> TensorKind: ...

@typing.final
class TensorInt16Bit_Static(winrt._winrt.IInspectable_Static):
    # Windows.AI.MachineLearning.TensorInt16Bit Windows.AI.MachineLearning.TensorInt16Bit::Create()
    def create(cls) -> TensorInt16Bit: ...
    # Windows.AI.MachineLearning.TensorInt16Bit Windows.AI.MachineLearning.TensorInt16Bit::Create(Windows.Foundation.Collections.IIterable`1<System.Int64>)
    def create2(cls, shape: typing.Iterable[winrt.system.Int64], /) -> TensorInt16Bit: ...
    # Windows.AI.MachineLearning.TensorInt16Bit Windows.AI.MachineLearning.TensorInt16Bit::CreateFromArray(Windows.Foundation.Collections.IIterable`1<System.Int64>,System.Int16[])
    def create_from_array(cls, shape: typing.Iterable[winrt.system.Int64], data: typing.Union[winrt.system.Array[winrt.system.Int16], winrt.system.ReadableBuffer], /) -> TensorInt16Bit: ...
    # Windows.AI.MachineLearning.TensorInt16Bit Windows.AI.MachineLearning.TensorInt16Bit::CreateFromBuffer(System.Int64[],Windows.Storage.Streams.IBuffer)
    def create_from_buffer(cls, shape: typing.Union[winrt.system.Array[winrt.system.Int64], winrt.system.ReadableBuffer], buffer: winrt.system.Buffer, /) -> TensorInt16Bit: ...
    # Windows.AI.MachineLearning.TensorInt16Bit Windows.AI.MachineLearning.TensorInt16Bit::CreateFromIterable(Windows.Foundation.Collections.IIterable`1<System.Int64>,Windows.Foundation.Collections.IIterable`1<System.Int16>)
    def create_from_iterable(cls, shape: typing.Iterable[winrt.system.Int64], data: typing.Iterable[winrt.system.Int16], /) -> TensorInt16Bit: ...
    # Windows.AI.MachineLearning.TensorInt16Bit Windows.AI.MachineLearning.TensorInt16Bit::CreateFromShapeArrayAndDataArray(System.Int64[],System.Int16[])
    def create_from_shape_array_and_data_array(cls, shape: typing.Union[winrt.system.Array[winrt.system.Int64], winrt.system.ReadableBuffer], data: typing.Union[winrt.system.Array[winrt.system.Int16], winrt.system.ReadableBuffer], /) -> TensorInt16Bit: ...

@typing.final
class TensorInt16Bit(winrt.system.Object, windows_foundation.IMemoryBuffer, windows_foundation.IClosable, ITensor, ILearningModelFeatureValue, metaclass=TensorInt16Bit_Static):
    def __enter__(self: Self) -> Self: ...
    def __exit__(self, exc_type: typing.Optional[typing.Type[BaseException]], exc_value: typing.Optional[BaseException], traceback: typing.Optional[types.TracebackType]) -> None: ...
    # System.Void Windows.AI.MachineLearning.TensorInt16Bit::Close()
    def close(self) -> None: ...
    # Windows.Foundation.IMemoryBufferReference Windows.AI.MachineLearning.TensorInt16Bit::CreateReference()
    def create_reference(self) -> windows_foundation.IMemoryBufferReference: ...
    # Windows.Foundation.Collections.IVectorView`1<System.Int16> Windows.AI.MachineLearning.TensorInt16Bit::GetAsVectorView()
    def get_as_vector_view(self) -> typing.Sequence[winrt.system.Int16]: ...
    # Windows.AI.MachineLearning.LearningModelFeatureKind Windows.AI.MachineLearning.TensorInt16Bit::get_Kind()
    @_property
    def kind(self) -> LearningModelFeatureKind: ...
    # Windows.Foundation.Collections.IVectorView`1<System.Int64> Windows.AI.MachineLearning.TensorInt16Bit::get_Shape()
    @_property
    def shape(self) -> typing.Sequence[winrt.system.Int64]: ...
    # Windows.AI.MachineLearning.TensorKind Windows.AI.MachineLearning.TensorInt16Bit::get_TensorKind()
    @_property
    def tensor_kind(self) -> TensorKind: ...

@typing.final
class TensorInt32Bit_Static(winrt._winrt.IInspectable_Static):
    # Windows.AI.MachineLearning.TensorInt32Bit Windows.AI.MachineLearning.TensorInt32Bit::Create()
    def create(cls) -> TensorInt32Bit: ...
    # Windows.AI.MachineLearning.TensorInt32Bit Windows.AI.MachineLearning.TensorInt32Bit::Create(Windows.Foundation.Collections.IIterable`1<System.Int64>)
    def create2(cls, shape: typing.Iterable[winrt.system.Int64], /) -> TensorInt32Bit: ...
    # Windows.AI.MachineLearning.TensorInt32Bit Windows.AI.MachineLearning.TensorInt32Bit::CreateFromArray(Windows.Foundation.Collections.IIterable`1<System.Int64>,System.Int32[])
    def create_from_array(cls, shape: typing.Iterable[winrt.system.Int64], data: typing.Union[winrt.system.Array[winrt.system.Int32], winrt.system.ReadableBuffer], /) -> TensorInt32Bit: ...
    # Windows.AI.MachineLearning.TensorInt32Bit Windows.AI.MachineLearning.TensorInt32Bit::CreateFromBuffer(System.Int64[],Windows.Storage.Streams.IBuffer)
    def create_from_buffer(cls, shape: typing.Union[winrt.system.Array[winrt.system.Int64], winrt.system.ReadableBuffer], buffer: winrt.system.Buffer, /) -> TensorInt32Bit: ...
    # Windows.AI.MachineLearning.TensorInt32Bit Windows.AI.MachineLearning.TensorInt32Bit::CreateFromIterable(Windows.Foundation.Collections.IIterable`1<System.Int64>,Windows.Foundation.Collections.IIterable`1<System.Int32>)
    def create_from_iterable(cls, shape: typing.Iterable[winrt.system.Int64], data: typing.Iterable[winrt.system.Int32], /) -> TensorInt32Bit: ...
    # Windows.AI.MachineLearning.TensorInt32Bit Windows.AI.MachineLearning.TensorInt32Bit::CreateFromShapeArrayAndDataArray(System.Int64[],System.Int32[])
    def create_from_shape_array_and_data_array(cls, shape: typing.Union[winrt.system.Array[winrt.system.Int64], winrt.system.ReadableBuffer], data: typing.Union[winrt.system.Array[winrt.system.Int32], winrt.system.ReadableBuffer], /) -> TensorInt32Bit: ...

@typing.final
class TensorInt32Bit(winrt.system.Object, windows_foundation.IMemoryBuffer, windows_foundation.IClosable, ITensor, ILearningModelFeatureValue, metaclass=TensorInt32Bit_Static):
    def __enter__(self: Self) -> Self: ...
    def __exit__(self, exc_type: typing.Optional[typing.Type[BaseException]], exc_value: typing.Optional[BaseException], traceback: typing.Optional[types.TracebackType]) -> None: ...
    # System.Void Windows.AI.MachineLearning.TensorInt32Bit::Close()
    def close(self) -> None: ...
    # Windows.Foundation.IMemoryBufferReference Windows.AI.MachineLearning.TensorInt32Bit::CreateReference()
    def create_reference(self) -> windows_foundation.IMemoryBufferReference: ...
    # Windows.Foundation.Collections.IVectorView`1<System.Int32> Windows.AI.MachineLearning.TensorInt32Bit::GetAsVectorView()
    def get_as_vector_view(self) -> typing.Sequence[winrt.system.Int32]: ...
    # Windows.AI.MachineLearning.LearningModelFeatureKind Windows.AI.MachineLearning.TensorInt32Bit::get_Kind()
    @_property
    def kind(self) -> LearningModelFeatureKind: ...
    # Windows.Foundation.Collections.IVectorView`1<System.Int64> Windows.AI.MachineLearning.TensorInt32Bit::get_Shape()
    @_property
    def shape(self) -> typing.Sequence[winrt.system.Int64]: ...
    # Windows.AI.MachineLearning.TensorKind Windows.AI.MachineLearning.TensorInt32Bit::get_TensorKind()
    @_property
    def tensor_kind(self) -> TensorKind: ...

@typing.final
class TensorInt64Bit_Static(winrt._winrt.IInspectable_Static):
    # Windows.AI.MachineLearning.TensorInt64Bit Windows.AI.MachineLearning.TensorInt64Bit::Create()
    def create(cls) -> TensorInt64Bit: ...
    # Windows.AI.MachineLearning.TensorInt64Bit Windows.AI.MachineLearning.TensorInt64Bit::Create(Windows.Foundation.Collections.IIterable`1<System.Int64>)
    def create2(cls, shape: typing.Iterable[winrt.system.Int64], /) -> TensorInt64Bit: ...
    # Windows.AI.MachineLearning.TensorInt64Bit Windows.AI.MachineLearning.TensorInt64Bit::CreateFromArray(Windows.Foundation.Collections.IIterable`1<System.Int64>,System.Int64[])
    def create_from_array(cls, shape: typing.Iterable[winrt.system.Int64], data: typing.Union[winrt.system.Array[winrt.system.Int64], winrt.system.ReadableBuffer], /) -> TensorInt64Bit: ...
    # Windows.AI.MachineLearning.TensorInt64Bit Windows.AI.MachineLearning.TensorInt64Bit::CreateFromBuffer(System.Int64[],Windows.Storage.Streams.IBuffer)
    def create_from_buffer(cls, shape: typing.Union[winrt.system.Array[winrt.system.Int64], winrt.system.ReadableBuffer], buffer: winrt.system.Buffer, /) -> TensorInt64Bit: ...
    # Windows.AI.MachineLearning.TensorInt64Bit Windows.AI.MachineLearning.TensorInt64Bit::CreateFromIterable(Windows.Foundation.Collections.IIterable`1<System.Int64>,Windows.Foundation.Collections.IIterable`1<System.Int64>)
    def create_from_iterable(cls, shape: typing.Iterable[winrt.system.Int64], data: typing.Iterable[winrt.system.Int64], /) -> TensorInt64Bit: ...
    # Windows.AI.MachineLearning.TensorInt64Bit Windows.AI.MachineLearning.TensorInt64Bit::CreateFromShapeArrayAndDataArray(System.Int64[],System.Int64[])
    def create_from_shape_array_and_data_array(cls, shape: typing.Union[winrt.system.Array[winrt.system.Int64], winrt.system.ReadableBuffer], data: typing.Union[winrt.system.Array[winrt.system.Int64], winrt.system.ReadableBuffer], /) -> TensorInt64Bit: ...

@typing.final
class TensorInt64Bit(winrt.system.Object, windows_foundation.IMemoryBuffer, windows_foundation.IClosable, ITensor, ILearningModelFeatureValue, metaclass=TensorInt64Bit_Static):
    def __enter__(self: Self) -> Self: ...
    def __exit__(self, exc_type: typing.Optional[typing.Type[BaseException]], exc_value: typing.Optional[BaseException], traceback: typing.Optional[types.TracebackType]) -> None: ...
    # System.Void Windows.AI.MachineLearning.TensorInt64Bit::Close()
    def close(self) -> None: ...
    # Windows.Foundation.IMemoryBufferReference Windows.AI.MachineLearning.TensorInt64Bit::CreateReference()
    def create_reference(self) -> windows_foundation.IMemoryBufferReference: ...
    # Windows.Foundation.Collections.IVectorView`1<System.Int64> Windows.AI.MachineLearning.TensorInt64Bit::GetAsVectorView()
    def get_as_vector_view(self) -> typing.Sequence[winrt.system.Int64]: ...
    # Windows.AI.MachineLearning.LearningModelFeatureKind Windows.AI.MachineLearning.TensorInt64Bit::get_Kind()
    @_property
    def kind(self) -> LearningModelFeatureKind: ...
    # Windows.Foundation.Collections.IVectorView`1<System.Int64> Windows.AI.MachineLearning.TensorInt64Bit::get_Shape()
    @_property
    def shape(self) -> typing.Sequence[winrt.system.Int64]: ...
    # Windows.AI.MachineLearning.TensorKind Windows.AI.MachineLearning.TensorInt64Bit::get_TensorKind()
    @_property
    def tensor_kind(self) -> TensorKind: ...

@typing.final
class TensorInt8Bit_Static(winrt._winrt.IInspectable_Static):
    # Windows.AI.MachineLearning.TensorInt8Bit Windows.AI.MachineLearning.TensorInt8Bit::Create()
    def create(cls) -> TensorInt8Bit: ...
    # Windows.AI.MachineLearning.TensorInt8Bit Windows.AI.MachineLearning.TensorInt8Bit::Create(Windows.Foundation.Collections.IIterable`1<System.Int64>)
    def create2(cls, shape: typing.Iterable[winrt.system.Int64], /) -> TensorInt8Bit: ...
    # Windows.AI.MachineLearning.TensorInt8Bit Windows.AI.MachineLearning.TensorInt8Bit::CreateFromArray(Windows.Foundation.Collections.IIterable`1<System.Int64>,System.Byte[])
    def create_from_array(cls, shape: typing.Iterable[winrt.system.Int64], data: typing.Union[winrt.system.Array[winrt.system.UInt8], winrt.system.ReadableBuffer], /) -> TensorInt8Bit: ...
    # Windows.AI.MachineLearning.TensorInt8Bit Windows.AI.MachineLearning.TensorInt8Bit::CreateFromBuffer(System.Int64[],Windows.Storage.Streams.IBuffer)
    def create_from_buffer(cls, shape: typing.Union[winrt.system.Array[winrt.system.Int64], winrt.system.ReadableBuffer], buffer: winrt.system.Buffer, /) -> TensorInt8Bit: ...
    # Windows.AI.MachineLearning.TensorInt8Bit Windows.AI.MachineLearning.TensorInt8Bit::CreateFromIterable(Windows.Foundation.Collections.IIterable`1<System.Int64>,Windows.Foundation.Collections.IIterable`1<System.Byte>)
    def create_from_iterable(cls, shape: typing.Iterable[winrt.system.Int64], data: typing.Iterable[winrt.system.UInt8], /) -> TensorInt8Bit: ...
    # Windows.AI.MachineLearning.TensorInt8Bit Windows.AI.MachineLearning.TensorInt8Bit::CreateFromShapeArrayAndDataArray(System.Int64[],System.Byte[])
    def create_from_shape_array_and_data_array(cls, shape: typing.Union[winrt.system.Array[winrt.system.Int64], winrt.system.ReadableBuffer], data: typing.Union[winrt.system.Array[winrt.system.UInt8], winrt.system.ReadableBuffer], /) -> TensorInt8Bit: ...

@typing.final
class TensorInt8Bit(winrt.system.Object, windows_foundation.IMemoryBuffer, windows_foundation.IClosable, ITensor, ILearningModelFeatureValue, metaclass=TensorInt8Bit_Static):
    def __enter__(self: Self) -> Self: ...
    def __exit__(self, exc_type: typing.Optional[typing.Type[BaseException]], exc_value: typing.Optional[BaseException], traceback: typing.Optional[types.TracebackType]) -> None: ...
    # System.Void Windows.AI.MachineLearning.TensorInt8Bit::Close()
    def close(self) -> None: ...
    # Windows.Foundation.IMemoryBufferReference Windows.AI.MachineLearning.TensorInt8Bit::CreateReference()
    def create_reference(self) -> windows_foundation.IMemoryBufferReference: ...
    # Windows.Foundation.Collections.IVectorView`1<System.Byte> Windows.AI.MachineLearning.TensorInt8Bit::GetAsVectorView()
    def get_as_vector_view(self) -> typing.Sequence[winrt.system.UInt8]: ...
    # Windows.AI.MachineLearning.LearningModelFeatureKind Windows.AI.MachineLearning.TensorInt8Bit::get_Kind()
    @_property
    def kind(self) -> LearningModelFeatureKind: ...
    # Windows.Foundation.Collections.IVectorView`1<System.Int64> Windows.AI.MachineLearning.TensorInt8Bit::get_Shape()
    @_property
    def shape(self) -> typing.Sequence[winrt.system.Int64]: ...
    # Windows.AI.MachineLearning.TensorKind Windows.AI.MachineLearning.TensorInt8Bit::get_TensorKind()
    @_property
    def tensor_kind(self) -> TensorKind: ...

@typing.final
class TensorString_Static(winrt._winrt.IInspectable_Static):
    # Windows.AI.MachineLearning.TensorString Windows.AI.MachineLearning.TensorString::Create()
    def create(cls) -> TensorString: ...
    # Windows.AI.MachineLearning.TensorString Windows.AI.MachineLearning.TensorString::Create(Windows.Foundation.Collections.IIterable`1<System.Int64>)
    def create2(cls, shape: typing.Iterable[winrt.system.Int64], /) -> TensorString: ...
    # Windows.AI.MachineLearning.TensorString Windows.AI.MachineLearning.TensorString::CreateFromArray(Windows.Foundation.Collections.IIterable`1<System.Int64>,System.String[])
    def create_from_array(cls, shape: typing.Iterable[winrt.system.Int64], data: typing.Union[winrt.system.Array[str], winrt.system.ReadableBuffer], /) -> TensorString: ...
    # Windows.AI.MachineLearning.TensorString Windows.AI.MachineLearning.TensorString::CreateFromIterable(Windows.Foundation.Collections.IIterable`1<System.Int64>,Windows.Foundation.Collections.IIterable`1<System.String>)
    def create_from_iterable(cls, shape: typing.Iterable[winrt.system.Int64], data: typing.Iterable[str], /) -> TensorString: ...
    # Windows.AI.MachineLearning.TensorString Windows.AI.MachineLearning.TensorString::CreateFromShapeArrayAndDataArray(System.Int64[],System.String[])
    def create_from_shape_array_and_data_array(cls, shape: typing.Union[winrt.system.Array[winrt.system.Int64], winrt.system.ReadableBuffer], data: typing.Union[winrt.system.Array[str], winrt.system.ReadableBuffer], /) -> TensorString: ...

@typing.final
class TensorString(winrt.system.Object, windows_foundation.IMemoryBuffer, windows_foundation.IClosable, ITensor, ILearningModelFeatureValue, metaclass=TensorString_Static):
    def __enter__(self: Self) -> Self: ...
    def __exit__(self, exc_type: typing.Optional[typing.Type[BaseException]], exc_value: typing.Optional[BaseException], traceback: typing.Optional[types.TracebackType]) -> None: ...
    # System.Void Windows.AI.MachineLearning.TensorString::Close()
    def close(self) -> None: ...
    # Windows.Foundation.IMemoryBufferReference Windows.AI.MachineLearning.TensorString::CreateReference()
    def create_reference(self) -> windows_foundation.IMemoryBufferReference: ...
    # Windows.Foundation.Collections.IVectorView`1<System.String> Windows.AI.MachineLearning.TensorString::GetAsVectorView()
    def get_as_vector_view(self) -> typing.Sequence[str]: ...
    # Windows.AI.MachineLearning.LearningModelFeatureKind Windows.AI.MachineLearning.TensorString::get_Kind()
    @_property
    def kind(self) -> LearningModelFeatureKind: ...
    # Windows.Foundation.Collections.IVectorView`1<System.Int64> Windows.AI.MachineLearning.TensorString::get_Shape()
    @_property
    def shape(self) -> typing.Sequence[winrt.system.Int64]: ...
    # Windows.AI.MachineLearning.TensorKind Windows.AI.MachineLearning.TensorString::get_TensorKind()
    @_property
    def tensor_kind(self) -> TensorKind: ...

@typing.final
class TensorUInt16Bit_Static(winrt._winrt.IInspectable_Static):
    # Windows.AI.MachineLearning.TensorUInt16Bit Windows.AI.MachineLearning.TensorUInt16Bit::Create()
    def create(cls) -> TensorUInt16Bit: ...
    # Windows.AI.MachineLearning.TensorUInt16Bit Windows.AI.MachineLearning.TensorUInt16Bit::Create(Windows.Foundation.Collections.IIterable`1<System.Int64>)
    def create2(cls, shape: typing.Iterable[winrt.system.Int64], /) -> TensorUInt16Bit: ...
    # Windows.AI.MachineLearning.TensorUInt16Bit Windows.AI.MachineLearning.TensorUInt16Bit::CreateFromArray(Windows.Foundation.Collections.IIterable`1<System.Int64>,System.UInt16[])
    def create_from_array(cls, shape: typing.Iterable[winrt.system.Int64], data: typing.Union[winrt.system.Array[winrt.system.UInt16], winrt.system.ReadableBuffer], /) -> TensorUInt16Bit: ...
    # Windows.AI.MachineLearning.TensorUInt16Bit Windows.AI.MachineLearning.TensorUInt16Bit::CreateFromBuffer(System.Int64[],Windows.Storage.Streams.IBuffer)
    def create_from_buffer(cls, shape: typing.Union[winrt.system.Array[winrt.system.Int64], winrt.system.ReadableBuffer], buffer: winrt.system.Buffer, /) -> TensorUInt16Bit: ...
    # Windows.AI.MachineLearning.TensorUInt16Bit Windows.AI.MachineLearning.TensorUInt16Bit::CreateFromIterable(Windows.Foundation.Collections.IIterable`1<System.Int64>,Windows.Foundation.Collections.IIterable`1<System.UInt16>)
    def create_from_iterable(cls, shape: typing.Iterable[winrt.system.Int64], data: typing.Iterable[winrt.system.UInt16], /) -> TensorUInt16Bit: ...
    # Windows.AI.MachineLearning.TensorUInt16Bit Windows.AI.MachineLearning.TensorUInt16Bit::CreateFromShapeArrayAndDataArray(System.Int64[],System.UInt16[])
    def create_from_shape_array_and_data_array(cls, shape: typing.Union[winrt.system.Array[winrt.system.Int64], winrt.system.ReadableBuffer], data: typing.Union[winrt.system.Array[winrt.system.UInt16], winrt.system.ReadableBuffer], /) -> TensorUInt16Bit: ...

@typing.final
class TensorUInt16Bit(winrt.system.Object, windows_foundation.IMemoryBuffer, windows_foundation.IClosable, ITensor, ILearningModelFeatureValue, metaclass=TensorUInt16Bit_Static):
    def __enter__(self: Self) -> Self: ...
    def __exit__(self, exc_type: typing.Optional[typing.Type[BaseException]], exc_value: typing.Optional[BaseException], traceback: typing.Optional[types.TracebackType]) -> None: ...
    # System.Void Windows.AI.MachineLearning.TensorUInt16Bit::Close()
    def close(self) -> None: ...
    # Windows.Foundation.IMemoryBufferReference Windows.AI.MachineLearning.TensorUInt16Bit::CreateReference()
    def create_reference(self) -> windows_foundation.IMemoryBufferReference: ...
    # Windows.Foundation.Collections.IVectorView`1<System.UInt16> Windows.AI.MachineLearning.TensorUInt16Bit::GetAsVectorView()
    def get_as_vector_view(self) -> typing.Sequence[winrt.system.UInt16]: ...
    # Windows.AI.MachineLearning.LearningModelFeatureKind Windows.AI.MachineLearning.TensorUInt16Bit::get_Kind()
    @_property
    def kind(self) -> LearningModelFeatureKind: ...
    # Windows.Foundation.Collections.IVectorView`1<System.Int64> Windows.AI.MachineLearning.TensorUInt16Bit::get_Shape()
    @_property
    def shape(self) -> typing.Sequence[winrt.system.Int64]: ...
    # Windows.AI.MachineLearning.TensorKind Windows.AI.MachineLearning.TensorUInt16Bit::get_TensorKind()
    @_property
    def tensor_kind(self) -> TensorKind: ...

@typing.final
class TensorUInt32Bit_Static(winrt._winrt.IInspectable_Static):
    # Windows.AI.MachineLearning.TensorUInt32Bit Windows.AI.MachineLearning.TensorUInt32Bit::Create()
    def create(cls) -> TensorUInt32Bit: ...
    # Windows.AI.MachineLearning.TensorUInt32Bit Windows.AI.MachineLearning.TensorUInt32Bit::Create(Windows.Foundation.Collections.IIterable`1<System.Int64>)
    def create2(cls, shape: typing.Iterable[winrt.system.Int64], /) -> TensorUInt32Bit: ...
    # Windows.AI.MachineLearning.TensorUInt32Bit Windows.AI.MachineLearning.TensorUInt32Bit::CreateFromArray(Windows.Foundation.Collections.IIterable`1<System.Int64>,System.UInt32[])
    def create_from_array(cls, shape: typing.Iterable[winrt.system.Int64], data: typing.Union[winrt.system.Array[winrt.system.UInt32], winrt.system.ReadableBuffer], /) -> TensorUInt32Bit: ...
    # Windows.AI.MachineLearning.TensorUInt32Bit Windows.AI.MachineLearning.TensorUInt32Bit::CreateFromBuffer(System.Int64[],Windows.Storage.Streams.IBuffer)
    def create_from_buffer(cls, shape: typing.Union[winrt.system.Array[winrt.system.Int64], winrt.system.ReadableBuffer], buffer: winrt.system.Buffer, /) -> TensorUInt32Bit: ...
    # Windows.AI.MachineLearning.TensorUInt32Bit Windows.AI.MachineLearning.TensorUInt32Bit::CreateFromIterable(Windows.Foundation.Collections.IIterable`1<System.Int64>,Windows.Foundation.Collections.IIterable`1<System.UInt32>)
    def create_from_iterable(cls, shape: typing.Iterable[winrt.system.Int64], data: typing.Iterable[winrt.system.UInt32], /) -> TensorUInt32Bit: ...
    # Windows.AI.MachineLearning.TensorUInt32Bit Windows.AI.MachineLearning.TensorUInt32Bit::CreateFromShapeArrayAndDataArray(System.Int64[],System.UInt32[])
    def create_from_shape_array_and_data_array(cls, shape: typing.Union[winrt.system.Array[winrt.system.Int64], winrt.system.ReadableBuffer], data: typing.Union[winrt.system.Array[winrt.system.UInt32], winrt.system.ReadableBuffer], /) -> TensorUInt32Bit: ...

@typing.final
class TensorUInt32Bit(winrt.system.Object, windows_foundation.IMemoryBuffer, windows_foundation.IClosable, ITensor, ILearningModelFeatureValue, metaclass=TensorUInt32Bit_Static):
    def __enter__(self: Self) -> Self: ...
    def __exit__(self, exc_type: typing.Optional[typing.Type[BaseException]], exc_value: typing.Optional[BaseException], traceback: typing.Optional[types.TracebackType]) -> None: ...
    # System.Void Windows.AI.MachineLearning.TensorUInt32Bit::Close()
    def close(self) -> None: ...
    # Windows.Foundation.IMemoryBufferReference Windows.AI.MachineLearning.TensorUInt32Bit::CreateReference()
    def create_reference(self) -> windows_foundation.IMemoryBufferReference: ...
    # Windows.Foundation.Collections.IVectorView`1<System.UInt32> Windows.AI.MachineLearning.TensorUInt32Bit::GetAsVectorView()
    def get_as_vector_view(self) -> typing.Sequence[winrt.system.UInt32]: ...
    # Windows.AI.MachineLearning.LearningModelFeatureKind Windows.AI.MachineLearning.TensorUInt32Bit::get_Kind()
    @_property
    def kind(self) -> LearningModelFeatureKind: ...
    # Windows.Foundation.Collections.IVectorView`1<System.Int64> Windows.AI.MachineLearning.TensorUInt32Bit::get_Shape()
    @_property
    def shape(self) -> typing.Sequence[winrt.system.Int64]: ...
    # Windows.AI.MachineLearning.TensorKind Windows.AI.MachineLearning.TensorUInt32Bit::get_TensorKind()
    @_property
    def tensor_kind(self) -> TensorKind: ...

@typing.final
class TensorUInt64Bit_Static(winrt._winrt.IInspectable_Static):
    # Windows.AI.MachineLearning.TensorUInt64Bit Windows.AI.MachineLearning.TensorUInt64Bit::Create()
    def create(cls) -> TensorUInt64Bit: ...
    # Windows.AI.MachineLearning.TensorUInt64Bit Windows.AI.MachineLearning.TensorUInt64Bit::Create(Windows.Foundation.Collections.IIterable`1<System.Int64>)
    def create2(cls, shape: typing.Iterable[winrt.system.Int64], /) -> TensorUInt64Bit: ...
    # Windows.AI.MachineLearning.TensorUInt64Bit Windows.AI.MachineLearning.TensorUInt64Bit::CreateFromArray(Windows.Foundation.Collections.IIterable`1<System.Int64>,System.UInt64[])
    def create_from_array(cls, shape: typing.Iterable[winrt.system.Int64], data: typing.Union[winrt.system.Array[winrt.system.UInt64], winrt.system.ReadableBuffer], /) -> TensorUInt64Bit: ...
    # Windows.AI.MachineLearning.TensorUInt64Bit Windows.AI.MachineLearning.TensorUInt64Bit::CreateFromBuffer(System.Int64[],Windows.Storage.Streams.IBuffer)
    def create_from_buffer(cls, shape: typing.Union[winrt.system.Array[winrt.system.Int64], winrt.system.ReadableBuffer], buffer: winrt.system.Buffer, /) -> TensorUInt64Bit: ...
    # Windows.AI.MachineLearning.TensorUInt64Bit Windows.AI.MachineLearning.TensorUInt64Bit::CreateFromIterable(Windows.Foundation.Collections.IIterable`1<System.Int64>,Windows.Foundation.Collections.IIterable`1<System.UInt64>)
    def create_from_iterable(cls, shape: typing.Iterable[winrt.system.Int64], data: typing.Iterable[winrt.system.UInt64], /) -> TensorUInt64Bit: ...
    # Windows.AI.MachineLearning.TensorUInt64Bit Windows.AI.MachineLearning.TensorUInt64Bit::CreateFromShapeArrayAndDataArray(System.Int64[],System.UInt64[])
    def create_from_shape_array_and_data_array(cls, shape: typing.Union[winrt.system.Array[winrt.system.Int64], winrt.system.ReadableBuffer], data: typing.Union[winrt.system.Array[winrt.system.UInt64], winrt.system.ReadableBuffer], /) -> TensorUInt64Bit: ...

@typing.final
class TensorUInt64Bit(winrt.system.Object, windows_foundation.IMemoryBuffer, windows_foundation.IClosable, ITensor, ILearningModelFeatureValue, metaclass=TensorUInt64Bit_Static):
    def __enter__(self: Self) -> Self: ...
    def __exit__(self, exc_type: typing.Optional[typing.Type[BaseException]], exc_value: typing.Optional[BaseException], traceback: typing.Optional[types.TracebackType]) -> None: ...
    # System.Void Windows.AI.MachineLearning.TensorUInt64Bit::Close()
    def close(self) -> None: ...
    # Windows.Foundation.IMemoryBufferReference Windows.AI.MachineLearning.TensorUInt64Bit::CreateReference()
    def create_reference(self) -> windows_foundation.IMemoryBufferReference: ...
    # Windows.Foundation.Collections.IVectorView`1<System.UInt64> Windows.AI.MachineLearning.TensorUInt64Bit::GetAsVectorView()
    def get_as_vector_view(self) -> typing.Sequence[winrt.system.UInt64]: ...
    # Windows.AI.MachineLearning.LearningModelFeatureKind Windows.AI.MachineLearning.TensorUInt64Bit::get_Kind()
    @_property
    def kind(self) -> LearningModelFeatureKind: ...
    # Windows.Foundation.Collections.IVectorView`1<System.Int64> Windows.AI.MachineLearning.TensorUInt64Bit::get_Shape()
    @_property
    def shape(self) -> typing.Sequence[winrt.system.Int64]: ...
    # Windows.AI.MachineLearning.TensorKind Windows.AI.MachineLearning.TensorUInt64Bit::get_TensorKind()
    @_property
    def tensor_kind(self) -> TensorKind: ...

@typing.final
class TensorUInt8Bit_Static(winrt._winrt.IInspectable_Static):
    # Windows.AI.MachineLearning.TensorUInt8Bit Windows.AI.MachineLearning.TensorUInt8Bit::Create()
    def create(cls) -> TensorUInt8Bit: ...
    # Windows.AI.MachineLearning.TensorUInt8Bit Windows.AI.MachineLearning.TensorUInt8Bit::Create(Windows.Foundation.Collections.IIterable`1<System.Int64>)
    def create2(cls, shape: typing.Iterable[winrt.system.Int64], /) -> TensorUInt8Bit: ...
    # Windows.AI.MachineLearning.TensorUInt8Bit Windows.AI.MachineLearning.TensorUInt8Bit::CreateFromArray(Windows.Foundation.Collections.IIterable`1<System.Int64>,System.Byte[])
    def create_from_array(cls, shape: typing.Iterable[winrt.system.Int64], data: typing.Union[winrt.system.Array[winrt.system.UInt8], winrt.system.ReadableBuffer], /) -> TensorUInt8Bit: ...
    # Windows.AI.MachineLearning.TensorUInt8Bit Windows.AI.MachineLearning.TensorUInt8Bit::CreateFromBuffer(System.Int64[],Windows.Storage.Streams.IBuffer)
    def create_from_buffer(cls, shape: typing.Union[winrt.system.Array[winrt.system.Int64], winrt.system.ReadableBuffer], buffer: winrt.system.Buffer, /) -> TensorUInt8Bit: ...
    # Windows.AI.MachineLearning.TensorUInt8Bit Windows.AI.MachineLearning.TensorUInt8Bit::CreateFromIterable(Windows.Foundation.Collections.IIterable`1<System.Int64>,Windows.Foundation.Collections.IIterable`1<System.Byte>)
    def create_from_iterable(cls, shape: typing.Iterable[winrt.system.Int64], data: typing.Iterable[winrt.system.UInt8], /) -> TensorUInt8Bit: ...
    # Windows.AI.MachineLearning.TensorUInt8Bit Windows.AI.MachineLearning.TensorUInt8Bit::CreateFromShapeArrayAndDataArray(System.Int64[],System.Byte[])
    def create_from_shape_array_and_data_array(cls, shape: typing.Union[winrt.system.Array[winrt.system.Int64], winrt.system.ReadableBuffer], data: typing.Union[winrt.system.Array[winrt.system.UInt8], winrt.system.ReadableBuffer], /) -> TensorUInt8Bit: ...

@typing.final
class TensorUInt8Bit(winrt.system.Object, windows_foundation.IMemoryBuffer, windows_foundation.IClosable, ITensor, ILearningModelFeatureValue, metaclass=TensorUInt8Bit_Static):
    def __enter__(self: Self) -> Self: ...
    def __exit__(self, exc_type: typing.Optional[typing.Type[BaseException]], exc_value: typing.Optional[BaseException], traceback: typing.Optional[types.TracebackType]) -> None: ...
    # System.Void Windows.AI.MachineLearning.TensorUInt8Bit::Close()
    def close(self) -> None: ...
    # Windows.Foundation.IMemoryBufferReference Windows.AI.MachineLearning.TensorUInt8Bit::CreateReference()
    def create_reference(self) -> windows_foundation.IMemoryBufferReference: ...
    # Windows.Foundation.Collections.IVectorView`1<System.Byte> Windows.AI.MachineLearning.TensorUInt8Bit::GetAsVectorView()
    def get_as_vector_view(self) -> typing.Sequence[winrt.system.UInt8]: ...
    # Windows.AI.MachineLearning.LearningModelFeatureKind Windows.AI.MachineLearning.TensorUInt8Bit::get_Kind()
    @_property
    def kind(self) -> LearningModelFeatureKind: ...
    # Windows.Foundation.Collections.IVectorView`1<System.Int64> Windows.AI.MachineLearning.TensorUInt8Bit::get_Shape()
    @_property
    def shape(self) -> typing.Sequence[winrt.system.Int64]: ...
    # Windows.AI.MachineLearning.TensorKind Windows.AI.MachineLearning.TensorUInt8Bit::get_TensorKind()
    @_property
    def tensor_kind(self) -> TensorKind: ...

@typing.final
class _ILearningModelFeatureDescriptor: ...

class ILearningModelFeatureDescriptor(winrt._winrt.IInspectable):
    # System.String Windows.AI.MachineLearning.ILearningModelFeatureDescriptor::get_Description()
    @_property
    @abstractmethod
    def description(self) -> str: ...
    # System.Boolean Windows.AI.MachineLearning.ILearningModelFeatureDescriptor::get_IsRequired()
    @_property
    @abstractmethod
    def is_required(self) -> bool: ...
    # Windows.AI.MachineLearning.LearningModelFeatureKind Windows.AI.MachineLearning.ILearningModelFeatureDescriptor::get_Kind()
    @_property
    @abstractmethod
    def kind(self) -> LearningModelFeatureKind: ...
    # System.String Windows.AI.MachineLearning.ILearningModelFeatureDescriptor::get_Name()
    @_property
    @abstractmethod
    def name(self) -> str: ...

@typing.final
class _ILearningModelFeatureValue: ...

class ILearningModelFeatureValue(winrt._winrt.IInspectable):
    # Windows.AI.MachineLearning.LearningModelFeatureKind Windows.AI.MachineLearning.ILearningModelFeatureValue::get_Kind()
    @_property
    @abstractmethod
    def kind(self) -> LearningModelFeatureKind: ...

@typing.final
class _ILearningModelOperatorProvider: ...

class ILearningModelOperatorProvider(winrt._winrt.IInspectable):  # type: ignore[misc]
    pass

@typing.final
class _ITensor: ...

class ITensor(ILearningModelFeatureValue, winrt._winrt.IInspectable):
    # Windows.Foundation.Collections.IVectorView`1<System.Int64> Windows.AI.MachineLearning.ITensor::get_Shape()
    @_property
    @abstractmethod
    def shape(self) -> typing.Sequence[winrt.system.Int64]: ...
    # Windows.AI.MachineLearning.TensorKind Windows.AI.MachineLearning.ITensor::get_TensorKind()
    @_property
    @abstractmethod
    def tensor_kind(self) -> TensorKind: ...

