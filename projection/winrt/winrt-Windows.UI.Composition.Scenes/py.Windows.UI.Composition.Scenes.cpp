// WARNING: Please don't edit this file. It was generated by Python/WinRT v3.1.0

#include "py.Windows.UI.Composition.Scenes.h"

namespace py::cpp::Windows::UI::Composition::Scenes
{
    // ----- SceneBoundingBox class --------------------

    static PyObject* _new_SceneBoundingBox(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Composition::Scenes::SceneBoundingBox>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Composition::Scenes::SceneBoundingBox>::type_name);
        return nullptr;
    }

    static void _dealloc_SceneBoundingBox(py::wrapper::Windows::UI::Composition::Scenes::SceneBoundingBox* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SceneBoundingBox_get_Center(py::wrapper::Windows::UI::Composition::Scenes::SceneBoundingBox* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Composition.Scenes.SceneBoundingBox", L"Center");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Center();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SceneBoundingBox_get_Extents(py::wrapper::Windows::UI::Composition::Scenes::SceneBoundingBox* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Composition.Scenes.SceneBoundingBox", L"Extents");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Extents();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SceneBoundingBox_get_Max(py::wrapper::Windows::UI::Composition::Scenes::SceneBoundingBox* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Composition.Scenes.SceneBoundingBox", L"Max");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Max();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SceneBoundingBox_get_Min(py::wrapper::Windows::UI::Composition::Scenes::SceneBoundingBox* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Composition.Scenes.SceneBoundingBox", L"Min");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Min();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SceneBoundingBox_get_Size(py::wrapper::Windows::UI::Composition::Scenes::SceneBoundingBox* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Composition.Scenes.SceneBoundingBox", L"Size");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Size();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SceneBoundingBox(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Composition::Scenes::SceneBoundingBox>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SceneBoundingBox(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Composition::Scenes::SceneBoundingBox>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SceneBoundingBox[] = {
        { "_assign_array_", _assign_array_SceneBoundingBox, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SceneBoundingBox), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_SceneBoundingBox[] = {
        { "center", reinterpret_cast<getter>(SceneBoundingBox_get_Center), nullptr, nullptr, nullptr },
        { "extents", reinterpret_cast<getter>(SceneBoundingBox_get_Extents), nullptr, nullptr, nullptr },
        { "max", reinterpret_cast<getter>(SceneBoundingBox_get_Max), nullptr, nullptr, nullptr },
        { "min", reinterpret_cast<getter>(SceneBoundingBox_get_Min), nullptr, nullptr, nullptr },
        { "size", reinterpret_cast<getter>(SceneBoundingBox_get_Size), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_SceneBoundingBox[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_SceneBoundingBox) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SceneBoundingBox) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SceneBoundingBox) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SceneBoundingBox) },
        { }};

    static PyType_Spec type_spec_SceneBoundingBox = {
        "winrt._winrt_windows_ui_composition_scenes.SceneBoundingBox",
        sizeof(py::wrapper::Windows::UI::Composition::Scenes::SceneBoundingBox),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SceneBoundingBox};

    // ----- SceneComponent class --------------------

    static PyObject* _new_SceneComponent(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Composition::Scenes::SceneComponent>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Composition::Scenes::SceneComponent>::type_name);
        return nullptr;
    }

    static void _dealloc_SceneComponent(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SceneComponent_get_ComponentType(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Composition.Scenes.SceneComponent", L"ComponentType");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Windows::UI::Composition::Scenes::SceneComponent>().ComponentType();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SceneComponent(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Composition::Scenes::SceneComponent>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SceneComponent(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Composition::Scenes::SceneComponent>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SceneComponent[] = {
        { "_assign_array_", _assign_array_SceneComponent, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SceneComponent), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_SceneComponent[] = {
        { "component_type", reinterpret_cast<getter>(SceneComponent_get_ComponentType), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_SceneComponent[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_SceneComponent) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SceneComponent) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SceneComponent) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SceneComponent) },
        { }};

    static PyType_Spec type_spec_SceneComponent = {
        "winrt._winrt_windows_ui_composition_scenes.SceneComponent",
        sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_SceneComponent};

    static PyGetSetDef getset_SceneComponent_Static[] = {
        { }};

    static PyMethodDef methods_SceneComponent_Static[] = {
        { }};

    static PyType_Slot type_slots_SceneComponent_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_SceneComponent_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_SceneComponent_Static) },
        { }
    };

    static PyType_Spec type_spec_SceneComponent_Static = {
        "winrt._winrt_windows_ui_composition_scenes.SceneComponent_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_SceneComponent_Static};

    // ----- SceneComponentCollection class --------------------

    static PyObject* _new_SceneComponentCollection(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Composition::Scenes::SceneComponentCollection>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Composition::Scenes::SceneComponentCollection>::type_name);
        return nullptr;
    }

    static void _dealloc_SceneComponentCollection(py::wrapper::Windows::UI::Composition::Scenes::SceneComponentCollection* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SceneComponentCollection_Append(py::wrapper::Windows::UI::Composition::Scenes::SceneComponentCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Composition.Scenes.SceneComponentCollection", L"Append", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Composition::Scenes::SceneComponent>(args, 0);

                {
                    auto _gil = release_gil();
                    self->obj.Append(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SceneComponentCollection_Clear(py::wrapper::Windows::UI::Composition::Scenes::SceneComponentCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Composition.Scenes.SceneComponentCollection", L"Clear", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.Clear();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SceneComponentCollection_First(py::wrapper::Windows::UI::Composition::Scenes::SceneComponentCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Composition.Scenes.SceneComponentCollection", L"First", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.First();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SceneComponentCollection_GetAt(py::wrapper::Windows::UI::Composition::Scenes::SceneComponentCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Composition.Scenes.SceneComponentCollection", L"GetAt", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint32_t>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetAt(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SceneComponentCollection_GetMany(py::wrapper::Windows::UI::Composition::Scenes::SceneComponentCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Composition.Scenes.SceneComponentCollection", L"GetMany", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<winrt::Windows::UI::Composition::Scenes::SceneComponent, true>>(args, 1);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetMany(param0, param1);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SceneComponentCollection_GetView(py::wrapper::Windows::UI::Composition::Scenes::SceneComponentCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Composition.Scenes.SceneComponentCollection", L"GetView", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetView();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SceneComponentCollection_IndexOf(py::wrapper::Windows::UI::Composition::Scenes::SceneComponentCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Composition.Scenes.SceneComponentCollection", L"IndexOf", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Composition::Scenes::SceneComponent>(args, 0);
                uint32_t param1{};

                auto return_value = [&]()
                {
                    auto _gil = release_gil();
                    return self->obj.IndexOf(param0, param1);
                }();

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }

                return PyTuple_Pack(2, out_return_value.get(), out1.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SceneComponentCollection_InsertAt(py::wrapper::Windows::UI::Composition::Scenes::SceneComponentCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Composition.Scenes.SceneComponentCollection", L"InsertAt", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Composition::Scenes::SceneComponent>(args, 1);

                {
                    auto _gil = release_gil();
                    self->obj.InsertAt(param0, param1);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SceneComponentCollection_RemoveAt(py::wrapper::Windows::UI::Composition::Scenes::SceneComponentCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Composition.Scenes.SceneComponentCollection", L"RemoveAt", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint32_t>(args, 0);

                {
                    auto _gil = release_gil();
                    self->obj.RemoveAt(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SceneComponentCollection_RemoveAtEnd(py::wrapper::Windows::UI::Composition::Scenes::SceneComponentCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Composition.Scenes.SceneComponentCollection", L"RemoveAtEnd", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.RemoveAtEnd();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SceneComponentCollection_ReplaceAll(py::wrapper::Windows::UI::Composition::Scenes::SceneComponentCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Composition.Scenes.SceneComponentCollection", L"ReplaceAll", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<py::pybuf_view<winrt::Windows::UI::Composition::Scenes::SceneComponent, false>>(args, 0);

                {
                    auto _gil = release_gil();
                    self->obj.ReplaceAll(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SceneComponentCollection_SetAt(py::wrapper::Windows::UI::Composition::Scenes::SceneComponentCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Composition.Scenes.SceneComponentCollection", L"SetAt", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Composition::Scenes::SceneComponent>(args, 1);

                {
                    auto _gil = release_gil();
                    self->obj.SetAt(param0, param1);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SceneComponentCollection_get_Size(py::wrapper::Windows::UI::Composition::Scenes::SceneComponentCollection* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Composition.Scenes.SceneComponentCollection", L"Size");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Size();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SceneComponentCollection(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Composition::Scenes::SceneComponentCollection>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SceneComponentCollection(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Composition::Scenes::SceneComponentCollection>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _iterator_SceneComponentCollection(py::wrapper::Windows::UI::Composition::Scenes::SceneComponentCollection* self) noexcept
    {
        try
        {
            return py::convert([&]()
            {
                auto _gil = py::release_gil();
                return self->obj.First();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static Py_ssize_t _seq_length_SceneComponentCollection(py::wrapper::Windows::UI::Composition::Scenes::SceneComponentCollection* self) noexcept
    {
        try
        {
            auto _gil = py::release_gil();
            return static_cast<Py_ssize_t>(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _seq_item_SceneComponentCollection(py::wrapper::Windows::UI::Composition::Scenes::SceneComponentCollection* self, Py_ssize_t i) noexcept
    {
        try
        {
            return py::convert([&]()
            {
                auto _gil = py::release_gil();
                return self->obj.GetAt(static_cast<uint32_t>(i));
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _seq_subscript_SceneComponentCollection(py::wrapper::Windows::UI::Composition::Scenes::SceneComponentCollection* self, PyObject* slice) noexcept
    {
        try
        {
            if (PyIndex_Check(slice))
            {
                pyobj_handle index{PyNumber_Index(slice)};

                if (!index)
                {
                    return nullptr;
                }

                auto i = PyNumber_AsSsize_t(index.get(), PyExc_IndexError);

                if (i == -1 && PyErr_Occurred())
                {
                    return nullptr;
                }

                return _seq_item_SceneComponentCollection(self, i);
            }

            if (!PySlice_Check(slice))
            {
                PyErr_Format(PyExc_TypeError, "indices must be integers, not '%s'", Py_TYPE(slice)->tp_name);
            }

            Py_ssize_t start, stop, step, length;

            auto size = [&]()
            {
                auto _gil = py::release_gil();
                return self->obj.Size();
            }();
            if (PySlice_GetIndicesEx(slice, size, &start, &stop, &step, &length) < 0)
            {
                return nullptr;
            }

            if (step != 1)
            {
                PyErr_SetString(PyExc_NotImplementedError, "slices with step other than 1 are not implemented");
                return nullptr;
            }

            winrt::com_array<winrt::Windows::UI::Composition::Scenes::SceneComponent> items(static_cast<uint32_t>(length), empty_instance<winrt::Windows::UI::Composition::Scenes::SceneComponent>::get());

            auto count = [&]()
            {
                auto _gil = py::release_gil();
                return self->obj.GetMany(static_cast<uint32_t>(start), items);
            }();

            if (count != static_cast<uint32_t>(length))
            {
                PyErr_Format(PyExc_RuntimeError, "returned count %d did not match requested length %zd", count, length);
                return nullptr;
            }

            return convert(items);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int _seq_assign_SceneComponentCollection(py::wrapper::Windows::UI::Composition::Scenes::SceneComponentCollection* self, Py_ssize_t i, PyObject* value) noexcept
    {
        try
        {
            if (!value)
            {
                auto _gil = py::release_gil();
                self->obj.RemoveAt(static_cast<uint32_t>(i));
            }
            else
            {
                auto _value = py::convert_to<winrt::Windows::UI::Composition::Scenes::SceneComponent>(value);
                {
                    auto _gil = py::release_gil();
                    self->obj.SetAt(static_cast<uint32_t>(i), _value);
                }
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyMethodDef _methods_SceneComponentCollection[] = {
        { "append", reinterpret_cast<PyCFunction>(SceneComponentCollection_Append), METH_VARARGS, nullptr },
        { "clear", reinterpret_cast<PyCFunction>(SceneComponentCollection_Clear), METH_VARARGS, nullptr },
        { "first", reinterpret_cast<PyCFunction>(SceneComponentCollection_First), METH_VARARGS, nullptr },
        { "get_at", reinterpret_cast<PyCFunction>(SceneComponentCollection_GetAt), METH_VARARGS, nullptr },
        { "get_many", reinterpret_cast<PyCFunction>(SceneComponentCollection_GetMany), METH_VARARGS, nullptr },
        { "get_view", reinterpret_cast<PyCFunction>(SceneComponentCollection_GetView), METH_VARARGS, nullptr },
        { "index_of", reinterpret_cast<PyCFunction>(SceneComponentCollection_IndexOf), METH_VARARGS, nullptr },
        { "insert_at", reinterpret_cast<PyCFunction>(SceneComponentCollection_InsertAt), METH_VARARGS, nullptr },
        { "remove_at", reinterpret_cast<PyCFunction>(SceneComponentCollection_RemoveAt), METH_VARARGS, nullptr },
        { "remove_at_end", reinterpret_cast<PyCFunction>(SceneComponentCollection_RemoveAtEnd), METH_VARARGS, nullptr },
        { "replace_all", reinterpret_cast<PyCFunction>(SceneComponentCollection_ReplaceAll), METH_VARARGS, nullptr },
        { "set_at", reinterpret_cast<PyCFunction>(SceneComponentCollection_SetAt), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_SceneComponentCollection, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SceneComponentCollection), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_SceneComponentCollection[] = {
        { "size", reinterpret_cast<getter>(SceneComponentCollection_get_Size), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_SceneComponentCollection[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_SceneComponentCollection) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SceneComponentCollection) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SceneComponentCollection) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SceneComponentCollection) },
        { Py_tp_iter, reinterpret_cast<void*>(_iterator_SceneComponentCollection) },
        { Py_sq_length, reinterpret_cast<void*>(_seq_length_SceneComponentCollection) },
        { Py_sq_item, reinterpret_cast<void*>(_seq_item_SceneComponentCollection) },
        { Py_mp_subscript, reinterpret_cast<void*>(_seq_subscript_SceneComponentCollection) },
        { Py_sq_ass_item, reinterpret_cast<void*>(_seq_assign_SceneComponentCollection) },
        { }};

    static PyType_Spec type_spec_SceneComponentCollection = {
        "winrt._winrt_windows_ui_composition_scenes.SceneComponentCollection",
        sizeof(py::wrapper::Windows::UI::Composition::Scenes::SceneComponentCollection),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SceneComponentCollection};

    // ----- SceneMaterial class --------------------

    static PyObject* _new_SceneMaterial(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Composition::Scenes::SceneMaterial>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Composition::Scenes::SceneMaterial>::type_name);
        return nullptr;
    }

    static void _dealloc_SceneMaterial(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_SceneMaterial(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Composition::Scenes::SceneMaterial>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SceneMaterial(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Composition::Scenes::SceneMaterial>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SceneMaterial[] = {
        { "_assign_array_", _assign_array_SceneMaterial, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SceneMaterial), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_SceneMaterial[] = {
        { }};

    static PyType_Slot _type_slots_SceneMaterial[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_SceneMaterial) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SceneMaterial) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SceneMaterial) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SceneMaterial) },
        { }};

    static PyType_Spec type_spec_SceneMaterial = {
        "winrt._winrt_windows_ui_composition_scenes.SceneMaterial",
        sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_SceneMaterial};

    static PyGetSetDef getset_SceneMaterial_Static[] = {
        { }};

    static PyMethodDef methods_SceneMaterial_Static[] = {
        { }};

    static PyType_Slot type_slots_SceneMaterial_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_SceneMaterial_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_SceneMaterial_Static) },
        { }
    };

    static PyType_Spec type_spec_SceneMaterial_Static = {
        "winrt._winrt_windows_ui_composition_scenes.SceneMaterial_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_SceneMaterial_Static};

    // ----- SceneMaterialInput class --------------------

    static PyObject* _new_SceneMaterialInput(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Composition::Scenes::SceneMaterialInput>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Composition::Scenes::SceneMaterialInput>::type_name);
        return nullptr;
    }

    static void _dealloc_SceneMaterialInput(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_SceneMaterialInput(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Composition::Scenes::SceneMaterialInput>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SceneMaterialInput(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Composition::Scenes::SceneMaterialInput>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SceneMaterialInput[] = {
        { "_assign_array_", _assign_array_SceneMaterialInput, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SceneMaterialInput), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_SceneMaterialInput[] = {
        { }};

    static PyType_Slot _type_slots_SceneMaterialInput[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_SceneMaterialInput) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SceneMaterialInput) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SceneMaterialInput) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SceneMaterialInput) },
        { }};

    static PyType_Spec type_spec_SceneMaterialInput = {
        "winrt._winrt_windows_ui_composition_scenes.SceneMaterialInput",
        sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_SceneMaterialInput};

    static PyGetSetDef getset_SceneMaterialInput_Static[] = {
        { }};

    static PyMethodDef methods_SceneMaterialInput_Static[] = {
        { }};

    static PyType_Slot type_slots_SceneMaterialInput_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_SceneMaterialInput_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_SceneMaterialInput_Static) },
        { }
    };

    static PyType_Spec type_spec_SceneMaterialInput_Static = {
        "winrt._winrt_windows_ui_composition_scenes.SceneMaterialInput_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_SceneMaterialInput_Static};

    // ----- SceneMesh class --------------------

    static PyObject* _new_SceneMesh(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Composition::Scenes::SceneMesh>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Composition::Scenes::SceneMesh>::type_name);
        return nullptr;
    }

    static void _dealloc_SceneMesh(py::wrapper::Windows::UI::Composition::Scenes::SceneMesh* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SceneMesh_Create(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Composition.Scenes.SceneMesh", L"Create", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Composition::Compositor>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::UI::Composition::Scenes::SceneMesh::Create(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SceneMesh_FillMeshAttribute(py::wrapper::Windows::UI::Composition::Scenes::SceneMesh* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 3)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Composition.Scenes.SceneMesh", L"FillMeshAttribute", 3);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Composition::Scenes::SceneAttributeSemantic>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Graphics::DirectX::DirectXPixelFormat>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::MemoryBuffer>(args, 2);

                {
                    auto _gil = release_gil();
                    self->obj.FillMeshAttribute(param0, param1, param2);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SceneMesh_get_PrimitiveTopology(py::wrapper::Windows::UI::Composition::Scenes::SceneMesh* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Composition.Scenes.SceneMesh", L"PrimitiveTopology");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PrimitiveTopology();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SceneMesh_put_PrimitiveTopology(py::wrapper::Windows::UI::Composition::Scenes::SceneMesh* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Composition.Scenes.SceneMesh", L"PrimitiveTopology");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Graphics::DirectX::DirectXPrimitiveTopology>(arg);

            {
                auto _gil = release_gil();
                self->obj.PrimitiveTopology(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SceneMesh_get_Bounds(py::wrapper::Windows::UI::Composition::Scenes::SceneMesh* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Composition.Scenes.SceneMesh", L"Bounds");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Bounds();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SceneMesh(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Composition::Scenes::SceneMesh>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SceneMesh(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Composition::Scenes::SceneMesh>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SceneMesh[] = {
        { "fill_mesh_attribute", reinterpret_cast<PyCFunction>(SceneMesh_FillMeshAttribute), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_SceneMesh, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SceneMesh), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_SceneMesh[] = {
        { "primitive_topology", reinterpret_cast<getter>(SceneMesh_get_PrimitiveTopology), reinterpret_cast<setter>(SceneMesh_put_PrimitiveTopology), nullptr, nullptr },
        { "bounds", reinterpret_cast<getter>(SceneMesh_get_Bounds), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_SceneMesh[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_SceneMesh) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SceneMesh) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SceneMesh) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SceneMesh) },
        { }};

    static PyType_Spec type_spec_SceneMesh = {
        "winrt._winrt_windows_ui_composition_scenes.SceneMesh",
        sizeof(py::wrapper::Windows::UI::Composition::Scenes::SceneMesh),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SceneMesh};

    static PyGetSetDef getset_SceneMesh_Static[] = {
        { }};

    static PyMethodDef methods_SceneMesh_Static[] = {
        { "create", reinterpret_cast<PyCFunction>(SceneMesh_Create), METH_VARARGS, nullptr },
        { }};

    static PyType_Slot type_slots_SceneMesh_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_SceneMesh_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_SceneMesh_Static) },
        { }
    };

    static PyType_Spec type_spec_SceneMesh_Static = {
        "winrt._winrt_windows_ui_composition_scenes.SceneMesh_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_SceneMesh_Static};

    // ----- SceneMeshMaterialAttributeMap class --------------------

    static PyObject* _new_SceneMeshMaterialAttributeMap(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Composition::Scenes::SceneMeshMaterialAttributeMap>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Composition::Scenes::SceneMeshMaterialAttributeMap>::type_name);
        return nullptr;
    }

    static void _dealloc_SceneMeshMaterialAttributeMap(py::wrapper::Windows::UI::Composition::Scenes::SceneMeshMaterialAttributeMap* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SceneMeshMaterialAttributeMap_Clear(py::wrapper::Windows::UI::Composition::Scenes::SceneMeshMaterialAttributeMap* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Composition.Scenes.SceneMeshMaterialAttributeMap", L"Clear", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.Clear();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SceneMeshMaterialAttributeMap_First(py::wrapper::Windows::UI::Composition::Scenes::SceneMeshMaterialAttributeMap* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Composition.Scenes.SceneMeshMaterialAttributeMap", L"First", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.First();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SceneMeshMaterialAttributeMap_GetView(py::wrapper::Windows::UI::Composition::Scenes::SceneMeshMaterialAttributeMap* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Composition.Scenes.SceneMeshMaterialAttributeMap", L"GetView", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetView();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SceneMeshMaterialAttributeMap_HasKey(py::wrapper::Windows::UI::Composition::Scenes::SceneMeshMaterialAttributeMap* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Composition.Scenes.SceneMeshMaterialAttributeMap", L"HasKey", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.HasKey(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SceneMeshMaterialAttributeMap_Insert(py::wrapper::Windows::UI::Composition::Scenes::SceneMeshMaterialAttributeMap* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Composition.Scenes.SceneMeshMaterialAttributeMap", L"Insert", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Composition::Scenes::SceneAttributeSemantic>(args, 1);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.Insert(param0, param1);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SceneMeshMaterialAttributeMap_Lookup(py::wrapper::Windows::UI::Composition::Scenes::SceneMeshMaterialAttributeMap* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Composition.Scenes.SceneMeshMaterialAttributeMap", L"Lookup", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.Lookup(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SceneMeshMaterialAttributeMap_Remove(py::wrapper::Windows::UI::Composition::Scenes::SceneMeshMaterialAttributeMap* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Composition.Scenes.SceneMeshMaterialAttributeMap", L"Remove", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                {
                    auto _gil = release_gil();
                    self->obj.Remove(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SceneMeshMaterialAttributeMap_get_Size(py::wrapper::Windows::UI::Composition::Scenes::SceneMeshMaterialAttributeMap* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Composition.Scenes.SceneMeshMaterialAttributeMap", L"Size");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Size();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SceneMeshMaterialAttributeMap(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Composition::Scenes::SceneMeshMaterialAttributeMap>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SceneMeshMaterialAttributeMap(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Composition::Scenes::SceneMeshMaterialAttributeMap>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _iterator_SceneMeshMaterialAttributeMap(py::wrapper::Windows::UI::Composition::Scenes::SceneMeshMaterialAttributeMap* self) noexcept
    {
        try
        {
            py::pyobj_handle iter{py::convert([&]()
            {
                auto _gil = py::release_gil();
                return self->obj.First();
            }())};

            if (!iter)
            {
                return nullptr;
            }

            return py::wrap_mapping_iter(iter.get());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int _map_contains_SceneMeshMaterialAttributeMap(py::wrapper::Windows::UI::Composition::Scenes::SceneMeshMaterialAttributeMap* self, PyObject* key) noexcept
    {
        try
        {
            auto _key = py::convert_to<winrt::hstring>(key);
            {
                auto _gil = py::release_gil();
                return static_cast<int>(self->obj.HasKey(_key));
            }
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static Py_ssize_t _map_length_SceneMeshMaterialAttributeMap(py::wrapper::Windows::UI::Composition::Scenes::SceneMeshMaterialAttributeMap* self) noexcept
    {
        try
        {
            auto _gil = py::release_gil();
            return static_cast<Py_ssize_t>(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _map_subscript_SceneMeshMaterialAttributeMap(py::wrapper::Windows::UI::Composition::Scenes::SceneMeshMaterialAttributeMap* self, PyObject* key) noexcept
    {
        try
        {
            auto _key = py::convert_to<winrt::hstring>(key);
            auto value = [&]()
            {
                auto _gil = py::release_gil();
                return self->obj.TryLookup(_key);
            }();

            if (!value)
            {
                if constexpr (std::is_base_of_v<winrt::Windows::Foundation::IUnknown, decltype(value)>)
                {
                    auto has_key = [&]()
                    {
                        auto _gil = py::release_gil();
                        return self->obj.HasKey(_key);
                    }();

                    if (has_key)
                    {
                        Py_RETURN_NONE;
                    }
                }

                PyErr_SetObject(PyExc_KeyError, key);
                return nullptr;
            }

            return py::convert(value);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int _map_assign_SceneMeshMaterialAttributeMap(py::wrapper::Windows::UI::Composition::Scenes::SceneMeshMaterialAttributeMap* self, PyObject* key, PyObject* value) noexcept
    {
        try
        {
            auto _key = py::convert_to<winrt::hstring>(key);

            if (!value)
            {
                bool did_remove;
                {
                    auto _gil = py::release_gil();
                    did_remove = self->obj.TryRemove(_key);
                }
                if (!did_remove)
                {
                    PyErr_SetObject(PyExc_KeyError, key);
                    return -1;
                }

                return 0;
            }

            auto _value = py::convert_to<winrt::Windows::UI::Composition::Scenes::SceneAttributeSemantic>(value);
            {
                auto _gil = py::release_gil();
                self->obj.Insert(_key, _value);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyMethodDef _methods_SceneMeshMaterialAttributeMap[] = {
        { "clear", reinterpret_cast<PyCFunction>(SceneMeshMaterialAttributeMap_Clear), METH_VARARGS, nullptr },
        { "first", reinterpret_cast<PyCFunction>(SceneMeshMaterialAttributeMap_First), METH_VARARGS, nullptr },
        { "get_view", reinterpret_cast<PyCFunction>(SceneMeshMaterialAttributeMap_GetView), METH_VARARGS, nullptr },
        { "has_key", reinterpret_cast<PyCFunction>(SceneMeshMaterialAttributeMap_HasKey), METH_VARARGS, nullptr },
        { "insert", reinterpret_cast<PyCFunction>(SceneMeshMaterialAttributeMap_Insert), METH_VARARGS, nullptr },
        { "lookup", reinterpret_cast<PyCFunction>(SceneMeshMaterialAttributeMap_Lookup), METH_VARARGS, nullptr },
        { "remove", reinterpret_cast<PyCFunction>(SceneMeshMaterialAttributeMap_Remove), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_SceneMeshMaterialAttributeMap, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SceneMeshMaterialAttributeMap), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_SceneMeshMaterialAttributeMap[] = {
        { "size", reinterpret_cast<getter>(SceneMeshMaterialAttributeMap_get_Size), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_SceneMeshMaterialAttributeMap[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_SceneMeshMaterialAttributeMap) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SceneMeshMaterialAttributeMap) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SceneMeshMaterialAttributeMap) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SceneMeshMaterialAttributeMap) },
        { Py_tp_iter, reinterpret_cast<void*>(_iterator_SceneMeshMaterialAttributeMap) },
        { Py_sq_contains, reinterpret_cast<void*>(_map_contains_SceneMeshMaterialAttributeMap) },
        { Py_mp_length, reinterpret_cast<void*>(_map_length_SceneMeshMaterialAttributeMap) },
        { Py_mp_subscript, reinterpret_cast<void*>(_map_subscript_SceneMeshMaterialAttributeMap) },
        { Py_mp_ass_subscript, reinterpret_cast<void*>(_map_assign_SceneMeshMaterialAttributeMap) },
        { }};

    static PyType_Spec type_spec_SceneMeshMaterialAttributeMap = {
        "winrt._winrt_windows_ui_composition_scenes.SceneMeshMaterialAttributeMap",
        sizeof(py::wrapper::Windows::UI::Composition::Scenes::SceneMeshMaterialAttributeMap),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SceneMeshMaterialAttributeMap};

    // ----- SceneMeshRendererComponent class --------------------

    static PyObject* _new_SceneMeshRendererComponent(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Composition::Scenes::SceneMeshRendererComponent>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Composition::Scenes::SceneMeshRendererComponent>::type_name);
        return nullptr;
    }

    static void _dealloc_SceneMeshRendererComponent(py::wrapper::Windows::UI::Composition::Scenes::SceneMeshRendererComponent* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SceneMeshRendererComponent_Create(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Composition.Scenes.SceneMeshRendererComponent", L"Create", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Composition::Compositor>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::UI::Composition::Scenes::SceneMeshRendererComponent::Create(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SceneMeshRendererComponent_get_Mesh(py::wrapper::Windows::UI::Composition::Scenes::SceneMeshRendererComponent* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Composition.Scenes.SceneMeshRendererComponent", L"Mesh");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Mesh();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SceneMeshRendererComponent_put_Mesh(py::wrapper::Windows::UI::Composition::Scenes::SceneMeshRendererComponent* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Composition.Scenes.SceneMeshRendererComponent", L"Mesh");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Composition::Scenes::SceneMesh>(arg);

            {
                auto _gil = release_gil();
                self->obj.Mesh(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SceneMeshRendererComponent_get_Material(py::wrapper::Windows::UI::Composition::Scenes::SceneMeshRendererComponent* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Composition.Scenes.SceneMeshRendererComponent", L"Material");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Material();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SceneMeshRendererComponent_put_Material(py::wrapper::Windows::UI::Composition::Scenes::SceneMeshRendererComponent* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Composition.Scenes.SceneMeshRendererComponent", L"Material");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Composition::Scenes::SceneMaterial>(arg);

            {
                auto _gil = release_gil();
                self->obj.Material(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SceneMeshRendererComponent_get_UVMappings(py::wrapper::Windows::UI::Composition::Scenes::SceneMeshRendererComponent* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Composition.Scenes.SceneMeshRendererComponent", L"UVMappings");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.UVMappings();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SceneMeshRendererComponent(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Composition::Scenes::SceneMeshRendererComponent>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SceneMeshRendererComponent(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Composition::Scenes::SceneMeshRendererComponent>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SceneMeshRendererComponent[] = {
        { "_assign_array_", _assign_array_SceneMeshRendererComponent, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SceneMeshRendererComponent), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_SceneMeshRendererComponent[] = {
        { "mesh", reinterpret_cast<getter>(SceneMeshRendererComponent_get_Mesh), reinterpret_cast<setter>(SceneMeshRendererComponent_put_Mesh), nullptr, nullptr },
        { "material", reinterpret_cast<getter>(SceneMeshRendererComponent_get_Material), reinterpret_cast<setter>(SceneMeshRendererComponent_put_Material), nullptr, nullptr },
        { "u_v_mappings", reinterpret_cast<getter>(SceneMeshRendererComponent_get_UVMappings), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_SceneMeshRendererComponent[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_SceneMeshRendererComponent) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SceneMeshRendererComponent) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SceneMeshRendererComponent) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SceneMeshRendererComponent) },
        { }};

    static PyType_Spec type_spec_SceneMeshRendererComponent = {
        "winrt._winrt_windows_ui_composition_scenes.SceneMeshRendererComponent",
        sizeof(py::wrapper::Windows::UI::Composition::Scenes::SceneMeshRendererComponent),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SceneMeshRendererComponent};

    static PyGetSetDef getset_SceneMeshRendererComponent_Static[] = {
        { }};

    static PyMethodDef methods_SceneMeshRendererComponent_Static[] = {
        { "create", reinterpret_cast<PyCFunction>(SceneMeshRendererComponent_Create), METH_VARARGS, nullptr },
        { }};

    static PyType_Slot type_slots_SceneMeshRendererComponent_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_SceneMeshRendererComponent_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_SceneMeshRendererComponent_Static) },
        { }
    };

    static PyType_Spec type_spec_SceneMeshRendererComponent_Static = {
        "winrt._winrt_windows_ui_composition_scenes.SceneMeshRendererComponent_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_SceneMeshRendererComponent_Static};

    // ----- SceneMetallicRoughnessMaterial class --------------------

    static PyObject* _new_SceneMetallicRoughnessMaterial(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Composition::Scenes::SceneMetallicRoughnessMaterial>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Composition::Scenes::SceneMetallicRoughnessMaterial>::type_name);
        return nullptr;
    }

    static void _dealloc_SceneMetallicRoughnessMaterial(py::wrapper::Windows::UI::Composition::Scenes::SceneMetallicRoughnessMaterial* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SceneMetallicRoughnessMaterial_Create(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Composition.Scenes.SceneMetallicRoughnessMaterial", L"Create", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Composition::Compositor>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::UI::Composition::Scenes::SceneMetallicRoughnessMaterial::Create(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SceneMetallicRoughnessMaterial_get_RoughnessFactor(py::wrapper::Windows::UI::Composition::Scenes::SceneMetallicRoughnessMaterial* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Composition.Scenes.SceneMetallicRoughnessMaterial", L"RoughnessFactor");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.RoughnessFactor();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SceneMetallicRoughnessMaterial_put_RoughnessFactor(py::wrapper::Windows::UI::Composition::Scenes::SceneMetallicRoughnessMaterial* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Composition.Scenes.SceneMetallicRoughnessMaterial", L"RoughnessFactor");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<float>(arg);

            {
                auto _gil = release_gil();
                self->obj.RoughnessFactor(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SceneMetallicRoughnessMaterial_get_MetallicRoughnessInput(py::wrapper::Windows::UI::Composition::Scenes::SceneMetallicRoughnessMaterial* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Composition.Scenes.SceneMetallicRoughnessMaterial", L"MetallicRoughnessInput");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.MetallicRoughnessInput();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SceneMetallicRoughnessMaterial_put_MetallicRoughnessInput(py::wrapper::Windows::UI::Composition::Scenes::SceneMetallicRoughnessMaterial* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Composition.Scenes.SceneMetallicRoughnessMaterial", L"MetallicRoughnessInput");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Composition::Scenes::SceneMaterialInput>(arg);

            {
                auto _gil = release_gil();
                self->obj.MetallicRoughnessInput(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SceneMetallicRoughnessMaterial_get_MetallicFactor(py::wrapper::Windows::UI::Composition::Scenes::SceneMetallicRoughnessMaterial* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Composition.Scenes.SceneMetallicRoughnessMaterial", L"MetallicFactor");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.MetallicFactor();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SceneMetallicRoughnessMaterial_put_MetallicFactor(py::wrapper::Windows::UI::Composition::Scenes::SceneMetallicRoughnessMaterial* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Composition.Scenes.SceneMetallicRoughnessMaterial", L"MetallicFactor");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<float>(arg);

            {
                auto _gil = release_gil();
                self->obj.MetallicFactor(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SceneMetallicRoughnessMaterial_get_BaseColorInput(py::wrapper::Windows::UI::Composition::Scenes::SceneMetallicRoughnessMaterial* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Composition.Scenes.SceneMetallicRoughnessMaterial", L"BaseColorInput");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.BaseColorInput();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SceneMetallicRoughnessMaterial_put_BaseColorInput(py::wrapper::Windows::UI::Composition::Scenes::SceneMetallicRoughnessMaterial* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Composition.Scenes.SceneMetallicRoughnessMaterial", L"BaseColorInput");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Composition::Scenes::SceneMaterialInput>(arg);

            {
                auto _gil = release_gil();
                self->obj.BaseColorInput(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SceneMetallicRoughnessMaterial_get_BaseColorFactor(py::wrapper::Windows::UI::Composition::Scenes::SceneMetallicRoughnessMaterial* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Composition.Scenes.SceneMetallicRoughnessMaterial", L"BaseColorFactor");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.BaseColorFactor();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SceneMetallicRoughnessMaterial_put_BaseColorFactor(py::wrapper::Windows::UI::Composition::Scenes::SceneMetallicRoughnessMaterial* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Composition.Scenes.SceneMetallicRoughnessMaterial", L"BaseColorFactor");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::Numerics::float4>(arg);

            {
                auto _gil = release_gil();
                self->obj.BaseColorFactor(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_SceneMetallicRoughnessMaterial(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Composition::Scenes::SceneMetallicRoughnessMaterial>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SceneMetallicRoughnessMaterial(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Composition::Scenes::SceneMetallicRoughnessMaterial>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SceneMetallicRoughnessMaterial[] = {
        { "_assign_array_", _assign_array_SceneMetallicRoughnessMaterial, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SceneMetallicRoughnessMaterial), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_SceneMetallicRoughnessMaterial[] = {
        { "roughness_factor", reinterpret_cast<getter>(SceneMetallicRoughnessMaterial_get_RoughnessFactor), reinterpret_cast<setter>(SceneMetallicRoughnessMaterial_put_RoughnessFactor), nullptr, nullptr },
        { "metallic_roughness_input", reinterpret_cast<getter>(SceneMetallicRoughnessMaterial_get_MetallicRoughnessInput), reinterpret_cast<setter>(SceneMetallicRoughnessMaterial_put_MetallicRoughnessInput), nullptr, nullptr },
        { "metallic_factor", reinterpret_cast<getter>(SceneMetallicRoughnessMaterial_get_MetallicFactor), reinterpret_cast<setter>(SceneMetallicRoughnessMaterial_put_MetallicFactor), nullptr, nullptr },
        { "base_color_input", reinterpret_cast<getter>(SceneMetallicRoughnessMaterial_get_BaseColorInput), reinterpret_cast<setter>(SceneMetallicRoughnessMaterial_put_BaseColorInput), nullptr, nullptr },
        { "base_color_factor", reinterpret_cast<getter>(SceneMetallicRoughnessMaterial_get_BaseColorFactor), reinterpret_cast<setter>(SceneMetallicRoughnessMaterial_put_BaseColorFactor), nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_SceneMetallicRoughnessMaterial[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_SceneMetallicRoughnessMaterial) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SceneMetallicRoughnessMaterial) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SceneMetallicRoughnessMaterial) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SceneMetallicRoughnessMaterial) },
        { }};

    static PyType_Spec type_spec_SceneMetallicRoughnessMaterial = {
        "winrt._winrt_windows_ui_composition_scenes.SceneMetallicRoughnessMaterial",
        sizeof(py::wrapper::Windows::UI::Composition::Scenes::SceneMetallicRoughnessMaterial),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SceneMetallicRoughnessMaterial};

    static PyGetSetDef getset_SceneMetallicRoughnessMaterial_Static[] = {
        { }};

    static PyMethodDef methods_SceneMetallicRoughnessMaterial_Static[] = {
        { "create", reinterpret_cast<PyCFunction>(SceneMetallicRoughnessMaterial_Create), METH_VARARGS, nullptr },
        { }};

    static PyType_Slot type_slots_SceneMetallicRoughnessMaterial_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_SceneMetallicRoughnessMaterial_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_SceneMetallicRoughnessMaterial_Static) },
        { }
    };

    static PyType_Spec type_spec_SceneMetallicRoughnessMaterial_Static = {
        "winrt._winrt_windows_ui_composition_scenes.SceneMetallicRoughnessMaterial_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_SceneMetallicRoughnessMaterial_Static};

    // ----- SceneModelTransform class --------------------

    static PyObject* _new_SceneModelTransform(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Composition::Scenes::SceneModelTransform>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Composition::Scenes::SceneModelTransform>::type_name);
        return nullptr;
    }

    static void _dealloc_SceneModelTransform(py::wrapper::Windows::UI::Composition::Scenes::SceneModelTransform* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SceneModelTransform_get_Translation(py::wrapper::Windows::UI::Composition::Scenes::SceneModelTransform* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Composition.Scenes.SceneModelTransform", L"Translation");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Translation();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SceneModelTransform_put_Translation(py::wrapper::Windows::UI::Composition::Scenes::SceneModelTransform* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Composition.Scenes.SceneModelTransform", L"Translation");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::Numerics::float3>(arg);

            {
                auto _gil = release_gil();
                self->obj.Translation(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SceneModelTransform_get_Scale(py::wrapper::Windows::UI::Composition::Scenes::SceneModelTransform* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Composition.Scenes.SceneModelTransform", L"Scale");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Scale();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SceneModelTransform_put_Scale(py::wrapper::Windows::UI::Composition::Scenes::SceneModelTransform* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Composition.Scenes.SceneModelTransform", L"Scale");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::Numerics::float3>(arg);

            {
                auto _gil = release_gil();
                self->obj.Scale(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SceneModelTransform_get_RotationAxis(py::wrapper::Windows::UI::Composition::Scenes::SceneModelTransform* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Composition.Scenes.SceneModelTransform", L"RotationAxis");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.RotationAxis();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SceneModelTransform_put_RotationAxis(py::wrapper::Windows::UI::Composition::Scenes::SceneModelTransform* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Composition.Scenes.SceneModelTransform", L"RotationAxis");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::Numerics::float3>(arg);

            {
                auto _gil = release_gil();
                self->obj.RotationAxis(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SceneModelTransform_get_RotationAngleInDegrees(py::wrapper::Windows::UI::Composition::Scenes::SceneModelTransform* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Composition.Scenes.SceneModelTransform", L"RotationAngleInDegrees");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.RotationAngleInDegrees();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SceneModelTransform_put_RotationAngleInDegrees(py::wrapper::Windows::UI::Composition::Scenes::SceneModelTransform* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Composition.Scenes.SceneModelTransform", L"RotationAngleInDegrees");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<float>(arg);

            {
                auto _gil = release_gil();
                self->obj.RotationAngleInDegrees(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SceneModelTransform_get_RotationAngle(py::wrapper::Windows::UI::Composition::Scenes::SceneModelTransform* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Composition.Scenes.SceneModelTransform", L"RotationAngle");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.RotationAngle();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SceneModelTransform_put_RotationAngle(py::wrapper::Windows::UI::Composition::Scenes::SceneModelTransform* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Composition.Scenes.SceneModelTransform", L"RotationAngle");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<float>(arg);

            {
                auto _gil = release_gil();
                self->obj.RotationAngle(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SceneModelTransform_get_Orientation(py::wrapper::Windows::UI::Composition::Scenes::SceneModelTransform* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Composition.Scenes.SceneModelTransform", L"Orientation");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Orientation();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SceneModelTransform_put_Orientation(py::wrapper::Windows::UI::Composition::Scenes::SceneModelTransform* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Composition.Scenes.SceneModelTransform", L"Orientation");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::Numerics::quaternion>(arg);

            {
                auto _gil = release_gil();
                self->obj.Orientation(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_SceneModelTransform(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Composition::Scenes::SceneModelTransform>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SceneModelTransform(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Composition::Scenes::SceneModelTransform>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SceneModelTransform[] = {
        { "_assign_array_", _assign_array_SceneModelTransform, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SceneModelTransform), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_SceneModelTransform[] = {
        { "translation", reinterpret_cast<getter>(SceneModelTransform_get_Translation), reinterpret_cast<setter>(SceneModelTransform_put_Translation), nullptr, nullptr },
        { "scale", reinterpret_cast<getter>(SceneModelTransform_get_Scale), reinterpret_cast<setter>(SceneModelTransform_put_Scale), nullptr, nullptr },
        { "rotation_axis", reinterpret_cast<getter>(SceneModelTransform_get_RotationAxis), reinterpret_cast<setter>(SceneModelTransform_put_RotationAxis), nullptr, nullptr },
        { "rotation_angle_in_degrees", reinterpret_cast<getter>(SceneModelTransform_get_RotationAngleInDegrees), reinterpret_cast<setter>(SceneModelTransform_put_RotationAngleInDegrees), nullptr, nullptr },
        { "rotation_angle", reinterpret_cast<getter>(SceneModelTransform_get_RotationAngle), reinterpret_cast<setter>(SceneModelTransform_put_RotationAngle), nullptr, nullptr },
        { "orientation", reinterpret_cast<getter>(SceneModelTransform_get_Orientation), reinterpret_cast<setter>(SceneModelTransform_put_Orientation), nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_SceneModelTransform[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_SceneModelTransform) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SceneModelTransform) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SceneModelTransform) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SceneModelTransform) },
        { }};

    static PyType_Spec type_spec_SceneModelTransform = {
        "winrt._winrt_windows_ui_composition_scenes.SceneModelTransform",
        sizeof(py::wrapper::Windows::UI::Composition::Scenes::SceneModelTransform),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SceneModelTransform};

    // ----- SceneNode class --------------------

    static PyObject* _new_SceneNode(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Composition::Scenes::SceneNode>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Composition::Scenes::SceneNode>::type_name);
        return nullptr;
    }

    static void _dealloc_SceneNode(py::wrapper::Windows::UI::Composition::Scenes::SceneNode* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SceneNode_Create(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Composition.Scenes.SceneNode", L"Create", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Composition::Compositor>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::UI::Composition::Scenes::SceneNode::Create(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SceneNode_FindFirstComponentOfType(py::wrapper::Windows::UI::Composition::Scenes::SceneNode* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Composition.Scenes.SceneNode", L"FindFirstComponentOfType", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Composition::Scenes::SceneComponentType>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.FindFirstComponentOfType(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SceneNode_get_Children(py::wrapper::Windows::UI::Composition::Scenes::SceneNode* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Composition.Scenes.SceneNode", L"Children");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Children();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SceneNode_get_Components(py::wrapper::Windows::UI::Composition::Scenes::SceneNode* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Composition.Scenes.SceneNode", L"Components");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Components();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SceneNode_get_Parent(py::wrapper::Windows::UI::Composition::Scenes::SceneNode* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Composition.Scenes.SceneNode", L"Parent");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Parent();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SceneNode_get_Transform(py::wrapper::Windows::UI::Composition::Scenes::SceneNode* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Composition.Scenes.SceneNode", L"Transform");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Transform();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SceneNode(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Composition::Scenes::SceneNode>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SceneNode(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Composition::Scenes::SceneNode>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SceneNode[] = {
        { "find_first_component_of_type", reinterpret_cast<PyCFunction>(SceneNode_FindFirstComponentOfType), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_SceneNode, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SceneNode), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_SceneNode[] = {
        { "children", reinterpret_cast<getter>(SceneNode_get_Children), nullptr, nullptr, nullptr },
        { "components", reinterpret_cast<getter>(SceneNode_get_Components), nullptr, nullptr, nullptr },
        { "parent", reinterpret_cast<getter>(SceneNode_get_Parent), nullptr, nullptr, nullptr },
        { "transform", reinterpret_cast<getter>(SceneNode_get_Transform), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_SceneNode[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_SceneNode) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SceneNode) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SceneNode) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SceneNode) },
        { }};

    static PyType_Spec type_spec_SceneNode = {
        "winrt._winrt_windows_ui_composition_scenes.SceneNode",
        sizeof(py::wrapper::Windows::UI::Composition::Scenes::SceneNode),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SceneNode};

    static PyGetSetDef getset_SceneNode_Static[] = {
        { }};

    static PyMethodDef methods_SceneNode_Static[] = {
        { "create", reinterpret_cast<PyCFunction>(SceneNode_Create), METH_VARARGS, nullptr },
        { }};

    static PyType_Slot type_slots_SceneNode_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_SceneNode_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_SceneNode_Static) },
        { }
    };

    static PyType_Spec type_spec_SceneNode_Static = {
        "winrt._winrt_windows_ui_composition_scenes.SceneNode_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_SceneNode_Static};

    // ----- SceneNodeCollection class --------------------

    static PyObject* _new_SceneNodeCollection(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Composition::Scenes::SceneNodeCollection>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Composition::Scenes::SceneNodeCollection>::type_name);
        return nullptr;
    }

    static void _dealloc_SceneNodeCollection(py::wrapper::Windows::UI::Composition::Scenes::SceneNodeCollection* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SceneNodeCollection_Append(py::wrapper::Windows::UI::Composition::Scenes::SceneNodeCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Composition.Scenes.SceneNodeCollection", L"Append", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Composition::Scenes::SceneNode>(args, 0);

                {
                    auto _gil = release_gil();
                    self->obj.Append(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SceneNodeCollection_Clear(py::wrapper::Windows::UI::Composition::Scenes::SceneNodeCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Composition.Scenes.SceneNodeCollection", L"Clear", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.Clear();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SceneNodeCollection_First(py::wrapper::Windows::UI::Composition::Scenes::SceneNodeCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Composition.Scenes.SceneNodeCollection", L"First", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.First();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SceneNodeCollection_GetAt(py::wrapper::Windows::UI::Composition::Scenes::SceneNodeCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Composition.Scenes.SceneNodeCollection", L"GetAt", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint32_t>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetAt(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SceneNodeCollection_GetMany(py::wrapper::Windows::UI::Composition::Scenes::SceneNodeCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Composition.Scenes.SceneNodeCollection", L"GetMany", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<winrt::Windows::UI::Composition::Scenes::SceneNode, true>>(args, 1);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetMany(param0, param1);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SceneNodeCollection_GetView(py::wrapper::Windows::UI::Composition::Scenes::SceneNodeCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Composition.Scenes.SceneNodeCollection", L"GetView", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetView();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SceneNodeCollection_IndexOf(py::wrapper::Windows::UI::Composition::Scenes::SceneNodeCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Composition.Scenes.SceneNodeCollection", L"IndexOf", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Composition::Scenes::SceneNode>(args, 0);
                uint32_t param1{};

                auto return_value = [&]()
                {
                    auto _gil = release_gil();
                    return self->obj.IndexOf(param0, param1);
                }();

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }

                return PyTuple_Pack(2, out_return_value.get(), out1.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SceneNodeCollection_InsertAt(py::wrapper::Windows::UI::Composition::Scenes::SceneNodeCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Composition.Scenes.SceneNodeCollection", L"InsertAt", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Composition::Scenes::SceneNode>(args, 1);

                {
                    auto _gil = release_gil();
                    self->obj.InsertAt(param0, param1);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SceneNodeCollection_RemoveAt(py::wrapper::Windows::UI::Composition::Scenes::SceneNodeCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Composition.Scenes.SceneNodeCollection", L"RemoveAt", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint32_t>(args, 0);

                {
                    auto _gil = release_gil();
                    self->obj.RemoveAt(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SceneNodeCollection_RemoveAtEnd(py::wrapper::Windows::UI::Composition::Scenes::SceneNodeCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Composition.Scenes.SceneNodeCollection", L"RemoveAtEnd", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.RemoveAtEnd();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SceneNodeCollection_ReplaceAll(py::wrapper::Windows::UI::Composition::Scenes::SceneNodeCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Composition.Scenes.SceneNodeCollection", L"ReplaceAll", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<py::pybuf_view<winrt::Windows::UI::Composition::Scenes::SceneNode, false>>(args, 0);

                {
                    auto _gil = release_gil();
                    self->obj.ReplaceAll(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SceneNodeCollection_SetAt(py::wrapper::Windows::UI::Composition::Scenes::SceneNodeCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Composition.Scenes.SceneNodeCollection", L"SetAt", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Composition::Scenes::SceneNode>(args, 1);

                {
                    auto _gil = release_gil();
                    self->obj.SetAt(param0, param1);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SceneNodeCollection_get_Size(py::wrapper::Windows::UI::Composition::Scenes::SceneNodeCollection* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Composition.Scenes.SceneNodeCollection", L"Size");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Size();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SceneNodeCollection(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Composition::Scenes::SceneNodeCollection>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SceneNodeCollection(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Composition::Scenes::SceneNodeCollection>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _iterator_SceneNodeCollection(py::wrapper::Windows::UI::Composition::Scenes::SceneNodeCollection* self) noexcept
    {
        try
        {
            return py::convert([&]()
            {
                auto _gil = py::release_gil();
                return self->obj.First();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static Py_ssize_t _seq_length_SceneNodeCollection(py::wrapper::Windows::UI::Composition::Scenes::SceneNodeCollection* self) noexcept
    {
        try
        {
            auto _gil = py::release_gil();
            return static_cast<Py_ssize_t>(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _seq_item_SceneNodeCollection(py::wrapper::Windows::UI::Composition::Scenes::SceneNodeCollection* self, Py_ssize_t i) noexcept
    {
        try
        {
            return py::convert([&]()
            {
                auto _gil = py::release_gil();
                return self->obj.GetAt(static_cast<uint32_t>(i));
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _seq_subscript_SceneNodeCollection(py::wrapper::Windows::UI::Composition::Scenes::SceneNodeCollection* self, PyObject* slice) noexcept
    {
        try
        {
            if (PyIndex_Check(slice))
            {
                pyobj_handle index{PyNumber_Index(slice)};

                if (!index)
                {
                    return nullptr;
                }

                auto i = PyNumber_AsSsize_t(index.get(), PyExc_IndexError);

                if (i == -1 && PyErr_Occurred())
                {
                    return nullptr;
                }

                return _seq_item_SceneNodeCollection(self, i);
            }

            if (!PySlice_Check(slice))
            {
                PyErr_Format(PyExc_TypeError, "indices must be integers, not '%s'", Py_TYPE(slice)->tp_name);
            }

            Py_ssize_t start, stop, step, length;

            auto size = [&]()
            {
                auto _gil = py::release_gil();
                return self->obj.Size();
            }();
            if (PySlice_GetIndicesEx(slice, size, &start, &stop, &step, &length) < 0)
            {
                return nullptr;
            }

            if (step != 1)
            {
                PyErr_SetString(PyExc_NotImplementedError, "slices with step other than 1 are not implemented");
                return nullptr;
            }

            winrt::com_array<winrt::Windows::UI::Composition::Scenes::SceneNode> items(static_cast<uint32_t>(length), empty_instance<winrt::Windows::UI::Composition::Scenes::SceneNode>::get());

            auto count = [&]()
            {
                auto _gil = py::release_gil();
                return self->obj.GetMany(static_cast<uint32_t>(start), items);
            }();

            if (count != static_cast<uint32_t>(length))
            {
                PyErr_Format(PyExc_RuntimeError, "returned count %d did not match requested length %zd", count, length);
                return nullptr;
            }

            return convert(items);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int _seq_assign_SceneNodeCollection(py::wrapper::Windows::UI::Composition::Scenes::SceneNodeCollection* self, Py_ssize_t i, PyObject* value) noexcept
    {
        try
        {
            if (!value)
            {
                auto _gil = py::release_gil();
                self->obj.RemoveAt(static_cast<uint32_t>(i));
            }
            else
            {
                auto _value = py::convert_to<winrt::Windows::UI::Composition::Scenes::SceneNode>(value);
                {
                    auto _gil = py::release_gil();
                    self->obj.SetAt(static_cast<uint32_t>(i), _value);
                }
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyMethodDef _methods_SceneNodeCollection[] = {
        { "append", reinterpret_cast<PyCFunction>(SceneNodeCollection_Append), METH_VARARGS, nullptr },
        { "clear", reinterpret_cast<PyCFunction>(SceneNodeCollection_Clear), METH_VARARGS, nullptr },
        { "first", reinterpret_cast<PyCFunction>(SceneNodeCollection_First), METH_VARARGS, nullptr },
        { "get_at", reinterpret_cast<PyCFunction>(SceneNodeCollection_GetAt), METH_VARARGS, nullptr },
        { "get_many", reinterpret_cast<PyCFunction>(SceneNodeCollection_GetMany), METH_VARARGS, nullptr },
        { "get_view", reinterpret_cast<PyCFunction>(SceneNodeCollection_GetView), METH_VARARGS, nullptr },
        { "index_of", reinterpret_cast<PyCFunction>(SceneNodeCollection_IndexOf), METH_VARARGS, nullptr },
        { "insert_at", reinterpret_cast<PyCFunction>(SceneNodeCollection_InsertAt), METH_VARARGS, nullptr },
        { "remove_at", reinterpret_cast<PyCFunction>(SceneNodeCollection_RemoveAt), METH_VARARGS, nullptr },
        { "remove_at_end", reinterpret_cast<PyCFunction>(SceneNodeCollection_RemoveAtEnd), METH_VARARGS, nullptr },
        { "replace_all", reinterpret_cast<PyCFunction>(SceneNodeCollection_ReplaceAll), METH_VARARGS, nullptr },
        { "set_at", reinterpret_cast<PyCFunction>(SceneNodeCollection_SetAt), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_SceneNodeCollection, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SceneNodeCollection), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_SceneNodeCollection[] = {
        { "size", reinterpret_cast<getter>(SceneNodeCollection_get_Size), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_SceneNodeCollection[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_SceneNodeCollection) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SceneNodeCollection) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SceneNodeCollection) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SceneNodeCollection) },
        { Py_tp_iter, reinterpret_cast<void*>(_iterator_SceneNodeCollection) },
        { Py_sq_length, reinterpret_cast<void*>(_seq_length_SceneNodeCollection) },
        { Py_sq_item, reinterpret_cast<void*>(_seq_item_SceneNodeCollection) },
        { Py_mp_subscript, reinterpret_cast<void*>(_seq_subscript_SceneNodeCollection) },
        { Py_sq_ass_item, reinterpret_cast<void*>(_seq_assign_SceneNodeCollection) },
        { }};

    static PyType_Spec type_spec_SceneNodeCollection = {
        "winrt._winrt_windows_ui_composition_scenes.SceneNodeCollection",
        sizeof(py::wrapper::Windows::UI::Composition::Scenes::SceneNodeCollection),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SceneNodeCollection};

    // ----- SceneObject class --------------------

    static PyObject* _new_SceneObject(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Composition::Scenes::SceneObject>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Composition::Scenes::SceneObject>::type_name);
        return nullptr;
    }

    static void _dealloc_SceneObject(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_SceneObject(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Composition::Scenes::SceneObject>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SceneObject(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Composition::Scenes::SceneObject>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SceneObject[] = {
        { "_assign_array_", _assign_array_SceneObject, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SceneObject), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_SceneObject[] = {
        { }};

    static PyType_Slot _type_slots_SceneObject[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_SceneObject) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SceneObject) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SceneObject) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SceneObject) },
        { }};

    static PyType_Spec type_spec_SceneObject = {
        "winrt._winrt_windows_ui_composition_scenes.SceneObject",
        sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_SceneObject};

    static PyGetSetDef getset_SceneObject_Static[] = {
        { }};

    static PyMethodDef methods_SceneObject_Static[] = {
        { }};

    static PyType_Slot type_slots_SceneObject_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_SceneObject_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_SceneObject_Static) },
        { }
    };

    static PyType_Spec type_spec_SceneObject_Static = {
        "winrt._winrt_windows_ui_composition_scenes.SceneObject_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_SceneObject_Static};

    // ----- ScenePbrMaterial class --------------------

    static PyObject* _new_ScenePbrMaterial(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Composition::Scenes::ScenePbrMaterial>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Composition::Scenes::ScenePbrMaterial>::type_name);
        return nullptr;
    }

    static void _dealloc_ScenePbrMaterial(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ScenePbrMaterial_get_OcclusionStrength(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Composition.Scenes.ScenePbrMaterial", L"OcclusionStrength");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Windows::UI::Composition::Scenes::ScenePbrMaterial>().OcclusionStrength();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ScenePbrMaterial_put_OcclusionStrength(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Composition.Scenes.ScenePbrMaterial", L"OcclusionStrength");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<float>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Windows::UI::Composition::Scenes::ScenePbrMaterial>().OcclusionStrength(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ScenePbrMaterial_get_OcclusionInput(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Composition.Scenes.ScenePbrMaterial", L"OcclusionInput");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Windows::UI::Composition::Scenes::ScenePbrMaterial>().OcclusionInput();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ScenePbrMaterial_put_OcclusionInput(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Composition.Scenes.ScenePbrMaterial", L"OcclusionInput");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Composition::Scenes::SceneMaterialInput>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Windows::UI::Composition::Scenes::ScenePbrMaterial>().OcclusionInput(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ScenePbrMaterial_get_NormalScale(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Composition.Scenes.ScenePbrMaterial", L"NormalScale");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Windows::UI::Composition::Scenes::ScenePbrMaterial>().NormalScale();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ScenePbrMaterial_put_NormalScale(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Composition.Scenes.ScenePbrMaterial", L"NormalScale");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<float>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Windows::UI::Composition::Scenes::ScenePbrMaterial>().NormalScale(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ScenePbrMaterial_get_NormalInput(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Composition.Scenes.ScenePbrMaterial", L"NormalInput");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Windows::UI::Composition::Scenes::ScenePbrMaterial>().NormalInput();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ScenePbrMaterial_put_NormalInput(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Composition.Scenes.ScenePbrMaterial", L"NormalInput");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Composition::Scenes::SceneMaterialInput>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Windows::UI::Composition::Scenes::ScenePbrMaterial>().NormalInput(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ScenePbrMaterial_get_IsDoubleSided(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Composition.Scenes.ScenePbrMaterial", L"IsDoubleSided");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Windows::UI::Composition::Scenes::ScenePbrMaterial>().IsDoubleSided();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ScenePbrMaterial_put_IsDoubleSided(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Composition.Scenes.ScenePbrMaterial", L"IsDoubleSided");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Windows::UI::Composition::Scenes::ScenePbrMaterial>().IsDoubleSided(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ScenePbrMaterial_get_EmissiveInput(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Composition.Scenes.ScenePbrMaterial", L"EmissiveInput");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Windows::UI::Composition::Scenes::ScenePbrMaterial>().EmissiveInput();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ScenePbrMaterial_put_EmissiveInput(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Composition.Scenes.ScenePbrMaterial", L"EmissiveInput");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Composition::Scenes::SceneMaterialInput>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Windows::UI::Composition::Scenes::ScenePbrMaterial>().EmissiveInput(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ScenePbrMaterial_get_EmissiveFactor(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Composition.Scenes.ScenePbrMaterial", L"EmissiveFactor");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Windows::UI::Composition::Scenes::ScenePbrMaterial>().EmissiveFactor();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ScenePbrMaterial_put_EmissiveFactor(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Composition.Scenes.ScenePbrMaterial", L"EmissiveFactor");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::Numerics::float3>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Windows::UI::Composition::Scenes::ScenePbrMaterial>().EmissiveFactor(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ScenePbrMaterial_get_AlphaMode(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Composition.Scenes.ScenePbrMaterial", L"AlphaMode");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Windows::UI::Composition::Scenes::ScenePbrMaterial>().AlphaMode();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ScenePbrMaterial_put_AlphaMode(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Composition.Scenes.ScenePbrMaterial", L"AlphaMode");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Composition::Scenes::SceneAlphaMode>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Windows::UI::Composition::Scenes::ScenePbrMaterial>().AlphaMode(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ScenePbrMaterial_get_AlphaCutoff(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Composition.Scenes.ScenePbrMaterial", L"AlphaCutoff");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Windows::UI::Composition::Scenes::ScenePbrMaterial>().AlphaCutoff();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ScenePbrMaterial_put_AlphaCutoff(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Composition.Scenes.ScenePbrMaterial", L"AlphaCutoff");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<float>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Windows::UI::Composition::Scenes::ScenePbrMaterial>().AlphaCutoff(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_ScenePbrMaterial(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Composition::Scenes::ScenePbrMaterial>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ScenePbrMaterial(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Composition::Scenes::ScenePbrMaterial>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ScenePbrMaterial[] = {
        { "_assign_array_", _assign_array_ScenePbrMaterial, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ScenePbrMaterial), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_ScenePbrMaterial[] = {
        { "occlusion_strength", reinterpret_cast<getter>(ScenePbrMaterial_get_OcclusionStrength), reinterpret_cast<setter>(ScenePbrMaterial_put_OcclusionStrength), nullptr, nullptr },
        { "occlusion_input", reinterpret_cast<getter>(ScenePbrMaterial_get_OcclusionInput), reinterpret_cast<setter>(ScenePbrMaterial_put_OcclusionInput), nullptr, nullptr },
        { "normal_scale", reinterpret_cast<getter>(ScenePbrMaterial_get_NormalScale), reinterpret_cast<setter>(ScenePbrMaterial_put_NormalScale), nullptr, nullptr },
        { "normal_input", reinterpret_cast<getter>(ScenePbrMaterial_get_NormalInput), reinterpret_cast<setter>(ScenePbrMaterial_put_NormalInput), nullptr, nullptr },
        { "is_double_sided", reinterpret_cast<getter>(ScenePbrMaterial_get_IsDoubleSided), reinterpret_cast<setter>(ScenePbrMaterial_put_IsDoubleSided), nullptr, nullptr },
        { "emissive_input", reinterpret_cast<getter>(ScenePbrMaterial_get_EmissiveInput), reinterpret_cast<setter>(ScenePbrMaterial_put_EmissiveInput), nullptr, nullptr },
        { "emissive_factor", reinterpret_cast<getter>(ScenePbrMaterial_get_EmissiveFactor), reinterpret_cast<setter>(ScenePbrMaterial_put_EmissiveFactor), nullptr, nullptr },
        { "alpha_mode", reinterpret_cast<getter>(ScenePbrMaterial_get_AlphaMode), reinterpret_cast<setter>(ScenePbrMaterial_put_AlphaMode), nullptr, nullptr },
        { "alpha_cutoff", reinterpret_cast<getter>(ScenePbrMaterial_get_AlphaCutoff), reinterpret_cast<setter>(ScenePbrMaterial_put_AlphaCutoff), nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_ScenePbrMaterial[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ScenePbrMaterial) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ScenePbrMaterial) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ScenePbrMaterial) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ScenePbrMaterial) },
        { }};

    static PyType_Spec type_spec_ScenePbrMaterial = {
        "winrt._winrt_windows_ui_composition_scenes.ScenePbrMaterial",
        sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_ScenePbrMaterial};

    static PyGetSetDef getset_ScenePbrMaterial_Static[] = {
        { }};

    static PyMethodDef methods_ScenePbrMaterial_Static[] = {
        { }};

    static PyType_Slot type_slots_ScenePbrMaterial_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_ScenePbrMaterial_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_ScenePbrMaterial_Static) },
        { }
    };

    static PyType_Spec type_spec_ScenePbrMaterial_Static = {
        "winrt._winrt_windows_ui_composition_scenes.ScenePbrMaterial_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_ScenePbrMaterial_Static};

    // ----- SceneRendererComponent class --------------------

    static PyObject* _new_SceneRendererComponent(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Composition::Scenes::SceneRendererComponent>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Composition::Scenes::SceneRendererComponent>::type_name);
        return nullptr;
    }

    static void _dealloc_SceneRendererComponent(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_SceneRendererComponent(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Composition::Scenes::SceneRendererComponent>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SceneRendererComponent(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Composition::Scenes::SceneRendererComponent>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SceneRendererComponent[] = {
        { "_assign_array_", _assign_array_SceneRendererComponent, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SceneRendererComponent), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_SceneRendererComponent[] = {
        { }};

    static PyType_Slot _type_slots_SceneRendererComponent[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_SceneRendererComponent) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SceneRendererComponent) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SceneRendererComponent) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SceneRendererComponent) },
        { }};

    static PyType_Spec type_spec_SceneRendererComponent = {
        "winrt._winrt_windows_ui_composition_scenes.SceneRendererComponent",
        sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_SceneRendererComponent};

    static PyGetSetDef getset_SceneRendererComponent_Static[] = {
        { }};

    static PyMethodDef methods_SceneRendererComponent_Static[] = {
        { }};

    static PyType_Slot type_slots_SceneRendererComponent_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_SceneRendererComponent_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_SceneRendererComponent_Static) },
        { }
    };

    static PyType_Spec type_spec_SceneRendererComponent_Static = {
        "winrt._winrt_windows_ui_composition_scenes.SceneRendererComponent_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_SceneRendererComponent_Static};

    // ----- SceneSurfaceMaterialInput class --------------------

    static PyObject* _new_SceneSurfaceMaterialInput(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Composition::Scenes::SceneSurfaceMaterialInput>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Composition::Scenes::SceneSurfaceMaterialInput>::type_name);
        return nullptr;
    }

    static void _dealloc_SceneSurfaceMaterialInput(py::wrapper::Windows::UI::Composition::Scenes::SceneSurfaceMaterialInput* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SceneSurfaceMaterialInput_Create(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Composition.Scenes.SceneSurfaceMaterialInput", L"Create", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Composition::Compositor>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::UI::Composition::Scenes::SceneSurfaceMaterialInput::Create(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SceneSurfaceMaterialInput_get_WrappingVMode(py::wrapper::Windows::UI::Composition::Scenes::SceneSurfaceMaterialInput* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Composition.Scenes.SceneSurfaceMaterialInput", L"WrappingVMode");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.WrappingVMode();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SceneSurfaceMaterialInput_put_WrappingVMode(py::wrapper::Windows::UI::Composition::Scenes::SceneSurfaceMaterialInput* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Composition.Scenes.SceneSurfaceMaterialInput", L"WrappingVMode");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Composition::Scenes::SceneWrappingMode>(arg);

            {
                auto _gil = release_gil();
                self->obj.WrappingVMode(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SceneSurfaceMaterialInput_get_WrappingUMode(py::wrapper::Windows::UI::Composition::Scenes::SceneSurfaceMaterialInput* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Composition.Scenes.SceneSurfaceMaterialInput", L"WrappingUMode");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.WrappingUMode();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SceneSurfaceMaterialInput_put_WrappingUMode(py::wrapper::Windows::UI::Composition::Scenes::SceneSurfaceMaterialInput* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Composition.Scenes.SceneSurfaceMaterialInput", L"WrappingUMode");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Composition::Scenes::SceneWrappingMode>(arg);

            {
                auto _gil = release_gil();
                self->obj.WrappingUMode(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SceneSurfaceMaterialInput_get_Surface(py::wrapper::Windows::UI::Composition::Scenes::SceneSurfaceMaterialInput* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Composition.Scenes.SceneSurfaceMaterialInput", L"Surface");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Surface();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SceneSurfaceMaterialInput_put_Surface(py::wrapper::Windows::UI::Composition::Scenes::SceneSurfaceMaterialInput* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Composition.Scenes.SceneSurfaceMaterialInput", L"Surface");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Composition::ICompositionSurface>(arg);

            {
                auto _gil = release_gil();
                self->obj.Surface(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SceneSurfaceMaterialInput_get_BitmapInterpolationMode(py::wrapper::Windows::UI::Composition::Scenes::SceneSurfaceMaterialInput* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Composition.Scenes.SceneSurfaceMaterialInput", L"BitmapInterpolationMode");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.BitmapInterpolationMode();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SceneSurfaceMaterialInput_put_BitmapInterpolationMode(py::wrapper::Windows::UI::Composition::Scenes::SceneSurfaceMaterialInput* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Composition.Scenes.SceneSurfaceMaterialInput", L"BitmapInterpolationMode");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Composition::CompositionBitmapInterpolationMode>(arg);

            {
                auto _gil = release_gil();
                self->obj.BitmapInterpolationMode(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_SceneSurfaceMaterialInput(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Composition::Scenes::SceneSurfaceMaterialInput>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SceneSurfaceMaterialInput(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Composition::Scenes::SceneSurfaceMaterialInput>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SceneSurfaceMaterialInput[] = {
        { "_assign_array_", _assign_array_SceneSurfaceMaterialInput, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SceneSurfaceMaterialInput), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_SceneSurfaceMaterialInput[] = {
        { "wrapping_v_mode", reinterpret_cast<getter>(SceneSurfaceMaterialInput_get_WrappingVMode), reinterpret_cast<setter>(SceneSurfaceMaterialInput_put_WrappingVMode), nullptr, nullptr },
        { "wrapping_u_mode", reinterpret_cast<getter>(SceneSurfaceMaterialInput_get_WrappingUMode), reinterpret_cast<setter>(SceneSurfaceMaterialInput_put_WrappingUMode), nullptr, nullptr },
        { "surface", reinterpret_cast<getter>(SceneSurfaceMaterialInput_get_Surface), reinterpret_cast<setter>(SceneSurfaceMaterialInput_put_Surface), nullptr, nullptr },
        { "bitmap_interpolation_mode", reinterpret_cast<getter>(SceneSurfaceMaterialInput_get_BitmapInterpolationMode), reinterpret_cast<setter>(SceneSurfaceMaterialInput_put_BitmapInterpolationMode), nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_SceneSurfaceMaterialInput[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_SceneSurfaceMaterialInput) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SceneSurfaceMaterialInput) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SceneSurfaceMaterialInput) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SceneSurfaceMaterialInput) },
        { }};

    static PyType_Spec type_spec_SceneSurfaceMaterialInput = {
        "winrt._winrt_windows_ui_composition_scenes.SceneSurfaceMaterialInput",
        sizeof(py::wrapper::Windows::UI::Composition::Scenes::SceneSurfaceMaterialInput),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SceneSurfaceMaterialInput};

    static PyGetSetDef getset_SceneSurfaceMaterialInput_Static[] = {
        { }};

    static PyMethodDef methods_SceneSurfaceMaterialInput_Static[] = {
        { "create", reinterpret_cast<PyCFunction>(SceneSurfaceMaterialInput_Create), METH_VARARGS, nullptr },
        { }};

    static PyType_Slot type_slots_SceneSurfaceMaterialInput_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_SceneSurfaceMaterialInput_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_SceneSurfaceMaterialInput_Static) },
        { }
    };

    static PyType_Spec type_spec_SceneSurfaceMaterialInput_Static = {
        "winrt._winrt_windows_ui_composition_scenes.SceneSurfaceMaterialInput_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_SceneSurfaceMaterialInput_Static};

    // ----- SceneVisual class --------------------

    static PyObject* _new_SceneVisual(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Composition::Scenes::SceneVisual>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Composition::Scenes::SceneVisual>::type_name);
        return nullptr;
    }

    static void _dealloc_SceneVisual(py::wrapper::Windows::UI::Composition::Scenes::SceneVisual* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SceneVisual_Create(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Composition.Scenes.SceneVisual", L"Create", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Composition::Compositor>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::UI::Composition::Scenes::SceneVisual::Create(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SceneVisual_get_Root(py::wrapper::Windows::UI::Composition::Scenes::SceneVisual* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Composition.Scenes.SceneVisual", L"Root");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Root();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SceneVisual_put_Root(py::wrapper::Windows::UI::Composition::Scenes::SceneVisual* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Composition.Scenes.SceneVisual", L"Root");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Composition::Scenes::SceneNode>(arg);

            {
                auto _gil = release_gil();
                self->obj.Root(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_SceneVisual(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Composition::Scenes::SceneVisual>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SceneVisual(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Composition::Scenes::SceneVisual>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SceneVisual[] = {
        { "_assign_array_", _assign_array_SceneVisual, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SceneVisual), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_SceneVisual[] = {
        { "root", reinterpret_cast<getter>(SceneVisual_get_Root), reinterpret_cast<setter>(SceneVisual_put_Root), nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_SceneVisual[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_SceneVisual) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SceneVisual) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SceneVisual) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SceneVisual) },
        { }};

    static PyType_Spec type_spec_SceneVisual = {
        "winrt._winrt_windows_ui_composition_scenes.SceneVisual",
        sizeof(py::wrapper::Windows::UI::Composition::Scenes::SceneVisual),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SceneVisual};

    static PyGetSetDef getset_SceneVisual_Static[] = {
        { }};

    static PyMethodDef methods_SceneVisual_Static[] = {
        { "create", reinterpret_cast<PyCFunction>(SceneVisual_Create), METH_VARARGS, nullptr },
        { }};

    static PyType_Slot type_slots_SceneVisual_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_SceneVisual_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_SceneVisual_Static) },
        { }
    };

    static PyType_Spec type_spec_SceneVisual_Static = {
        "winrt._winrt_windows_ui_composition_scenes.SceneVisual_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_SceneVisual_Static};

    // ----- Windows.UI.Composition.Scenes Initialization --------------------

    PyDoc_STRVAR(module_doc, "Windows.UI.Composition.Scenes");

    static PyModuleDef module_def = {
        PyModuleDef_HEAD_INIT,
        "_winrt_windows_ui_composition_scenes",
        module_doc,
        0,
        nullptr,
        nullptr,
        nullptr,
        nullptr,
        nullptr};
} // py::cpp::Windows::UI::Composition::Scenes

PyMODINIT_FUNC PyInit__winrt_windows_ui_composition_scenes(void) noexcept
{
    using namespace py::cpp::Windows::UI::Composition::Scenes;

    if (py::import_winrt_runtime() == -1)
    {
        return nullptr;
    }

    py::pyobj_handle module{PyModule_Create(&module_def)};

    if (!module)
    {
        return nullptr;
    }

    auto inspectable_meta_type = py::get_inspectable_meta_type();
    if (!inspectable_meta_type)
    {
        return nullptr;
    }

    auto object_type = py::get_object_type();
    if (!object_type)
    {
        return nullptr;
    }

    py::pyobj_handle object_bases{PyTuple_Pack(1, object_type)};

    if (!object_bases)
    {
        return nullptr;
    }

    py::pyobj_handle windows_ui_composition_module{PyImport_ImportModule("winrt._winrt_windows_ui_composition")};
    if (!windows_ui_composition_module)
    {
        return nullptr;
    }

    py::pyobj_handle windows_ui_composition_CompositionTransform_type{PyObject_GetAttrString(windows_ui_composition_module.get(), "CompositionTransform")};
    if (!windows_ui_composition_CompositionTransform_type)
    {
        return nullptr;
    }

    py::pyobj_handle windows_ui_composition_CompositionObject_type{PyObject_GetAttrString(windows_ui_composition_module.get(), "CompositionObject")};
    if (!windows_ui_composition_CompositionObject_type)
    {
        return nullptr;
    }

    py::pyobj_handle windows_ui_composition_ContainerVisual_type{PyObject_GetAttrString(windows_ui_composition_module.get(), "ContainerVisual")};
    if (!windows_ui_composition_ContainerVisual_type)
    {
        return nullptr;
    }

    py::pyobj_handle SceneObject_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(windows_ui_composition_CompositionObject_type.get())))};
    if (!SceneObject_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_SceneObject_Static{PyType_FromSpecWithBases(&type_spec_SceneObject_Static, SceneObject_Static_bases.get())};
    if (!type_SceneObject_Static)
    {
        return nullptr;
    }

    py::pyobj_handle SceneObject_bases{PyTuple_Pack(1, windows_ui_composition_CompositionObject_type.get())};
    if (!SceneObject_bases)
    {
        return nullptr;
    }

    py::pytype_handle SceneObject_type{py::register_python_type(module.get(), &type_spec_SceneObject, SceneObject_bases.get(), reinterpret_cast<PyTypeObject*>(type_SceneObject_Static.get()))};
    if (!SceneObject_type)
    {
        return nullptr;
    }

    py::pyobj_handle SceneBoundingBox_bases{PyTuple_Pack(1, SceneObject_type.get())};
    if (!SceneBoundingBox_bases)
    {
        return nullptr;
    }

    py::pytype_handle SceneBoundingBox_type{py::register_python_type(module.get(), &type_spec_SceneBoundingBox, SceneBoundingBox_bases.get(), inspectable_meta_type)};
    if (!SceneBoundingBox_type)
    {
        return nullptr;
    }

    py::pyobj_handle SceneComponent_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(SceneObject_type.get())))};
    if (!SceneComponent_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_SceneComponent_Static{PyType_FromSpecWithBases(&type_spec_SceneComponent_Static, SceneComponent_Static_bases.get())};
    if (!type_SceneComponent_Static)
    {
        return nullptr;
    }

    py::pyobj_handle SceneComponent_bases{PyTuple_Pack(1, SceneObject_type.get())};
    if (!SceneComponent_bases)
    {
        return nullptr;
    }

    py::pytype_handle SceneComponent_type{py::register_python_type(module.get(), &type_spec_SceneComponent, SceneComponent_bases.get(), reinterpret_cast<PyTypeObject*>(type_SceneComponent_Static.get()))};
    if (!SceneComponent_type)
    {
        return nullptr;
    }

    py::pyobj_handle SceneComponentCollection_bases{PyTuple_Pack(1, SceneObject_type.get())};
    if (!SceneComponentCollection_bases)
    {
        return nullptr;
    }

    py::pytype_handle SceneComponentCollection_type{py::register_python_type(module.get(), &type_spec_SceneComponentCollection, SceneComponentCollection_bases.get(), inspectable_meta_type)};
    if (!SceneComponentCollection_type)
    {
        return nullptr;
    }

    py::pyobj_handle SceneMaterial_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(SceneObject_type.get())))};
    if (!SceneMaterial_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_SceneMaterial_Static{PyType_FromSpecWithBases(&type_spec_SceneMaterial_Static, SceneMaterial_Static_bases.get())};
    if (!type_SceneMaterial_Static)
    {
        return nullptr;
    }

    py::pyobj_handle SceneMaterial_bases{PyTuple_Pack(1, SceneObject_type.get())};
    if (!SceneMaterial_bases)
    {
        return nullptr;
    }

    py::pytype_handle SceneMaterial_type{py::register_python_type(module.get(), &type_spec_SceneMaterial, SceneMaterial_bases.get(), reinterpret_cast<PyTypeObject*>(type_SceneMaterial_Static.get()))};
    if (!SceneMaterial_type)
    {
        return nullptr;
    }

    py::pyobj_handle SceneMaterialInput_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(SceneObject_type.get())))};
    if (!SceneMaterialInput_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_SceneMaterialInput_Static{PyType_FromSpecWithBases(&type_spec_SceneMaterialInput_Static, SceneMaterialInput_Static_bases.get())};
    if (!type_SceneMaterialInput_Static)
    {
        return nullptr;
    }

    py::pyobj_handle SceneMaterialInput_bases{PyTuple_Pack(1, SceneObject_type.get())};
    if (!SceneMaterialInput_bases)
    {
        return nullptr;
    }

    py::pytype_handle SceneMaterialInput_type{py::register_python_type(module.get(), &type_spec_SceneMaterialInput, SceneMaterialInput_bases.get(), reinterpret_cast<PyTypeObject*>(type_SceneMaterialInput_Static.get()))};
    if (!SceneMaterialInput_type)
    {
        return nullptr;
    }

    py::pyobj_handle SceneMesh_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(SceneObject_type.get())))};
    if (!SceneMesh_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_SceneMesh_Static{PyType_FromSpecWithBases(&type_spec_SceneMesh_Static, SceneMesh_Static_bases.get())};
    if (!type_SceneMesh_Static)
    {
        return nullptr;
    }

    py::pyobj_handle SceneMesh_bases{PyTuple_Pack(1, SceneObject_type.get())};
    if (!SceneMesh_bases)
    {
        return nullptr;
    }

    py::pytype_handle SceneMesh_type{py::register_python_type(module.get(), &type_spec_SceneMesh, SceneMesh_bases.get(), reinterpret_cast<PyTypeObject*>(type_SceneMesh_Static.get()))};
    if (!SceneMesh_type)
    {
        return nullptr;
    }

    py::pyobj_handle SceneMeshMaterialAttributeMap_bases{PyTuple_Pack(1, SceneObject_type.get())};
    if (!SceneMeshMaterialAttributeMap_bases)
    {
        return nullptr;
    }

    py::pytype_handle SceneMeshMaterialAttributeMap_type{py::register_python_type(module.get(), &type_spec_SceneMeshMaterialAttributeMap, SceneMeshMaterialAttributeMap_bases.get(), inspectable_meta_type)};
    if (!SceneMeshMaterialAttributeMap_type)
    {
        return nullptr;
    }

    py::pyobj_handle SceneRendererComponent_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(SceneComponent_type.get())))};
    if (!SceneRendererComponent_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_SceneRendererComponent_Static{PyType_FromSpecWithBases(&type_spec_SceneRendererComponent_Static, SceneRendererComponent_Static_bases.get())};
    if (!type_SceneRendererComponent_Static)
    {
        return nullptr;
    }

    py::pyobj_handle SceneRendererComponent_bases{PyTuple_Pack(1, SceneComponent_type.get())};
    if (!SceneRendererComponent_bases)
    {
        return nullptr;
    }

    py::pytype_handle SceneRendererComponent_type{py::register_python_type(module.get(), &type_spec_SceneRendererComponent, SceneRendererComponent_bases.get(), reinterpret_cast<PyTypeObject*>(type_SceneRendererComponent_Static.get()))};
    if (!SceneRendererComponent_type)
    {
        return nullptr;
    }

    py::pyobj_handle SceneMeshRendererComponent_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(SceneRendererComponent_type.get())))};
    if (!SceneMeshRendererComponent_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_SceneMeshRendererComponent_Static{PyType_FromSpecWithBases(&type_spec_SceneMeshRendererComponent_Static, SceneMeshRendererComponent_Static_bases.get())};
    if (!type_SceneMeshRendererComponent_Static)
    {
        return nullptr;
    }

    py::pyobj_handle SceneMeshRendererComponent_bases{PyTuple_Pack(1, SceneRendererComponent_type.get())};
    if (!SceneMeshRendererComponent_bases)
    {
        return nullptr;
    }

    py::pytype_handle SceneMeshRendererComponent_type{py::register_python_type(module.get(), &type_spec_SceneMeshRendererComponent, SceneMeshRendererComponent_bases.get(), reinterpret_cast<PyTypeObject*>(type_SceneMeshRendererComponent_Static.get()))};
    if (!SceneMeshRendererComponent_type)
    {
        return nullptr;
    }

    py::pyobj_handle ScenePbrMaterial_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(SceneMaterial_type.get())))};
    if (!ScenePbrMaterial_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_ScenePbrMaterial_Static{PyType_FromSpecWithBases(&type_spec_ScenePbrMaterial_Static, ScenePbrMaterial_Static_bases.get())};
    if (!type_ScenePbrMaterial_Static)
    {
        return nullptr;
    }

    py::pyobj_handle ScenePbrMaterial_bases{PyTuple_Pack(1, SceneMaterial_type.get())};
    if (!ScenePbrMaterial_bases)
    {
        return nullptr;
    }

    py::pytype_handle ScenePbrMaterial_type{py::register_python_type(module.get(), &type_spec_ScenePbrMaterial, ScenePbrMaterial_bases.get(), reinterpret_cast<PyTypeObject*>(type_ScenePbrMaterial_Static.get()))};
    if (!ScenePbrMaterial_type)
    {
        return nullptr;
    }

    py::pyobj_handle SceneMetallicRoughnessMaterial_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(ScenePbrMaterial_type.get())))};
    if (!SceneMetallicRoughnessMaterial_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_SceneMetallicRoughnessMaterial_Static{PyType_FromSpecWithBases(&type_spec_SceneMetallicRoughnessMaterial_Static, SceneMetallicRoughnessMaterial_Static_bases.get())};
    if (!type_SceneMetallicRoughnessMaterial_Static)
    {
        return nullptr;
    }

    py::pyobj_handle SceneMetallicRoughnessMaterial_bases{PyTuple_Pack(1, ScenePbrMaterial_type.get())};
    if (!SceneMetallicRoughnessMaterial_bases)
    {
        return nullptr;
    }

    py::pytype_handle SceneMetallicRoughnessMaterial_type{py::register_python_type(module.get(), &type_spec_SceneMetallicRoughnessMaterial, SceneMetallicRoughnessMaterial_bases.get(), reinterpret_cast<PyTypeObject*>(type_SceneMetallicRoughnessMaterial_Static.get()))};
    if (!SceneMetallicRoughnessMaterial_type)
    {
        return nullptr;
    }

    py::pyobj_handle SceneModelTransform_bases{PyTuple_Pack(1, windows_ui_composition_CompositionTransform_type.get())};
    if (!SceneModelTransform_bases)
    {
        return nullptr;
    }

    py::pytype_handle SceneModelTransform_type{py::register_python_type(module.get(), &type_spec_SceneModelTransform, SceneModelTransform_bases.get(), inspectable_meta_type)};
    if (!SceneModelTransform_type)
    {
        return nullptr;
    }

    py::pyobj_handle SceneNode_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(SceneObject_type.get())))};
    if (!SceneNode_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_SceneNode_Static{PyType_FromSpecWithBases(&type_spec_SceneNode_Static, SceneNode_Static_bases.get())};
    if (!type_SceneNode_Static)
    {
        return nullptr;
    }

    py::pyobj_handle SceneNode_bases{PyTuple_Pack(1, SceneObject_type.get())};
    if (!SceneNode_bases)
    {
        return nullptr;
    }

    py::pytype_handle SceneNode_type{py::register_python_type(module.get(), &type_spec_SceneNode, SceneNode_bases.get(), reinterpret_cast<PyTypeObject*>(type_SceneNode_Static.get()))};
    if (!SceneNode_type)
    {
        return nullptr;
    }

    py::pyobj_handle SceneNodeCollection_bases{PyTuple_Pack(1, SceneObject_type.get())};
    if (!SceneNodeCollection_bases)
    {
        return nullptr;
    }

    py::pytype_handle SceneNodeCollection_type{py::register_python_type(module.get(), &type_spec_SceneNodeCollection, SceneNodeCollection_bases.get(), inspectable_meta_type)};
    if (!SceneNodeCollection_type)
    {
        return nullptr;
    }

    py::pyobj_handle SceneSurfaceMaterialInput_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(SceneMaterialInput_type.get())))};
    if (!SceneSurfaceMaterialInput_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_SceneSurfaceMaterialInput_Static{PyType_FromSpecWithBases(&type_spec_SceneSurfaceMaterialInput_Static, SceneSurfaceMaterialInput_Static_bases.get())};
    if (!type_SceneSurfaceMaterialInput_Static)
    {
        return nullptr;
    }

    py::pyobj_handle SceneSurfaceMaterialInput_bases{PyTuple_Pack(1, SceneMaterialInput_type.get())};
    if (!SceneSurfaceMaterialInput_bases)
    {
        return nullptr;
    }

    py::pytype_handle SceneSurfaceMaterialInput_type{py::register_python_type(module.get(), &type_spec_SceneSurfaceMaterialInput, SceneSurfaceMaterialInput_bases.get(), reinterpret_cast<PyTypeObject*>(type_SceneSurfaceMaterialInput_Static.get()))};
    if (!SceneSurfaceMaterialInput_type)
    {
        return nullptr;
    }

    py::pyobj_handle SceneVisual_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(windows_ui_composition_ContainerVisual_type.get())))};
    if (!SceneVisual_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_SceneVisual_Static{PyType_FromSpecWithBases(&type_spec_SceneVisual_Static, SceneVisual_Static_bases.get())};
    if (!type_SceneVisual_Static)
    {
        return nullptr;
    }

    py::pyobj_handle SceneVisual_bases{PyTuple_Pack(1, windows_ui_composition_ContainerVisual_type.get())};
    if (!SceneVisual_bases)
    {
        return nullptr;
    }

    py::pytype_handle SceneVisual_type{py::register_python_type(module.get(), &type_spec_SceneVisual, SceneVisual_bases.get(), reinterpret_cast<PyTypeObject*>(type_SceneVisual_Static.get()))};
    if (!SceneVisual_type)
    {
        return nullptr;
    }


    return module.detach();
}
