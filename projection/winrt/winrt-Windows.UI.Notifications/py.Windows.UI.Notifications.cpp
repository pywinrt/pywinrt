// WARNING: Please don't edit this file. It was generated by Python/WinRT v3.2.0

#include "py.Windows.UI.Notifications.h"

namespace py::cpp::Windows::UI::Notifications
{
    // ----- AdaptiveNotificationText class --------------------

    static PyObject* _new_AdaptiveNotificationText(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Notifications::AdaptiveNotificationText instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_AdaptiveNotificationText(py::wrapper::Windows::UI::Notifications::AdaptiveNotificationText* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AdaptiveNotificationText_get_Hints(py::wrapper::Windows::UI::Notifications::AdaptiveNotificationText* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.AdaptiveNotificationText", L"Hints");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Hints();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AdaptiveNotificationText_get_Kind(py::wrapper::Windows::UI::Notifications::AdaptiveNotificationText* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.AdaptiveNotificationText", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Kind();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AdaptiveNotificationText_get_Text(py::wrapper::Windows::UI::Notifications::AdaptiveNotificationText* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.AdaptiveNotificationText", L"Text");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Text();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AdaptiveNotificationText_put_Text(py::wrapper::Windows::UI::Notifications::AdaptiveNotificationText* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.AdaptiveNotificationText", L"Text");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            {
                auto _gil = release_gil();
                self->obj.Text(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AdaptiveNotificationText_get_Language(py::wrapper::Windows::UI::Notifications::AdaptiveNotificationText* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.AdaptiveNotificationText", L"Language");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Language();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AdaptiveNotificationText_put_Language(py::wrapper::Windows::UI::Notifications::AdaptiveNotificationText* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.AdaptiveNotificationText", L"Language");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            {
                auto _gil = release_gil();
                self->obj.Language(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_AdaptiveNotificationText(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Notifications::AdaptiveNotificationText>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AdaptiveNotificationText(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Notifications::AdaptiveNotificationText>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AdaptiveNotificationText[] = {
        { "_assign_array_", _assign_array_AdaptiveNotificationText, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AdaptiveNotificationText), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_AdaptiveNotificationText[] = {
        { "hints", reinterpret_cast<getter>(AdaptiveNotificationText_get_Hints), nullptr, nullptr, nullptr },
        { "kind", reinterpret_cast<getter>(AdaptiveNotificationText_get_Kind), nullptr, nullptr, nullptr },
        { "text", reinterpret_cast<getter>(AdaptiveNotificationText_get_Text), reinterpret_cast<setter>(AdaptiveNotificationText_put_Text), nullptr, nullptr },
        { "language", reinterpret_cast<getter>(AdaptiveNotificationText_get_Language), reinterpret_cast<setter>(AdaptiveNotificationText_put_Language), nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_AdaptiveNotificationText[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_AdaptiveNotificationText) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AdaptiveNotificationText) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AdaptiveNotificationText) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AdaptiveNotificationText) },
        { }};

    static PyType_Spec type_spec_AdaptiveNotificationText = {
        "winrt._winrt_windows_ui_notifications.AdaptiveNotificationText",
        sizeof(py::wrapper::Windows::UI::Notifications::AdaptiveNotificationText),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AdaptiveNotificationText};

    // ----- BadgeNotification class --------------------

    static PyObject* _new_BadgeNotification(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Data::Xml::Dom::XmlDocument>(args, 0);

                winrt::Windows::UI::Notifications::BadgeNotification instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_BadgeNotification(py::wrapper::Windows::UI::Notifications::BadgeNotification* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* BadgeNotification_get_ExpirationTime(py::wrapper::Windows::UI::Notifications::BadgeNotification* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.BadgeNotification", L"ExpirationTime");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ExpirationTime();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BadgeNotification_put_ExpirationTime(py::wrapper::Windows::UI::Notifications::BadgeNotification* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.BadgeNotification", L"ExpirationTime");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::DateTime>>(arg);

            {
                auto _gil = release_gil();
                self->obj.ExpirationTime(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BadgeNotification_get_Content(py::wrapper::Windows::UI::Notifications::BadgeNotification* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.BadgeNotification", L"Content");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Content();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_BadgeNotification(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Notifications::BadgeNotification>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_BadgeNotification(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Notifications::BadgeNotification>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_BadgeNotification[] = {
        { "_assign_array_", _assign_array_BadgeNotification, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_BadgeNotification), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_BadgeNotification[] = {
        { "expiration_time", reinterpret_cast<getter>(BadgeNotification_get_ExpirationTime), reinterpret_cast<setter>(BadgeNotification_put_ExpirationTime), nullptr, nullptr },
        { "content", reinterpret_cast<getter>(BadgeNotification_get_Content), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_BadgeNotification[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_BadgeNotification) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_BadgeNotification) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_BadgeNotification) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_BadgeNotification) },
        { }};

    static PyType_Spec type_spec_BadgeNotification = {
        "winrt._winrt_windows_ui_notifications.BadgeNotification",
        sizeof(py::wrapper::Windows::UI::Notifications::BadgeNotification),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BadgeNotification};

    // ----- BadgeUpdateManager class --------------------

    static PyObject* _new_BadgeUpdateManager(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Notifications::BadgeUpdateManager>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Notifications::BadgeUpdateManager>::type_name);
        return nullptr;
    }

    static PyObject* BadgeUpdateManager_CreateBadgeUpdaterForApplication(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Notifications.BadgeUpdateManager", L"CreateBadgeUpdaterForApplication", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::UI::Notifications::BadgeUpdateManager::CreateBadgeUpdaterForApplication();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BadgeUpdateManager_CreateBadgeUpdaterForApplicationWithId(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Notifications.BadgeUpdateManager", L"CreateBadgeUpdaterForApplication", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::UI::Notifications::BadgeUpdateManager::CreateBadgeUpdaterForApplication(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BadgeUpdateManager_CreateBadgeUpdaterForSecondaryTile(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Notifications.BadgeUpdateManager", L"CreateBadgeUpdaterForSecondaryTile", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::UI::Notifications::BadgeUpdateManager::CreateBadgeUpdaterForSecondaryTile(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BadgeUpdateManager_GetForUser(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Notifications.BadgeUpdateManager", L"GetForUser", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::System::User>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::UI::Notifications::BadgeUpdateManager::GetForUser(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BadgeUpdateManager_GetTemplateContent(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Notifications.BadgeUpdateManager", L"GetTemplateContent", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Notifications::BadgeTemplateType>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::UI::Notifications::BadgeUpdateManager::GetTemplateContent(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyMethodDef _methods_BadgeUpdateManager[] = {
        { }};

    static PyGetSetDef _getset_BadgeUpdateManager[] = {
        { }};

    static PyType_Slot _type_slots_BadgeUpdateManager[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_BadgeUpdateManager) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_BadgeUpdateManager) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_BadgeUpdateManager) },
        { }};

    static PyType_Spec type_spec_BadgeUpdateManager = {
        "winrt._winrt_windows_ui_notifications.BadgeUpdateManager",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BadgeUpdateManager};

    static PyGetSetDef getset_BadgeUpdateManager_Static[] = {
        { }};

    static PyMethodDef methods_BadgeUpdateManager_Static[] = {
        { "create_badge_updater_for_application", reinterpret_cast<PyCFunction>(BadgeUpdateManager_CreateBadgeUpdaterForApplication), METH_VARARGS, nullptr },
        { "create_badge_updater_for_application_with_id", reinterpret_cast<PyCFunction>(BadgeUpdateManager_CreateBadgeUpdaterForApplicationWithId), METH_VARARGS, nullptr },
        { "create_badge_updater_for_secondary_tile", reinterpret_cast<PyCFunction>(BadgeUpdateManager_CreateBadgeUpdaterForSecondaryTile), METH_VARARGS, nullptr },
        { "get_for_user", reinterpret_cast<PyCFunction>(BadgeUpdateManager_GetForUser), METH_VARARGS, nullptr },
        { "get_template_content", reinterpret_cast<PyCFunction>(BadgeUpdateManager_GetTemplateContent), METH_VARARGS, nullptr },
        { }};

    static PyType_Slot type_slots_BadgeUpdateManager_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_BadgeUpdateManager_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_BadgeUpdateManager_Static) },
        { }
    };

    static PyType_Spec type_spec_BadgeUpdateManager_Static = {
        "winrt._winrt_windows_ui_notifications.BadgeUpdateManager_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_BadgeUpdateManager_Static};

    // ----- BadgeUpdateManagerForUser class --------------------

    static PyObject* _new_BadgeUpdateManagerForUser(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Notifications::BadgeUpdateManagerForUser>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Notifications::BadgeUpdateManagerForUser>::type_name);
        return nullptr;
    }

    static void _dealloc_BadgeUpdateManagerForUser(py::wrapper::Windows::UI::Notifications::BadgeUpdateManagerForUser* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* BadgeUpdateManagerForUser_CreateBadgeUpdaterForApplication(py::wrapper::Windows::UI::Notifications::BadgeUpdateManagerForUser* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Notifications.BadgeUpdateManagerForUser", L"CreateBadgeUpdaterForApplication", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.CreateBadgeUpdaterForApplication();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BadgeUpdateManagerForUser_CreateBadgeUpdaterForApplicationWithId(py::wrapper::Windows::UI::Notifications::BadgeUpdateManagerForUser* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Notifications.BadgeUpdateManagerForUser", L"CreateBadgeUpdaterForApplication", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.CreateBadgeUpdaterForApplication(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BadgeUpdateManagerForUser_CreateBadgeUpdaterForSecondaryTile(py::wrapper::Windows::UI::Notifications::BadgeUpdateManagerForUser* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Notifications.BadgeUpdateManagerForUser", L"CreateBadgeUpdaterForSecondaryTile", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.CreateBadgeUpdaterForSecondaryTile(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BadgeUpdateManagerForUser_get_User(py::wrapper::Windows::UI::Notifications::BadgeUpdateManagerForUser* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.BadgeUpdateManagerForUser", L"User");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.User();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_BadgeUpdateManagerForUser(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Notifications::BadgeUpdateManagerForUser>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_BadgeUpdateManagerForUser(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Notifications::BadgeUpdateManagerForUser>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_BadgeUpdateManagerForUser[] = {
        { "create_badge_updater_for_application", reinterpret_cast<PyCFunction>(BadgeUpdateManagerForUser_CreateBadgeUpdaterForApplication), METH_VARARGS, nullptr },
        { "create_badge_updater_for_application_with_id", reinterpret_cast<PyCFunction>(BadgeUpdateManagerForUser_CreateBadgeUpdaterForApplicationWithId), METH_VARARGS, nullptr },
        { "create_badge_updater_for_secondary_tile", reinterpret_cast<PyCFunction>(BadgeUpdateManagerForUser_CreateBadgeUpdaterForSecondaryTile), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_BadgeUpdateManagerForUser, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_BadgeUpdateManagerForUser), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_BadgeUpdateManagerForUser[] = {
        { "user", reinterpret_cast<getter>(BadgeUpdateManagerForUser_get_User), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_BadgeUpdateManagerForUser[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_BadgeUpdateManagerForUser) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_BadgeUpdateManagerForUser) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_BadgeUpdateManagerForUser) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_BadgeUpdateManagerForUser) },
        { }};

    static PyType_Spec type_spec_BadgeUpdateManagerForUser = {
        "winrt._winrt_windows_ui_notifications.BadgeUpdateManagerForUser",
        sizeof(py::wrapper::Windows::UI::Notifications::BadgeUpdateManagerForUser),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BadgeUpdateManagerForUser};

    // ----- BadgeUpdater class --------------------

    static PyObject* _new_BadgeUpdater(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Notifications::BadgeUpdater>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Notifications::BadgeUpdater>::type_name);
        return nullptr;
    }

    static void _dealloc_BadgeUpdater(py::wrapper::Windows::UI::Notifications::BadgeUpdater* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* BadgeUpdater_Clear(py::wrapper::Windows::UI::Notifications::BadgeUpdater* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Notifications.BadgeUpdater", L"Clear", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.Clear();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BadgeUpdater_StartPeriodicUpdate(py::wrapper::Windows::UI::Notifications::BadgeUpdater* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Notifications.BadgeUpdater", L"StartPeriodicUpdate", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Notifications::PeriodicUpdateRecurrence>(args, 1);

                {
                    auto _gil = release_gil();
                    self->obj.StartPeriodicUpdate(param0, param1);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BadgeUpdater_StartPeriodicUpdateAtTime(py::wrapper::Windows::UI::Notifications::BadgeUpdater* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 3)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Notifications.BadgeUpdater", L"StartPeriodicUpdate", 3);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::DateTime>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::UI::Notifications::PeriodicUpdateRecurrence>(args, 2);

                {
                    auto _gil = release_gil();
                    self->obj.StartPeriodicUpdate(param0, param1, param2);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BadgeUpdater_StopPeriodicUpdate(py::wrapper::Windows::UI::Notifications::BadgeUpdater* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Notifications.BadgeUpdater", L"StopPeriodicUpdate", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.StopPeriodicUpdate();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BadgeUpdater_Update(py::wrapper::Windows::UI::Notifications::BadgeUpdater* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Notifications.BadgeUpdater", L"Update", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Notifications::BadgeNotification>(args, 0);

                {
                    auto _gil = release_gil();
                    self->obj.Update(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_BadgeUpdater(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Notifications::BadgeUpdater>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_BadgeUpdater(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Notifications::BadgeUpdater>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_BadgeUpdater[] = {
        { "clear", reinterpret_cast<PyCFunction>(BadgeUpdater_Clear), METH_VARARGS, nullptr },
        { "start_periodic_update", reinterpret_cast<PyCFunction>(BadgeUpdater_StartPeriodicUpdate), METH_VARARGS, nullptr },
        { "start_periodic_update_at_time", reinterpret_cast<PyCFunction>(BadgeUpdater_StartPeriodicUpdateAtTime), METH_VARARGS, nullptr },
        { "stop_periodic_update", reinterpret_cast<PyCFunction>(BadgeUpdater_StopPeriodicUpdate), METH_VARARGS, nullptr },
        { "update", reinterpret_cast<PyCFunction>(BadgeUpdater_Update), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_BadgeUpdater, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_BadgeUpdater), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_BadgeUpdater[] = {
        { }};

    static PyType_Slot _type_slots_BadgeUpdater[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_BadgeUpdater) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_BadgeUpdater) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_BadgeUpdater) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_BadgeUpdater) },
        { }};

    static PyType_Spec type_spec_BadgeUpdater = {
        "winrt._winrt_windows_ui_notifications.BadgeUpdater",
        sizeof(py::wrapper::Windows::UI::Notifications::BadgeUpdater),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BadgeUpdater};

    // ----- KnownAdaptiveNotificationHints class --------------------

    static PyObject* _new_KnownAdaptiveNotificationHints(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Notifications::KnownAdaptiveNotificationHints>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Notifications::KnownAdaptiveNotificationHints>::type_name);
        return nullptr;
    }

    static PyObject* KnownAdaptiveNotificationHints_get_Align(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.KnownAdaptiveNotificationHints", L"Align");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::UI::Notifications::KnownAdaptiveNotificationHints::Align();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownAdaptiveNotificationHints_get_MaxLines(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.KnownAdaptiveNotificationHints", L"MaxLines");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::UI::Notifications::KnownAdaptiveNotificationHints::MaxLines();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownAdaptiveNotificationHints_get_MinLines(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.KnownAdaptiveNotificationHints", L"MinLines");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::UI::Notifications::KnownAdaptiveNotificationHints::MinLines();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownAdaptiveNotificationHints_get_Style(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.KnownAdaptiveNotificationHints", L"Style");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::UI::Notifications::KnownAdaptiveNotificationHints::Style();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownAdaptiveNotificationHints_get_TextStacking(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.KnownAdaptiveNotificationHints", L"TextStacking");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::UI::Notifications::KnownAdaptiveNotificationHints::TextStacking();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownAdaptiveNotificationHints_get_Wrap(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.KnownAdaptiveNotificationHints", L"Wrap");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::UI::Notifications::KnownAdaptiveNotificationHints::Wrap();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_KnownAdaptiveNotificationHints[] = {
        { }};

    static PyGetSetDef _getset_KnownAdaptiveNotificationHints[] = {
        { }};

    static PyType_Slot _type_slots_KnownAdaptiveNotificationHints[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_KnownAdaptiveNotificationHints) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_KnownAdaptiveNotificationHints) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_KnownAdaptiveNotificationHints) },
        { }};

    static PyType_Spec type_spec_KnownAdaptiveNotificationHints = {
        "winrt._winrt_windows_ui_notifications.KnownAdaptiveNotificationHints",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_KnownAdaptiveNotificationHints};

    static PyGetSetDef getset_KnownAdaptiveNotificationHints_Static[] = {
        { "align", reinterpret_cast<getter>(KnownAdaptiveNotificationHints_get_Align), nullptr, nullptr, nullptr },
        { "max_lines", reinterpret_cast<getter>(KnownAdaptiveNotificationHints_get_MaxLines), nullptr, nullptr, nullptr },
        { "min_lines", reinterpret_cast<getter>(KnownAdaptiveNotificationHints_get_MinLines), nullptr, nullptr, nullptr },
        { "style", reinterpret_cast<getter>(KnownAdaptiveNotificationHints_get_Style), nullptr, nullptr, nullptr },
        { "text_stacking", reinterpret_cast<getter>(KnownAdaptiveNotificationHints_get_TextStacking), nullptr, nullptr, nullptr },
        { "wrap", reinterpret_cast<getter>(KnownAdaptiveNotificationHints_get_Wrap), nullptr, nullptr, nullptr },
        { }};

    static PyMethodDef methods_KnownAdaptiveNotificationHints_Static[] = {
        { }};

    static PyType_Slot type_slots_KnownAdaptiveNotificationHints_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_KnownAdaptiveNotificationHints_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_KnownAdaptiveNotificationHints_Static) },
        { }
    };

    static PyType_Spec type_spec_KnownAdaptiveNotificationHints_Static = {
        "winrt._winrt_windows_ui_notifications.KnownAdaptiveNotificationHints_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_KnownAdaptiveNotificationHints_Static};

    // ----- KnownAdaptiveNotificationTextStyles class --------------------

    static PyObject* _new_KnownAdaptiveNotificationTextStyles(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Notifications::KnownAdaptiveNotificationTextStyles>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Notifications::KnownAdaptiveNotificationTextStyles>::type_name);
        return nullptr;
    }

    static PyObject* KnownAdaptiveNotificationTextStyles_get_Base(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.KnownAdaptiveNotificationTextStyles", L"Base");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::UI::Notifications::KnownAdaptiveNotificationTextStyles::Base();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownAdaptiveNotificationTextStyles_get_BaseSubtle(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.KnownAdaptiveNotificationTextStyles", L"BaseSubtle");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::UI::Notifications::KnownAdaptiveNotificationTextStyles::BaseSubtle();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownAdaptiveNotificationTextStyles_get_Body(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.KnownAdaptiveNotificationTextStyles", L"Body");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::UI::Notifications::KnownAdaptiveNotificationTextStyles::Body();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownAdaptiveNotificationTextStyles_get_BodySubtle(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.KnownAdaptiveNotificationTextStyles", L"BodySubtle");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::UI::Notifications::KnownAdaptiveNotificationTextStyles::BodySubtle();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownAdaptiveNotificationTextStyles_get_Caption(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.KnownAdaptiveNotificationTextStyles", L"Caption");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::UI::Notifications::KnownAdaptiveNotificationTextStyles::Caption();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownAdaptiveNotificationTextStyles_get_CaptionSubtle(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.KnownAdaptiveNotificationTextStyles", L"CaptionSubtle");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::UI::Notifications::KnownAdaptiveNotificationTextStyles::CaptionSubtle();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownAdaptiveNotificationTextStyles_get_Header(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.KnownAdaptiveNotificationTextStyles", L"Header");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::UI::Notifications::KnownAdaptiveNotificationTextStyles::Header();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownAdaptiveNotificationTextStyles_get_HeaderNumeral(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.KnownAdaptiveNotificationTextStyles", L"HeaderNumeral");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::UI::Notifications::KnownAdaptiveNotificationTextStyles::HeaderNumeral();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownAdaptiveNotificationTextStyles_get_HeaderNumeralSubtle(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.KnownAdaptiveNotificationTextStyles", L"HeaderNumeralSubtle");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::UI::Notifications::KnownAdaptiveNotificationTextStyles::HeaderNumeralSubtle();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownAdaptiveNotificationTextStyles_get_HeaderSubtle(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.KnownAdaptiveNotificationTextStyles", L"HeaderSubtle");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::UI::Notifications::KnownAdaptiveNotificationTextStyles::HeaderSubtle();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownAdaptiveNotificationTextStyles_get_Subheader(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.KnownAdaptiveNotificationTextStyles", L"Subheader");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::UI::Notifications::KnownAdaptiveNotificationTextStyles::Subheader();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownAdaptiveNotificationTextStyles_get_SubheaderNumeral(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.KnownAdaptiveNotificationTextStyles", L"SubheaderNumeral");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::UI::Notifications::KnownAdaptiveNotificationTextStyles::SubheaderNumeral();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownAdaptiveNotificationTextStyles_get_SubheaderNumeralSubtle(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.KnownAdaptiveNotificationTextStyles", L"SubheaderNumeralSubtle");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::UI::Notifications::KnownAdaptiveNotificationTextStyles::SubheaderNumeralSubtle();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownAdaptiveNotificationTextStyles_get_SubheaderSubtle(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.KnownAdaptiveNotificationTextStyles", L"SubheaderSubtle");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::UI::Notifications::KnownAdaptiveNotificationTextStyles::SubheaderSubtle();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownAdaptiveNotificationTextStyles_get_Subtitle(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.KnownAdaptiveNotificationTextStyles", L"Subtitle");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::UI::Notifications::KnownAdaptiveNotificationTextStyles::Subtitle();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownAdaptiveNotificationTextStyles_get_SubtitleSubtle(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.KnownAdaptiveNotificationTextStyles", L"SubtitleSubtle");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::UI::Notifications::KnownAdaptiveNotificationTextStyles::SubtitleSubtle();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownAdaptiveNotificationTextStyles_get_Title(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.KnownAdaptiveNotificationTextStyles", L"Title");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::UI::Notifications::KnownAdaptiveNotificationTextStyles::Title();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownAdaptiveNotificationTextStyles_get_TitleNumeral(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.KnownAdaptiveNotificationTextStyles", L"TitleNumeral");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::UI::Notifications::KnownAdaptiveNotificationTextStyles::TitleNumeral();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownAdaptiveNotificationTextStyles_get_TitleSubtle(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.KnownAdaptiveNotificationTextStyles", L"TitleSubtle");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::UI::Notifications::KnownAdaptiveNotificationTextStyles::TitleSubtle();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_KnownAdaptiveNotificationTextStyles[] = {
        { }};

    static PyGetSetDef _getset_KnownAdaptiveNotificationTextStyles[] = {
        { }};

    static PyType_Slot _type_slots_KnownAdaptiveNotificationTextStyles[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_KnownAdaptiveNotificationTextStyles) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_KnownAdaptiveNotificationTextStyles) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_KnownAdaptiveNotificationTextStyles) },
        { }};

    static PyType_Spec type_spec_KnownAdaptiveNotificationTextStyles = {
        "winrt._winrt_windows_ui_notifications.KnownAdaptiveNotificationTextStyles",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_KnownAdaptiveNotificationTextStyles};

    static PyGetSetDef getset_KnownAdaptiveNotificationTextStyles_Static[] = {
        { "base", reinterpret_cast<getter>(KnownAdaptiveNotificationTextStyles_get_Base), nullptr, nullptr, nullptr },
        { "base_subtle", reinterpret_cast<getter>(KnownAdaptiveNotificationTextStyles_get_BaseSubtle), nullptr, nullptr, nullptr },
        { "body", reinterpret_cast<getter>(KnownAdaptiveNotificationTextStyles_get_Body), nullptr, nullptr, nullptr },
        { "body_subtle", reinterpret_cast<getter>(KnownAdaptiveNotificationTextStyles_get_BodySubtle), nullptr, nullptr, nullptr },
        { "caption", reinterpret_cast<getter>(KnownAdaptiveNotificationTextStyles_get_Caption), nullptr, nullptr, nullptr },
        { "caption_subtle", reinterpret_cast<getter>(KnownAdaptiveNotificationTextStyles_get_CaptionSubtle), nullptr, nullptr, nullptr },
        { "header", reinterpret_cast<getter>(KnownAdaptiveNotificationTextStyles_get_Header), nullptr, nullptr, nullptr },
        { "header_numeral", reinterpret_cast<getter>(KnownAdaptiveNotificationTextStyles_get_HeaderNumeral), nullptr, nullptr, nullptr },
        { "header_numeral_subtle", reinterpret_cast<getter>(KnownAdaptiveNotificationTextStyles_get_HeaderNumeralSubtle), nullptr, nullptr, nullptr },
        { "header_subtle", reinterpret_cast<getter>(KnownAdaptiveNotificationTextStyles_get_HeaderSubtle), nullptr, nullptr, nullptr },
        { "subheader", reinterpret_cast<getter>(KnownAdaptiveNotificationTextStyles_get_Subheader), nullptr, nullptr, nullptr },
        { "subheader_numeral", reinterpret_cast<getter>(KnownAdaptiveNotificationTextStyles_get_SubheaderNumeral), nullptr, nullptr, nullptr },
        { "subheader_numeral_subtle", reinterpret_cast<getter>(KnownAdaptiveNotificationTextStyles_get_SubheaderNumeralSubtle), nullptr, nullptr, nullptr },
        { "subheader_subtle", reinterpret_cast<getter>(KnownAdaptiveNotificationTextStyles_get_SubheaderSubtle), nullptr, nullptr, nullptr },
        { "subtitle", reinterpret_cast<getter>(KnownAdaptiveNotificationTextStyles_get_Subtitle), nullptr, nullptr, nullptr },
        { "subtitle_subtle", reinterpret_cast<getter>(KnownAdaptiveNotificationTextStyles_get_SubtitleSubtle), nullptr, nullptr, nullptr },
        { "title", reinterpret_cast<getter>(KnownAdaptiveNotificationTextStyles_get_Title), nullptr, nullptr, nullptr },
        { "title_numeral", reinterpret_cast<getter>(KnownAdaptiveNotificationTextStyles_get_TitleNumeral), nullptr, nullptr, nullptr },
        { "title_subtle", reinterpret_cast<getter>(KnownAdaptiveNotificationTextStyles_get_TitleSubtle), nullptr, nullptr, nullptr },
        { }};

    static PyMethodDef methods_KnownAdaptiveNotificationTextStyles_Static[] = {
        { }};

    static PyType_Slot type_slots_KnownAdaptiveNotificationTextStyles_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_KnownAdaptiveNotificationTextStyles_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_KnownAdaptiveNotificationTextStyles_Static) },
        { }
    };

    static PyType_Spec type_spec_KnownAdaptiveNotificationTextStyles_Static = {
        "winrt._winrt_windows_ui_notifications.KnownAdaptiveNotificationTextStyles_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_KnownAdaptiveNotificationTextStyles_Static};

    // ----- KnownNotificationBindings class --------------------

    static PyObject* _new_KnownNotificationBindings(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Notifications::KnownNotificationBindings>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Notifications::KnownNotificationBindings>::type_name);
        return nullptr;
    }

    static PyObject* KnownNotificationBindings_get_ToastGeneric(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.KnownNotificationBindings", L"ToastGeneric");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::UI::Notifications::KnownNotificationBindings::ToastGeneric();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_KnownNotificationBindings[] = {
        { }};

    static PyGetSetDef _getset_KnownNotificationBindings[] = {
        { }};

    static PyType_Slot _type_slots_KnownNotificationBindings[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_KnownNotificationBindings) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_KnownNotificationBindings) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_KnownNotificationBindings) },
        { }};

    static PyType_Spec type_spec_KnownNotificationBindings = {
        "winrt._winrt_windows_ui_notifications.KnownNotificationBindings",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_KnownNotificationBindings};

    static PyGetSetDef getset_KnownNotificationBindings_Static[] = {
        { "toast_generic", reinterpret_cast<getter>(KnownNotificationBindings_get_ToastGeneric), nullptr, nullptr, nullptr },
        { }};

    static PyMethodDef methods_KnownNotificationBindings_Static[] = {
        { }};

    static PyType_Slot type_slots_KnownNotificationBindings_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_KnownNotificationBindings_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_KnownNotificationBindings_Static) },
        { }
    };

    static PyType_Spec type_spec_KnownNotificationBindings_Static = {
        "winrt._winrt_windows_ui_notifications.KnownNotificationBindings_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_KnownNotificationBindings_Static};

    // ----- Notification class --------------------

    static PyObject* _new_Notification(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Notifications::Notification instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_Notification(py::wrapper::Windows::UI::Notifications::Notification* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* Notification_get_Visual(py::wrapper::Windows::UI::Notifications::Notification* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.Notification", L"Visual");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Visual();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Notification_put_Visual(py::wrapper::Windows::UI::Notifications::Notification* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.Notification", L"Visual");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Notifications::NotificationVisual>(arg);

            {
                auto _gil = release_gil();
                self->obj.Visual(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Notification_get_ExpirationTime(py::wrapper::Windows::UI::Notifications::Notification* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.Notification", L"ExpirationTime");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ExpirationTime();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Notification_put_ExpirationTime(py::wrapper::Windows::UI::Notifications::Notification* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.Notification", L"ExpirationTime");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::DateTime>>(arg);

            {
                auto _gil = release_gil();
                self->obj.ExpirationTime(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_Notification(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Notifications::Notification>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_Notification(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Notifications::Notification>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_Notification[] = {
        { "_assign_array_", _assign_array_Notification, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_Notification), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_Notification[] = {
        { "visual", reinterpret_cast<getter>(Notification_get_Visual), reinterpret_cast<setter>(Notification_put_Visual), nullptr, nullptr },
        { "expiration_time", reinterpret_cast<getter>(Notification_get_ExpirationTime), reinterpret_cast<setter>(Notification_put_ExpirationTime), nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_Notification[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_Notification) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_Notification) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_Notification) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_Notification) },
        { }};

    static PyType_Spec type_spec_Notification = {
        "winrt._winrt_windows_ui_notifications.Notification",
        sizeof(py::wrapper::Windows::UI::Notifications::Notification),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_Notification};

    // ----- NotificationBinding class --------------------

    static PyObject* _new_NotificationBinding(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Notifications::NotificationBinding>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Notifications::NotificationBinding>::type_name);
        return nullptr;
    }

    static void _dealloc_NotificationBinding(py::wrapper::Windows::UI::Notifications::NotificationBinding* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* NotificationBinding_GetTextElements(py::wrapper::Windows::UI::Notifications::NotificationBinding* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Notifications.NotificationBinding", L"GetTextElements", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetTextElements();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* NotificationBinding_get_Template(py::wrapper::Windows::UI::Notifications::NotificationBinding* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.NotificationBinding", L"Template");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Template();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int NotificationBinding_put_Template(py::wrapper::Windows::UI::Notifications::NotificationBinding* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.NotificationBinding", L"Template");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            {
                auto _gil = release_gil();
                self->obj.Template(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* NotificationBinding_get_Language(py::wrapper::Windows::UI::Notifications::NotificationBinding* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.NotificationBinding", L"Language");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Language();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int NotificationBinding_put_Language(py::wrapper::Windows::UI::Notifications::NotificationBinding* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.NotificationBinding", L"Language");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            {
                auto _gil = release_gil();
                self->obj.Language(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* NotificationBinding_get_Hints(py::wrapper::Windows::UI::Notifications::NotificationBinding* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.NotificationBinding", L"Hints");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Hints();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_NotificationBinding(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Notifications::NotificationBinding>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_NotificationBinding(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Notifications::NotificationBinding>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_NotificationBinding[] = {
        { "get_text_elements", reinterpret_cast<PyCFunction>(NotificationBinding_GetTextElements), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_NotificationBinding, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_NotificationBinding), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_NotificationBinding[] = {
        { "template", reinterpret_cast<getter>(NotificationBinding_get_Template), reinterpret_cast<setter>(NotificationBinding_put_Template), nullptr, nullptr },
        { "language", reinterpret_cast<getter>(NotificationBinding_get_Language), reinterpret_cast<setter>(NotificationBinding_put_Language), nullptr, nullptr },
        { "hints", reinterpret_cast<getter>(NotificationBinding_get_Hints), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_NotificationBinding[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_NotificationBinding) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_NotificationBinding) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_NotificationBinding) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_NotificationBinding) },
        { }};

    static PyType_Spec type_spec_NotificationBinding = {
        "winrt._winrt_windows_ui_notifications.NotificationBinding",
        sizeof(py::wrapper::Windows::UI::Notifications::NotificationBinding),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_NotificationBinding};

    // ----- NotificationData class --------------------

    static PyObject* _new_NotificationData(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);
        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Foundation::Collections::IKeyValuePair<winrt::hstring, winrt::hstring>>>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);

                winrt::Windows::UI::Notifications::NotificationData instance{param0, param1};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Foundation::Collections::IKeyValuePair<winrt::hstring, winrt::hstring>>>(args, 0);

                winrt::Windows::UI::Notifications::NotificationData instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Notifications::NotificationData instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_NotificationData(py::wrapper::Windows::UI::Notifications::NotificationData* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* NotificationData_get_SequenceNumber(py::wrapper::Windows::UI::Notifications::NotificationData* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.NotificationData", L"SequenceNumber");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SequenceNumber();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int NotificationData_put_SequenceNumber(py::wrapper::Windows::UI::Notifications::NotificationData* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.NotificationData", L"SequenceNumber");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<uint32_t>(arg);

            {
                auto _gil = release_gil();
                self->obj.SequenceNumber(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* NotificationData_get_Values(py::wrapper::Windows::UI::Notifications::NotificationData* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.NotificationData", L"Values");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Values();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_NotificationData(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Notifications::NotificationData>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_NotificationData(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Notifications::NotificationData>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_NotificationData[] = {
        { "_assign_array_", _assign_array_NotificationData, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_NotificationData), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_NotificationData[] = {
        { "sequence_number", reinterpret_cast<getter>(NotificationData_get_SequenceNumber), reinterpret_cast<setter>(NotificationData_put_SequenceNumber), nullptr, nullptr },
        { "values", reinterpret_cast<getter>(NotificationData_get_Values), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_NotificationData[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_NotificationData) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_NotificationData) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_NotificationData) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_NotificationData) },
        { }};

    static PyType_Spec type_spec_NotificationData = {
        "winrt._winrt_windows_ui_notifications.NotificationData",
        sizeof(py::wrapper::Windows::UI::Notifications::NotificationData),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_NotificationData};

    // ----- NotificationVisual class --------------------

    static PyObject* _new_NotificationVisual(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Notifications::NotificationVisual>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Notifications::NotificationVisual>::type_name);
        return nullptr;
    }

    static void _dealloc_NotificationVisual(py::wrapper::Windows::UI::Notifications::NotificationVisual* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* NotificationVisual_GetBinding(py::wrapper::Windows::UI::Notifications::NotificationVisual* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Notifications.NotificationVisual", L"GetBinding", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetBinding(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* NotificationVisual_get_Language(py::wrapper::Windows::UI::Notifications::NotificationVisual* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.NotificationVisual", L"Language");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Language();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int NotificationVisual_put_Language(py::wrapper::Windows::UI::Notifications::NotificationVisual* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.NotificationVisual", L"Language");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            {
                auto _gil = release_gil();
                self->obj.Language(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* NotificationVisual_get_Bindings(py::wrapper::Windows::UI::Notifications::NotificationVisual* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.NotificationVisual", L"Bindings");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Bindings();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_NotificationVisual(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Notifications::NotificationVisual>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_NotificationVisual(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Notifications::NotificationVisual>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_NotificationVisual[] = {
        { "get_binding", reinterpret_cast<PyCFunction>(NotificationVisual_GetBinding), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_NotificationVisual, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_NotificationVisual), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_NotificationVisual[] = {
        { "language", reinterpret_cast<getter>(NotificationVisual_get_Language), reinterpret_cast<setter>(NotificationVisual_put_Language), nullptr, nullptr },
        { "bindings", reinterpret_cast<getter>(NotificationVisual_get_Bindings), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_NotificationVisual[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_NotificationVisual) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_NotificationVisual) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_NotificationVisual) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_NotificationVisual) },
        { }};

    static PyType_Spec type_spec_NotificationVisual = {
        "winrt._winrt_windows_ui_notifications.NotificationVisual",
        sizeof(py::wrapper::Windows::UI::Notifications::NotificationVisual),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_NotificationVisual};

    // ----- ScheduledTileNotification class --------------------

    static PyObject* _new_ScheduledTileNotification(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);
        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Data::Xml::Dom::XmlDocument>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::DateTime>(args, 1);

                winrt::Windows::UI::Notifications::ScheduledTileNotification instance{param0, param1};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ScheduledTileNotification(py::wrapper::Windows::UI::Notifications::ScheduledTileNotification* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ScheduledTileNotification_get_Tag(py::wrapper::Windows::UI::Notifications::ScheduledTileNotification* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.ScheduledTileNotification", L"Tag");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Tag();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ScheduledTileNotification_put_Tag(py::wrapper::Windows::UI::Notifications::ScheduledTileNotification* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.ScheduledTileNotification", L"Tag");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            {
                auto _gil = release_gil();
                self->obj.Tag(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ScheduledTileNotification_get_Id(py::wrapper::Windows::UI::Notifications::ScheduledTileNotification* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.ScheduledTileNotification", L"Id");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Id();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ScheduledTileNotification_put_Id(py::wrapper::Windows::UI::Notifications::ScheduledTileNotification* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.ScheduledTileNotification", L"Id");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            {
                auto _gil = release_gil();
                self->obj.Id(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ScheduledTileNotification_get_ExpirationTime(py::wrapper::Windows::UI::Notifications::ScheduledTileNotification* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.ScheduledTileNotification", L"ExpirationTime");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ExpirationTime();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ScheduledTileNotification_put_ExpirationTime(py::wrapper::Windows::UI::Notifications::ScheduledTileNotification* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.ScheduledTileNotification", L"ExpirationTime");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::DateTime>>(arg);

            {
                auto _gil = release_gil();
                self->obj.ExpirationTime(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ScheduledTileNotification_get_Content(py::wrapper::Windows::UI::Notifications::ScheduledTileNotification* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.ScheduledTileNotification", L"Content");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Content();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ScheduledTileNotification_get_DeliveryTime(py::wrapper::Windows::UI::Notifications::ScheduledTileNotification* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.ScheduledTileNotification", L"DeliveryTime");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.DeliveryTime();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ScheduledTileNotification(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Notifications::ScheduledTileNotification>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ScheduledTileNotification(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Notifications::ScheduledTileNotification>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ScheduledTileNotification[] = {
        { "_assign_array_", _assign_array_ScheduledTileNotification, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ScheduledTileNotification), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_ScheduledTileNotification[] = {
        { "tag", reinterpret_cast<getter>(ScheduledTileNotification_get_Tag), reinterpret_cast<setter>(ScheduledTileNotification_put_Tag), nullptr, nullptr },
        { "id", reinterpret_cast<getter>(ScheduledTileNotification_get_Id), reinterpret_cast<setter>(ScheduledTileNotification_put_Id), nullptr, nullptr },
        { "expiration_time", reinterpret_cast<getter>(ScheduledTileNotification_get_ExpirationTime), reinterpret_cast<setter>(ScheduledTileNotification_put_ExpirationTime), nullptr, nullptr },
        { "content", reinterpret_cast<getter>(ScheduledTileNotification_get_Content), nullptr, nullptr, nullptr },
        { "delivery_time", reinterpret_cast<getter>(ScheduledTileNotification_get_DeliveryTime), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_ScheduledTileNotification[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ScheduledTileNotification) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ScheduledTileNotification) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ScheduledTileNotification) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ScheduledTileNotification) },
        { }};

    static PyType_Spec type_spec_ScheduledTileNotification = {
        "winrt._winrt_windows_ui_notifications.ScheduledTileNotification",
        sizeof(py::wrapper::Windows::UI::Notifications::ScheduledTileNotification),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ScheduledTileNotification};

    // ----- ScheduledToastNotification class --------------------

    static PyObject* _new_ScheduledToastNotification(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);
        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Data::Xml::Dom::XmlDocument>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::DateTime>(args, 1);

                winrt::Windows::UI::Notifications::ScheduledToastNotification instance{param0, param1};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 4)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Data::Xml::Dom::XmlDocument>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::DateTime>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(args, 2);
                auto param3 = py::convert_to<uint32_t>(args, 3);

                winrt::Windows::UI::Notifications::ScheduledToastNotification instance{param0, param1, param2, param3};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ScheduledToastNotification(py::wrapper::Windows::UI::Notifications::ScheduledToastNotification* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ScheduledToastNotification_get_Id(py::wrapper::Windows::UI::Notifications::ScheduledToastNotification* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.ScheduledToastNotification", L"Id");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Id();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ScheduledToastNotification_put_Id(py::wrapper::Windows::UI::Notifications::ScheduledToastNotification* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.ScheduledToastNotification", L"Id");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            {
                auto _gil = release_gil();
                self->obj.Id(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ScheduledToastNotification_get_Content(py::wrapper::Windows::UI::Notifications::ScheduledToastNotification* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.ScheduledToastNotification", L"Content");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Content();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ScheduledToastNotification_get_DeliveryTime(py::wrapper::Windows::UI::Notifications::ScheduledToastNotification* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.ScheduledToastNotification", L"DeliveryTime");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.DeliveryTime();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ScheduledToastNotification_get_MaximumSnoozeCount(py::wrapper::Windows::UI::Notifications::ScheduledToastNotification* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.ScheduledToastNotification", L"MaximumSnoozeCount");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.MaximumSnoozeCount();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ScheduledToastNotification_get_SnoozeInterval(py::wrapper::Windows::UI::Notifications::ScheduledToastNotification* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.ScheduledToastNotification", L"SnoozeInterval");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SnoozeInterval();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ScheduledToastNotification_get_Tag(py::wrapper::Windows::UI::Notifications::ScheduledToastNotification* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.ScheduledToastNotification", L"Tag");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Tag();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ScheduledToastNotification_put_Tag(py::wrapper::Windows::UI::Notifications::ScheduledToastNotification* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.ScheduledToastNotification", L"Tag");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            {
                auto _gil = release_gil();
                self->obj.Tag(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ScheduledToastNotification_get_SuppressPopup(py::wrapper::Windows::UI::Notifications::ScheduledToastNotification* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.ScheduledToastNotification", L"SuppressPopup");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SuppressPopup();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ScheduledToastNotification_put_SuppressPopup(py::wrapper::Windows::UI::Notifications::ScheduledToastNotification* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.ScheduledToastNotification", L"SuppressPopup");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.SuppressPopup(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ScheduledToastNotification_get_Group(py::wrapper::Windows::UI::Notifications::ScheduledToastNotification* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.ScheduledToastNotification", L"Group");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Group();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ScheduledToastNotification_put_Group(py::wrapper::Windows::UI::Notifications::ScheduledToastNotification* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.ScheduledToastNotification", L"Group");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            {
                auto _gil = release_gil();
                self->obj.Group(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ScheduledToastNotification_get_RemoteId(py::wrapper::Windows::UI::Notifications::ScheduledToastNotification* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.ScheduledToastNotification", L"RemoteId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.RemoteId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ScheduledToastNotification_put_RemoteId(py::wrapper::Windows::UI::Notifications::ScheduledToastNotification* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.ScheduledToastNotification", L"RemoteId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            {
                auto _gil = release_gil();
                self->obj.RemoteId(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ScheduledToastNotification_get_NotificationMirroring(py::wrapper::Windows::UI::Notifications::ScheduledToastNotification* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.ScheduledToastNotification", L"NotificationMirroring");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.NotificationMirroring();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ScheduledToastNotification_put_NotificationMirroring(py::wrapper::Windows::UI::Notifications::ScheduledToastNotification* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.ScheduledToastNotification", L"NotificationMirroring");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Notifications::NotificationMirroring>(arg);

            {
                auto _gil = release_gil();
                self->obj.NotificationMirroring(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ScheduledToastNotification_get_ExpirationTime(py::wrapper::Windows::UI::Notifications::ScheduledToastNotification* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.ScheduledToastNotification", L"ExpirationTime");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ExpirationTime();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ScheduledToastNotification_put_ExpirationTime(py::wrapper::Windows::UI::Notifications::ScheduledToastNotification* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.ScheduledToastNotification", L"ExpirationTime");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::DateTime>>(arg);

            {
                auto _gil = release_gil();
                self->obj.ExpirationTime(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_ScheduledToastNotification(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Notifications::ScheduledToastNotification>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ScheduledToastNotification(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Notifications::ScheduledToastNotification>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ScheduledToastNotification[] = {
        { "_assign_array_", _assign_array_ScheduledToastNotification, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ScheduledToastNotification), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_ScheduledToastNotification[] = {
        { "id", reinterpret_cast<getter>(ScheduledToastNotification_get_Id), reinterpret_cast<setter>(ScheduledToastNotification_put_Id), nullptr, nullptr },
        { "content", reinterpret_cast<getter>(ScheduledToastNotification_get_Content), nullptr, nullptr, nullptr },
        { "delivery_time", reinterpret_cast<getter>(ScheduledToastNotification_get_DeliveryTime), nullptr, nullptr, nullptr },
        { "maximum_snooze_count", reinterpret_cast<getter>(ScheduledToastNotification_get_MaximumSnoozeCount), nullptr, nullptr, nullptr },
        { "snooze_interval", reinterpret_cast<getter>(ScheduledToastNotification_get_SnoozeInterval), nullptr, nullptr, nullptr },
        { "tag", reinterpret_cast<getter>(ScheduledToastNotification_get_Tag), reinterpret_cast<setter>(ScheduledToastNotification_put_Tag), nullptr, nullptr },
        { "suppress_popup", reinterpret_cast<getter>(ScheduledToastNotification_get_SuppressPopup), reinterpret_cast<setter>(ScheduledToastNotification_put_SuppressPopup), nullptr, nullptr },
        { "group", reinterpret_cast<getter>(ScheduledToastNotification_get_Group), reinterpret_cast<setter>(ScheduledToastNotification_put_Group), nullptr, nullptr },
        { "remote_id", reinterpret_cast<getter>(ScheduledToastNotification_get_RemoteId), reinterpret_cast<setter>(ScheduledToastNotification_put_RemoteId), nullptr, nullptr },
        { "notification_mirroring", reinterpret_cast<getter>(ScheduledToastNotification_get_NotificationMirroring), reinterpret_cast<setter>(ScheduledToastNotification_put_NotificationMirroring), nullptr, nullptr },
        { "expiration_time", reinterpret_cast<getter>(ScheduledToastNotification_get_ExpirationTime), reinterpret_cast<setter>(ScheduledToastNotification_put_ExpirationTime), nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_ScheduledToastNotification[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ScheduledToastNotification) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ScheduledToastNotification) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ScheduledToastNotification) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ScheduledToastNotification) },
        { }};

    static PyType_Spec type_spec_ScheduledToastNotification = {
        "winrt._winrt_windows_ui_notifications.ScheduledToastNotification",
        sizeof(py::wrapper::Windows::UI::Notifications::ScheduledToastNotification),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ScheduledToastNotification};

    // ----- ScheduledToastNotificationShowingEventArgs class --------------------

    static PyObject* _new_ScheduledToastNotificationShowingEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Notifications::ScheduledToastNotificationShowingEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Notifications::ScheduledToastNotificationShowingEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_ScheduledToastNotificationShowingEventArgs(py::wrapper::Windows::UI::Notifications::ScheduledToastNotificationShowingEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ScheduledToastNotificationShowingEventArgs_GetDeferral(py::wrapper::Windows::UI::Notifications::ScheduledToastNotificationShowingEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Notifications.ScheduledToastNotificationShowingEventArgs", L"GetDeferral", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetDeferral();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ScheduledToastNotificationShowingEventArgs_get_Cancel(py::wrapper::Windows::UI::Notifications::ScheduledToastNotificationShowingEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.ScheduledToastNotificationShowingEventArgs", L"Cancel");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Cancel();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ScheduledToastNotificationShowingEventArgs_put_Cancel(py::wrapper::Windows::UI::Notifications::ScheduledToastNotificationShowingEventArgs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.ScheduledToastNotificationShowingEventArgs", L"Cancel");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.Cancel(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ScheduledToastNotificationShowingEventArgs_get_ScheduledToastNotification(py::wrapper::Windows::UI::Notifications::ScheduledToastNotificationShowingEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.ScheduledToastNotificationShowingEventArgs", L"ScheduledToastNotification");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ScheduledToastNotification();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ScheduledToastNotificationShowingEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Notifications::ScheduledToastNotificationShowingEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ScheduledToastNotificationShowingEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Notifications::ScheduledToastNotificationShowingEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ScheduledToastNotificationShowingEventArgs[] = {
        { "get_deferral", reinterpret_cast<PyCFunction>(ScheduledToastNotificationShowingEventArgs_GetDeferral), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_ScheduledToastNotificationShowingEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ScheduledToastNotificationShowingEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_ScheduledToastNotificationShowingEventArgs[] = {
        { "cancel", reinterpret_cast<getter>(ScheduledToastNotificationShowingEventArgs_get_Cancel), reinterpret_cast<setter>(ScheduledToastNotificationShowingEventArgs_put_Cancel), nullptr, nullptr },
        { "scheduled_toast_notification", reinterpret_cast<getter>(ScheduledToastNotificationShowingEventArgs_get_ScheduledToastNotification), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_ScheduledToastNotificationShowingEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ScheduledToastNotificationShowingEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ScheduledToastNotificationShowingEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ScheduledToastNotificationShowingEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ScheduledToastNotificationShowingEventArgs) },
        { }};

    static PyType_Spec type_spec_ScheduledToastNotificationShowingEventArgs = {
        "winrt._winrt_windows_ui_notifications.ScheduledToastNotificationShowingEventArgs",
        sizeof(py::wrapper::Windows::UI::Notifications::ScheduledToastNotificationShowingEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ScheduledToastNotificationShowingEventArgs};

    // ----- ShownTileNotification class --------------------

    static PyObject* _new_ShownTileNotification(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Notifications::ShownTileNotification>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Notifications::ShownTileNotification>::type_name);
        return nullptr;
    }

    static void _dealloc_ShownTileNotification(py::wrapper::Windows::UI::Notifications::ShownTileNotification* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ShownTileNotification_get_Arguments(py::wrapper::Windows::UI::Notifications::ShownTileNotification* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.ShownTileNotification", L"Arguments");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Arguments();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ShownTileNotification(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Notifications::ShownTileNotification>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ShownTileNotification(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Notifications::ShownTileNotification>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ShownTileNotification[] = {
        { "_assign_array_", _assign_array_ShownTileNotification, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ShownTileNotification), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_ShownTileNotification[] = {
        { "arguments", reinterpret_cast<getter>(ShownTileNotification_get_Arguments), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_ShownTileNotification[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ShownTileNotification) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ShownTileNotification) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ShownTileNotification) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ShownTileNotification) },
        { }};

    static PyType_Spec type_spec_ShownTileNotification = {
        "winrt._winrt_windows_ui_notifications.ShownTileNotification",
        sizeof(py::wrapper::Windows::UI::Notifications::ShownTileNotification),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ShownTileNotification};

    // ----- TileFlyoutNotification class --------------------

    static PyObject* _new_TileFlyoutNotification(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Data::Xml::Dom::XmlDocument>(args, 0);

                winrt::Windows::UI::Notifications::TileFlyoutNotification instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_TileFlyoutNotification(py::wrapper::Windows::UI::Notifications::TileFlyoutNotification* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* TileFlyoutNotification_get_ExpirationTime(py::wrapper::Windows::UI::Notifications::TileFlyoutNotification* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.TileFlyoutNotification", L"ExpirationTime");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ExpirationTime();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TileFlyoutNotification_put_ExpirationTime(py::wrapper::Windows::UI::Notifications::TileFlyoutNotification* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.TileFlyoutNotification", L"ExpirationTime");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::DateTime>>(arg);

            {
                auto _gil = release_gil();
                self->obj.ExpirationTime(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TileFlyoutNotification_get_Content(py::wrapper::Windows::UI::Notifications::TileFlyoutNotification* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.TileFlyoutNotification", L"Content");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Content();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_TileFlyoutNotification(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Notifications::TileFlyoutNotification>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_TileFlyoutNotification(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Notifications::TileFlyoutNotification>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TileFlyoutNotification[] = {
        { "_assign_array_", _assign_array_TileFlyoutNotification, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_TileFlyoutNotification), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_TileFlyoutNotification[] = {
        { "expiration_time", reinterpret_cast<getter>(TileFlyoutNotification_get_ExpirationTime), reinterpret_cast<setter>(TileFlyoutNotification_put_ExpirationTime), nullptr, nullptr },
        { "content", reinterpret_cast<getter>(TileFlyoutNotification_get_Content), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_TileFlyoutNotification[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_TileFlyoutNotification) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_TileFlyoutNotification) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_TileFlyoutNotification) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_TileFlyoutNotification) },
        { }};

    static PyType_Spec type_spec_TileFlyoutNotification = {
        "winrt._winrt_windows_ui_notifications.TileFlyoutNotification",
        sizeof(py::wrapper::Windows::UI::Notifications::TileFlyoutNotification),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TileFlyoutNotification};

    // ----- TileFlyoutUpdateManager class --------------------

    static PyObject* _new_TileFlyoutUpdateManager(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Notifications::TileFlyoutUpdateManager>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Notifications::TileFlyoutUpdateManager>::type_name);
        return nullptr;
    }

    static PyObject* TileFlyoutUpdateManager_CreateTileFlyoutUpdaterForApplication(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Notifications.TileFlyoutUpdateManager", L"CreateTileFlyoutUpdaterForApplication", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::UI::Notifications::TileFlyoutUpdateManager::CreateTileFlyoutUpdaterForApplication();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TileFlyoutUpdateManager_CreateTileFlyoutUpdaterForApplicationWithId(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Notifications.TileFlyoutUpdateManager", L"CreateTileFlyoutUpdaterForApplication", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::UI::Notifications::TileFlyoutUpdateManager::CreateTileFlyoutUpdaterForApplication(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TileFlyoutUpdateManager_CreateTileFlyoutUpdaterForSecondaryTile(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Notifications.TileFlyoutUpdateManager", L"CreateTileFlyoutUpdaterForSecondaryTile", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::UI::Notifications::TileFlyoutUpdateManager::CreateTileFlyoutUpdaterForSecondaryTile(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TileFlyoutUpdateManager_GetTemplateContent(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Notifications.TileFlyoutUpdateManager", L"GetTemplateContent", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Notifications::TileFlyoutTemplateType>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::UI::Notifications::TileFlyoutUpdateManager::GetTemplateContent(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyMethodDef _methods_TileFlyoutUpdateManager[] = {
        { }};

    static PyGetSetDef _getset_TileFlyoutUpdateManager[] = {
        { }};

    static PyType_Slot _type_slots_TileFlyoutUpdateManager[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_TileFlyoutUpdateManager) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_TileFlyoutUpdateManager) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_TileFlyoutUpdateManager) },
        { }};

    static PyType_Spec type_spec_TileFlyoutUpdateManager = {
        "winrt._winrt_windows_ui_notifications.TileFlyoutUpdateManager",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TileFlyoutUpdateManager};

    static PyGetSetDef getset_TileFlyoutUpdateManager_Static[] = {
        { }};

    static PyMethodDef methods_TileFlyoutUpdateManager_Static[] = {
        { "create_tile_flyout_updater_for_application", reinterpret_cast<PyCFunction>(TileFlyoutUpdateManager_CreateTileFlyoutUpdaterForApplication), METH_VARARGS, nullptr },
        { "create_tile_flyout_updater_for_application_with_id", reinterpret_cast<PyCFunction>(TileFlyoutUpdateManager_CreateTileFlyoutUpdaterForApplicationWithId), METH_VARARGS, nullptr },
        { "create_tile_flyout_updater_for_secondary_tile", reinterpret_cast<PyCFunction>(TileFlyoutUpdateManager_CreateTileFlyoutUpdaterForSecondaryTile), METH_VARARGS, nullptr },
        { "get_template_content", reinterpret_cast<PyCFunction>(TileFlyoutUpdateManager_GetTemplateContent), METH_VARARGS, nullptr },
        { }};

    static PyType_Slot type_slots_TileFlyoutUpdateManager_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_TileFlyoutUpdateManager_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_TileFlyoutUpdateManager_Static) },
        { }
    };

    static PyType_Spec type_spec_TileFlyoutUpdateManager_Static = {
        "winrt._winrt_windows_ui_notifications.TileFlyoutUpdateManager_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_TileFlyoutUpdateManager_Static};

    // ----- TileFlyoutUpdater class --------------------

    static PyObject* _new_TileFlyoutUpdater(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Notifications::TileFlyoutUpdater>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Notifications::TileFlyoutUpdater>::type_name);
        return nullptr;
    }

    static void _dealloc_TileFlyoutUpdater(py::wrapper::Windows::UI::Notifications::TileFlyoutUpdater* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* TileFlyoutUpdater_Clear(py::wrapper::Windows::UI::Notifications::TileFlyoutUpdater* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Notifications.TileFlyoutUpdater", L"Clear", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.Clear();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TileFlyoutUpdater_StartPeriodicUpdate(py::wrapper::Windows::UI::Notifications::TileFlyoutUpdater* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Notifications.TileFlyoutUpdater", L"StartPeriodicUpdate", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Notifications::PeriodicUpdateRecurrence>(args, 1);

                {
                    auto _gil = release_gil();
                    self->obj.StartPeriodicUpdate(param0, param1);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TileFlyoutUpdater_StartPeriodicUpdateAtTime(py::wrapper::Windows::UI::Notifications::TileFlyoutUpdater* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 3)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Notifications.TileFlyoutUpdater", L"StartPeriodicUpdate", 3);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::DateTime>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::UI::Notifications::PeriodicUpdateRecurrence>(args, 2);

                {
                    auto _gil = release_gil();
                    self->obj.StartPeriodicUpdate(param0, param1, param2);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TileFlyoutUpdater_StopPeriodicUpdate(py::wrapper::Windows::UI::Notifications::TileFlyoutUpdater* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Notifications.TileFlyoutUpdater", L"StopPeriodicUpdate", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.StopPeriodicUpdate();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TileFlyoutUpdater_Update(py::wrapper::Windows::UI::Notifications::TileFlyoutUpdater* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Notifications.TileFlyoutUpdater", L"Update", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Notifications::TileFlyoutNotification>(args, 0);

                {
                    auto _gil = release_gil();
                    self->obj.Update(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TileFlyoutUpdater_get_Setting(py::wrapper::Windows::UI::Notifications::TileFlyoutUpdater* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.TileFlyoutUpdater", L"Setting");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Setting();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_TileFlyoutUpdater(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Notifications::TileFlyoutUpdater>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_TileFlyoutUpdater(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Notifications::TileFlyoutUpdater>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TileFlyoutUpdater[] = {
        { "clear", reinterpret_cast<PyCFunction>(TileFlyoutUpdater_Clear), METH_VARARGS, nullptr },
        { "start_periodic_update", reinterpret_cast<PyCFunction>(TileFlyoutUpdater_StartPeriodicUpdate), METH_VARARGS, nullptr },
        { "start_periodic_update_at_time", reinterpret_cast<PyCFunction>(TileFlyoutUpdater_StartPeriodicUpdateAtTime), METH_VARARGS, nullptr },
        { "stop_periodic_update", reinterpret_cast<PyCFunction>(TileFlyoutUpdater_StopPeriodicUpdate), METH_VARARGS, nullptr },
        { "update", reinterpret_cast<PyCFunction>(TileFlyoutUpdater_Update), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_TileFlyoutUpdater, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_TileFlyoutUpdater), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_TileFlyoutUpdater[] = {
        { "setting", reinterpret_cast<getter>(TileFlyoutUpdater_get_Setting), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_TileFlyoutUpdater[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_TileFlyoutUpdater) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_TileFlyoutUpdater) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_TileFlyoutUpdater) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_TileFlyoutUpdater) },
        { }};

    static PyType_Spec type_spec_TileFlyoutUpdater = {
        "winrt._winrt_windows_ui_notifications.TileFlyoutUpdater",
        sizeof(py::wrapper::Windows::UI::Notifications::TileFlyoutUpdater),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TileFlyoutUpdater};

    // ----- TileNotification class --------------------

    static PyObject* _new_TileNotification(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Data::Xml::Dom::XmlDocument>(args, 0);

                winrt::Windows::UI::Notifications::TileNotification instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_TileNotification(py::wrapper::Windows::UI::Notifications::TileNotification* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* TileNotification_get_Tag(py::wrapper::Windows::UI::Notifications::TileNotification* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.TileNotification", L"Tag");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Tag();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TileNotification_put_Tag(py::wrapper::Windows::UI::Notifications::TileNotification* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.TileNotification", L"Tag");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            {
                auto _gil = release_gil();
                self->obj.Tag(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TileNotification_get_ExpirationTime(py::wrapper::Windows::UI::Notifications::TileNotification* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.TileNotification", L"ExpirationTime");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ExpirationTime();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TileNotification_put_ExpirationTime(py::wrapper::Windows::UI::Notifications::TileNotification* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.TileNotification", L"ExpirationTime");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::DateTime>>(arg);

            {
                auto _gil = release_gil();
                self->obj.ExpirationTime(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TileNotification_get_Content(py::wrapper::Windows::UI::Notifications::TileNotification* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.TileNotification", L"Content");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Content();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_TileNotification(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Notifications::TileNotification>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_TileNotification(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Notifications::TileNotification>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TileNotification[] = {
        { "_assign_array_", _assign_array_TileNotification, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_TileNotification), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_TileNotification[] = {
        { "tag", reinterpret_cast<getter>(TileNotification_get_Tag), reinterpret_cast<setter>(TileNotification_put_Tag), nullptr, nullptr },
        { "expiration_time", reinterpret_cast<getter>(TileNotification_get_ExpirationTime), reinterpret_cast<setter>(TileNotification_put_ExpirationTime), nullptr, nullptr },
        { "content", reinterpret_cast<getter>(TileNotification_get_Content), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_TileNotification[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_TileNotification) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_TileNotification) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_TileNotification) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_TileNotification) },
        { }};

    static PyType_Spec type_spec_TileNotification = {
        "winrt._winrt_windows_ui_notifications.TileNotification",
        sizeof(py::wrapper::Windows::UI::Notifications::TileNotification),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TileNotification};

    // ----- TileUpdateManager class --------------------

    static PyObject* _new_TileUpdateManager(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Notifications::TileUpdateManager>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Notifications::TileUpdateManager>::type_name);
        return nullptr;
    }

    static PyObject* TileUpdateManager_CreateTileUpdaterForApplication(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Notifications.TileUpdateManager", L"CreateTileUpdaterForApplication", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::UI::Notifications::TileUpdateManager::CreateTileUpdaterForApplication();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TileUpdateManager_CreateTileUpdaterForApplicationWithId(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Notifications.TileUpdateManager", L"CreateTileUpdaterForApplication", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::UI::Notifications::TileUpdateManager::CreateTileUpdaterForApplication(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TileUpdateManager_CreateTileUpdaterForSecondaryTile(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Notifications.TileUpdateManager", L"CreateTileUpdaterForSecondaryTile", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::UI::Notifications::TileUpdateManager::CreateTileUpdaterForSecondaryTile(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TileUpdateManager_GetForUser(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Notifications.TileUpdateManager", L"GetForUser", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::System::User>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::UI::Notifications::TileUpdateManager::GetForUser(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TileUpdateManager_GetTemplateContent(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Notifications.TileUpdateManager", L"GetTemplateContent", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Notifications::TileTemplateType>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::UI::Notifications::TileUpdateManager::GetTemplateContent(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyMethodDef _methods_TileUpdateManager[] = {
        { }};

    static PyGetSetDef _getset_TileUpdateManager[] = {
        { }};

    static PyType_Slot _type_slots_TileUpdateManager[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_TileUpdateManager) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_TileUpdateManager) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_TileUpdateManager) },
        { }};

    static PyType_Spec type_spec_TileUpdateManager = {
        "winrt._winrt_windows_ui_notifications.TileUpdateManager",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TileUpdateManager};

    static PyGetSetDef getset_TileUpdateManager_Static[] = {
        { }};

    static PyMethodDef methods_TileUpdateManager_Static[] = {
        { "create_tile_updater_for_application", reinterpret_cast<PyCFunction>(TileUpdateManager_CreateTileUpdaterForApplication), METH_VARARGS, nullptr },
        { "create_tile_updater_for_application_with_id", reinterpret_cast<PyCFunction>(TileUpdateManager_CreateTileUpdaterForApplicationWithId), METH_VARARGS, nullptr },
        { "create_tile_updater_for_secondary_tile", reinterpret_cast<PyCFunction>(TileUpdateManager_CreateTileUpdaterForSecondaryTile), METH_VARARGS, nullptr },
        { "get_for_user", reinterpret_cast<PyCFunction>(TileUpdateManager_GetForUser), METH_VARARGS, nullptr },
        { "get_template_content", reinterpret_cast<PyCFunction>(TileUpdateManager_GetTemplateContent), METH_VARARGS, nullptr },
        { }};

    static PyType_Slot type_slots_TileUpdateManager_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_TileUpdateManager_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_TileUpdateManager_Static) },
        { }
    };

    static PyType_Spec type_spec_TileUpdateManager_Static = {
        "winrt._winrt_windows_ui_notifications.TileUpdateManager_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_TileUpdateManager_Static};

    // ----- TileUpdateManagerForUser class --------------------

    static PyObject* _new_TileUpdateManagerForUser(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Notifications::TileUpdateManagerForUser>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Notifications::TileUpdateManagerForUser>::type_name);
        return nullptr;
    }

    static void _dealloc_TileUpdateManagerForUser(py::wrapper::Windows::UI::Notifications::TileUpdateManagerForUser* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* TileUpdateManagerForUser_CreateTileUpdaterForApplication(py::wrapper::Windows::UI::Notifications::TileUpdateManagerForUser* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Notifications.TileUpdateManagerForUser", L"CreateTileUpdaterForApplicationForUser", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.CreateTileUpdaterForApplicationForUser();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TileUpdateManagerForUser_CreateTileUpdaterForApplicationWithId(py::wrapper::Windows::UI::Notifications::TileUpdateManagerForUser* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Notifications.TileUpdateManagerForUser", L"CreateTileUpdaterForApplication", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.CreateTileUpdaterForApplication(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TileUpdateManagerForUser_CreateTileUpdaterForSecondaryTile(py::wrapper::Windows::UI::Notifications::TileUpdateManagerForUser* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Notifications.TileUpdateManagerForUser", L"CreateTileUpdaterForSecondaryTile", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.CreateTileUpdaterForSecondaryTile(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TileUpdateManagerForUser_get_User(py::wrapper::Windows::UI::Notifications::TileUpdateManagerForUser* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.TileUpdateManagerForUser", L"User");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.User();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_TileUpdateManagerForUser(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Notifications::TileUpdateManagerForUser>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_TileUpdateManagerForUser(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Notifications::TileUpdateManagerForUser>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TileUpdateManagerForUser[] = {
        { "create_tile_updater_for_application", reinterpret_cast<PyCFunction>(TileUpdateManagerForUser_CreateTileUpdaterForApplication), METH_VARARGS, nullptr },
        { "create_tile_updater_for_application_with_id", reinterpret_cast<PyCFunction>(TileUpdateManagerForUser_CreateTileUpdaterForApplicationWithId), METH_VARARGS, nullptr },
        { "create_tile_updater_for_secondary_tile", reinterpret_cast<PyCFunction>(TileUpdateManagerForUser_CreateTileUpdaterForSecondaryTile), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_TileUpdateManagerForUser, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_TileUpdateManagerForUser), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_TileUpdateManagerForUser[] = {
        { "user", reinterpret_cast<getter>(TileUpdateManagerForUser_get_User), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_TileUpdateManagerForUser[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_TileUpdateManagerForUser) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_TileUpdateManagerForUser) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_TileUpdateManagerForUser) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_TileUpdateManagerForUser) },
        { }};

    static PyType_Spec type_spec_TileUpdateManagerForUser = {
        "winrt._winrt_windows_ui_notifications.TileUpdateManagerForUser",
        sizeof(py::wrapper::Windows::UI::Notifications::TileUpdateManagerForUser),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TileUpdateManagerForUser};

    // ----- TileUpdater class --------------------

    static PyObject* _new_TileUpdater(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Notifications::TileUpdater>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Notifications::TileUpdater>::type_name);
        return nullptr;
    }

    static void _dealloc_TileUpdater(py::wrapper::Windows::UI::Notifications::TileUpdater* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* TileUpdater_AddToSchedule(py::wrapper::Windows::UI::Notifications::TileUpdater* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Notifications.TileUpdater", L"AddToSchedule", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Notifications::ScheduledTileNotification>(args, 0);

                {
                    auto _gil = release_gil();
                    self->obj.AddToSchedule(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TileUpdater_Clear(py::wrapper::Windows::UI::Notifications::TileUpdater* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Notifications.TileUpdater", L"Clear", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.Clear();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TileUpdater_EnableNotificationQueue(py::wrapper::Windows::UI::Notifications::TileUpdater* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Notifications.TileUpdater", L"EnableNotificationQueue", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<bool>(args, 0);

                {
                    auto _gil = release_gil();
                    self->obj.EnableNotificationQueue(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TileUpdater_EnableNotificationQueueForSquare150x150(py::wrapper::Windows::UI::Notifications::TileUpdater* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Notifications.TileUpdater", L"EnableNotificationQueueForSquare150x150", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<bool>(args, 0);

                {
                    auto _gil = release_gil();
                    self->obj.EnableNotificationQueueForSquare150x150(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TileUpdater_EnableNotificationQueueForSquare310x310(py::wrapper::Windows::UI::Notifications::TileUpdater* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Notifications.TileUpdater", L"EnableNotificationQueueForSquare310x310", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<bool>(args, 0);

                {
                    auto _gil = release_gil();
                    self->obj.EnableNotificationQueueForSquare310x310(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TileUpdater_EnableNotificationQueueForWide310x150(py::wrapper::Windows::UI::Notifications::TileUpdater* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Notifications.TileUpdater", L"EnableNotificationQueueForWide310x150", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<bool>(args, 0);

                {
                    auto _gil = release_gil();
                    self->obj.EnableNotificationQueueForWide310x150(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TileUpdater_GetScheduledTileNotifications(py::wrapper::Windows::UI::Notifications::TileUpdater* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Notifications.TileUpdater", L"GetScheduledTileNotifications", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetScheduledTileNotifications();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TileUpdater_RemoveFromSchedule(py::wrapper::Windows::UI::Notifications::TileUpdater* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Notifications.TileUpdater", L"RemoveFromSchedule", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Notifications::ScheduledTileNotification>(args, 0);

                {
                    auto _gil = release_gil();
                    self->obj.RemoveFromSchedule(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TileUpdater_StartPeriodicUpdate(py::wrapper::Windows::UI::Notifications::TileUpdater* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Notifications.TileUpdater", L"StartPeriodicUpdate", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Notifications::PeriodicUpdateRecurrence>(args, 1);

                {
                    auto _gil = release_gil();
                    self->obj.StartPeriodicUpdate(param0, param1);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TileUpdater_StartPeriodicUpdateAtTime(py::wrapper::Windows::UI::Notifications::TileUpdater* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 3)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Notifications.TileUpdater", L"StartPeriodicUpdate", 3);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::DateTime>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::UI::Notifications::PeriodicUpdateRecurrence>(args, 2);

                {
                    auto _gil = release_gil();
                    self->obj.StartPeriodicUpdate(param0, param1, param2);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TileUpdater_StartPeriodicUpdateBatch(py::wrapper::Windows::UI::Notifications::TileUpdater* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Notifications.TileUpdater", L"StartPeriodicUpdateBatch", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Foundation::Uri>>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Notifications::PeriodicUpdateRecurrence>(args, 1);

                {
                    auto _gil = release_gil();
                    self->obj.StartPeriodicUpdateBatch(param0, param1);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TileUpdater_StartPeriodicUpdateBatchAtTime(py::wrapper::Windows::UI::Notifications::TileUpdater* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 3)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Notifications.TileUpdater", L"StartPeriodicUpdateBatch", 3);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Foundation::Uri>>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::DateTime>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::UI::Notifications::PeriodicUpdateRecurrence>(args, 2);

                {
                    auto _gil = release_gil();
                    self->obj.StartPeriodicUpdateBatch(param0, param1, param2);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TileUpdater_StopPeriodicUpdate(py::wrapper::Windows::UI::Notifications::TileUpdater* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Notifications.TileUpdater", L"StopPeriodicUpdate", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.StopPeriodicUpdate();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TileUpdater_Update(py::wrapper::Windows::UI::Notifications::TileUpdater* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Notifications.TileUpdater", L"Update", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Notifications::TileNotification>(args, 0);

                {
                    auto _gil = release_gil();
                    self->obj.Update(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TileUpdater_get_Setting(py::wrapper::Windows::UI::Notifications::TileUpdater* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.TileUpdater", L"Setting");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Setting();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_TileUpdater(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Notifications::TileUpdater>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_TileUpdater(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Notifications::TileUpdater>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TileUpdater[] = {
        { "add_to_schedule", reinterpret_cast<PyCFunction>(TileUpdater_AddToSchedule), METH_VARARGS, nullptr },
        { "clear", reinterpret_cast<PyCFunction>(TileUpdater_Clear), METH_VARARGS, nullptr },
        { "enable_notification_queue", reinterpret_cast<PyCFunction>(TileUpdater_EnableNotificationQueue), METH_VARARGS, nullptr },
        { "enable_notification_queue_for_square150x150", reinterpret_cast<PyCFunction>(TileUpdater_EnableNotificationQueueForSquare150x150), METH_VARARGS, nullptr },
        { "enable_notification_queue_for_square310x310", reinterpret_cast<PyCFunction>(TileUpdater_EnableNotificationQueueForSquare310x310), METH_VARARGS, nullptr },
        { "enable_notification_queue_for_wide310x150", reinterpret_cast<PyCFunction>(TileUpdater_EnableNotificationQueueForWide310x150), METH_VARARGS, nullptr },
        { "get_scheduled_tile_notifications", reinterpret_cast<PyCFunction>(TileUpdater_GetScheduledTileNotifications), METH_VARARGS, nullptr },
        { "remove_from_schedule", reinterpret_cast<PyCFunction>(TileUpdater_RemoveFromSchedule), METH_VARARGS, nullptr },
        { "start_periodic_update", reinterpret_cast<PyCFunction>(TileUpdater_StartPeriodicUpdate), METH_VARARGS, nullptr },
        { "start_periodic_update_at_time", reinterpret_cast<PyCFunction>(TileUpdater_StartPeriodicUpdateAtTime), METH_VARARGS, nullptr },
        { "start_periodic_update_batch", reinterpret_cast<PyCFunction>(TileUpdater_StartPeriodicUpdateBatch), METH_VARARGS, nullptr },
        { "start_periodic_update_batch_at_time", reinterpret_cast<PyCFunction>(TileUpdater_StartPeriodicUpdateBatchAtTime), METH_VARARGS, nullptr },
        { "stop_periodic_update", reinterpret_cast<PyCFunction>(TileUpdater_StopPeriodicUpdate), METH_VARARGS, nullptr },
        { "update", reinterpret_cast<PyCFunction>(TileUpdater_Update), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_TileUpdater, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_TileUpdater), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_TileUpdater[] = {
        { "setting", reinterpret_cast<getter>(TileUpdater_get_Setting), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_TileUpdater[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_TileUpdater) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_TileUpdater) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_TileUpdater) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_TileUpdater) },
        { }};

    static PyType_Spec type_spec_TileUpdater = {
        "winrt._winrt_windows_ui_notifications.TileUpdater",
        sizeof(py::wrapper::Windows::UI::Notifications::TileUpdater),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TileUpdater};

    // ----- ToastActivatedEventArgs class --------------------

    static PyObject* _new_ToastActivatedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Notifications::ToastActivatedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Notifications::ToastActivatedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_ToastActivatedEventArgs(py::wrapper::Windows::UI::Notifications::ToastActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ToastActivatedEventArgs_get_Arguments(py::wrapper::Windows::UI::Notifications::ToastActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.ToastActivatedEventArgs", L"Arguments");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Arguments();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ToastActivatedEventArgs_get_UserInput(py::wrapper::Windows::UI::Notifications::ToastActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.ToastActivatedEventArgs", L"UserInput");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.UserInput();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ToastActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Notifications::ToastActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ToastActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Notifications::ToastActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ToastActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_ToastActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ToastActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_ToastActivatedEventArgs[] = {
        { "arguments", reinterpret_cast<getter>(ToastActivatedEventArgs_get_Arguments), nullptr, nullptr, nullptr },
        { "user_input", reinterpret_cast<getter>(ToastActivatedEventArgs_get_UserInput), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_ToastActivatedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ToastActivatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ToastActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ToastActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ToastActivatedEventArgs) },
        { }};

    static PyType_Spec type_spec_ToastActivatedEventArgs = {
        "winrt._winrt_windows_ui_notifications.ToastActivatedEventArgs",
        sizeof(py::wrapper::Windows::UI::Notifications::ToastActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ToastActivatedEventArgs};

    // ----- ToastCollection class --------------------

    static PyObject* _new_ToastCollection(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);
        if (arg_count == 4)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::hstring>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 3);

                winrt::Windows::UI::Notifications::ToastCollection instance{param0, param1, param2, param3};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ToastCollection(py::wrapper::Windows::UI::Notifications::ToastCollection* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ToastCollection_get_LaunchArgs(py::wrapper::Windows::UI::Notifications::ToastCollection* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.ToastCollection", L"LaunchArgs");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.LaunchArgs();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ToastCollection_put_LaunchArgs(py::wrapper::Windows::UI::Notifications::ToastCollection* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.ToastCollection", L"LaunchArgs");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            {
                auto _gil = release_gil();
                self->obj.LaunchArgs(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ToastCollection_get_Icon(py::wrapper::Windows::UI::Notifications::ToastCollection* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.ToastCollection", L"Icon");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Icon();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ToastCollection_put_Icon(py::wrapper::Windows::UI::Notifications::ToastCollection* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.ToastCollection", L"Icon");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(arg);

            {
                auto _gil = release_gil();
                self->obj.Icon(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ToastCollection_get_DisplayName(py::wrapper::Windows::UI::Notifications::ToastCollection* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.ToastCollection", L"DisplayName");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.DisplayName();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ToastCollection_put_DisplayName(py::wrapper::Windows::UI::Notifications::ToastCollection* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.ToastCollection", L"DisplayName");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            {
                auto _gil = release_gil();
                self->obj.DisplayName(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ToastCollection_get_Id(py::wrapper::Windows::UI::Notifications::ToastCollection* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.ToastCollection", L"Id");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Id();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ToastCollection(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Notifications::ToastCollection>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ToastCollection(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Notifications::ToastCollection>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ToastCollection[] = {
        { "_assign_array_", _assign_array_ToastCollection, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ToastCollection), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_ToastCollection[] = {
        { "launch_args", reinterpret_cast<getter>(ToastCollection_get_LaunchArgs), reinterpret_cast<setter>(ToastCollection_put_LaunchArgs), nullptr, nullptr },
        { "icon", reinterpret_cast<getter>(ToastCollection_get_Icon), reinterpret_cast<setter>(ToastCollection_put_Icon), nullptr, nullptr },
        { "display_name", reinterpret_cast<getter>(ToastCollection_get_DisplayName), reinterpret_cast<setter>(ToastCollection_put_DisplayName), nullptr, nullptr },
        { "id", reinterpret_cast<getter>(ToastCollection_get_Id), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_ToastCollection[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ToastCollection) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ToastCollection) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ToastCollection) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ToastCollection) },
        { }};

    static PyType_Spec type_spec_ToastCollection = {
        "winrt._winrt_windows_ui_notifications.ToastCollection",
        sizeof(py::wrapper::Windows::UI::Notifications::ToastCollection),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ToastCollection};

    // ----- ToastCollectionManager class --------------------

    static PyObject* _new_ToastCollectionManager(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Notifications::ToastCollectionManager>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Notifications::ToastCollectionManager>::type_name);
        return nullptr;
    }

    static void _dealloc_ToastCollectionManager(py::wrapper::Windows::UI::Notifications::ToastCollectionManager* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ToastCollectionManager_FindAllToastCollectionsAsync(py::wrapper::Windows::UI::Notifications::ToastCollectionManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Notifications.ToastCollectionManager", L"FindAllToastCollectionsAsync", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.FindAllToastCollectionsAsync();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ToastCollectionManager_GetToastCollectionAsync(py::wrapper::Windows::UI::Notifications::ToastCollectionManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Notifications.ToastCollectionManager", L"GetToastCollectionAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetToastCollectionAsync(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ToastCollectionManager_RemoveAllToastCollectionsAsync(py::wrapper::Windows::UI::Notifications::ToastCollectionManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Notifications.ToastCollectionManager", L"RemoveAllToastCollectionsAsync", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.RemoveAllToastCollectionsAsync();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ToastCollectionManager_RemoveToastCollectionAsync(py::wrapper::Windows::UI::Notifications::ToastCollectionManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Notifications.ToastCollectionManager", L"RemoveToastCollectionAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.RemoveToastCollectionAsync(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ToastCollectionManager_SaveToastCollectionAsync(py::wrapper::Windows::UI::Notifications::ToastCollectionManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Notifications.ToastCollectionManager", L"SaveToastCollectionAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Notifications::ToastCollection>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.SaveToastCollectionAsync(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ToastCollectionManager_get_AppId(py::wrapper::Windows::UI::Notifications::ToastCollectionManager* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.ToastCollectionManager", L"AppId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.AppId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ToastCollectionManager_get_User(py::wrapper::Windows::UI::Notifications::ToastCollectionManager* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.ToastCollectionManager", L"User");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.User();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ToastCollectionManager(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Notifications::ToastCollectionManager>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ToastCollectionManager(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Notifications::ToastCollectionManager>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ToastCollectionManager[] = {
        { "find_all_toast_collections_async", reinterpret_cast<PyCFunction>(ToastCollectionManager_FindAllToastCollectionsAsync), METH_VARARGS, nullptr },
        { "get_toast_collection_async", reinterpret_cast<PyCFunction>(ToastCollectionManager_GetToastCollectionAsync), METH_VARARGS, nullptr },
        { "remove_all_toast_collections_async", reinterpret_cast<PyCFunction>(ToastCollectionManager_RemoveAllToastCollectionsAsync), METH_VARARGS, nullptr },
        { "remove_toast_collection_async", reinterpret_cast<PyCFunction>(ToastCollectionManager_RemoveToastCollectionAsync), METH_VARARGS, nullptr },
        { "save_toast_collection_async", reinterpret_cast<PyCFunction>(ToastCollectionManager_SaveToastCollectionAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_ToastCollectionManager, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ToastCollectionManager), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_ToastCollectionManager[] = {
        { "app_id", reinterpret_cast<getter>(ToastCollectionManager_get_AppId), nullptr, nullptr, nullptr },
        { "user", reinterpret_cast<getter>(ToastCollectionManager_get_User), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_ToastCollectionManager[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ToastCollectionManager) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ToastCollectionManager) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ToastCollectionManager) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ToastCollectionManager) },
        { }};

    static PyType_Spec type_spec_ToastCollectionManager = {
        "winrt._winrt_windows_ui_notifications.ToastCollectionManager",
        sizeof(py::wrapper::Windows::UI::Notifications::ToastCollectionManager),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ToastCollectionManager};

    // ----- ToastDismissedEventArgs class --------------------

    static PyObject* _new_ToastDismissedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Notifications::ToastDismissedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Notifications::ToastDismissedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_ToastDismissedEventArgs(py::wrapper::Windows::UI::Notifications::ToastDismissedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ToastDismissedEventArgs_get_Reason(py::wrapper::Windows::UI::Notifications::ToastDismissedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.ToastDismissedEventArgs", L"Reason");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Reason();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ToastDismissedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Notifications::ToastDismissedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ToastDismissedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Notifications::ToastDismissedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ToastDismissedEventArgs[] = {
        { "_assign_array_", _assign_array_ToastDismissedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ToastDismissedEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_ToastDismissedEventArgs[] = {
        { "reason", reinterpret_cast<getter>(ToastDismissedEventArgs_get_Reason), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_ToastDismissedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ToastDismissedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ToastDismissedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ToastDismissedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ToastDismissedEventArgs) },
        { }};

    static PyType_Spec type_spec_ToastDismissedEventArgs = {
        "winrt._winrt_windows_ui_notifications.ToastDismissedEventArgs",
        sizeof(py::wrapper::Windows::UI::Notifications::ToastDismissedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ToastDismissedEventArgs};

    // ----- ToastFailedEventArgs class --------------------

    static PyObject* _new_ToastFailedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Notifications::ToastFailedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Notifications::ToastFailedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_ToastFailedEventArgs(py::wrapper::Windows::UI::Notifications::ToastFailedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ToastFailedEventArgs_get_ErrorCode(py::wrapper::Windows::UI::Notifications::ToastFailedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.ToastFailedEventArgs", L"ErrorCode");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ErrorCode();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ToastFailedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Notifications::ToastFailedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ToastFailedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Notifications::ToastFailedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ToastFailedEventArgs[] = {
        { "_assign_array_", _assign_array_ToastFailedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ToastFailedEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_ToastFailedEventArgs[] = {
        { "error_code", reinterpret_cast<getter>(ToastFailedEventArgs_get_ErrorCode), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_ToastFailedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ToastFailedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ToastFailedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ToastFailedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ToastFailedEventArgs) },
        { }};

    static PyType_Spec type_spec_ToastFailedEventArgs = {
        "winrt._winrt_windows_ui_notifications.ToastFailedEventArgs",
        sizeof(py::wrapper::Windows::UI::Notifications::ToastFailedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ToastFailedEventArgs};

    // ----- ToastNotification class --------------------

    static PyObject* _new_ToastNotification(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Data::Xml::Dom::XmlDocument>(args, 0);

                winrt::Windows::UI::Notifications::ToastNotification instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ToastNotification(py::wrapper::Windows::UI::Notifications::ToastNotification* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ToastNotification_get_ExpirationTime(py::wrapper::Windows::UI::Notifications::ToastNotification* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.ToastNotification", L"ExpirationTime");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ExpirationTime();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ToastNotification_put_ExpirationTime(py::wrapper::Windows::UI::Notifications::ToastNotification* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.ToastNotification", L"ExpirationTime");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::DateTime>>(arg);

            {
                auto _gil = release_gil();
                self->obj.ExpirationTime(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ToastNotification_get_Content(py::wrapper::Windows::UI::Notifications::ToastNotification* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.ToastNotification", L"Content");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Content();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ToastNotification_get_Tag(py::wrapper::Windows::UI::Notifications::ToastNotification* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.ToastNotification", L"Tag");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Tag();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ToastNotification_put_Tag(py::wrapper::Windows::UI::Notifications::ToastNotification* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.ToastNotification", L"Tag");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            {
                auto _gil = release_gil();
                self->obj.Tag(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ToastNotification_get_SuppressPopup(py::wrapper::Windows::UI::Notifications::ToastNotification* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.ToastNotification", L"SuppressPopup");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SuppressPopup();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ToastNotification_put_SuppressPopup(py::wrapper::Windows::UI::Notifications::ToastNotification* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.ToastNotification", L"SuppressPopup");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.SuppressPopup(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ToastNotification_get_Group(py::wrapper::Windows::UI::Notifications::ToastNotification* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.ToastNotification", L"Group");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Group();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ToastNotification_put_Group(py::wrapper::Windows::UI::Notifications::ToastNotification* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.ToastNotification", L"Group");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            {
                auto _gil = release_gil();
                self->obj.Group(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ToastNotification_get_RemoteId(py::wrapper::Windows::UI::Notifications::ToastNotification* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.ToastNotification", L"RemoteId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.RemoteId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ToastNotification_put_RemoteId(py::wrapper::Windows::UI::Notifications::ToastNotification* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.ToastNotification", L"RemoteId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            {
                auto _gil = release_gil();
                self->obj.RemoteId(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ToastNotification_get_NotificationMirroring(py::wrapper::Windows::UI::Notifications::ToastNotification* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.ToastNotification", L"NotificationMirroring");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.NotificationMirroring();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ToastNotification_put_NotificationMirroring(py::wrapper::Windows::UI::Notifications::ToastNotification* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.ToastNotification", L"NotificationMirroring");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Notifications::NotificationMirroring>(arg);

            {
                auto _gil = release_gil();
                self->obj.NotificationMirroring(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ToastNotification_get_Priority(py::wrapper::Windows::UI::Notifications::ToastNotification* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.ToastNotification", L"Priority");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Priority();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ToastNotification_put_Priority(py::wrapper::Windows::UI::Notifications::ToastNotification* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.ToastNotification", L"Priority");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Notifications::ToastNotificationPriority>(arg);

            {
                auto _gil = release_gil();
                self->obj.Priority(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ToastNotification_get_Data(py::wrapper::Windows::UI::Notifications::ToastNotification* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.ToastNotification", L"Data");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Data();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ToastNotification_put_Data(py::wrapper::Windows::UI::Notifications::ToastNotification* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.ToastNotification", L"Data");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Notifications::NotificationData>(arg);

            {
                auto _gil = release_gil();
                self->obj.Data(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ToastNotification_get_ExpiresOnReboot(py::wrapper::Windows::UI::Notifications::ToastNotification* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.ToastNotification", L"ExpiresOnReboot");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ExpiresOnReboot();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ToastNotification_put_ExpiresOnReboot(py::wrapper::Windows::UI::Notifications::ToastNotification* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.ToastNotification", L"ExpiresOnReboot");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.ExpiresOnReboot(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ToastNotification_add_Activated(py::wrapper::Windows::UI::Notifications::ToastNotification* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Notifications.ToastNotification", L"Activated");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Notifications::ToastNotification, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Activated(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ToastNotification_remove_Activated(py::wrapper::Windows::UI::Notifications::ToastNotification* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Notifications.ToastNotification", L"Activated");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.Activated(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ToastNotification_add_Dismissed(py::wrapper::Windows::UI::Notifications::ToastNotification* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Notifications.ToastNotification", L"Dismissed");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Notifications::ToastNotification, winrt::Windows::UI::Notifications::ToastDismissedEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Dismissed(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ToastNotification_remove_Dismissed(py::wrapper::Windows::UI::Notifications::ToastNotification* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Notifications.ToastNotification", L"Dismissed");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.Dismissed(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ToastNotification_add_Failed(py::wrapper::Windows::UI::Notifications::ToastNotification* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Notifications.ToastNotification", L"Failed");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Notifications::ToastNotification, winrt::Windows::UI::Notifications::ToastFailedEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Failed(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ToastNotification_remove_Failed(py::wrapper::Windows::UI::Notifications::ToastNotification* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Notifications.ToastNotification", L"Failed");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.Failed(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ToastNotification(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Notifications::ToastNotification>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ToastNotification(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Notifications::ToastNotification>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ToastNotification[] = {
        { "add_activated", reinterpret_cast<PyCFunction>(ToastNotification_add_Activated), METH_O, nullptr },
        { "remove_activated", reinterpret_cast<PyCFunction>(ToastNotification_remove_Activated), METH_O, nullptr },
        { "add_dismissed", reinterpret_cast<PyCFunction>(ToastNotification_add_Dismissed), METH_O, nullptr },
        { "remove_dismissed", reinterpret_cast<PyCFunction>(ToastNotification_remove_Dismissed), METH_O, nullptr },
        { "add_failed", reinterpret_cast<PyCFunction>(ToastNotification_add_Failed), METH_O, nullptr },
        { "remove_failed", reinterpret_cast<PyCFunction>(ToastNotification_remove_Failed), METH_O, nullptr },
        { "_assign_array_", _assign_array_ToastNotification, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ToastNotification), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_ToastNotification[] = {
        { "expiration_time", reinterpret_cast<getter>(ToastNotification_get_ExpirationTime), reinterpret_cast<setter>(ToastNotification_put_ExpirationTime), nullptr, nullptr },
        { "content", reinterpret_cast<getter>(ToastNotification_get_Content), nullptr, nullptr, nullptr },
        { "tag", reinterpret_cast<getter>(ToastNotification_get_Tag), reinterpret_cast<setter>(ToastNotification_put_Tag), nullptr, nullptr },
        { "suppress_popup", reinterpret_cast<getter>(ToastNotification_get_SuppressPopup), reinterpret_cast<setter>(ToastNotification_put_SuppressPopup), nullptr, nullptr },
        { "group", reinterpret_cast<getter>(ToastNotification_get_Group), reinterpret_cast<setter>(ToastNotification_put_Group), nullptr, nullptr },
        { "remote_id", reinterpret_cast<getter>(ToastNotification_get_RemoteId), reinterpret_cast<setter>(ToastNotification_put_RemoteId), nullptr, nullptr },
        { "notification_mirroring", reinterpret_cast<getter>(ToastNotification_get_NotificationMirroring), reinterpret_cast<setter>(ToastNotification_put_NotificationMirroring), nullptr, nullptr },
        { "priority", reinterpret_cast<getter>(ToastNotification_get_Priority), reinterpret_cast<setter>(ToastNotification_put_Priority), nullptr, nullptr },
        { "data", reinterpret_cast<getter>(ToastNotification_get_Data), reinterpret_cast<setter>(ToastNotification_put_Data), nullptr, nullptr },
        { "expires_on_reboot", reinterpret_cast<getter>(ToastNotification_get_ExpiresOnReboot), reinterpret_cast<setter>(ToastNotification_put_ExpiresOnReboot), nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_ToastNotification[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ToastNotification) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ToastNotification) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ToastNotification) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ToastNotification) },
        { }};

    static PyType_Spec type_spec_ToastNotification = {
        "winrt._winrt_windows_ui_notifications.ToastNotification",
        sizeof(py::wrapper::Windows::UI::Notifications::ToastNotification),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ToastNotification};

    // ----- ToastNotificationActionTriggerDetail class --------------------

    static PyObject* _new_ToastNotificationActionTriggerDetail(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Notifications::ToastNotificationActionTriggerDetail>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Notifications::ToastNotificationActionTriggerDetail>::type_name);
        return nullptr;
    }

    static void _dealloc_ToastNotificationActionTriggerDetail(py::wrapper::Windows::UI::Notifications::ToastNotificationActionTriggerDetail* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ToastNotificationActionTriggerDetail_get_Argument(py::wrapper::Windows::UI::Notifications::ToastNotificationActionTriggerDetail* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.ToastNotificationActionTriggerDetail", L"Argument");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Argument();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ToastNotificationActionTriggerDetail_get_UserInput(py::wrapper::Windows::UI::Notifications::ToastNotificationActionTriggerDetail* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.ToastNotificationActionTriggerDetail", L"UserInput");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.UserInput();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ToastNotificationActionTriggerDetail(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Notifications::ToastNotificationActionTriggerDetail>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ToastNotificationActionTriggerDetail(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Notifications::ToastNotificationActionTriggerDetail>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ToastNotificationActionTriggerDetail[] = {
        { "_assign_array_", _assign_array_ToastNotificationActionTriggerDetail, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ToastNotificationActionTriggerDetail), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_ToastNotificationActionTriggerDetail[] = {
        { "argument", reinterpret_cast<getter>(ToastNotificationActionTriggerDetail_get_Argument), nullptr, nullptr, nullptr },
        { "user_input", reinterpret_cast<getter>(ToastNotificationActionTriggerDetail_get_UserInput), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_ToastNotificationActionTriggerDetail[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ToastNotificationActionTriggerDetail) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ToastNotificationActionTriggerDetail) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ToastNotificationActionTriggerDetail) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ToastNotificationActionTriggerDetail) },
        { }};

    static PyType_Spec type_spec_ToastNotificationActionTriggerDetail = {
        "winrt._winrt_windows_ui_notifications.ToastNotificationActionTriggerDetail",
        sizeof(py::wrapper::Windows::UI::Notifications::ToastNotificationActionTriggerDetail),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ToastNotificationActionTriggerDetail};

    // ----- ToastNotificationHistory class --------------------

    static PyObject* _new_ToastNotificationHistory(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Notifications::ToastNotificationHistory>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Notifications::ToastNotificationHistory>::type_name);
        return nullptr;
    }

    static void _dealloc_ToastNotificationHistory(py::wrapper::Windows::UI::Notifications::ToastNotificationHistory* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ToastNotificationHistory_Clear(py::wrapper::Windows::UI::Notifications::ToastNotificationHistory* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Notifications.ToastNotificationHistory", L"Clear", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.Clear();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ToastNotificationHistory_ClearWithId(py::wrapper::Windows::UI::Notifications::ToastNotificationHistory* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Notifications.ToastNotificationHistory", L"Clear", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                {
                    auto _gil = release_gil();
                    self->obj.Clear(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ToastNotificationHistory_GetHistory(py::wrapper::Windows::UI::Notifications::ToastNotificationHistory* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Notifications.ToastNotificationHistory", L"GetHistory", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetHistory();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ToastNotificationHistory_GetHistoryWithId(py::wrapper::Windows::UI::Notifications::ToastNotificationHistory* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Notifications.ToastNotificationHistory", L"GetHistory", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetHistory(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ToastNotificationHistory_Remove(py::wrapper::Windows::UI::Notifications::ToastNotificationHistory* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Notifications.ToastNotificationHistory", L"Remove", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                {
                    auto _gil = release_gil();
                    self->obj.Remove(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ToastNotificationHistory_RemoveGroup(py::wrapper::Windows::UI::Notifications::ToastNotificationHistory* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Notifications.ToastNotificationHistory", L"RemoveGroup", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                {
                    auto _gil = release_gil();
                    self->obj.RemoveGroup(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ToastNotificationHistory_RemoveGroupWithId(py::wrapper::Windows::UI::Notifications::ToastNotificationHistory* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Notifications.ToastNotificationHistory", L"RemoveGroup", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                {
                    auto _gil = release_gil();
                    self->obj.RemoveGroup(param0, param1);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ToastNotificationHistory_RemoveGroupedTag(py::wrapper::Windows::UI::Notifications::ToastNotificationHistory* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Notifications.ToastNotificationHistory", L"Remove", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                {
                    auto _gil = release_gil();
                    self->obj.Remove(param0, param1);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ToastNotificationHistory_RemoveGroupedTagWithId(py::wrapper::Windows::UI::Notifications::ToastNotificationHistory* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 3)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Notifications.ToastNotificationHistory", L"Remove", 3);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::hstring>(args, 2);

                {
                    auto _gil = release_gil();
                    self->obj.Remove(param0, param1, param2);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_ToastNotificationHistory(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Notifications::ToastNotificationHistory>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ToastNotificationHistory(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Notifications::ToastNotificationHistory>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ToastNotificationHistory[] = {
        { "clear", reinterpret_cast<PyCFunction>(ToastNotificationHistory_Clear), METH_VARARGS, nullptr },
        { "clear_with_id", reinterpret_cast<PyCFunction>(ToastNotificationHistory_ClearWithId), METH_VARARGS, nullptr },
        { "get_history", reinterpret_cast<PyCFunction>(ToastNotificationHistory_GetHistory), METH_VARARGS, nullptr },
        { "get_history_with_id", reinterpret_cast<PyCFunction>(ToastNotificationHistory_GetHistoryWithId), METH_VARARGS, nullptr },
        { "remove", reinterpret_cast<PyCFunction>(ToastNotificationHistory_Remove), METH_VARARGS, nullptr },
        { "remove_group", reinterpret_cast<PyCFunction>(ToastNotificationHistory_RemoveGroup), METH_VARARGS, nullptr },
        { "remove_group_with_id", reinterpret_cast<PyCFunction>(ToastNotificationHistory_RemoveGroupWithId), METH_VARARGS, nullptr },
        { "remove_grouped_tag", reinterpret_cast<PyCFunction>(ToastNotificationHistory_RemoveGroupedTag), METH_VARARGS, nullptr },
        { "remove_grouped_tag_with_id", reinterpret_cast<PyCFunction>(ToastNotificationHistory_RemoveGroupedTagWithId), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_ToastNotificationHistory, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ToastNotificationHistory), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_ToastNotificationHistory[] = {
        { }};

    static PyType_Slot _type_slots_ToastNotificationHistory[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ToastNotificationHistory) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ToastNotificationHistory) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ToastNotificationHistory) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ToastNotificationHistory) },
        { }};

    static PyType_Spec type_spec_ToastNotificationHistory = {
        "winrt._winrt_windows_ui_notifications.ToastNotificationHistory",
        sizeof(py::wrapper::Windows::UI::Notifications::ToastNotificationHistory),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ToastNotificationHistory};

    // ----- ToastNotificationHistoryChangedTriggerDetail class --------------------

    static PyObject* _new_ToastNotificationHistoryChangedTriggerDetail(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Notifications::ToastNotificationHistoryChangedTriggerDetail>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Notifications::ToastNotificationHistoryChangedTriggerDetail>::type_name);
        return nullptr;
    }

    static void _dealloc_ToastNotificationHistoryChangedTriggerDetail(py::wrapper::Windows::UI::Notifications::ToastNotificationHistoryChangedTriggerDetail* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ToastNotificationHistoryChangedTriggerDetail_get_ChangeType(py::wrapper::Windows::UI::Notifications::ToastNotificationHistoryChangedTriggerDetail* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.ToastNotificationHistoryChangedTriggerDetail", L"ChangeType");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ChangeType();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ToastNotificationHistoryChangedTriggerDetail_get_CollectionId(py::wrapper::Windows::UI::Notifications::ToastNotificationHistoryChangedTriggerDetail* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.ToastNotificationHistoryChangedTriggerDetail", L"CollectionId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.CollectionId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ToastNotificationHistoryChangedTriggerDetail(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Notifications::ToastNotificationHistoryChangedTriggerDetail>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ToastNotificationHistoryChangedTriggerDetail(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Notifications::ToastNotificationHistoryChangedTriggerDetail>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ToastNotificationHistoryChangedTriggerDetail[] = {
        { "_assign_array_", _assign_array_ToastNotificationHistoryChangedTriggerDetail, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ToastNotificationHistoryChangedTriggerDetail), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_ToastNotificationHistoryChangedTriggerDetail[] = {
        { "change_type", reinterpret_cast<getter>(ToastNotificationHistoryChangedTriggerDetail_get_ChangeType), nullptr, nullptr, nullptr },
        { "collection_id", reinterpret_cast<getter>(ToastNotificationHistoryChangedTriggerDetail_get_CollectionId), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_ToastNotificationHistoryChangedTriggerDetail[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ToastNotificationHistoryChangedTriggerDetail) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ToastNotificationHistoryChangedTriggerDetail) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ToastNotificationHistoryChangedTriggerDetail) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ToastNotificationHistoryChangedTriggerDetail) },
        { }};

    static PyType_Spec type_spec_ToastNotificationHistoryChangedTriggerDetail = {
        "winrt._winrt_windows_ui_notifications.ToastNotificationHistoryChangedTriggerDetail",
        sizeof(py::wrapper::Windows::UI::Notifications::ToastNotificationHistoryChangedTriggerDetail),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ToastNotificationHistoryChangedTriggerDetail};

    // ----- ToastNotificationManager class --------------------

    static PyObject* _new_ToastNotificationManager(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Notifications::ToastNotificationManager>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Notifications::ToastNotificationManager>::type_name);
        return nullptr;
    }

    static PyObject* ToastNotificationManager_ConfigureNotificationMirroring(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Notifications.ToastNotificationManager", L"ConfigureNotificationMirroring", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Notifications::NotificationMirroring>(args, 0);

                {
                    auto _gil = release_gil();
                    winrt::Windows::UI::Notifications::ToastNotificationManager::ConfigureNotificationMirroring(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ToastNotificationManager_CreateToastNotifier(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Notifications.ToastNotificationManager", L"CreateToastNotifier", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::UI::Notifications::ToastNotificationManager::CreateToastNotifier();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ToastNotificationManager_CreateToastNotifierWithId(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Notifications.ToastNotificationManager", L"CreateToastNotifier", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::UI::Notifications::ToastNotificationManager::CreateToastNotifier(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ToastNotificationManager_GetDefault(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Notifications.ToastNotificationManager", L"GetDefault", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::UI::Notifications::ToastNotificationManager::GetDefault();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ToastNotificationManager_GetForUser(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Notifications.ToastNotificationManager", L"GetForUser", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::System::User>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::UI::Notifications::ToastNotificationManager::GetForUser(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ToastNotificationManager_GetTemplateContent(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Notifications.ToastNotificationManager", L"GetTemplateContent", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Notifications::ToastTemplateType>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::UI::Notifications::ToastNotificationManager::GetTemplateContent(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ToastNotificationManager_get_History(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.ToastNotificationManager", L"History");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::UI::Notifications::ToastNotificationManager::History();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ToastNotificationManager[] = {
        { }};

    static PyGetSetDef _getset_ToastNotificationManager[] = {
        { }};

    static PyType_Slot _type_slots_ToastNotificationManager[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ToastNotificationManager) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ToastNotificationManager) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ToastNotificationManager) },
        { }};

    static PyType_Spec type_spec_ToastNotificationManager = {
        "winrt._winrt_windows_ui_notifications.ToastNotificationManager",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ToastNotificationManager};

    static PyGetSetDef getset_ToastNotificationManager_Static[] = {
        { "history", reinterpret_cast<getter>(ToastNotificationManager_get_History), nullptr, nullptr, nullptr },
        { }};

    static PyMethodDef methods_ToastNotificationManager_Static[] = {
        { "configure_notification_mirroring", reinterpret_cast<PyCFunction>(ToastNotificationManager_ConfigureNotificationMirroring), METH_VARARGS, nullptr },
        { "create_toast_notifier", reinterpret_cast<PyCFunction>(ToastNotificationManager_CreateToastNotifier), METH_VARARGS, nullptr },
        { "create_toast_notifier_with_id", reinterpret_cast<PyCFunction>(ToastNotificationManager_CreateToastNotifierWithId), METH_VARARGS, nullptr },
        { "get_default", reinterpret_cast<PyCFunction>(ToastNotificationManager_GetDefault), METH_VARARGS, nullptr },
        { "get_for_user", reinterpret_cast<PyCFunction>(ToastNotificationManager_GetForUser), METH_VARARGS, nullptr },
        { "get_template_content", reinterpret_cast<PyCFunction>(ToastNotificationManager_GetTemplateContent), METH_VARARGS, nullptr },
        { }};

    static PyType_Slot type_slots_ToastNotificationManager_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_ToastNotificationManager_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_ToastNotificationManager_Static) },
        { }
    };

    static PyType_Spec type_spec_ToastNotificationManager_Static = {
        "winrt._winrt_windows_ui_notifications.ToastNotificationManager_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_ToastNotificationManager_Static};

    // ----- ToastNotificationManagerForUser class --------------------

    static PyObject* _new_ToastNotificationManagerForUser(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Notifications::ToastNotificationManagerForUser>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Notifications::ToastNotificationManagerForUser>::type_name);
        return nullptr;
    }

    static void _dealloc_ToastNotificationManagerForUser(py::wrapper::Windows::UI::Notifications::ToastNotificationManagerForUser* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ToastNotificationManagerForUser_CreateToastNotifier(py::wrapper::Windows::UI::Notifications::ToastNotificationManagerForUser* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Notifications.ToastNotificationManagerForUser", L"CreateToastNotifier", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.CreateToastNotifier();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ToastNotificationManagerForUser_CreateToastNotifierWithId(py::wrapper::Windows::UI::Notifications::ToastNotificationManagerForUser* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Notifications.ToastNotificationManagerForUser", L"CreateToastNotifier", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.CreateToastNotifier(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ToastNotificationManagerForUser_GetHistoryForToastCollectionIdAsync(py::wrapper::Windows::UI::Notifications::ToastNotificationManagerForUser* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Notifications.ToastNotificationManagerForUser", L"GetHistoryForToastCollectionIdAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetHistoryForToastCollectionIdAsync(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ToastNotificationManagerForUser_GetToastCollectionManager(py::wrapper::Windows::UI::Notifications::ToastNotificationManagerForUser* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Notifications.ToastNotificationManagerForUser", L"GetToastCollectionManager", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetToastCollectionManager();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ToastNotificationManagerForUser_GetToastCollectionManagerWithAppId(py::wrapper::Windows::UI::Notifications::ToastNotificationManagerForUser* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Notifications.ToastNotificationManagerForUser", L"GetToastCollectionManager", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetToastCollectionManager(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ToastNotificationManagerForUser_GetToastNotifierForToastCollectionIdAsync(py::wrapper::Windows::UI::Notifications::ToastNotificationManagerForUser* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Notifications.ToastNotificationManagerForUser", L"GetToastNotifierForToastCollectionIdAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetToastNotifierForToastCollectionIdAsync(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ToastNotificationManagerForUser_get_History(py::wrapper::Windows::UI::Notifications::ToastNotificationManagerForUser* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.ToastNotificationManagerForUser", L"History");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.History();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ToastNotificationManagerForUser_get_User(py::wrapper::Windows::UI::Notifications::ToastNotificationManagerForUser* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.ToastNotificationManagerForUser", L"User");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.User();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ToastNotificationManagerForUser_get_NotificationMode(py::wrapper::Windows::UI::Notifications::ToastNotificationManagerForUser* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.ToastNotificationManagerForUser", L"NotificationMode");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.NotificationMode();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ToastNotificationManagerForUser_add_NotificationModeChanged(py::wrapper::Windows::UI::Notifications::ToastNotificationManagerForUser* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Notifications.ToastNotificationManagerForUser", L"NotificationModeChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Notifications::ToastNotificationManagerForUser, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.NotificationModeChanged(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ToastNotificationManagerForUser_remove_NotificationModeChanged(py::wrapper::Windows::UI::Notifications::ToastNotificationManagerForUser* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Notifications.ToastNotificationManagerForUser", L"NotificationModeChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.NotificationModeChanged(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ToastNotificationManagerForUser(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Notifications::ToastNotificationManagerForUser>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ToastNotificationManagerForUser(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Notifications::ToastNotificationManagerForUser>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ToastNotificationManagerForUser[] = {
        { "create_toast_notifier", reinterpret_cast<PyCFunction>(ToastNotificationManagerForUser_CreateToastNotifier), METH_VARARGS, nullptr },
        { "create_toast_notifier_with_id", reinterpret_cast<PyCFunction>(ToastNotificationManagerForUser_CreateToastNotifierWithId), METH_VARARGS, nullptr },
        { "get_history_for_toast_collection_id_async", reinterpret_cast<PyCFunction>(ToastNotificationManagerForUser_GetHistoryForToastCollectionIdAsync), METH_VARARGS, nullptr },
        { "get_toast_collection_manager", reinterpret_cast<PyCFunction>(ToastNotificationManagerForUser_GetToastCollectionManager), METH_VARARGS, nullptr },
        { "get_toast_collection_manager_with_app_id", reinterpret_cast<PyCFunction>(ToastNotificationManagerForUser_GetToastCollectionManagerWithAppId), METH_VARARGS, nullptr },
        { "get_toast_notifier_for_toast_collection_id_async", reinterpret_cast<PyCFunction>(ToastNotificationManagerForUser_GetToastNotifierForToastCollectionIdAsync), METH_VARARGS, nullptr },
        { "add_notification_mode_changed", reinterpret_cast<PyCFunction>(ToastNotificationManagerForUser_add_NotificationModeChanged), METH_O, nullptr },
        { "remove_notification_mode_changed", reinterpret_cast<PyCFunction>(ToastNotificationManagerForUser_remove_NotificationModeChanged), METH_O, nullptr },
        { "_assign_array_", _assign_array_ToastNotificationManagerForUser, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ToastNotificationManagerForUser), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_ToastNotificationManagerForUser[] = {
        { "history", reinterpret_cast<getter>(ToastNotificationManagerForUser_get_History), nullptr, nullptr, nullptr },
        { "user", reinterpret_cast<getter>(ToastNotificationManagerForUser_get_User), nullptr, nullptr, nullptr },
        { "notification_mode", reinterpret_cast<getter>(ToastNotificationManagerForUser_get_NotificationMode), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_ToastNotificationManagerForUser[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ToastNotificationManagerForUser) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ToastNotificationManagerForUser) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ToastNotificationManagerForUser) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ToastNotificationManagerForUser) },
        { }};

    static PyType_Spec type_spec_ToastNotificationManagerForUser = {
        "winrt._winrt_windows_ui_notifications.ToastNotificationManagerForUser",
        sizeof(py::wrapper::Windows::UI::Notifications::ToastNotificationManagerForUser),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ToastNotificationManagerForUser};

    // ----- ToastNotifier class --------------------

    static PyObject* _new_ToastNotifier(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Notifications::ToastNotifier>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Notifications::ToastNotifier>::type_name);
        return nullptr;
    }

    static void _dealloc_ToastNotifier(py::wrapper::Windows::UI::Notifications::ToastNotifier* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ToastNotifier_AddToSchedule(py::wrapper::Windows::UI::Notifications::ToastNotifier* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Notifications.ToastNotifier", L"AddToSchedule", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Notifications::ScheduledToastNotification>(args, 0);

                {
                    auto _gil = release_gil();
                    self->obj.AddToSchedule(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ToastNotifier_GetScheduledToastNotifications(py::wrapper::Windows::UI::Notifications::ToastNotifier* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Notifications.ToastNotifier", L"GetScheduledToastNotifications", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetScheduledToastNotifications();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ToastNotifier_Hide(py::wrapper::Windows::UI::Notifications::ToastNotifier* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Notifications.ToastNotifier", L"Hide", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Notifications::ToastNotification>(args, 0);

                {
                    auto _gil = release_gil();
                    self->obj.Hide(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ToastNotifier_RemoveFromSchedule(py::wrapper::Windows::UI::Notifications::ToastNotifier* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Notifications.ToastNotifier", L"RemoveFromSchedule", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Notifications::ScheduledToastNotification>(args, 0);

                {
                    auto _gil = release_gil();
                    self->obj.RemoveFromSchedule(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ToastNotifier_Show(py::wrapper::Windows::UI::Notifications::ToastNotifier* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Notifications.ToastNotifier", L"Show", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Notifications::ToastNotification>(args, 0);

                {
                    auto _gil = release_gil();
                    self->obj.Show(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ToastNotifier_UpdateWithTag(py::wrapper::Windows::UI::Notifications::ToastNotifier* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Notifications.ToastNotifier", L"Update", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Notifications::NotificationData>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.Update(param0, param1);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ToastNotifier_UpdateWithTagAndGroup(py::wrapper::Windows::UI::Notifications::ToastNotifier* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 3)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Notifications.ToastNotifier", L"Update", 3);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Notifications::NotificationData>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::hstring>(args, 2);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.Update(param0, param1, param2);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ToastNotifier_get_Setting(py::wrapper::Windows::UI::Notifications::ToastNotifier* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.ToastNotifier", L"Setting");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Setting();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ToastNotifier_add_ScheduledToastNotificationShowing(py::wrapper::Windows::UI::Notifications::ToastNotifier* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Notifications.ToastNotifier", L"ScheduledToastNotificationShowing");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Notifications::ToastNotifier, winrt::Windows::UI::Notifications::ScheduledToastNotificationShowingEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ScheduledToastNotificationShowing(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ToastNotifier_remove_ScheduledToastNotificationShowing(py::wrapper::Windows::UI::Notifications::ToastNotifier* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Notifications.ToastNotifier", L"ScheduledToastNotificationShowing");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.ScheduledToastNotificationShowing(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ToastNotifier(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Notifications::ToastNotifier>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ToastNotifier(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Notifications::ToastNotifier>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ToastNotifier[] = {
        { "add_to_schedule", reinterpret_cast<PyCFunction>(ToastNotifier_AddToSchedule), METH_VARARGS, nullptr },
        { "get_scheduled_toast_notifications", reinterpret_cast<PyCFunction>(ToastNotifier_GetScheduledToastNotifications), METH_VARARGS, nullptr },
        { "hide", reinterpret_cast<PyCFunction>(ToastNotifier_Hide), METH_VARARGS, nullptr },
        { "remove_from_schedule", reinterpret_cast<PyCFunction>(ToastNotifier_RemoveFromSchedule), METH_VARARGS, nullptr },
        { "show", reinterpret_cast<PyCFunction>(ToastNotifier_Show), METH_VARARGS, nullptr },
        { "update_with_tag", reinterpret_cast<PyCFunction>(ToastNotifier_UpdateWithTag), METH_VARARGS, nullptr },
        { "update_with_tag_and_group", reinterpret_cast<PyCFunction>(ToastNotifier_UpdateWithTagAndGroup), METH_VARARGS, nullptr },
        { "add_scheduled_toast_notification_showing", reinterpret_cast<PyCFunction>(ToastNotifier_add_ScheduledToastNotificationShowing), METH_O, nullptr },
        { "remove_scheduled_toast_notification_showing", reinterpret_cast<PyCFunction>(ToastNotifier_remove_ScheduledToastNotificationShowing), METH_O, nullptr },
        { "_assign_array_", _assign_array_ToastNotifier, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ToastNotifier), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_ToastNotifier[] = {
        { "setting", reinterpret_cast<getter>(ToastNotifier_get_Setting), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_ToastNotifier[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ToastNotifier) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ToastNotifier) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ToastNotifier) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ToastNotifier) },
        { }};

    static PyType_Spec type_spec_ToastNotifier = {
        "winrt._winrt_windows_ui_notifications.ToastNotifier",
        sizeof(py::wrapper::Windows::UI::Notifications::ToastNotifier),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ToastNotifier};

    // ----- UserNotification class --------------------

    static PyObject* _new_UserNotification(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Notifications::UserNotification>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Notifications::UserNotification>::type_name);
        return nullptr;
    }

    static void _dealloc_UserNotification(py::wrapper::Windows::UI::Notifications::UserNotification* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* UserNotification_get_AppInfo(py::wrapper::Windows::UI::Notifications::UserNotification* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.UserNotification", L"AppInfo");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.AppInfo();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UserNotification_get_CreationTime(py::wrapper::Windows::UI::Notifications::UserNotification* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.UserNotification", L"CreationTime");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.CreationTime();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UserNotification_get_Id(py::wrapper::Windows::UI::Notifications::UserNotification* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.UserNotification", L"Id");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Id();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UserNotification_get_Notification(py::wrapper::Windows::UI::Notifications::UserNotification* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.UserNotification", L"Notification");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Notification();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_UserNotification(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Notifications::UserNotification>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_UserNotification(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Notifications::UserNotification>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_UserNotification[] = {
        { "_assign_array_", _assign_array_UserNotification, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_UserNotification), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_UserNotification[] = {
        { "app_info", reinterpret_cast<getter>(UserNotification_get_AppInfo), nullptr, nullptr, nullptr },
        { "creation_time", reinterpret_cast<getter>(UserNotification_get_CreationTime), nullptr, nullptr, nullptr },
        { "id", reinterpret_cast<getter>(UserNotification_get_Id), nullptr, nullptr, nullptr },
        { "notification", reinterpret_cast<getter>(UserNotification_get_Notification), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_UserNotification[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_UserNotification) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_UserNotification) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_UserNotification) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_UserNotification) },
        { }};

    static PyType_Spec type_spec_UserNotification = {
        "winrt._winrt_windows_ui_notifications.UserNotification",
        sizeof(py::wrapper::Windows::UI::Notifications::UserNotification),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_UserNotification};

    // ----- UserNotificationChangedEventArgs class --------------------

    static PyObject* _new_UserNotificationChangedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Notifications::UserNotificationChangedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Notifications::UserNotificationChangedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_UserNotificationChangedEventArgs(py::wrapper::Windows::UI::Notifications::UserNotificationChangedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* UserNotificationChangedEventArgs_get_ChangeKind(py::wrapper::Windows::UI::Notifications::UserNotificationChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.UserNotificationChangedEventArgs", L"ChangeKind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ChangeKind();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UserNotificationChangedEventArgs_get_UserNotificationId(py::wrapper::Windows::UI::Notifications::UserNotificationChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.UserNotificationChangedEventArgs", L"UserNotificationId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.UserNotificationId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_UserNotificationChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Notifications::UserNotificationChangedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_UserNotificationChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Notifications::UserNotificationChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_UserNotificationChangedEventArgs[] = {
        { "_assign_array_", _assign_array_UserNotificationChangedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_UserNotificationChangedEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_UserNotificationChangedEventArgs[] = {
        { "change_kind", reinterpret_cast<getter>(UserNotificationChangedEventArgs_get_ChangeKind), nullptr, nullptr, nullptr },
        { "user_notification_id", reinterpret_cast<getter>(UserNotificationChangedEventArgs_get_UserNotificationId), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_UserNotificationChangedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_UserNotificationChangedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_UserNotificationChangedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_UserNotificationChangedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_UserNotificationChangedEventArgs) },
        { }};

    static PyType_Spec type_spec_UserNotificationChangedEventArgs = {
        "winrt._winrt_windows_ui_notifications.UserNotificationChangedEventArgs",
        sizeof(py::wrapper::Windows::UI::Notifications::UserNotificationChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_UserNotificationChangedEventArgs};

    // ----- IAdaptiveNotificationContent interface --------------------

    #if PY_VERSION_HEX < 0x030A0000
    static PyObject* _new_IAdaptiveNotificationContent(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Notifications::IAdaptiveNotificationContent>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Notifications::IAdaptiveNotificationContent>::type_name);
        return nullptr;
    }
    #endif

    static void _dealloc_IAdaptiveNotificationContent(py::wrapper::Windows::UI::Notifications::IAdaptiveNotificationContent* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IAdaptiveNotificationContent_get_Hints(py::wrapper::Windows::UI::Notifications::IAdaptiveNotificationContent* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.IAdaptiveNotificationContent", L"Hints");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Hints();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IAdaptiveNotificationContent_get_Kind(py::wrapper::Windows::UI::Notifications::IAdaptiveNotificationContent* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.IAdaptiveNotificationContent", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Kind();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IAdaptiveNotificationContent[] = {
        { }};

    static PyGetSetDef _getset_IAdaptiveNotificationContent[] = {
        { "hints", reinterpret_cast<getter>(IAdaptiveNotificationContent_get_Hints), nullptr, nullptr, nullptr },
        { "kind", reinterpret_cast<getter>(IAdaptiveNotificationContent_get_Kind), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_IAdaptiveNotificationContent[] = {
        #if PY_VERSION_HEX < 0x030A0000
        { Py_tp_new, reinterpret_cast<void*>(_new_IAdaptiveNotificationContent) },
        #endif
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IAdaptiveNotificationContent) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IAdaptiveNotificationContent) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IAdaptiveNotificationContent) },
        { }};

    static PyType_Spec type_spec_IAdaptiveNotificationContent = {
        "winrt._winrt_windows_ui_notifications._IAdaptiveNotificationContent",
        sizeof(py::wrapper::Windows::UI::Notifications::IAdaptiveNotificationContent),
        0,
        Py_TPFLAGS_DEFAULT
        #if PY_VERSION_HEX >= 0x030A0000
        | Py_TPFLAGS_DISALLOW_INSTANTIATION
        #endif
        ,
        _type_slots_IAdaptiveNotificationContent};

    struct ImplementsIAdaptiveNotificationContent : py::ImplementsInterfaceT<ImplementsIAdaptiveNotificationContent, winrt::Windows::UI::Notifications::IAdaptiveNotificationContent>
    {
        ImplementsIAdaptiveNotificationContent() = delete;
        ImplementsIAdaptiveNotificationContent(PyObject* py_obj, winrt::impl::inspectable_abi* runtime_class) : py::ImplementsInterfaceT<ImplementsIAdaptiveNotificationContent, winrt::Windows::UI::Notifications::IAdaptiveNotificationContent>(py_obj, runtime_class)
        {
        }

        auto Hints()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "hints")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Foundation::Collections::IMap<winrt::hstring, winrt::hstring>>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto Kind()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "kind")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::UI::Notifications::AdaptiveNotificationContentKind>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }
    };

    static PyObject* _assign_array_IAdaptiveNotificationContent(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Notifications::IAdaptiveNotificationContent>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IAdaptiveNotificationContent(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Notifications::IAdaptiveNotificationContent>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _guid_ImplementsIAdaptiveNotificationContent(PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::guid_of<winrt::Windows::UI::Notifications::IAdaptiveNotificationContent>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _make_ImplementsIAdaptiveNotificationContent(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            PyObject* py_obj;
            winrt::impl::inspectable_abi* runtime_class;

            if (!PyArg_ParseTuple(args, "On", &py_obj, &runtime_class))
            {
                return nullptr;
            }

            auto iface{std::make_unique<ImplementsIAdaptiveNotificationContent>(py_obj, runtime_class)};

            return PyLong_FromVoidPtr(iface.release());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef methods_ImplementsIAdaptiveNotificationContent[] = {
        { "_assign_array_", _assign_array_IAdaptiveNotificationContent, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IAdaptiveNotificationContent), METH_O | METH_STATIC, nullptr },
        { "_guid_", reinterpret_cast<PyCFunction>(_guid_ImplementsIAdaptiveNotificationContent), METH_NOARGS | METH_STATIC, nullptr },
        { "_make_", reinterpret_cast<PyCFunction>(_make_ImplementsIAdaptiveNotificationContent), METH_VARARGS | METH_STATIC, nullptr },
        { }};

    static PyType_Slot type_slots_ImplementsIAdaptiveNotificationContent[] = {
        { Py_tp_methods, reinterpret_cast<void*>(methods_ImplementsIAdaptiveNotificationContent) },
        { }};

    static PyType_Spec type_spec_ImplementsIAdaptiveNotificationContent = {
        "winrt._winrt_windows_ui_notifications.IAdaptiveNotificationContent",
        0,
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE
        #if PY_VERSION_HEX >= 0x030A0000
        | Py_TPFLAGS_DISALLOW_INSTANTIATION
        #endif
        ,
        type_slots_ImplementsIAdaptiveNotificationContent};

    // ----- Windows.UI.Notifications Initialization --------------------

    PyDoc_STRVAR(module_doc, "Windows.UI.Notifications");

    static PyModuleDef module_def = {
        PyModuleDef_HEAD_INIT,
        "_winrt_windows_ui_notifications",
        module_doc,
        0,
        nullptr,
        nullptr,
        nullptr,
        nullptr,
        nullptr};
} // py::cpp::Windows::UI::Notifications

PyMODINIT_FUNC PyInit__winrt_windows_ui_notifications(void) noexcept
{
    using namespace py::cpp::Windows::UI::Notifications;

    if (py::import_winrt_runtime() == -1)
    {
        return nullptr;
    }

    py::pyobj_handle module{PyModule_Create(&module_def)};

    if (!module)
    {
        return nullptr;
    }

    auto inspectable_meta_type = py::get_inspectable_meta_type();
    if (!inspectable_meta_type)
    {
        return nullptr;
    }

    auto object_type = py::get_object_type();
    if (!object_type)
    {
        return nullptr;
    }

    py::pyobj_handle object_bases{PyTuple_Pack(1, object_type)};

    if (!object_bases)
    {
        return nullptr;
    }

    py::pytype_handle AdaptiveNotificationText_type{py::register_python_type(module.get(), &type_spec_AdaptiveNotificationText, object_bases.get(), inspectable_meta_type)};
    if (!AdaptiveNotificationText_type)
    {
        return nullptr;
    }

    py::pytype_handle BadgeNotification_type{py::register_python_type(module.get(), &type_spec_BadgeNotification, object_bases.get(), inspectable_meta_type)};
    if (!BadgeNotification_type)
    {
        return nullptr;
    }

    py::pyobj_handle BadgeUpdateManager_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(inspectable_meta_type))};
    if (!BadgeUpdateManager_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_BadgeUpdateManager_Static{PyType_FromSpecWithBases(&type_spec_BadgeUpdateManager_Static, BadgeUpdateManager_Static_bases.get())};
    if (!type_BadgeUpdateManager_Static)
    {
        return nullptr;
    }

    py::pytype_handle BadgeUpdateManager_type{py::register_python_type(module.get(), &type_spec_BadgeUpdateManager, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_BadgeUpdateManager_Static.get()))};
    if (!BadgeUpdateManager_type)
    {
        return nullptr;
    }

    py::pytype_handle BadgeUpdateManagerForUser_type{py::register_python_type(module.get(), &type_spec_BadgeUpdateManagerForUser, object_bases.get(), inspectable_meta_type)};
    if (!BadgeUpdateManagerForUser_type)
    {
        return nullptr;
    }

    py::pytype_handle BadgeUpdater_type{py::register_python_type(module.get(), &type_spec_BadgeUpdater, object_bases.get(), inspectable_meta_type)};
    if (!BadgeUpdater_type)
    {
        return nullptr;
    }

    py::pyobj_handle KnownAdaptiveNotificationHints_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(inspectable_meta_type))};
    if (!KnownAdaptiveNotificationHints_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_KnownAdaptiveNotificationHints_Static{PyType_FromSpecWithBases(&type_spec_KnownAdaptiveNotificationHints_Static, KnownAdaptiveNotificationHints_Static_bases.get())};
    if (!type_KnownAdaptiveNotificationHints_Static)
    {
        return nullptr;
    }

    py::pytype_handle KnownAdaptiveNotificationHints_type{py::register_python_type(module.get(), &type_spec_KnownAdaptiveNotificationHints, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_KnownAdaptiveNotificationHints_Static.get()))};
    if (!KnownAdaptiveNotificationHints_type)
    {
        return nullptr;
    }

    py::pyobj_handle KnownAdaptiveNotificationTextStyles_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(inspectable_meta_type))};
    if (!KnownAdaptiveNotificationTextStyles_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_KnownAdaptiveNotificationTextStyles_Static{PyType_FromSpecWithBases(&type_spec_KnownAdaptiveNotificationTextStyles_Static, KnownAdaptiveNotificationTextStyles_Static_bases.get())};
    if (!type_KnownAdaptiveNotificationTextStyles_Static)
    {
        return nullptr;
    }

    py::pytype_handle KnownAdaptiveNotificationTextStyles_type{py::register_python_type(module.get(), &type_spec_KnownAdaptiveNotificationTextStyles, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_KnownAdaptiveNotificationTextStyles_Static.get()))};
    if (!KnownAdaptiveNotificationTextStyles_type)
    {
        return nullptr;
    }

    py::pyobj_handle KnownNotificationBindings_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(inspectable_meta_type))};
    if (!KnownNotificationBindings_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_KnownNotificationBindings_Static{PyType_FromSpecWithBases(&type_spec_KnownNotificationBindings_Static, KnownNotificationBindings_Static_bases.get())};
    if (!type_KnownNotificationBindings_Static)
    {
        return nullptr;
    }

    py::pytype_handle KnownNotificationBindings_type{py::register_python_type(module.get(), &type_spec_KnownNotificationBindings, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_KnownNotificationBindings_Static.get()))};
    if (!KnownNotificationBindings_type)
    {
        return nullptr;
    }

    py::pytype_handle Notification_type{py::register_python_type(module.get(), &type_spec_Notification, object_bases.get(), inspectable_meta_type)};
    if (!Notification_type)
    {
        return nullptr;
    }

    py::pytype_handle NotificationBinding_type{py::register_python_type(module.get(), &type_spec_NotificationBinding, object_bases.get(), inspectable_meta_type)};
    if (!NotificationBinding_type)
    {
        return nullptr;
    }

    py::pytype_handle NotificationData_type{py::register_python_type(module.get(), &type_spec_NotificationData, object_bases.get(), inspectable_meta_type)};
    if (!NotificationData_type)
    {
        return nullptr;
    }

    py::pytype_handle NotificationVisual_type{py::register_python_type(module.get(), &type_spec_NotificationVisual, object_bases.get(), inspectable_meta_type)};
    if (!NotificationVisual_type)
    {
        return nullptr;
    }

    py::pytype_handle ScheduledTileNotification_type{py::register_python_type(module.get(), &type_spec_ScheduledTileNotification, object_bases.get(), inspectable_meta_type)};
    if (!ScheduledTileNotification_type)
    {
        return nullptr;
    }

    py::pytype_handle ScheduledToastNotification_type{py::register_python_type(module.get(), &type_spec_ScheduledToastNotification, object_bases.get(), inspectable_meta_type)};
    if (!ScheduledToastNotification_type)
    {
        return nullptr;
    }

    py::pytype_handle ScheduledToastNotificationShowingEventArgs_type{py::register_python_type(module.get(), &type_spec_ScheduledToastNotificationShowingEventArgs, object_bases.get(), inspectable_meta_type)};
    if (!ScheduledToastNotificationShowingEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle ShownTileNotification_type{py::register_python_type(module.get(), &type_spec_ShownTileNotification, object_bases.get(), inspectable_meta_type)};
    if (!ShownTileNotification_type)
    {
        return nullptr;
    }

    py::pytype_handle TileFlyoutNotification_type{py::register_python_type(module.get(), &type_spec_TileFlyoutNotification, object_bases.get(), inspectable_meta_type)};
    if (!TileFlyoutNotification_type)
    {
        return nullptr;
    }

    py::pyobj_handle TileFlyoutUpdateManager_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(inspectable_meta_type))};
    if (!TileFlyoutUpdateManager_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_TileFlyoutUpdateManager_Static{PyType_FromSpecWithBases(&type_spec_TileFlyoutUpdateManager_Static, TileFlyoutUpdateManager_Static_bases.get())};
    if (!type_TileFlyoutUpdateManager_Static)
    {
        return nullptr;
    }

    py::pytype_handle TileFlyoutUpdateManager_type{py::register_python_type(module.get(), &type_spec_TileFlyoutUpdateManager, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_TileFlyoutUpdateManager_Static.get()))};
    if (!TileFlyoutUpdateManager_type)
    {
        return nullptr;
    }

    py::pytype_handle TileFlyoutUpdater_type{py::register_python_type(module.get(), &type_spec_TileFlyoutUpdater, object_bases.get(), inspectable_meta_type)};
    if (!TileFlyoutUpdater_type)
    {
        return nullptr;
    }

    py::pytype_handle TileNotification_type{py::register_python_type(module.get(), &type_spec_TileNotification, object_bases.get(), inspectable_meta_type)};
    if (!TileNotification_type)
    {
        return nullptr;
    }

    py::pyobj_handle TileUpdateManager_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(inspectable_meta_type))};
    if (!TileUpdateManager_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_TileUpdateManager_Static{PyType_FromSpecWithBases(&type_spec_TileUpdateManager_Static, TileUpdateManager_Static_bases.get())};
    if (!type_TileUpdateManager_Static)
    {
        return nullptr;
    }

    py::pytype_handle TileUpdateManager_type{py::register_python_type(module.get(), &type_spec_TileUpdateManager, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_TileUpdateManager_Static.get()))};
    if (!TileUpdateManager_type)
    {
        return nullptr;
    }

    py::pytype_handle TileUpdateManagerForUser_type{py::register_python_type(module.get(), &type_spec_TileUpdateManagerForUser, object_bases.get(), inspectable_meta_type)};
    if (!TileUpdateManagerForUser_type)
    {
        return nullptr;
    }

    py::pytype_handle TileUpdater_type{py::register_python_type(module.get(), &type_spec_TileUpdater, object_bases.get(), inspectable_meta_type)};
    if (!TileUpdater_type)
    {
        return nullptr;
    }

    py::pytype_handle ToastActivatedEventArgs_type{py::register_python_type(module.get(), &type_spec_ToastActivatedEventArgs, object_bases.get(), inspectable_meta_type)};
    if (!ToastActivatedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle ToastCollection_type{py::register_python_type(module.get(), &type_spec_ToastCollection, object_bases.get(), inspectable_meta_type)};
    if (!ToastCollection_type)
    {
        return nullptr;
    }

    py::pytype_handle ToastCollectionManager_type{py::register_python_type(module.get(), &type_spec_ToastCollectionManager, object_bases.get(), inspectable_meta_type)};
    if (!ToastCollectionManager_type)
    {
        return nullptr;
    }

    py::pytype_handle ToastDismissedEventArgs_type{py::register_python_type(module.get(), &type_spec_ToastDismissedEventArgs, object_bases.get(), inspectable_meta_type)};
    if (!ToastDismissedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle ToastFailedEventArgs_type{py::register_python_type(module.get(), &type_spec_ToastFailedEventArgs, object_bases.get(), inspectable_meta_type)};
    if (!ToastFailedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle ToastNotification_type{py::register_python_type(module.get(), &type_spec_ToastNotification, object_bases.get(), inspectable_meta_type)};
    if (!ToastNotification_type)
    {
        return nullptr;
    }

    py::pytype_handle ToastNotificationActionTriggerDetail_type{py::register_python_type(module.get(), &type_spec_ToastNotificationActionTriggerDetail, object_bases.get(), inspectable_meta_type)};
    if (!ToastNotificationActionTriggerDetail_type)
    {
        return nullptr;
    }

    py::pytype_handle ToastNotificationHistory_type{py::register_python_type(module.get(), &type_spec_ToastNotificationHistory, object_bases.get(), inspectable_meta_type)};
    if (!ToastNotificationHistory_type)
    {
        return nullptr;
    }

    py::pytype_handle ToastNotificationHistoryChangedTriggerDetail_type{py::register_python_type(module.get(), &type_spec_ToastNotificationHistoryChangedTriggerDetail, object_bases.get(), inspectable_meta_type)};
    if (!ToastNotificationHistoryChangedTriggerDetail_type)
    {
        return nullptr;
    }

    py::pyobj_handle ToastNotificationManager_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(inspectable_meta_type))};
    if (!ToastNotificationManager_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_ToastNotificationManager_Static{PyType_FromSpecWithBases(&type_spec_ToastNotificationManager_Static, ToastNotificationManager_Static_bases.get())};
    if (!type_ToastNotificationManager_Static)
    {
        return nullptr;
    }

    py::pytype_handle ToastNotificationManager_type{py::register_python_type(module.get(), &type_spec_ToastNotificationManager, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_ToastNotificationManager_Static.get()))};
    if (!ToastNotificationManager_type)
    {
        return nullptr;
    }

    py::pytype_handle ToastNotificationManagerForUser_type{py::register_python_type(module.get(), &type_spec_ToastNotificationManagerForUser, object_bases.get(), inspectable_meta_type)};
    if (!ToastNotificationManagerForUser_type)
    {
        return nullptr;
    }

    py::pytype_handle ToastNotifier_type{py::register_python_type(module.get(), &type_spec_ToastNotifier, object_bases.get(), inspectable_meta_type)};
    if (!ToastNotifier_type)
    {
        return nullptr;
    }

    py::pytype_handle UserNotification_type{py::register_python_type(module.get(), &type_spec_UserNotification, object_bases.get(), inspectable_meta_type)};
    if (!UserNotification_type)
    {
        return nullptr;
    }

    py::pytype_handle UserNotificationChangedEventArgs_type{py::register_python_type(module.get(), &type_spec_UserNotificationChangedEventArgs, object_bases.get(), inspectable_meta_type)};
    if (!UserNotificationChangedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle IAdaptiveNotificationContent_type{py::register_python_type(module.get(), &type_spec_IAdaptiveNotificationContent, object_bases.get(), nullptr)};
    if (!IAdaptiveNotificationContent_type)
    {
        return nullptr;
    }

    py::pytype_handle ImplementsIAdaptiveNotificationContent_type{py::register_python_type(module.get(), &type_spec_ImplementsIAdaptiveNotificationContent, nullptr, inspectable_meta_type)};
    if (!ImplementsIAdaptiveNotificationContent_type)
    {
        return nullptr;
    }

    if (PyModule_AddType(module.get(), ImplementsIAdaptiveNotificationContent_type.get()) == -1)
    {
        return nullptr;
    }


    return module.detach();
}
