// WARNING: Please don't edit this file. It was generated by Python/WinRT v3.2.1

#include "py.Windows.Media.Control.h"

namespace py::cpp::Windows::Media::Control
{
    // ----- CurrentSessionChangedEventArgs class --------------------

    static PyObject* _new_CurrentSessionChangedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Control::CurrentSessionChangedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Control::CurrentSessionChangedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_CurrentSessionChangedEventArgs(py::wrapper::Windows::Media::Control::CurrentSessionChangedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_CurrentSessionChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Control::CurrentSessionChangedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CurrentSessionChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Control::CurrentSessionChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CurrentSessionChangedEventArgs[] = {
        { "_assign_array_", _assign_array_CurrentSessionChangedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CurrentSessionChangedEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_CurrentSessionChangedEventArgs[] = {
        { }};

    static PyType_Slot _type_slots_CurrentSessionChangedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_CurrentSessionChangedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CurrentSessionChangedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CurrentSessionChangedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CurrentSessionChangedEventArgs) },
        { }};

    static PyType_Spec type_spec_CurrentSessionChangedEventArgs = {
        "winrt._winrt_windows_media_control.CurrentSessionChangedEventArgs",
        sizeof(py::wrapper::Windows::Media::Control::CurrentSessionChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CurrentSessionChangedEventArgs};

    // ----- GlobalSystemMediaTransportControlsSession class --------------------

    static PyObject* _new_GlobalSystemMediaTransportControlsSession(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Control::GlobalSystemMediaTransportControlsSession>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Control::GlobalSystemMediaTransportControlsSession>::type_name);
        return nullptr;
    }

    static void _dealloc_GlobalSystemMediaTransportControlsSession(py::wrapper::Windows::Media::Control::GlobalSystemMediaTransportControlsSession* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* GlobalSystemMediaTransportControlsSession_GetPlaybackInfo(py::wrapper::Windows::Media::Control::GlobalSystemMediaTransportControlsSession* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Control.GlobalSystemMediaTransportControlsSession", L"GetPlaybackInfo", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetPlaybackInfo();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GlobalSystemMediaTransportControlsSession_GetTimelineProperties(py::wrapper::Windows::Media::Control::GlobalSystemMediaTransportControlsSession* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Control.GlobalSystemMediaTransportControlsSession", L"GetTimelineProperties", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetTimelineProperties();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GlobalSystemMediaTransportControlsSession_TryChangeAutoRepeatModeAsync(py::wrapper::Windows::Media::Control::GlobalSystemMediaTransportControlsSession* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Control.GlobalSystemMediaTransportControlsSession", L"TryChangeAutoRepeatModeAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Media::MediaPlaybackAutoRepeatMode>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.TryChangeAutoRepeatModeAsync(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GlobalSystemMediaTransportControlsSession_TryChangeChannelDownAsync(py::wrapper::Windows::Media::Control::GlobalSystemMediaTransportControlsSession* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Control.GlobalSystemMediaTransportControlsSession", L"TryChangeChannelDownAsync", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.TryChangeChannelDownAsync();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GlobalSystemMediaTransportControlsSession_TryChangeChannelUpAsync(py::wrapper::Windows::Media::Control::GlobalSystemMediaTransportControlsSession* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Control.GlobalSystemMediaTransportControlsSession", L"TryChangeChannelUpAsync", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.TryChangeChannelUpAsync();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GlobalSystemMediaTransportControlsSession_TryChangePlaybackPositionAsync(py::wrapper::Windows::Media::Control::GlobalSystemMediaTransportControlsSession* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Control.GlobalSystemMediaTransportControlsSession", L"TryChangePlaybackPositionAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<int64_t>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.TryChangePlaybackPositionAsync(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GlobalSystemMediaTransportControlsSession_TryChangePlaybackRateAsync(py::wrapper::Windows::Media::Control::GlobalSystemMediaTransportControlsSession* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Control.GlobalSystemMediaTransportControlsSession", L"TryChangePlaybackRateAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<double>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.TryChangePlaybackRateAsync(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GlobalSystemMediaTransportControlsSession_TryChangeShuffleActiveAsync(py::wrapper::Windows::Media::Control::GlobalSystemMediaTransportControlsSession* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Control.GlobalSystemMediaTransportControlsSession", L"TryChangeShuffleActiveAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<bool>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.TryChangeShuffleActiveAsync(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GlobalSystemMediaTransportControlsSession_TryFastForwardAsync(py::wrapper::Windows::Media::Control::GlobalSystemMediaTransportControlsSession* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Control.GlobalSystemMediaTransportControlsSession", L"TryFastForwardAsync", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.TryFastForwardAsync();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GlobalSystemMediaTransportControlsSession_TryGetMediaPropertiesAsync(py::wrapper::Windows::Media::Control::GlobalSystemMediaTransportControlsSession* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Control.GlobalSystemMediaTransportControlsSession", L"TryGetMediaPropertiesAsync", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.TryGetMediaPropertiesAsync();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GlobalSystemMediaTransportControlsSession_TryPauseAsync(py::wrapper::Windows::Media::Control::GlobalSystemMediaTransportControlsSession* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Control.GlobalSystemMediaTransportControlsSession", L"TryPauseAsync", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.TryPauseAsync();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GlobalSystemMediaTransportControlsSession_TryPlayAsync(py::wrapper::Windows::Media::Control::GlobalSystemMediaTransportControlsSession* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Control.GlobalSystemMediaTransportControlsSession", L"TryPlayAsync", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.TryPlayAsync();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GlobalSystemMediaTransportControlsSession_TryRecordAsync(py::wrapper::Windows::Media::Control::GlobalSystemMediaTransportControlsSession* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Control.GlobalSystemMediaTransportControlsSession", L"TryRecordAsync", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.TryRecordAsync();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GlobalSystemMediaTransportControlsSession_TryRewindAsync(py::wrapper::Windows::Media::Control::GlobalSystemMediaTransportControlsSession* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Control.GlobalSystemMediaTransportControlsSession", L"TryRewindAsync", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.TryRewindAsync();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GlobalSystemMediaTransportControlsSession_TrySkipNextAsync(py::wrapper::Windows::Media::Control::GlobalSystemMediaTransportControlsSession* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Control.GlobalSystemMediaTransportControlsSession", L"TrySkipNextAsync", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.TrySkipNextAsync();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GlobalSystemMediaTransportControlsSession_TrySkipPreviousAsync(py::wrapper::Windows::Media::Control::GlobalSystemMediaTransportControlsSession* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Control.GlobalSystemMediaTransportControlsSession", L"TrySkipPreviousAsync", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.TrySkipPreviousAsync();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GlobalSystemMediaTransportControlsSession_TryStopAsync(py::wrapper::Windows::Media::Control::GlobalSystemMediaTransportControlsSession* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Control.GlobalSystemMediaTransportControlsSession", L"TryStopAsync", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.TryStopAsync();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GlobalSystemMediaTransportControlsSession_TryTogglePlayPauseAsync(py::wrapper::Windows::Media::Control::GlobalSystemMediaTransportControlsSession* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Control.GlobalSystemMediaTransportControlsSession", L"TryTogglePlayPauseAsync", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.TryTogglePlayPauseAsync();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GlobalSystemMediaTransportControlsSession_get_SourceAppUserModelId(py::wrapper::Windows::Media::Control::GlobalSystemMediaTransportControlsSession* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Control.GlobalSystemMediaTransportControlsSession", L"SourceAppUserModelId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SourceAppUserModelId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GlobalSystemMediaTransportControlsSession_add_MediaPropertiesChanged(py::wrapper::Windows::Media::Control::GlobalSystemMediaTransportControlsSession* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Control.GlobalSystemMediaTransportControlsSession", L"MediaPropertiesChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Control::GlobalSystemMediaTransportControlsSession, winrt::Windows::Media::Control::MediaPropertiesChangedEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.MediaPropertiesChanged(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GlobalSystemMediaTransportControlsSession_remove_MediaPropertiesChanged(py::wrapper::Windows::Media::Control::GlobalSystemMediaTransportControlsSession* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Control.GlobalSystemMediaTransportControlsSession", L"MediaPropertiesChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.MediaPropertiesChanged(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GlobalSystemMediaTransportControlsSession_add_PlaybackInfoChanged(py::wrapper::Windows::Media::Control::GlobalSystemMediaTransportControlsSession* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Control.GlobalSystemMediaTransportControlsSession", L"PlaybackInfoChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Control::GlobalSystemMediaTransportControlsSession, winrt::Windows::Media::Control::PlaybackInfoChangedEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PlaybackInfoChanged(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GlobalSystemMediaTransportControlsSession_remove_PlaybackInfoChanged(py::wrapper::Windows::Media::Control::GlobalSystemMediaTransportControlsSession* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Control.GlobalSystemMediaTransportControlsSession", L"PlaybackInfoChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.PlaybackInfoChanged(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GlobalSystemMediaTransportControlsSession_add_TimelinePropertiesChanged(py::wrapper::Windows::Media::Control::GlobalSystemMediaTransportControlsSession* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Control.GlobalSystemMediaTransportControlsSession", L"TimelinePropertiesChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Control::GlobalSystemMediaTransportControlsSession, winrt::Windows::Media::Control::TimelinePropertiesChangedEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.TimelinePropertiesChanged(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GlobalSystemMediaTransportControlsSession_remove_TimelinePropertiesChanged(py::wrapper::Windows::Media::Control::GlobalSystemMediaTransportControlsSession* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Control.GlobalSystemMediaTransportControlsSession", L"TimelinePropertiesChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.TimelinePropertiesChanged(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_GlobalSystemMediaTransportControlsSession(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Control::GlobalSystemMediaTransportControlsSession>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_GlobalSystemMediaTransportControlsSession(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Control::GlobalSystemMediaTransportControlsSession>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_GlobalSystemMediaTransportControlsSession[] = {
        { "get_playback_info", reinterpret_cast<PyCFunction>(GlobalSystemMediaTransportControlsSession_GetPlaybackInfo), METH_VARARGS, nullptr },
        { "get_timeline_properties", reinterpret_cast<PyCFunction>(GlobalSystemMediaTransportControlsSession_GetTimelineProperties), METH_VARARGS, nullptr },
        { "try_change_auto_repeat_mode_async", reinterpret_cast<PyCFunction>(GlobalSystemMediaTransportControlsSession_TryChangeAutoRepeatModeAsync), METH_VARARGS, nullptr },
        { "try_change_channel_down_async", reinterpret_cast<PyCFunction>(GlobalSystemMediaTransportControlsSession_TryChangeChannelDownAsync), METH_VARARGS, nullptr },
        { "try_change_channel_up_async", reinterpret_cast<PyCFunction>(GlobalSystemMediaTransportControlsSession_TryChangeChannelUpAsync), METH_VARARGS, nullptr },
        { "try_change_playback_position_async", reinterpret_cast<PyCFunction>(GlobalSystemMediaTransportControlsSession_TryChangePlaybackPositionAsync), METH_VARARGS, nullptr },
        { "try_change_playback_rate_async", reinterpret_cast<PyCFunction>(GlobalSystemMediaTransportControlsSession_TryChangePlaybackRateAsync), METH_VARARGS, nullptr },
        { "try_change_shuffle_active_async", reinterpret_cast<PyCFunction>(GlobalSystemMediaTransportControlsSession_TryChangeShuffleActiveAsync), METH_VARARGS, nullptr },
        { "try_fast_forward_async", reinterpret_cast<PyCFunction>(GlobalSystemMediaTransportControlsSession_TryFastForwardAsync), METH_VARARGS, nullptr },
        { "try_get_media_properties_async", reinterpret_cast<PyCFunction>(GlobalSystemMediaTransportControlsSession_TryGetMediaPropertiesAsync), METH_VARARGS, nullptr },
        { "try_pause_async", reinterpret_cast<PyCFunction>(GlobalSystemMediaTransportControlsSession_TryPauseAsync), METH_VARARGS, nullptr },
        { "try_play_async", reinterpret_cast<PyCFunction>(GlobalSystemMediaTransportControlsSession_TryPlayAsync), METH_VARARGS, nullptr },
        { "try_record_async", reinterpret_cast<PyCFunction>(GlobalSystemMediaTransportControlsSession_TryRecordAsync), METH_VARARGS, nullptr },
        { "try_rewind_async", reinterpret_cast<PyCFunction>(GlobalSystemMediaTransportControlsSession_TryRewindAsync), METH_VARARGS, nullptr },
        { "try_skip_next_async", reinterpret_cast<PyCFunction>(GlobalSystemMediaTransportControlsSession_TrySkipNextAsync), METH_VARARGS, nullptr },
        { "try_skip_previous_async", reinterpret_cast<PyCFunction>(GlobalSystemMediaTransportControlsSession_TrySkipPreviousAsync), METH_VARARGS, nullptr },
        { "try_stop_async", reinterpret_cast<PyCFunction>(GlobalSystemMediaTransportControlsSession_TryStopAsync), METH_VARARGS, nullptr },
        { "try_toggle_play_pause_async", reinterpret_cast<PyCFunction>(GlobalSystemMediaTransportControlsSession_TryTogglePlayPauseAsync), METH_VARARGS, nullptr },
        { "add_media_properties_changed", reinterpret_cast<PyCFunction>(GlobalSystemMediaTransportControlsSession_add_MediaPropertiesChanged), METH_O, nullptr },
        { "remove_media_properties_changed", reinterpret_cast<PyCFunction>(GlobalSystemMediaTransportControlsSession_remove_MediaPropertiesChanged), METH_O, nullptr },
        { "add_playback_info_changed", reinterpret_cast<PyCFunction>(GlobalSystemMediaTransportControlsSession_add_PlaybackInfoChanged), METH_O, nullptr },
        { "remove_playback_info_changed", reinterpret_cast<PyCFunction>(GlobalSystemMediaTransportControlsSession_remove_PlaybackInfoChanged), METH_O, nullptr },
        { "add_timeline_properties_changed", reinterpret_cast<PyCFunction>(GlobalSystemMediaTransportControlsSession_add_TimelinePropertiesChanged), METH_O, nullptr },
        { "remove_timeline_properties_changed", reinterpret_cast<PyCFunction>(GlobalSystemMediaTransportControlsSession_remove_TimelinePropertiesChanged), METH_O, nullptr },
        { "_assign_array_", _assign_array_GlobalSystemMediaTransportControlsSession, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_GlobalSystemMediaTransportControlsSession), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_GlobalSystemMediaTransportControlsSession[] = {
        { "source_app_user_model_id", reinterpret_cast<getter>(GlobalSystemMediaTransportControlsSession_get_SourceAppUserModelId), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_GlobalSystemMediaTransportControlsSession[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_GlobalSystemMediaTransportControlsSession) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_GlobalSystemMediaTransportControlsSession) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_GlobalSystemMediaTransportControlsSession) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_GlobalSystemMediaTransportControlsSession) },
        { }};

    static PyType_Spec type_spec_GlobalSystemMediaTransportControlsSession = {
        "winrt._winrt_windows_media_control.GlobalSystemMediaTransportControlsSession",
        sizeof(py::wrapper::Windows::Media::Control::GlobalSystemMediaTransportControlsSession),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_GlobalSystemMediaTransportControlsSession};

    // ----- GlobalSystemMediaTransportControlsSessionManager class --------------------

    static PyObject* _new_GlobalSystemMediaTransportControlsSessionManager(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Control::GlobalSystemMediaTransportControlsSessionManager>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Control::GlobalSystemMediaTransportControlsSessionManager>::type_name);
        return nullptr;
    }

    static void _dealloc_GlobalSystemMediaTransportControlsSessionManager(py::wrapper::Windows::Media::Control::GlobalSystemMediaTransportControlsSessionManager* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* GlobalSystemMediaTransportControlsSessionManager_GetCurrentSession(py::wrapper::Windows::Media::Control::GlobalSystemMediaTransportControlsSessionManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Control.GlobalSystemMediaTransportControlsSessionManager", L"GetCurrentSession", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetCurrentSession();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GlobalSystemMediaTransportControlsSessionManager_GetSessions(py::wrapper::Windows::Media::Control::GlobalSystemMediaTransportControlsSessionManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Control.GlobalSystemMediaTransportControlsSessionManager", L"GetSessions", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetSessions();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GlobalSystemMediaTransportControlsSessionManager_RequestAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Control.GlobalSystemMediaTransportControlsSessionManager", L"RequestAsync", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::Media::Control::GlobalSystemMediaTransportControlsSessionManager::RequestAsync();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GlobalSystemMediaTransportControlsSessionManager_add_CurrentSessionChanged(py::wrapper::Windows::Media::Control::GlobalSystemMediaTransportControlsSessionManager* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Control.GlobalSystemMediaTransportControlsSessionManager", L"CurrentSessionChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Control::GlobalSystemMediaTransportControlsSessionManager, winrt::Windows::Media::Control::CurrentSessionChangedEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.CurrentSessionChanged(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GlobalSystemMediaTransportControlsSessionManager_remove_CurrentSessionChanged(py::wrapper::Windows::Media::Control::GlobalSystemMediaTransportControlsSessionManager* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Control.GlobalSystemMediaTransportControlsSessionManager", L"CurrentSessionChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.CurrentSessionChanged(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GlobalSystemMediaTransportControlsSessionManager_add_SessionsChanged(py::wrapper::Windows::Media::Control::GlobalSystemMediaTransportControlsSessionManager* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Control.GlobalSystemMediaTransportControlsSessionManager", L"SessionsChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Control::GlobalSystemMediaTransportControlsSessionManager, winrt::Windows::Media::Control::SessionsChangedEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SessionsChanged(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GlobalSystemMediaTransportControlsSessionManager_remove_SessionsChanged(py::wrapper::Windows::Media::Control::GlobalSystemMediaTransportControlsSessionManager* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Control.GlobalSystemMediaTransportControlsSessionManager", L"SessionsChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.SessionsChanged(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_GlobalSystemMediaTransportControlsSessionManager(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Control::GlobalSystemMediaTransportControlsSessionManager>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_GlobalSystemMediaTransportControlsSessionManager(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Control::GlobalSystemMediaTransportControlsSessionManager>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_GlobalSystemMediaTransportControlsSessionManager[] = {
        { "get_current_session", reinterpret_cast<PyCFunction>(GlobalSystemMediaTransportControlsSessionManager_GetCurrentSession), METH_VARARGS, nullptr },
        { "get_sessions", reinterpret_cast<PyCFunction>(GlobalSystemMediaTransportControlsSessionManager_GetSessions), METH_VARARGS, nullptr },
        { "add_current_session_changed", reinterpret_cast<PyCFunction>(GlobalSystemMediaTransportControlsSessionManager_add_CurrentSessionChanged), METH_O, nullptr },
        { "remove_current_session_changed", reinterpret_cast<PyCFunction>(GlobalSystemMediaTransportControlsSessionManager_remove_CurrentSessionChanged), METH_O, nullptr },
        { "add_sessions_changed", reinterpret_cast<PyCFunction>(GlobalSystemMediaTransportControlsSessionManager_add_SessionsChanged), METH_O, nullptr },
        { "remove_sessions_changed", reinterpret_cast<PyCFunction>(GlobalSystemMediaTransportControlsSessionManager_remove_SessionsChanged), METH_O, nullptr },
        { "_assign_array_", _assign_array_GlobalSystemMediaTransportControlsSessionManager, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_GlobalSystemMediaTransportControlsSessionManager), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_GlobalSystemMediaTransportControlsSessionManager[] = {
        { }};

    static PyType_Slot _type_slots_GlobalSystemMediaTransportControlsSessionManager[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_GlobalSystemMediaTransportControlsSessionManager) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_GlobalSystemMediaTransportControlsSessionManager) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_GlobalSystemMediaTransportControlsSessionManager) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_GlobalSystemMediaTransportControlsSessionManager) },
        { }};

    static PyType_Spec type_spec_GlobalSystemMediaTransportControlsSessionManager = {
        "winrt._winrt_windows_media_control.GlobalSystemMediaTransportControlsSessionManager",
        sizeof(py::wrapper::Windows::Media::Control::GlobalSystemMediaTransportControlsSessionManager),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_GlobalSystemMediaTransportControlsSessionManager};

    static PyGetSetDef getset_GlobalSystemMediaTransportControlsSessionManager_Static[] = {
        { }};

    static PyMethodDef methods_GlobalSystemMediaTransportControlsSessionManager_Static[] = {
        { "request_async", reinterpret_cast<PyCFunction>(GlobalSystemMediaTransportControlsSessionManager_RequestAsync), METH_VARARGS, nullptr },
        { }};

    static PyType_Slot type_slots_GlobalSystemMediaTransportControlsSessionManager_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_GlobalSystemMediaTransportControlsSessionManager_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_GlobalSystemMediaTransportControlsSessionManager_Static) },
        { }
    };

    static PyType_Spec type_spec_GlobalSystemMediaTransportControlsSessionManager_Static = {
        "winrt._winrt_windows_media_control.GlobalSystemMediaTransportControlsSessionManager_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_GlobalSystemMediaTransportControlsSessionManager_Static};

    // ----- GlobalSystemMediaTransportControlsSessionMediaProperties class --------------------

    static PyObject* _new_GlobalSystemMediaTransportControlsSessionMediaProperties(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Control::GlobalSystemMediaTransportControlsSessionMediaProperties>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Control::GlobalSystemMediaTransportControlsSessionMediaProperties>::type_name);
        return nullptr;
    }

    static void _dealloc_GlobalSystemMediaTransportControlsSessionMediaProperties(py::wrapper::Windows::Media::Control::GlobalSystemMediaTransportControlsSessionMediaProperties* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* GlobalSystemMediaTransportControlsSessionMediaProperties_get_AlbumArtist(py::wrapper::Windows::Media::Control::GlobalSystemMediaTransportControlsSessionMediaProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Control.GlobalSystemMediaTransportControlsSessionMediaProperties", L"AlbumArtist");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.AlbumArtist();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GlobalSystemMediaTransportControlsSessionMediaProperties_get_AlbumTitle(py::wrapper::Windows::Media::Control::GlobalSystemMediaTransportControlsSessionMediaProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Control.GlobalSystemMediaTransportControlsSessionMediaProperties", L"AlbumTitle");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.AlbumTitle();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GlobalSystemMediaTransportControlsSessionMediaProperties_get_AlbumTrackCount(py::wrapper::Windows::Media::Control::GlobalSystemMediaTransportControlsSessionMediaProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Control.GlobalSystemMediaTransportControlsSessionMediaProperties", L"AlbumTrackCount");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.AlbumTrackCount();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GlobalSystemMediaTransportControlsSessionMediaProperties_get_Artist(py::wrapper::Windows::Media::Control::GlobalSystemMediaTransportControlsSessionMediaProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Control.GlobalSystemMediaTransportControlsSessionMediaProperties", L"Artist");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Artist();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GlobalSystemMediaTransportControlsSessionMediaProperties_get_Genres(py::wrapper::Windows::Media::Control::GlobalSystemMediaTransportControlsSessionMediaProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Control.GlobalSystemMediaTransportControlsSessionMediaProperties", L"Genres");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Genres();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GlobalSystemMediaTransportControlsSessionMediaProperties_get_PlaybackType(py::wrapper::Windows::Media::Control::GlobalSystemMediaTransportControlsSessionMediaProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Control.GlobalSystemMediaTransportControlsSessionMediaProperties", L"PlaybackType");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PlaybackType();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GlobalSystemMediaTransportControlsSessionMediaProperties_get_Subtitle(py::wrapper::Windows::Media::Control::GlobalSystemMediaTransportControlsSessionMediaProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Control.GlobalSystemMediaTransportControlsSessionMediaProperties", L"Subtitle");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Subtitle();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GlobalSystemMediaTransportControlsSessionMediaProperties_get_Thumbnail(py::wrapper::Windows::Media::Control::GlobalSystemMediaTransportControlsSessionMediaProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Control.GlobalSystemMediaTransportControlsSessionMediaProperties", L"Thumbnail");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Thumbnail();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GlobalSystemMediaTransportControlsSessionMediaProperties_get_Title(py::wrapper::Windows::Media::Control::GlobalSystemMediaTransportControlsSessionMediaProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Control.GlobalSystemMediaTransportControlsSessionMediaProperties", L"Title");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Title();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GlobalSystemMediaTransportControlsSessionMediaProperties_get_TrackNumber(py::wrapper::Windows::Media::Control::GlobalSystemMediaTransportControlsSessionMediaProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Control.GlobalSystemMediaTransportControlsSessionMediaProperties", L"TrackNumber");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.TrackNumber();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_GlobalSystemMediaTransportControlsSessionMediaProperties(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Control::GlobalSystemMediaTransportControlsSessionMediaProperties>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_GlobalSystemMediaTransportControlsSessionMediaProperties(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Control::GlobalSystemMediaTransportControlsSessionMediaProperties>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_GlobalSystemMediaTransportControlsSessionMediaProperties[] = {
        { "_assign_array_", _assign_array_GlobalSystemMediaTransportControlsSessionMediaProperties, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_GlobalSystemMediaTransportControlsSessionMediaProperties), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_GlobalSystemMediaTransportControlsSessionMediaProperties[] = {
        { "album_artist", reinterpret_cast<getter>(GlobalSystemMediaTransportControlsSessionMediaProperties_get_AlbumArtist), nullptr, nullptr, nullptr },
        { "album_title", reinterpret_cast<getter>(GlobalSystemMediaTransportControlsSessionMediaProperties_get_AlbumTitle), nullptr, nullptr, nullptr },
        { "album_track_count", reinterpret_cast<getter>(GlobalSystemMediaTransportControlsSessionMediaProperties_get_AlbumTrackCount), nullptr, nullptr, nullptr },
        { "artist", reinterpret_cast<getter>(GlobalSystemMediaTransportControlsSessionMediaProperties_get_Artist), nullptr, nullptr, nullptr },
        { "genres", reinterpret_cast<getter>(GlobalSystemMediaTransportControlsSessionMediaProperties_get_Genres), nullptr, nullptr, nullptr },
        { "playback_type", reinterpret_cast<getter>(GlobalSystemMediaTransportControlsSessionMediaProperties_get_PlaybackType), nullptr, nullptr, nullptr },
        { "subtitle", reinterpret_cast<getter>(GlobalSystemMediaTransportControlsSessionMediaProperties_get_Subtitle), nullptr, nullptr, nullptr },
        { "thumbnail", reinterpret_cast<getter>(GlobalSystemMediaTransportControlsSessionMediaProperties_get_Thumbnail), nullptr, nullptr, nullptr },
        { "title", reinterpret_cast<getter>(GlobalSystemMediaTransportControlsSessionMediaProperties_get_Title), nullptr, nullptr, nullptr },
        { "track_number", reinterpret_cast<getter>(GlobalSystemMediaTransportControlsSessionMediaProperties_get_TrackNumber), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_GlobalSystemMediaTransportControlsSessionMediaProperties[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_GlobalSystemMediaTransportControlsSessionMediaProperties) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_GlobalSystemMediaTransportControlsSessionMediaProperties) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_GlobalSystemMediaTransportControlsSessionMediaProperties) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_GlobalSystemMediaTransportControlsSessionMediaProperties) },
        { }};

    static PyType_Spec type_spec_GlobalSystemMediaTransportControlsSessionMediaProperties = {
        "winrt._winrt_windows_media_control.GlobalSystemMediaTransportControlsSessionMediaProperties",
        sizeof(py::wrapper::Windows::Media::Control::GlobalSystemMediaTransportControlsSessionMediaProperties),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_GlobalSystemMediaTransportControlsSessionMediaProperties};

    // ----- GlobalSystemMediaTransportControlsSessionPlaybackControls class --------------------

    static PyObject* _new_GlobalSystemMediaTransportControlsSessionPlaybackControls(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Control::GlobalSystemMediaTransportControlsSessionPlaybackControls>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Control::GlobalSystemMediaTransportControlsSessionPlaybackControls>::type_name);
        return nullptr;
    }

    static void _dealloc_GlobalSystemMediaTransportControlsSessionPlaybackControls(py::wrapper::Windows::Media::Control::GlobalSystemMediaTransportControlsSessionPlaybackControls* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* GlobalSystemMediaTransportControlsSessionPlaybackControls_get_IsChannelDownEnabled(py::wrapper::Windows::Media::Control::GlobalSystemMediaTransportControlsSessionPlaybackControls* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Control.GlobalSystemMediaTransportControlsSessionPlaybackControls", L"IsChannelDownEnabled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsChannelDownEnabled();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GlobalSystemMediaTransportControlsSessionPlaybackControls_get_IsChannelUpEnabled(py::wrapper::Windows::Media::Control::GlobalSystemMediaTransportControlsSessionPlaybackControls* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Control.GlobalSystemMediaTransportControlsSessionPlaybackControls", L"IsChannelUpEnabled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsChannelUpEnabled();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GlobalSystemMediaTransportControlsSessionPlaybackControls_get_IsFastForwardEnabled(py::wrapper::Windows::Media::Control::GlobalSystemMediaTransportControlsSessionPlaybackControls* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Control.GlobalSystemMediaTransportControlsSessionPlaybackControls", L"IsFastForwardEnabled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsFastForwardEnabled();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GlobalSystemMediaTransportControlsSessionPlaybackControls_get_IsNextEnabled(py::wrapper::Windows::Media::Control::GlobalSystemMediaTransportControlsSessionPlaybackControls* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Control.GlobalSystemMediaTransportControlsSessionPlaybackControls", L"IsNextEnabled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsNextEnabled();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GlobalSystemMediaTransportControlsSessionPlaybackControls_get_IsPauseEnabled(py::wrapper::Windows::Media::Control::GlobalSystemMediaTransportControlsSessionPlaybackControls* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Control.GlobalSystemMediaTransportControlsSessionPlaybackControls", L"IsPauseEnabled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsPauseEnabled();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GlobalSystemMediaTransportControlsSessionPlaybackControls_get_IsPlayEnabled(py::wrapper::Windows::Media::Control::GlobalSystemMediaTransportControlsSessionPlaybackControls* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Control.GlobalSystemMediaTransportControlsSessionPlaybackControls", L"IsPlayEnabled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsPlayEnabled();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GlobalSystemMediaTransportControlsSessionPlaybackControls_get_IsPlayPauseToggleEnabled(py::wrapper::Windows::Media::Control::GlobalSystemMediaTransportControlsSessionPlaybackControls* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Control.GlobalSystemMediaTransportControlsSessionPlaybackControls", L"IsPlayPauseToggleEnabled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsPlayPauseToggleEnabled();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GlobalSystemMediaTransportControlsSessionPlaybackControls_get_IsPlaybackPositionEnabled(py::wrapper::Windows::Media::Control::GlobalSystemMediaTransportControlsSessionPlaybackControls* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Control.GlobalSystemMediaTransportControlsSessionPlaybackControls", L"IsPlaybackPositionEnabled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsPlaybackPositionEnabled();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GlobalSystemMediaTransportControlsSessionPlaybackControls_get_IsPlaybackRateEnabled(py::wrapper::Windows::Media::Control::GlobalSystemMediaTransportControlsSessionPlaybackControls* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Control.GlobalSystemMediaTransportControlsSessionPlaybackControls", L"IsPlaybackRateEnabled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsPlaybackRateEnabled();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GlobalSystemMediaTransportControlsSessionPlaybackControls_get_IsPreviousEnabled(py::wrapper::Windows::Media::Control::GlobalSystemMediaTransportControlsSessionPlaybackControls* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Control.GlobalSystemMediaTransportControlsSessionPlaybackControls", L"IsPreviousEnabled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsPreviousEnabled();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GlobalSystemMediaTransportControlsSessionPlaybackControls_get_IsRecordEnabled(py::wrapper::Windows::Media::Control::GlobalSystemMediaTransportControlsSessionPlaybackControls* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Control.GlobalSystemMediaTransportControlsSessionPlaybackControls", L"IsRecordEnabled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsRecordEnabled();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GlobalSystemMediaTransportControlsSessionPlaybackControls_get_IsRepeatEnabled(py::wrapper::Windows::Media::Control::GlobalSystemMediaTransportControlsSessionPlaybackControls* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Control.GlobalSystemMediaTransportControlsSessionPlaybackControls", L"IsRepeatEnabled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsRepeatEnabled();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GlobalSystemMediaTransportControlsSessionPlaybackControls_get_IsRewindEnabled(py::wrapper::Windows::Media::Control::GlobalSystemMediaTransportControlsSessionPlaybackControls* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Control.GlobalSystemMediaTransportControlsSessionPlaybackControls", L"IsRewindEnabled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsRewindEnabled();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GlobalSystemMediaTransportControlsSessionPlaybackControls_get_IsShuffleEnabled(py::wrapper::Windows::Media::Control::GlobalSystemMediaTransportControlsSessionPlaybackControls* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Control.GlobalSystemMediaTransportControlsSessionPlaybackControls", L"IsShuffleEnabled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsShuffleEnabled();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GlobalSystemMediaTransportControlsSessionPlaybackControls_get_IsStopEnabled(py::wrapper::Windows::Media::Control::GlobalSystemMediaTransportControlsSessionPlaybackControls* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Control.GlobalSystemMediaTransportControlsSessionPlaybackControls", L"IsStopEnabled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsStopEnabled();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_GlobalSystemMediaTransportControlsSessionPlaybackControls(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Control::GlobalSystemMediaTransportControlsSessionPlaybackControls>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_GlobalSystemMediaTransportControlsSessionPlaybackControls(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Control::GlobalSystemMediaTransportControlsSessionPlaybackControls>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_GlobalSystemMediaTransportControlsSessionPlaybackControls[] = {
        { "_assign_array_", _assign_array_GlobalSystemMediaTransportControlsSessionPlaybackControls, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_GlobalSystemMediaTransportControlsSessionPlaybackControls), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_GlobalSystemMediaTransportControlsSessionPlaybackControls[] = {
        { "is_channel_down_enabled", reinterpret_cast<getter>(GlobalSystemMediaTransportControlsSessionPlaybackControls_get_IsChannelDownEnabled), nullptr, nullptr, nullptr },
        { "is_channel_up_enabled", reinterpret_cast<getter>(GlobalSystemMediaTransportControlsSessionPlaybackControls_get_IsChannelUpEnabled), nullptr, nullptr, nullptr },
        { "is_fast_forward_enabled", reinterpret_cast<getter>(GlobalSystemMediaTransportControlsSessionPlaybackControls_get_IsFastForwardEnabled), nullptr, nullptr, nullptr },
        { "is_next_enabled", reinterpret_cast<getter>(GlobalSystemMediaTransportControlsSessionPlaybackControls_get_IsNextEnabled), nullptr, nullptr, nullptr },
        { "is_pause_enabled", reinterpret_cast<getter>(GlobalSystemMediaTransportControlsSessionPlaybackControls_get_IsPauseEnabled), nullptr, nullptr, nullptr },
        { "is_play_enabled", reinterpret_cast<getter>(GlobalSystemMediaTransportControlsSessionPlaybackControls_get_IsPlayEnabled), nullptr, nullptr, nullptr },
        { "is_play_pause_toggle_enabled", reinterpret_cast<getter>(GlobalSystemMediaTransportControlsSessionPlaybackControls_get_IsPlayPauseToggleEnabled), nullptr, nullptr, nullptr },
        { "is_playback_position_enabled", reinterpret_cast<getter>(GlobalSystemMediaTransportControlsSessionPlaybackControls_get_IsPlaybackPositionEnabled), nullptr, nullptr, nullptr },
        { "is_playback_rate_enabled", reinterpret_cast<getter>(GlobalSystemMediaTransportControlsSessionPlaybackControls_get_IsPlaybackRateEnabled), nullptr, nullptr, nullptr },
        { "is_previous_enabled", reinterpret_cast<getter>(GlobalSystemMediaTransportControlsSessionPlaybackControls_get_IsPreviousEnabled), nullptr, nullptr, nullptr },
        { "is_record_enabled", reinterpret_cast<getter>(GlobalSystemMediaTransportControlsSessionPlaybackControls_get_IsRecordEnabled), nullptr, nullptr, nullptr },
        { "is_repeat_enabled", reinterpret_cast<getter>(GlobalSystemMediaTransportControlsSessionPlaybackControls_get_IsRepeatEnabled), nullptr, nullptr, nullptr },
        { "is_rewind_enabled", reinterpret_cast<getter>(GlobalSystemMediaTransportControlsSessionPlaybackControls_get_IsRewindEnabled), nullptr, nullptr, nullptr },
        { "is_shuffle_enabled", reinterpret_cast<getter>(GlobalSystemMediaTransportControlsSessionPlaybackControls_get_IsShuffleEnabled), nullptr, nullptr, nullptr },
        { "is_stop_enabled", reinterpret_cast<getter>(GlobalSystemMediaTransportControlsSessionPlaybackControls_get_IsStopEnabled), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_GlobalSystemMediaTransportControlsSessionPlaybackControls[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_GlobalSystemMediaTransportControlsSessionPlaybackControls) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_GlobalSystemMediaTransportControlsSessionPlaybackControls) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_GlobalSystemMediaTransportControlsSessionPlaybackControls) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_GlobalSystemMediaTransportControlsSessionPlaybackControls) },
        { }};

    static PyType_Spec type_spec_GlobalSystemMediaTransportControlsSessionPlaybackControls = {
        "winrt._winrt_windows_media_control.GlobalSystemMediaTransportControlsSessionPlaybackControls",
        sizeof(py::wrapper::Windows::Media::Control::GlobalSystemMediaTransportControlsSessionPlaybackControls),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_GlobalSystemMediaTransportControlsSessionPlaybackControls};

    // ----- GlobalSystemMediaTransportControlsSessionPlaybackInfo class --------------------

    static PyObject* _new_GlobalSystemMediaTransportControlsSessionPlaybackInfo(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Control::GlobalSystemMediaTransportControlsSessionPlaybackInfo>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Control::GlobalSystemMediaTransportControlsSessionPlaybackInfo>::type_name);
        return nullptr;
    }

    static void _dealloc_GlobalSystemMediaTransportControlsSessionPlaybackInfo(py::wrapper::Windows::Media::Control::GlobalSystemMediaTransportControlsSessionPlaybackInfo* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* GlobalSystemMediaTransportControlsSessionPlaybackInfo_get_AutoRepeatMode(py::wrapper::Windows::Media::Control::GlobalSystemMediaTransportControlsSessionPlaybackInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Control.GlobalSystemMediaTransportControlsSessionPlaybackInfo", L"AutoRepeatMode");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.AutoRepeatMode();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GlobalSystemMediaTransportControlsSessionPlaybackInfo_get_Controls(py::wrapper::Windows::Media::Control::GlobalSystemMediaTransportControlsSessionPlaybackInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Control.GlobalSystemMediaTransportControlsSessionPlaybackInfo", L"Controls");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Controls();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GlobalSystemMediaTransportControlsSessionPlaybackInfo_get_IsShuffleActive(py::wrapper::Windows::Media::Control::GlobalSystemMediaTransportControlsSessionPlaybackInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Control.GlobalSystemMediaTransportControlsSessionPlaybackInfo", L"IsShuffleActive");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsShuffleActive();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GlobalSystemMediaTransportControlsSessionPlaybackInfo_get_PlaybackRate(py::wrapper::Windows::Media::Control::GlobalSystemMediaTransportControlsSessionPlaybackInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Control.GlobalSystemMediaTransportControlsSessionPlaybackInfo", L"PlaybackRate");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PlaybackRate();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GlobalSystemMediaTransportControlsSessionPlaybackInfo_get_PlaybackStatus(py::wrapper::Windows::Media::Control::GlobalSystemMediaTransportControlsSessionPlaybackInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Control.GlobalSystemMediaTransportControlsSessionPlaybackInfo", L"PlaybackStatus");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PlaybackStatus();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GlobalSystemMediaTransportControlsSessionPlaybackInfo_get_PlaybackType(py::wrapper::Windows::Media::Control::GlobalSystemMediaTransportControlsSessionPlaybackInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Control.GlobalSystemMediaTransportControlsSessionPlaybackInfo", L"PlaybackType");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PlaybackType();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_GlobalSystemMediaTransportControlsSessionPlaybackInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Control::GlobalSystemMediaTransportControlsSessionPlaybackInfo>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_GlobalSystemMediaTransportControlsSessionPlaybackInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Control::GlobalSystemMediaTransportControlsSessionPlaybackInfo>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_GlobalSystemMediaTransportControlsSessionPlaybackInfo[] = {
        { "_assign_array_", _assign_array_GlobalSystemMediaTransportControlsSessionPlaybackInfo, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_GlobalSystemMediaTransportControlsSessionPlaybackInfo), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_GlobalSystemMediaTransportControlsSessionPlaybackInfo[] = {
        { "auto_repeat_mode", reinterpret_cast<getter>(GlobalSystemMediaTransportControlsSessionPlaybackInfo_get_AutoRepeatMode), nullptr, nullptr, nullptr },
        { "controls", reinterpret_cast<getter>(GlobalSystemMediaTransportControlsSessionPlaybackInfo_get_Controls), nullptr, nullptr, nullptr },
        { "is_shuffle_active", reinterpret_cast<getter>(GlobalSystemMediaTransportControlsSessionPlaybackInfo_get_IsShuffleActive), nullptr, nullptr, nullptr },
        { "playback_rate", reinterpret_cast<getter>(GlobalSystemMediaTransportControlsSessionPlaybackInfo_get_PlaybackRate), nullptr, nullptr, nullptr },
        { "playback_status", reinterpret_cast<getter>(GlobalSystemMediaTransportControlsSessionPlaybackInfo_get_PlaybackStatus), nullptr, nullptr, nullptr },
        { "playback_type", reinterpret_cast<getter>(GlobalSystemMediaTransportControlsSessionPlaybackInfo_get_PlaybackType), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_GlobalSystemMediaTransportControlsSessionPlaybackInfo[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_GlobalSystemMediaTransportControlsSessionPlaybackInfo) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_GlobalSystemMediaTransportControlsSessionPlaybackInfo) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_GlobalSystemMediaTransportControlsSessionPlaybackInfo) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_GlobalSystemMediaTransportControlsSessionPlaybackInfo) },
        { }};

    static PyType_Spec type_spec_GlobalSystemMediaTransportControlsSessionPlaybackInfo = {
        "winrt._winrt_windows_media_control.GlobalSystemMediaTransportControlsSessionPlaybackInfo",
        sizeof(py::wrapper::Windows::Media::Control::GlobalSystemMediaTransportControlsSessionPlaybackInfo),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_GlobalSystemMediaTransportControlsSessionPlaybackInfo};

    // ----- GlobalSystemMediaTransportControlsSessionTimelineProperties class --------------------

    static PyObject* _new_GlobalSystemMediaTransportControlsSessionTimelineProperties(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Control::GlobalSystemMediaTransportControlsSessionTimelineProperties>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Control::GlobalSystemMediaTransportControlsSessionTimelineProperties>::type_name);
        return nullptr;
    }

    static void _dealloc_GlobalSystemMediaTransportControlsSessionTimelineProperties(py::wrapper::Windows::Media::Control::GlobalSystemMediaTransportControlsSessionTimelineProperties* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* GlobalSystemMediaTransportControlsSessionTimelineProperties_get_EndTime(py::wrapper::Windows::Media::Control::GlobalSystemMediaTransportControlsSessionTimelineProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Control.GlobalSystemMediaTransportControlsSessionTimelineProperties", L"EndTime");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.EndTime();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GlobalSystemMediaTransportControlsSessionTimelineProperties_get_LastUpdatedTime(py::wrapper::Windows::Media::Control::GlobalSystemMediaTransportControlsSessionTimelineProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Control.GlobalSystemMediaTransportControlsSessionTimelineProperties", L"LastUpdatedTime");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.LastUpdatedTime();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GlobalSystemMediaTransportControlsSessionTimelineProperties_get_MaxSeekTime(py::wrapper::Windows::Media::Control::GlobalSystemMediaTransportControlsSessionTimelineProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Control.GlobalSystemMediaTransportControlsSessionTimelineProperties", L"MaxSeekTime");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.MaxSeekTime();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GlobalSystemMediaTransportControlsSessionTimelineProperties_get_MinSeekTime(py::wrapper::Windows::Media::Control::GlobalSystemMediaTransportControlsSessionTimelineProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Control.GlobalSystemMediaTransportControlsSessionTimelineProperties", L"MinSeekTime");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.MinSeekTime();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GlobalSystemMediaTransportControlsSessionTimelineProperties_get_Position(py::wrapper::Windows::Media::Control::GlobalSystemMediaTransportControlsSessionTimelineProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Control.GlobalSystemMediaTransportControlsSessionTimelineProperties", L"Position");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Position();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GlobalSystemMediaTransportControlsSessionTimelineProperties_get_StartTime(py::wrapper::Windows::Media::Control::GlobalSystemMediaTransportControlsSessionTimelineProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Control.GlobalSystemMediaTransportControlsSessionTimelineProperties", L"StartTime");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.StartTime();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_GlobalSystemMediaTransportControlsSessionTimelineProperties(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Control::GlobalSystemMediaTransportControlsSessionTimelineProperties>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_GlobalSystemMediaTransportControlsSessionTimelineProperties(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Control::GlobalSystemMediaTransportControlsSessionTimelineProperties>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_GlobalSystemMediaTransportControlsSessionTimelineProperties[] = {
        { "_assign_array_", _assign_array_GlobalSystemMediaTransportControlsSessionTimelineProperties, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_GlobalSystemMediaTransportControlsSessionTimelineProperties), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_GlobalSystemMediaTransportControlsSessionTimelineProperties[] = {
        { "end_time", reinterpret_cast<getter>(GlobalSystemMediaTransportControlsSessionTimelineProperties_get_EndTime), nullptr, nullptr, nullptr },
        { "last_updated_time", reinterpret_cast<getter>(GlobalSystemMediaTransportControlsSessionTimelineProperties_get_LastUpdatedTime), nullptr, nullptr, nullptr },
        { "max_seek_time", reinterpret_cast<getter>(GlobalSystemMediaTransportControlsSessionTimelineProperties_get_MaxSeekTime), nullptr, nullptr, nullptr },
        { "min_seek_time", reinterpret_cast<getter>(GlobalSystemMediaTransportControlsSessionTimelineProperties_get_MinSeekTime), nullptr, nullptr, nullptr },
        { "position", reinterpret_cast<getter>(GlobalSystemMediaTransportControlsSessionTimelineProperties_get_Position), nullptr, nullptr, nullptr },
        { "start_time", reinterpret_cast<getter>(GlobalSystemMediaTransportControlsSessionTimelineProperties_get_StartTime), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_GlobalSystemMediaTransportControlsSessionTimelineProperties[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_GlobalSystemMediaTransportControlsSessionTimelineProperties) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_GlobalSystemMediaTransportControlsSessionTimelineProperties) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_GlobalSystemMediaTransportControlsSessionTimelineProperties) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_GlobalSystemMediaTransportControlsSessionTimelineProperties) },
        { }};

    static PyType_Spec type_spec_GlobalSystemMediaTransportControlsSessionTimelineProperties = {
        "winrt._winrt_windows_media_control.GlobalSystemMediaTransportControlsSessionTimelineProperties",
        sizeof(py::wrapper::Windows::Media::Control::GlobalSystemMediaTransportControlsSessionTimelineProperties),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_GlobalSystemMediaTransportControlsSessionTimelineProperties};

    // ----- MediaPropertiesChangedEventArgs class --------------------

    static PyObject* _new_MediaPropertiesChangedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Control::MediaPropertiesChangedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Control::MediaPropertiesChangedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_MediaPropertiesChangedEventArgs(py::wrapper::Windows::Media::Control::MediaPropertiesChangedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_MediaPropertiesChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Control::MediaPropertiesChangedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MediaPropertiesChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Control::MediaPropertiesChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaPropertiesChangedEventArgs[] = {
        { "_assign_array_", _assign_array_MediaPropertiesChangedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MediaPropertiesChangedEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_MediaPropertiesChangedEventArgs[] = {
        { }};

    static PyType_Slot _type_slots_MediaPropertiesChangedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_MediaPropertiesChangedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MediaPropertiesChangedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MediaPropertiesChangedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MediaPropertiesChangedEventArgs) },
        { }};

    static PyType_Spec type_spec_MediaPropertiesChangedEventArgs = {
        "winrt._winrt_windows_media_control.MediaPropertiesChangedEventArgs",
        sizeof(py::wrapper::Windows::Media::Control::MediaPropertiesChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaPropertiesChangedEventArgs};

    // ----- PlaybackInfoChangedEventArgs class --------------------

    static PyObject* _new_PlaybackInfoChangedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Control::PlaybackInfoChangedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Control::PlaybackInfoChangedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_PlaybackInfoChangedEventArgs(py::wrapper::Windows::Media::Control::PlaybackInfoChangedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_PlaybackInfoChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Control::PlaybackInfoChangedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PlaybackInfoChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Control::PlaybackInfoChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PlaybackInfoChangedEventArgs[] = {
        { "_assign_array_", _assign_array_PlaybackInfoChangedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PlaybackInfoChangedEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_PlaybackInfoChangedEventArgs[] = {
        { }};

    static PyType_Slot _type_slots_PlaybackInfoChangedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PlaybackInfoChangedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PlaybackInfoChangedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PlaybackInfoChangedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PlaybackInfoChangedEventArgs) },
        { }};

    static PyType_Spec type_spec_PlaybackInfoChangedEventArgs = {
        "winrt._winrt_windows_media_control.PlaybackInfoChangedEventArgs",
        sizeof(py::wrapper::Windows::Media::Control::PlaybackInfoChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PlaybackInfoChangedEventArgs};

    // ----- SessionsChangedEventArgs class --------------------

    static PyObject* _new_SessionsChangedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Control::SessionsChangedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Control::SessionsChangedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_SessionsChangedEventArgs(py::wrapper::Windows::Media::Control::SessionsChangedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_SessionsChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Control::SessionsChangedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SessionsChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Control::SessionsChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SessionsChangedEventArgs[] = {
        { "_assign_array_", _assign_array_SessionsChangedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SessionsChangedEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_SessionsChangedEventArgs[] = {
        { }};

    static PyType_Slot _type_slots_SessionsChangedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_SessionsChangedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SessionsChangedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SessionsChangedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SessionsChangedEventArgs) },
        { }};

    static PyType_Spec type_spec_SessionsChangedEventArgs = {
        "winrt._winrt_windows_media_control.SessionsChangedEventArgs",
        sizeof(py::wrapper::Windows::Media::Control::SessionsChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SessionsChangedEventArgs};

    // ----- TimelinePropertiesChangedEventArgs class --------------------

    static PyObject* _new_TimelinePropertiesChangedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Control::TimelinePropertiesChangedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Control::TimelinePropertiesChangedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_TimelinePropertiesChangedEventArgs(py::wrapper::Windows::Media::Control::TimelinePropertiesChangedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_TimelinePropertiesChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Control::TimelinePropertiesChangedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_TimelinePropertiesChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Control::TimelinePropertiesChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TimelinePropertiesChangedEventArgs[] = {
        { "_assign_array_", _assign_array_TimelinePropertiesChangedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_TimelinePropertiesChangedEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_TimelinePropertiesChangedEventArgs[] = {
        { }};

    static PyType_Slot _type_slots_TimelinePropertiesChangedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_TimelinePropertiesChangedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_TimelinePropertiesChangedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_TimelinePropertiesChangedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_TimelinePropertiesChangedEventArgs) },
        { }};

    static PyType_Spec type_spec_TimelinePropertiesChangedEventArgs = {
        "winrt._winrt_windows_media_control.TimelinePropertiesChangedEventArgs",
        sizeof(py::wrapper::Windows::Media::Control::TimelinePropertiesChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TimelinePropertiesChangedEventArgs};

    // ----- Windows.Media.Control Initialization --------------------

    PyDoc_STRVAR(module_doc, "Windows.Media.Control");

    static PyModuleDef module_def = {
        PyModuleDef_HEAD_INIT,
        "_winrt_windows_media_control",
        module_doc,
        0,
        nullptr,
        nullptr,
        nullptr,
        nullptr,
        nullptr};
} // py::cpp::Windows::Media::Control

PyMODINIT_FUNC PyInit__winrt_windows_media_control(void) noexcept
{
    using namespace py::cpp::Windows::Media::Control;

    if (py::import_winrt_runtime() == -1)
    {
        return nullptr;
    }

    py::pyobj_handle module{PyModule_Create(&module_def)};

    if (!module)
    {
        return nullptr;
    }

    auto inspectable_meta_type = py::get_inspectable_meta_type();
    if (!inspectable_meta_type)
    {
        return nullptr;
    }

    auto object_type = py::get_object_type();
    if (!object_type)
    {
        return nullptr;
    }

    py::pyobj_handle object_bases{PyTuple_Pack(1, object_type)};

    if (!object_bases)
    {
        return nullptr;
    }

    py::pytype_handle CurrentSessionChangedEventArgs_type{py::register_python_type(module.get(), &type_spec_CurrentSessionChangedEventArgs, object_bases.get(), inspectable_meta_type)};
    if (!CurrentSessionChangedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle GlobalSystemMediaTransportControlsSession_type{py::register_python_type(module.get(), &type_spec_GlobalSystemMediaTransportControlsSession, object_bases.get(), inspectable_meta_type)};
    if (!GlobalSystemMediaTransportControlsSession_type)
    {
        return nullptr;
    }

    py::pyobj_handle GlobalSystemMediaTransportControlsSessionManager_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(inspectable_meta_type))};
    if (!GlobalSystemMediaTransportControlsSessionManager_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_GlobalSystemMediaTransportControlsSessionManager_Static{PyType_FromSpecWithBases(&type_spec_GlobalSystemMediaTransportControlsSessionManager_Static, GlobalSystemMediaTransportControlsSessionManager_Static_bases.get())};
    if (!type_GlobalSystemMediaTransportControlsSessionManager_Static)
    {
        return nullptr;
    }

    py::pytype_handle GlobalSystemMediaTransportControlsSessionManager_type{py::register_python_type(module.get(), &type_spec_GlobalSystemMediaTransportControlsSessionManager, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_GlobalSystemMediaTransportControlsSessionManager_Static.get()))};
    if (!GlobalSystemMediaTransportControlsSessionManager_type)
    {
        return nullptr;
    }

    py::pytype_handle GlobalSystemMediaTransportControlsSessionMediaProperties_type{py::register_python_type(module.get(), &type_spec_GlobalSystemMediaTransportControlsSessionMediaProperties, object_bases.get(), inspectable_meta_type)};
    if (!GlobalSystemMediaTransportControlsSessionMediaProperties_type)
    {
        return nullptr;
    }

    py::pytype_handle GlobalSystemMediaTransportControlsSessionPlaybackControls_type{py::register_python_type(module.get(), &type_spec_GlobalSystemMediaTransportControlsSessionPlaybackControls, object_bases.get(), inspectable_meta_type)};
    if (!GlobalSystemMediaTransportControlsSessionPlaybackControls_type)
    {
        return nullptr;
    }

    py::pytype_handle GlobalSystemMediaTransportControlsSessionPlaybackInfo_type{py::register_python_type(module.get(), &type_spec_GlobalSystemMediaTransportControlsSessionPlaybackInfo, object_bases.get(), inspectable_meta_type)};
    if (!GlobalSystemMediaTransportControlsSessionPlaybackInfo_type)
    {
        return nullptr;
    }

    py::pytype_handle GlobalSystemMediaTransportControlsSessionTimelineProperties_type{py::register_python_type(module.get(), &type_spec_GlobalSystemMediaTransportControlsSessionTimelineProperties, object_bases.get(), inspectable_meta_type)};
    if (!GlobalSystemMediaTransportControlsSessionTimelineProperties_type)
    {
        return nullptr;
    }

    py::pytype_handle MediaPropertiesChangedEventArgs_type{py::register_python_type(module.get(), &type_spec_MediaPropertiesChangedEventArgs, object_bases.get(), inspectable_meta_type)};
    if (!MediaPropertiesChangedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle PlaybackInfoChangedEventArgs_type{py::register_python_type(module.get(), &type_spec_PlaybackInfoChangedEventArgs, object_bases.get(), inspectable_meta_type)};
    if (!PlaybackInfoChangedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle SessionsChangedEventArgs_type{py::register_python_type(module.get(), &type_spec_SessionsChangedEventArgs, object_bases.get(), inspectable_meta_type)};
    if (!SessionsChangedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle TimelinePropertiesChangedEventArgs_type{py::register_python_type(module.get(), &type_spec_TimelinePropertiesChangedEventArgs, object_bases.get(), inspectable_meta_type)};
    if (!TimelinePropertiesChangedEventArgs_type)
    {
        return nullptr;
    }


    return module.detach();
}
