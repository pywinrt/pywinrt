// WARNING: Please don't edit this file. It was generated by Python/WinRT v3.2.1

#include "py.Windows.Graphics.h"

namespace py::cpp::Windows::Graphics
{
    // ----- IGeometrySource2D interface --------------------

    #if PY_VERSION_HEX < 0x030A0000
    static PyObject* _new_IGeometrySource2D(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Graphics::IGeometrySource2D>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Graphics::IGeometrySource2D>::type_name);
        return nullptr;
    }
    #endif

    static void _dealloc_IGeometrySource2D(py::wrapper::Windows::Graphics::IGeometrySource2D* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyMethodDef _methods_IGeometrySource2D[] = {
        { }};

    static PyGetSetDef _getset_IGeometrySource2D[] = {
        { }};

    static PyType_Slot _type_slots_IGeometrySource2D[] = {
        #if PY_VERSION_HEX < 0x030A0000
        { Py_tp_new, reinterpret_cast<void*>(_new_IGeometrySource2D) },
        #endif
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IGeometrySource2D) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IGeometrySource2D) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IGeometrySource2D) },
        { }};

    static PyType_Spec type_spec_IGeometrySource2D = {
        "winrt._winrt_windows_graphics._IGeometrySource2D",
        sizeof(py::wrapper::Windows::Graphics::IGeometrySource2D),
        0,
        Py_TPFLAGS_DEFAULT
        #if PY_VERSION_HEX >= 0x030A0000
        | Py_TPFLAGS_DISALLOW_INSTANTIATION
        #endif
        ,
        _type_slots_IGeometrySource2D};

    struct ImplementsIGeometrySource2D : py::ImplementsInterfaceT<ImplementsIGeometrySource2D, winrt::Windows::Graphics::IGeometrySource2D>
    {
        ImplementsIGeometrySource2D() = delete;
        ImplementsIGeometrySource2D(PyObject* py_obj, winrt::impl::inspectable_abi* runtime_class) : py::ImplementsInterfaceT<ImplementsIGeometrySource2D, winrt::Windows::Graphics::IGeometrySource2D>(py_obj, runtime_class)
        {
        }
    };

    static PyObject* _assign_array_IGeometrySource2D(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Graphics::IGeometrySource2D>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IGeometrySource2D(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Graphics::IGeometrySource2D>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _guid_ImplementsIGeometrySource2D(PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::guid_of<winrt::Windows::Graphics::IGeometrySource2D>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _make_ImplementsIGeometrySource2D(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            PyObject* py_obj;
            winrt::impl::inspectable_abi* runtime_class;

            if (!PyArg_ParseTuple(args, "On", &py_obj, &runtime_class))
            {
                return nullptr;
            }

            auto iface{std::make_unique<ImplementsIGeometrySource2D>(py_obj, runtime_class)};

            return PyLong_FromVoidPtr(iface.release());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef methods_ImplementsIGeometrySource2D[] = {
        { "_assign_array_", _assign_array_IGeometrySource2D, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IGeometrySource2D), METH_O | METH_STATIC, nullptr },
        { "_guid_", reinterpret_cast<PyCFunction>(_guid_ImplementsIGeometrySource2D), METH_NOARGS | METH_STATIC, nullptr },
        { "_make_", reinterpret_cast<PyCFunction>(_make_ImplementsIGeometrySource2D), METH_VARARGS | METH_STATIC, nullptr },
        { }};

    static PyType_Slot type_slots_ImplementsIGeometrySource2D[] = {
        { Py_tp_methods, reinterpret_cast<void*>(methods_ImplementsIGeometrySource2D) },
        { }};

    static PyType_Spec type_spec_ImplementsIGeometrySource2D = {
        "winrt._winrt_windows_graphics.IGeometrySource2D",
        0,
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE
        #if PY_VERSION_HEX >= 0x030A0000
        | Py_TPFLAGS_DISALLOW_INSTANTIATION
        #endif
        ,
        type_slots_ImplementsIGeometrySource2D};

    // ----- DisplayAdapterId struct --------------------

    winrt::Windows::Graphics::DisplayAdapterId DisplayAdapterId_from_tuple(PyObject* tuple)
    {
        if (PyTuple_GET_SIZE(tuple) != 2)
        {
            PyErr_SetString(PyExc_TypeError, "Incorrect number of fields");
            throw python_exception();
        }

        winrt::Windows::Graphics::DisplayAdapterId result{};

        result.LowPart = py::convert_to<uint32_t>(tuple, 0);
        result.HighPart = py::convert_to<int32_t>(tuple, 1);

        return result;
    }

    PyObject* _new_DisplayAdapterId(PyTypeObject* subclass, PyObject* args, PyObject* kwds) noexcept
    {
        pyobj_handle self_obj{(subclass->tp_alloc(subclass, 0))};
        if (!self_obj)
        {
            return nullptr;
        }

        auto self = reinterpret_cast<winrt_struct_wrapper<winrt::Windows::Graphics::DisplayAdapterId>*>(self_obj.get());
        std::construct_at(&self->obj);

        auto tuple_size = PyTuple_GET_SIZE(args);
        if ((tuple_size == 0) && (!kwds))
        {
            return self_obj.detach();
        }

        uint32_t _LowPart{};
        int32_t _HighPart{};

        static const char* kwlist[] = {"low_part", "high_part", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "|Ii", const_cast<char**>(kwlist), &_LowPart, &_HighPart))
        {
            return nullptr;
        }

        try
        {
            self->obj.LowPart = _LowPart;
            self->obj.HighPart = _HighPart;

            return self_obj.detach();
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static void _dealloc_DisplayAdapterId(py::wrapper::Windows::Graphics::DisplayAdapterId* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_DisplayAdapterId(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Graphics::DisplayAdapterId>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    PyObject* _replace_DisplayAdapterId(py::wrapper::Windows::Graphics::DisplayAdapterId* self, PyObject* args, PyObject* kwds) noexcept
    {
        try
        {
            uint32_t _LowPart{self->obj.LowPart};
            int32_t _HighPart{self->obj.HighPart};

            static const char* kwlist[] = {"low_part", "high_part", nullptr};
            if (!PyArg_ParseTupleAndKeywords(args, kwds, "|$Ii", const_cast<char**>(kwlist), &_LowPart, &_HighPart))
            {
                return nullptr;
            }

            auto copy = self->obj;
            copy.LowPart = _LowPart;
            copy.HighPart = _HighPart;

            return convert(copy);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    PyObject* unpack_DisplayAdapterId(py::wrapper::Windows::Graphics::DisplayAdapterId* self, PyObject* /*unused*/) noexcept
    {
        py::pyobj_handle LowPart{convert(self->obj.LowPart)};
        if (!LowPart)
        {
            return nullptr;
        }

        py::pyobj_handle HighPart{convert(self->obj.HighPart)};
        if (!HighPart)
        {
            return nullptr;
        }

        pyobj_handle tuple{PyTuple_New(2)};
        if (!tuple)
        {
            return nullptr;
        }

        PyTuple_SET_ITEM(tuple.get(), 0, LowPart.detach());
        PyTuple_SET_ITEM(tuple.get(), 1, HighPart.detach());

        return tuple.detach();
    }

    static PyMethodDef _methods_DisplayAdapterId[] = {
        { "_assign_array_", _assign_array_DisplayAdapterId, METH_O | METH_STATIC, nullptr },
        { "__replace__", reinterpret_cast<PyCFunction>(reinterpret_cast<void*>(_replace_DisplayAdapterId)), METH_VARARGS | METH_KEYWORDS, nullptr },
        { "unpack", reinterpret_cast<PyCFunction>(unpack_DisplayAdapterId), METH_NOARGS, nullptr },
        { }};

    static PyObject* DisplayAdapterId_get_LowPart(py::wrapper::Windows::Graphics::DisplayAdapterId* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.LowPart);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DisplayAdapterId_get_HighPart(py::wrapper::Windows::Graphics::DisplayAdapterId* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.HighPart);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyGetSetDef _getset_DisplayAdapterId[] = {
        { "low_part", reinterpret_cast<getter>(DisplayAdapterId_get_LowPart), nullptr, nullptr, nullptr },
        { "high_part", reinterpret_cast<getter>(DisplayAdapterId_get_HighPart), nullptr, nullptr, nullptr },
        { }};

    static PyObject* _richcompare_DisplayAdapterId(py::wrapper::Windows::Graphics::DisplayAdapterId* self, PyObject* other, int op) noexcept
    {
        try
        {
            auto _other = py::convert_to<winrt::Windows::Graphics::DisplayAdapterId>(other);

            if (op == Py_EQ)
            {
                if (self->obj == _other)
                {
                    Py_RETURN_TRUE;
                }

                Py_RETURN_FALSE;
            }

            if (op == Py_NE)
            {
                if (self->obj != _other)
                {
                    Py_RETURN_TRUE;
                }

                Py_RETURN_FALSE;
            }

            Py_RETURN_NOTIMPLEMENTED;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _repr_DisplayAdapterId(PyObject* self) noexcept
    {
        py::pyobj_handle LowPart{PyObject_GetAttrString(self, "low_part")};
        if (!LowPart)
        {
            return nullptr;
        }

        py::pyobj_handle HighPart{PyObject_GetAttrString(self, "high_part")};
        if (!HighPart)
        {
            return nullptr;
        }

        return PyUnicode_FromFormat("DisplayAdapterId(low_part=%R, high_part=%R)", LowPart.get(), HighPart.get());
    }

    static PyType_Slot _type_slots_DisplayAdapterId[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_DisplayAdapterId) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_DisplayAdapterId) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_DisplayAdapterId) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_DisplayAdapterId) },
        { Py_tp_richcompare, reinterpret_cast<void*>(_richcompare_DisplayAdapterId) },
        { Py_tp_repr, reinterpret_cast<void*>(_repr_DisplayAdapterId) },
        { }};

    static PyType_Spec type_spec_DisplayAdapterId = {
        "winrt._winrt_windows_graphics.DisplayAdapterId",
        sizeof(py::wrapper::Windows::Graphics::DisplayAdapterId),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DisplayAdapterId};

    // ----- DisplayId struct --------------------

    winrt::Windows::Graphics::DisplayId DisplayId_from_tuple(PyObject* tuple)
    {
        if (PyTuple_GET_SIZE(tuple) != 1)
        {
            PyErr_SetString(PyExc_TypeError, "Incorrect number of fields");
            throw python_exception();
        }

        winrt::Windows::Graphics::DisplayId result{};

        result.Value = py::convert_to<uint64_t>(tuple, 0);

        return result;
    }

    PyObject* _new_DisplayId(PyTypeObject* subclass, PyObject* args, PyObject* kwds) noexcept
    {
        pyobj_handle self_obj{(subclass->tp_alloc(subclass, 0))};
        if (!self_obj)
        {
            return nullptr;
        }

        auto self = reinterpret_cast<winrt_struct_wrapper<winrt::Windows::Graphics::DisplayId>*>(self_obj.get());
        std::construct_at(&self->obj);

        auto tuple_size = PyTuple_GET_SIZE(args);
        if ((tuple_size == 0) && (!kwds))
        {
            return self_obj.detach();
        }

        uint64_t _Value{};

        static const char* kwlist[] = {"value", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "|K", const_cast<char**>(kwlist), &_Value))
        {
            return nullptr;
        }

        try
        {
            self->obj.Value = _Value;

            return self_obj.detach();
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static void _dealloc_DisplayId(py::wrapper::Windows::Graphics::DisplayId* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_DisplayId(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Graphics::DisplayId>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    PyObject* _replace_DisplayId(py::wrapper::Windows::Graphics::DisplayId* self, PyObject* args, PyObject* kwds) noexcept
    {
        try
        {
            uint64_t _Value{self->obj.Value};

            static const char* kwlist[] = {"value", nullptr};
            if (!PyArg_ParseTupleAndKeywords(args, kwds, "|$K", const_cast<char**>(kwlist), &_Value))
            {
                return nullptr;
            }

            auto copy = self->obj;
            copy.Value = _Value;

            return convert(copy);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DisplayId[] = {
        { "_assign_array_", _assign_array_DisplayId, METH_O | METH_STATIC, nullptr },
        { "__replace__", reinterpret_cast<PyCFunction>(reinterpret_cast<void*>(_replace_DisplayId)), METH_VARARGS | METH_KEYWORDS, nullptr },
        { }};

    static PyObject* DisplayId_get_Value(py::wrapper::Windows::Graphics::DisplayId* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Value);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyGetSetDef _getset_DisplayId[] = {
        { "value", reinterpret_cast<getter>(DisplayId_get_Value), nullptr, nullptr, nullptr },
        { }};

    static PyObject* _richcompare_DisplayId(py::wrapper::Windows::Graphics::DisplayId* self, PyObject* other, int op) noexcept
    {
        try
        {
            auto _other = py::convert_to<winrt::Windows::Graphics::DisplayId>(other);

            if (op == Py_EQ)
            {
                if (self->obj == _other)
                {
                    Py_RETURN_TRUE;
                }

                Py_RETURN_FALSE;
            }

            if (op == Py_NE)
            {
                if (self->obj != _other)
                {
                    Py_RETURN_TRUE;
                }

                Py_RETURN_FALSE;
            }

            Py_RETURN_NOTIMPLEMENTED;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _repr_DisplayId(PyObject* self) noexcept
    {
        py::pyobj_handle Value{PyObject_GetAttrString(self, "value")};
        if (!Value)
        {
            return nullptr;
        }

        return PyUnicode_FromFormat("DisplayId(value=%R)", Value.get());
    }

    static PyType_Slot _type_slots_DisplayId[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_DisplayId) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_DisplayId) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_DisplayId) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_DisplayId) },
        { Py_tp_richcompare, reinterpret_cast<void*>(_richcompare_DisplayId) },
        { Py_tp_repr, reinterpret_cast<void*>(_repr_DisplayId) },
        { }};

    static PyType_Spec type_spec_DisplayId = {
        "winrt._winrt_windows_graphics.DisplayId",
        sizeof(py::wrapper::Windows::Graphics::DisplayId),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DisplayId};

    // ----- PointInt32 struct --------------------

    winrt::Windows::Graphics::PointInt32 PointInt32_from_tuple(PyObject* tuple)
    {
        if (PyTuple_GET_SIZE(tuple) != 2)
        {
            PyErr_SetString(PyExc_TypeError, "Incorrect number of fields");
            throw python_exception();
        }

        winrt::Windows::Graphics::PointInt32 result{};

        result.X = py::convert_to<int32_t>(tuple, 0);
        result.Y = py::convert_to<int32_t>(tuple, 1);

        return result;
    }

    PyObject* _new_PointInt32(PyTypeObject* subclass, PyObject* args, PyObject* kwds) noexcept
    {
        pyobj_handle self_obj{(subclass->tp_alloc(subclass, 0))};
        if (!self_obj)
        {
            return nullptr;
        }

        auto self = reinterpret_cast<winrt_struct_wrapper<winrt::Windows::Graphics::PointInt32>*>(self_obj.get());
        std::construct_at(&self->obj);

        auto tuple_size = PyTuple_GET_SIZE(args);
        if ((tuple_size == 0) && (!kwds))
        {
            return self_obj.detach();
        }

        int32_t _X{};
        int32_t _Y{};

        static const char* kwlist[] = {"x", "y", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "|ii", const_cast<char**>(kwlist), &_X, &_Y))
        {
            return nullptr;
        }

        try
        {
            self->obj.X = _X;
            self->obj.Y = _Y;

            return self_obj.detach();
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static void _dealloc_PointInt32(py::wrapper::Windows::Graphics::PointInt32* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_PointInt32(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Graphics::PointInt32>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    PyObject* _replace_PointInt32(py::wrapper::Windows::Graphics::PointInt32* self, PyObject* args, PyObject* kwds) noexcept
    {
        try
        {
            int32_t _X{self->obj.X};
            int32_t _Y{self->obj.Y};

            static const char* kwlist[] = {"x", "y", nullptr};
            if (!PyArg_ParseTupleAndKeywords(args, kwds, "|$ii", const_cast<char**>(kwlist), &_X, &_Y))
            {
                return nullptr;
            }

            auto copy = self->obj;
            copy.X = _X;
            copy.Y = _Y;

            return convert(copy);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    PyObject* unpack_PointInt32(py::wrapper::Windows::Graphics::PointInt32* self, PyObject* /*unused*/) noexcept
    {
        py::pyobj_handle X{convert(self->obj.X)};
        if (!X)
        {
            return nullptr;
        }

        py::pyobj_handle Y{convert(self->obj.Y)};
        if (!Y)
        {
            return nullptr;
        }

        pyobj_handle tuple{PyTuple_New(2)};
        if (!tuple)
        {
            return nullptr;
        }

        PyTuple_SET_ITEM(tuple.get(), 0, X.detach());
        PyTuple_SET_ITEM(tuple.get(), 1, Y.detach());

        return tuple.detach();
    }

    static PyMethodDef _methods_PointInt32[] = {
        { "_assign_array_", _assign_array_PointInt32, METH_O | METH_STATIC, nullptr },
        { "__replace__", reinterpret_cast<PyCFunction>(reinterpret_cast<void*>(_replace_PointInt32)), METH_VARARGS | METH_KEYWORDS, nullptr },
        { "unpack", reinterpret_cast<PyCFunction>(unpack_PointInt32), METH_NOARGS, nullptr },
        { }};

    static PyObject* PointInt32_get_X(py::wrapper::Windows::Graphics::PointInt32* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.X);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PointInt32_get_Y(py::wrapper::Windows::Graphics::PointInt32* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Y);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyGetSetDef _getset_PointInt32[] = {
        { "x", reinterpret_cast<getter>(PointInt32_get_X), nullptr, nullptr, nullptr },
        { "y", reinterpret_cast<getter>(PointInt32_get_Y), nullptr, nullptr, nullptr },
        { }};

    static PyObject* _richcompare_PointInt32(py::wrapper::Windows::Graphics::PointInt32* self, PyObject* other, int op) noexcept
    {
        try
        {
            auto _other = py::convert_to<winrt::Windows::Graphics::PointInt32>(other);

            if (op == Py_EQ)
            {
                if (self->obj == _other)
                {
                    Py_RETURN_TRUE;
                }

                Py_RETURN_FALSE;
            }

            if (op == Py_NE)
            {
                if (self->obj != _other)
                {
                    Py_RETURN_TRUE;
                }

                Py_RETURN_FALSE;
            }

            Py_RETURN_NOTIMPLEMENTED;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _repr_PointInt32(PyObject* self) noexcept
    {
        py::pyobj_handle X{PyObject_GetAttrString(self, "x")};
        if (!X)
        {
            return nullptr;
        }

        py::pyobj_handle Y{PyObject_GetAttrString(self, "y")};
        if (!Y)
        {
            return nullptr;
        }

        return PyUnicode_FromFormat("PointInt32(x=%R, y=%R)", X.get(), Y.get());
    }

    static PyType_Slot _type_slots_PointInt32[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PointInt32) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PointInt32) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PointInt32) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PointInt32) },
        { Py_tp_richcompare, reinterpret_cast<void*>(_richcompare_PointInt32) },
        { Py_tp_repr, reinterpret_cast<void*>(_repr_PointInt32) },
        { }};

    static PyType_Spec type_spec_PointInt32 = {
        "winrt._winrt_windows_graphics.PointInt32",
        sizeof(py::wrapper::Windows::Graphics::PointInt32),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PointInt32};

    // ----- RectInt32 struct --------------------

    winrt::Windows::Graphics::RectInt32 RectInt32_from_tuple(PyObject* tuple)
    {
        if (PyTuple_GET_SIZE(tuple) != 4)
        {
            PyErr_SetString(PyExc_TypeError, "Incorrect number of fields");
            throw python_exception();
        }

        winrt::Windows::Graphics::RectInt32 result{};

        result.X = py::convert_to<int32_t>(tuple, 0);
        result.Y = py::convert_to<int32_t>(tuple, 1);
        result.Width = py::convert_to<int32_t>(tuple, 2);
        result.Height = py::convert_to<int32_t>(tuple, 3);

        return result;
    }

    PyObject* _new_RectInt32(PyTypeObject* subclass, PyObject* args, PyObject* kwds) noexcept
    {
        pyobj_handle self_obj{(subclass->tp_alloc(subclass, 0))};
        if (!self_obj)
        {
            return nullptr;
        }

        auto self = reinterpret_cast<winrt_struct_wrapper<winrt::Windows::Graphics::RectInt32>*>(self_obj.get());
        std::construct_at(&self->obj);

        auto tuple_size = PyTuple_GET_SIZE(args);
        if ((tuple_size == 0) && (!kwds))
        {
            return self_obj.detach();
        }

        int32_t _X{};
        int32_t _Y{};
        int32_t _Width{};
        int32_t _Height{};

        static const char* kwlist[] = {"x", "y", "width", "height", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "|iiii", const_cast<char**>(kwlist), &_X, &_Y, &_Width, &_Height))
        {
            return nullptr;
        }

        try
        {
            self->obj.X = _X;
            self->obj.Y = _Y;
            self->obj.Width = _Width;
            self->obj.Height = _Height;

            return self_obj.detach();
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static void _dealloc_RectInt32(py::wrapper::Windows::Graphics::RectInt32* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_RectInt32(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Graphics::RectInt32>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    PyObject* _replace_RectInt32(py::wrapper::Windows::Graphics::RectInt32* self, PyObject* args, PyObject* kwds) noexcept
    {
        try
        {
            int32_t _X{self->obj.X};
            int32_t _Y{self->obj.Y};
            int32_t _Width{self->obj.Width};
            int32_t _Height{self->obj.Height};

            static const char* kwlist[] = {"x", "y", "width", "height", nullptr};
            if (!PyArg_ParseTupleAndKeywords(args, kwds, "|$iiii", const_cast<char**>(kwlist), &_X, &_Y, &_Width, &_Height))
            {
                return nullptr;
            }

            auto copy = self->obj;
            copy.X = _X;
            copy.Y = _Y;
            copy.Width = _Width;
            copy.Height = _Height;

            return convert(copy);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    PyObject* unpack_RectInt32(py::wrapper::Windows::Graphics::RectInt32* self, PyObject* /*unused*/) noexcept
    {
        py::pyobj_handle X{convert(self->obj.X)};
        if (!X)
        {
            return nullptr;
        }

        py::pyobj_handle Y{convert(self->obj.Y)};
        if (!Y)
        {
            return nullptr;
        }

        py::pyobj_handle Width{convert(self->obj.Width)};
        if (!Width)
        {
            return nullptr;
        }

        py::pyobj_handle Height{convert(self->obj.Height)};
        if (!Height)
        {
            return nullptr;
        }

        pyobj_handle tuple{PyTuple_New(4)};
        if (!tuple)
        {
            return nullptr;
        }

        PyTuple_SET_ITEM(tuple.get(), 0, X.detach());
        PyTuple_SET_ITEM(tuple.get(), 1, Y.detach());
        PyTuple_SET_ITEM(tuple.get(), 2, Width.detach());
        PyTuple_SET_ITEM(tuple.get(), 3, Height.detach());

        return tuple.detach();
    }

    static PyMethodDef _methods_RectInt32[] = {
        { "_assign_array_", _assign_array_RectInt32, METH_O | METH_STATIC, nullptr },
        { "__replace__", reinterpret_cast<PyCFunction>(reinterpret_cast<void*>(_replace_RectInt32)), METH_VARARGS | METH_KEYWORDS, nullptr },
        { "unpack", reinterpret_cast<PyCFunction>(unpack_RectInt32), METH_NOARGS, nullptr },
        { }};

    static PyObject* RectInt32_get_X(py::wrapper::Windows::Graphics::RectInt32* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.X);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RectInt32_get_Y(py::wrapper::Windows::Graphics::RectInt32* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Y);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RectInt32_get_Width(py::wrapper::Windows::Graphics::RectInt32* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Width);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RectInt32_get_Height(py::wrapper::Windows::Graphics::RectInt32* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Height);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyGetSetDef _getset_RectInt32[] = {
        { "x", reinterpret_cast<getter>(RectInt32_get_X), nullptr, nullptr, nullptr },
        { "y", reinterpret_cast<getter>(RectInt32_get_Y), nullptr, nullptr, nullptr },
        { "width", reinterpret_cast<getter>(RectInt32_get_Width), nullptr, nullptr, nullptr },
        { "height", reinterpret_cast<getter>(RectInt32_get_Height), nullptr, nullptr, nullptr },
        { }};

    static PyObject* _richcompare_RectInt32(py::wrapper::Windows::Graphics::RectInt32* self, PyObject* other, int op) noexcept
    {
        try
        {
            auto _other = py::convert_to<winrt::Windows::Graphics::RectInt32>(other);

            if (op == Py_EQ)
            {
                if (self->obj == _other)
                {
                    Py_RETURN_TRUE;
                }

                Py_RETURN_FALSE;
            }

            if (op == Py_NE)
            {
                if (self->obj != _other)
                {
                    Py_RETURN_TRUE;
                }

                Py_RETURN_FALSE;
            }

            Py_RETURN_NOTIMPLEMENTED;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _repr_RectInt32(PyObject* self) noexcept
    {
        py::pyobj_handle X{PyObject_GetAttrString(self, "x")};
        if (!X)
        {
            return nullptr;
        }

        py::pyobj_handle Y{PyObject_GetAttrString(self, "y")};
        if (!Y)
        {
            return nullptr;
        }

        py::pyobj_handle Width{PyObject_GetAttrString(self, "width")};
        if (!Width)
        {
            return nullptr;
        }

        py::pyobj_handle Height{PyObject_GetAttrString(self, "height")};
        if (!Height)
        {
            return nullptr;
        }

        return PyUnicode_FromFormat("RectInt32(x=%R, y=%R, width=%R, height=%R)", X.get(), Y.get(), Width.get(), Height.get());
    }

    static PyType_Slot _type_slots_RectInt32[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_RectInt32) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_RectInt32) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_RectInt32) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_RectInt32) },
        { Py_tp_richcompare, reinterpret_cast<void*>(_richcompare_RectInt32) },
        { Py_tp_repr, reinterpret_cast<void*>(_repr_RectInt32) },
        { }};

    static PyType_Spec type_spec_RectInt32 = {
        "winrt._winrt_windows_graphics.RectInt32",
        sizeof(py::wrapper::Windows::Graphics::RectInt32),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RectInt32};

    // ----- SizeInt32 struct --------------------

    winrt::Windows::Graphics::SizeInt32 SizeInt32_from_tuple(PyObject* tuple)
    {
        if (PyTuple_GET_SIZE(tuple) != 2)
        {
            PyErr_SetString(PyExc_TypeError, "Incorrect number of fields");
            throw python_exception();
        }

        winrt::Windows::Graphics::SizeInt32 result{};

        result.Width = py::convert_to<int32_t>(tuple, 0);
        result.Height = py::convert_to<int32_t>(tuple, 1);

        return result;
    }

    PyObject* _new_SizeInt32(PyTypeObject* subclass, PyObject* args, PyObject* kwds) noexcept
    {
        pyobj_handle self_obj{(subclass->tp_alloc(subclass, 0))};
        if (!self_obj)
        {
            return nullptr;
        }

        auto self = reinterpret_cast<winrt_struct_wrapper<winrt::Windows::Graphics::SizeInt32>*>(self_obj.get());
        std::construct_at(&self->obj);

        auto tuple_size = PyTuple_GET_SIZE(args);
        if ((tuple_size == 0) && (!kwds))
        {
            return self_obj.detach();
        }

        int32_t _Width{};
        int32_t _Height{};

        static const char* kwlist[] = {"width", "height", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "|ii", const_cast<char**>(kwlist), &_Width, &_Height))
        {
            return nullptr;
        }

        try
        {
            self->obj.Width = _Width;
            self->obj.Height = _Height;

            return self_obj.detach();
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static void _dealloc_SizeInt32(py::wrapper::Windows::Graphics::SizeInt32* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_SizeInt32(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Graphics::SizeInt32>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    PyObject* _replace_SizeInt32(py::wrapper::Windows::Graphics::SizeInt32* self, PyObject* args, PyObject* kwds) noexcept
    {
        try
        {
            int32_t _Width{self->obj.Width};
            int32_t _Height{self->obj.Height};

            static const char* kwlist[] = {"width", "height", nullptr};
            if (!PyArg_ParseTupleAndKeywords(args, kwds, "|$ii", const_cast<char**>(kwlist), &_Width, &_Height))
            {
                return nullptr;
            }

            auto copy = self->obj;
            copy.Width = _Width;
            copy.Height = _Height;

            return convert(copy);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    PyObject* unpack_SizeInt32(py::wrapper::Windows::Graphics::SizeInt32* self, PyObject* /*unused*/) noexcept
    {
        py::pyobj_handle Width{convert(self->obj.Width)};
        if (!Width)
        {
            return nullptr;
        }

        py::pyobj_handle Height{convert(self->obj.Height)};
        if (!Height)
        {
            return nullptr;
        }

        pyobj_handle tuple{PyTuple_New(2)};
        if (!tuple)
        {
            return nullptr;
        }

        PyTuple_SET_ITEM(tuple.get(), 0, Width.detach());
        PyTuple_SET_ITEM(tuple.get(), 1, Height.detach());

        return tuple.detach();
    }

    static PyMethodDef _methods_SizeInt32[] = {
        { "_assign_array_", _assign_array_SizeInt32, METH_O | METH_STATIC, nullptr },
        { "__replace__", reinterpret_cast<PyCFunction>(reinterpret_cast<void*>(_replace_SizeInt32)), METH_VARARGS | METH_KEYWORDS, nullptr },
        { "unpack", reinterpret_cast<PyCFunction>(unpack_SizeInt32), METH_NOARGS, nullptr },
        { }};

    static PyObject* SizeInt32_get_Width(py::wrapper::Windows::Graphics::SizeInt32* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Width);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SizeInt32_get_Height(py::wrapper::Windows::Graphics::SizeInt32* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Height);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyGetSetDef _getset_SizeInt32[] = {
        { "width", reinterpret_cast<getter>(SizeInt32_get_Width), nullptr, nullptr, nullptr },
        { "height", reinterpret_cast<getter>(SizeInt32_get_Height), nullptr, nullptr, nullptr },
        { }};

    static PyObject* _richcompare_SizeInt32(py::wrapper::Windows::Graphics::SizeInt32* self, PyObject* other, int op) noexcept
    {
        try
        {
            auto _other = py::convert_to<winrt::Windows::Graphics::SizeInt32>(other);

            if (op == Py_EQ)
            {
                if (self->obj == _other)
                {
                    Py_RETURN_TRUE;
                }

                Py_RETURN_FALSE;
            }

            if (op == Py_NE)
            {
                if (self->obj != _other)
                {
                    Py_RETURN_TRUE;
                }

                Py_RETURN_FALSE;
            }

            Py_RETURN_NOTIMPLEMENTED;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _repr_SizeInt32(PyObject* self) noexcept
    {
        py::pyobj_handle Width{PyObject_GetAttrString(self, "width")};
        if (!Width)
        {
            return nullptr;
        }

        py::pyobj_handle Height{PyObject_GetAttrString(self, "height")};
        if (!Height)
        {
            return nullptr;
        }

        return PyUnicode_FromFormat("SizeInt32(width=%R, height=%R)", Width.get(), Height.get());
    }

    static PyType_Slot _type_slots_SizeInt32[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_SizeInt32) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SizeInt32) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SizeInt32) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SizeInt32) },
        { Py_tp_richcompare, reinterpret_cast<void*>(_richcompare_SizeInt32) },
        { Py_tp_repr, reinterpret_cast<void*>(_repr_SizeInt32) },
        { }};

    static PyType_Spec type_spec_SizeInt32 = {
        "winrt._winrt_windows_graphics.SizeInt32",
        sizeof(py::wrapper::Windows::Graphics::SizeInt32),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SizeInt32};

    // ----- Windows.Graphics Initialization --------------------

    PyDoc_STRVAR(module_doc, "Windows.Graphics");

    static PyModuleDef module_def = {
        PyModuleDef_HEAD_INIT,
        "_winrt_windows_graphics",
        module_doc,
        0,
        nullptr,
        nullptr,
        nullptr,
        nullptr,
        nullptr};
} // py::cpp::Windows::Graphics

PyMODINIT_FUNC PyInit__winrt_windows_graphics(void) noexcept
{
    using namespace py::cpp::Windows::Graphics;

    if (py::import_winrt_runtime() == -1)
    {
        return nullptr;
    }

    py::pyobj_handle module{PyModule_Create(&module_def)};

    if (!module)
    {
        return nullptr;
    }

    auto inspectable_meta_type = py::get_inspectable_meta_type();
    if (!inspectable_meta_type)
    {
        return nullptr;
    }

    auto object_type = py::get_object_type();
    if (!object_type)
    {
        return nullptr;
    }

    py::pyobj_handle object_bases{PyTuple_Pack(1, object_type)};

    if (!object_bases)
    {
        return nullptr;
    }

    py::pytype_handle IGeometrySource2D_type{py::register_python_type(module.get(), &type_spec_IGeometrySource2D, object_bases.get(), nullptr)};
    if (!IGeometrySource2D_type)
    {
        return nullptr;
    }

    py::pytype_handle ImplementsIGeometrySource2D_type{py::register_python_type(module.get(), &type_spec_ImplementsIGeometrySource2D, nullptr, inspectable_meta_type)};
    if (!ImplementsIGeometrySource2D_type)
    {
        return nullptr;
    }

    if (PyModule_AddType(module.get(), ImplementsIGeometrySource2D_type.get()) == -1)
    {
        return nullptr;
    }

    py::pytype_handle DisplayAdapterId_type{py::register_python_type(module.get(), &type_spec_DisplayAdapterId, nullptr, nullptr)};
    if (!DisplayAdapterId_type)
    {
        return nullptr;
    }

    py::pyobj_handle DisplayAdapterId_from_tuple_capsule{PyCapsule_New(reinterpret_cast<void*>(DisplayAdapterId_from_tuple),"winrt._winrt_windows_graphics.DisplayAdapterId_from_tuple", nullptr)};
    if (!DisplayAdapterId_from_tuple_capsule)
    {
        return nullptr;
    }

    if (PyModule_AddObjectRef(module.get(), "DisplayAdapterId_from_tuple", DisplayAdapterId_from_tuple_capsule.get()) == -1)
    {
        return nullptr;
    }
    py::pytype_handle DisplayId_type{py::register_python_type(module.get(), &type_spec_DisplayId, nullptr, nullptr)};
    if (!DisplayId_type)
    {
        return nullptr;
    }

    py::pyobj_handle DisplayId_from_tuple_capsule{PyCapsule_New(reinterpret_cast<void*>(DisplayId_from_tuple),"winrt._winrt_windows_graphics.DisplayId_from_tuple", nullptr)};
    if (!DisplayId_from_tuple_capsule)
    {
        return nullptr;
    }

    if (PyModule_AddObjectRef(module.get(), "DisplayId_from_tuple", DisplayId_from_tuple_capsule.get()) == -1)
    {
        return nullptr;
    }
    py::pytype_handle PointInt32_type{py::register_python_type(module.get(), &type_spec_PointInt32, nullptr, nullptr)};
    if (!PointInt32_type)
    {
        return nullptr;
    }

    py::pyobj_handle PointInt32_from_tuple_capsule{PyCapsule_New(reinterpret_cast<void*>(PointInt32_from_tuple),"winrt._winrt_windows_graphics.PointInt32_from_tuple", nullptr)};
    if (!PointInt32_from_tuple_capsule)
    {
        return nullptr;
    }

    if (PyModule_AddObjectRef(module.get(), "PointInt32_from_tuple", PointInt32_from_tuple_capsule.get()) == -1)
    {
        return nullptr;
    }
    py::pytype_handle RectInt32_type{py::register_python_type(module.get(), &type_spec_RectInt32, nullptr, nullptr)};
    if (!RectInt32_type)
    {
        return nullptr;
    }

    py::pyobj_handle RectInt32_from_tuple_capsule{PyCapsule_New(reinterpret_cast<void*>(RectInt32_from_tuple),"winrt._winrt_windows_graphics.RectInt32_from_tuple", nullptr)};
    if (!RectInt32_from_tuple_capsule)
    {
        return nullptr;
    }

    if (PyModule_AddObjectRef(module.get(), "RectInt32_from_tuple", RectInt32_from_tuple_capsule.get()) == -1)
    {
        return nullptr;
    }
    py::pytype_handle SizeInt32_type{py::register_python_type(module.get(), &type_spec_SizeInt32, nullptr, nullptr)};
    if (!SizeInt32_type)
    {
        return nullptr;
    }

    py::pyobj_handle SizeInt32_from_tuple_capsule{PyCapsule_New(reinterpret_cast<void*>(SizeInt32_from_tuple),"winrt._winrt_windows_graphics.SizeInt32_from_tuple", nullptr)};
    if (!SizeInt32_from_tuple_capsule)
    {
        return nullptr;
    }

    if (PyModule_AddObjectRef(module.get(), "SizeInt32_from_tuple", SizeInt32_from_tuple_capsule.get()) == -1)
    {
        return nullptr;
    }

    return module.detach();
}
