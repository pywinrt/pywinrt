// WARNING: Please don't edit this file. It was generated by Python/WinRT v3.2.1

#include "py.Windows.Web.Http.Diagnostics.h"

namespace py::cpp::Windows::Web::Http::Diagnostics
{
    // ----- HttpDiagnosticProvider class --------------------

    static PyObject* _new_HttpDiagnosticProvider(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Web::Http::Diagnostics::HttpDiagnosticProvider>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Web::Http::Diagnostics::HttpDiagnosticProvider>::type_name);
        return nullptr;
    }

    static void _dealloc_HttpDiagnosticProvider(py::wrapper::Windows::Web::Http::Diagnostics::HttpDiagnosticProvider* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* HttpDiagnosticProvider_CreateFromProcessDiagnosticInfo(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Diagnostics.HttpDiagnosticProvider", L"CreateFromProcessDiagnosticInfo", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::System::Diagnostics::ProcessDiagnosticInfo>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::Web::Http::Diagnostics::HttpDiagnosticProvider::CreateFromProcessDiagnosticInfo(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpDiagnosticProvider_Start(py::wrapper::Windows::Web::Http::Diagnostics::HttpDiagnosticProvider* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Diagnostics.HttpDiagnosticProvider", L"Start", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.Start();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpDiagnosticProvider_Stop(py::wrapper::Windows::Web::Http::Diagnostics::HttpDiagnosticProvider* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Diagnostics.HttpDiagnosticProvider", L"Stop", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.Stop();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpDiagnosticProvider_add_RequestResponseCompleted(py::wrapper::Windows::Web::Http::Diagnostics::HttpDiagnosticProvider* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Web.Http.Diagnostics.HttpDiagnosticProvider", L"RequestResponseCompleted");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Web::Http::Diagnostics::HttpDiagnosticProvider, winrt::Windows::Web::Http::Diagnostics::HttpDiagnosticProviderRequestResponseCompletedEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.RequestResponseCompleted(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HttpDiagnosticProvider_remove_RequestResponseCompleted(py::wrapper::Windows::Web::Http::Diagnostics::HttpDiagnosticProvider* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Web.Http.Diagnostics.HttpDiagnosticProvider", L"RequestResponseCompleted");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.RequestResponseCompleted(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HttpDiagnosticProvider_add_RequestSent(py::wrapper::Windows::Web::Http::Diagnostics::HttpDiagnosticProvider* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Web.Http.Diagnostics.HttpDiagnosticProvider", L"RequestSent");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Web::Http::Diagnostics::HttpDiagnosticProvider, winrt::Windows::Web::Http::Diagnostics::HttpDiagnosticProviderRequestSentEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.RequestSent(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HttpDiagnosticProvider_remove_RequestSent(py::wrapper::Windows::Web::Http::Diagnostics::HttpDiagnosticProvider* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Web.Http.Diagnostics.HttpDiagnosticProvider", L"RequestSent");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.RequestSent(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HttpDiagnosticProvider_add_ResponseReceived(py::wrapper::Windows::Web::Http::Diagnostics::HttpDiagnosticProvider* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Web.Http.Diagnostics.HttpDiagnosticProvider", L"ResponseReceived");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Web::Http::Diagnostics::HttpDiagnosticProvider, winrt::Windows::Web::Http::Diagnostics::HttpDiagnosticProviderResponseReceivedEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ResponseReceived(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HttpDiagnosticProvider_remove_ResponseReceived(py::wrapper::Windows::Web::Http::Diagnostics::HttpDiagnosticProvider* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Web.Http.Diagnostics.HttpDiagnosticProvider", L"ResponseReceived");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.ResponseReceived(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_HttpDiagnosticProvider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Web::Http::Diagnostics::HttpDiagnosticProvider>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_HttpDiagnosticProvider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Web::Http::Diagnostics::HttpDiagnosticProvider>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_HttpDiagnosticProvider[] = {
        { "start", reinterpret_cast<PyCFunction>(HttpDiagnosticProvider_Start), METH_VARARGS, nullptr },
        { "stop", reinterpret_cast<PyCFunction>(HttpDiagnosticProvider_Stop), METH_VARARGS, nullptr },
        { "add_request_response_completed", reinterpret_cast<PyCFunction>(HttpDiagnosticProvider_add_RequestResponseCompleted), METH_O, nullptr },
        { "remove_request_response_completed", reinterpret_cast<PyCFunction>(HttpDiagnosticProvider_remove_RequestResponseCompleted), METH_O, nullptr },
        { "add_request_sent", reinterpret_cast<PyCFunction>(HttpDiagnosticProvider_add_RequestSent), METH_O, nullptr },
        { "remove_request_sent", reinterpret_cast<PyCFunction>(HttpDiagnosticProvider_remove_RequestSent), METH_O, nullptr },
        { "add_response_received", reinterpret_cast<PyCFunction>(HttpDiagnosticProvider_add_ResponseReceived), METH_O, nullptr },
        { "remove_response_received", reinterpret_cast<PyCFunction>(HttpDiagnosticProvider_remove_ResponseReceived), METH_O, nullptr },
        { "_assign_array_", _assign_array_HttpDiagnosticProvider, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_HttpDiagnosticProvider), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_HttpDiagnosticProvider[] = {
        { }};

    static PyType_Slot _type_slots_HttpDiagnosticProvider[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_HttpDiagnosticProvider) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_HttpDiagnosticProvider) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_HttpDiagnosticProvider) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_HttpDiagnosticProvider) },
        { }};

    static PyType_Spec type_spec_HttpDiagnosticProvider = {
        "winrt._winrt_windows_web_http_diagnostics.HttpDiagnosticProvider",
        sizeof(py::wrapper::Windows::Web::Http::Diagnostics::HttpDiagnosticProvider),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_HttpDiagnosticProvider};

    static PyGetSetDef getset_HttpDiagnosticProvider_Static[] = {
        { }};

    static PyMethodDef methods_HttpDiagnosticProvider_Static[] = {
        { "create_from_process_diagnostic_info", reinterpret_cast<PyCFunction>(HttpDiagnosticProvider_CreateFromProcessDiagnosticInfo), METH_VARARGS, nullptr },
        { }};

    static PyType_Slot type_slots_HttpDiagnosticProvider_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_HttpDiagnosticProvider_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_HttpDiagnosticProvider_Static) },
        { }
    };

    static PyType_Spec type_spec_HttpDiagnosticProvider_Static = {
        "winrt._winrt_windows_web_http_diagnostics.HttpDiagnosticProvider_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_HttpDiagnosticProvider_Static};

    // ----- HttpDiagnosticProviderRequestResponseCompletedEventArgs class --------------------

    static PyObject* _new_HttpDiagnosticProviderRequestResponseCompletedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Web::Http::Diagnostics::HttpDiagnosticProviderRequestResponseCompletedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Web::Http::Diagnostics::HttpDiagnosticProviderRequestResponseCompletedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_HttpDiagnosticProviderRequestResponseCompletedEventArgs(py::wrapper::Windows::Web::Http::Diagnostics::HttpDiagnosticProviderRequestResponseCompletedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* HttpDiagnosticProviderRequestResponseCompletedEventArgs_get_ActivityId(py::wrapper::Windows::Web::Http::Diagnostics::HttpDiagnosticProviderRequestResponseCompletedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.Diagnostics.HttpDiagnosticProviderRequestResponseCompletedEventArgs", L"ActivityId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ActivityId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HttpDiagnosticProviderRequestResponseCompletedEventArgs_get_Initiator(py::wrapper::Windows::Web::Http::Diagnostics::HttpDiagnosticProviderRequestResponseCompletedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.Diagnostics.HttpDiagnosticProviderRequestResponseCompletedEventArgs", L"Initiator");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Initiator();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HttpDiagnosticProviderRequestResponseCompletedEventArgs_get_ProcessId(py::wrapper::Windows::Web::Http::Diagnostics::HttpDiagnosticProviderRequestResponseCompletedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.Diagnostics.HttpDiagnosticProviderRequestResponseCompletedEventArgs", L"ProcessId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ProcessId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HttpDiagnosticProviderRequestResponseCompletedEventArgs_get_RequestedUri(py::wrapper::Windows::Web::Http::Diagnostics::HttpDiagnosticProviderRequestResponseCompletedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.Diagnostics.HttpDiagnosticProviderRequestResponseCompletedEventArgs", L"RequestedUri");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.RequestedUri();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HttpDiagnosticProviderRequestResponseCompletedEventArgs_get_SourceLocations(py::wrapper::Windows::Web::Http::Diagnostics::HttpDiagnosticProviderRequestResponseCompletedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.Diagnostics.HttpDiagnosticProviderRequestResponseCompletedEventArgs", L"SourceLocations");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SourceLocations();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HttpDiagnosticProviderRequestResponseCompletedEventArgs_get_ThreadId(py::wrapper::Windows::Web::Http::Diagnostics::HttpDiagnosticProviderRequestResponseCompletedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.Diagnostics.HttpDiagnosticProviderRequestResponseCompletedEventArgs", L"ThreadId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ThreadId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HttpDiagnosticProviderRequestResponseCompletedEventArgs_get_Timestamps(py::wrapper::Windows::Web::Http::Diagnostics::HttpDiagnosticProviderRequestResponseCompletedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.Diagnostics.HttpDiagnosticProviderRequestResponseCompletedEventArgs", L"Timestamps");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Timestamps();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_HttpDiagnosticProviderRequestResponseCompletedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Web::Http::Diagnostics::HttpDiagnosticProviderRequestResponseCompletedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_HttpDiagnosticProviderRequestResponseCompletedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Web::Http::Diagnostics::HttpDiagnosticProviderRequestResponseCompletedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_HttpDiagnosticProviderRequestResponseCompletedEventArgs[] = {
        { "_assign_array_", _assign_array_HttpDiagnosticProviderRequestResponseCompletedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_HttpDiagnosticProviderRequestResponseCompletedEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_HttpDiagnosticProviderRequestResponseCompletedEventArgs[] = {
        { "activity_id", reinterpret_cast<getter>(HttpDiagnosticProviderRequestResponseCompletedEventArgs_get_ActivityId), nullptr, nullptr, nullptr },
        { "initiator", reinterpret_cast<getter>(HttpDiagnosticProviderRequestResponseCompletedEventArgs_get_Initiator), nullptr, nullptr, nullptr },
        { "process_id", reinterpret_cast<getter>(HttpDiagnosticProviderRequestResponseCompletedEventArgs_get_ProcessId), nullptr, nullptr, nullptr },
        { "requested_uri", reinterpret_cast<getter>(HttpDiagnosticProviderRequestResponseCompletedEventArgs_get_RequestedUri), nullptr, nullptr, nullptr },
        { "source_locations", reinterpret_cast<getter>(HttpDiagnosticProviderRequestResponseCompletedEventArgs_get_SourceLocations), nullptr, nullptr, nullptr },
        { "thread_id", reinterpret_cast<getter>(HttpDiagnosticProviderRequestResponseCompletedEventArgs_get_ThreadId), nullptr, nullptr, nullptr },
        { "timestamps", reinterpret_cast<getter>(HttpDiagnosticProviderRequestResponseCompletedEventArgs_get_Timestamps), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_HttpDiagnosticProviderRequestResponseCompletedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_HttpDiagnosticProviderRequestResponseCompletedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_HttpDiagnosticProviderRequestResponseCompletedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_HttpDiagnosticProviderRequestResponseCompletedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_HttpDiagnosticProviderRequestResponseCompletedEventArgs) },
        { }};

    static PyType_Spec type_spec_HttpDiagnosticProviderRequestResponseCompletedEventArgs = {
        "winrt._winrt_windows_web_http_diagnostics.HttpDiagnosticProviderRequestResponseCompletedEventArgs",
        sizeof(py::wrapper::Windows::Web::Http::Diagnostics::HttpDiagnosticProviderRequestResponseCompletedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_HttpDiagnosticProviderRequestResponseCompletedEventArgs};

    // ----- HttpDiagnosticProviderRequestResponseTimestamps class --------------------

    static PyObject* _new_HttpDiagnosticProviderRequestResponseTimestamps(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Web::Http::Diagnostics::HttpDiagnosticProviderRequestResponseTimestamps>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Web::Http::Diagnostics::HttpDiagnosticProviderRequestResponseTimestamps>::type_name);
        return nullptr;
    }

    static void _dealloc_HttpDiagnosticProviderRequestResponseTimestamps(py::wrapper::Windows::Web::Http::Diagnostics::HttpDiagnosticProviderRequestResponseTimestamps* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* HttpDiagnosticProviderRequestResponseTimestamps_get_CacheCheckedTimestamp(py::wrapper::Windows::Web::Http::Diagnostics::HttpDiagnosticProviderRequestResponseTimestamps* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.Diagnostics.HttpDiagnosticProviderRequestResponseTimestamps", L"CacheCheckedTimestamp");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.CacheCheckedTimestamp();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HttpDiagnosticProviderRequestResponseTimestamps_get_ConnectionCompletedTimestamp(py::wrapper::Windows::Web::Http::Diagnostics::HttpDiagnosticProviderRequestResponseTimestamps* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.Diagnostics.HttpDiagnosticProviderRequestResponseTimestamps", L"ConnectionCompletedTimestamp");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ConnectionCompletedTimestamp();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HttpDiagnosticProviderRequestResponseTimestamps_get_ConnectionInitiatedTimestamp(py::wrapper::Windows::Web::Http::Diagnostics::HttpDiagnosticProviderRequestResponseTimestamps* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.Diagnostics.HttpDiagnosticProviderRequestResponseTimestamps", L"ConnectionInitiatedTimestamp");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ConnectionInitiatedTimestamp();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HttpDiagnosticProviderRequestResponseTimestamps_get_NameResolvedTimestamp(py::wrapper::Windows::Web::Http::Diagnostics::HttpDiagnosticProviderRequestResponseTimestamps* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.Diagnostics.HttpDiagnosticProviderRequestResponseTimestamps", L"NameResolvedTimestamp");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.NameResolvedTimestamp();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HttpDiagnosticProviderRequestResponseTimestamps_get_RequestCompletedTimestamp(py::wrapper::Windows::Web::Http::Diagnostics::HttpDiagnosticProviderRequestResponseTimestamps* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.Diagnostics.HttpDiagnosticProviderRequestResponseTimestamps", L"RequestCompletedTimestamp");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.RequestCompletedTimestamp();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HttpDiagnosticProviderRequestResponseTimestamps_get_RequestSentTimestamp(py::wrapper::Windows::Web::Http::Diagnostics::HttpDiagnosticProviderRequestResponseTimestamps* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.Diagnostics.HttpDiagnosticProviderRequestResponseTimestamps", L"RequestSentTimestamp");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.RequestSentTimestamp();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HttpDiagnosticProviderRequestResponseTimestamps_get_ResponseCompletedTimestamp(py::wrapper::Windows::Web::Http::Diagnostics::HttpDiagnosticProviderRequestResponseTimestamps* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.Diagnostics.HttpDiagnosticProviderRequestResponseTimestamps", L"ResponseCompletedTimestamp");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ResponseCompletedTimestamp();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HttpDiagnosticProviderRequestResponseTimestamps_get_ResponseReceivedTimestamp(py::wrapper::Windows::Web::Http::Diagnostics::HttpDiagnosticProviderRequestResponseTimestamps* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.Diagnostics.HttpDiagnosticProviderRequestResponseTimestamps", L"ResponseReceivedTimestamp");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ResponseReceivedTimestamp();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HttpDiagnosticProviderRequestResponseTimestamps_get_SslNegotiatedTimestamp(py::wrapper::Windows::Web::Http::Diagnostics::HttpDiagnosticProviderRequestResponseTimestamps* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.Diagnostics.HttpDiagnosticProviderRequestResponseTimestamps", L"SslNegotiatedTimestamp");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SslNegotiatedTimestamp();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_HttpDiagnosticProviderRequestResponseTimestamps(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Web::Http::Diagnostics::HttpDiagnosticProviderRequestResponseTimestamps>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_HttpDiagnosticProviderRequestResponseTimestamps(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Web::Http::Diagnostics::HttpDiagnosticProviderRequestResponseTimestamps>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_HttpDiagnosticProviderRequestResponseTimestamps[] = {
        { "_assign_array_", _assign_array_HttpDiagnosticProviderRequestResponseTimestamps, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_HttpDiagnosticProviderRequestResponseTimestamps), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_HttpDiagnosticProviderRequestResponseTimestamps[] = {
        { "cache_checked_timestamp", reinterpret_cast<getter>(HttpDiagnosticProviderRequestResponseTimestamps_get_CacheCheckedTimestamp), nullptr, nullptr, nullptr },
        { "connection_completed_timestamp", reinterpret_cast<getter>(HttpDiagnosticProviderRequestResponseTimestamps_get_ConnectionCompletedTimestamp), nullptr, nullptr, nullptr },
        { "connection_initiated_timestamp", reinterpret_cast<getter>(HttpDiagnosticProviderRequestResponseTimestamps_get_ConnectionInitiatedTimestamp), nullptr, nullptr, nullptr },
        { "name_resolved_timestamp", reinterpret_cast<getter>(HttpDiagnosticProviderRequestResponseTimestamps_get_NameResolvedTimestamp), nullptr, nullptr, nullptr },
        { "request_completed_timestamp", reinterpret_cast<getter>(HttpDiagnosticProviderRequestResponseTimestamps_get_RequestCompletedTimestamp), nullptr, nullptr, nullptr },
        { "request_sent_timestamp", reinterpret_cast<getter>(HttpDiagnosticProviderRequestResponseTimestamps_get_RequestSentTimestamp), nullptr, nullptr, nullptr },
        { "response_completed_timestamp", reinterpret_cast<getter>(HttpDiagnosticProviderRequestResponseTimestamps_get_ResponseCompletedTimestamp), nullptr, nullptr, nullptr },
        { "response_received_timestamp", reinterpret_cast<getter>(HttpDiagnosticProviderRequestResponseTimestamps_get_ResponseReceivedTimestamp), nullptr, nullptr, nullptr },
        { "ssl_negotiated_timestamp", reinterpret_cast<getter>(HttpDiagnosticProviderRequestResponseTimestamps_get_SslNegotiatedTimestamp), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_HttpDiagnosticProviderRequestResponseTimestamps[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_HttpDiagnosticProviderRequestResponseTimestamps) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_HttpDiagnosticProviderRequestResponseTimestamps) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_HttpDiagnosticProviderRequestResponseTimestamps) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_HttpDiagnosticProviderRequestResponseTimestamps) },
        { }};

    static PyType_Spec type_spec_HttpDiagnosticProviderRequestResponseTimestamps = {
        "winrt._winrt_windows_web_http_diagnostics.HttpDiagnosticProviderRequestResponseTimestamps",
        sizeof(py::wrapper::Windows::Web::Http::Diagnostics::HttpDiagnosticProviderRequestResponseTimestamps),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_HttpDiagnosticProviderRequestResponseTimestamps};

    // ----- HttpDiagnosticProviderRequestSentEventArgs class --------------------

    static PyObject* _new_HttpDiagnosticProviderRequestSentEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Web::Http::Diagnostics::HttpDiagnosticProviderRequestSentEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Web::Http::Diagnostics::HttpDiagnosticProviderRequestSentEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_HttpDiagnosticProviderRequestSentEventArgs(py::wrapper::Windows::Web::Http::Diagnostics::HttpDiagnosticProviderRequestSentEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* HttpDiagnosticProviderRequestSentEventArgs_get_ActivityId(py::wrapper::Windows::Web::Http::Diagnostics::HttpDiagnosticProviderRequestSentEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.Diagnostics.HttpDiagnosticProviderRequestSentEventArgs", L"ActivityId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ActivityId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HttpDiagnosticProviderRequestSentEventArgs_get_Initiator(py::wrapper::Windows::Web::Http::Diagnostics::HttpDiagnosticProviderRequestSentEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.Diagnostics.HttpDiagnosticProviderRequestSentEventArgs", L"Initiator");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Initiator();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HttpDiagnosticProviderRequestSentEventArgs_get_Message(py::wrapper::Windows::Web::Http::Diagnostics::HttpDiagnosticProviderRequestSentEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.Diagnostics.HttpDiagnosticProviderRequestSentEventArgs", L"Message");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Message();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HttpDiagnosticProviderRequestSentEventArgs_get_ProcessId(py::wrapper::Windows::Web::Http::Diagnostics::HttpDiagnosticProviderRequestSentEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.Diagnostics.HttpDiagnosticProviderRequestSentEventArgs", L"ProcessId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ProcessId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HttpDiagnosticProviderRequestSentEventArgs_get_SourceLocations(py::wrapper::Windows::Web::Http::Diagnostics::HttpDiagnosticProviderRequestSentEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.Diagnostics.HttpDiagnosticProviderRequestSentEventArgs", L"SourceLocations");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SourceLocations();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HttpDiagnosticProviderRequestSentEventArgs_get_ThreadId(py::wrapper::Windows::Web::Http::Diagnostics::HttpDiagnosticProviderRequestSentEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.Diagnostics.HttpDiagnosticProviderRequestSentEventArgs", L"ThreadId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ThreadId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HttpDiagnosticProviderRequestSentEventArgs_get_Timestamp(py::wrapper::Windows::Web::Http::Diagnostics::HttpDiagnosticProviderRequestSentEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.Diagnostics.HttpDiagnosticProviderRequestSentEventArgs", L"Timestamp");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Timestamp();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_HttpDiagnosticProviderRequestSentEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Web::Http::Diagnostics::HttpDiagnosticProviderRequestSentEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_HttpDiagnosticProviderRequestSentEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Web::Http::Diagnostics::HttpDiagnosticProviderRequestSentEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_HttpDiagnosticProviderRequestSentEventArgs[] = {
        { "_assign_array_", _assign_array_HttpDiagnosticProviderRequestSentEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_HttpDiagnosticProviderRequestSentEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_HttpDiagnosticProviderRequestSentEventArgs[] = {
        { "activity_id", reinterpret_cast<getter>(HttpDiagnosticProviderRequestSentEventArgs_get_ActivityId), nullptr, nullptr, nullptr },
        { "initiator", reinterpret_cast<getter>(HttpDiagnosticProviderRequestSentEventArgs_get_Initiator), nullptr, nullptr, nullptr },
        { "message", reinterpret_cast<getter>(HttpDiagnosticProviderRequestSentEventArgs_get_Message), nullptr, nullptr, nullptr },
        { "process_id", reinterpret_cast<getter>(HttpDiagnosticProviderRequestSentEventArgs_get_ProcessId), nullptr, nullptr, nullptr },
        { "source_locations", reinterpret_cast<getter>(HttpDiagnosticProviderRequestSentEventArgs_get_SourceLocations), nullptr, nullptr, nullptr },
        { "thread_id", reinterpret_cast<getter>(HttpDiagnosticProviderRequestSentEventArgs_get_ThreadId), nullptr, nullptr, nullptr },
        { "timestamp", reinterpret_cast<getter>(HttpDiagnosticProviderRequestSentEventArgs_get_Timestamp), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_HttpDiagnosticProviderRequestSentEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_HttpDiagnosticProviderRequestSentEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_HttpDiagnosticProviderRequestSentEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_HttpDiagnosticProviderRequestSentEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_HttpDiagnosticProviderRequestSentEventArgs) },
        { }};

    static PyType_Spec type_spec_HttpDiagnosticProviderRequestSentEventArgs = {
        "winrt._winrt_windows_web_http_diagnostics.HttpDiagnosticProviderRequestSentEventArgs",
        sizeof(py::wrapper::Windows::Web::Http::Diagnostics::HttpDiagnosticProviderRequestSentEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_HttpDiagnosticProviderRequestSentEventArgs};

    // ----- HttpDiagnosticProviderResponseReceivedEventArgs class --------------------

    static PyObject* _new_HttpDiagnosticProviderResponseReceivedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Web::Http::Diagnostics::HttpDiagnosticProviderResponseReceivedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Web::Http::Diagnostics::HttpDiagnosticProviderResponseReceivedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_HttpDiagnosticProviderResponseReceivedEventArgs(py::wrapper::Windows::Web::Http::Diagnostics::HttpDiagnosticProviderResponseReceivedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* HttpDiagnosticProviderResponseReceivedEventArgs_get_ActivityId(py::wrapper::Windows::Web::Http::Diagnostics::HttpDiagnosticProviderResponseReceivedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.Diagnostics.HttpDiagnosticProviderResponseReceivedEventArgs", L"ActivityId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ActivityId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HttpDiagnosticProviderResponseReceivedEventArgs_get_Message(py::wrapper::Windows::Web::Http::Diagnostics::HttpDiagnosticProviderResponseReceivedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.Diagnostics.HttpDiagnosticProviderResponseReceivedEventArgs", L"Message");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Message();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HttpDiagnosticProviderResponseReceivedEventArgs_get_Timestamp(py::wrapper::Windows::Web::Http::Diagnostics::HttpDiagnosticProviderResponseReceivedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.Diagnostics.HttpDiagnosticProviderResponseReceivedEventArgs", L"Timestamp");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Timestamp();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_HttpDiagnosticProviderResponseReceivedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Web::Http::Diagnostics::HttpDiagnosticProviderResponseReceivedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_HttpDiagnosticProviderResponseReceivedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Web::Http::Diagnostics::HttpDiagnosticProviderResponseReceivedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_HttpDiagnosticProviderResponseReceivedEventArgs[] = {
        { "_assign_array_", _assign_array_HttpDiagnosticProviderResponseReceivedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_HttpDiagnosticProviderResponseReceivedEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_HttpDiagnosticProviderResponseReceivedEventArgs[] = {
        { "activity_id", reinterpret_cast<getter>(HttpDiagnosticProviderResponseReceivedEventArgs_get_ActivityId), nullptr, nullptr, nullptr },
        { "message", reinterpret_cast<getter>(HttpDiagnosticProviderResponseReceivedEventArgs_get_Message), nullptr, nullptr, nullptr },
        { "timestamp", reinterpret_cast<getter>(HttpDiagnosticProviderResponseReceivedEventArgs_get_Timestamp), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_HttpDiagnosticProviderResponseReceivedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_HttpDiagnosticProviderResponseReceivedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_HttpDiagnosticProviderResponseReceivedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_HttpDiagnosticProviderResponseReceivedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_HttpDiagnosticProviderResponseReceivedEventArgs) },
        { }};

    static PyType_Spec type_spec_HttpDiagnosticProviderResponseReceivedEventArgs = {
        "winrt._winrt_windows_web_http_diagnostics.HttpDiagnosticProviderResponseReceivedEventArgs",
        sizeof(py::wrapper::Windows::Web::Http::Diagnostics::HttpDiagnosticProviderResponseReceivedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_HttpDiagnosticProviderResponseReceivedEventArgs};

    // ----- HttpDiagnosticSourceLocation class --------------------

    static PyObject* _new_HttpDiagnosticSourceLocation(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Web::Http::Diagnostics::HttpDiagnosticSourceLocation>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Web::Http::Diagnostics::HttpDiagnosticSourceLocation>::type_name);
        return nullptr;
    }

    static void _dealloc_HttpDiagnosticSourceLocation(py::wrapper::Windows::Web::Http::Diagnostics::HttpDiagnosticSourceLocation* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* HttpDiagnosticSourceLocation_get_ColumnNumber(py::wrapper::Windows::Web::Http::Diagnostics::HttpDiagnosticSourceLocation* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.Diagnostics.HttpDiagnosticSourceLocation", L"ColumnNumber");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ColumnNumber();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HttpDiagnosticSourceLocation_get_LineNumber(py::wrapper::Windows::Web::Http::Diagnostics::HttpDiagnosticSourceLocation* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.Diagnostics.HttpDiagnosticSourceLocation", L"LineNumber");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.LineNumber();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HttpDiagnosticSourceLocation_get_SourceUri(py::wrapper::Windows::Web::Http::Diagnostics::HttpDiagnosticSourceLocation* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.Diagnostics.HttpDiagnosticSourceLocation", L"SourceUri");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SourceUri();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_HttpDiagnosticSourceLocation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Web::Http::Diagnostics::HttpDiagnosticSourceLocation>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_HttpDiagnosticSourceLocation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Web::Http::Diagnostics::HttpDiagnosticSourceLocation>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_HttpDiagnosticSourceLocation[] = {
        { "_assign_array_", _assign_array_HttpDiagnosticSourceLocation, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_HttpDiagnosticSourceLocation), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_HttpDiagnosticSourceLocation[] = {
        { "column_number", reinterpret_cast<getter>(HttpDiagnosticSourceLocation_get_ColumnNumber), nullptr, nullptr, nullptr },
        { "line_number", reinterpret_cast<getter>(HttpDiagnosticSourceLocation_get_LineNumber), nullptr, nullptr, nullptr },
        { "source_uri", reinterpret_cast<getter>(HttpDiagnosticSourceLocation_get_SourceUri), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_HttpDiagnosticSourceLocation[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_HttpDiagnosticSourceLocation) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_HttpDiagnosticSourceLocation) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_HttpDiagnosticSourceLocation) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_HttpDiagnosticSourceLocation) },
        { }};

    static PyType_Spec type_spec_HttpDiagnosticSourceLocation = {
        "winrt._winrt_windows_web_http_diagnostics.HttpDiagnosticSourceLocation",
        sizeof(py::wrapper::Windows::Web::Http::Diagnostics::HttpDiagnosticSourceLocation),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_HttpDiagnosticSourceLocation};

    // ----- Windows.Web.Http.Diagnostics Initialization --------------------

    PyDoc_STRVAR(module_doc, "Windows.Web.Http.Diagnostics");

    static PyModuleDef module_def = {
        PyModuleDef_HEAD_INIT,
        "_winrt_windows_web_http_diagnostics",
        module_doc,
        0,
        nullptr,
        nullptr,
        nullptr,
        nullptr,
        nullptr};
} // py::cpp::Windows::Web::Http::Diagnostics

PyMODINIT_FUNC PyInit__winrt_windows_web_http_diagnostics(void) noexcept
{
    using namespace py::cpp::Windows::Web::Http::Diagnostics;

    if (py::import_winrt_runtime() == -1)
    {
        return nullptr;
    }

    py::pyobj_handle module{PyModule_Create(&module_def)};

    if (!module)
    {
        return nullptr;
    }

    auto inspectable_meta_type = py::get_inspectable_meta_type();
    if (!inspectable_meta_type)
    {
        return nullptr;
    }

    auto object_type = py::get_object_type();
    if (!object_type)
    {
        return nullptr;
    }

    py::pyobj_handle object_bases{PyTuple_Pack(1, object_type)};

    if (!object_bases)
    {
        return nullptr;
    }

    py::pyobj_handle HttpDiagnosticProvider_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(inspectable_meta_type))};
    if (!HttpDiagnosticProvider_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_HttpDiagnosticProvider_Static{PyType_FromSpecWithBases(&type_spec_HttpDiagnosticProvider_Static, HttpDiagnosticProvider_Static_bases.get())};
    if (!type_HttpDiagnosticProvider_Static)
    {
        return nullptr;
    }

    py::pytype_handle HttpDiagnosticProvider_type{py::register_python_type(module.get(), &type_spec_HttpDiagnosticProvider, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_HttpDiagnosticProvider_Static.get()))};
    if (!HttpDiagnosticProvider_type)
    {
        return nullptr;
    }

    py::pytype_handle HttpDiagnosticProviderRequestResponseCompletedEventArgs_type{py::register_python_type(module.get(), &type_spec_HttpDiagnosticProviderRequestResponseCompletedEventArgs, object_bases.get(), inspectable_meta_type)};
    if (!HttpDiagnosticProviderRequestResponseCompletedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle HttpDiagnosticProviderRequestResponseTimestamps_type{py::register_python_type(module.get(), &type_spec_HttpDiagnosticProviderRequestResponseTimestamps, object_bases.get(), inspectable_meta_type)};
    if (!HttpDiagnosticProviderRequestResponseTimestamps_type)
    {
        return nullptr;
    }

    py::pytype_handle HttpDiagnosticProviderRequestSentEventArgs_type{py::register_python_type(module.get(), &type_spec_HttpDiagnosticProviderRequestSentEventArgs, object_bases.get(), inspectable_meta_type)};
    if (!HttpDiagnosticProviderRequestSentEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle HttpDiagnosticProviderResponseReceivedEventArgs_type{py::register_python_type(module.get(), &type_spec_HttpDiagnosticProviderResponseReceivedEventArgs, object_bases.get(), inspectable_meta_type)};
    if (!HttpDiagnosticProviderResponseReceivedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle HttpDiagnosticSourceLocation_type{py::register_python_type(module.get(), &type_spec_HttpDiagnosticSourceLocation, object_bases.get(), inspectable_meta_type)};
    if (!HttpDiagnosticSourceLocation_type)
    {
        return nullptr;
    }


    return module.detach();
}
