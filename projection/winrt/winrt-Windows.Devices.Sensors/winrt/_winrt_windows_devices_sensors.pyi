# WARNING: Please don't edit this file. It was generated by Python/WinRT v3.2.1

import datetime
import sys
import types
import typing
import uuid as _uuid
from builtins import property as _property
from abc import abstractmethod

import winrt._winrt
import winrt.system
import winrt.windows.foundation as windows_foundation
import winrt.windows.foundation.collections as windows_foundation_collections
import winrt.windows.graphics.display as windows_graphics_display

from winrt.windows.devices.sensors import AccelerometerReadingType, ActivitySensorReadingConfidence, ActivityType, HumanEngagement, HumanPresence, MagnetometerAccuracy, OnlookerDetectionAction, OnlookerDetectionBackOnMode, PedometerStepKind, SensorOptimizationGoal, SensorReadingType, SensorType, SimpleOrientation

Self = typing.TypeVar('Self')

@typing.final
class LightSensorChromaticity:
    @_property
    def x(self) -> winrt.system.Double: ...
    @_property
    def y(self) -> winrt.system.Double: ...
    def __new__(cls, x: winrt.system.Double = 0, y: winrt.system.Double = 0) -> LightSensorChromaticity: ...
    def __replace__(self, /, **changes: typing.Any) -> LightSensorChromaticity: ...
    def unpack(self) -> typing.Tuple[winrt.system.Double, winrt.system.Double]: ...

@typing.final
class Accelerometer_Static(winrt._winrt.IInspectable_Static):
    # Windows.Foundation.IAsyncOperation`1<Windows.Devices.Sensors.Accelerometer> Windows.Devices.Sensors.Accelerometer::FromIdAsync(System.String)
    def from_id_async(cls, device_id: str, /) -> windows_foundation.IAsyncOperation[Accelerometer]: ...
    # Windows.Devices.Sensors.Accelerometer Windows.Devices.Sensors.Accelerometer::GetDefault()
    def get_default(cls) -> Accelerometer: ...
    # Windows.Devices.Sensors.Accelerometer Windows.Devices.Sensors.Accelerometer::GetDefault(Windows.Devices.Sensors.AccelerometerReadingType)
    def get_default_with_accelerometer_reading_type(cls, reading_type: AccelerometerReadingType, /) -> Accelerometer: ...
    # System.String Windows.Devices.Sensors.Accelerometer::GetDeviceSelector(Windows.Devices.Sensors.AccelerometerReadingType)
    def get_device_selector(cls, reading_type: AccelerometerReadingType, /) -> str: ...

@typing.final
class Accelerometer(winrt.system.Object, metaclass=Accelerometer_Static):
    # Windows.Devices.Sensors.AccelerometerReading Windows.Devices.Sensors.Accelerometer::GetCurrentReading()
    def get_current_reading(self) -> AccelerometerReading: ...
    # Windows.Foundation.EventRegistrationToken Windows.Devices.Sensors.Accelerometer::add_ReadingChanged(Windows.Foundation.TypedEventHandler`2<Windows.Devices.Sensors.Accelerometer,Windows.Devices.Sensors.AccelerometerReadingChangedEventArgs>)
    def add_reading_changed(self, handler: windows_foundation.TypedEventHandler[Accelerometer, AccelerometerReadingChangedEventArgs], /) -> windows_foundation.EventRegistrationToken: ...
    # System.Void Windows.Devices.Sensors.Accelerometer::remove_ReadingChanged(Windows.Foundation.EventRegistrationToken)
    def remove_reading_changed(self, token: typing.Union[windows_foundation.EventRegistrationToken, typing.Tuple[winrt.system.Int64]], /) -> None: ...
    # Windows.Foundation.EventRegistrationToken Windows.Devices.Sensors.Accelerometer::add_Shaken(Windows.Foundation.TypedEventHandler`2<Windows.Devices.Sensors.Accelerometer,Windows.Devices.Sensors.AccelerometerShakenEventArgs>)
    def add_shaken(self, handler: windows_foundation.TypedEventHandler[Accelerometer, AccelerometerShakenEventArgs], /) -> windows_foundation.EventRegistrationToken: ...
    # System.Void Windows.Devices.Sensors.Accelerometer::remove_Shaken(Windows.Foundation.EventRegistrationToken)
    def remove_shaken(self, token: typing.Union[windows_foundation.EventRegistrationToken, typing.Tuple[winrt.system.Int64]], /) -> None: ...
    # System.UInt32 Windows.Devices.Sensors.Accelerometer::get_ReportInterval()
    @_property
    def report_interval(self) -> winrt.system.UInt32: ...
    # System.Void Windows.Devices.Sensors.Accelerometer::put_ReportInterval(System.UInt32)
    @report_interval.setter
    def report_interval(self, value: winrt.system.UInt32) -> None: ...
    # System.UInt32 Windows.Devices.Sensors.Accelerometer::get_MinimumReportInterval()
    @_property
    def minimum_report_interval(self) -> winrt.system.UInt32: ...
    # Windows.Graphics.Display.DisplayOrientations Windows.Devices.Sensors.Accelerometer::get_ReadingTransform()
    @_property
    def reading_transform(self) -> windows_graphics_display.DisplayOrientations: ...
    # System.Void Windows.Devices.Sensors.Accelerometer::put_ReadingTransform(Windows.Graphics.Display.DisplayOrientations)
    @reading_transform.setter
    def reading_transform(self, value: windows_graphics_display.DisplayOrientations) -> None: ...
    # System.UInt32 Windows.Devices.Sensors.Accelerometer::get_ReportLatency()
    @_property
    def report_latency(self) -> winrt.system.UInt32: ...
    # System.Void Windows.Devices.Sensors.Accelerometer::put_ReportLatency(System.UInt32)
    @report_latency.setter
    def report_latency(self, value: winrt.system.UInt32) -> None: ...
    # System.UInt32 Windows.Devices.Sensors.Accelerometer::get_MaxBatchSize()
    @_property
    def max_batch_size(self) -> winrt.system.UInt32: ...
    # Windows.Devices.Sensors.AccelerometerReadingType Windows.Devices.Sensors.Accelerometer::get_ReadingType()
    @_property
    def reading_type(self) -> AccelerometerReadingType: ...
    # Windows.Devices.Sensors.AccelerometerDataThreshold Windows.Devices.Sensors.Accelerometer::get_ReportThreshold()
    @_property
    def report_threshold(self) -> AccelerometerDataThreshold: ...
    # System.String Windows.Devices.Sensors.Accelerometer::get_DeviceId()
    @_property
    def device_id(self) -> str: ...

@typing.final
class AccelerometerDataThreshold(winrt.system.Object):
    # System.Double Windows.Devices.Sensors.AccelerometerDataThreshold::get_ZAxisInGForce()
    @_property
    def z_axis_in_g_force(self) -> winrt.system.Double: ...
    # System.Void Windows.Devices.Sensors.AccelerometerDataThreshold::put_ZAxisInGForce(System.Double)
    @z_axis_in_g_force.setter
    def z_axis_in_g_force(self, value: winrt.system.Double) -> None: ...
    # System.Double Windows.Devices.Sensors.AccelerometerDataThreshold::get_YAxisInGForce()
    @_property
    def y_axis_in_g_force(self) -> winrt.system.Double: ...
    # System.Void Windows.Devices.Sensors.AccelerometerDataThreshold::put_YAxisInGForce(System.Double)
    @y_axis_in_g_force.setter
    def y_axis_in_g_force(self, value: winrt.system.Double) -> None: ...
    # System.Double Windows.Devices.Sensors.AccelerometerDataThreshold::get_XAxisInGForce()
    @_property
    def x_axis_in_g_force(self) -> winrt.system.Double: ...
    # System.Void Windows.Devices.Sensors.AccelerometerDataThreshold::put_XAxisInGForce(System.Double)
    @x_axis_in_g_force.setter
    def x_axis_in_g_force(self, value: winrt.system.Double) -> None: ...

@typing.final
class AccelerometerReading(winrt.system.Object):
    # System.Double Windows.Devices.Sensors.AccelerometerReading::get_AccelerationX()
    @_property
    def acceleration_x(self) -> winrt.system.Double: ...
    # System.Double Windows.Devices.Sensors.AccelerometerReading::get_AccelerationY()
    @_property
    def acceleration_y(self) -> winrt.system.Double: ...
    # System.Double Windows.Devices.Sensors.AccelerometerReading::get_AccelerationZ()
    @_property
    def acceleration_z(self) -> winrt.system.Double: ...
    # Windows.Foundation.DateTime Windows.Devices.Sensors.AccelerometerReading::get_Timestamp()
    @_property
    def timestamp(self) -> datetime.datetime: ...
    # Windows.Foundation.IReference`1<Windows.Foundation.TimeSpan> Windows.Devices.Sensors.AccelerometerReading::get_PerformanceCount()
    @_property
    def performance_count(self) -> typing.Optional[datetime.timedelta]: ...
    # Windows.Foundation.Collections.IMapView`2<System.String,System.Object> Windows.Devices.Sensors.AccelerometerReading::get_Properties()
    @_property
    def properties(self) -> typing.Mapping[str, winrt.system.Object]: ...

@typing.final
class AccelerometerReadingChangedEventArgs(winrt.system.Object):
    # Windows.Devices.Sensors.AccelerometerReading Windows.Devices.Sensors.AccelerometerReadingChangedEventArgs::get_Reading()
    @_property
    def reading(self) -> AccelerometerReading: ...

@typing.final
class AccelerometerShakenEventArgs(winrt.system.Object):
    # Windows.Foundation.DateTime Windows.Devices.Sensors.AccelerometerShakenEventArgs::get_Timestamp()
    @_property
    def timestamp(self) -> datetime.datetime: ...

@typing.final
class ActivitySensor_Static(winrt._winrt.IInspectable_Static):
    # Windows.Foundation.IAsyncOperation`1<Windows.Devices.Sensors.ActivitySensor> Windows.Devices.Sensors.ActivitySensor::FromIdAsync(System.String)
    def from_id_async(cls, device_id: str, /) -> windows_foundation.IAsyncOperation[ActivitySensor]: ...
    # Windows.Foundation.IAsyncOperation`1<Windows.Devices.Sensors.ActivitySensor> Windows.Devices.Sensors.ActivitySensor::GetDefaultAsync()
    def get_default_async(cls) -> windows_foundation.IAsyncOperation[ActivitySensor]: ...
    # System.String Windows.Devices.Sensors.ActivitySensor::GetDeviceSelector()
    def get_device_selector(cls) -> str: ...
    # Windows.Foundation.IAsyncOperation`1<Windows.Foundation.Collections.IVectorView`1<Windows.Devices.Sensors.ActivitySensorReading>> Windows.Devices.Sensors.ActivitySensor::GetSystemHistoryAsync(Windows.Foundation.DateTime)
    def get_system_history_async(cls, from_time: datetime.datetime, /) -> windows_foundation.IAsyncOperation[typing.Sequence[ActivitySensorReading]]: ...
    # Windows.Foundation.IAsyncOperation`1<Windows.Foundation.Collections.IVectorView`1<Windows.Devices.Sensors.ActivitySensorReading>> Windows.Devices.Sensors.ActivitySensor::GetSystemHistoryAsync(Windows.Foundation.DateTime,Windows.Foundation.TimeSpan)
    def get_system_history_with_duration_async(cls, from_time: datetime.datetime, duration: datetime.timedelta, /) -> windows_foundation.IAsyncOperation[typing.Sequence[ActivitySensorReading]]: ...

@typing.final
class ActivitySensor(winrt.system.Object, metaclass=ActivitySensor_Static):
    # Windows.Foundation.IAsyncOperation`1<Windows.Devices.Sensors.ActivitySensorReading> Windows.Devices.Sensors.ActivitySensor::GetCurrentReadingAsync()
    def get_current_reading_async(self) -> windows_foundation.IAsyncOperation[ActivitySensorReading]: ...
    # Windows.Foundation.EventRegistrationToken Windows.Devices.Sensors.ActivitySensor::add_ReadingChanged(Windows.Foundation.TypedEventHandler`2<Windows.Devices.Sensors.ActivitySensor,Windows.Devices.Sensors.ActivitySensorReadingChangedEventArgs>)
    def add_reading_changed(self, handler: windows_foundation.TypedEventHandler[ActivitySensor, ActivitySensorReadingChangedEventArgs], /) -> windows_foundation.EventRegistrationToken: ...
    # System.Void Windows.Devices.Sensors.ActivitySensor::remove_ReadingChanged(Windows.Foundation.EventRegistrationToken)
    def remove_reading_changed(self, token: typing.Union[windows_foundation.EventRegistrationToken, typing.Tuple[winrt.system.Int64]], /) -> None: ...
    # System.String Windows.Devices.Sensors.ActivitySensor::get_DeviceId()
    @_property
    def device_id(self) -> str: ...
    # System.UInt32 Windows.Devices.Sensors.ActivitySensor::get_MinimumReportInterval()
    @_property
    def minimum_report_interval(self) -> winrt.system.UInt32: ...
    # System.Double Windows.Devices.Sensors.ActivitySensor::get_PowerInMilliwatts()
    @_property
    def power_in_milliwatts(self) -> winrt.system.Double: ...
    # Windows.Foundation.Collections.IVector`1<Windows.Devices.Sensors.ActivityType> Windows.Devices.Sensors.ActivitySensor::get_SubscribedActivities()
    @_property
    def subscribed_activities(self) -> typing.MutableSequence[ActivityType]: ...
    # Windows.Foundation.Collections.IVectorView`1<Windows.Devices.Sensors.ActivityType> Windows.Devices.Sensors.ActivitySensor::get_SupportedActivities()
    @_property
    def supported_activities(self) -> typing.Sequence[ActivityType]: ...

@typing.final
class ActivitySensorReading(winrt.system.Object):
    # Windows.Devices.Sensors.ActivityType Windows.Devices.Sensors.ActivitySensorReading::get_Activity()
    @_property
    def activity(self) -> ActivityType: ...
    # Windows.Devices.Sensors.ActivitySensorReadingConfidence Windows.Devices.Sensors.ActivitySensorReading::get_Confidence()
    @_property
    def confidence(self) -> ActivitySensorReadingConfidence: ...
    # Windows.Foundation.DateTime Windows.Devices.Sensors.ActivitySensorReading::get_Timestamp()
    @_property
    def timestamp(self) -> datetime.datetime: ...

@typing.final
class ActivitySensorReadingChangeReport(winrt.system.Object):
    # Windows.Devices.Sensors.ActivitySensorReading Windows.Devices.Sensors.ActivitySensorReadingChangeReport::get_Reading()
    @_property
    def reading(self) -> ActivitySensorReading: ...

@typing.final
class ActivitySensorReadingChangedEventArgs(winrt.system.Object):
    # Windows.Devices.Sensors.ActivitySensorReading Windows.Devices.Sensors.ActivitySensorReadingChangedEventArgs::get_Reading()
    @_property
    def reading(self) -> ActivitySensorReading: ...

@typing.final
class ActivitySensorTriggerDetails(winrt.system.Object):
    # Windows.Foundation.Collections.IVectorView`1<Windows.Devices.Sensors.ActivitySensorReadingChangeReport> Windows.Devices.Sensors.ActivitySensorTriggerDetails::ReadReports()
    def read_reports(self) -> typing.Sequence[ActivitySensorReadingChangeReport]: ...

@typing.final
class AdaptiveDimmingOptions(winrt.system.Object):
    # System.Boolean Windows.Devices.Sensors.AdaptiveDimmingOptions::get_AllowWhenExternalDisplayConnected()
    @_property
    def allow_when_external_display_connected(self) -> bool: ...
    # System.Void Windows.Devices.Sensors.AdaptiveDimmingOptions::put_AllowWhenExternalDisplayConnected(System.Boolean)
    @allow_when_external_display_connected.setter
    def allow_when_external_display_connected(self, value: bool) -> None: ...

@typing.final
class Altimeter_Static(winrt._winrt.IInspectable_Static):
    # Windows.Devices.Sensors.Altimeter Windows.Devices.Sensors.Altimeter::GetDefault()
    def get_default(cls) -> Altimeter: ...

@typing.final
class Altimeter(winrt.system.Object, metaclass=Altimeter_Static):
    # Windows.Devices.Sensors.AltimeterReading Windows.Devices.Sensors.Altimeter::GetCurrentReading()
    def get_current_reading(self) -> AltimeterReading: ...
    # Windows.Foundation.EventRegistrationToken Windows.Devices.Sensors.Altimeter::add_ReadingChanged(Windows.Foundation.TypedEventHandler`2<Windows.Devices.Sensors.Altimeter,Windows.Devices.Sensors.AltimeterReadingChangedEventArgs>)
    def add_reading_changed(self, handler: windows_foundation.TypedEventHandler[Altimeter, AltimeterReadingChangedEventArgs], /) -> windows_foundation.EventRegistrationToken: ...
    # System.Void Windows.Devices.Sensors.Altimeter::remove_ReadingChanged(Windows.Foundation.EventRegistrationToken)
    def remove_reading_changed(self, token: typing.Union[windows_foundation.EventRegistrationToken, typing.Tuple[winrt.system.Int64]], /) -> None: ...
    # System.UInt32 Windows.Devices.Sensors.Altimeter::get_ReportInterval()
    @_property
    def report_interval(self) -> winrt.system.UInt32: ...
    # System.Void Windows.Devices.Sensors.Altimeter::put_ReportInterval(System.UInt32)
    @report_interval.setter
    def report_interval(self, value: winrt.system.UInt32) -> None: ...
    # System.String Windows.Devices.Sensors.Altimeter::get_DeviceId()
    @_property
    def device_id(self) -> str: ...
    # System.UInt32 Windows.Devices.Sensors.Altimeter::get_MinimumReportInterval()
    @_property
    def minimum_report_interval(self) -> winrt.system.UInt32: ...
    # System.UInt32 Windows.Devices.Sensors.Altimeter::get_ReportLatency()
    @_property
    def report_latency(self) -> winrt.system.UInt32: ...
    # System.Void Windows.Devices.Sensors.Altimeter::put_ReportLatency(System.UInt32)
    @report_latency.setter
    def report_latency(self, value: winrt.system.UInt32) -> None: ...
    # System.UInt32 Windows.Devices.Sensors.Altimeter::get_MaxBatchSize()
    @_property
    def max_batch_size(self) -> winrt.system.UInt32: ...

@typing.final
class AltimeterReading(winrt.system.Object):
    # System.Double Windows.Devices.Sensors.AltimeterReading::get_AltitudeChangeInMeters()
    @_property
    def altitude_change_in_meters(self) -> winrt.system.Double: ...
    # Windows.Foundation.DateTime Windows.Devices.Sensors.AltimeterReading::get_Timestamp()
    @_property
    def timestamp(self) -> datetime.datetime: ...
    # Windows.Foundation.IReference`1<Windows.Foundation.TimeSpan> Windows.Devices.Sensors.AltimeterReading::get_PerformanceCount()
    @_property
    def performance_count(self) -> typing.Optional[datetime.timedelta]: ...
    # Windows.Foundation.Collections.IMapView`2<System.String,System.Object> Windows.Devices.Sensors.AltimeterReading::get_Properties()
    @_property
    def properties(self) -> typing.Mapping[str, winrt.system.Object]: ...

@typing.final
class AltimeterReadingChangedEventArgs(winrt.system.Object):
    # Windows.Devices.Sensors.AltimeterReading Windows.Devices.Sensors.AltimeterReadingChangedEventArgs::get_Reading()
    @_property
    def reading(self) -> AltimeterReading: ...

@typing.final
class Barometer_Static(winrt._winrt.IInspectable_Static):
    # Windows.Foundation.IAsyncOperation`1<Windows.Devices.Sensors.Barometer> Windows.Devices.Sensors.Barometer::FromIdAsync(System.String)
    def from_id_async(cls, device_id: str, /) -> windows_foundation.IAsyncOperation[Barometer]: ...
    # Windows.Devices.Sensors.Barometer Windows.Devices.Sensors.Barometer::GetDefault()
    def get_default(cls) -> Barometer: ...
    # System.String Windows.Devices.Sensors.Barometer::GetDeviceSelector()
    def get_device_selector(cls) -> str: ...

@typing.final
class Barometer(winrt.system.Object, metaclass=Barometer_Static):
    # Windows.Devices.Sensors.BarometerReading Windows.Devices.Sensors.Barometer::GetCurrentReading()
    def get_current_reading(self) -> BarometerReading: ...
    # Windows.Foundation.EventRegistrationToken Windows.Devices.Sensors.Barometer::add_ReadingChanged(Windows.Foundation.TypedEventHandler`2<Windows.Devices.Sensors.Barometer,Windows.Devices.Sensors.BarometerReadingChangedEventArgs>)
    def add_reading_changed(self, handler: windows_foundation.TypedEventHandler[Barometer, BarometerReadingChangedEventArgs], /) -> windows_foundation.EventRegistrationToken: ...
    # System.Void Windows.Devices.Sensors.Barometer::remove_ReadingChanged(Windows.Foundation.EventRegistrationToken)
    def remove_reading_changed(self, token: typing.Union[windows_foundation.EventRegistrationToken, typing.Tuple[winrt.system.Int64]], /) -> None: ...
    # System.UInt32 Windows.Devices.Sensors.Barometer::get_ReportInterval()
    @_property
    def report_interval(self) -> winrt.system.UInt32: ...
    # System.Void Windows.Devices.Sensors.Barometer::put_ReportInterval(System.UInt32)
    @report_interval.setter
    def report_interval(self, value: winrt.system.UInt32) -> None: ...
    # System.String Windows.Devices.Sensors.Barometer::get_DeviceId()
    @_property
    def device_id(self) -> str: ...
    # System.UInt32 Windows.Devices.Sensors.Barometer::get_MinimumReportInterval()
    @_property
    def minimum_report_interval(self) -> winrt.system.UInt32: ...
    # System.UInt32 Windows.Devices.Sensors.Barometer::get_ReportLatency()
    @_property
    def report_latency(self) -> winrt.system.UInt32: ...
    # System.Void Windows.Devices.Sensors.Barometer::put_ReportLatency(System.UInt32)
    @report_latency.setter
    def report_latency(self, value: winrt.system.UInt32) -> None: ...
    # System.UInt32 Windows.Devices.Sensors.Barometer::get_MaxBatchSize()
    @_property
    def max_batch_size(self) -> winrt.system.UInt32: ...
    # Windows.Devices.Sensors.BarometerDataThreshold Windows.Devices.Sensors.Barometer::get_ReportThreshold()
    @_property
    def report_threshold(self) -> BarometerDataThreshold: ...

@typing.final
class BarometerDataThreshold(winrt.system.Object):
    # System.Double Windows.Devices.Sensors.BarometerDataThreshold::get_Hectopascals()
    @_property
    def hectopascals(self) -> winrt.system.Double: ...
    # System.Void Windows.Devices.Sensors.BarometerDataThreshold::put_Hectopascals(System.Double)
    @hectopascals.setter
    def hectopascals(self, value: winrt.system.Double) -> None: ...

@typing.final
class BarometerReading(winrt.system.Object):
    # System.Double Windows.Devices.Sensors.BarometerReading::get_StationPressureInHectopascals()
    @_property
    def station_pressure_in_hectopascals(self) -> winrt.system.Double: ...
    # Windows.Foundation.DateTime Windows.Devices.Sensors.BarometerReading::get_Timestamp()
    @_property
    def timestamp(self) -> datetime.datetime: ...
    # Windows.Foundation.IReference`1<Windows.Foundation.TimeSpan> Windows.Devices.Sensors.BarometerReading::get_PerformanceCount()
    @_property
    def performance_count(self) -> typing.Optional[datetime.timedelta]: ...
    # Windows.Foundation.Collections.IMapView`2<System.String,System.Object> Windows.Devices.Sensors.BarometerReading::get_Properties()
    @_property
    def properties(self) -> typing.Mapping[str, winrt.system.Object]: ...

@typing.final
class BarometerReadingChangedEventArgs(winrt.system.Object):
    # Windows.Devices.Sensors.BarometerReading Windows.Devices.Sensors.BarometerReadingChangedEventArgs::get_Reading()
    @_property
    def reading(self) -> BarometerReading: ...

@typing.final
class Compass_Static(winrt._winrt.IInspectable_Static):
    # Windows.Foundation.IAsyncOperation`1<Windows.Devices.Sensors.Compass> Windows.Devices.Sensors.Compass::FromIdAsync(System.String)
    def from_id_async(cls, device_id: str, /) -> windows_foundation.IAsyncOperation[Compass]: ...
    # Windows.Devices.Sensors.Compass Windows.Devices.Sensors.Compass::GetDefault()
    def get_default(cls) -> Compass: ...
    # System.String Windows.Devices.Sensors.Compass::GetDeviceSelector()
    def get_device_selector(cls) -> str: ...

@typing.final
class Compass(winrt.system.Object, metaclass=Compass_Static):
    # Windows.Devices.Sensors.CompassReading Windows.Devices.Sensors.Compass::GetCurrentReading()
    def get_current_reading(self) -> CompassReading: ...
    # Windows.Foundation.EventRegistrationToken Windows.Devices.Sensors.Compass::add_ReadingChanged(Windows.Foundation.TypedEventHandler`2<Windows.Devices.Sensors.Compass,Windows.Devices.Sensors.CompassReadingChangedEventArgs>)
    def add_reading_changed(self, handler: windows_foundation.TypedEventHandler[Compass, CompassReadingChangedEventArgs], /) -> windows_foundation.EventRegistrationToken: ...
    # System.Void Windows.Devices.Sensors.Compass::remove_ReadingChanged(Windows.Foundation.EventRegistrationToken)
    def remove_reading_changed(self, token: typing.Union[windows_foundation.EventRegistrationToken, typing.Tuple[winrt.system.Int64]], /) -> None: ...
    # System.UInt32 Windows.Devices.Sensors.Compass::get_ReportInterval()
    @_property
    def report_interval(self) -> winrt.system.UInt32: ...
    # System.Void Windows.Devices.Sensors.Compass::put_ReportInterval(System.UInt32)
    @report_interval.setter
    def report_interval(self, value: winrt.system.UInt32) -> None: ...
    # System.UInt32 Windows.Devices.Sensors.Compass::get_MinimumReportInterval()
    @_property
    def minimum_report_interval(self) -> winrt.system.UInt32: ...
    # Windows.Graphics.Display.DisplayOrientations Windows.Devices.Sensors.Compass::get_ReadingTransform()
    @_property
    def reading_transform(self) -> windows_graphics_display.DisplayOrientations: ...
    # System.Void Windows.Devices.Sensors.Compass::put_ReadingTransform(Windows.Graphics.Display.DisplayOrientations)
    @reading_transform.setter
    def reading_transform(self, value: windows_graphics_display.DisplayOrientations) -> None: ...
    # System.UInt32 Windows.Devices.Sensors.Compass::get_ReportLatency()
    @_property
    def report_latency(self) -> winrt.system.UInt32: ...
    # System.Void Windows.Devices.Sensors.Compass::put_ReportLatency(System.UInt32)
    @report_latency.setter
    def report_latency(self, value: winrt.system.UInt32) -> None: ...
    # System.UInt32 Windows.Devices.Sensors.Compass::get_MaxBatchSize()
    @_property
    def max_batch_size(self) -> winrt.system.UInt32: ...
    # Windows.Devices.Sensors.CompassDataThreshold Windows.Devices.Sensors.Compass::get_ReportThreshold()
    @_property
    def report_threshold(self) -> CompassDataThreshold: ...
    # System.String Windows.Devices.Sensors.Compass::get_DeviceId()
    @_property
    def device_id(self) -> str: ...

@typing.final
class CompassDataThreshold(winrt.system.Object):
    # System.Double Windows.Devices.Sensors.CompassDataThreshold::get_Degrees()
    @_property
    def degrees(self) -> winrt.system.Double: ...
    # System.Void Windows.Devices.Sensors.CompassDataThreshold::put_Degrees(System.Double)
    @degrees.setter
    def degrees(self, value: winrt.system.Double) -> None: ...

@typing.final
class CompassReading(winrt.system.Object):
    # System.Double Windows.Devices.Sensors.CompassReading::get_HeadingMagneticNorth()
    @_property
    def heading_magnetic_north(self) -> winrt.system.Double: ...
    # Windows.Foundation.IReference`1<System.Double> Windows.Devices.Sensors.CompassReading::get_HeadingTrueNorth()
    @_property
    def heading_true_north(self) -> typing.Optional[winrt.system.Double]: ...
    # Windows.Foundation.DateTime Windows.Devices.Sensors.CompassReading::get_Timestamp()
    @_property
    def timestamp(self) -> datetime.datetime: ...
    # Windows.Foundation.IReference`1<Windows.Foundation.TimeSpan> Windows.Devices.Sensors.CompassReading::get_PerformanceCount()
    @_property
    def performance_count(self) -> typing.Optional[datetime.timedelta]: ...
    # Windows.Foundation.Collections.IMapView`2<System.String,System.Object> Windows.Devices.Sensors.CompassReading::get_Properties()
    @_property
    def properties(self) -> typing.Mapping[str, winrt.system.Object]: ...
    # Windows.Devices.Sensors.MagnetometerAccuracy Windows.Devices.Sensors.CompassReading::get_HeadingAccuracy()
    @_property
    def heading_accuracy(self) -> MagnetometerAccuracy: ...

@typing.final
class CompassReadingChangedEventArgs(winrt.system.Object):
    # Windows.Devices.Sensors.CompassReading Windows.Devices.Sensors.CompassReadingChangedEventArgs::get_Reading()
    @_property
    def reading(self) -> CompassReading: ...

@typing.final
class DetectedPerson(winrt.system.Object):
    # Windows.Foundation.IReference`1<System.UInt32> Windows.Devices.Sensors.DetectedPerson::get_DistanceInMillimeters()
    @_property
    def distance_in_millimeters(self) -> typing.Optional[winrt.system.UInt32]: ...
    # Windows.Devices.Sensors.HumanEngagement Windows.Devices.Sensors.DetectedPerson::get_Engagement()
    @_property
    def engagement(self) -> HumanEngagement: ...
    # Windows.Devices.Sensors.HeadOrientation Windows.Devices.Sensors.DetectedPerson::get_HeadOrientation()
    @_property
    def head_orientation(self) -> HeadOrientation: ...
    # Windows.Devices.Sensors.HeadPosition Windows.Devices.Sensors.DetectedPerson::get_HeadPosition()
    @_property
    def head_position(self) -> HeadPosition: ...
    # Windows.Foundation.IReference`1<System.Int32> Windows.Devices.Sensors.DetectedPerson::get_PersonId()
    @_property
    def person_id(self) -> typing.Optional[winrt.system.Int32]: ...

@typing.final
class Gyrometer_Static(winrt._winrt.IInspectable_Static):
    # Windows.Foundation.IAsyncOperation`1<Windows.Devices.Sensors.Gyrometer> Windows.Devices.Sensors.Gyrometer::FromIdAsync(System.String)
    def from_id_async(cls, device_id: str, /) -> windows_foundation.IAsyncOperation[Gyrometer]: ...
    # Windows.Devices.Sensors.Gyrometer Windows.Devices.Sensors.Gyrometer::GetDefault()
    def get_default(cls) -> Gyrometer: ...
    # System.String Windows.Devices.Sensors.Gyrometer::GetDeviceSelector()
    def get_device_selector(cls) -> str: ...

@typing.final
class Gyrometer(winrt.system.Object, metaclass=Gyrometer_Static):
    # Windows.Devices.Sensors.GyrometerReading Windows.Devices.Sensors.Gyrometer::GetCurrentReading()
    def get_current_reading(self) -> GyrometerReading: ...
    # Windows.Foundation.EventRegistrationToken Windows.Devices.Sensors.Gyrometer::add_ReadingChanged(Windows.Foundation.TypedEventHandler`2<Windows.Devices.Sensors.Gyrometer,Windows.Devices.Sensors.GyrometerReadingChangedEventArgs>)
    def add_reading_changed(self, handler: windows_foundation.TypedEventHandler[Gyrometer, GyrometerReadingChangedEventArgs], /) -> windows_foundation.EventRegistrationToken: ...
    # System.Void Windows.Devices.Sensors.Gyrometer::remove_ReadingChanged(Windows.Foundation.EventRegistrationToken)
    def remove_reading_changed(self, token: typing.Union[windows_foundation.EventRegistrationToken, typing.Tuple[winrt.system.Int64]], /) -> None: ...
    # System.UInt32 Windows.Devices.Sensors.Gyrometer::get_ReportInterval()
    @_property
    def report_interval(self) -> winrt.system.UInt32: ...
    # System.Void Windows.Devices.Sensors.Gyrometer::put_ReportInterval(System.UInt32)
    @report_interval.setter
    def report_interval(self, value: winrt.system.UInt32) -> None: ...
    # System.UInt32 Windows.Devices.Sensors.Gyrometer::get_MinimumReportInterval()
    @_property
    def minimum_report_interval(self) -> winrt.system.UInt32: ...
    # Windows.Graphics.Display.DisplayOrientations Windows.Devices.Sensors.Gyrometer::get_ReadingTransform()
    @_property
    def reading_transform(self) -> windows_graphics_display.DisplayOrientations: ...
    # System.Void Windows.Devices.Sensors.Gyrometer::put_ReadingTransform(Windows.Graphics.Display.DisplayOrientations)
    @reading_transform.setter
    def reading_transform(self, value: windows_graphics_display.DisplayOrientations) -> None: ...
    # System.UInt32 Windows.Devices.Sensors.Gyrometer::get_ReportLatency()
    @_property
    def report_latency(self) -> winrt.system.UInt32: ...
    # System.Void Windows.Devices.Sensors.Gyrometer::put_ReportLatency(System.UInt32)
    @report_latency.setter
    def report_latency(self, value: winrt.system.UInt32) -> None: ...
    # System.UInt32 Windows.Devices.Sensors.Gyrometer::get_MaxBatchSize()
    @_property
    def max_batch_size(self) -> winrt.system.UInt32: ...
    # Windows.Devices.Sensors.GyrometerDataThreshold Windows.Devices.Sensors.Gyrometer::get_ReportThreshold()
    @_property
    def report_threshold(self) -> GyrometerDataThreshold: ...
    # System.String Windows.Devices.Sensors.Gyrometer::get_DeviceId()
    @_property
    def device_id(self) -> str: ...

@typing.final
class GyrometerDataThreshold(winrt.system.Object):
    # System.Double Windows.Devices.Sensors.GyrometerDataThreshold::get_ZAxisInDegreesPerSecond()
    @_property
    def z_axis_in_degrees_per_second(self) -> winrt.system.Double: ...
    # System.Void Windows.Devices.Sensors.GyrometerDataThreshold::put_ZAxisInDegreesPerSecond(System.Double)
    @z_axis_in_degrees_per_second.setter
    def z_axis_in_degrees_per_second(self, value: winrt.system.Double) -> None: ...
    # System.Double Windows.Devices.Sensors.GyrometerDataThreshold::get_YAxisInDegreesPerSecond()
    @_property
    def y_axis_in_degrees_per_second(self) -> winrt.system.Double: ...
    # System.Void Windows.Devices.Sensors.GyrometerDataThreshold::put_YAxisInDegreesPerSecond(System.Double)
    @y_axis_in_degrees_per_second.setter
    def y_axis_in_degrees_per_second(self, value: winrt.system.Double) -> None: ...
    # System.Double Windows.Devices.Sensors.GyrometerDataThreshold::get_XAxisInDegreesPerSecond()
    @_property
    def x_axis_in_degrees_per_second(self) -> winrt.system.Double: ...
    # System.Void Windows.Devices.Sensors.GyrometerDataThreshold::put_XAxisInDegreesPerSecond(System.Double)
    @x_axis_in_degrees_per_second.setter
    def x_axis_in_degrees_per_second(self, value: winrt.system.Double) -> None: ...

@typing.final
class GyrometerReading(winrt.system.Object):
    # System.Double Windows.Devices.Sensors.GyrometerReading::get_AngularVelocityX()
    @_property
    def angular_velocity_x(self) -> winrt.system.Double: ...
    # System.Double Windows.Devices.Sensors.GyrometerReading::get_AngularVelocityY()
    @_property
    def angular_velocity_y(self) -> winrt.system.Double: ...
    # System.Double Windows.Devices.Sensors.GyrometerReading::get_AngularVelocityZ()
    @_property
    def angular_velocity_z(self) -> winrt.system.Double: ...
    # Windows.Foundation.DateTime Windows.Devices.Sensors.GyrometerReading::get_Timestamp()
    @_property
    def timestamp(self) -> datetime.datetime: ...
    # Windows.Foundation.IReference`1<Windows.Foundation.TimeSpan> Windows.Devices.Sensors.GyrometerReading::get_PerformanceCount()
    @_property
    def performance_count(self) -> typing.Optional[datetime.timedelta]: ...
    # Windows.Foundation.Collections.IMapView`2<System.String,System.Object> Windows.Devices.Sensors.GyrometerReading::get_Properties()
    @_property
    def properties(self) -> typing.Mapping[str, winrt.system.Object]: ...

@typing.final
class GyrometerReadingChangedEventArgs(winrt.system.Object):
    # Windows.Devices.Sensors.GyrometerReading Windows.Devices.Sensors.GyrometerReadingChangedEventArgs::get_Reading()
    @_property
    def reading(self) -> GyrometerReading: ...

@typing.final
class HeadOrientation(winrt.system.Object):
    # Windows.Foundation.IReference`1<System.Double> Windows.Devices.Sensors.HeadOrientation::get_PitchInDegrees()
    @_property
    def pitch_in_degrees(self) -> typing.Optional[winrt.system.Double]: ...
    # Windows.Foundation.IReference`1<System.Double> Windows.Devices.Sensors.HeadOrientation::get_RollInDegrees()
    @_property
    def roll_in_degrees(self) -> typing.Optional[winrt.system.Double]: ...
    # Windows.Foundation.IReference`1<System.Double> Windows.Devices.Sensors.HeadOrientation::get_YawInDegrees()
    @_property
    def yaw_in_degrees(self) -> typing.Optional[winrt.system.Double]: ...

@typing.final
class HeadPosition(winrt.system.Object):
    # Windows.Foundation.IReference`1<System.Double> Windows.Devices.Sensors.HeadPosition::get_AltitudeInDegrees()
    @_property
    def altitude_in_degrees(self) -> typing.Optional[winrt.system.Double]: ...
    # Windows.Foundation.IReference`1<System.Double> Windows.Devices.Sensors.HeadPosition::get_AzimuthInDegrees()
    @_property
    def azimuth_in_degrees(self) -> typing.Optional[winrt.system.Double]: ...

@typing.final
class HingeAngleReading(winrt.system.Object):
    # System.Double Windows.Devices.Sensors.HingeAngleReading::get_AngleInDegrees()
    @_property
    def angle_in_degrees(self) -> winrt.system.Double: ...
    # Windows.Foundation.Collections.IMapView`2<System.String,System.Object> Windows.Devices.Sensors.HingeAngleReading::get_Properties()
    @_property
    def properties(self) -> typing.Mapping[str, winrt.system.Object]: ...
    # Windows.Foundation.DateTime Windows.Devices.Sensors.HingeAngleReading::get_Timestamp()
    @_property
    def timestamp(self) -> datetime.datetime: ...

@typing.final
class HingeAngleSensor_Static(winrt._winrt.IInspectable_Static):
    # Windows.Foundation.IAsyncOperation`1<Windows.Devices.Sensors.HingeAngleSensor> Windows.Devices.Sensors.HingeAngleSensor::FromIdAsync(System.String)
    def from_id_async(cls, device_id: str, /) -> windows_foundation.IAsyncOperation[HingeAngleSensor]: ...
    # Windows.Foundation.IAsyncOperation`1<Windows.Devices.Sensors.HingeAngleSensor> Windows.Devices.Sensors.HingeAngleSensor::GetDefaultAsync()
    def get_default_async(cls) -> windows_foundation.IAsyncOperation[HingeAngleSensor]: ...
    # System.String Windows.Devices.Sensors.HingeAngleSensor::GetDeviceSelector()
    def get_device_selector(cls) -> str: ...
    # Windows.Foundation.IAsyncOperation`1<Windows.Devices.Sensors.HingeAngleSensor> Windows.Devices.Sensors.HingeAngleSensor::GetRelatedToAdjacentPanelsAsync(System.String,System.String)
    def get_related_to_adjacent_panels_async(cls, first_panel_id: str, second_panel_id: str, /) -> windows_foundation.IAsyncOperation[HingeAngleSensor]: ...

@typing.final
class HingeAngleSensor(winrt.system.Object, metaclass=HingeAngleSensor_Static):
    # Windows.Foundation.IAsyncOperation`1<Windows.Devices.Sensors.HingeAngleReading> Windows.Devices.Sensors.HingeAngleSensor::GetCurrentReadingAsync()
    def get_current_reading_async(self) -> windows_foundation.IAsyncOperation[HingeAngleReading]: ...
    # Windows.Foundation.EventRegistrationToken Windows.Devices.Sensors.HingeAngleSensor::add_ReadingChanged(Windows.Foundation.TypedEventHandler`2<Windows.Devices.Sensors.HingeAngleSensor,Windows.Devices.Sensors.HingeAngleSensorReadingChangedEventArgs>)
    def add_reading_changed(self, handler: windows_foundation.TypedEventHandler[HingeAngleSensor, HingeAngleSensorReadingChangedEventArgs], /) -> windows_foundation.EventRegistrationToken: ...
    # System.Void Windows.Devices.Sensors.HingeAngleSensor::remove_ReadingChanged(Windows.Foundation.EventRegistrationToken)
    def remove_reading_changed(self, token: typing.Union[windows_foundation.EventRegistrationToken, typing.Tuple[winrt.system.Int64]], /) -> None: ...
    # System.Double Windows.Devices.Sensors.HingeAngleSensor::get_ReportThresholdInDegrees()
    @_property
    def report_threshold_in_degrees(self) -> winrt.system.Double: ...
    # System.Void Windows.Devices.Sensors.HingeAngleSensor::put_ReportThresholdInDegrees(System.Double)
    @report_threshold_in_degrees.setter
    def report_threshold_in_degrees(self, value: winrt.system.Double) -> None: ...
    # System.String Windows.Devices.Sensors.HingeAngleSensor::get_DeviceId()
    @_property
    def device_id(self) -> str: ...
    # System.Double Windows.Devices.Sensors.HingeAngleSensor::get_MinReportThresholdInDegrees()
    @_property
    def min_report_threshold_in_degrees(self) -> winrt.system.Double: ...

@typing.final
class HingeAngleSensorReadingChangedEventArgs(winrt.system.Object):
    # Windows.Devices.Sensors.HingeAngleReading Windows.Devices.Sensors.HingeAngleSensorReadingChangedEventArgs::get_Reading()
    @_property
    def reading(self) -> HingeAngleReading: ...

@typing.final
class HumanPresenceFeatures(winrt.system.Object):
    # System.Boolean Windows.Devices.Sensors.HumanPresenceFeatures::get_IsAttentionAwareDimmingSupported()
    @_property
    def is_attention_aware_dimming_supported(self) -> bool: ...
    # System.Boolean Windows.Devices.Sensors.HumanPresenceFeatures::get_IsLockOnLeaveSupported()
    @_property
    def is_lock_on_leave_supported(self) -> bool: ...
    # System.Boolean Windows.Devices.Sensors.HumanPresenceFeatures::get_IsWakeOnApproachSupported()
    @_property
    def is_wake_on_approach_supported(self) -> bool: ...
    # System.String Windows.Devices.Sensors.HumanPresenceFeatures::get_SensorId()
    @_property
    def sensor_id(self) -> str: ...
    # Windows.Foundation.Collections.IVectorView`1<System.UInt32> Windows.Devices.Sensors.HumanPresenceFeatures::get_SupportedWakeOrLockDistancesInMillimeters()
    @_property
    def supported_wake_or_lock_distances_in_millimeters(self) -> typing.Sequence[winrt.system.UInt32]: ...
    # System.Boolean Windows.Devices.Sensors.HumanPresenceFeatures::get_IsAdaptiveDimmingSupported()
    @_property
    def is_adaptive_dimming_supported(self) -> bool: ...
    # System.Boolean Windows.Devices.Sensors.HumanPresenceFeatures::get_IsOnlookerDetectionSupported()
    @_property
    def is_onlooker_detection_supported(self) -> bool: ...

@typing.final
class HumanPresenceSensor_Static(winrt._winrt.IInspectable_Static):
    # Windows.Devices.Sensors.HumanPresenceSensor Windows.Devices.Sensors.HumanPresenceSensor::FromId(System.String)
    def from_id(cls, sensor_id: str, /) -> HumanPresenceSensor: ...
    # Windows.Foundation.IAsyncOperation`1<Windows.Devices.Sensors.HumanPresenceSensor> Windows.Devices.Sensors.HumanPresenceSensor::FromIdAsync(System.String)
    def from_id_async(cls, sensor_id: str, /) -> windows_foundation.IAsyncOperation[HumanPresenceSensor]: ...
    # Windows.Devices.Sensors.HumanPresenceSensor Windows.Devices.Sensors.HumanPresenceSensor::GetDefault()
    def get_default(cls) -> HumanPresenceSensor: ...
    # Windows.Foundation.IAsyncOperation`1<Windows.Devices.Sensors.HumanPresenceSensor> Windows.Devices.Sensors.HumanPresenceSensor::GetDefaultAsync()
    def get_default_async(cls) -> windows_foundation.IAsyncOperation[HumanPresenceSensor]: ...
    # System.String Windows.Devices.Sensors.HumanPresenceSensor::GetDeviceSelector()
    def get_device_selector(cls) -> str: ...

@typing.final
class HumanPresenceSensor(winrt.system.Object, metaclass=HumanPresenceSensor_Static):
    # Windows.Devices.Sensors.HumanPresenceSensorReading Windows.Devices.Sensors.HumanPresenceSensor::GetCurrentReading()
    def get_current_reading(self) -> HumanPresenceSensorReading: ...
    # Windows.Foundation.EventRegistrationToken Windows.Devices.Sensors.HumanPresenceSensor::add_ReadingChanged(Windows.Foundation.TypedEventHandler`2<Windows.Devices.Sensors.HumanPresenceSensor,Windows.Devices.Sensors.HumanPresenceSensorReadingChangedEventArgs>)
    def add_reading_changed(self, handler: windows_foundation.TypedEventHandler[HumanPresenceSensor, HumanPresenceSensorReadingChangedEventArgs], /) -> windows_foundation.EventRegistrationToken: ...
    # System.Void Windows.Devices.Sensors.HumanPresenceSensor::remove_ReadingChanged(Windows.Foundation.EventRegistrationToken)
    def remove_reading_changed(self, token: typing.Union[windows_foundation.EventRegistrationToken, typing.Tuple[winrt.system.Int64]], /) -> None: ...
    # System.String Windows.Devices.Sensors.HumanPresenceSensor::get_DeviceId()
    @_property
    def device_id(self) -> str: ...
    # Windows.Foundation.IReference`1<System.UInt32> Windows.Devices.Sensors.HumanPresenceSensor::get_MaxDetectableDistanceInMillimeters()
    @_property
    def max_detectable_distance_in_millimeters(self) -> typing.Optional[winrt.system.UInt32]: ...
    # Windows.Foundation.IReference`1<System.UInt32> Windows.Devices.Sensors.HumanPresenceSensor::get_MinDetectableDistanceInMillimeters()
    @_property
    def min_detectable_distance_in_millimeters(self) -> typing.Optional[winrt.system.UInt32]: ...
    # System.Boolean Windows.Devices.Sensors.HumanPresenceSensor::get_IsEngagementSupported()
    @_property
    def is_engagement_supported(self) -> bool: ...
    # System.Boolean Windows.Devices.Sensors.HumanPresenceSensor::get_IsPresenceSupported()
    @_property
    def is_presence_supported(self) -> bool: ...
    # Windows.Foundation.IReference`1<System.Double> Windows.Devices.Sensors.HumanPresenceSensor::get_MaxDetectableAltitudeInDegrees()
    @_property
    def max_detectable_altitude_in_degrees(self) -> typing.Optional[winrt.system.Double]: ...
    # Windows.Foundation.IReference`1<System.Double> Windows.Devices.Sensors.HumanPresenceSensor::get_MaxDetectableAzimuthInDegrees()
    @_property
    def max_detectable_azimuth_in_degrees(self) -> typing.Optional[winrt.system.Double]: ...
    # System.Int32 Windows.Devices.Sensors.HumanPresenceSensor::get_MaxDetectablePersons()
    @_property
    def max_detectable_persons(self) -> winrt.system.Int32: ...
    # Windows.Foundation.IReference`1<System.Double> Windows.Devices.Sensors.HumanPresenceSensor::get_MinDetectableAltitudeInDegrees()
    @_property
    def min_detectable_altitude_in_degrees(self) -> typing.Optional[winrt.system.Double]: ...
    # Windows.Foundation.IReference`1<System.Double> Windows.Devices.Sensors.HumanPresenceSensor::get_MinDetectableAzimuthInDegrees()
    @_property
    def min_detectable_azimuth_in_degrees(self) -> typing.Optional[winrt.system.Double]: ...

@typing.final
class HumanPresenceSensorReading(winrt.system.Object):
    # Windows.Foundation.IReference`1<System.UInt32> Windows.Devices.Sensors.HumanPresenceSensorReading::get_DistanceInMillimeters()
    @_property
    def distance_in_millimeters(self) -> typing.Optional[winrt.system.UInt32]: ...
    # Windows.Devices.Sensors.HumanEngagement Windows.Devices.Sensors.HumanPresenceSensorReading::get_Engagement()
    @_property
    def engagement(self) -> HumanEngagement: ...
    # Windows.Devices.Sensors.HumanPresence Windows.Devices.Sensors.HumanPresenceSensorReading::get_Presence()
    @_property
    def presence(self) -> HumanPresence: ...
    # Windows.Foundation.DateTime Windows.Devices.Sensors.HumanPresenceSensorReading::get_Timestamp()
    @_property
    def timestamp(self) -> datetime.datetime: ...
    # Windows.Foundation.Collections.IMapView`2<System.String,System.Object> Windows.Devices.Sensors.HumanPresenceSensorReading::get_Properties()
    @_property
    def properties(self) -> typing.Mapping[str, winrt.system.Object]: ...
    # Windows.Foundation.Collections.IVectorView`1<Windows.Devices.Sensors.DetectedPerson> Windows.Devices.Sensors.HumanPresenceSensorReading::get_DetectedPersons()
    @_property
    def detected_persons(self) -> typing.Sequence[DetectedPerson]: ...
    # Windows.Devices.Sensors.HumanPresence Windows.Devices.Sensors.HumanPresenceSensorReading::get_OnlookerPresence()
    @_property
    def onlooker_presence(self) -> HumanPresence: ...

@typing.final
class HumanPresenceSensorReadingChangedEventArgs(winrt.system.Object):
    # Windows.Devices.Sensors.HumanPresenceSensorReading Windows.Devices.Sensors.HumanPresenceSensorReadingChangedEventArgs::get_Reading()
    @_property
    def reading(self) -> HumanPresenceSensorReading: ...

@typing.final
class HumanPresenceSensorReadingUpdate(winrt.system.Object):
    def __new__(cls: typing.Type[Self]) -> Self: ...
    # Windows.Foundation.IReference`1<Windows.Foundation.DateTime> Windows.Devices.Sensors.HumanPresenceSensorReadingUpdate::get_Timestamp()
    @_property
    def timestamp(self) -> typing.Optional[datetime.datetime]: ...
    # System.Void Windows.Devices.Sensors.HumanPresenceSensorReadingUpdate::put_Timestamp(Windows.Foundation.IReference`1<Windows.Foundation.DateTime>)
    @timestamp.setter
    def timestamp(self, value: typing.Optional[datetime.datetime]) -> None: ...
    # Windows.Foundation.IReference`1<Windows.Devices.Sensors.HumanPresence> Windows.Devices.Sensors.HumanPresenceSensorReadingUpdate::get_Presence()
    @_property
    def presence(self) -> typing.Optional[HumanPresence]: ...
    # System.Void Windows.Devices.Sensors.HumanPresenceSensorReadingUpdate::put_Presence(Windows.Foundation.IReference`1<Windows.Devices.Sensors.HumanPresence>)
    @presence.setter
    def presence(self, value: typing.Optional[HumanPresence]) -> None: ...
    # Windows.Foundation.IReference`1<Windows.Devices.Sensors.HumanEngagement> Windows.Devices.Sensors.HumanPresenceSensorReadingUpdate::get_Engagement()
    @_property
    def engagement(self) -> typing.Optional[HumanEngagement]: ...
    # System.Void Windows.Devices.Sensors.HumanPresenceSensorReadingUpdate::put_Engagement(Windows.Foundation.IReference`1<Windows.Devices.Sensors.HumanEngagement>)
    @engagement.setter
    def engagement(self, value: typing.Optional[HumanEngagement]) -> None: ...
    # Windows.Foundation.IReference`1<System.UInt32> Windows.Devices.Sensors.HumanPresenceSensorReadingUpdate::get_DistanceInMillimeters()
    @_property
    def distance_in_millimeters(self) -> typing.Optional[winrt.system.UInt32]: ...
    # System.Void Windows.Devices.Sensors.HumanPresenceSensorReadingUpdate::put_DistanceInMillimeters(Windows.Foundation.IReference`1<System.UInt32>)
    @distance_in_millimeters.setter
    def distance_in_millimeters(self, value: typing.Optional[winrt.system.UInt32]) -> None: ...
    # Windows.Foundation.IReference`1<Windows.Devices.Sensors.HumanPresence> Windows.Devices.Sensors.HumanPresenceSensorReadingUpdate::get_OnlookerPresence()
    @_property
    def onlooker_presence(self) -> typing.Optional[HumanPresence]: ...
    # System.Void Windows.Devices.Sensors.HumanPresenceSensorReadingUpdate::put_OnlookerPresence(Windows.Foundation.IReference`1<Windows.Devices.Sensors.HumanPresence>)
    @onlooker_presence.setter
    def onlooker_presence(self, value: typing.Optional[HumanPresence]) -> None: ...

@typing.final
class HumanPresenceSettings_Static(winrt._winrt.IInspectable_Static):
    # Windows.Devices.Sensors.HumanPresenceSettings Windows.Devices.Sensors.HumanPresenceSettings::GetCurrentSettings()
    def get_current_settings(cls) -> HumanPresenceSettings: ...
    # Windows.Foundation.IAsyncOperation`1<Windows.Devices.Sensors.HumanPresenceSettings> Windows.Devices.Sensors.HumanPresenceSettings::GetCurrentSettingsAsync()
    def get_current_settings_async(cls) -> windows_foundation.IAsyncOperation[HumanPresenceSettings]: ...
    # Windows.Devices.Sensors.HumanPresenceFeatures Windows.Devices.Sensors.HumanPresenceSettings::GetSupportedFeaturesForSensorId(System.String)
    def get_supported_features_for_sensor_id(cls, sensor_id: str, /) -> HumanPresenceFeatures: ...
    # Windows.Foundation.IAsyncOperation`1<Windows.Devices.Sensors.HumanPresenceFeatures> Windows.Devices.Sensors.HumanPresenceSettings::GetSupportedFeaturesForSensorIdAsync(System.String)
    def get_supported_features_for_sensor_id_async(cls, sensor_id: str, /) -> windows_foundation.IAsyncOperation[HumanPresenceFeatures]: ...
    # Windows.Foundation.Collections.IVectorView`1<Windows.Foundation.TimeSpan> Windows.Devices.Sensors.HumanPresenceSettings::GetSupportedLockOnLeaveTimeouts()
    def get_supported_lock_on_leave_timeouts(cls) -> typing.Sequence[datetime.timedelta]: ...
    # System.Void Windows.Devices.Sensors.HumanPresenceSettings::UpdateSettings(Windows.Devices.Sensors.HumanPresenceSettings)
    def update_settings(cls, settings: HumanPresenceSettings, /) -> None: ...
    # Windows.Foundation.IAsyncAction Windows.Devices.Sensors.HumanPresenceSettings::UpdateSettingsAsync(Windows.Devices.Sensors.HumanPresenceSettings)
    def update_settings_async(cls, settings: HumanPresenceSettings, /) -> windows_foundation.IAsyncAction: ...
    # Windows.Foundation.EventRegistrationToken Windows.Devices.Sensors.HumanPresenceSettings::add_SettingsChanged(Windows.Foundation.EventHandler`1<System.Object>)
    def add_settings_changed(cls, handler: windows_foundation.EventHandler[winrt.system.Object], /) -> windows_foundation.EventRegistrationToken: ...
    # System.Void Windows.Devices.Sensors.HumanPresenceSettings::remove_SettingsChanged(Windows.Foundation.EventRegistrationToken)
    def remove_settings_changed(cls, token: typing.Union[windows_foundation.EventRegistrationToken, typing.Tuple[winrt.system.Int64]], /) -> None: ...

@typing.final
class HumanPresenceSettings(winrt.system.Object, metaclass=HumanPresenceSettings_Static):
    # Windows.Foundation.IReference`1<System.UInt32> Windows.Devices.Sensors.HumanPresenceSettings::get_WakeOnApproachDistanceInMillimeters()
    @_property
    def wake_on_approach_distance_in_millimeters(self) -> typing.Optional[winrt.system.UInt32]: ...
    # System.Void Windows.Devices.Sensors.HumanPresenceSettings::put_WakeOnApproachDistanceInMillimeters(Windows.Foundation.IReference`1<System.UInt32>)
    @wake_on_approach_distance_in_millimeters.setter
    def wake_on_approach_distance_in_millimeters(self, value: typing.Optional[winrt.system.UInt32]) -> None: ...
    # System.String Windows.Devices.Sensors.HumanPresenceSettings::get_SensorId()
    @_property
    def sensor_id(self) -> str: ...
    # System.Void Windows.Devices.Sensors.HumanPresenceSettings::put_SensorId(System.String)
    @sensor_id.setter
    def sensor_id(self, value: str) -> None: ...
    # Windows.Foundation.TimeSpan Windows.Devices.Sensors.HumanPresenceSettings::get_LockOnLeaveTimeout()
    @_property
    def lock_on_leave_timeout(self) -> datetime.timedelta: ...
    # System.Void Windows.Devices.Sensors.HumanPresenceSettings::put_LockOnLeaveTimeout(Windows.Foundation.TimeSpan)
    @lock_on_leave_timeout.setter
    def lock_on_leave_timeout(self, value: datetime.timedelta) -> None: ...
    # Windows.Foundation.IReference`1<System.UInt32> Windows.Devices.Sensors.HumanPresenceSettings::get_LockOnLeaveDistanceInMillimeters()
    @_property
    def lock_on_leave_distance_in_millimeters(self) -> typing.Optional[winrt.system.UInt32]: ...
    # System.Void Windows.Devices.Sensors.HumanPresenceSettings::put_LockOnLeaveDistanceInMillimeters(Windows.Foundation.IReference`1<System.UInt32>)
    @lock_on_leave_distance_in_millimeters.setter
    def lock_on_leave_distance_in_millimeters(self, value: typing.Optional[winrt.system.UInt32]) -> None: ...
    # System.Boolean Windows.Devices.Sensors.HumanPresenceSettings::get_IsWakeOnApproachEnabled()
    @_property
    def is_wake_on_approach_enabled(self) -> bool: ...
    # System.Void Windows.Devices.Sensors.HumanPresenceSettings::put_IsWakeOnApproachEnabled(System.Boolean)
    @is_wake_on_approach_enabled.setter
    def is_wake_on_approach_enabled(self, value: bool) -> None: ...
    # System.Boolean Windows.Devices.Sensors.HumanPresenceSettings::get_IsLockOnLeaveEnabled()
    @_property
    def is_lock_on_leave_enabled(self) -> bool: ...
    # System.Void Windows.Devices.Sensors.HumanPresenceSettings::put_IsLockOnLeaveEnabled(System.Boolean)
    @is_lock_on_leave_enabled.setter
    def is_lock_on_leave_enabled(self, value: bool) -> None: ...
    # System.Boolean Windows.Devices.Sensors.HumanPresenceSettings::get_IsAttentionAwareDimmingEnabled()
    @_property
    def is_attention_aware_dimming_enabled(self) -> bool: ...
    # System.Void Windows.Devices.Sensors.HumanPresenceSettings::put_IsAttentionAwareDimmingEnabled(System.Boolean)
    @is_attention_aware_dimming_enabled.setter
    def is_attention_aware_dimming_enabled(self, value: bool) -> None: ...
    # System.Boolean Windows.Devices.Sensors.HumanPresenceSettings::get_IsAdaptiveDimmingEnabled()
    @_property
    def is_adaptive_dimming_enabled(self) -> bool: ...
    # System.Void Windows.Devices.Sensors.HumanPresenceSettings::put_IsAdaptiveDimmingEnabled(System.Boolean)
    @is_adaptive_dimming_enabled.setter
    def is_adaptive_dimming_enabled(self, value: bool) -> None: ...
    # Windows.Devices.Sensors.AdaptiveDimmingOptions Windows.Devices.Sensors.HumanPresenceSettings::get_DimmingOptions()
    @_property
    def dimming_options(self) -> AdaptiveDimmingOptions: ...
    # Windows.Devices.Sensors.LockOnLeaveOptions Windows.Devices.Sensors.HumanPresenceSettings::get_LockOptions()
    @_property
    def lock_options(self) -> LockOnLeaveOptions: ...
    # Windows.Devices.Sensors.WakeOnApproachOptions Windows.Devices.Sensors.HumanPresenceSettings::get_WakeOptions()
    @_property
    def wake_options(self) -> WakeOnApproachOptions: ...
    # System.Boolean Windows.Devices.Sensors.HumanPresenceSettings::get_IsOnlookerDetectionEnabled()
    @_property
    def is_onlooker_detection_enabled(self) -> bool: ...
    # System.Void Windows.Devices.Sensors.HumanPresenceSettings::put_IsOnlookerDetectionEnabled(System.Boolean)
    @is_onlooker_detection_enabled.setter
    def is_onlooker_detection_enabled(self, value: bool) -> None: ...
    # Windows.Devices.Sensors.OnlookerDetectionOptions Windows.Devices.Sensors.HumanPresenceSettings::get_OnlookerDetectionOptions()
    @_property
    def onlooker_detection_options(self) -> OnlookerDetectionOptions: ...

@typing.final
class Inclinometer_Static(winrt._winrt.IInspectable_Static):
    # Windows.Foundation.IAsyncOperation`1<Windows.Devices.Sensors.Inclinometer> Windows.Devices.Sensors.Inclinometer::FromIdAsync(System.String)
    def from_id_async(cls, device_id: str, /) -> windows_foundation.IAsyncOperation[Inclinometer]: ...
    # Windows.Devices.Sensors.Inclinometer Windows.Devices.Sensors.Inclinometer::GetDefault()
    def get_default(cls) -> Inclinometer: ...
    # Windows.Devices.Sensors.Inclinometer Windows.Devices.Sensors.Inclinometer::GetDefaultForRelativeReadings()
    def get_default_for_relative_readings(cls) -> Inclinometer: ...
    # Windows.Devices.Sensors.Inclinometer Windows.Devices.Sensors.Inclinometer::GetDefault(Windows.Devices.Sensors.SensorReadingType)
    def get_default_with_sensor_reading_type(cls, sensor_readingtype: SensorReadingType, /) -> Inclinometer: ...
    # System.String Windows.Devices.Sensors.Inclinometer::GetDeviceSelector(Windows.Devices.Sensors.SensorReadingType)
    def get_device_selector(cls, reading_type: SensorReadingType, /) -> str: ...

@typing.final
class Inclinometer(winrt.system.Object, metaclass=Inclinometer_Static):
    # Windows.Devices.Sensors.InclinometerReading Windows.Devices.Sensors.Inclinometer::GetCurrentReading()
    def get_current_reading(self) -> InclinometerReading: ...
    # Windows.Foundation.EventRegistrationToken Windows.Devices.Sensors.Inclinometer::add_ReadingChanged(Windows.Foundation.TypedEventHandler`2<Windows.Devices.Sensors.Inclinometer,Windows.Devices.Sensors.InclinometerReadingChangedEventArgs>)
    def add_reading_changed(self, handler: windows_foundation.TypedEventHandler[Inclinometer, InclinometerReadingChangedEventArgs], /) -> windows_foundation.EventRegistrationToken: ...
    # System.Void Windows.Devices.Sensors.Inclinometer::remove_ReadingChanged(Windows.Foundation.EventRegistrationToken)
    def remove_reading_changed(self, token: typing.Union[windows_foundation.EventRegistrationToken, typing.Tuple[winrt.system.Int64]], /) -> None: ...
    # System.UInt32 Windows.Devices.Sensors.Inclinometer::get_ReportInterval()
    @_property
    def report_interval(self) -> winrt.system.UInt32: ...
    # System.Void Windows.Devices.Sensors.Inclinometer::put_ReportInterval(System.UInt32)
    @report_interval.setter
    def report_interval(self, value: winrt.system.UInt32) -> None: ...
    # System.UInt32 Windows.Devices.Sensors.Inclinometer::get_MinimumReportInterval()
    @_property
    def minimum_report_interval(self) -> winrt.system.UInt32: ...
    # Windows.Graphics.Display.DisplayOrientations Windows.Devices.Sensors.Inclinometer::get_ReadingTransform()
    @_property
    def reading_transform(self) -> windows_graphics_display.DisplayOrientations: ...
    # System.Void Windows.Devices.Sensors.Inclinometer::put_ReadingTransform(Windows.Graphics.Display.DisplayOrientations)
    @reading_transform.setter
    def reading_transform(self, value: windows_graphics_display.DisplayOrientations) -> None: ...
    # Windows.Devices.Sensors.SensorReadingType Windows.Devices.Sensors.Inclinometer::get_ReadingType()
    @_property
    def reading_type(self) -> SensorReadingType: ...
    # System.UInt32 Windows.Devices.Sensors.Inclinometer::get_ReportLatency()
    @_property
    def report_latency(self) -> winrt.system.UInt32: ...
    # System.Void Windows.Devices.Sensors.Inclinometer::put_ReportLatency(System.UInt32)
    @report_latency.setter
    def report_latency(self, value: winrt.system.UInt32) -> None: ...
    # System.UInt32 Windows.Devices.Sensors.Inclinometer::get_MaxBatchSize()
    @_property
    def max_batch_size(self) -> winrt.system.UInt32: ...
    # Windows.Devices.Sensors.InclinometerDataThreshold Windows.Devices.Sensors.Inclinometer::get_ReportThreshold()
    @_property
    def report_threshold(self) -> InclinometerDataThreshold: ...
    # System.String Windows.Devices.Sensors.Inclinometer::get_DeviceId()
    @_property
    def device_id(self) -> str: ...

@typing.final
class InclinometerDataThreshold(winrt.system.Object):
    # System.Single Windows.Devices.Sensors.InclinometerDataThreshold::get_YawInDegrees()
    @_property
    def yaw_in_degrees(self) -> winrt.system.Single: ...
    # System.Void Windows.Devices.Sensors.InclinometerDataThreshold::put_YawInDegrees(System.Single)
    @yaw_in_degrees.setter
    def yaw_in_degrees(self, value: winrt.system.Single) -> None: ...
    # System.Single Windows.Devices.Sensors.InclinometerDataThreshold::get_RollInDegrees()
    @_property
    def roll_in_degrees(self) -> winrt.system.Single: ...
    # System.Void Windows.Devices.Sensors.InclinometerDataThreshold::put_RollInDegrees(System.Single)
    @roll_in_degrees.setter
    def roll_in_degrees(self, value: winrt.system.Single) -> None: ...
    # System.Single Windows.Devices.Sensors.InclinometerDataThreshold::get_PitchInDegrees()
    @_property
    def pitch_in_degrees(self) -> winrt.system.Single: ...
    # System.Void Windows.Devices.Sensors.InclinometerDataThreshold::put_PitchInDegrees(System.Single)
    @pitch_in_degrees.setter
    def pitch_in_degrees(self, value: winrt.system.Single) -> None: ...

@typing.final
class InclinometerReading(winrt.system.Object):
    # System.Single Windows.Devices.Sensors.InclinometerReading::get_PitchDegrees()
    @_property
    def pitch_degrees(self) -> winrt.system.Single: ...
    # System.Single Windows.Devices.Sensors.InclinometerReading::get_RollDegrees()
    @_property
    def roll_degrees(self) -> winrt.system.Single: ...
    # Windows.Foundation.DateTime Windows.Devices.Sensors.InclinometerReading::get_Timestamp()
    @_property
    def timestamp(self) -> datetime.datetime: ...
    # System.Single Windows.Devices.Sensors.InclinometerReading::get_YawDegrees()
    @_property
    def yaw_degrees(self) -> winrt.system.Single: ...
    # Windows.Foundation.IReference`1<Windows.Foundation.TimeSpan> Windows.Devices.Sensors.InclinometerReading::get_PerformanceCount()
    @_property
    def performance_count(self) -> typing.Optional[datetime.timedelta]: ...
    # Windows.Foundation.Collections.IMapView`2<System.String,System.Object> Windows.Devices.Sensors.InclinometerReading::get_Properties()
    @_property
    def properties(self) -> typing.Mapping[str, winrt.system.Object]: ...
    # Windows.Devices.Sensors.MagnetometerAccuracy Windows.Devices.Sensors.InclinometerReading::get_YawAccuracy()
    @_property
    def yaw_accuracy(self) -> MagnetometerAccuracy: ...

@typing.final
class InclinometerReadingChangedEventArgs(winrt.system.Object):
    # Windows.Devices.Sensors.InclinometerReading Windows.Devices.Sensors.InclinometerReadingChangedEventArgs::get_Reading()
    @_property
    def reading(self) -> InclinometerReading: ...

@typing.final
class LightSensor_Static(winrt._winrt.IInspectable_Static):
    # Windows.Foundation.IAsyncOperation`1<Windows.Devices.Sensors.LightSensor> Windows.Devices.Sensors.LightSensor::FromIdAsync(System.String)
    def from_id_async(cls, device_id: str, /) -> windows_foundation.IAsyncOperation[LightSensor]: ...
    # Windows.Devices.Sensors.LightSensor Windows.Devices.Sensors.LightSensor::GetDefault()
    def get_default(cls) -> LightSensor: ...
    # System.String Windows.Devices.Sensors.LightSensor::GetDeviceSelector()
    def get_device_selector(cls) -> str: ...

@typing.final
class LightSensor(winrt.system.Object, metaclass=LightSensor_Static):
    # Windows.Devices.Sensors.LightSensorReading Windows.Devices.Sensors.LightSensor::GetCurrentReading()
    def get_current_reading(self) -> LightSensorReading: ...
    # System.Boolean Windows.Devices.Sensors.LightSensor::IsChromaticitySupported()
    def is_chromaticity_supported(self) -> bool: ...
    # Windows.Foundation.EventRegistrationToken Windows.Devices.Sensors.LightSensor::add_ReadingChanged(Windows.Foundation.TypedEventHandler`2<Windows.Devices.Sensors.LightSensor,Windows.Devices.Sensors.LightSensorReadingChangedEventArgs>)
    def add_reading_changed(self, handler: windows_foundation.TypedEventHandler[LightSensor, LightSensorReadingChangedEventArgs], /) -> windows_foundation.EventRegistrationToken: ...
    # System.Void Windows.Devices.Sensors.LightSensor::remove_ReadingChanged(Windows.Foundation.EventRegistrationToken)
    def remove_reading_changed(self, token: typing.Union[windows_foundation.EventRegistrationToken, typing.Tuple[winrt.system.Int64]], /) -> None: ...
    # System.UInt32 Windows.Devices.Sensors.LightSensor::get_ReportInterval()
    @_property
    def report_interval(self) -> winrt.system.UInt32: ...
    # System.Void Windows.Devices.Sensors.LightSensor::put_ReportInterval(System.UInt32)
    @report_interval.setter
    def report_interval(self, value: winrt.system.UInt32) -> None: ...
    # System.UInt32 Windows.Devices.Sensors.LightSensor::get_MinimumReportInterval()
    @_property
    def minimum_report_interval(self) -> winrt.system.UInt32: ...
    # System.UInt32 Windows.Devices.Sensors.LightSensor::get_ReportLatency()
    @_property
    def report_latency(self) -> winrt.system.UInt32: ...
    # System.Void Windows.Devices.Sensors.LightSensor::put_ReportLatency(System.UInt32)
    @report_latency.setter
    def report_latency(self, value: winrt.system.UInt32) -> None: ...
    # System.UInt32 Windows.Devices.Sensors.LightSensor::get_MaxBatchSize()
    @_property
    def max_batch_size(self) -> winrt.system.UInt32: ...
    # Windows.Devices.Sensors.LightSensorDataThreshold Windows.Devices.Sensors.LightSensor::get_ReportThreshold()
    @_property
    def report_threshold(self) -> LightSensorDataThreshold: ...
    # System.String Windows.Devices.Sensors.LightSensor::get_DeviceId()
    @_property
    def device_id(self) -> str: ...

@typing.final
class LightSensorDataThreshold(winrt.system.Object):
    # System.Single Windows.Devices.Sensors.LightSensorDataThreshold::get_LuxPercentage()
    @_property
    def lux_percentage(self) -> winrt.system.Single: ...
    # System.Void Windows.Devices.Sensors.LightSensorDataThreshold::put_LuxPercentage(System.Single)
    @lux_percentage.setter
    def lux_percentage(self, value: winrt.system.Single) -> None: ...
    # System.Single Windows.Devices.Sensors.LightSensorDataThreshold::get_AbsoluteLux()
    @_property
    def absolute_lux(self) -> winrt.system.Single: ...
    # System.Void Windows.Devices.Sensors.LightSensorDataThreshold::put_AbsoluteLux(System.Single)
    @absolute_lux.setter
    def absolute_lux(self, value: winrt.system.Single) -> None: ...
    # Windows.Devices.Sensors.LightSensorChromaticity Windows.Devices.Sensors.LightSensorDataThreshold::get_Chromaticity()
    @_property
    def chromaticity(self) -> LightSensorChromaticity: ...
    # System.Void Windows.Devices.Sensors.LightSensorDataThreshold::put_Chromaticity(Windows.Devices.Sensors.LightSensorChromaticity)
    @chromaticity.setter
    def chromaticity(self, value: typing.Union[LightSensorChromaticity, typing.Tuple[winrt.system.Double, winrt.system.Double]]) -> None: ...

@typing.final
class LightSensorReading(winrt.system.Object):
    # System.Single Windows.Devices.Sensors.LightSensorReading::get_IlluminanceInLux()
    @_property
    def illuminance_in_lux(self) -> winrt.system.Single: ...
    # Windows.Foundation.DateTime Windows.Devices.Sensors.LightSensorReading::get_Timestamp()
    @_property
    def timestamp(self) -> datetime.datetime: ...
    # Windows.Foundation.IReference`1<Windows.Foundation.TimeSpan> Windows.Devices.Sensors.LightSensorReading::get_PerformanceCount()
    @_property
    def performance_count(self) -> typing.Optional[datetime.timedelta]: ...
    # Windows.Foundation.Collections.IMapView`2<System.String,System.Object> Windows.Devices.Sensors.LightSensorReading::get_Properties()
    @_property
    def properties(self) -> typing.Mapping[str, winrt.system.Object]: ...
    # Windows.Devices.Sensors.LightSensorChromaticity Windows.Devices.Sensors.LightSensorReading::get_Chromaticity()
    @_property
    def chromaticity(self) -> LightSensorChromaticity: ...

@typing.final
class LightSensorReadingChangedEventArgs(winrt.system.Object):
    # Windows.Devices.Sensors.LightSensorReading Windows.Devices.Sensors.LightSensorReadingChangedEventArgs::get_Reading()
    @_property
    def reading(self) -> LightSensorReading: ...

@typing.final
class LockOnLeaveOptions(winrt.system.Object):
    # System.Boolean Windows.Devices.Sensors.LockOnLeaveOptions::get_AllowWhenExternalDisplayConnected()
    @_property
    def allow_when_external_display_connected(self) -> bool: ...
    # System.Void Windows.Devices.Sensors.LockOnLeaveOptions::put_AllowWhenExternalDisplayConnected(System.Boolean)
    @allow_when_external_display_connected.setter
    def allow_when_external_display_connected(self, value: bool) -> None: ...

@typing.final
class Magnetometer_Static(winrt._winrt.IInspectable_Static):
    # Windows.Foundation.IAsyncOperation`1<Windows.Devices.Sensors.Magnetometer> Windows.Devices.Sensors.Magnetometer::FromIdAsync(System.String)
    def from_id_async(cls, device_id: str, /) -> windows_foundation.IAsyncOperation[Magnetometer]: ...
    # Windows.Devices.Sensors.Magnetometer Windows.Devices.Sensors.Magnetometer::GetDefault()
    def get_default(cls) -> Magnetometer: ...
    # System.String Windows.Devices.Sensors.Magnetometer::GetDeviceSelector()
    def get_device_selector(cls) -> str: ...

@typing.final
class Magnetometer(winrt.system.Object, metaclass=Magnetometer_Static):
    # Windows.Devices.Sensors.MagnetometerReading Windows.Devices.Sensors.Magnetometer::GetCurrentReading()
    def get_current_reading(self) -> MagnetometerReading: ...
    # Windows.Foundation.EventRegistrationToken Windows.Devices.Sensors.Magnetometer::add_ReadingChanged(Windows.Foundation.TypedEventHandler`2<Windows.Devices.Sensors.Magnetometer,Windows.Devices.Sensors.MagnetometerReadingChangedEventArgs>)
    def add_reading_changed(self, handler: windows_foundation.TypedEventHandler[Magnetometer, MagnetometerReadingChangedEventArgs], /) -> windows_foundation.EventRegistrationToken: ...
    # System.Void Windows.Devices.Sensors.Magnetometer::remove_ReadingChanged(Windows.Foundation.EventRegistrationToken)
    def remove_reading_changed(self, token: typing.Union[windows_foundation.EventRegistrationToken, typing.Tuple[winrt.system.Int64]], /) -> None: ...
    # System.UInt32 Windows.Devices.Sensors.Magnetometer::get_ReportInterval()
    @_property
    def report_interval(self) -> winrt.system.UInt32: ...
    # System.Void Windows.Devices.Sensors.Magnetometer::put_ReportInterval(System.UInt32)
    @report_interval.setter
    def report_interval(self, value: winrt.system.UInt32) -> None: ...
    # System.UInt32 Windows.Devices.Sensors.Magnetometer::get_MinimumReportInterval()
    @_property
    def minimum_report_interval(self) -> winrt.system.UInt32: ...
    # Windows.Graphics.Display.DisplayOrientations Windows.Devices.Sensors.Magnetometer::get_ReadingTransform()
    @_property
    def reading_transform(self) -> windows_graphics_display.DisplayOrientations: ...
    # System.Void Windows.Devices.Sensors.Magnetometer::put_ReadingTransform(Windows.Graphics.Display.DisplayOrientations)
    @reading_transform.setter
    def reading_transform(self, value: windows_graphics_display.DisplayOrientations) -> None: ...
    # System.UInt32 Windows.Devices.Sensors.Magnetometer::get_ReportLatency()
    @_property
    def report_latency(self) -> winrt.system.UInt32: ...
    # System.Void Windows.Devices.Sensors.Magnetometer::put_ReportLatency(System.UInt32)
    @report_latency.setter
    def report_latency(self, value: winrt.system.UInt32) -> None: ...
    # System.UInt32 Windows.Devices.Sensors.Magnetometer::get_MaxBatchSize()
    @_property
    def max_batch_size(self) -> winrt.system.UInt32: ...
    # Windows.Devices.Sensors.MagnetometerDataThreshold Windows.Devices.Sensors.Magnetometer::get_ReportThreshold()
    @_property
    def report_threshold(self) -> MagnetometerDataThreshold: ...
    # System.String Windows.Devices.Sensors.Magnetometer::get_DeviceId()
    @_property
    def device_id(self) -> str: ...

@typing.final
class MagnetometerDataThreshold(winrt.system.Object):
    # System.Single Windows.Devices.Sensors.MagnetometerDataThreshold::get_ZAxisMicroteslas()
    @_property
    def z_axis_microteslas(self) -> winrt.system.Single: ...
    # System.Void Windows.Devices.Sensors.MagnetometerDataThreshold::put_ZAxisMicroteslas(System.Single)
    @z_axis_microteslas.setter
    def z_axis_microteslas(self, value: winrt.system.Single) -> None: ...
    # System.Single Windows.Devices.Sensors.MagnetometerDataThreshold::get_YAxisMicroteslas()
    @_property
    def y_axis_microteslas(self) -> winrt.system.Single: ...
    # System.Void Windows.Devices.Sensors.MagnetometerDataThreshold::put_YAxisMicroteslas(System.Single)
    @y_axis_microteslas.setter
    def y_axis_microteslas(self, value: winrt.system.Single) -> None: ...
    # System.Single Windows.Devices.Sensors.MagnetometerDataThreshold::get_XAxisMicroteslas()
    @_property
    def x_axis_microteslas(self) -> winrt.system.Single: ...
    # System.Void Windows.Devices.Sensors.MagnetometerDataThreshold::put_XAxisMicroteslas(System.Single)
    @x_axis_microteslas.setter
    def x_axis_microteslas(self, value: winrt.system.Single) -> None: ...

@typing.final
class MagnetometerReading(winrt.system.Object):
    # Windows.Devices.Sensors.MagnetometerAccuracy Windows.Devices.Sensors.MagnetometerReading::get_DirectionalAccuracy()
    @_property
    def directional_accuracy(self) -> MagnetometerAccuracy: ...
    # System.Single Windows.Devices.Sensors.MagnetometerReading::get_MagneticFieldX()
    @_property
    def magnetic_field_x(self) -> winrt.system.Single: ...
    # System.Single Windows.Devices.Sensors.MagnetometerReading::get_MagneticFieldY()
    @_property
    def magnetic_field_y(self) -> winrt.system.Single: ...
    # System.Single Windows.Devices.Sensors.MagnetometerReading::get_MagneticFieldZ()
    @_property
    def magnetic_field_z(self) -> winrt.system.Single: ...
    # Windows.Foundation.DateTime Windows.Devices.Sensors.MagnetometerReading::get_Timestamp()
    @_property
    def timestamp(self) -> datetime.datetime: ...
    # Windows.Foundation.IReference`1<Windows.Foundation.TimeSpan> Windows.Devices.Sensors.MagnetometerReading::get_PerformanceCount()
    @_property
    def performance_count(self) -> typing.Optional[datetime.timedelta]: ...
    # Windows.Foundation.Collections.IMapView`2<System.String,System.Object> Windows.Devices.Sensors.MagnetometerReading::get_Properties()
    @_property
    def properties(self) -> typing.Mapping[str, winrt.system.Object]: ...

@typing.final
class MagnetometerReadingChangedEventArgs(winrt.system.Object):
    # Windows.Devices.Sensors.MagnetometerReading Windows.Devices.Sensors.MagnetometerReadingChangedEventArgs::get_Reading()
    @_property
    def reading(self) -> MagnetometerReading: ...

@typing.final
class OnlookerDetectionOptions(winrt.system.Object):
    # Windows.Devices.Sensors.OnlookerDetectionBackOnMode Windows.Devices.Sensors.OnlookerDetectionOptions::get_BackOnMode()
    @_property
    def back_on_mode(self) -> OnlookerDetectionBackOnMode: ...
    # System.Void Windows.Devices.Sensors.OnlookerDetectionOptions::put_BackOnMode(Windows.Devices.Sensors.OnlookerDetectionBackOnMode)
    @back_on_mode.setter
    def back_on_mode(self, value: OnlookerDetectionBackOnMode) -> None: ...
    # Windows.Devices.Sensors.OnlookerDetectionAction Windows.Devices.Sensors.OnlookerDetectionOptions::get_Action()
    @_property
    def action(self) -> OnlookerDetectionAction: ...
    # System.Void Windows.Devices.Sensors.OnlookerDetectionOptions::put_Action(Windows.Devices.Sensors.OnlookerDetectionAction)
    @action.setter
    def action(self, value: OnlookerDetectionAction) -> None: ...

@typing.final
class OrientationSensor_Static(winrt._winrt.IInspectable_Static):
    # Windows.Foundation.IAsyncOperation`1<Windows.Devices.Sensors.OrientationSensor> Windows.Devices.Sensors.OrientationSensor::FromIdAsync(System.String)
    def from_id_async(cls, device_id: str, /) -> windows_foundation.IAsyncOperation[OrientationSensor]: ...
    # Windows.Devices.Sensors.OrientationSensor Windows.Devices.Sensors.OrientationSensor::GetDefault()
    def get_default(cls) -> OrientationSensor: ...
    # Windows.Devices.Sensors.OrientationSensor Windows.Devices.Sensors.OrientationSensor::GetDefaultForRelativeReadings()
    def get_default_for_relative_readings(cls) -> OrientationSensor: ...
    # Windows.Devices.Sensors.OrientationSensor Windows.Devices.Sensors.OrientationSensor::GetDefault(Windows.Devices.Sensors.SensorReadingType)
    def get_default_with_sensor_reading_type(cls, sensor_readingtype: SensorReadingType, /) -> OrientationSensor: ...
    # Windows.Devices.Sensors.OrientationSensor Windows.Devices.Sensors.OrientationSensor::GetDefault(Windows.Devices.Sensors.SensorReadingType,Windows.Devices.Sensors.SensorOptimizationGoal)
    def get_default_with_sensor_reading_type_and_sensor_optimization_goal(cls, sensor_reading_type: SensorReadingType, optimization_goal: SensorOptimizationGoal, /) -> OrientationSensor: ...
    # System.String Windows.Devices.Sensors.OrientationSensor::GetDeviceSelector(Windows.Devices.Sensors.SensorReadingType)
    def get_device_selector(cls, reading_type: SensorReadingType, /) -> str: ...
    # System.String Windows.Devices.Sensors.OrientationSensor::GetDeviceSelector(Windows.Devices.Sensors.SensorReadingType,Windows.Devices.Sensors.SensorOptimizationGoal)
    def get_device_selector_with_sensor_reading_type_and_sensor_optimization_goal(cls, reading_type: SensorReadingType, optimization_goal: SensorOptimizationGoal, /) -> str: ...

@typing.final
class OrientationSensor(winrt.system.Object, metaclass=OrientationSensor_Static):
    # Windows.Devices.Sensors.OrientationSensorReading Windows.Devices.Sensors.OrientationSensor::GetCurrentReading()
    def get_current_reading(self) -> OrientationSensorReading: ...
    # Windows.Foundation.EventRegistrationToken Windows.Devices.Sensors.OrientationSensor::add_ReadingChanged(Windows.Foundation.TypedEventHandler`2<Windows.Devices.Sensors.OrientationSensor,Windows.Devices.Sensors.OrientationSensorReadingChangedEventArgs>)
    def add_reading_changed(self, handler: windows_foundation.TypedEventHandler[OrientationSensor, OrientationSensorReadingChangedEventArgs], /) -> windows_foundation.EventRegistrationToken: ...
    # System.Void Windows.Devices.Sensors.OrientationSensor::remove_ReadingChanged(Windows.Foundation.EventRegistrationToken)
    def remove_reading_changed(self, token: typing.Union[windows_foundation.EventRegistrationToken, typing.Tuple[winrt.system.Int64]], /) -> None: ...
    # System.UInt32 Windows.Devices.Sensors.OrientationSensor::get_ReportInterval()
    @_property
    def report_interval(self) -> winrt.system.UInt32: ...
    # System.Void Windows.Devices.Sensors.OrientationSensor::put_ReportInterval(System.UInt32)
    @report_interval.setter
    def report_interval(self, value: winrt.system.UInt32) -> None: ...
    # System.UInt32 Windows.Devices.Sensors.OrientationSensor::get_MinimumReportInterval()
    @_property
    def minimum_report_interval(self) -> winrt.system.UInt32: ...
    # Windows.Graphics.Display.DisplayOrientations Windows.Devices.Sensors.OrientationSensor::get_ReadingTransform()
    @_property
    def reading_transform(self) -> windows_graphics_display.DisplayOrientations: ...
    # System.Void Windows.Devices.Sensors.OrientationSensor::put_ReadingTransform(Windows.Graphics.Display.DisplayOrientations)
    @reading_transform.setter
    def reading_transform(self, value: windows_graphics_display.DisplayOrientations) -> None: ...
    # Windows.Devices.Sensors.SensorReadingType Windows.Devices.Sensors.OrientationSensor::get_ReadingType()
    @_property
    def reading_type(self) -> SensorReadingType: ...
    # System.UInt32 Windows.Devices.Sensors.OrientationSensor::get_ReportLatency()
    @_property
    def report_latency(self) -> winrt.system.UInt32: ...
    # System.Void Windows.Devices.Sensors.OrientationSensor::put_ReportLatency(System.UInt32)
    @report_latency.setter
    def report_latency(self, value: winrt.system.UInt32) -> None: ...
    # System.UInt32 Windows.Devices.Sensors.OrientationSensor::get_MaxBatchSize()
    @_property
    def max_batch_size(self) -> winrt.system.UInt32: ...
    # System.String Windows.Devices.Sensors.OrientationSensor::get_DeviceId()
    @_property
    def device_id(self) -> str: ...

@typing.final
class OrientationSensorReading(winrt.system.Object):
    # Windows.Devices.Sensors.SensorQuaternion Windows.Devices.Sensors.OrientationSensorReading::get_Quaternion()
    @_property
    def quaternion(self) -> SensorQuaternion: ...
    # Windows.Devices.Sensors.SensorRotationMatrix Windows.Devices.Sensors.OrientationSensorReading::get_RotationMatrix()
    @_property
    def rotation_matrix(self) -> SensorRotationMatrix: ...
    # Windows.Foundation.DateTime Windows.Devices.Sensors.OrientationSensorReading::get_Timestamp()
    @_property
    def timestamp(self) -> datetime.datetime: ...
    # Windows.Foundation.IReference`1<Windows.Foundation.TimeSpan> Windows.Devices.Sensors.OrientationSensorReading::get_PerformanceCount()
    @_property
    def performance_count(self) -> typing.Optional[datetime.timedelta]: ...
    # Windows.Foundation.Collections.IMapView`2<System.String,System.Object> Windows.Devices.Sensors.OrientationSensorReading::get_Properties()
    @_property
    def properties(self) -> typing.Mapping[str, winrt.system.Object]: ...
    # Windows.Devices.Sensors.MagnetometerAccuracy Windows.Devices.Sensors.OrientationSensorReading::get_YawAccuracy()
    @_property
    def yaw_accuracy(self) -> MagnetometerAccuracy: ...

@typing.final
class OrientationSensorReadingChangedEventArgs(winrt.system.Object):
    # Windows.Devices.Sensors.OrientationSensorReading Windows.Devices.Sensors.OrientationSensorReadingChangedEventArgs::get_Reading()
    @_property
    def reading(self) -> OrientationSensorReading: ...

@typing.final
class Pedometer_Static(winrt._winrt.IInspectable_Static):
    # Windows.Foundation.IAsyncOperation`1<Windows.Devices.Sensors.Pedometer> Windows.Devices.Sensors.Pedometer::FromIdAsync(System.String)
    def from_id_async(cls, device_id: str, /) -> windows_foundation.IAsyncOperation[Pedometer]: ...
    # Windows.Foundation.IAsyncOperation`1<Windows.Devices.Sensors.Pedometer> Windows.Devices.Sensors.Pedometer::GetDefaultAsync()
    def get_default_async(cls) -> windows_foundation.IAsyncOperation[Pedometer]: ...
    # System.String Windows.Devices.Sensors.Pedometer::GetDeviceSelector()
    def get_device_selector(cls) -> str: ...
    # Windows.Foundation.Collections.IVectorView`1<Windows.Devices.Sensors.PedometerReading> Windows.Devices.Sensors.Pedometer::GetReadingsFromTriggerDetails(Windows.Devices.Sensors.SensorDataThresholdTriggerDetails)
    def get_readings_from_trigger_details(cls, trigger_details: SensorDataThresholdTriggerDetails, /) -> typing.Sequence[PedometerReading]: ...
    # Windows.Foundation.IAsyncOperation`1<Windows.Foundation.Collections.IVectorView`1<Windows.Devices.Sensors.PedometerReading>> Windows.Devices.Sensors.Pedometer::GetSystemHistoryAsync(Windows.Foundation.DateTime)
    def get_system_history_async(cls, from_time: datetime.datetime, /) -> windows_foundation.IAsyncOperation[typing.Sequence[PedometerReading]]: ...
    # Windows.Foundation.IAsyncOperation`1<Windows.Foundation.Collections.IVectorView`1<Windows.Devices.Sensors.PedometerReading>> Windows.Devices.Sensors.Pedometer::GetSystemHistoryAsync(Windows.Foundation.DateTime,Windows.Foundation.TimeSpan)
    def get_system_history_with_duration_async(cls, from_time: datetime.datetime, duration: datetime.timedelta, /) -> windows_foundation.IAsyncOperation[typing.Sequence[PedometerReading]]: ...

@typing.final
class Pedometer(winrt.system.Object, metaclass=Pedometer_Static):
    # Windows.Foundation.Collections.IMapView`2<Windows.Devices.Sensors.PedometerStepKind,Windows.Devices.Sensors.PedometerReading> Windows.Devices.Sensors.Pedometer::GetCurrentReadings()
    def get_current_readings(self) -> typing.Mapping[PedometerStepKind, PedometerReading]: ...
    # Windows.Foundation.EventRegistrationToken Windows.Devices.Sensors.Pedometer::add_ReadingChanged(Windows.Foundation.TypedEventHandler`2<Windows.Devices.Sensors.Pedometer,Windows.Devices.Sensors.PedometerReadingChangedEventArgs>)
    def add_reading_changed(self, handler: windows_foundation.TypedEventHandler[Pedometer, PedometerReadingChangedEventArgs], /) -> windows_foundation.EventRegistrationToken: ...
    # System.Void Windows.Devices.Sensors.Pedometer::remove_ReadingChanged(Windows.Foundation.EventRegistrationToken)
    def remove_reading_changed(self, token: typing.Union[windows_foundation.EventRegistrationToken, typing.Tuple[winrt.system.Int64]], /) -> None: ...
    # System.UInt32 Windows.Devices.Sensors.Pedometer::get_ReportInterval()
    @_property
    def report_interval(self) -> winrt.system.UInt32: ...
    # System.Void Windows.Devices.Sensors.Pedometer::put_ReportInterval(System.UInt32)
    @report_interval.setter
    def report_interval(self, value: winrt.system.UInt32) -> None: ...
    # System.String Windows.Devices.Sensors.Pedometer::get_DeviceId()
    @_property
    def device_id(self) -> str: ...
    # System.UInt32 Windows.Devices.Sensors.Pedometer::get_MinimumReportInterval()
    @_property
    def minimum_report_interval(self) -> winrt.system.UInt32: ...
    # System.Double Windows.Devices.Sensors.Pedometer::get_PowerInMilliwatts()
    @_property
    def power_in_milliwatts(self) -> winrt.system.Double: ...

@typing.final
class PedometerDataThreshold(winrt.system.Object, ISensorDataThreshold):
    def __new__(cls: typing.Type[Self], sensor: Pedometer, step_goal: winrt.system.Int32) -> Self: ...

@typing.final
class PedometerReading(winrt.system.Object):
    # System.Int32 Windows.Devices.Sensors.PedometerReading::get_CumulativeSteps()
    @_property
    def cumulative_steps(self) -> winrt.system.Int32: ...
    # Windows.Foundation.TimeSpan Windows.Devices.Sensors.PedometerReading::get_CumulativeStepsDuration()
    @_property
    def cumulative_steps_duration(self) -> datetime.timedelta: ...
    # Windows.Devices.Sensors.PedometerStepKind Windows.Devices.Sensors.PedometerReading::get_StepKind()
    @_property
    def step_kind(self) -> PedometerStepKind: ...
    # Windows.Foundation.DateTime Windows.Devices.Sensors.PedometerReading::get_Timestamp()
    @_property
    def timestamp(self) -> datetime.datetime: ...

@typing.final
class PedometerReadingChangedEventArgs(winrt.system.Object):
    # Windows.Devices.Sensors.PedometerReading Windows.Devices.Sensors.PedometerReadingChangedEventArgs::get_Reading()
    @_property
    def reading(self) -> PedometerReading: ...

@typing.final
class ProximitySensor_Static(winrt._winrt.IInspectable_Static):
    # Windows.Devices.Sensors.ProximitySensor Windows.Devices.Sensors.ProximitySensor::FromId(System.String)
    def from_id(cls, sensor_id: str, /) -> ProximitySensor: ...
    # System.String Windows.Devices.Sensors.ProximitySensor::GetDeviceSelector()
    def get_device_selector(cls) -> str: ...
    # Windows.Foundation.Collections.IVectorView`1<Windows.Devices.Sensors.ProximitySensorReading> Windows.Devices.Sensors.ProximitySensor::GetReadingsFromTriggerDetails(Windows.Devices.Sensors.SensorDataThresholdTriggerDetails)
    def get_readings_from_trigger_details(cls, trigger_details: SensorDataThresholdTriggerDetails, /) -> typing.Sequence[ProximitySensorReading]: ...

@typing.final
class ProximitySensor(winrt.system.Object, metaclass=ProximitySensor_Static):
    # Windows.Devices.Sensors.ProximitySensorDisplayOnOffController Windows.Devices.Sensors.ProximitySensor::CreateDisplayOnOffController()
    def create_display_on_off_controller(self) -> ProximitySensorDisplayOnOffController: ...
    # Windows.Devices.Sensors.ProximitySensorReading Windows.Devices.Sensors.ProximitySensor::GetCurrentReading()
    def get_current_reading(self) -> ProximitySensorReading: ...
    # Windows.Foundation.EventRegistrationToken Windows.Devices.Sensors.ProximitySensor::add_ReadingChanged(Windows.Foundation.TypedEventHandler`2<Windows.Devices.Sensors.ProximitySensor,Windows.Devices.Sensors.ProximitySensorReadingChangedEventArgs>)
    def add_reading_changed(self, handler: windows_foundation.TypedEventHandler[ProximitySensor, ProximitySensorReadingChangedEventArgs], /) -> windows_foundation.EventRegistrationToken: ...
    # System.Void Windows.Devices.Sensors.ProximitySensor::remove_ReadingChanged(Windows.Foundation.EventRegistrationToken)
    def remove_reading_changed(self, token: typing.Union[windows_foundation.EventRegistrationToken, typing.Tuple[winrt.system.Int64]], /) -> None: ...
    # System.String Windows.Devices.Sensors.ProximitySensor::get_DeviceId()
    @_property
    def device_id(self) -> str: ...
    # Windows.Foundation.IReference`1<System.UInt32> Windows.Devices.Sensors.ProximitySensor::get_MaxDistanceInMillimeters()
    @_property
    def max_distance_in_millimeters(self) -> typing.Optional[winrt.system.UInt32]: ...
    # Windows.Foundation.IReference`1<System.UInt32> Windows.Devices.Sensors.ProximitySensor::get_MinDistanceInMillimeters()
    @_property
    def min_distance_in_millimeters(self) -> typing.Optional[winrt.system.UInt32]: ...

@typing.final
class ProximitySensorDataThreshold(winrt.system.Object, ISensorDataThreshold):
    def __new__(cls: typing.Type[Self], sensor: ProximitySensor) -> Self: ...

@typing.final
class ProximitySensorDisplayOnOffController(winrt.system.Object, windows_foundation.IClosable):
    def __enter__(self: Self) -> Self: ...
    def __exit__(self, exc_type: typing.Optional[typing.Type[BaseException]], exc_value: typing.Optional[BaseException], traceback: typing.Optional[types.TracebackType]) -> None: ...
    # System.Void Windows.Devices.Sensors.ProximitySensorDisplayOnOffController::Close()
    def close(self) -> None: ...

@typing.final
class ProximitySensorReading(winrt.system.Object):
    # Windows.Foundation.IReference`1<System.UInt32> Windows.Devices.Sensors.ProximitySensorReading::get_DistanceInMillimeters()
    @_property
    def distance_in_millimeters(self) -> typing.Optional[winrt.system.UInt32]: ...
    # System.Boolean Windows.Devices.Sensors.ProximitySensorReading::get_IsDetected()
    @_property
    def is_detected(self) -> bool: ...
    # Windows.Foundation.DateTime Windows.Devices.Sensors.ProximitySensorReading::get_Timestamp()
    @_property
    def timestamp(self) -> datetime.datetime: ...

@typing.final
class ProximitySensorReadingChangedEventArgs(winrt.system.Object):
    # Windows.Devices.Sensors.ProximitySensorReading Windows.Devices.Sensors.ProximitySensorReadingChangedEventArgs::get_Reading()
    @_property
    def reading(self) -> ProximitySensorReading: ...

@typing.final
class SensorDataThresholdTriggerDetails(winrt.system.Object):
    # System.String Windows.Devices.Sensors.SensorDataThresholdTriggerDetails::get_DeviceId()
    @_property
    def device_id(self) -> str: ...
    # Windows.Devices.Sensors.SensorType Windows.Devices.Sensors.SensorDataThresholdTriggerDetails::get_SensorType()
    @_property
    def sensor_type(self) -> SensorType: ...

@typing.final
class SensorQuaternion(winrt.system.Object):
    # System.Single Windows.Devices.Sensors.SensorQuaternion::get_W()
    @_property
    def w(self) -> winrt.system.Single: ...
    # System.Single Windows.Devices.Sensors.SensorQuaternion::get_X()
    @_property
    def x(self) -> winrt.system.Single: ...
    # System.Single Windows.Devices.Sensors.SensorQuaternion::get_Y()
    @_property
    def y(self) -> winrt.system.Single: ...
    # System.Single Windows.Devices.Sensors.SensorQuaternion::get_Z()
    @_property
    def z(self) -> winrt.system.Single: ...

@typing.final
class SensorRotationMatrix(winrt.system.Object):
    # System.Single Windows.Devices.Sensors.SensorRotationMatrix::get_M11()
    @_property
    def m11(self) -> winrt.system.Single: ...
    # System.Single Windows.Devices.Sensors.SensorRotationMatrix::get_M12()
    @_property
    def m12(self) -> winrt.system.Single: ...
    # System.Single Windows.Devices.Sensors.SensorRotationMatrix::get_M13()
    @_property
    def m13(self) -> winrt.system.Single: ...
    # System.Single Windows.Devices.Sensors.SensorRotationMatrix::get_M21()
    @_property
    def m21(self) -> winrt.system.Single: ...
    # System.Single Windows.Devices.Sensors.SensorRotationMatrix::get_M22()
    @_property
    def m22(self) -> winrt.system.Single: ...
    # System.Single Windows.Devices.Sensors.SensorRotationMatrix::get_M23()
    @_property
    def m23(self) -> winrt.system.Single: ...
    # System.Single Windows.Devices.Sensors.SensorRotationMatrix::get_M31()
    @_property
    def m31(self) -> winrt.system.Single: ...
    # System.Single Windows.Devices.Sensors.SensorRotationMatrix::get_M32()
    @_property
    def m32(self) -> winrt.system.Single: ...
    # System.Single Windows.Devices.Sensors.SensorRotationMatrix::get_M33()
    @_property
    def m33(self) -> winrt.system.Single: ...

@typing.final
class SimpleOrientationSensor_Static(winrt._winrt.IInspectable_Static):
    # Windows.Foundation.IAsyncOperation`1<Windows.Devices.Sensors.SimpleOrientationSensor> Windows.Devices.Sensors.SimpleOrientationSensor::FromIdAsync(System.String)
    def from_id_async(cls, device_id: str, /) -> windows_foundation.IAsyncOperation[SimpleOrientationSensor]: ...
    # Windows.Devices.Sensors.SimpleOrientationSensor Windows.Devices.Sensors.SimpleOrientationSensor::GetDefault()
    def get_default(cls) -> SimpleOrientationSensor: ...
    # System.String Windows.Devices.Sensors.SimpleOrientationSensor::GetDeviceSelector()
    def get_device_selector(cls) -> str: ...

@typing.final
class SimpleOrientationSensor(winrt.system.Object, metaclass=SimpleOrientationSensor_Static):
    # Windows.Devices.Sensors.SimpleOrientation Windows.Devices.Sensors.SimpleOrientationSensor::GetCurrentOrientation()
    def get_current_orientation(self) -> SimpleOrientation: ...
    # Windows.Foundation.EventRegistrationToken Windows.Devices.Sensors.SimpleOrientationSensor::add_OrientationChanged(Windows.Foundation.TypedEventHandler`2<Windows.Devices.Sensors.SimpleOrientationSensor,Windows.Devices.Sensors.SimpleOrientationSensorOrientationChangedEventArgs>)
    def add_orientation_changed(self, handler: windows_foundation.TypedEventHandler[SimpleOrientationSensor, SimpleOrientationSensorOrientationChangedEventArgs], /) -> windows_foundation.EventRegistrationToken: ...
    # System.Void Windows.Devices.Sensors.SimpleOrientationSensor::remove_OrientationChanged(Windows.Foundation.EventRegistrationToken)
    def remove_orientation_changed(self, token: typing.Union[windows_foundation.EventRegistrationToken, typing.Tuple[winrt.system.Int64]], /) -> None: ...
    # Windows.Graphics.Display.DisplayOrientations Windows.Devices.Sensors.SimpleOrientationSensor::get_ReadingTransform()
    @_property
    def reading_transform(self) -> windows_graphics_display.DisplayOrientations: ...
    # System.Void Windows.Devices.Sensors.SimpleOrientationSensor::put_ReadingTransform(Windows.Graphics.Display.DisplayOrientations)
    @reading_transform.setter
    def reading_transform(self, value: windows_graphics_display.DisplayOrientations) -> None: ...
    # System.String Windows.Devices.Sensors.SimpleOrientationSensor::get_DeviceId()
    @_property
    def device_id(self) -> str: ...

@typing.final
class SimpleOrientationSensorOrientationChangedEventArgs(winrt.system.Object):
    # Windows.Devices.Sensors.SimpleOrientation Windows.Devices.Sensors.SimpleOrientationSensorOrientationChangedEventArgs::get_Orientation()
    @_property
    def orientation(self) -> SimpleOrientation: ...
    # Windows.Foundation.DateTime Windows.Devices.Sensors.SimpleOrientationSensorOrientationChangedEventArgs::get_Timestamp()
    @_property
    def timestamp(self) -> datetime.datetime: ...

@typing.final
class WakeOnApproachOptions(winrt.system.Object):
    # System.Boolean Windows.Devices.Sensors.WakeOnApproachOptions::get_DisableWhenBatterySaverOn()
    @_property
    def disable_when_battery_saver_on(self) -> bool: ...
    # System.Void Windows.Devices.Sensors.WakeOnApproachOptions::put_DisableWhenBatterySaverOn(System.Boolean)
    @disable_when_battery_saver_on.setter
    def disable_when_battery_saver_on(self, value: bool) -> None: ...
    # System.Boolean Windows.Devices.Sensors.WakeOnApproachOptions::get_AllowWhenExternalDisplayConnected()
    @_property
    def allow_when_external_display_connected(self) -> bool: ...
    # System.Void Windows.Devices.Sensors.WakeOnApproachOptions::put_AllowWhenExternalDisplayConnected(System.Boolean)
    @allow_when_external_display_connected.setter
    def allow_when_external_display_connected(self, value: bool) -> None: ...

@typing.final
class _IHumanPresenceSensorExtension: ...

class IHumanPresenceSensorExtension(winrt._winrt.IInspectable):
    # System.Void Windows.Devices.Sensors.IHumanPresenceSensorExtension::Initialize(System.String)
    @abstractmethod
    def initialize(self, device_interface: str, /) -> None: ...
    # Windows.Devices.Sensors.HumanPresenceSensorReadingUpdate Windows.Devices.Sensors.IHumanPresenceSensorExtension::ProcessReading(Windows.Devices.Sensors.HumanPresenceSensorReading)
    @abstractmethod
    def process_reading(self, reading: HumanPresenceSensorReading, /) -> HumanPresenceSensorReadingUpdate: ...
    # System.Void Windows.Devices.Sensors.IHumanPresenceSensorExtension::ProcessReadingTimeoutExpired(Windows.Devices.Sensors.HumanPresenceSensorReading)
    @abstractmethod
    def process_reading_timeout_expired(self, reading: HumanPresenceSensorReading, /) -> None: ...
    # System.Void Windows.Devices.Sensors.IHumanPresenceSensorExtension::Reset()
    @abstractmethod
    def reset(self) -> None: ...
    # System.Void Windows.Devices.Sensors.IHumanPresenceSensorExtension::Start()
    @abstractmethod
    def start(self) -> None: ...
    # System.Void Windows.Devices.Sensors.IHumanPresenceSensorExtension::Stop()
    @abstractmethod
    def stop(self) -> None: ...
    # System.Void Windows.Devices.Sensors.IHumanPresenceSensorExtension::Uninitialize()
    @abstractmethod
    def uninitialize(self) -> None: ...

@typing.final
class _ISensorDataThreshold: ...

class ISensorDataThreshold(winrt._winrt.IInspectable):  # type: ignore[misc]
    pass

