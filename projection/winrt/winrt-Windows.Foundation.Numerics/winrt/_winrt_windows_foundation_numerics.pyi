# WARNING: Please don't edit this file. It was generated by Python/WinRT v3.2.1

import datetime
import sys
import types
import typing
import uuid as _uuid
from builtins import property as _property

import winrt._winrt
import winrt.system

Self = typing.TypeVar('Self')

@typing.final
class Matrix3x2_Static(type):
    @typing.overload
    def make_translation(self, position: Vector2) -> Matrix3x2: ...
    @typing.overload
    def make_translation(self, x_position: float, y_position: float) -> Matrix3x2: ...
    @typing.overload
    def make_scale(self, x_scale: float, y_scale: float) -> Matrix3x2: ...
    @typing.overload
    def make_scale(self, x_scale: float, y_scale: float, center_point: Vector2) -> Matrix3x2: ...
    @typing.overload
    def make_scale_from_vector(self, scales: Vector2) -> Matrix3x2: ...
    @typing.overload
    def make_scale_from_vector(self, scales: Vector2, center_point: Vector2) -> Matrix3x2: ...
    @typing.overload
    def make_scale_from_scalar(self, scale: float) -> Matrix3x2: ...
    @typing.overload
    def make_scale_from_scalar(self, scale: float, center_point: Vector2) -> Matrix3x2: ...
    @typing.overload
    def make_skew(self, radians_x: float, radians_y: float) -> Matrix3x2: ...
    @typing.overload
    def make_skew(self, radians_x: float, radians_y: float, center_point: Vector2) -> Matrix3x2: ...
    @typing.overload
    def make_rotation(self, radians: float) -> Matrix3x2: ...
    @typing.overload
    def make_rotation(self, radians: float, center_point: Vector2) -> Matrix3x2: ...
    @_property
    def identity(self) -> Matrix3x2: ...

@typing.final
class Matrix3x2(metaclass=Matrix3x2_Static):
    @_property
    def m11(self) -> winrt.system.Single: ...
    @_property
    def m12(self) -> winrt.system.Single: ...
    @_property
    def m21(self) -> winrt.system.Single: ...
    @_property
    def m22(self) -> winrt.system.Single: ...
    @_property
    def m31(self) -> winrt.system.Single: ...
    @_property
    def m32(self) -> winrt.system.Single: ...
    def __new__(cls, m11: winrt.system.Single = 0, m12: winrt.system.Single = 0, m21: winrt.system.Single = 0, m22: winrt.system.Single = 0, m31: winrt.system.Single = 0, m32: winrt.system.Single = 0) -> Matrix3x2: ...
    def __replace__(self, /, **changes: typing.Any) -> Matrix3x2: ...
    def __add__(self, other: Matrix3x2) -> Matrix3x2: ...
    def __sub__(self, other: Matrix3x2) -> Matrix3x2: ...
    @typing.overload
    def __mul__(self, other: Matrix3x2) -> Matrix3x2: ...
    @typing.overload
    def __mul__(self, other: float) -> Matrix3x2: ...
    def __neg__(self) -> Matrix3x2: ...
    def __iadd__(self, other: Matrix3x2) -> Matrix3x2: ...
    def __isub__(self, other: Matrix3x2) -> Matrix3x2: ...
    @typing.overload
    def __imul__(self, other: Matrix3x2) -> Matrix3x2: ...
    @typing.overload
    def __imul__(self, other: float) -> Matrix3x2: ...
    def is_identity(self) -> bool: ...
    def determinant(self) -> float: ...
    def translation(self) -> Vector2: ...
    def invert(self) -> Matrix3x2: ...
    def lerp(self, value: Matrix3x2, amount: float) -> Matrix3x2: ...
    def unpack(self) -> typing.Tuple[winrt.system.Single, winrt.system.Single, winrt.system.Single, winrt.system.Single, winrt.system.Single, winrt.system.Single]: ...

@typing.final
class Matrix4x4_Static(type):
    def make_billboard(self, object_position: Vector3, camera_position: Vector3, camera_up_vector: Vector3, camera_forward_vector: Vector3) -> Matrix4x4: ...
    def make_constrained_billboard(self, object_position: Vector3, camera_position: Vector3, rotate_axis: Vector3, camera_forward_vector: Vector3, object_forward_vector: Vector3) -> Matrix4x4: ...
    @typing.overload
    def make_translation(self, position: Vector3) -> Matrix4x4: ...
    @typing.overload
    def make_translation(self, x_position: float, y_position: float, z_position: float) -> Matrix4x4: ...
    @typing.overload
    def make_scale(self, x_scale: float, y_scale: float, z_scale: float) -> Matrix4x4: ...
    @typing.overload
    def make_scale(self, x_scale: float, y_scale: float, z_scale: float, center_point: Vector3) -> Matrix4x4: ...
    @typing.overload
    def make_scale_from_vector(self, scales: Vector3) -> Matrix4x4: ...
    @typing.overload
    def make_scale_from_vector(self, scales: Vector3, center_point: Vector3) -> Matrix4x4: ...
    @typing.overload
    def make_scale_from_scalar(self, scale: float) -> Matrix4x4: ...
    @typing.overload
    def make_scale_from_scalar(self, scale: float, center_point: Vector3) -> Matrix4x4: ...
    @typing.overload
    def make_rotation_x(self, radians: float) -> Matrix4x4: ...
    @typing.overload
    def make_rotation_x(self, radians: float, center_point: Vector3) -> Matrix4x4: ...
    @typing.overload
    def make_rotation_y(self, radians: float) -> Matrix4x4: ...
    @typing.overload
    def make_rotation_y(self, radians: float, center_point: Vector3) -> Matrix4x4: ...
    @typing.overload
    def make_rotation_z(self, radians: float) -> Matrix4x4: ...
    @typing.overload
    def make_rotation_z(self, radians: float, center_point: Vector3) -> Matrix4x4: ...
    def make_from_axis_angle(self, axis: Vector3, angle: float) -> Matrix4x4: ...
    def make_perspective_field_of_view(self, field_of_view: float, aspect_ratio: float, near_plane_distance: float, far_plane_distance: float) -> Matrix4x4: ...
    def make_perspective(self, width: float, height: float, near_plane_distance: float, far_plane_distance: float) -> Matrix4x4: ...
    def make_perspective_off_center(self, left: float, right: float, bottom: float, top: float, near_plane_distance: float, far_plane_distance: float) -> Matrix4x4: ...
    def make_orthographic(self, width: float, height: float, z_near_plane: float, z_far_plane: float) -> Matrix4x4: ...
    def make_orthographic_off_center(self, left: float, right: float, bottom: float, top: float, z_near_plane: float, z_far_plane: float) -> Matrix4x4: ...
    def make_look_at(self, camera_position: Vector3, camera_target: Vector3, camera_up_vector: Vector3) -> Matrix4x4: ...
    def make_world(self, position: Vector3, forward: Vector3, up: Vector3) -> Matrix4x4: ...
    def make_from_quaternion(self, quaternion: Quaternion) -> Matrix4x4: ...
    def make_from_yaw_pitch_roll(self, yaw: float, pitch: float, roll: float) -> Matrix4x4: ...
    def make_shadow(self, light_direction: Vector3, plane: Plane) -> Matrix4x4: ...
    def make_reflection(self, value: Plane) -> Matrix4x4: ...
    @_property
    def identity(self) -> Matrix4x4: ...

@typing.final
class Matrix4x4(metaclass=Matrix4x4_Static):
    @_property
    def m11(self) -> winrt.system.Single: ...
    @_property
    def m12(self) -> winrt.system.Single: ...
    @_property
    def m13(self) -> winrt.system.Single: ...
    @_property
    def m14(self) -> winrt.system.Single: ...
    @_property
    def m21(self) -> winrt.system.Single: ...
    @_property
    def m22(self) -> winrt.system.Single: ...
    @_property
    def m23(self) -> winrt.system.Single: ...
    @_property
    def m24(self) -> winrt.system.Single: ...
    @_property
    def m31(self) -> winrt.system.Single: ...
    @_property
    def m32(self) -> winrt.system.Single: ...
    @_property
    def m33(self) -> winrt.system.Single: ...
    @_property
    def m34(self) -> winrt.system.Single: ...
    @_property
    def m41(self) -> winrt.system.Single: ...
    @_property
    def m42(self) -> winrt.system.Single: ...
    @_property
    def m43(self) -> winrt.system.Single: ...
    @_property
    def m44(self) -> winrt.system.Single: ...
    def __new__(cls, m11: winrt.system.Single = 0, m12: winrt.system.Single = 0, m13: winrt.system.Single = 0, m14: winrt.system.Single = 0, m21: winrt.system.Single = 0, m22: winrt.system.Single = 0, m23: winrt.system.Single = 0, m24: winrt.system.Single = 0, m31: winrt.system.Single = 0, m32: winrt.system.Single = 0, m33: winrt.system.Single = 0, m34: winrt.system.Single = 0, m41: winrt.system.Single = 0, m42: winrt.system.Single = 0, m43: winrt.system.Single = 0, m44: winrt.system.Single = 0) -> Matrix4x4: ...
    def __replace__(self, /, **changes: typing.Any) -> Matrix4x4: ...
    def __add__(self, other: Matrix4x4) -> Matrix4x4: ...
    def __sub__(self, other: Matrix4x4) -> Matrix4x4: ...
    @typing.overload
    def __mul__(self, other: Matrix4x4) -> Matrix4x4: ...
    @typing.overload
    def __mul__(self, other: float) -> Matrix4x4: ...
    def __neg__(self) -> Matrix4x4: ...
    def __iadd__(self, other: Matrix4x4) -> Matrix4x4: ...
    def __isub__(self, other: Matrix4x4) -> Matrix4x4: ...
    @typing.overload
    def __imul__(self, other: Matrix4x4) -> Matrix4x4: ...
    @typing.overload
    def __imul__(self, other: float) -> Matrix4x4: ...
    def is_identity(self) -> bool: ...
    def determinant(self) -> float: ...
    def translation(self) -> Vector2: ...
    def invert(self) -> Matrix4x4: ...
    def decompose(self) -> typing.Tuple[Vector3, Quaternion, Vector3]: ...
    def transform(self, rotation: Quaternion) -> Matrix4x4: ...
    def transpose(self) -> Matrix4x4: ...
    def lerp(self, value: Matrix4x4, amount: float) -> Matrix4x4: ...
    def unpack(self) -> typing.Tuple[winrt.system.Single, winrt.system.Single, winrt.system.Single, winrt.system.Single, winrt.system.Single, winrt.system.Single, winrt.system.Single, winrt.system.Single, winrt.system.Single, winrt.system.Single, winrt.system.Single, winrt.system.Single, winrt.system.Single, winrt.system.Single, winrt.system.Single, winrt.system.Single]: ...

@typing.final
class Plane_Static(type):
    def make_from_vertices(self, point1: Vector3, point2: Vector3, point3: Vector3) -> Plane: ...

@typing.final
class Plane(metaclass=Plane_Static):
    @_property
    def normal(self) -> Vector3: ...
    @_property
    def d(self) -> winrt.system.Single: ...
    def __new__(cls, normal: Vector3 = Vector3(), d: winrt.system.Single = 0) -> Plane: ...
    def __replace__(self, /, **changes: typing.Any) -> Plane: ...
    def normalize(self) -> Plane: ...
    @typing.overload
    def transform(self, matrix: Matrix4x4) -> Plane: ...
    @typing.overload
    def transform(self, rotation: Quaternion) -> Plane: ...
    def dot(self, value: Vector4) -> float: ...
    def dot_coordinate(self, value: Vector3) -> float: ...
    def dot_normal(self, value: Vector3) -> float: ...
    def unpack(self) -> typing.Tuple[typing.Tuple[winrt.system.Single, winrt.system.Single, winrt.system.Single], winrt.system.Single]: ...

@typing.final
class Quaternion_Static(type):
    def make_from_axis_angle(self, axis: Vector3, angle: float) -> Quaternion: ...
    def make_from_yaw_pitch_roll(self, yaw: float, pitch: float, roll: float) -> Quaternion: ...
    def make_from_rotation_matrix(self, matrix: Matrix4x4) -> Quaternion: ...
    @_property
    def identity(self) -> Quaternion: ...

@typing.final
class Quaternion(metaclass=Quaternion_Static):
    @_property
    def x(self) -> winrt.system.Single: ...
    @_property
    def y(self) -> winrt.system.Single: ...
    @_property
    def z(self) -> winrt.system.Single: ...
    @_property
    def w(self) -> winrt.system.Single: ...
    def __new__(cls, x: winrt.system.Single = 0, y: winrt.system.Single = 0, z: winrt.system.Single = 0, w: winrt.system.Single = 0) -> Quaternion: ...
    def __replace__(self, /, **changes: typing.Any) -> Quaternion: ...
    def __add__(self, other: Quaternion) -> Quaternion: ...
    def __sub__(self, other: Quaternion) -> Quaternion: ...
    @typing.overload
    def __mul__(self, other: Quaternion) -> Quaternion: ...
    @typing.overload
    def __mul__(self, other: float) -> Quaternion: ...
    def __truediv__(self, value: Quaternion) -> Quaternion: ...
    def __neg__(self) -> Quaternion: ...
    def __iadd__(self, other: Quaternion) -> Quaternion: ...
    def __isub__(self, other: Quaternion) -> Quaternion: ...
    @typing.overload
    def __imul__(self, other: Quaternion) -> Quaternion: ...
    @typing.overload
    def __imul__(self, other: float) -> Quaternion: ...
    def __itruediv__(self, value: Quaternion) -> Quaternion: ...
    def __abs__(self) -> float: ...
    def is_identity(self) -> bool: ...
    def length(self) -> float: ...
    def length_squared(self) -> float: ...
    def dot(self, value: Quaternion) -> float: ...
    def normalize(self) -> Quaternion: ...
    def conjugate(self) -> Quaternion: ...
    def inverse(self) -> Quaternion: ...
    def slerp(self, value: Quaternion, amount: float) -> Quaternion: ...
    def lerp(self, value: Quaternion, amount: float) -> Quaternion: ...
    def concatenate(self, value: Quaternion) -> Quaternion: ...
    def unpack(self) -> typing.Tuple[winrt.system.Single, winrt.system.Single, winrt.system.Single, winrt.system.Single]: ...

@typing.final
class Rational:
    @_property
    def numerator(self) -> winrt.system.UInt32: ...
    @_property
    def denominator(self) -> winrt.system.UInt32: ...
    def __new__(cls, numerator: winrt.system.UInt32 = 0, denominator: winrt.system.UInt32 = 0) -> Rational: ...
    def __replace__(self, /, **changes: typing.Any) -> Rational: ...
    def unpack(self) -> typing.Tuple[winrt.system.UInt32, winrt.system.UInt32]: ...

@typing.final
class Vector2_Static(type):
    @_property
    def zero(self) -> Vector2: ...
    @_property
    def one(self) -> Vector2: ...
    @_property
    def unit_x(self) -> Vector2: ...
    @_property
    def unit_y(self) -> Vector2: ...

@typing.final
class Vector2(metaclass=Vector2_Static):
    @_property
    def x(self) -> winrt.system.Single: ...
    @_property
    def y(self) -> winrt.system.Single: ...
    def __new__(cls, x: winrt.system.Single = 0, y: winrt.system.Single = 0) -> Vector2: ...
    def __replace__(self, /, **changes: typing.Any) -> Vector2: ...
    def __add__(self, other: Vector2) -> Vector2: ...
    def __sub__(self, other: Vector2) -> Vector2: ...
    @typing.overload
    def __mul__(self, other: Vector2) -> Vector2: ...
    @typing.overload
    def __mul__(self, other: float) -> Vector2: ...
    def __rmul__(self, other: float) -> Vector2: ...
    @typing.overload
    def __truediv__(self, value: Vector2) -> Vector2: ...
    @typing.overload
    def __truediv__(self, value: float) -> Vector2: ...
    def __neg__(self) -> Vector2: ...
    def __iadd__(self, other: Vector2) -> Vector2: ...
    def __isub__(self, other: Vector2) -> Vector2: ...
    @typing.overload
    def __imul__(self, other: Vector2) -> Vector2: ...
    @typing.overload
    def __imul__(self, other: float) -> Vector2: ...
    @typing.overload
    def __itruediv__(self, value: Vector2) -> Vector2: ...
    @typing.overload
    def __itruediv__(self, value: float) -> Vector2: ...
    def __abs__(self) -> float: ...
    def length(self) -> float: ...
    def length_squared(self) -> float: ...
    def distance(self, value: Vector2) -> float: ...
    def distance_squared(self, value: Vector2) -> float: ...
    def dot(self, value: Vector2) -> float: ...
    def normalize(self) -> Vector2: ...
    def reflect(self, normal: Vector2) -> Vector2: ...
    def min(self, value: Vector2) -> Vector2: ...
    def max(self, value: Vector2) -> Vector2: ...
    def clamp(self, min: Vector2, max: Vector2) -> Vector2: ...
    def lerp(self, value: Vector2, amount: float) -> Vector2: ...
    @typing.overload
    def transform(self, matrix: Matrix3x2) -> Vector2: ...
    @typing.overload
    def transform(self, matrix: Matrix4x4) -> Vector2: ...
    @typing.overload
    def transform(self, rotation: Quaternion) -> Vector2: ...
    @typing.overload
    def transform_normal(self, matrix: Matrix3x2) -> Vector2: ...
    @typing.overload
    def transform_normal(self, matrix: Matrix4x4) -> Vector2: ...
    @typing.overload
    def transform4(self, matrix: Matrix4x4) -> Vector4: ...
    @typing.overload
    def transform4(self, rotation: Quaternion) -> Vector4: ...
    def unpack(self) -> typing.Tuple[winrt.system.Single, winrt.system.Single]: ...

@typing.final
class Vector3_Static(type):
    @_property
    def zero(self) -> Vector3: ...
    @_property
    def one(self) -> Vector3: ...
    @_property
    def unit_x(self) -> Vector3: ...
    @_property
    def unit_y(self) -> Vector3: ...
    @_property
    def unit_z(self) -> Vector3: ...

@typing.final
class Vector3(metaclass=Vector3_Static):
    @_property
    def x(self) -> winrt.system.Single: ...
    @_property
    def y(self) -> winrt.system.Single: ...
    @_property
    def z(self) -> winrt.system.Single: ...
    def __new__(cls, x: winrt.system.Single = 0, y: winrt.system.Single = 0, z: winrt.system.Single = 0) -> Vector3: ...
    def __replace__(self, /, **changes: typing.Any) -> Vector3: ...
    def __add__(self, other: Vector3) -> Vector3: ...
    def __sub__(self, other: Vector3) -> Vector3: ...
    @typing.overload
    def __mul__(self, other: Vector3) -> Vector3: ...
    @typing.overload
    def __mul__(self, other: float) -> Vector3: ...
    def __rmul__(self, other: float) -> Vector3: ...
    @typing.overload
    def __truediv__(self, value: Vector3) -> Vector3: ...
    @typing.overload
    def __truediv__(self, value: float) -> Vector3: ...
    def __neg__(self) -> Vector3: ...
    def __iadd__(self, other: Vector3) -> Vector3: ...
    def __isub__(self, other: Vector3) -> Vector3: ...
    @typing.overload
    def __imul__(self, other: Vector3) -> Vector3: ...
    @typing.overload
    def __imul__(self, other: float) -> Vector3: ...
    @typing.overload
    def __itruediv__(self, value: Vector3) -> Vector3: ...
    @typing.overload
    def __itruediv__(self, value: float) -> Vector3: ...
    def __abs__(self) -> float: ...
    def length(self) -> float: ...
    def length_squared(self) -> float: ...
    def distance(self, value: Vector3) -> float: ...
    def distance_squared(self, value: Vector3) -> float: ...
    def dot(self, value: Vector3) -> float: ...
    def cross(self, value: Vector3) -> Vector3: ...
    def normalize(self) -> Vector3: ...
    def reflect(self, normal: Vector3) -> Vector3: ...
    def min(self, value: Vector3) -> Vector3: ...
    def max(self, value: Vector3) -> Vector3: ...
    def clamp(self, min: Vector3, max: Vector3) -> Vector3: ...
    def lerp(self, value: Vector3, amount: float) -> Vector3: ...
    @typing.overload
    def transform(self, matrix: Matrix4x4) -> Vector3: ...
    @typing.overload
    def transform(self, rotation: Quaternion) -> Vector3: ...
    def transform_normal(self, matrix: Matrix4x4) -> Vector3: ...
    @typing.overload
    def transform4(self, matrix: Matrix4x4) -> Vector4: ...
    @typing.overload
    def transform4(self, rotation: Quaternion) -> Vector4: ...
    def unpack(self) -> typing.Tuple[winrt.system.Single, winrt.system.Single, winrt.system.Single]: ...

@typing.final
class Vector4_Static(type):
    @_property
    def zero(self) -> Vector4: ...
    @_property
    def one(self) -> Vector4: ...
    @_property
    def unit_x(self) -> Vector4: ...
    @_property
    def unit_y(self) -> Vector4: ...
    @_property
    def unit_z(self) -> Vector4: ...
    @_property
    def unit_w(self) -> Vector4: ...

@typing.final
class Vector4(metaclass=Vector4_Static):
    @_property
    def x(self) -> winrt.system.Single: ...
    @_property
    def y(self) -> winrt.system.Single: ...
    @_property
    def z(self) -> winrt.system.Single: ...
    @_property
    def w(self) -> winrt.system.Single: ...
    def __new__(cls, x: winrt.system.Single = 0, y: winrt.system.Single = 0, z: winrt.system.Single = 0, w: winrt.system.Single = 0) -> Vector4: ...
    def __replace__(self, /, **changes: typing.Any) -> Vector4: ...
    def __add__(self, other: Vector4) -> Vector4: ...
    def __sub__(self, other: Vector4) -> Vector4: ...
    @typing.overload
    def __mul__(self, other: Vector4) -> Vector4: ...
    @typing.overload
    def __mul__(self, other: float) -> Vector4: ...
    def __rmul__(self, other: float) -> Vector4: ...
    @typing.overload
    def __truediv__(self, value: Vector4) -> Vector4: ...
    @typing.overload
    def __truediv__(self, value: float) -> Vector4: ...
    def __neg__(self) -> Vector4: ...
    def __iadd__(self, other: Vector4) -> Vector4: ...
    def __isub__(self, other: Vector4) -> Vector4: ...
    @typing.overload
    def __imul__(self, other: Vector4) -> Vector4: ...
    @typing.overload
    def __imul__(self, other: float) -> Vector4: ...
    @typing.overload
    def __itruediv__(self, value: Vector4) -> Vector4: ...
    @typing.overload
    def __itruediv__(self, value: float) -> Vector4: ...
    def __abs__(self) -> float: ...
    def length(self) -> float: ...
    def length_squared(self) -> float: ...
    def distance(self, value: Vector4) -> float: ...
    def distance_squared(self, value: Vector4) -> float: ...
    def dot(self, value: Vector4) -> float: ...
    def normalize(self) -> Vector4: ...
    def min(self, value: Vector4) -> Vector4: ...
    def max(self, value: Vector4) -> Vector4: ...
    def clamp(self, min: Vector4, max: Vector4) -> Vector4: ...
    def lerp(self, value: Vector4, amount: float) -> Vector4: ...
    @typing.overload
    def transform(self, matrix: Matrix4x4) -> Vector4: ...
    @typing.overload
    def transform(self, rotation: Quaternion) -> Vector4: ...
    def unpack(self) -> typing.Tuple[winrt.system.Single, winrt.system.Single, winrt.system.Single, winrt.system.Single]: ...

