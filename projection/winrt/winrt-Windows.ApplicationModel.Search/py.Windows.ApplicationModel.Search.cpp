// WARNING: Please don't edit this file. It was generated by Python/WinRT v3.2.1

#include "py.Windows.ApplicationModel.Search.h"

namespace py::cpp::Windows::ApplicationModel::Search
{
    // ----- LocalContentSuggestionSettings class --------------------

    static PyObject* _new_LocalContentSuggestionSettings(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::ApplicationModel::Search::LocalContentSuggestionSettings instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_LocalContentSuggestionSettings(py::wrapper::Windows::ApplicationModel::Search::LocalContentSuggestionSettings* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* LocalContentSuggestionSettings_get_Enabled(py::wrapper::Windows::ApplicationModel::Search::LocalContentSuggestionSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Search.LocalContentSuggestionSettings", L"Enabled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Enabled();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LocalContentSuggestionSettings_put_Enabled(py::wrapper::Windows::ApplicationModel::Search::LocalContentSuggestionSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Search.LocalContentSuggestionSettings", L"Enabled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.Enabled(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LocalContentSuggestionSettings_get_AqsFilter(py::wrapper::Windows::ApplicationModel::Search::LocalContentSuggestionSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Search.LocalContentSuggestionSettings", L"AqsFilter");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.AqsFilter();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LocalContentSuggestionSettings_put_AqsFilter(py::wrapper::Windows::ApplicationModel::Search::LocalContentSuggestionSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Search.LocalContentSuggestionSettings", L"AqsFilter");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            {
                auto _gil = release_gil();
                self->obj.AqsFilter(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LocalContentSuggestionSettings_get_Locations(py::wrapper::Windows::ApplicationModel::Search::LocalContentSuggestionSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Search.LocalContentSuggestionSettings", L"Locations");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Locations();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LocalContentSuggestionSettings_get_PropertiesToMatch(py::wrapper::Windows::ApplicationModel::Search::LocalContentSuggestionSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Search.LocalContentSuggestionSettings", L"PropertiesToMatch");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PropertiesToMatch();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_LocalContentSuggestionSettings(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Search::LocalContentSuggestionSettings>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_LocalContentSuggestionSettings(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Search::LocalContentSuggestionSettings>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_LocalContentSuggestionSettings[] = {
        { "_assign_array_", _assign_array_LocalContentSuggestionSettings, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_LocalContentSuggestionSettings), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_LocalContentSuggestionSettings[] = {
        { "enabled", reinterpret_cast<getter>(LocalContentSuggestionSettings_get_Enabled), reinterpret_cast<setter>(LocalContentSuggestionSettings_put_Enabled), nullptr, nullptr },
        { "aqs_filter", reinterpret_cast<getter>(LocalContentSuggestionSettings_get_AqsFilter), reinterpret_cast<setter>(LocalContentSuggestionSettings_put_AqsFilter), nullptr, nullptr },
        { "locations", reinterpret_cast<getter>(LocalContentSuggestionSettings_get_Locations), nullptr, nullptr, nullptr },
        { "properties_to_match", reinterpret_cast<getter>(LocalContentSuggestionSettings_get_PropertiesToMatch), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_LocalContentSuggestionSettings[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_LocalContentSuggestionSettings) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_LocalContentSuggestionSettings) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_LocalContentSuggestionSettings) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_LocalContentSuggestionSettings) },
        { }};

    static PyType_Spec type_spec_LocalContentSuggestionSettings = {
        "winrt._winrt_windows_applicationmodel_search.LocalContentSuggestionSettings",
        sizeof(py::wrapper::Windows::ApplicationModel::Search::LocalContentSuggestionSettings),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_LocalContentSuggestionSettings};

    // ----- SearchPane class --------------------

    static PyObject* _new_SearchPane(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Search::SearchPane>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Search::SearchPane>::type_name);
        return nullptr;
    }

    static void _dealloc_SearchPane(py::wrapper::Windows::ApplicationModel::Search::SearchPane* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SearchPane_GetForCurrentView(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Search.SearchPane", L"GetForCurrentView", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::ApplicationModel::Search::SearchPane::GetForCurrentView();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SearchPane_HideThisApplication(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Search.SearchPane", L"HideThisApplication", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    winrt::Windows::ApplicationModel::Search::SearchPane::HideThisApplication();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SearchPane_SetLocalContentSuggestionSettings(py::wrapper::Windows::ApplicationModel::Search::SearchPane* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Search.SearchPane", L"SetLocalContentSuggestionSettings", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Search::LocalContentSuggestionSettings>(args, 0);

                {
                    auto _gil = release_gil();
                    self->obj.SetLocalContentSuggestionSettings(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SearchPane_ShowOverloadDefault(py::wrapper::Windows::ApplicationModel::Search::SearchPane* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Search.SearchPane", L"Show", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.Show();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SearchPane_ShowOverloadWithQuery(py::wrapper::Windows::ApplicationModel::Search::SearchPane* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Search.SearchPane", L"Show", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                {
                    auto _gil = release_gil();
                    self->obj.Show(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SearchPane_TrySetQueryText(py::wrapper::Windows::ApplicationModel::Search::SearchPane* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Search.SearchPane", L"TrySetQueryText", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.TrySetQueryText(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SearchPane_get_ShowOnKeyboardInput(py::wrapper::Windows::ApplicationModel::Search::SearchPane* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Search.SearchPane", L"ShowOnKeyboardInput");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ShowOnKeyboardInput();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SearchPane_put_ShowOnKeyboardInput(py::wrapper::Windows::ApplicationModel::Search::SearchPane* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Search.SearchPane", L"ShowOnKeyboardInput");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.ShowOnKeyboardInput(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SearchPane_get_SearchHistoryEnabled(py::wrapper::Windows::ApplicationModel::Search::SearchPane* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Search.SearchPane", L"SearchHistoryEnabled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SearchHistoryEnabled();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SearchPane_put_SearchHistoryEnabled(py::wrapper::Windows::ApplicationModel::Search::SearchPane* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Search.SearchPane", L"SearchHistoryEnabled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.SearchHistoryEnabled(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SearchPane_get_SearchHistoryContext(py::wrapper::Windows::ApplicationModel::Search::SearchPane* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Search.SearchPane", L"SearchHistoryContext");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SearchHistoryContext();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SearchPane_put_SearchHistoryContext(py::wrapper::Windows::ApplicationModel::Search::SearchPane* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Search.SearchPane", L"SearchHistoryContext");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            {
                auto _gil = release_gil();
                self->obj.SearchHistoryContext(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SearchPane_get_PlaceholderText(py::wrapper::Windows::ApplicationModel::Search::SearchPane* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Search.SearchPane", L"PlaceholderText");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PlaceholderText();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SearchPane_put_PlaceholderText(py::wrapper::Windows::ApplicationModel::Search::SearchPane* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Search.SearchPane", L"PlaceholderText");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            {
                auto _gil = release_gil();
                self->obj.PlaceholderText(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SearchPane_get_Language(py::wrapper::Windows::ApplicationModel::Search::SearchPane* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Search.SearchPane", L"Language");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Language();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SearchPane_get_QueryText(py::wrapper::Windows::ApplicationModel::Search::SearchPane* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Search.SearchPane", L"QueryText");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.QueryText();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SearchPane_get_Visible(py::wrapper::Windows::ApplicationModel::Search::SearchPane* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Search.SearchPane", L"Visible");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Visible();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SearchPane_add_QueryChanged(py::wrapper::Windows::ApplicationModel::Search::SearchPane* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Search.SearchPane", L"QueryChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::ApplicationModel::Search::SearchPane, winrt::Windows::ApplicationModel::Search::SearchPaneQueryChangedEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.QueryChanged(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SearchPane_remove_QueryChanged(py::wrapper::Windows::ApplicationModel::Search::SearchPane* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Search.SearchPane", L"QueryChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.QueryChanged(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SearchPane_add_QuerySubmitted(py::wrapper::Windows::ApplicationModel::Search::SearchPane* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Search.SearchPane", L"QuerySubmitted");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::ApplicationModel::Search::SearchPane, winrt::Windows::ApplicationModel::Search::SearchPaneQuerySubmittedEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.QuerySubmitted(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SearchPane_remove_QuerySubmitted(py::wrapper::Windows::ApplicationModel::Search::SearchPane* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Search.SearchPane", L"QuerySubmitted");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.QuerySubmitted(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SearchPane_add_ResultSuggestionChosen(py::wrapper::Windows::ApplicationModel::Search::SearchPane* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Search.SearchPane", L"ResultSuggestionChosen");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::ApplicationModel::Search::SearchPane, winrt::Windows::ApplicationModel::Search::SearchPaneResultSuggestionChosenEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ResultSuggestionChosen(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SearchPane_remove_ResultSuggestionChosen(py::wrapper::Windows::ApplicationModel::Search::SearchPane* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Search.SearchPane", L"ResultSuggestionChosen");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.ResultSuggestionChosen(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SearchPane_add_SuggestionsRequested(py::wrapper::Windows::ApplicationModel::Search::SearchPane* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Search.SearchPane", L"SuggestionsRequested");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::ApplicationModel::Search::SearchPane, winrt::Windows::ApplicationModel::Search::SearchPaneSuggestionsRequestedEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SuggestionsRequested(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SearchPane_remove_SuggestionsRequested(py::wrapper::Windows::ApplicationModel::Search::SearchPane* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Search.SearchPane", L"SuggestionsRequested");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.SuggestionsRequested(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SearchPane_add_VisibilityChanged(py::wrapper::Windows::ApplicationModel::Search::SearchPane* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Search.SearchPane", L"VisibilityChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::ApplicationModel::Search::SearchPane, winrt::Windows::ApplicationModel::Search::SearchPaneVisibilityChangedEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.VisibilityChanged(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SearchPane_remove_VisibilityChanged(py::wrapper::Windows::ApplicationModel::Search::SearchPane* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Search.SearchPane", L"VisibilityChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.VisibilityChanged(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SearchPane(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Search::SearchPane>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SearchPane(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Search::SearchPane>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SearchPane[] = {
        { "set_local_content_suggestion_settings", reinterpret_cast<PyCFunction>(SearchPane_SetLocalContentSuggestionSettings), METH_VARARGS, nullptr },
        { "show_overload_default", reinterpret_cast<PyCFunction>(SearchPane_ShowOverloadDefault), METH_VARARGS, nullptr },
        { "show_overload_with_query", reinterpret_cast<PyCFunction>(SearchPane_ShowOverloadWithQuery), METH_VARARGS, nullptr },
        { "try_set_query_text", reinterpret_cast<PyCFunction>(SearchPane_TrySetQueryText), METH_VARARGS, nullptr },
        { "add_query_changed", reinterpret_cast<PyCFunction>(SearchPane_add_QueryChanged), METH_O, nullptr },
        { "remove_query_changed", reinterpret_cast<PyCFunction>(SearchPane_remove_QueryChanged), METH_O, nullptr },
        { "add_query_submitted", reinterpret_cast<PyCFunction>(SearchPane_add_QuerySubmitted), METH_O, nullptr },
        { "remove_query_submitted", reinterpret_cast<PyCFunction>(SearchPane_remove_QuerySubmitted), METH_O, nullptr },
        { "add_result_suggestion_chosen", reinterpret_cast<PyCFunction>(SearchPane_add_ResultSuggestionChosen), METH_O, nullptr },
        { "remove_result_suggestion_chosen", reinterpret_cast<PyCFunction>(SearchPane_remove_ResultSuggestionChosen), METH_O, nullptr },
        { "add_suggestions_requested", reinterpret_cast<PyCFunction>(SearchPane_add_SuggestionsRequested), METH_O, nullptr },
        { "remove_suggestions_requested", reinterpret_cast<PyCFunction>(SearchPane_remove_SuggestionsRequested), METH_O, nullptr },
        { "add_visibility_changed", reinterpret_cast<PyCFunction>(SearchPane_add_VisibilityChanged), METH_O, nullptr },
        { "remove_visibility_changed", reinterpret_cast<PyCFunction>(SearchPane_remove_VisibilityChanged), METH_O, nullptr },
        { "_assign_array_", _assign_array_SearchPane, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SearchPane), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_SearchPane[] = {
        { "show_on_keyboard_input", reinterpret_cast<getter>(SearchPane_get_ShowOnKeyboardInput), reinterpret_cast<setter>(SearchPane_put_ShowOnKeyboardInput), nullptr, nullptr },
        { "search_history_enabled", reinterpret_cast<getter>(SearchPane_get_SearchHistoryEnabled), reinterpret_cast<setter>(SearchPane_put_SearchHistoryEnabled), nullptr, nullptr },
        { "search_history_context", reinterpret_cast<getter>(SearchPane_get_SearchHistoryContext), reinterpret_cast<setter>(SearchPane_put_SearchHistoryContext), nullptr, nullptr },
        { "placeholder_text", reinterpret_cast<getter>(SearchPane_get_PlaceholderText), reinterpret_cast<setter>(SearchPane_put_PlaceholderText), nullptr, nullptr },
        { "language", reinterpret_cast<getter>(SearchPane_get_Language), nullptr, nullptr, nullptr },
        { "query_text", reinterpret_cast<getter>(SearchPane_get_QueryText), nullptr, nullptr, nullptr },
        { "visible", reinterpret_cast<getter>(SearchPane_get_Visible), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_SearchPane[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_SearchPane) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SearchPane) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SearchPane) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SearchPane) },
        { }};

    static PyType_Spec type_spec_SearchPane = {
        "winrt._winrt_windows_applicationmodel_search.SearchPane",
        sizeof(py::wrapper::Windows::ApplicationModel::Search::SearchPane),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SearchPane};

    static PyGetSetDef getset_SearchPane_Static[] = {
        { }};

    static PyMethodDef methods_SearchPane_Static[] = {
        { "get_for_current_view", reinterpret_cast<PyCFunction>(SearchPane_GetForCurrentView), METH_VARARGS, nullptr },
        { "hide_this_application", reinterpret_cast<PyCFunction>(SearchPane_HideThisApplication), METH_VARARGS, nullptr },
        { }};

    static PyType_Slot type_slots_SearchPane_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_SearchPane_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_SearchPane_Static) },
        { }
    };

    static PyType_Spec type_spec_SearchPane_Static = {
        "winrt._winrt_windows_applicationmodel_search.SearchPane_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_SearchPane_Static};

    // ----- SearchPaneQueryChangedEventArgs class --------------------

    static PyObject* _new_SearchPaneQueryChangedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Search::SearchPaneQueryChangedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Search::SearchPaneQueryChangedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_SearchPaneQueryChangedEventArgs(py::wrapper::Windows::ApplicationModel::Search::SearchPaneQueryChangedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SearchPaneQueryChangedEventArgs_get_Language(py::wrapper::Windows::ApplicationModel::Search::SearchPaneQueryChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Search.SearchPaneQueryChangedEventArgs", L"Language");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Language();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SearchPaneQueryChangedEventArgs_get_LinguisticDetails(py::wrapper::Windows::ApplicationModel::Search::SearchPaneQueryChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Search.SearchPaneQueryChangedEventArgs", L"LinguisticDetails");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.LinguisticDetails();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SearchPaneQueryChangedEventArgs_get_QueryText(py::wrapper::Windows::ApplicationModel::Search::SearchPaneQueryChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Search.SearchPaneQueryChangedEventArgs", L"QueryText");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.QueryText();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SearchPaneQueryChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Search::SearchPaneQueryChangedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SearchPaneQueryChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Search::SearchPaneQueryChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SearchPaneQueryChangedEventArgs[] = {
        { "_assign_array_", _assign_array_SearchPaneQueryChangedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SearchPaneQueryChangedEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_SearchPaneQueryChangedEventArgs[] = {
        { "language", reinterpret_cast<getter>(SearchPaneQueryChangedEventArgs_get_Language), nullptr, nullptr, nullptr },
        { "linguistic_details", reinterpret_cast<getter>(SearchPaneQueryChangedEventArgs_get_LinguisticDetails), nullptr, nullptr, nullptr },
        { "query_text", reinterpret_cast<getter>(SearchPaneQueryChangedEventArgs_get_QueryText), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_SearchPaneQueryChangedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_SearchPaneQueryChangedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SearchPaneQueryChangedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SearchPaneQueryChangedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SearchPaneQueryChangedEventArgs) },
        { }};

    static PyType_Spec type_spec_SearchPaneQueryChangedEventArgs = {
        "winrt._winrt_windows_applicationmodel_search.SearchPaneQueryChangedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Search::SearchPaneQueryChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SearchPaneQueryChangedEventArgs};

    // ----- SearchPaneQueryLinguisticDetails class --------------------

    static PyObject* _new_SearchPaneQueryLinguisticDetails(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Search::SearchPaneQueryLinguisticDetails>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Search::SearchPaneQueryLinguisticDetails>::type_name);
        return nullptr;
    }

    static void _dealloc_SearchPaneQueryLinguisticDetails(py::wrapper::Windows::ApplicationModel::Search::SearchPaneQueryLinguisticDetails* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SearchPaneQueryLinguisticDetails_get_QueryTextAlternatives(py::wrapper::Windows::ApplicationModel::Search::SearchPaneQueryLinguisticDetails* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Search.SearchPaneQueryLinguisticDetails", L"QueryTextAlternatives");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.QueryTextAlternatives();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SearchPaneQueryLinguisticDetails_get_QueryTextCompositionLength(py::wrapper::Windows::ApplicationModel::Search::SearchPaneQueryLinguisticDetails* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Search.SearchPaneQueryLinguisticDetails", L"QueryTextCompositionLength");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.QueryTextCompositionLength();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SearchPaneQueryLinguisticDetails_get_QueryTextCompositionStart(py::wrapper::Windows::ApplicationModel::Search::SearchPaneQueryLinguisticDetails* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Search.SearchPaneQueryLinguisticDetails", L"QueryTextCompositionStart");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.QueryTextCompositionStart();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SearchPaneQueryLinguisticDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Search::SearchPaneQueryLinguisticDetails>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SearchPaneQueryLinguisticDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Search::SearchPaneQueryLinguisticDetails>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SearchPaneQueryLinguisticDetails[] = {
        { "_assign_array_", _assign_array_SearchPaneQueryLinguisticDetails, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SearchPaneQueryLinguisticDetails), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_SearchPaneQueryLinguisticDetails[] = {
        { "query_text_alternatives", reinterpret_cast<getter>(SearchPaneQueryLinguisticDetails_get_QueryTextAlternatives), nullptr, nullptr, nullptr },
        { "query_text_composition_length", reinterpret_cast<getter>(SearchPaneQueryLinguisticDetails_get_QueryTextCompositionLength), nullptr, nullptr, nullptr },
        { "query_text_composition_start", reinterpret_cast<getter>(SearchPaneQueryLinguisticDetails_get_QueryTextCompositionStart), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_SearchPaneQueryLinguisticDetails[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_SearchPaneQueryLinguisticDetails) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SearchPaneQueryLinguisticDetails) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SearchPaneQueryLinguisticDetails) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SearchPaneQueryLinguisticDetails) },
        { }};

    static PyType_Spec type_spec_SearchPaneQueryLinguisticDetails = {
        "winrt._winrt_windows_applicationmodel_search.SearchPaneQueryLinguisticDetails",
        sizeof(py::wrapper::Windows::ApplicationModel::Search::SearchPaneQueryLinguisticDetails),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SearchPaneQueryLinguisticDetails};

    // ----- SearchPaneQuerySubmittedEventArgs class --------------------

    static PyObject* _new_SearchPaneQuerySubmittedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Search::SearchPaneQuerySubmittedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Search::SearchPaneQuerySubmittedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_SearchPaneQuerySubmittedEventArgs(py::wrapper::Windows::ApplicationModel::Search::SearchPaneQuerySubmittedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SearchPaneQuerySubmittedEventArgs_get_Language(py::wrapper::Windows::ApplicationModel::Search::SearchPaneQuerySubmittedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Search.SearchPaneQuerySubmittedEventArgs", L"Language");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Language();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SearchPaneQuerySubmittedEventArgs_get_QueryText(py::wrapper::Windows::ApplicationModel::Search::SearchPaneQuerySubmittedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Search.SearchPaneQuerySubmittedEventArgs", L"QueryText");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.QueryText();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SearchPaneQuerySubmittedEventArgs_get_LinguisticDetails(py::wrapper::Windows::ApplicationModel::Search::SearchPaneQuerySubmittedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Search.SearchPaneQuerySubmittedEventArgs", L"LinguisticDetails");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.LinguisticDetails();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SearchPaneQuerySubmittedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Search::SearchPaneQuerySubmittedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SearchPaneQuerySubmittedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Search::SearchPaneQuerySubmittedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SearchPaneQuerySubmittedEventArgs[] = {
        { "_assign_array_", _assign_array_SearchPaneQuerySubmittedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SearchPaneQuerySubmittedEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_SearchPaneQuerySubmittedEventArgs[] = {
        { "language", reinterpret_cast<getter>(SearchPaneQuerySubmittedEventArgs_get_Language), nullptr, nullptr, nullptr },
        { "query_text", reinterpret_cast<getter>(SearchPaneQuerySubmittedEventArgs_get_QueryText), nullptr, nullptr, nullptr },
        { "linguistic_details", reinterpret_cast<getter>(SearchPaneQuerySubmittedEventArgs_get_LinguisticDetails), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_SearchPaneQuerySubmittedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_SearchPaneQuerySubmittedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SearchPaneQuerySubmittedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SearchPaneQuerySubmittedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SearchPaneQuerySubmittedEventArgs) },
        { }};

    static PyType_Spec type_spec_SearchPaneQuerySubmittedEventArgs = {
        "winrt._winrt_windows_applicationmodel_search.SearchPaneQuerySubmittedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Search::SearchPaneQuerySubmittedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SearchPaneQuerySubmittedEventArgs};

    // ----- SearchPaneResultSuggestionChosenEventArgs class --------------------

    static PyObject* _new_SearchPaneResultSuggestionChosenEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Search::SearchPaneResultSuggestionChosenEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Search::SearchPaneResultSuggestionChosenEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_SearchPaneResultSuggestionChosenEventArgs(py::wrapper::Windows::ApplicationModel::Search::SearchPaneResultSuggestionChosenEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SearchPaneResultSuggestionChosenEventArgs_get_Tag(py::wrapper::Windows::ApplicationModel::Search::SearchPaneResultSuggestionChosenEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Search.SearchPaneResultSuggestionChosenEventArgs", L"Tag");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Tag();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SearchPaneResultSuggestionChosenEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Search::SearchPaneResultSuggestionChosenEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SearchPaneResultSuggestionChosenEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Search::SearchPaneResultSuggestionChosenEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SearchPaneResultSuggestionChosenEventArgs[] = {
        { "_assign_array_", _assign_array_SearchPaneResultSuggestionChosenEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SearchPaneResultSuggestionChosenEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_SearchPaneResultSuggestionChosenEventArgs[] = {
        { "tag", reinterpret_cast<getter>(SearchPaneResultSuggestionChosenEventArgs_get_Tag), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_SearchPaneResultSuggestionChosenEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_SearchPaneResultSuggestionChosenEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SearchPaneResultSuggestionChosenEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SearchPaneResultSuggestionChosenEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SearchPaneResultSuggestionChosenEventArgs) },
        { }};

    static PyType_Spec type_spec_SearchPaneResultSuggestionChosenEventArgs = {
        "winrt._winrt_windows_applicationmodel_search.SearchPaneResultSuggestionChosenEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Search::SearchPaneResultSuggestionChosenEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SearchPaneResultSuggestionChosenEventArgs};

    // ----- SearchPaneSuggestionsRequest class --------------------

    static PyObject* _new_SearchPaneSuggestionsRequest(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Search::SearchPaneSuggestionsRequest>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Search::SearchPaneSuggestionsRequest>::type_name);
        return nullptr;
    }

    static void _dealloc_SearchPaneSuggestionsRequest(py::wrapper::Windows::ApplicationModel::Search::SearchPaneSuggestionsRequest* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SearchPaneSuggestionsRequest_GetDeferral(py::wrapper::Windows::ApplicationModel::Search::SearchPaneSuggestionsRequest* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Search.SearchPaneSuggestionsRequest", L"GetDeferral", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetDeferral();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SearchPaneSuggestionsRequest_get_IsCanceled(py::wrapper::Windows::ApplicationModel::Search::SearchPaneSuggestionsRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Search.SearchPaneSuggestionsRequest", L"IsCanceled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsCanceled();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SearchPaneSuggestionsRequest_get_SearchSuggestionCollection(py::wrapper::Windows::ApplicationModel::Search::SearchPaneSuggestionsRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Search.SearchPaneSuggestionsRequest", L"SearchSuggestionCollection");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SearchSuggestionCollection();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SearchPaneSuggestionsRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Search::SearchPaneSuggestionsRequest>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SearchPaneSuggestionsRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Search::SearchPaneSuggestionsRequest>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SearchPaneSuggestionsRequest[] = {
        { "get_deferral", reinterpret_cast<PyCFunction>(SearchPaneSuggestionsRequest_GetDeferral), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_SearchPaneSuggestionsRequest, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SearchPaneSuggestionsRequest), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_SearchPaneSuggestionsRequest[] = {
        { "is_canceled", reinterpret_cast<getter>(SearchPaneSuggestionsRequest_get_IsCanceled), nullptr, nullptr, nullptr },
        { "search_suggestion_collection", reinterpret_cast<getter>(SearchPaneSuggestionsRequest_get_SearchSuggestionCollection), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_SearchPaneSuggestionsRequest[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_SearchPaneSuggestionsRequest) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SearchPaneSuggestionsRequest) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SearchPaneSuggestionsRequest) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SearchPaneSuggestionsRequest) },
        { }};

    static PyType_Spec type_spec_SearchPaneSuggestionsRequest = {
        "winrt._winrt_windows_applicationmodel_search.SearchPaneSuggestionsRequest",
        sizeof(py::wrapper::Windows::ApplicationModel::Search::SearchPaneSuggestionsRequest),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SearchPaneSuggestionsRequest};

    // ----- SearchPaneSuggestionsRequestDeferral class --------------------

    static PyObject* _new_SearchPaneSuggestionsRequestDeferral(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Search::SearchPaneSuggestionsRequestDeferral>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Search::SearchPaneSuggestionsRequestDeferral>::type_name);
        return nullptr;
    }

    static void _dealloc_SearchPaneSuggestionsRequestDeferral(py::wrapper::Windows::ApplicationModel::Search::SearchPaneSuggestionsRequestDeferral* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SearchPaneSuggestionsRequestDeferral_Complete(py::wrapper::Windows::ApplicationModel::Search::SearchPaneSuggestionsRequestDeferral* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Search.SearchPaneSuggestionsRequestDeferral", L"Complete", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.Complete();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_SearchPaneSuggestionsRequestDeferral(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Search::SearchPaneSuggestionsRequestDeferral>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SearchPaneSuggestionsRequestDeferral(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Search::SearchPaneSuggestionsRequestDeferral>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SearchPaneSuggestionsRequestDeferral[] = {
        { "complete", reinterpret_cast<PyCFunction>(SearchPaneSuggestionsRequestDeferral_Complete), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_SearchPaneSuggestionsRequestDeferral, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SearchPaneSuggestionsRequestDeferral), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_SearchPaneSuggestionsRequestDeferral[] = {
        { }};

    static PyType_Slot _type_slots_SearchPaneSuggestionsRequestDeferral[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_SearchPaneSuggestionsRequestDeferral) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SearchPaneSuggestionsRequestDeferral) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SearchPaneSuggestionsRequestDeferral) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SearchPaneSuggestionsRequestDeferral) },
        { }};

    static PyType_Spec type_spec_SearchPaneSuggestionsRequestDeferral = {
        "winrt._winrt_windows_applicationmodel_search.SearchPaneSuggestionsRequestDeferral",
        sizeof(py::wrapper::Windows::ApplicationModel::Search::SearchPaneSuggestionsRequestDeferral),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SearchPaneSuggestionsRequestDeferral};

    // ----- SearchPaneSuggestionsRequestedEventArgs class --------------------

    static PyObject* _new_SearchPaneSuggestionsRequestedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Search::SearchPaneSuggestionsRequestedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Search::SearchPaneSuggestionsRequestedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_SearchPaneSuggestionsRequestedEventArgs(py::wrapper::Windows::ApplicationModel::Search::SearchPaneSuggestionsRequestedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SearchPaneSuggestionsRequestedEventArgs_get_Language(py::wrapper::Windows::ApplicationModel::Search::SearchPaneSuggestionsRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Search.SearchPaneSuggestionsRequestedEventArgs", L"Language");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Language();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SearchPaneSuggestionsRequestedEventArgs_get_LinguisticDetails(py::wrapper::Windows::ApplicationModel::Search::SearchPaneSuggestionsRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Search.SearchPaneSuggestionsRequestedEventArgs", L"LinguisticDetails");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.LinguisticDetails();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SearchPaneSuggestionsRequestedEventArgs_get_QueryText(py::wrapper::Windows::ApplicationModel::Search::SearchPaneSuggestionsRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Search.SearchPaneSuggestionsRequestedEventArgs", L"QueryText");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.QueryText();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SearchPaneSuggestionsRequestedEventArgs_get_Request(py::wrapper::Windows::ApplicationModel::Search::SearchPaneSuggestionsRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Search.SearchPaneSuggestionsRequestedEventArgs", L"Request");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Request();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SearchPaneSuggestionsRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Search::SearchPaneSuggestionsRequestedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SearchPaneSuggestionsRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Search::SearchPaneSuggestionsRequestedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SearchPaneSuggestionsRequestedEventArgs[] = {
        { "_assign_array_", _assign_array_SearchPaneSuggestionsRequestedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SearchPaneSuggestionsRequestedEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_SearchPaneSuggestionsRequestedEventArgs[] = {
        { "language", reinterpret_cast<getter>(SearchPaneSuggestionsRequestedEventArgs_get_Language), nullptr, nullptr, nullptr },
        { "linguistic_details", reinterpret_cast<getter>(SearchPaneSuggestionsRequestedEventArgs_get_LinguisticDetails), nullptr, nullptr, nullptr },
        { "query_text", reinterpret_cast<getter>(SearchPaneSuggestionsRequestedEventArgs_get_QueryText), nullptr, nullptr, nullptr },
        { "request", reinterpret_cast<getter>(SearchPaneSuggestionsRequestedEventArgs_get_Request), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_SearchPaneSuggestionsRequestedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_SearchPaneSuggestionsRequestedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SearchPaneSuggestionsRequestedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SearchPaneSuggestionsRequestedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SearchPaneSuggestionsRequestedEventArgs) },
        { }};

    static PyType_Spec type_spec_SearchPaneSuggestionsRequestedEventArgs = {
        "winrt._winrt_windows_applicationmodel_search.SearchPaneSuggestionsRequestedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Search::SearchPaneSuggestionsRequestedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SearchPaneSuggestionsRequestedEventArgs};

    // ----- SearchPaneVisibilityChangedEventArgs class --------------------

    static PyObject* _new_SearchPaneVisibilityChangedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Search::SearchPaneVisibilityChangedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Search::SearchPaneVisibilityChangedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_SearchPaneVisibilityChangedEventArgs(py::wrapper::Windows::ApplicationModel::Search::SearchPaneVisibilityChangedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SearchPaneVisibilityChangedEventArgs_get_Visible(py::wrapper::Windows::ApplicationModel::Search::SearchPaneVisibilityChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Search.SearchPaneVisibilityChangedEventArgs", L"Visible");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Visible();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SearchPaneVisibilityChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Search::SearchPaneVisibilityChangedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SearchPaneVisibilityChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Search::SearchPaneVisibilityChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SearchPaneVisibilityChangedEventArgs[] = {
        { "_assign_array_", _assign_array_SearchPaneVisibilityChangedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SearchPaneVisibilityChangedEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_SearchPaneVisibilityChangedEventArgs[] = {
        { "visible", reinterpret_cast<getter>(SearchPaneVisibilityChangedEventArgs_get_Visible), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_SearchPaneVisibilityChangedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_SearchPaneVisibilityChangedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SearchPaneVisibilityChangedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SearchPaneVisibilityChangedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SearchPaneVisibilityChangedEventArgs) },
        { }};

    static PyType_Spec type_spec_SearchPaneVisibilityChangedEventArgs = {
        "winrt._winrt_windows_applicationmodel_search.SearchPaneVisibilityChangedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Search::SearchPaneVisibilityChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SearchPaneVisibilityChangedEventArgs};

    // ----- SearchQueryLinguisticDetails class --------------------

    static PyObject* _new_SearchQueryLinguisticDetails(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);
        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);
                auto param2 = py::convert_to<uint32_t>(args, 2);

                winrt::Windows::ApplicationModel::Search::SearchQueryLinguisticDetails instance{param0, param1, param2};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_SearchQueryLinguisticDetails(py::wrapper::Windows::ApplicationModel::Search::SearchQueryLinguisticDetails* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SearchQueryLinguisticDetails_get_QueryTextAlternatives(py::wrapper::Windows::ApplicationModel::Search::SearchQueryLinguisticDetails* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Search.SearchQueryLinguisticDetails", L"QueryTextAlternatives");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.QueryTextAlternatives();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SearchQueryLinguisticDetails_get_QueryTextCompositionLength(py::wrapper::Windows::ApplicationModel::Search::SearchQueryLinguisticDetails* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Search.SearchQueryLinguisticDetails", L"QueryTextCompositionLength");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.QueryTextCompositionLength();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SearchQueryLinguisticDetails_get_QueryTextCompositionStart(py::wrapper::Windows::ApplicationModel::Search::SearchQueryLinguisticDetails* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Search.SearchQueryLinguisticDetails", L"QueryTextCompositionStart");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.QueryTextCompositionStart();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SearchQueryLinguisticDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Search::SearchQueryLinguisticDetails>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SearchQueryLinguisticDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Search::SearchQueryLinguisticDetails>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SearchQueryLinguisticDetails[] = {
        { "_assign_array_", _assign_array_SearchQueryLinguisticDetails, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SearchQueryLinguisticDetails), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_SearchQueryLinguisticDetails[] = {
        { "query_text_alternatives", reinterpret_cast<getter>(SearchQueryLinguisticDetails_get_QueryTextAlternatives), nullptr, nullptr, nullptr },
        { "query_text_composition_length", reinterpret_cast<getter>(SearchQueryLinguisticDetails_get_QueryTextCompositionLength), nullptr, nullptr, nullptr },
        { "query_text_composition_start", reinterpret_cast<getter>(SearchQueryLinguisticDetails_get_QueryTextCompositionStart), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_SearchQueryLinguisticDetails[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_SearchQueryLinguisticDetails) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SearchQueryLinguisticDetails) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SearchQueryLinguisticDetails) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SearchQueryLinguisticDetails) },
        { }};

    static PyType_Spec type_spec_SearchQueryLinguisticDetails = {
        "winrt._winrt_windows_applicationmodel_search.SearchQueryLinguisticDetails",
        sizeof(py::wrapper::Windows::ApplicationModel::Search::SearchQueryLinguisticDetails),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SearchQueryLinguisticDetails};

    // ----- SearchSuggestionCollection class --------------------

    static PyObject* _new_SearchSuggestionCollection(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Search::SearchSuggestionCollection>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Search::SearchSuggestionCollection>::type_name);
        return nullptr;
    }

    static void _dealloc_SearchSuggestionCollection(py::wrapper::Windows::ApplicationModel::Search::SearchSuggestionCollection* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SearchSuggestionCollection_AppendQuerySuggestion(py::wrapper::Windows::ApplicationModel::Search::SearchSuggestionCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Search.SearchSuggestionCollection", L"AppendQuerySuggestion", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                {
                    auto _gil = release_gil();
                    self->obj.AppendQuerySuggestion(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SearchSuggestionCollection_AppendQuerySuggestions(py::wrapper::Windows::ApplicationModel::Search::SearchSuggestionCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Search.SearchSuggestionCollection", L"AppendQuerySuggestions", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 0);

                {
                    auto _gil = release_gil();
                    self->obj.AppendQuerySuggestions(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SearchSuggestionCollection_AppendResultSuggestion(py::wrapper::Windows::ApplicationModel::Search::SearchSuggestionCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 5)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Search.SearchSuggestionCollection", L"AppendResultSuggestion", 5);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(5);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::hstring>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStreamReference>(args, 3);
                auto param4 = py::convert_to<winrt::hstring>(args, 4);

                {
                    auto _gil = release_gil();
                    self->obj.AppendResultSuggestion(param0, param1, param2, param3, param4);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SearchSuggestionCollection_AppendSearchSeparator(py::wrapper::Windows::ApplicationModel::Search::SearchSuggestionCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Search.SearchSuggestionCollection", L"AppendSearchSeparator", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                {
                    auto _gil = release_gil();
                    self->obj.AppendSearchSeparator(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SearchSuggestionCollection_get_Size(py::wrapper::Windows::ApplicationModel::Search::SearchSuggestionCollection* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Search.SearchSuggestionCollection", L"Size");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Size();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SearchSuggestionCollection(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Search::SearchSuggestionCollection>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SearchSuggestionCollection(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Search::SearchSuggestionCollection>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SearchSuggestionCollection[] = {
        { "append_query_suggestion", reinterpret_cast<PyCFunction>(SearchSuggestionCollection_AppendQuerySuggestion), METH_VARARGS, nullptr },
        { "append_query_suggestions", reinterpret_cast<PyCFunction>(SearchSuggestionCollection_AppendQuerySuggestions), METH_VARARGS, nullptr },
        { "append_result_suggestion", reinterpret_cast<PyCFunction>(SearchSuggestionCollection_AppendResultSuggestion), METH_VARARGS, nullptr },
        { "append_search_separator", reinterpret_cast<PyCFunction>(SearchSuggestionCollection_AppendSearchSeparator), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_SearchSuggestionCollection, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SearchSuggestionCollection), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_SearchSuggestionCollection[] = {
        { "size", reinterpret_cast<getter>(SearchSuggestionCollection_get_Size), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_SearchSuggestionCollection[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_SearchSuggestionCollection) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SearchSuggestionCollection) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SearchSuggestionCollection) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SearchSuggestionCollection) },
        { }};

    static PyType_Spec type_spec_SearchSuggestionCollection = {
        "winrt._winrt_windows_applicationmodel_search.SearchSuggestionCollection",
        sizeof(py::wrapper::Windows::ApplicationModel::Search::SearchSuggestionCollection),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SearchSuggestionCollection};

    // ----- SearchSuggestionsRequest class --------------------

    static PyObject* _new_SearchSuggestionsRequest(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Search::SearchSuggestionsRequest>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Search::SearchSuggestionsRequest>::type_name);
        return nullptr;
    }

    static void _dealloc_SearchSuggestionsRequest(py::wrapper::Windows::ApplicationModel::Search::SearchSuggestionsRequest* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SearchSuggestionsRequest_GetDeferral(py::wrapper::Windows::ApplicationModel::Search::SearchSuggestionsRequest* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Search.SearchSuggestionsRequest", L"GetDeferral", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetDeferral();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SearchSuggestionsRequest_get_IsCanceled(py::wrapper::Windows::ApplicationModel::Search::SearchSuggestionsRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Search.SearchSuggestionsRequest", L"IsCanceled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsCanceled();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SearchSuggestionsRequest_get_SearchSuggestionCollection(py::wrapper::Windows::ApplicationModel::Search::SearchSuggestionsRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Search.SearchSuggestionsRequest", L"SearchSuggestionCollection");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SearchSuggestionCollection();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SearchSuggestionsRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Search::SearchSuggestionsRequest>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SearchSuggestionsRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Search::SearchSuggestionsRequest>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SearchSuggestionsRequest[] = {
        { "get_deferral", reinterpret_cast<PyCFunction>(SearchSuggestionsRequest_GetDeferral), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_SearchSuggestionsRequest, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SearchSuggestionsRequest), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_SearchSuggestionsRequest[] = {
        { "is_canceled", reinterpret_cast<getter>(SearchSuggestionsRequest_get_IsCanceled), nullptr, nullptr, nullptr },
        { "search_suggestion_collection", reinterpret_cast<getter>(SearchSuggestionsRequest_get_SearchSuggestionCollection), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_SearchSuggestionsRequest[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_SearchSuggestionsRequest) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SearchSuggestionsRequest) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SearchSuggestionsRequest) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SearchSuggestionsRequest) },
        { }};

    static PyType_Spec type_spec_SearchSuggestionsRequest = {
        "winrt._winrt_windows_applicationmodel_search.SearchSuggestionsRequest",
        sizeof(py::wrapper::Windows::ApplicationModel::Search::SearchSuggestionsRequest),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SearchSuggestionsRequest};

    // ----- SearchSuggestionsRequestDeferral class --------------------

    static PyObject* _new_SearchSuggestionsRequestDeferral(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Search::SearchSuggestionsRequestDeferral>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Search::SearchSuggestionsRequestDeferral>::type_name);
        return nullptr;
    }

    static void _dealloc_SearchSuggestionsRequestDeferral(py::wrapper::Windows::ApplicationModel::Search::SearchSuggestionsRequestDeferral* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SearchSuggestionsRequestDeferral_Complete(py::wrapper::Windows::ApplicationModel::Search::SearchSuggestionsRequestDeferral* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Search.SearchSuggestionsRequestDeferral", L"Complete", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.Complete();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_SearchSuggestionsRequestDeferral(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Search::SearchSuggestionsRequestDeferral>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SearchSuggestionsRequestDeferral(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Search::SearchSuggestionsRequestDeferral>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SearchSuggestionsRequestDeferral[] = {
        { "complete", reinterpret_cast<PyCFunction>(SearchSuggestionsRequestDeferral_Complete), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_SearchSuggestionsRequestDeferral, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SearchSuggestionsRequestDeferral), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_SearchSuggestionsRequestDeferral[] = {
        { }};

    static PyType_Slot _type_slots_SearchSuggestionsRequestDeferral[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_SearchSuggestionsRequestDeferral) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SearchSuggestionsRequestDeferral) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SearchSuggestionsRequestDeferral) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SearchSuggestionsRequestDeferral) },
        { }};

    static PyType_Spec type_spec_SearchSuggestionsRequestDeferral = {
        "winrt._winrt_windows_applicationmodel_search.SearchSuggestionsRequestDeferral",
        sizeof(py::wrapper::Windows::ApplicationModel::Search::SearchSuggestionsRequestDeferral),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SearchSuggestionsRequestDeferral};

    // ----- ISearchPaneQueryChangedEventArgs interface --------------------

    #if PY_VERSION_HEX < 0x030A0000
    static PyObject* _new_ISearchPaneQueryChangedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Search::ISearchPaneQueryChangedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Search::ISearchPaneQueryChangedEventArgs>::type_name);
        return nullptr;
    }
    #endif

    static void _dealloc_ISearchPaneQueryChangedEventArgs(py::wrapper::Windows::ApplicationModel::Search::ISearchPaneQueryChangedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ISearchPaneQueryChangedEventArgs_get_Language(py::wrapper::Windows::ApplicationModel::Search::ISearchPaneQueryChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Search.ISearchPaneQueryChangedEventArgs", L"Language");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Language();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ISearchPaneQueryChangedEventArgs_get_LinguisticDetails(py::wrapper::Windows::ApplicationModel::Search::ISearchPaneQueryChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Search.ISearchPaneQueryChangedEventArgs", L"LinguisticDetails");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.LinguisticDetails();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ISearchPaneQueryChangedEventArgs_get_QueryText(py::wrapper::Windows::ApplicationModel::Search::ISearchPaneQueryChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Search.ISearchPaneQueryChangedEventArgs", L"QueryText");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.QueryText();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ISearchPaneQueryChangedEventArgs[] = {
        { }};

    static PyGetSetDef _getset_ISearchPaneQueryChangedEventArgs[] = {
        { "language", reinterpret_cast<getter>(ISearchPaneQueryChangedEventArgs_get_Language), nullptr, nullptr, nullptr },
        { "linguistic_details", reinterpret_cast<getter>(ISearchPaneQueryChangedEventArgs_get_LinguisticDetails), nullptr, nullptr, nullptr },
        { "query_text", reinterpret_cast<getter>(ISearchPaneQueryChangedEventArgs_get_QueryText), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_ISearchPaneQueryChangedEventArgs[] = {
        #if PY_VERSION_HEX < 0x030A0000
        { Py_tp_new, reinterpret_cast<void*>(_new_ISearchPaneQueryChangedEventArgs) },
        #endif
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ISearchPaneQueryChangedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ISearchPaneQueryChangedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ISearchPaneQueryChangedEventArgs) },
        { }};

    static PyType_Spec type_spec_ISearchPaneQueryChangedEventArgs = {
        "winrt._winrt_windows_applicationmodel_search._ISearchPaneQueryChangedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Search::ISearchPaneQueryChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT
        #if PY_VERSION_HEX >= 0x030A0000
        | Py_TPFLAGS_DISALLOW_INSTANTIATION
        #endif
        ,
        _type_slots_ISearchPaneQueryChangedEventArgs};

    struct ImplementsISearchPaneQueryChangedEventArgs : py::ImplementsInterfaceT<ImplementsISearchPaneQueryChangedEventArgs, winrt::Windows::ApplicationModel::Search::ISearchPaneQueryChangedEventArgs>
    {
        ImplementsISearchPaneQueryChangedEventArgs() = delete;
        ImplementsISearchPaneQueryChangedEventArgs(PyObject* py_obj, winrt::impl::inspectable_abi* runtime_class) : py::ImplementsInterfaceT<ImplementsISearchPaneQueryChangedEventArgs, winrt::Windows::ApplicationModel::Search::ISearchPaneQueryChangedEventArgs>(py_obj, runtime_class)
        {
        }

        auto Language()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "language")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::hstring>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto LinguisticDetails()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "linguistic_details")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::ApplicationModel::Search::SearchPaneQueryLinguisticDetails>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto QueryText()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "query_text")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::hstring>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }
    };

    static PyObject* _assign_array_ISearchPaneQueryChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Search::ISearchPaneQueryChangedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ISearchPaneQueryChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Search::ISearchPaneQueryChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _guid_ImplementsISearchPaneQueryChangedEventArgs(PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::guid_of<winrt::Windows::ApplicationModel::Search::ISearchPaneQueryChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _make_ImplementsISearchPaneQueryChangedEventArgs(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            PyObject* py_obj;
            winrt::impl::inspectable_abi* runtime_class;

            if (!PyArg_ParseTuple(args, "On", &py_obj, &runtime_class))
            {
                return nullptr;
            }

            auto iface{std::make_unique<ImplementsISearchPaneQueryChangedEventArgs>(py_obj, runtime_class)};

            return PyLong_FromVoidPtr(iface.release());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef methods_ImplementsISearchPaneQueryChangedEventArgs[] = {
        { "_assign_array_", _assign_array_ISearchPaneQueryChangedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ISearchPaneQueryChangedEventArgs), METH_O | METH_STATIC, nullptr },
        { "_guid_", reinterpret_cast<PyCFunction>(_guid_ImplementsISearchPaneQueryChangedEventArgs), METH_NOARGS | METH_STATIC, nullptr },
        { "_make_", reinterpret_cast<PyCFunction>(_make_ImplementsISearchPaneQueryChangedEventArgs), METH_VARARGS | METH_STATIC, nullptr },
        { }};

    static PyType_Slot type_slots_ImplementsISearchPaneQueryChangedEventArgs[] = {
        { Py_tp_methods, reinterpret_cast<void*>(methods_ImplementsISearchPaneQueryChangedEventArgs) },
        { }};

    static PyType_Spec type_spec_ImplementsISearchPaneQueryChangedEventArgs = {
        "winrt._winrt_windows_applicationmodel_search.ISearchPaneQueryChangedEventArgs",
        0,
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE
        #if PY_VERSION_HEX >= 0x030A0000
        | Py_TPFLAGS_DISALLOW_INSTANTIATION
        #endif
        ,
        type_slots_ImplementsISearchPaneQueryChangedEventArgs};

    // ----- Windows.ApplicationModel.Search Initialization --------------------

    PyDoc_STRVAR(module_doc, "Windows.ApplicationModel.Search");

    static PyModuleDef module_def = {
        PyModuleDef_HEAD_INIT,
        "_winrt_windows_applicationmodel_search",
        module_doc,
        0,
        nullptr,
        nullptr,
        nullptr,
        nullptr,
        nullptr};
} // py::cpp::Windows::ApplicationModel::Search

PyMODINIT_FUNC PyInit__winrt_windows_applicationmodel_search(void) noexcept
{
    using namespace py::cpp::Windows::ApplicationModel::Search;

    if (py::import_winrt_runtime() == -1)
    {
        return nullptr;
    }

    py::pyobj_handle module{PyModule_Create(&module_def)};

    if (!module)
    {
        return nullptr;
    }

    auto inspectable_meta_type = py::get_inspectable_meta_type();
    if (!inspectable_meta_type)
    {
        return nullptr;
    }

    auto object_type = py::get_object_type();
    if (!object_type)
    {
        return nullptr;
    }

    py::pyobj_handle object_bases{PyTuple_Pack(1, object_type)};

    if (!object_bases)
    {
        return nullptr;
    }

    py::pytype_handle LocalContentSuggestionSettings_type{py::register_python_type(module.get(), &type_spec_LocalContentSuggestionSettings, object_bases.get(), inspectable_meta_type)};
    if (!LocalContentSuggestionSettings_type)
    {
        return nullptr;
    }

    py::pyobj_handle SearchPane_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(inspectable_meta_type))};
    if (!SearchPane_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_SearchPane_Static{PyType_FromSpecWithBases(&type_spec_SearchPane_Static, SearchPane_Static_bases.get())};
    if (!type_SearchPane_Static)
    {
        return nullptr;
    }

    py::pytype_handle SearchPane_type{py::register_python_type(module.get(), &type_spec_SearchPane, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_SearchPane_Static.get()))};
    if (!SearchPane_type)
    {
        return nullptr;
    }

    py::pytype_handle SearchPaneQueryChangedEventArgs_type{py::register_python_type(module.get(), &type_spec_SearchPaneQueryChangedEventArgs, object_bases.get(), inspectable_meta_type)};
    if (!SearchPaneQueryChangedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle SearchPaneQueryLinguisticDetails_type{py::register_python_type(module.get(), &type_spec_SearchPaneQueryLinguisticDetails, object_bases.get(), inspectable_meta_type)};
    if (!SearchPaneQueryLinguisticDetails_type)
    {
        return nullptr;
    }

    py::pytype_handle SearchPaneQuerySubmittedEventArgs_type{py::register_python_type(module.get(), &type_spec_SearchPaneQuerySubmittedEventArgs, object_bases.get(), inspectable_meta_type)};
    if (!SearchPaneQuerySubmittedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle SearchPaneResultSuggestionChosenEventArgs_type{py::register_python_type(module.get(), &type_spec_SearchPaneResultSuggestionChosenEventArgs, object_bases.get(), inspectable_meta_type)};
    if (!SearchPaneResultSuggestionChosenEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle SearchPaneSuggestionsRequest_type{py::register_python_type(module.get(), &type_spec_SearchPaneSuggestionsRequest, object_bases.get(), inspectable_meta_type)};
    if (!SearchPaneSuggestionsRequest_type)
    {
        return nullptr;
    }

    py::pytype_handle SearchPaneSuggestionsRequestDeferral_type{py::register_python_type(module.get(), &type_spec_SearchPaneSuggestionsRequestDeferral, object_bases.get(), inspectable_meta_type)};
    if (!SearchPaneSuggestionsRequestDeferral_type)
    {
        return nullptr;
    }

    py::pytype_handle SearchPaneSuggestionsRequestedEventArgs_type{py::register_python_type(module.get(), &type_spec_SearchPaneSuggestionsRequestedEventArgs, object_bases.get(), inspectable_meta_type)};
    if (!SearchPaneSuggestionsRequestedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle SearchPaneVisibilityChangedEventArgs_type{py::register_python_type(module.get(), &type_spec_SearchPaneVisibilityChangedEventArgs, object_bases.get(), inspectable_meta_type)};
    if (!SearchPaneVisibilityChangedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle SearchQueryLinguisticDetails_type{py::register_python_type(module.get(), &type_spec_SearchQueryLinguisticDetails, object_bases.get(), inspectable_meta_type)};
    if (!SearchQueryLinguisticDetails_type)
    {
        return nullptr;
    }

    py::pytype_handle SearchSuggestionCollection_type{py::register_python_type(module.get(), &type_spec_SearchSuggestionCollection, object_bases.get(), inspectable_meta_type)};
    if (!SearchSuggestionCollection_type)
    {
        return nullptr;
    }

    py::pytype_handle SearchSuggestionsRequest_type{py::register_python_type(module.get(), &type_spec_SearchSuggestionsRequest, object_bases.get(), inspectable_meta_type)};
    if (!SearchSuggestionsRequest_type)
    {
        return nullptr;
    }

    py::pytype_handle SearchSuggestionsRequestDeferral_type{py::register_python_type(module.get(), &type_spec_SearchSuggestionsRequestDeferral, object_bases.get(), inspectable_meta_type)};
    if (!SearchSuggestionsRequestDeferral_type)
    {
        return nullptr;
    }

    py::pytype_handle ISearchPaneQueryChangedEventArgs_type{py::register_python_type(module.get(), &type_spec_ISearchPaneQueryChangedEventArgs, object_bases.get(), nullptr)};
    if (!ISearchPaneQueryChangedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle ImplementsISearchPaneQueryChangedEventArgs_type{py::register_python_type(module.get(), &type_spec_ImplementsISearchPaneQueryChangedEventArgs, nullptr, inspectable_meta_type)};
    if (!ImplementsISearchPaneQueryChangedEventArgs_type)
    {
        return nullptr;
    }

    if (PyModule_AddType(module.get(), ImplementsISearchPaneQueryChangedEventArgs_type.get()) == -1)
    {
        return nullptr;
    }


    return module.detach();
}
