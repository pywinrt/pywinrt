// WARNING: Please don't edit this file. It was generated by Python/WinRT v3.2.1

#include "py.Windows.UI.Text.Core.h"

namespace py::cpp::Windows::UI::Text::Core
{
    // ----- CoreTextCompositionCompletedEventArgs class --------------------

    static PyObject* _new_CoreTextCompositionCompletedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Text::Core::CoreTextCompositionCompletedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Text::Core::CoreTextCompositionCompletedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_CoreTextCompositionCompletedEventArgs(py::wrapper::Windows::UI::Text::Core::CoreTextCompositionCompletedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CoreTextCompositionCompletedEventArgs_GetDeferral(py::wrapper::Windows::UI::Text::Core::CoreTextCompositionCompletedEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Text.Core.CoreTextCompositionCompletedEventArgs", L"GetDeferral", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetDeferral();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CoreTextCompositionCompletedEventArgs_get_CompositionSegments(py::wrapper::Windows::UI::Text::Core::CoreTextCompositionCompletedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.Core.CoreTextCompositionCompletedEventArgs", L"CompositionSegments");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.CompositionSegments();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreTextCompositionCompletedEventArgs_get_IsCanceled(py::wrapper::Windows::UI::Text::Core::CoreTextCompositionCompletedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.Core.CoreTextCompositionCompletedEventArgs", L"IsCanceled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsCanceled();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CoreTextCompositionCompletedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Text::Core::CoreTextCompositionCompletedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CoreTextCompositionCompletedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Text::Core::CoreTextCompositionCompletedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CoreTextCompositionCompletedEventArgs[] = {
        { "get_deferral", reinterpret_cast<PyCFunction>(CoreTextCompositionCompletedEventArgs_GetDeferral), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_CoreTextCompositionCompletedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CoreTextCompositionCompletedEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_CoreTextCompositionCompletedEventArgs[] = {
        { "composition_segments", reinterpret_cast<getter>(CoreTextCompositionCompletedEventArgs_get_CompositionSegments), nullptr, nullptr, nullptr },
        { "is_canceled", reinterpret_cast<getter>(CoreTextCompositionCompletedEventArgs_get_IsCanceled), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_CoreTextCompositionCompletedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_CoreTextCompositionCompletedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CoreTextCompositionCompletedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CoreTextCompositionCompletedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CoreTextCompositionCompletedEventArgs) },
        { }};

    static PyType_Spec type_spec_CoreTextCompositionCompletedEventArgs = {
        "winrt._winrt_windows_ui_text_core.CoreTextCompositionCompletedEventArgs",
        sizeof(py::wrapper::Windows::UI::Text::Core::CoreTextCompositionCompletedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CoreTextCompositionCompletedEventArgs};

    // ----- CoreTextCompositionSegment class --------------------

    static PyObject* _new_CoreTextCompositionSegment(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Text::Core::CoreTextCompositionSegment>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Text::Core::CoreTextCompositionSegment>::type_name);
        return nullptr;
    }

    static void _dealloc_CoreTextCompositionSegment(py::wrapper::Windows::UI::Text::Core::CoreTextCompositionSegment* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CoreTextCompositionSegment_get_PreconversionString(py::wrapper::Windows::UI::Text::Core::CoreTextCompositionSegment* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.Core.CoreTextCompositionSegment", L"PreconversionString");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PreconversionString();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreTextCompositionSegment_get_Range(py::wrapper::Windows::UI::Text::Core::CoreTextCompositionSegment* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.Core.CoreTextCompositionSegment", L"Range");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Range();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CoreTextCompositionSegment(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Text::Core::CoreTextCompositionSegment>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CoreTextCompositionSegment(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Text::Core::CoreTextCompositionSegment>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CoreTextCompositionSegment[] = {
        { "_assign_array_", _assign_array_CoreTextCompositionSegment, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CoreTextCompositionSegment), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_CoreTextCompositionSegment[] = {
        { "preconversion_string", reinterpret_cast<getter>(CoreTextCompositionSegment_get_PreconversionString), nullptr, nullptr, nullptr },
        { "range", reinterpret_cast<getter>(CoreTextCompositionSegment_get_Range), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_CoreTextCompositionSegment[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_CoreTextCompositionSegment) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CoreTextCompositionSegment) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CoreTextCompositionSegment) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CoreTextCompositionSegment) },
        { }};

    static PyType_Spec type_spec_CoreTextCompositionSegment = {
        "winrt._winrt_windows_ui_text_core.CoreTextCompositionSegment",
        sizeof(py::wrapper::Windows::UI::Text::Core::CoreTextCompositionSegment),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CoreTextCompositionSegment};

    // ----- CoreTextCompositionStartedEventArgs class --------------------

    static PyObject* _new_CoreTextCompositionStartedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Text::Core::CoreTextCompositionStartedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Text::Core::CoreTextCompositionStartedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_CoreTextCompositionStartedEventArgs(py::wrapper::Windows::UI::Text::Core::CoreTextCompositionStartedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CoreTextCompositionStartedEventArgs_GetDeferral(py::wrapper::Windows::UI::Text::Core::CoreTextCompositionStartedEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Text.Core.CoreTextCompositionStartedEventArgs", L"GetDeferral", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetDeferral();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CoreTextCompositionStartedEventArgs_get_IsCanceled(py::wrapper::Windows::UI::Text::Core::CoreTextCompositionStartedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.Core.CoreTextCompositionStartedEventArgs", L"IsCanceled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsCanceled();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CoreTextCompositionStartedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Text::Core::CoreTextCompositionStartedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CoreTextCompositionStartedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Text::Core::CoreTextCompositionStartedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CoreTextCompositionStartedEventArgs[] = {
        { "get_deferral", reinterpret_cast<PyCFunction>(CoreTextCompositionStartedEventArgs_GetDeferral), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_CoreTextCompositionStartedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CoreTextCompositionStartedEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_CoreTextCompositionStartedEventArgs[] = {
        { "is_canceled", reinterpret_cast<getter>(CoreTextCompositionStartedEventArgs_get_IsCanceled), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_CoreTextCompositionStartedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_CoreTextCompositionStartedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CoreTextCompositionStartedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CoreTextCompositionStartedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CoreTextCompositionStartedEventArgs) },
        { }};

    static PyType_Spec type_spec_CoreTextCompositionStartedEventArgs = {
        "winrt._winrt_windows_ui_text_core.CoreTextCompositionStartedEventArgs",
        sizeof(py::wrapper::Windows::UI::Text::Core::CoreTextCompositionStartedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CoreTextCompositionStartedEventArgs};

    // ----- CoreTextEditContext class --------------------

    static PyObject* _new_CoreTextEditContext(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Text::Core::CoreTextEditContext>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Text::Core::CoreTextEditContext>::type_name);
        return nullptr;
    }

    static void _dealloc_CoreTextEditContext(py::wrapper::Windows::UI::Text::Core::CoreTextEditContext* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CoreTextEditContext_NotifyFocusEnter(py::wrapper::Windows::UI::Text::Core::CoreTextEditContext* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Text.Core.CoreTextEditContext", L"NotifyFocusEnter", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.NotifyFocusEnter();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CoreTextEditContext_NotifyFocusLeave(py::wrapper::Windows::UI::Text::Core::CoreTextEditContext* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Text.Core.CoreTextEditContext", L"NotifyFocusLeave", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.NotifyFocusLeave();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CoreTextEditContext_NotifyLayoutChanged(py::wrapper::Windows::UI::Text::Core::CoreTextEditContext* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Text.Core.CoreTextEditContext", L"NotifyLayoutChanged", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.NotifyLayoutChanged();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CoreTextEditContext_NotifySelectionChanged(py::wrapper::Windows::UI::Text::Core::CoreTextEditContext* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Text.Core.CoreTextEditContext", L"NotifySelectionChanged", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Text::Core::CoreTextRange>(args, 0);

                {
                    auto _gil = release_gil();
                    self->obj.NotifySelectionChanged(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CoreTextEditContext_NotifyTextChanged(py::wrapper::Windows::UI::Text::Core::CoreTextEditContext* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 3)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Text.Core.CoreTextEditContext", L"NotifyTextChanged", 3);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Text::Core::CoreTextRange>(args, 0);
                auto param1 = py::convert_to<int32_t>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::UI::Text::Core::CoreTextRange>(args, 2);

                {
                    auto _gil = release_gil();
                    self->obj.NotifyTextChanged(param0, param1, param2);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CoreTextEditContext_get_Name(py::wrapper::Windows::UI::Text::Core::CoreTextEditContext* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.Core.CoreTextEditContext", L"Name");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Name();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CoreTextEditContext_put_Name(py::wrapper::Windows::UI::Text::Core::CoreTextEditContext* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.Core.CoreTextEditContext", L"Name");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            {
                auto _gil = release_gil();
                self->obj.Name(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CoreTextEditContext_get_IsReadOnly(py::wrapper::Windows::UI::Text::Core::CoreTextEditContext* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.Core.CoreTextEditContext", L"IsReadOnly");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsReadOnly();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CoreTextEditContext_put_IsReadOnly(py::wrapper::Windows::UI::Text::Core::CoreTextEditContext* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.Core.CoreTextEditContext", L"IsReadOnly");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.IsReadOnly(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CoreTextEditContext_get_InputScope(py::wrapper::Windows::UI::Text::Core::CoreTextEditContext* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.Core.CoreTextEditContext", L"InputScope");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.InputScope();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CoreTextEditContext_put_InputScope(py::wrapper::Windows::UI::Text::Core::CoreTextEditContext* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.Core.CoreTextEditContext", L"InputScope");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Text::Core::CoreTextInputScope>(arg);

            {
                auto _gil = release_gil();
                self->obj.InputScope(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CoreTextEditContext_get_InputPaneDisplayPolicy(py::wrapper::Windows::UI::Text::Core::CoreTextEditContext* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.Core.CoreTextEditContext", L"InputPaneDisplayPolicy");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.InputPaneDisplayPolicy();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CoreTextEditContext_put_InputPaneDisplayPolicy(py::wrapper::Windows::UI::Text::Core::CoreTextEditContext* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.Core.CoreTextEditContext", L"InputPaneDisplayPolicy");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Text::Core::CoreTextInputPaneDisplayPolicy>(arg);

            {
                auto _gil = release_gil();
                self->obj.InputPaneDisplayPolicy(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CoreTextEditContext_add_CompositionCompleted(py::wrapper::Windows::UI::Text::Core::CoreTextEditContext* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Text.Core.CoreTextEditContext", L"CompositionCompleted");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Text::Core::CoreTextEditContext, winrt::Windows::UI::Text::Core::CoreTextCompositionCompletedEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.CompositionCompleted(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreTextEditContext_remove_CompositionCompleted(py::wrapper::Windows::UI::Text::Core::CoreTextEditContext* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Text.Core.CoreTextEditContext", L"CompositionCompleted");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.CompositionCompleted(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreTextEditContext_add_CompositionStarted(py::wrapper::Windows::UI::Text::Core::CoreTextEditContext* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Text.Core.CoreTextEditContext", L"CompositionStarted");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Text::Core::CoreTextEditContext, winrt::Windows::UI::Text::Core::CoreTextCompositionStartedEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.CompositionStarted(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreTextEditContext_remove_CompositionStarted(py::wrapper::Windows::UI::Text::Core::CoreTextEditContext* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Text.Core.CoreTextEditContext", L"CompositionStarted");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.CompositionStarted(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreTextEditContext_add_FocusRemoved(py::wrapper::Windows::UI::Text::Core::CoreTextEditContext* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Text.Core.CoreTextEditContext", L"FocusRemoved");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Text::Core::CoreTextEditContext, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.FocusRemoved(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreTextEditContext_remove_FocusRemoved(py::wrapper::Windows::UI::Text::Core::CoreTextEditContext* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Text.Core.CoreTextEditContext", L"FocusRemoved");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.FocusRemoved(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreTextEditContext_add_FormatUpdating(py::wrapper::Windows::UI::Text::Core::CoreTextEditContext* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Text.Core.CoreTextEditContext", L"FormatUpdating");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Text::Core::CoreTextEditContext, winrt::Windows::UI::Text::Core::CoreTextFormatUpdatingEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.FormatUpdating(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreTextEditContext_remove_FormatUpdating(py::wrapper::Windows::UI::Text::Core::CoreTextEditContext* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Text.Core.CoreTextEditContext", L"FormatUpdating");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.FormatUpdating(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreTextEditContext_add_LayoutRequested(py::wrapper::Windows::UI::Text::Core::CoreTextEditContext* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Text.Core.CoreTextEditContext", L"LayoutRequested");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Text::Core::CoreTextEditContext, winrt::Windows::UI::Text::Core::CoreTextLayoutRequestedEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.LayoutRequested(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreTextEditContext_remove_LayoutRequested(py::wrapper::Windows::UI::Text::Core::CoreTextEditContext* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Text.Core.CoreTextEditContext", L"LayoutRequested");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.LayoutRequested(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreTextEditContext_add_SelectionRequested(py::wrapper::Windows::UI::Text::Core::CoreTextEditContext* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Text.Core.CoreTextEditContext", L"SelectionRequested");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Text::Core::CoreTextEditContext, winrt::Windows::UI::Text::Core::CoreTextSelectionRequestedEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SelectionRequested(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreTextEditContext_remove_SelectionRequested(py::wrapper::Windows::UI::Text::Core::CoreTextEditContext* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Text.Core.CoreTextEditContext", L"SelectionRequested");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.SelectionRequested(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreTextEditContext_add_SelectionUpdating(py::wrapper::Windows::UI::Text::Core::CoreTextEditContext* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Text.Core.CoreTextEditContext", L"SelectionUpdating");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Text::Core::CoreTextEditContext, winrt::Windows::UI::Text::Core::CoreTextSelectionUpdatingEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SelectionUpdating(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreTextEditContext_remove_SelectionUpdating(py::wrapper::Windows::UI::Text::Core::CoreTextEditContext* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Text.Core.CoreTextEditContext", L"SelectionUpdating");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.SelectionUpdating(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreTextEditContext_add_TextRequested(py::wrapper::Windows::UI::Text::Core::CoreTextEditContext* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Text.Core.CoreTextEditContext", L"TextRequested");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Text::Core::CoreTextEditContext, winrt::Windows::UI::Text::Core::CoreTextTextRequestedEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.TextRequested(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreTextEditContext_remove_TextRequested(py::wrapper::Windows::UI::Text::Core::CoreTextEditContext* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Text.Core.CoreTextEditContext", L"TextRequested");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.TextRequested(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreTextEditContext_add_TextUpdating(py::wrapper::Windows::UI::Text::Core::CoreTextEditContext* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Text.Core.CoreTextEditContext", L"TextUpdating");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Text::Core::CoreTextEditContext, winrt::Windows::UI::Text::Core::CoreTextTextUpdatingEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.TextUpdating(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreTextEditContext_remove_TextUpdating(py::wrapper::Windows::UI::Text::Core::CoreTextEditContext* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Text.Core.CoreTextEditContext", L"TextUpdating");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.TextUpdating(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreTextEditContext_add_NotifyFocusLeaveCompleted(py::wrapper::Windows::UI::Text::Core::CoreTextEditContext* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Text.Core.CoreTextEditContext", L"NotifyFocusLeaveCompleted");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Text::Core::CoreTextEditContext, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.NotifyFocusLeaveCompleted(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreTextEditContext_remove_NotifyFocusLeaveCompleted(py::wrapper::Windows::UI::Text::Core::CoreTextEditContext* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Text.Core.CoreTextEditContext", L"NotifyFocusLeaveCompleted");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.NotifyFocusLeaveCompleted(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CoreTextEditContext(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Text::Core::CoreTextEditContext>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CoreTextEditContext(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Text::Core::CoreTextEditContext>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CoreTextEditContext[] = {
        { "notify_focus_enter", reinterpret_cast<PyCFunction>(CoreTextEditContext_NotifyFocusEnter), METH_VARARGS, nullptr },
        { "notify_focus_leave", reinterpret_cast<PyCFunction>(CoreTextEditContext_NotifyFocusLeave), METH_VARARGS, nullptr },
        { "notify_layout_changed", reinterpret_cast<PyCFunction>(CoreTextEditContext_NotifyLayoutChanged), METH_VARARGS, nullptr },
        { "notify_selection_changed", reinterpret_cast<PyCFunction>(CoreTextEditContext_NotifySelectionChanged), METH_VARARGS, nullptr },
        { "notify_text_changed", reinterpret_cast<PyCFunction>(CoreTextEditContext_NotifyTextChanged), METH_VARARGS, nullptr },
        { "add_composition_completed", reinterpret_cast<PyCFunction>(CoreTextEditContext_add_CompositionCompleted), METH_O, nullptr },
        { "remove_composition_completed", reinterpret_cast<PyCFunction>(CoreTextEditContext_remove_CompositionCompleted), METH_O, nullptr },
        { "add_composition_started", reinterpret_cast<PyCFunction>(CoreTextEditContext_add_CompositionStarted), METH_O, nullptr },
        { "remove_composition_started", reinterpret_cast<PyCFunction>(CoreTextEditContext_remove_CompositionStarted), METH_O, nullptr },
        { "add_focus_removed", reinterpret_cast<PyCFunction>(CoreTextEditContext_add_FocusRemoved), METH_O, nullptr },
        { "remove_focus_removed", reinterpret_cast<PyCFunction>(CoreTextEditContext_remove_FocusRemoved), METH_O, nullptr },
        { "add_format_updating", reinterpret_cast<PyCFunction>(CoreTextEditContext_add_FormatUpdating), METH_O, nullptr },
        { "remove_format_updating", reinterpret_cast<PyCFunction>(CoreTextEditContext_remove_FormatUpdating), METH_O, nullptr },
        { "add_layout_requested", reinterpret_cast<PyCFunction>(CoreTextEditContext_add_LayoutRequested), METH_O, nullptr },
        { "remove_layout_requested", reinterpret_cast<PyCFunction>(CoreTextEditContext_remove_LayoutRequested), METH_O, nullptr },
        { "add_selection_requested", reinterpret_cast<PyCFunction>(CoreTextEditContext_add_SelectionRequested), METH_O, nullptr },
        { "remove_selection_requested", reinterpret_cast<PyCFunction>(CoreTextEditContext_remove_SelectionRequested), METH_O, nullptr },
        { "add_selection_updating", reinterpret_cast<PyCFunction>(CoreTextEditContext_add_SelectionUpdating), METH_O, nullptr },
        { "remove_selection_updating", reinterpret_cast<PyCFunction>(CoreTextEditContext_remove_SelectionUpdating), METH_O, nullptr },
        { "add_text_requested", reinterpret_cast<PyCFunction>(CoreTextEditContext_add_TextRequested), METH_O, nullptr },
        { "remove_text_requested", reinterpret_cast<PyCFunction>(CoreTextEditContext_remove_TextRequested), METH_O, nullptr },
        { "add_text_updating", reinterpret_cast<PyCFunction>(CoreTextEditContext_add_TextUpdating), METH_O, nullptr },
        { "remove_text_updating", reinterpret_cast<PyCFunction>(CoreTextEditContext_remove_TextUpdating), METH_O, nullptr },
        { "add_notify_focus_leave_completed", reinterpret_cast<PyCFunction>(CoreTextEditContext_add_NotifyFocusLeaveCompleted), METH_O, nullptr },
        { "remove_notify_focus_leave_completed", reinterpret_cast<PyCFunction>(CoreTextEditContext_remove_NotifyFocusLeaveCompleted), METH_O, nullptr },
        { "_assign_array_", _assign_array_CoreTextEditContext, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CoreTextEditContext), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_CoreTextEditContext[] = {
        { "name", reinterpret_cast<getter>(CoreTextEditContext_get_Name), reinterpret_cast<setter>(CoreTextEditContext_put_Name), nullptr, nullptr },
        { "is_read_only", reinterpret_cast<getter>(CoreTextEditContext_get_IsReadOnly), reinterpret_cast<setter>(CoreTextEditContext_put_IsReadOnly), nullptr, nullptr },
        { "input_scope", reinterpret_cast<getter>(CoreTextEditContext_get_InputScope), reinterpret_cast<setter>(CoreTextEditContext_put_InputScope), nullptr, nullptr },
        { "input_pane_display_policy", reinterpret_cast<getter>(CoreTextEditContext_get_InputPaneDisplayPolicy), reinterpret_cast<setter>(CoreTextEditContext_put_InputPaneDisplayPolicy), nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_CoreTextEditContext[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_CoreTextEditContext) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CoreTextEditContext) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CoreTextEditContext) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CoreTextEditContext) },
        { }};

    static PyType_Spec type_spec_CoreTextEditContext = {
        "winrt._winrt_windows_ui_text_core.CoreTextEditContext",
        sizeof(py::wrapper::Windows::UI::Text::Core::CoreTextEditContext),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CoreTextEditContext};

    // ----- CoreTextFormatUpdatingEventArgs class --------------------

    static PyObject* _new_CoreTextFormatUpdatingEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Text::Core::CoreTextFormatUpdatingEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Text::Core::CoreTextFormatUpdatingEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_CoreTextFormatUpdatingEventArgs(py::wrapper::Windows::UI::Text::Core::CoreTextFormatUpdatingEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CoreTextFormatUpdatingEventArgs_GetDeferral(py::wrapper::Windows::UI::Text::Core::CoreTextFormatUpdatingEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Text.Core.CoreTextFormatUpdatingEventArgs", L"GetDeferral", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetDeferral();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CoreTextFormatUpdatingEventArgs_get_Result(py::wrapper::Windows::UI::Text::Core::CoreTextFormatUpdatingEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.Core.CoreTextFormatUpdatingEventArgs", L"Result");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Result();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CoreTextFormatUpdatingEventArgs_put_Result(py::wrapper::Windows::UI::Text::Core::CoreTextFormatUpdatingEventArgs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.Core.CoreTextFormatUpdatingEventArgs", L"Result");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Text::Core::CoreTextFormatUpdatingResult>(arg);

            {
                auto _gil = release_gil();
                self->obj.Result(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CoreTextFormatUpdatingEventArgs_get_BackgroundColor(py::wrapper::Windows::UI::Text::Core::CoreTextFormatUpdatingEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.Core.CoreTextFormatUpdatingEventArgs", L"BackgroundColor");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.BackgroundColor();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreTextFormatUpdatingEventArgs_get_IsCanceled(py::wrapper::Windows::UI::Text::Core::CoreTextFormatUpdatingEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.Core.CoreTextFormatUpdatingEventArgs", L"IsCanceled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsCanceled();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreTextFormatUpdatingEventArgs_get_Range(py::wrapper::Windows::UI::Text::Core::CoreTextFormatUpdatingEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.Core.CoreTextFormatUpdatingEventArgs", L"Range");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Range();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreTextFormatUpdatingEventArgs_get_Reason(py::wrapper::Windows::UI::Text::Core::CoreTextFormatUpdatingEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.Core.CoreTextFormatUpdatingEventArgs", L"Reason");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Reason();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreTextFormatUpdatingEventArgs_get_TextColor(py::wrapper::Windows::UI::Text::Core::CoreTextFormatUpdatingEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.Core.CoreTextFormatUpdatingEventArgs", L"TextColor");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.TextColor();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreTextFormatUpdatingEventArgs_get_UnderlineColor(py::wrapper::Windows::UI::Text::Core::CoreTextFormatUpdatingEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.Core.CoreTextFormatUpdatingEventArgs", L"UnderlineColor");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.UnderlineColor();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreTextFormatUpdatingEventArgs_get_UnderlineType(py::wrapper::Windows::UI::Text::Core::CoreTextFormatUpdatingEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.Core.CoreTextFormatUpdatingEventArgs", L"UnderlineType");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.UnderlineType();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CoreTextFormatUpdatingEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Text::Core::CoreTextFormatUpdatingEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CoreTextFormatUpdatingEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Text::Core::CoreTextFormatUpdatingEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CoreTextFormatUpdatingEventArgs[] = {
        { "get_deferral", reinterpret_cast<PyCFunction>(CoreTextFormatUpdatingEventArgs_GetDeferral), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_CoreTextFormatUpdatingEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CoreTextFormatUpdatingEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_CoreTextFormatUpdatingEventArgs[] = {
        { "result", reinterpret_cast<getter>(CoreTextFormatUpdatingEventArgs_get_Result), reinterpret_cast<setter>(CoreTextFormatUpdatingEventArgs_put_Result), nullptr, nullptr },
        { "background_color", reinterpret_cast<getter>(CoreTextFormatUpdatingEventArgs_get_BackgroundColor), nullptr, nullptr, nullptr },
        { "is_canceled", reinterpret_cast<getter>(CoreTextFormatUpdatingEventArgs_get_IsCanceled), nullptr, nullptr, nullptr },
        { "range", reinterpret_cast<getter>(CoreTextFormatUpdatingEventArgs_get_Range), nullptr, nullptr, nullptr },
        { "reason", reinterpret_cast<getter>(CoreTextFormatUpdatingEventArgs_get_Reason), nullptr, nullptr, nullptr },
        { "text_color", reinterpret_cast<getter>(CoreTextFormatUpdatingEventArgs_get_TextColor), nullptr, nullptr, nullptr },
        { "underline_color", reinterpret_cast<getter>(CoreTextFormatUpdatingEventArgs_get_UnderlineColor), nullptr, nullptr, nullptr },
        { "underline_type", reinterpret_cast<getter>(CoreTextFormatUpdatingEventArgs_get_UnderlineType), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_CoreTextFormatUpdatingEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_CoreTextFormatUpdatingEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CoreTextFormatUpdatingEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CoreTextFormatUpdatingEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CoreTextFormatUpdatingEventArgs) },
        { }};

    static PyType_Spec type_spec_CoreTextFormatUpdatingEventArgs = {
        "winrt._winrt_windows_ui_text_core.CoreTextFormatUpdatingEventArgs",
        sizeof(py::wrapper::Windows::UI::Text::Core::CoreTextFormatUpdatingEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CoreTextFormatUpdatingEventArgs};

    // ----- CoreTextLayoutBounds class --------------------

    static PyObject* _new_CoreTextLayoutBounds(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Text::Core::CoreTextLayoutBounds>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Text::Core::CoreTextLayoutBounds>::type_name);
        return nullptr;
    }

    static void _dealloc_CoreTextLayoutBounds(py::wrapper::Windows::UI::Text::Core::CoreTextLayoutBounds* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CoreTextLayoutBounds_get_TextBounds(py::wrapper::Windows::UI::Text::Core::CoreTextLayoutBounds* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.Core.CoreTextLayoutBounds", L"TextBounds");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.TextBounds();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CoreTextLayoutBounds_put_TextBounds(py::wrapper::Windows::UI::Text::Core::CoreTextLayoutBounds* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.Core.CoreTextLayoutBounds", L"TextBounds");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::Rect>(arg);

            {
                auto _gil = release_gil();
                self->obj.TextBounds(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CoreTextLayoutBounds_get_ControlBounds(py::wrapper::Windows::UI::Text::Core::CoreTextLayoutBounds* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.Core.CoreTextLayoutBounds", L"ControlBounds");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ControlBounds();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CoreTextLayoutBounds_put_ControlBounds(py::wrapper::Windows::UI::Text::Core::CoreTextLayoutBounds* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.Core.CoreTextLayoutBounds", L"ControlBounds");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::Rect>(arg);

            {
                auto _gil = release_gil();
                self->obj.ControlBounds(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_CoreTextLayoutBounds(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Text::Core::CoreTextLayoutBounds>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CoreTextLayoutBounds(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Text::Core::CoreTextLayoutBounds>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CoreTextLayoutBounds[] = {
        { "_assign_array_", _assign_array_CoreTextLayoutBounds, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CoreTextLayoutBounds), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_CoreTextLayoutBounds[] = {
        { "text_bounds", reinterpret_cast<getter>(CoreTextLayoutBounds_get_TextBounds), reinterpret_cast<setter>(CoreTextLayoutBounds_put_TextBounds), nullptr, nullptr },
        { "control_bounds", reinterpret_cast<getter>(CoreTextLayoutBounds_get_ControlBounds), reinterpret_cast<setter>(CoreTextLayoutBounds_put_ControlBounds), nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_CoreTextLayoutBounds[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_CoreTextLayoutBounds) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CoreTextLayoutBounds) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CoreTextLayoutBounds) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CoreTextLayoutBounds) },
        { }};

    static PyType_Spec type_spec_CoreTextLayoutBounds = {
        "winrt._winrt_windows_ui_text_core.CoreTextLayoutBounds",
        sizeof(py::wrapper::Windows::UI::Text::Core::CoreTextLayoutBounds),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CoreTextLayoutBounds};

    // ----- CoreTextLayoutRequest class --------------------

    static PyObject* _new_CoreTextLayoutRequest(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Text::Core::CoreTextLayoutRequest>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Text::Core::CoreTextLayoutRequest>::type_name);
        return nullptr;
    }

    static void _dealloc_CoreTextLayoutRequest(py::wrapper::Windows::UI::Text::Core::CoreTextLayoutRequest* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CoreTextLayoutRequest_GetDeferral(py::wrapper::Windows::UI::Text::Core::CoreTextLayoutRequest* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Text.Core.CoreTextLayoutRequest", L"GetDeferral", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetDeferral();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CoreTextLayoutRequest_get_IsCanceled(py::wrapper::Windows::UI::Text::Core::CoreTextLayoutRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.Core.CoreTextLayoutRequest", L"IsCanceled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsCanceled();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreTextLayoutRequest_get_LayoutBounds(py::wrapper::Windows::UI::Text::Core::CoreTextLayoutRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.Core.CoreTextLayoutRequest", L"LayoutBounds");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.LayoutBounds();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreTextLayoutRequest_get_Range(py::wrapper::Windows::UI::Text::Core::CoreTextLayoutRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.Core.CoreTextLayoutRequest", L"Range");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Range();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreTextLayoutRequest_get_LayoutBoundsVisualPixels(py::wrapper::Windows::UI::Text::Core::CoreTextLayoutRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.Core.CoreTextLayoutRequest", L"LayoutBoundsVisualPixels");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.LayoutBoundsVisualPixels();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CoreTextLayoutRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Text::Core::CoreTextLayoutRequest>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CoreTextLayoutRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Text::Core::CoreTextLayoutRequest>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CoreTextLayoutRequest[] = {
        { "get_deferral", reinterpret_cast<PyCFunction>(CoreTextLayoutRequest_GetDeferral), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_CoreTextLayoutRequest, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CoreTextLayoutRequest), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_CoreTextLayoutRequest[] = {
        { "is_canceled", reinterpret_cast<getter>(CoreTextLayoutRequest_get_IsCanceled), nullptr, nullptr, nullptr },
        { "layout_bounds", reinterpret_cast<getter>(CoreTextLayoutRequest_get_LayoutBounds), nullptr, nullptr, nullptr },
        { "range", reinterpret_cast<getter>(CoreTextLayoutRequest_get_Range), nullptr, nullptr, nullptr },
        { "layout_bounds_visual_pixels", reinterpret_cast<getter>(CoreTextLayoutRequest_get_LayoutBoundsVisualPixels), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_CoreTextLayoutRequest[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_CoreTextLayoutRequest) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CoreTextLayoutRequest) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CoreTextLayoutRequest) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CoreTextLayoutRequest) },
        { }};

    static PyType_Spec type_spec_CoreTextLayoutRequest = {
        "winrt._winrt_windows_ui_text_core.CoreTextLayoutRequest",
        sizeof(py::wrapper::Windows::UI::Text::Core::CoreTextLayoutRequest),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CoreTextLayoutRequest};

    // ----- CoreTextLayoutRequestedEventArgs class --------------------

    static PyObject* _new_CoreTextLayoutRequestedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Text::Core::CoreTextLayoutRequestedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Text::Core::CoreTextLayoutRequestedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_CoreTextLayoutRequestedEventArgs(py::wrapper::Windows::UI::Text::Core::CoreTextLayoutRequestedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CoreTextLayoutRequestedEventArgs_get_Request(py::wrapper::Windows::UI::Text::Core::CoreTextLayoutRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.Core.CoreTextLayoutRequestedEventArgs", L"Request");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Request();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CoreTextLayoutRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Text::Core::CoreTextLayoutRequestedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CoreTextLayoutRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Text::Core::CoreTextLayoutRequestedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CoreTextLayoutRequestedEventArgs[] = {
        { "_assign_array_", _assign_array_CoreTextLayoutRequestedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CoreTextLayoutRequestedEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_CoreTextLayoutRequestedEventArgs[] = {
        { "request", reinterpret_cast<getter>(CoreTextLayoutRequestedEventArgs_get_Request), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_CoreTextLayoutRequestedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_CoreTextLayoutRequestedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CoreTextLayoutRequestedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CoreTextLayoutRequestedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CoreTextLayoutRequestedEventArgs) },
        { }};

    static PyType_Spec type_spec_CoreTextLayoutRequestedEventArgs = {
        "winrt._winrt_windows_ui_text_core.CoreTextLayoutRequestedEventArgs",
        sizeof(py::wrapper::Windows::UI::Text::Core::CoreTextLayoutRequestedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CoreTextLayoutRequestedEventArgs};

    // ----- CoreTextSelectionRequest class --------------------

    static PyObject* _new_CoreTextSelectionRequest(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Text::Core::CoreTextSelectionRequest>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Text::Core::CoreTextSelectionRequest>::type_name);
        return nullptr;
    }

    static void _dealloc_CoreTextSelectionRequest(py::wrapper::Windows::UI::Text::Core::CoreTextSelectionRequest* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CoreTextSelectionRequest_GetDeferral(py::wrapper::Windows::UI::Text::Core::CoreTextSelectionRequest* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Text.Core.CoreTextSelectionRequest", L"GetDeferral", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetDeferral();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CoreTextSelectionRequest_get_Selection(py::wrapper::Windows::UI::Text::Core::CoreTextSelectionRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.Core.CoreTextSelectionRequest", L"Selection");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Selection();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CoreTextSelectionRequest_put_Selection(py::wrapper::Windows::UI::Text::Core::CoreTextSelectionRequest* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.Core.CoreTextSelectionRequest", L"Selection");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Text::Core::CoreTextRange>(arg);

            {
                auto _gil = release_gil();
                self->obj.Selection(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CoreTextSelectionRequest_get_IsCanceled(py::wrapper::Windows::UI::Text::Core::CoreTextSelectionRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.Core.CoreTextSelectionRequest", L"IsCanceled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsCanceled();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CoreTextSelectionRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Text::Core::CoreTextSelectionRequest>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CoreTextSelectionRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Text::Core::CoreTextSelectionRequest>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CoreTextSelectionRequest[] = {
        { "get_deferral", reinterpret_cast<PyCFunction>(CoreTextSelectionRequest_GetDeferral), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_CoreTextSelectionRequest, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CoreTextSelectionRequest), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_CoreTextSelectionRequest[] = {
        { "selection", reinterpret_cast<getter>(CoreTextSelectionRequest_get_Selection), reinterpret_cast<setter>(CoreTextSelectionRequest_put_Selection), nullptr, nullptr },
        { "is_canceled", reinterpret_cast<getter>(CoreTextSelectionRequest_get_IsCanceled), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_CoreTextSelectionRequest[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_CoreTextSelectionRequest) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CoreTextSelectionRequest) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CoreTextSelectionRequest) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CoreTextSelectionRequest) },
        { }};

    static PyType_Spec type_spec_CoreTextSelectionRequest = {
        "winrt._winrt_windows_ui_text_core.CoreTextSelectionRequest",
        sizeof(py::wrapper::Windows::UI::Text::Core::CoreTextSelectionRequest),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CoreTextSelectionRequest};

    // ----- CoreTextSelectionRequestedEventArgs class --------------------

    static PyObject* _new_CoreTextSelectionRequestedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Text::Core::CoreTextSelectionRequestedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Text::Core::CoreTextSelectionRequestedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_CoreTextSelectionRequestedEventArgs(py::wrapper::Windows::UI::Text::Core::CoreTextSelectionRequestedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CoreTextSelectionRequestedEventArgs_get_Request(py::wrapper::Windows::UI::Text::Core::CoreTextSelectionRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.Core.CoreTextSelectionRequestedEventArgs", L"Request");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Request();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CoreTextSelectionRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Text::Core::CoreTextSelectionRequestedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CoreTextSelectionRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Text::Core::CoreTextSelectionRequestedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CoreTextSelectionRequestedEventArgs[] = {
        { "_assign_array_", _assign_array_CoreTextSelectionRequestedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CoreTextSelectionRequestedEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_CoreTextSelectionRequestedEventArgs[] = {
        { "request", reinterpret_cast<getter>(CoreTextSelectionRequestedEventArgs_get_Request), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_CoreTextSelectionRequestedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_CoreTextSelectionRequestedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CoreTextSelectionRequestedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CoreTextSelectionRequestedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CoreTextSelectionRequestedEventArgs) },
        { }};

    static PyType_Spec type_spec_CoreTextSelectionRequestedEventArgs = {
        "winrt._winrt_windows_ui_text_core.CoreTextSelectionRequestedEventArgs",
        sizeof(py::wrapper::Windows::UI::Text::Core::CoreTextSelectionRequestedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CoreTextSelectionRequestedEventArgs};

    // ----- CoreTextSelectionUpdatingEventArgs class --------------------

    static PyObject* _new_CoreTextSelectionUpdatingEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Text::Core::CoreTextSelectionUpdatingEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Text::Core::CoreTextSelectionUpdatingEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_CoreTextSelectionUpdatingEventArgs(py::wrapper::Windows::UI::Text::Core::CoreTextSelectionUpdatingEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CoreTextSelectionUpdatingEventArgs_GetDeferral(py::wrapper::Windows::UI::Text::Core::CoreTextSelectionUpdatingEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Text.Core.CoreTextSelectionUpdatingEventArgs", L"GetDeferral", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetDeferral();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CoreTextSelectionUpdatingEventArgs_get_Result(py::wrapper::Windows::UI::Text::Core::CoreTextSelectionUpdatingEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.Core.CoreTextSelectionUpdatingEventArgs", L"Result");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Result();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CoreTextSelectionUpdatingEventArgs_put_Result(py::wrapper::Windows::UI::Text::Core::CoreTextSelectionUpdatingEventArgs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.Core.CoreTextSelectionUpdatingEventArgs", L"Result");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Text::Core::CoreTextSelectionUpdatingResult>(arg);

            {
                auto _gil = release_gil();
                self->obj.Result(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CoreTextSelectionUpdatingEventArgs_get_IsCanceled(py::wrapper::Windows::UI::Text::Core::CoreTextSelectionUpdatingEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.Core.CoreTextSelectionUpdatingEventArgs", L"IsCanceled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsCanceled();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreTextSelectionUpdatingEventArgs_get_Selection(py::wrapper::Windows::UI::Text::Core::CoreTextSelectionUpdatingEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.Core.CoreTextSelectionUpdatingEventArgs", L"Selection");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Selection();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CoreTextSelectionUpdatingEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Text::Core::CoreTextSelectionUpdatingEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CoreTextSelectionUpdatingEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Text::Core::CoreTextSelectionUpdatingEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CoreTextSelectionUpdatingEventArgs[] = {
        { "get_deferral", reinterpret_cast<PyCFunction>(CoreTextSelectionUpdatingEventArgs_GetDeferral), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_CoreTextSelectionUpdatingEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CoreTextSelectionUpdatingEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_CoreTextSelectionUpdatingEventArgs[] = {
        { "result", reinterpret_cast<getter>(CoreTextSelectionUpdatingEventArgs_get_Result), reinterpret_cast<setter>(CoreTextSelectionUpdatingEventArgs_put_Result), nullptr, nullptr },
        { "is_canceled", reinterpret_cast<getter>(CoreTextSelectionUpdatingEventArgs_get_IsCanceled), nullptr, nullptr, nullptr },
        { "selection", reinterpret_cast<getter>(CoreTextSelectionUpdatingEventArgs_get_Selection), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_CoreTextSelectionUpdatingEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_CoreTextSelectionUpdatingEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CoreTextSelectionUpdatingEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CoreTextSelectionUpdatingEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CoreTextSelectionUpdatingEventArgs) },
        { }};

    static PyType_Spec type_spec_CoreTextSelectionUpdatingEventArgs = {
        "winrt._winrt_windows_ui_text_core.CoreTextSelectionUpdatingEventArgs",
        sizeof(py::wrapper::Windows::UI::Text::Core::CoreTextSelectionUpdatingEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CoreTextSelectionUpdatingEventArgs};

    // ----- CoreTextServicesConstants class --------------------

    static PyObject* _new_CoreTextServicesConstants(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Text::Core::CoreTextServicesConstants>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Text::Core::CoreTextServicesConstants>::type_name);
        return nullptr;
    }

    static PyObject* CoreTextServicesConstants_get_HiddenCharacter(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.Core.CoreTextServicesConstants", L"HiddenCharacter");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::UI::Text::Core::CoreTextServicesConstants::HiddenCharacter();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CoreTextServicesConstants[] = {
        { }};

    static PyGetSetDef _getset_CoreTextServicesConstants[] = {
        { }};

    static PyType_Slot _type_slots_CoreTextServicesConstants[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_CoreTextServicesConstants) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CoreTextServicesConstants) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CoreTextServicesConstants) },
        { }};

    static PyType_Spec type_spec_CoreTextServicesConstants = {
        "winrt._winrt_windows_ui_text_core.CoreTextServicesConstants",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CoreTextServicesConstants};

    static PyGetSetDef getset_CoreTextServicesConstants_Static[] = {
        { "hidden_character", reinterpret_cast<getter>(CoreTextServicesConstants_get_HiddenCharacter), nullptr, nullptr, nullptr },
        { }};

    static PyMethodDef methods_CoreTextServicesConstants_Static[] = {
        { }};

    static PyType_Slot type_slots_CoreTextServicesConstants_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_CoreTextServicesConstants_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_CoreTextServicesConstants_Static) },
        { }
    };

    static PyType_Spec type_spec_CoreTextServicesConstants_Static = {
        "winrt._winrt_windows_ui_text_core.CoreTextServicesConstants_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_CoreTextServicesConstants_Static};

    // ----- CoreTextServicesManager class --------------------

    static PyObject* _new_CoreTextServicesManager(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Text::Core::CoreTextServicesManager>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Text::Core::CoreTextServicesManager>::type_name);
        return nullptr;
    }

    static void _dealloc_CoreTextServicesManager(py::wrapper::Windows::UI::Text::Core::CoreTextServicesManager* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CoreTextServicesManager_CreateEditContext(py::wrapper::Windows::UI::Text::Core::CoreTextServicesManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Text.Core.CoreTextServicesManager", L"CreateEditContext", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.CreateEditContext();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CoreTextServicesManager_GetForCurrentView(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Text.Core.CoreTextServicesManager", L"GetForCurrentView", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::UI::Text::Core::CoreTextServicesManager::GetForCurrentView();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CoreTextServicesManager_get_InputLanguage(py::wrapper::Windows::UI::Text::Core::CoreTextServicesManager* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.Core.CoreTextServicesManager", L"InputLanguage");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.InputLanguage();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreTextServicesManager_add_InputLanguageChanged(py::wrapper::Windows::UI::Text::Core::CoreTextServicesManager* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Text.Core.CoreTextServicesManager", L"InputLanguageChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Text::Core::CoreTextServicesManager, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.InputLanguageChanged(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreTextServicesManager_remove_InputLanguageChanged(py::wrapper::Windows::UI::Text::Core::CoreTextServicesManager* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Text.Core.CoreTextServicesManager", L"InputLanguageChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.InputLanguageChanged(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CoreTextServicesManager(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Text::Core::CoreTextServicesManager>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CoreTextServicesManager(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Text::Core::CoreTextServicesManager>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CoreTextServicesManager[] = {
        { "create_edit_context", reinterpret_cast<PyCFunction>(CoreTextServicesManager_CreateEditContext), METH_VARARGS, nullptr },
        { "add_input_language_changed", reinterpret_cast<PyCFunction>(CoreTextServicesManager_add_InputLanguageChanged), METH_O, nullptr },
        { "remove_input_language_changed", reinterpret_cast<PyCFunction>(CoreTextServicesManager_remove_InputLanguageChanged), METH_O, nullptr },
        { "_assign_array_", _assign_array_CoreTextServicesManager, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CoreTextServicesManager), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_CoreTextServicesManager[] = {
        { "input_language", reinterpret_cast<getter>(CoreTextServicesManager_get_InputLanguage), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_CoreTextServicesManager[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_CoreTextServicesManager) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CoreTextServicesManager) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CoreTextServicesManager) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CoreTextServicesManager) },
        { }};

    static PyType_Spec type_spec_CoreTextServicesManager = {
        "winrt._winrt_windows_ui_text_core.CoreTextServicesManager",
        sizeof(py::wrapper::Windows::UI::Text::Core::CoreTextServicesManager),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CoreTextServicesManager};

    static PyGetSetDef getset_CoreTextServicesManager_Static[] = {
        { }};

    static PyMethodDef methods_CoreTextServicesManager_Static[] = {
        { "get_for_current_view", reinterpret_cast<PyCFunction>(CoreTextServicesManager_GetForCurrentView), METH_VARARGS, nullptr },
        { }};

    static PyType_Slot type_slots_CoreTextServicesManager_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_CoreTextServicesManager_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_CoreTextServicesManager_Static) },
        { }
    };

    static PyType_Spec type_spec_CoreTextServicesManager_Static = {
        "winrt._winrt_windows_ui_text_core.CoreTextServicesManager_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_CoreTextServicesManager_Static};

    // ----- CoreTextTextRequest class --------------------

    static PyObject* _new_CoreTextTextRequest(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Text::Core::CoreTextTextRequest>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Text::Core::CoreTextTextRequest>::type_name);
        return nullptr;
    }

    static void _dealloc_CoreTextTextRequest(py::wrapper::Windows::UI::Text::Core::CoreTextTextRequest* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CoreTextTextRequest_GetDeferral(py::wrapper::Windows::UI::Text::Core::CoreTextTextRequest* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Text.Core.CoreTextTextRequest", L"GetDeferral", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetDeferral();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CoreTextTextRequest_get_Text(py::wrapper::Windows::UI::Text::Core::CoreTextTextRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.Core.CoreTextTextRequest", L"Text");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Text();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CoreTextTextRequest_put_Text(py::wrapper::Windows::UI::Text::Core::CoreTextTextRequest* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.Core.CoreTextTextRequest", L"Text");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            {
                auto _gil = release_gil();
                self->obj.Text(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CoreTextTextRequest_get_IsCanceled(py::wrapper::Windows::UI::Text::Core::CoreTextTextRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.Core.CoreTextTextRequest", L"IsCanceled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsCanceled();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreTextTextRequest_get_Range(py::wrapper::Windows::UI::Text::Core::CoreTextTextRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.Core.CoreTextTextRequest", L"Range");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Range();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CoreTextTextRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Text::Core::CoreTextTextRequest>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CoreTextTextRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Text::Core::CoreTextTextRequest>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CoreTextTextRequest[] = {
        { "get_deferral", reinterpret_cast<PyCFunction>(CoreTextTextRequest_GetDeferral), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_CoreTextTextRequest, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CoreTextTextRequest), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_CoreTextTextRequest[] = {
        { "text", reinterpret_cast<getter>(CoreTextTextRequest_get_Text), reinterpret_cast<setter>(CoreTextTextRequest_put_Text), nullptr, nullptr },
        { "is_canceled", reinterpret_cast<getter>(CoreTextTextRequest_get_IsCanceled), nullptr, nullptr, nullptr },
        { "range", reinterpret_cast<getter>(CoreTextTextRequest_get_Range), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_CoreTextTextRequest[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_CoreTextTextRequest) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CoreTextTextRequest) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CoreTextTextRequest) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CoreTextTextRequest) },
        { }};

    static PyType_Spec type_spec_CoreTextTextRequest = {
        "winrt._winrt_windows_ui_text_core.CoreTextTextRequest",
        sizeof(py::wrapper::Windows::UI::Text::Core::CoreTextTextRequest),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CoreTextTextRequest};

    // ----- CoreTextTextRequestedEventArgs class --------------------

    static PyObject* _new_CoreTextTextRequestedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Text::Core::CoreTextTextRequestedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Text::Core::CoreTextTextRequestedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_CoreTextTextRequestedEventArgs(py::wrapper::Windows::UI::Text::Core::CoreTextTextRequestedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CoreTextTextRequestedEventArgs_get_Request(py::wrapper::Windows::UI::Text::Core::CoreTextTextRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.Core.CoreTextTextRequestedEventArgs", L"Request");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Request();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CoreTextTextRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Text::Core::CoreTextTextRequestedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CoreTextTextRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Text::Core::CoreTextTextRequestedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CoreTextTextRequestedEventArgs[] = {
        { "_assign_array_", _assign_array_CoreTextTextRequestedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CoreTextTextRequestedEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_CoreTextTextRequestedEventArgs[] = {
        { "request", reinterpret_cast<getter>(CoreTextTextRequestedEventArgs_get_Request), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_CoreTextTextRequestedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_CoreTextTextRequestedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CoreTextTextRequestedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CoreTextTextRequestedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CoreTextTextRequestedEventArgs) },
        { }};

    static PyType_Spec type_spec_CoreTextTextRequestedEventArgs = {
        "winrt._winrt_windows_ui_text_core.CoreTextTextRequestedEventArgs",
        sizeof(py::wrapper::Windows::UI::Text::Core::CoreTextTextRequestedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CoreTextTextRequestedEventArgs};

    // ----- CoreTextTextUpdatingEventArgs class --------------------

    static PyObject* _new_CoreTextTextUpdatingEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Text::Core::CoreTextTextUpdatingEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Text::Core::CoreTextTextUpdatingEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_CoreTextTextUpdatingEventArgs(py::wrapper::Windows::UI::Text::Core::CoreTextTextUpdatingEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CoreTextTextUpdatingEventArgs_GetDeferral(py::wrapper::Windows::UI::Text::Core::CoreTextTextUpdatingEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Text.Core.CoreTextTextUpdatingEventArgs", L"GetDeferral", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetDeferral();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CoreTextTextUpdatingEventArgs_get_Result(py::wrapper::Windows::UI::Text::Core::CoreTextTextUpdatingEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.Core.CoreTextTextUpdatingEventArgs", L"Result");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Result();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CoreTextTextUpdatingEventArgs_put_Result(py::wrapper::Windows::UI::Text::Core::CoreTextTextUpdatingEventArgs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.Core.CoreTextTextUpdatingEventArgs", L"Result");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Text::Core::CoreTextTextUpdatingResult>(arg);

            {
                auto _gil = release_gil();
                self->obj.Result(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CoreTextTextUpdatingEventArgs_get_InputLanguage(py::wrapper::Windows::UI::Text::Core::CoreTextTextUpdatingEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.Core.CoreTextTextUpdatingEventArgs", L"InputLanguage");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.InputLanguage();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreTextTextUpdatingEventArgs_get_IsCanceled(py::wrapper::Windows::UI::Text::Core::CoreTextTextUpdatingEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.Core.CoreTextTextUpdatingEventArgs", L"IsCanceled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsCanceled();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreTextTextUpdatingEventArgs_get_NewSelection(py::wrapper::Windows::UI::Text::Core::CoreTextTextUpdatingEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.Core.CoreTextTextUpdatingEventArgs", L"NewSelection");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.NewSelection();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreTextTextUpdatingEventArgs_get_Range(py::wrapper::Windows::UI::Text::Core::CoreTextTextUpdatingEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.Core.CoreTextTextUpdatingEventArgs", L"Range");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Range();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreTextTextUpdatingEventArgs_get_Text(py::wrapper::Windows::UI::Text::Core::CoreTextTextUpdatingEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.Core.CoreTextTextUpdatingEventArgs", L"Text");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Text();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CoreTextTextUpdatingEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Text::Core::CoreTextTextUpdatingEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CoreTextTextUpdatingEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Text::Core::CoreTextTextUpdatingEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CoreTextTextUpdatingEventArgs[] = {
        { "get_deferral", reinterpret_cast<PyCFunction>(CoreTextTextUpdatingEventArgs_GetDeferral), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_CoreTextTextUpdatingEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CoreTextTextUpdatingEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_CoreTextTextUpdatingEventArgs[] = {
        { "result", reinterpret_cast<getter>(CoreTextTextUpdatingEventArgs_get_Result), reinterpret_cast<setter>(CoreTextTextUpdatingEventArgs_put_Result), nullptr, nullptr },
        { "input_language", reinterpret_cast<getter>(CoreTextTextUpdatingEventArgs_get_InputLanguage), nullptr, nullptr, nullptr },
        { "is_canceled", reinterpret_cast<getter>(CoreTextTextUpdatingEventArgs_get_IsCanceled), nullptr, nullptr, nullptr },
        { "new_selection", reinterpret_cast<getter>(CoreTextTextUpdatingEventArgs_get_NewSelection), nullptr, nullptr, nullptr },
        { "range", reinterpret_cast<getter>(CoreTextTextUpdatingEventArgs_get_Range), nullptr, nullptr, nullptr },
        { "text", reinterpret_cast<getter>(CoreTextTextUpdatingEventArgs_get_Text), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_CoreTextTextUpdatingEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_CoreTextTextUpdatingEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CoreTextTextUpdatingEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CoreTextTextUpdatingEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CoreTextTextUpdatingEventArgs) },
        { }};

    static PyType_Spec type_spec_CoreTextTextUpdatingEventArgs = {
        "winrt._winrt_windows_ui_text_core.CoreTextTextUpdatingEventArgs",
        sizeof(py::wrapper::Windows::UI::Text::Core::CoreTextTextUpdatingEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CoreTextTextUpdatingEventArgs};

    // ----- CoreTextRange struct --------------------

    winrt::Windows::UI::Text::Core::CoreTextRange CoreTextRange_from_tuple(PyObject* tuple)
    {
        if (PyTuple_GET_SIZE(tuple) != 2)
        {
            PyErr_SetString(PyExc_TypeError, "Incorrect number of fields");
            throw python_exception();
        }

        winrt::Windows::UI::Text::Core::CoreTextRange result{};

        result.StartCaretPosition = py::convert_to<int32_t>(tuple, 0);
        result.EndCaretPosition = py::convert_to<int32_t>(tuple, 1);

        return result;
    }

    PyObject* _new_CoreTextRange(PyTypeObject* subclass, PyObject* args, PyObject* kwds) noexcept
    {
        pyobj_handle self_obj{(subclass->tp_alloc(subclass, 0))};
        if (!self_obj)
        {
            return nullptr;
        }

        auto self = reinterpret_cast<winrt_struct_wrapper<winrt::Windows::UI::Text::Core::CoreTextRange>*>(self_obj.get());
        std::construct_at(&self->obj);

        auto tuple_size = PyTuple_GET_SIZE(args);
        if ((tuple_size == 0) && (!kwds))
        {
            return self_obj.detach();
        }

        int32_t _StartCaretPosition{};
        int32_t _EndCaretPosition{};

        static const char* kwlist[] = {"start_caret_position", "end_caret_position", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "|ii", const_cast<char**>(kwlist), &_StartCaretPosition, &_EndCaretPosition))
        {
            return nullptr;
        }

        try
        {
            self->obj.StartCaretPosition = _StartCaretPosition;
            self->obj.EndCaretPosition = _EndCaretPosition;

            return self_obj.detach();
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static void _dealloc_CoreTextRange(py::wrapper::Windows::UI::Text::Core::CoreTextRange* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_CoreTextRange(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Text::Core::CoreTextRange>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    PyObject* _replace_CoreTextRange(py::wrapper::Windows::UI::Text::Core::CoreTextRange* self, PyObject* args, PyObject* kwds) noexcept
    {
        try
        {
            int32_t _StartCaretPosition{self->obj.StartCaretPosition};
            int32_t _EndCaretPosition{self->obj.EndCaretPosition};

            static const char* kwlist[] = {"start_caret_position", "end_caret_position", nullptr};
            if (!PyArg_ParseTupleAndKeywords(args, kwds, "|$ii", const_cast<char**>(kwlist), &_StartCaretPosition, &_EndCaretPosition))
            {
                return nullptr;
            }

            auto copy = self->obj;
            copy.StartCaretPosition = _StartCaretPosition;
            copy.EndCaretPosition = _EndCaretPosition;

            return convert(copy);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    PyObject* unpack_CoreTextRange(py::wrapper::Windows::UI::Text::Core::CoreTextRange* self, PyObject* /*unused*/) noexcept
    {
        py::pyobj_handle StartCaretPosition{convert(self->obj.StartCaretPosition)};
        if (!StartCaretPosition)
        {
            return nullptr;
        }

        py::pyobj_handle EndCaretPosition{convert(self->obj.EndCaretPosition)};
        if (!EndCaretPosition)
        {
            return nullptr;
        }

        pyobj_handle tuple{PyTuple_New(2)};
        if (!tuple)
        {
            return nullptr;
        }

        PyTuple_SET_ITEM(tuple.get(), 0, StartCaretPosition.detach());
        PyTuple_SET_ITEM(tuple.get(), 1, EndCaretPosition.detach());

        return tuple.detach();
    }

    static PyMethodDef _methods_CoreTextRange[] = {
        { "_assign_array_", _assign_array_CoreTextRange, METH_O | METH_STATIC, nullptr },
        { "__replace__", reinterpret_cast<PyCFunction>(reinterpret_cast<void*>(_replace_CoreTextRange)), METH_VARARGS | METH_KEYWORDS, nullptr },
        { "unpack", reinterpret_cast<PyCFunction>(unpack_CoreTextRange), METH_NOARGS, nullptr },
        { }};

    static PyObject* CoreTextRange_get_StartCaretPosition(py::wrapper::Windows::UI::Text::Core::CoreTextRange* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.StartCaretPosition);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreTextRange_get_EndCaretPosition(py::wrapper::Windows::UI::Text::Core::CoreTextRange* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.EndCaretPosition);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyGetSetDef _getset_CoreTextRange[] = {
        { "start_caret_position", reinterpret_cast<getter>(CoreTextRange_get_StartCaretPosition), nullptr, nullptr, nullptr },
        { "end_caret_position", reinterpret_cast<getter>(CoreTextRange_get_EndCaretPosition), nullptr, nullptr, nullptr },
        { }};

    static PyObject* _richcompare_CoreTextRange(py::wrapper::Windows::UI::Text::Core::CoreTextRange* self, PyObject* other, int op) noexcept
    {
        try
        {
            auto _other = py::convert_to<winrt::Windows::UI::Text::Core::CoreTextRange>(other);

            if (op == Py_EQ)
            {
                if (self->obj == _other)
                {
                    Py_RETURN_TRUE;
                }

                Py_RETURN_FALSE;
            }

            if (op == Py_NE)
            {
                if (self->obj != _other)
                {
                    Py_RETURN_TRUE;
                }

                Py_RETURN_FALSE;
            }

            Py_RETURN_NOTIMPLEMENTED;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _repr_CoreTextRange(PyObject* self) noexcept
    {
        py::pyobj_handle StartCaretPosition{PyObject_GetAttrString(self, "start_caret_position")};
        if (!StartCaretPosition)
        {
            return nullptr;
        }

        py::pyobj_handle EndCaretPosition{PyObject_GetAttrString(self, "end_caret_position")};
        if (!EndCaretPosition)
        {
            return nullptr;
        }

        return PyUnicode_FromFormat("CoreTextRange(start_caret_position=%R, end_caret_position=%R)", StartCaretPosition.get(), EndCaretPosition.get());
    }

    static PyType_Slot _type_slots_CoreTextRange[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_CoreTextRange) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CoreTextRange) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CoreTextRange) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CoreTextRange) },
        { Py_tp_richcompare, reinterpret_cast<void*>(_richcompare_CoreTextRange) },
        { Py_tp_repr, reinterpret_cast<void*>(_repr_CoreTextRange) },
        { }};

    static PyType_Spec type_spec_CoreTextRange = {
        "winrt._winrt_windows_ui_text_core.CoreTextRange",
        sizeof(py::wrapper::Windows::UI::Text::Core::CoreTextRange),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CoreTextRange};

    // ----- Windows.UI.Text.Core Initialization --------------------

    PyDoc_STRVAR(module_doc, "Windows.UI.Text.Core");

    static PyModuleDef module_def = {
        PyModuleDef_HEAD_INIT,
        "_winrt_windows_ui_text_core",
        module_doc,
        0,
        nullptr,
        nullptr,
        nullptr,
        nullptr,
        nullptr};
} // py::cpp::Windows::UI::Text::Core

PyMODINIT_FUNC PyInit__winrt_windows_ui_text_core(void) noexcept
{
    using namespace py::cpp::Windows::UI::Text::Core;

    if (py::import_winrt_runtime() == -1)
    {
        return nullptr;
    }

    py::pyobj_handle module{PyModule_Create(&module_def)};

    if (!module)
    {
        return nullptr;
    }

    auto inspectable_meta_type = py::get_inspectable_meta_type();
    if (!inspectable_meta_type)
    {
        return nullptr;
    }

    auto object_type = py::get_object_type();
    if (!object_type)
    {
        return nullptr;
    }

    py::pyobj_handle object_bases{PyTuple_Pack(1, object_type)};

    if (!object_bases)
    {
        return nullptr;
    }

    py::pytype_handle CoreTextCompositionCompletedEventArgs_type{py::register_python_type(module.get(), &type_spec_CoreTextCompositionCompletedEventArgs, object_bases.get(), inspectable_meta_type)};
    if (!CoreTextCompositionCompletedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle CoreTextCompositionSegment_type{py::register_python_type(module.get(), &type_spec_CoreTextCompositionSegment, object_bases.get(), inspectable_meta_type)};
    if (!CoreTextCompositionSegment_type)
    {
        return nullptr;
    }

    py::pytype_handle CoreTextCompositionStartedEventArgs_type{py::register_python_type(module.get(), &type_spec_CoreTextCompositionStartedEventArgs, object_bases.get(), inspectable_meta_type)};
    if (!CoreTextCompositionStartedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle CoreTextEditContext_type{py::register_python_type(module.get(), &type_spec_CoreTextEditContext, object_bases.get(), inspectable_meta_type)};
    if (!CoreTextEditContext_type)
    {
        return nullptr;
    }

    py::pytype_handle CoreTextFormatUpdatingEventArgs_type{py::register_python_type(module.get(), &type_spec_CoreTextFormatUpdatingEventArgs, object_bases.get(), inspectable_meta_type)};
    if (!CoreTextFormatUpdatingEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle CoreTextLayoutBounds_type{py::register_python_type(module.get(), &type_spec_CoreTextLayoutBounds, object_bases.get(), inspectable_meta_type)};
    if (!CoreTextLayoutBounds_type)
    {
        return nullptr;
    }

    py::pytype_handle CoreTextLayoutRequest_type{py::register_python_type(module.get(), &type_spec_CoreTextLayoutRequest, object_bases.get(), inspectable_meta_type)};
    if (!CoreTextLayoutRequest_type)
    {
        return nullptr;
    }

    py::pytype_handle CoreTextLayoutRequestedEventArgs_type{py::register_python_type(module.get(), &type_spec_CoreTextLayoutRequestedEventArgs, object_bases.get(), inspectable_meta_type)};
    if (!CoreTextLayoutRequestedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle CoreTextSelectionRequest_type{py::register_python_type(module.get(), &type_spec_CoreTextSelectionRequest, object_bases.get(), inspectable_meta_type)};
    if (!CoreTextSelectionRequest_type)
    {
        return nullptr;
    }

    py::pytype_handle CoreTextSelectionRequestedEventArgs_type{py::register_python_type(module.get(), &type_spec_CoreTextSelectionRequestedEventArgs, object_bases.get(), inspectable_meta_type)};
    if (!CoreTextSelectionRequestedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle CoreTextSelectionUpdatingEventArgs_type{py::register_python_type(module.get(), &type_spec_CoreTextSelectionUpdatingEventArgs, object_bases.get(), inspectable_meta_type)};
    if (!CoreTextSelectionUpdatingEventArgs_type)
    {
        return nullptr;
    }

    py::pyobj_handle CoreTextServicesConstants_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(inspectable_meta_type))};
    if (!CoreTextServicesConstants_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_CoreTextServicesConstants_Static{PyType_FromSpecWithBases(&type_spec_CoreTextServicesConstants_Static, CoreTextServicesConstants_Static_bases.get())};
    if (!type_CoreTextServicesConstants_Static)
    {
        return nullptr;
    }

    py::pytype_handle CoreTextServicesConstants_type{py::register_python_type(module.get(), &type_spec_CoreTextServicesConstants, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_CoreTextServicesConstants_Static.get()))};
    if (!CoreTextServicesConstants_type)
    {
        return nullptr;
    }

    py::pyobj_handle CoreTextServicesManager_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(inspectable_meta_type))};
    if (!CoreTextServicesManager_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_CoreTextServicesManager_Static{PyType_FromSpecWithBases(&type_spec_CoreTextServicesManager_Static, CoreTextServicesManager_Static_bases.get())};
    if (!type_CoreTextServicesManager_Static)
    {
        return nullptr;
    }

    py::pytype_handle CoreTextServicesManager_type{py::register_python_type(module.get(), &type_spec_CoreTextServicesManager, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_CoreTextServicesManager_Static.get()))};
    if (!CoreTextServicesManager_type)
    {
        return nullptr;
    }

    py::pytype_handle CoreTextTextRequest_type{py::register_python_type(module.get(), &type_spec_CoreTextTextRequest, object_bases.get(), inspectable_meta_type)};
    if (!CoreTextTextRequest_type)
    {
        return nullptr;
    }

    py::pytype_handle CoreTextTextRequestedEventArgs_type{py::register_python_type(module.get(), &type_spec_CoreTextTextRequestedEventArgs, object_bases.get(), inspectable_meta_type)};
    if (!CoreTextTextRequestedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle CoreTextTextUpdatingEventArgs_type{py::register_python_type(module.get(), &type_spec_CoreTextTextUpdatingEventArgs, object_bases.get(), inspectable_meta_type)};
    if (!CoreTextTextUpdatingEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle CoreTextRange_type{py::register_python_type(module.get(), &type_spec_CoreTextRange, nullptr, nullptr)};
    if (!CoreTextRange_type)
    {
        return nullptr;
    }

    py::pyobj_handle CoreTextRange_from_tuple_capsule{PyCapsule_New(reinterpret_cast<void*>(CoreTextRange_from_tuple),"winrt._winrt_windows_ui_text_core.CoreTextRange_from_tuple", nullptr)};
    if (!CoreTextRange_from_tuple_capsule)
    {
        return nullptr;
    }

    if (PyModule_AddObjectRef(module.get(), "CoreTextRange_from_tuple", CoreTextRange_from_tuple_capsule.get()) == -1)
    {
        return nullptr;
    }

    return module.detach();
}
