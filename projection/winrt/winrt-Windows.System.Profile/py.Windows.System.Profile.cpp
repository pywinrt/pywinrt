// WARNING: Please don't edit this file. It was generated by Python/WinRT v3.0.0

#include "py.Windows.System.Profile.h"

namespace py::cpp::Windows::System::Profile
{
    // ----- AnalyticsInfo class --------------------

    static PyObject* _new_AnalyticsInfo(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::System::Profile::AnalyticsInfo>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::System::Profile::AnalyticsInfo>::type_name);
        return nullptr;
    }

    static PyObject* AnalyticsInfo_GetSystemPropertiesAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.Profile.AnalyticsInfo", L"GetSystemPropertiesAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::System::Profile::AnalyticsInfo::GetSystemPropertiesAsync(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AnalyticsInfo_get_DeviceForm(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.Profile.AnalyticsInfo", L"DeviceForm");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::System::Profile::AnalyticsInfo::DeviceForm();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AnalyticsInfo_get_VersionInfo(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.Profile.AnalyticsInfo", L"VersionInfo");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::System::Profile::AnalyticsInfo::VersionInfo();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AnalyticsInfo[] = {
        { }};

    static PyGetSetDef _getset_AnalyticsInfo[] = {
        { }};

    static PyType_Slot _type_slots_AnalyticsInfo[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_AnalyticsInfo) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AnalyticsInfo) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AnalyticsInfo) },
        { }};

    static PyType_Spec type_spec_AnalyticsInfo = {
        "winrt._winrt_windows_system_profile.AnalyticsInfo",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AnalyticsInfo};

    static PyGetSetDef getset_AnalyticsInfo_Static[] = {
        { "device_form", reinterpret_cast<getter>(AnalyticsInfo_get_DeviceForm), nullptr, nullptr, nullptr },
        { "version_info", reinterpret_cast<getter>(AnalyticsInfo_get_VersionInfo), nullptr, nullptr, nullptr },
        { }};

    static PyMethodDef methods_AnalyticsInfo_Static[] = {
        { "get_system_properties_async", reinterpret_cast<PyCFunction>(AnalyticsInfo_GetSystemPropertiesAsync), METH_VARARGS, nullptr },
        { }};

    static PyType_Slot type_slots_AnalyticsInfo_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_AnalyticsInfo_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_AnalyticsInfo_Static) },
        { }
    };

    static PyType_Spec type_spec_AnalyticsInfo_Static = {
        "winrt._winrt_windows_system_profile.AnalyticsInfo_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_AnalyticsInfo_Static};

    // ----- AnalyticsVersionInfo class --------------------

    static PyObject* _new_AnalyticsVersionInfo(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::System::Profile::AnalyticsVersionInfo>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::System::Profile::AnalyticsVersionInfo>::type_name);
        return nullptr;
    }

    static void _dealloc_AnalyticsVersionInfo(py::wrapper::Windows::System::Profile::AnalyticsVersionInfo* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AnalyticsVersionInfo_get_DeviceFamily(py::wrapper::Windows::System::Profile::AnalyticsVersionInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.Profile.AnalyticsVersionInfo", L"DeviceFamily");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.DeviceFamily();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AnalyticsVersionInfo_get_DeviceFamilyVersion(py::wrapper::Windows::System::Profile::AnalyticsVersionInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.Profile.AnalyticsVersionInfo", L"DeviceFamilyVersion");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.DeviceFamilyVersion();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AnalyticsVersionInfo_get_ProductName(py::wrapper::Windows::System::Profile::AnalyticsVersionInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.Profile.AnalyticsVersionInfo", L"ProductName");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ProductName();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AnalyticsVersionInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::System::Profile::AnalyticsVersionInfo>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AnalyticsVersionInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::Profile::AnalyticsVersionInfo>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AnalyticsVersionInfo[] = {
        { "_assign_array_", _assign_array_AnalyticsVersionInfo, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AnalyticsVersionInfo), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_AnalyticsVersionInfo[] = {
        { "device_family", reinterpret_cast<getter>(AnalyticsVersionInfo_get_DeviceFamily), nullptr, nullptr, nullptr },
        { "device_family_version", reinterpret_cast<getter>(AnalyticsVersionInfo_get_DeviceFamilyVersion), nullptr, nullptr, nullptr },
        { "product_name", reinterpret_cast<getter>(AnalyticsVersionInfo_get_ProductName), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_AnalyticsVersionInfo[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_AnalyticsVersionInfo) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AnalyticsVersionInfo) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AnalyticsVersionInfo) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AnalyticsVersionInfo) },
        { }};

    static PyType_Spec type_spec_AnalyticsVersionInfo = {
        "winrt._winrt_windows_system_profile.AnalyticsVersionInfo",
        sizeof(py::wrapper::Windows::System::Profile::AnalyticsVersionInfo),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AnalyticsVersionInfo};

    // ----- AppApplicability class --------------------

    static PyObject* _new_AppApplicability(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::System::Profile::AppApplicability>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::System::Profile::AppApplicability>::type_name);
        return nullptr;
    }

    static PyObject* AppApplicability_GetUnsupportedAppRequirements(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.Profile.AppApplicability", L"GetUnsupportedAppRequirements", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::System::Profile::AppApplicability::GetUnsupportedAppRequirements(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyMethodDef _methods_AppApplicability[] = {
        { }};

    static PyGetSetDef _getset_AppApplicability[] = {
        { }};

    static PyType_Slot _type_slots_AppApplicability[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_AppApplicability) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AppApplicability) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AppApplicability) },
        { }};

    static PyType_Spec type_spec_AppApplicability = {
        "winrt._winrt_windows_system_profile.AppApplicability",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AppApplicability};

    static PyGetSetDef getset_AppApplicability_Static[] = {
        { }};

    static PyMethodDef methods_AppApplicability_Static[] = {
        { "get_unsupported_app_requirements", reinterpret_cast<PyCFunction>(AppApplicability_GetUnsupportedAppRequirements), METH_VARARGS, nullptr },
        { }};

    static PyType_Slot type_slots_AppApplicability_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_AppApplicability_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_AppApplicability_Static) },
        { }
    };

    static PyType_Spec type_spec_AppApplicability_Static = {
        "winrt._winrt_windows_system_profile.AppApplicability_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_AppApplicability_Static};

    // ----- EducationSettings class --------------------

    static PyObject* _new_EducationSettings(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::System::Profile::EducationSettings>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::System::Profile::EducationSettings>::type_name);
        return nullptr;
    }

    static PyObject* EducationSettings_get_IsEducationEnvironment(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.Profile.EducationSettings", L"IsEducationEnvironment");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::System::Profile::EducationSettings::IsEducationEnvironment();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_EducationSettings[] = {
        { }};

    static PyGetSetDef _getset_EducationSettings[] = {
        { }};

    static PyType_Slot _type_slots_EducationSettings[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_EducationSettings) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_EducationSettings) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_EducationSettings) },
        { }};

    static PyType_Spec type_spec_EducationSettings = {
        "winrt._winrt_windows_system_profile.EducationSettings",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_EducationSettings};

    static PyGetSetDef getset_EducationSettings_Static[] = {
        { "is_education_environment", reinterpret_cast<getter>(EducationSettings_get_IsEducationEnvironment), nullptr, nullptr, nullptr },
        { }};

    static PyMethodDef methods_EducationSettings_Static[] = {
        { }};

    static PyType_Slot type_slots_EducationSettings_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_EducationSettings_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_EducationSettings_Static) },
        { }
    };

    static PyType_Spec type_spec_EducationSettings_Static = {
        "winrt._winrt_windows_system_profile.EducationSettings_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_EducationSettings_Static};

    // ----- HardwareIdentification class --------------------

    static PyObject* _new_HardwareIdentification(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::System::Profile::HardwareIdentification>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::System::Profile::HardwareIdentification>::type_name);
        return nullptr;
    }

    static PyObject* HardwareIdentification_GetPackageSpecificToken(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.Profile.HardwareIdentification", L"GetPackageSpecificToken", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::System::Profile::HardwareIdentification::GetPackageSpecificToken(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyMethodDef _methods_HardwareIdentification[] = {
        { }};

    static PyGetSetDef _getset_HardwareIdentification[] = {
        { }};

    static PyType_Slot _type_slots_HardwareIdentification[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_HardwareIdentification) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_HardwareIdentification) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_HardwareIdentification) },
        { }};

    static PyType_Spec type_spec_HardwareIdentification = {
        "winrt._winrt_windows_system_profile.HardwareIdentification",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_HardwareIdentification};

    static PyGetSetDef getset_HardwareIdentification_Static[] = {
        { }};

    static PyMethodDef methods_HardwareIdentification_Static[] = {
        { "get_package_specific_token", reinterpret_cast<PyCFunction>(HardwareIdentification_GetPackageSpecificToken), METH_VARARGS, nullptr },
        { }};

    static PyType_Slot type_slots_HardwareIdentification_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_HardwareIdentification_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_HardwareIdentification_Static) },
        { }
    };

    static PyType_Spec type_spec_HardwareIdentification_Static = {
        "winrt._winrt_windows_system_profile.HardwareIdentification_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_HardwareIdentification_Static};

    // ----- HardwareToken class --------------------

    static PyObject* _new_HardwareToken(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::System::Profile::HardwareToken>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::System::Profile::HardwareToken>::type_name);
        return nullptr;
    }

    static void _dealloc_HardwareToken(py::wrapper::Windows::System::Profile::HardwareToken* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* HardwareToken_get_Certificate(py::wrapper::Windows::System::Profile::HardwareToken* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.Profile.HardwareToken", L"Certificate");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Certificate();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HardwareToken_get_Id(py::wrapper::Windows::System::Profile::HardwareToken* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.Profile.HardwareToken", L"Id");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Id();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HardwareToken_get_Signature(py::wrapper::Windows::System::Profile::HardwareToken* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.Profile.HardwareToken", L"Signature");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Signature();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_HardwareToken(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::System::Profile::HardwareToken>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_HardwareToken(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::Profile::HardwareToken>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_HardwareToken[] = {
        { "_assign_array_", _assign_array_HardwareToken, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_HardwareToken), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_HardwareToken[] = {
        { "certificate", reinterpret_cast<getter>(HardwareToken_get_Certificate), nullptr, nullptr, nullptr },
        { "id", reinterpret_cast<getter>(HardwareToken_get_Id), nullptr, nullptr, nullptr },
        { "signature", reinterpret_cast<getter>(HardwareToken_get_Signature), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_HardwareToken[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_HardwareToken) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_HardwareToken) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_HardwareToken) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_HardwareToken) },
        { }};

    static PyType_Spec type_spec_HardwareToken = {
        "winrt._winrt_windows_system_profile.HardwareToken",
        sizeof(py::wrapper::Windows::System::Profile::HardwareToken),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_HardwareToken};

    // ----- KnownRetailInfoProperties class --------------------

    static PyObject* _new_KnownRetailInfoProperties(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::System::Profile::KnownRetailInfoProperties>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::System::Profile::KnownRetailInfoProperties>::type_name);
        return nullptr;
    }

    static PyObject* KnownRetailInfoProperties_get_BatteryLifeDescription(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.Profile.KnownRetailInfoProperties", L"BatteryLifeDescription");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::System::Profile::KnownRetailInfoProperties::BatteryLifeDescription();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownRetailInfoProperties_get_DisplayDescription(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.Profile.KnownRetailInfoProperties", L"DisplayDescription");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::System::Profile::KnownRetailInfoProperties::DisplayDescription();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownRetailInfoProperties_get_DisplayModelName(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.Profile.KnownRetailInfoProperties", L"DisplayModelName");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::System::Profile::KnownRetailInfoProperties::DisplayModelName();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownRetailInfoProperties_get_FormFactor(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.Profile.KnownRetailInfoProperties", L"FormFactor");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::System::Profile::KnownRetailInfoProperties::FormFactor();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownRetailInfoProperties_get_FrontCameraDescription(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.Profile.KnownRetailInfoProperties", L"FrontCameraDescription");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::System::Profile::KnownRetailInfoProperties::FrontCameraDescription();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownRetailInfoProperties_get_GraphicsDescription(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.Profile.KnownRetailInfoProperties", L"GraphicsDescription");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::System::Profile::KnownRetailInfoProperties::GraphicsDescription();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownRetailInfoProperties_get_HasNfc(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.Profile.KnownRetailInfoProperties", L"HasNfc");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::System::Profile::KnownRetailInfoProperties::HasNfc();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownRetailInfoProperties_get_HasOpticalDrive(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.Profile.KnownRetailInfoProperties", L"HasOpticalDrive");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::System::Profile::KnownRetailInfoProperties::HasOpticalDrive();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownRetailInfoProperties_get_HasSdSlot(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.Profile.KnownRetailInfoProperties", L"HasSdSlot");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::System::Profile::KnownRetailInfoProperties::HasSdSlot();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownRetailInfoProperties_get_IsFeatured(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.Profile.KnownRetailInfoProperties", L"IsFeatured");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::System::Profile::KnownRetailInfoProperties::IsFeatured();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownRetailInfoProperties_get_IsOfficeInstalled(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.Profile.KnownRetailInfoProperties", L"IsOfficeInstalled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::System::Profile::KnownRetailInfoProperties::IsOfficeInstalled();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownRetailInfoProperties_get_ManufacturerName(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.Profile.KnownRetailInfoProperties", L"ManufacturerName");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::System::Profile::KnownRetailInfoProperties::ManufacturerName();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownRetailInfoProperties_get_Memory(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.Profile.KnownRetailInfoProperties", L"Memory");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::System::Profile::KnownRetailInfoProperties::Memory();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownRetailInfoProperties_get_ModelName(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.Profile.KnownRetailInfoProperties", L"ModelName");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::System::Profile::KnownRetailInfoProperties::ModelName();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownRetailInfoProperties_get_Price(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.Profile.KnownRetailInfoProperties", L"Price");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::System::Profile::KnownRetailInfoProperties::Price();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownRetailInfoProperties_get_ProcessorDescription(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.Profile.KnownRetailInfoProperties", L"ProcessorDescription");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::System::Profile::KnownRetailInfoProperties::ProcessorDescription();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownRetailInfoProperties_get_RearCameraDescription(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.Profile.KnownRetailInfoProperties", L"RearCameraDescription");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::System::Profile::KnownRetailInfoProperties::RearCameraDescription();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownRetailInfoProperties_get_RetailAccessCode(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.Profile.KnownRetailInfoProperties", L"RetailAccessCode");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::System::Profile::KnownRetailInfoProperties::RetailAccessCode();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownRetailInfoProperties_get_ScreenSize(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.Profile.KnownRetailInfoProperties", L"ScreenSize");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::System::Profile::KnownRetailInfoProperties::ScreenSize();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownRetailInfoProperties_get_StorageDescription(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.Profile.KnownRetailInfoProperties", L"StorageDescription");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::System::Profile::KnownRetailInfoProperties::StorageDescription();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownRetailInfoProperties_get_Weight(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.Profile.KnownRetailInfoProperties", L"Weight");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::System::Profile::KnownRetailInfoProperties::Weight();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownRetailInfoProperties_get_WindowsEdition(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.Profile.KnownRetailInfoProperties", L"WindowsEdition");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::System::Profile::KnownRetailInfoProperties::WindowsEdition();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_KnownRetailInfoProperties[] = {
        { }};

    static PyGetSetDef _getset_KnownRetailInfoProperties[] = {
        { }};

    static PyType_Slot _type_slots_KnownRetailInfoProperties[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_KnownRetailInfoProperties) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_KnownRetailInfoProperties) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_KnownRetailInfoProperties) },
        { }};

    static PyType_Spec type_spec_KnownRetailInfoProperties = {
        "winrt._winrt_windows_system_profile.KnownRetailInfoProperties",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_KnownRetailInfoProperties};

    static PyGetSetDef getset_KnownRetailInfoProperties_Static[] = {
        { "battery_life_description", reinterpret_cast<getter>(KnownRetailInfoProperties_get_BatteryLifeDescription), nullptr, nullptr, nullptr },
        { "display_description", reinterpret_cast<getter>(KnownRetailInfoProperties_get_DisplayDescription), nullptr, nullptr, nullptr },
        { "display_model_name", reinterpret_cast<getter>(KnownRetailInfoProperties_get_DisplayModelName), nullptr, nullptr, nullptr },
        { "form_factor", reinterpret_cast<getter>(KnownRetailInfoProperties_get_FormFactor), nullptr, nullptr, nullptr },
        { "front_camera_description", reinterpret_cast<getter>(KnownRetailInfoProperties_get_FrontCameraDescription), nullptr, nullptr, nullptr },
        { "graphics_description", reinterpret_cast<getter>(KnownRetailInfoProperties_get_GraphicsDescription), nullptr, nullptr, nullptr },
        { "has_nfc", reinterpret_cast<getter>(KnownRetailInfoProperties_get_HasNfc), nullptr, nullptr, nullptr },
        { "has_optical_drive", reinterpret_cast<getter>(KnownRetailInfoProperties_get_HasOpticalDrive), nullptr, nullptr, nullptr },
        { "has_sd_slot", reinterpret_cast<getter>(KnownRetailInfoProperties_get_HasSdSlot), nullptr, nullptr, nullptr },
        { "is_featured", reinterpret_cast<getter>(KnownRetailInfoProperties_get_IsFeatured), nullptr, nullptr, nullptr },
        { "is_office_installed", reinterpret_cast<getter>(KnownRetailInfoProperties_get_IsOfficeInstalled), nullptr, nullptr, nullptr },
        { "manufacturer_name", reinterpret_cast<getter>(KnownRetailInfoProperties_get_ManufacturerName), nullptr, nullptr, nullptr },
        { "memory", reinterpret_cast<getter>(KnownRetailInfoProperties_get_Memory), nullptr, nullptr, nullptr },
        { "model_name", reinterpret_cast<getter>(KnownRetailInfoProperties_get_ModelName), nullptr, nullptr, nullptr },
        { "price", reinterpret_cast<getter>(KnownRetailInfoProperties_get_Price), nullptr, nullptr, nullptr },
        { "processor_description", reinterpret_cast<getter>(KnownRetailInfoProperties_get_ProcessorDescription), nullptr, nullptr, nullptr },
        { "rear_camera_description", reinterpret_cast<getter>(KnownRetailInfoProperties_get_RearCameraDescription), nullptr, nullptr, nullptr },
        { "retail_access_code", reinterpret_cast<getter>(KnownRetailInfoProperties_get_RetailAccessCode), nullptr, nullptr, nullptr },
        { "screen_size", reinterpret_cast<getter>(KnownRetailInfoProperties_get_ScreenSize), nullptr, nullptr, nullptr },
        { "storage_description", reinterpret_cast<getter>(KnownRetailInfoProperties_get_StorageDescription), nullptr, nullptr, nullptr },
        { "weight", reinterpret_cast<getter>(KnownRetailInfoProperties_get_Weight), nullptr, nullptr, nullptr },
        { "windows_edition", reinterpret_cast<getter>(KnownRetailInfoProperties_get_WindowsEdition), nullptr, nullptr, nullptr },
        { }};

    static PyMethodDef methods_KnownRetailInfoProperties_Static[] = {
        { }};

    static PyType_Slot type_slots_KnownRetailInfoProperties_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_KnownRetailInfoProperties_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_KnownRetailInfoProperties_Static) },
        { }
    };

    static PyType_Spec type_spec_KnownRetailInfoProperties_Static = {
        "winrt._winrt_windows_system_profile.KnownRetailInfoProperties_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_KnownRetailInfoProperties_Static};

    // ----- PlatformAutomaticAppSignInManager class --------------------

    static PyObject* _new_PlatformAutomaticAppSignInManager(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::System::Profile::PlatformAutomaticAppSignInManager>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::System::Profile::PlatformAutomaticAppSignInManager>::type_name);
        return nullptr;
    }

    static PyObject* PlatformAutomaticAppSignInManager_get_Policy(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.Profile.PlatformAutomaticAppSignInManager", L"Policy");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::System::Profile::PlatformAutomaticAppSignInManager::Policy();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PlatformAutomaticAppSignInManager[] = {
        { }};

    static PyGetSetDef _getset_PlatformAutomaticAppSignInManager[] = {
        { }};

    static PyType_Slot _type_slots_PlatformAutomaticAppSignInManager[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PlatformAutomaticAppSignInManager) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PlatformAutomaticAppSignInManager) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PlatformAutomaticAppSignInManager) },
        { }};

    static PyType_Spec type_spec_PlatformAutomaticAppSignInManager = {
        "winrt._winrt_windows_system_profile.PlatformAutomaticAppSignInManager",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PlatformAutomaticAppSignInManager};

    static PyGetSetDef getset_PlatformAutomaticAppSignInManager_Static[] = {
        { "policy", reinterpret_cast<getter>(PlatformAutomaticAppSignInManager_get_Policy), nullptr, nullptr, nullptr },
        { }};

    static PyMethodDef methods_PlatformAutomaticAppSignInManager_Static[] = {
        { }};

    static PyType_Slot type_slots_PlatformAutomaticAppSignInManager_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_PlatformAutomaticAppSignInManager_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_PlatformAutomaticAppSignInManager_Static) },
        { }
    };

    static PyType_Spec type_spec_PlatformAutomaticAppSignInManager_Static = {
        "winrt._winrt_windows_system_profile.PlatformAutomaticAppSignInManager_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_PlatformAutomaticAppSignInManager_Static};

    // ----- PlatformDiagnosticsAndUsageDataSettings class --------------------

    static PyObject* _new_PlatformDiagnosticsAndUsageDataSettings(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::System::Profile::PlatformDiagnosticsAndUsageDataSettings>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::System::Profile::PlatformDiagnosticsAndUsageDataSettings>::type_name);
        return nullptr;
    }

    static PyObject* PlatformDiagnosticsAndUsageDataSettings_CanCollectDiagnostics(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.Profile.PlatformDiagnosticsAndUsageDataSettings", L"CanCollectDiagnostics", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::System::Profile::PlatformDataCollectionLevel>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::System::Profile::PlatformDiagnosticsAndUsageDataSettings::CanCollectDiagnostics(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PlatformDiagnosticsAndUsageDataSettings_get_CollectionLevel(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.Profile.PlatformDiagnosticsAndUsageDataSettings", L"CollectionLevel");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::System::Profile::PlatformDiagnosticsAndUsageDataSettings::CollectionLevel();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlatformDiagnosticsAndUsageDataSettings_add_CollectionLevelChanged(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.System.Profile.PlatformDiagnosticsAndUsageDataSettings", L"CollectionLevelChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::EventHandler<winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::System::Profile::PlatformDiagnosticsAndUsageDataSettings::CollectionLevelChanged(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlatformDiagnosticsAndUsageDataSettings_remove_CollectionLevelChanged(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.System.Profile.PlatformDiagnosticsAndUsageDataSettings", L"CollectionLevelChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                winrt::Windows::System::Profile::PlatformDiagnosticsAndUsageDataSettings::CollectionLevelChanged(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PlatformDiagnosticsAndUsageDataSettings[] = {
        { }};

    static PyGetSetDef _getset_PlatformDiagnosticsAndUsageDataSettings[] = {
        { }};

    static PyType_Slot _type_slots_PlatformDiagnosticsAndUsageDataSettings[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PlatformDiagnosticsAndUsageDataSettings) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PlatformDiagnosticsAndUsageDataSettings) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PlatformDiagnosticsAndUsageDataSettings) },
        { }};

    static PyType_Spec type_spec_PlatformDiagnosticsAndUsageDataSettings = {
        "winrt._winrt_windows_system_profile.PlatformDiagnosticsAndUsageDataSettings",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PlatformDiagnosticsAndUsageDataSettings};

    static PyGetSetDef getset_PlatformDiagnosticsAndUsageDataSettings_Static[] = {
        { "collection_level", reinterpret_cast<getter>(PlatformDiagnosticsAndUsageDataSettings_get_CollectionLevel), nullptr, nullptr, nullptr },
        { }};

    static PyMethodDef methods_PlatformDiagnosticsAndUsageDataSettings_Static[] = {
        { "can_collect_diagnostics", reinterpret_cast<PyCFunction>(PlatformDiagnosticsAndUsageDataSettings_CanCollectDiagnostics), METH_VARARGS, nullptr },
        { "add_collection_level_changed", reinterpret_cast<PyCFunction>(PlatformDiagnosticsAndUsageDataSettings_add_CollectionLevelChanged), METH_O, nullptr },
        { "remove_collection_level_changed", reinterpret_cast<PyCFunction>(PlatformDiagnosticsAndUsageDataSettings_remove_CollectionLevelChanged), METH_O, nullptr },
        { }};

    static PyType_Slot type_slots_PlatformDiagnosticsAndUsageDataSettings_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_PlatformDiagnosticsAndUsageDataSettings_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_PlatformDiagnosticsAndUsageDataSettings_Static) },
        { }
    };

    static PyType_Spec type_spec_PlatformDiagnosticsAndUsageDataSettings_Static = {
        "winrt._winrt_windows_system_profile.PlatformDiagnosticsAndUsageDataSettings_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_PlatformDiagnosticsAndUsageDataSettings_Static};

    // ----- RetailInfo class --------------------

    static PyObject* _new_RetailInfo(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::System::Profile::RetailInfo>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::System::Profile::RetailInfo>::type_name);
        return nullptr;
    }

    static PyObject* RetailInfo_get_IsDemoModeEnabled(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.Profile.RetailInfo", L"IsDemoModeEnabled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::System::Profile::RetailInfo::IsDemoModeEnabled();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RetailInfo_get_Properties(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.Profile.RetailInfo", L"Properties");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::System::Profile::RetailInfo::Properties();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RetailInfo[] = {
        { }};

    static PyGetSetDef _getset_RetailInfo[] = {
        { }};

    static PyType_Slot _type_slots_RetailInfo[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_RetailInfo) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_RetailInfo) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_RetailInfo) },
        { }};

    static PyType_Spec type_spec_RetailInfo = {
        "winrt._winrt_windows_system_profile.RetailInfo",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RetailInfo};

    static PyGetSetDef getset_RetailInfo_Static[] = {
        { "is_demo_mode_enabled", reinterpret_cast<getter>(RetailInfo_get_IsDemoModeEnabled), nullptr, nullptr, nullptr },
        { "properties", reinterpret_cast<getter>(RetailInfo_get_Properties), nullptr, nullptr, nullptr },
        { }};

    static PyMethodDef methods_RetailInfo_Static[] = {
        { }};

    static PyType_Slot type_slots_RetailInfo_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_RetailInfo_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_RetailInfo_Static) },
        { }
    };

    static PyType_Spec type_spec_RetailInfo_Static = {
        "winrt._winrt_windows_system_profile.RetailInfo_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_RetailInfo_Static};

    // ----- SharedModeSettings class --------------------

    static PyObject* _new_SharedModeSettings(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::System::Profile::SharedModeSettings>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::System::Profile::SharedModeSettings>::type_name);
        return nullptr;
    }

    static PyObject* SharedModeSettings_get_IsEnabled(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.Profile.SharedModeSettings", L"IsEnabled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::System::Profile::SharedModeSettings::IsEnabled();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SharedModeSettings_get_ShouldAvoidLocalStorage(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.Profile.SharedModeSettings", L"ShouldAvoidLocalStorage");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::System::Profile::SharedModeSettings::ShouldAvoidLocalStorage();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SharedModeSettings[] = {
        { }};

    static PyGetSetDef _getset_SharedModeSettings[] = {
        { }};

    static PyType_Slot _type_slots_SharedModeSettings[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_SharedModeSettings) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SharedModeSettings) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SharedModeSettings) },
        { }};

    static PyType_Spec type_spec_SharedModeSettings = {
        "winrt._winrt_windows_system_profile.SharedModeSettings",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SharedModeSettings};

    static PyGetSetDef getset_SharedModeSettings_Static[] = {
        { "is_enabled", reinterpret_cast<getter>(SharedModeSettings_get_IsEnabled), nullptr, nullptr, nullptr },
        { "should_avoid_local_storage", reinterpret_cast<getter>(SharedModeSettings_get_ShouldAvoidLocalStorage), nullptr, nullptr, nullptr },
        { }};

    static PyMethodDef methods_SharedModeSettings_Static[] = {
        { }};

    static PyType_Slot type_slots_SharedModeSettings_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_SharedModeSettings_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_SharedModeSettings_Static) },
        { }
    };

    static PyType_Spec type_spec_SharedModeSettings_Static = {
        "winrt._winrt_windows_system_profile.SharedModeSettings_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_SharedModeSettings_Static};

    // ----- SmartAppControlPolicy class --------------------

    static PyObject* _new_SmartAppControlPolicy(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::System::Profile::SmartAppControlPolicy>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::System::Profile::SmartAppControlPolicy>::type_name);
        return nullptr;
    }

    static PyObject* SmartAppControlPolicy_get_IsEnabled(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.Profile.SmartAppControlPolicy", L"IsEnabled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::System::Profile::SmartAppControlPolicy::IsEnabled();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmartAppControlPolicy_add_Changed(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.System.Profile.SmartAppControlPolicy", L"Changed");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::EventHandler<winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::System::Profile::SmartAppControlPolicy::Changed(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmartAppControlPolicy_remove_Changed(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.System.Profile.SmartAppControlPolicy", L"Changed");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                winrt::Windows::System::Profile::SmartAppControlPolicy::Changed(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SmartAppControlPolicy[] = {
        { }};

    static PyGetSetDef _getset_SmartAppControlPolicy[] = {
        { }};

    static PyType_Slot _type_slots_SmartAppControlPolicy[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_SmartAppControlPolicy) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SmartAppControlPolicy) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SmartAppControlPolicy) },
        { }};

    static PyType_Spec type_spec_SmartAppControlPolicy = {
        "winrt._winrt_windows_system_profile.SmartAppControlPolicy",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SmartAppControlPolicy};

    static PyGetSetDef getset_SmartAppControlPolicy_Static[] = {
        { "is_enabled", reinterpret_cast<getter>(SmartAppControlPolicy_get_IsEnabled), nullptr, nullptr, nullptr },
        { }};

    static PyMethodDef methods_SmartAppControlPolicy_Static[] = {
        { "add_changed", reinterpret_cast<PyCFunction>(SmartAppControlPolicy_add_Changed), METH_O, nullptr },
        { "remove_changed", reinterpret_cast<PyCFunction>(SmartAppControlPolicy_remove_Changed), METH_O, nullptr },
        { }};

    static PyType_Slot type_slots_SmartAppControlPolicy_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_SmartAppControlPolicy_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_SmartAppControlPolicy_Static) },
        { }
    };

    static PyType_Spec type_spec_SmartAppControlPolicy_Static = {
        "winrt._winrt_windows_system_profile.SmartAppControlPolicy_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_SmartAppControlPolicy_Static};

    // ----- SystemIdentification class --------------------

    static PyObject* _new_SystemIdentification(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::System::Profile::SystemIdentification>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::System::Profile::SystemIdentification>::type_name);
        return nullptr;
    }

    static PyObject* SystemIdentification_GetSystemIdForPublisher(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.Profile.SystemIdentification", L"GetSystemIdForPublisher", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::System::Profile::SystemIdentification::GetSystemIdForPublisher();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SystemIdentification_GetSystemIdForUser(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.Profile.SystemIdentification", L"GetSystemIdForUser", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::System::User>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::System::Profile::SystemIdentification::GetSystemIdForUser(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyMethodDef _methods_SystemIdentification[] = {
        { }};

    static PyGetSetDef _getset_SystemIdentification[] = {
        { }};

    static PyType_Slot _type_slots_SystemIdentification[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_SystemIdentification) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SystemIdentification) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SystemIdentification) },
        { }};

    static PyType_Spec type_spec_SystemIdentification = {
        "winrt._winrt_windows_system_profile.SystemIdentification",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SystemIdentification};

    static PyGetSetDef getset_SystemIdentification_Static[] = {
        { }};

    static PyMethodDef methods_SystemIdentification_Static[] = {
        { "get_system_id_for_publisher", reinterpret_cast<PyCFunction>(SystemIdentification_GetSystemIdForPublisher), METH_VARARGS, nullptr },
        { "get_system_id_for_user", reinterpret_cast<PyCFunction>(SystemIdentification_GetSystemIdForUser), METH_VARARGS, nullptr },
        { }};

    static PyType_Slot type_slots_SystemIdentification_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_SystemIdentification_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_SystemIdentification_Static) },
        { }
    };

    static PyType_Spec type_spec_SystemIdentification_Static = {
        "winrt._winrt_windows_system_profile.SystemIdentification_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_SystemIdentification_Static};

    // ----- SystemIdentificationInfo class --------------------

    static PyObject* _new_SystemIdentificationInfo(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::System::Profile::SystemIdentificationInfo>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::System::Profile::SystemIdentificationInfo>::type_name);
        return nullptr;
    }

    static void _dealloc_SystemIdentificationInfo(py::wrapper::Windows::System::Profile::SystemIdentificationInfo* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SystemIdentificationInfo_get_Id(py::wrapper::Windows::System::Profile::SystemIdentificationInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.Profile.SystemIdentificationInfo", L"Id");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Id();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemIdentificationInfo_get_Source(py::wrapper::Windows::System::Profile::SystemIdentificationInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.Profile.SystemIdentificationInfo", L"Source");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Source();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SystemIdentificationInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::System::Profile::SystemIdentificationInfo>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SystemIdentificationInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::Profile::SystemIdentificationInfo>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SystemIdentificationInfo[] = {
        { "_assign_array_", _assign_array_SystemIdentificationInfo, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SystemIdentificationInfo), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_SystemIdentificationInfo[] = {
        { "id", reinterpret_cast<getter>(SystemIdentificationInfo_get_Id), nullptr, nullptr, nullptr },
        { "source", reinterpret_cast<getter>(SystemIdentificationInfo_get_Source), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_SystemIdentificationInfo[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_SystemIdentificationInfo) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SystemIdentificationInfo) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SystemIdentificationInfo) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SystemIdentificationInfo) },
        { }};

    static PyType_Spec type_spec_SystemIdentificationInfo = {
        "winrt._winrt_windows_system_profile.SystemIdentificationInfo",
        sizeof(py::wrapper::Windows::System::Profile::SystemIdentificationInfo),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SystemIdentificationInfo};

    // ----- SystemSetupInfo class --------------------

    static PyObject* _new_SystemSetupInfo(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::System::Profile::SystemSetupInfo>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::System::Profile::SystemSetupInfo>::type_name);
        return nullptr;
    }

    static PyObject* SystemSetupInfo_get_OutOfBoxExperienceState(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.Profile.SystemSetupInfo", L"OutOfBoxExperienceState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::System::Profile::SystemSetupInfo::OutOfBoxExperienceState();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemSetupInfo_add_OutOfBoxExperienceStateChanged(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.System.Profile.SystemSetupInfo", L"OutOfBoxExperienceStateChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::EventHandler<winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::System::Profile::SystemSetupInfo::OutOfBoxExperienceStateChanged(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemSetupInfo_remove_OutOfBoxExperienceStateChanged(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.System.Profile.SystemSetupInfo", L"OutOfBoxExperienceStateChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                winrt::Windows::System::Profile::SystemSetupInfo::OutOfBoxExperienceStateChanged(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SystemSetupInfo[] = {
        { }};

    static PyGetSetDef _getset_SystemSetupInfo[] = {
        { }};

    static PyType_Slot _type_slots_SystemSetupInfo[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_SystemSetupInfo) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SystemSetupInfo) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SystemSetupInfo) },
        { }};

    static PyType_Spec type_spec_SystemSetupInfo = {
        "winrt._winrt_windows_system_profile.SystemSetupInfo",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SystemSetupInfo};

    static PyGetSetDef getset_SystemSetupInfo_Static[] = {
        { "out_of_box_experience_state", reinterpret_cast<getter>(SystemSetupInfo_get_OutOfBoxExperienceState), nullptr, nullptr, nullptr },
        { }};

    static PyMethodDef methods_SystemSetupInfo_Static[] = {
        { "add_out_of_box_experience_state_changed", reinterpret_cast<PyCFunction>(SystemSetupInfo_add_OutOfBoxExperienceStateChanged), METH_O, nullptr },
        { "remove_out_of_box_experience_state_changed", reinterpret_cast<PyCFunction>(SystemSetupInfo_remove_OutOfBoxExperienceStateChanged), METH_O, nullptr },
        { }};

    static PyType_Slot type_slots_SystemSetupInfo_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_SystemSetupInfo_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_SystemSetupInfo_Static) },
        { }
    };

    static PyType_Spec type_spec_SystemSetupInfo_Static = {
        "winrt._winrt_windows_system_profile.SystemSetupInfo_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_SystemSetupInfo_Static};

    // ----- UnsupportedAppRequirement class --------------------

    static PyObject* _new_UnsupportedAppRequirement(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::System::Profile::UnsupportedAppRequirement>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::System::Profile::UnsupportedAppRequirement>::type_name);
        return nullptr;
    }

    static void _dealloc_UnsupportedAppRequirement(py::wrapper::Windows::System::Profile::UnsupportedAppRequirement* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* UnsupportedAppRequirement_get_Reasons(py::wrapper::Windows::System::Profile::UnsupportedAppRequirement* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.Profile.UnsupportedAppRequirement", L"Reasons");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Reasons();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UnsupportedAppRequirement_get_Requirement(py::wrapper::Windows::System::Profile::UnsupportedAppRequirement* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.Profile.UnsupportedAppRequirement", L"Requirement");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Requirement();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_UnsupportedAppRequirement(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::System::Profile::UnsupportedAppRequirement>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_UnsupportedAppRequirement(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::Profile::UnsupportedAppRequirement>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_UnsupportedAppRequirement[] = {
        { "_assign_array_", _assign_array_UnsupportedAppRequirement, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_UnsupportedAppRequirement), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_UnsupportedAppRequirement[] = {
        { "reasons", reinterpret_cast<getter>(UnsupportedAppRequirement_get_Reasons), nullptr, nullptr, nullptr },
        { "requirement", reinterpret_cast<getter>(UnsupportedAppRequirement_get_Requirement), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_UnsupportedAppRequirement[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_UnsupportedAppRequirement) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_UnsupportedAppRequirement) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_UnsupportedAppRequirement) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_UnsupportedAppRequirement) },
        { }};

    static PyType_Spec type_spec_UnsupportedAppRequirement = {
        "winrt._winrt_windows_system_profile.UnsupportedAppRequirement",
        sizeof(py::wrapper::Windows::System::Profile::UnsupportedAppRequirement),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_UnsupportedAppRequirement};

    // ----- WindowsIntegrityPolicy class --------------------

    static PyObject* _new_WindowsIntegrityPolicy(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::System::Profile::WindowsIntegrityPolicy>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::System::Profile::WindowsIntegrityPolicy>::type_name);
        return nullptr;
    }

    static PyObject* WindowsIntegrityPolicy_get_CanDisable(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.Profile.WindowsIntegrityPolicy", L"CanDisable");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::System::Profile::WindowsIntegrityPolicy::CanDisable();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WindowsIntegrityPolicy_get_IsDisableSupported(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.Profile.WindowsIntegrityPolicy", L"IsDisableSupported");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::System::Profile::WindowsIntegrityPolicy::IsDisableSupported();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WindowsIntegrityPolicy_get_IsEnabled(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.Profile.WindowsIntegrityPolicy", L"IsEnabled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::System::Profile::WindowsIntegrityPolicy::IsEnabled();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WindowsIntegrityPolicy_get_IsEnabledForTrial(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.Profile.WindowsIntegrityPolicy", L"IsEnabledForTrial");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::System::Profile::WindowsIntegrityPolicy::IsEnabledForTrial();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WindowsIntegrityPolicy_add_PolicyChanged(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.System.Profile.WindowsIntegrityPolicy", L"PolicyChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::EventHandler<winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::System::Profile::WindowsIntegrityPolicy::PolicyChanged(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WindowsIntegrityPolicy_remove_PolicyChanged(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.System.Profile.WindowsIntegrityPolicy", L"PolicyChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                winrt::Windows::System::Profile::WindowsIntegrityPolicy::PolicyChanged(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WindowsIntegrityPolicy[] = {
        { }};

    static PyGetSetDef _getset_WindowsIntegrityPolicy[] = {
        { }};

    static PyType_Slot _type_slots_WindowsIntegrityPolicy[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_WindowsIntegrityPolicy) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_WindowsIntegrityPolicy) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_WindowsIntegrityPolicy) },
        { }};

    static PyType_Spec type_spec_WindowsIntegrityPolicy = {
        "winrt._winrt_windows_system_profile.WindowsIntegrityPolicy",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WindowsIntegrityPolicy};

    static PyGetSetDef getset_WindowsIntegrityPolicy_Static[] = {
        { "can_disable", reinterpret_cast<getter>(WindowsIntegrityPolicy_get_CanDisable), nullptr, nullptr, nullptr },
        { "is_disable_supported", reinterpret_cast<getter>(WindowsIntegrityPolicy_get_IsDisableSupported), nullptr, nullptr, nullptr },
        { "is_enabled", reinterpret_cast<getter>(WindowsIntegrityPolicy_get_IsEnabled), nullptr, nullptr, nullptr },
        { "is_enabled_for_trial", reinterpret_cast<getter>(WindowsIntegrityPolicy_get_IsEnabledForTrial), nullptr, nullptr, nullptr },
        { }};

    static PyMethodDef methods_WindowsIntegrityPolicy_Static[] = {
        { "add_policy_changed", reinterpret_cast<PyCFunction>(WindowsIntegrityPolicy_add_PolicyChanged), METH_O, nullptr },
        { "remove_policy_changed", reinterpret_cast<PyCFunction>(WindowsIntegrityPolicy_remove_PolicyChanged), METH_O, nullptr },
        { }};

    static PyType_Slot type_slots_WindowsIntegrityPolicy_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_WindowsIntegrityPolicy_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_WindowsIntegrityPolicy_Static) },
        { }
    };

    static PyType_Spec type_spec_WindowsIntegrityPolicy_Static = {
        "winrt._winrt_windows_system_profile.WindowsIntegrityPolicy_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_WindowsIntegrityPolicy_Static};

    // ----- Windows.System.Profile Initialization --------------------

    PyDoc_STRVAR(module_doc, "Windows.System.Profile");

    static PyModuleDef module_def = {
        PyModuleDef_HEAD_INIT,
        "_winrt_windows_system_profile",
        module_doc,
        0,
        nullptr,
        nullptr,
        nullptr,
        nullptr,
        nullptr};
} // py::cpp::Windows::System::Profile

PyMODINIT_FUNC PyInit__winrt_windows_system_profile(void) noexcept
{
    using namespace py::cpp::Windows::System::Profile;

    if (py::import_winrt_runtime() == -1)
    {
        return nullptr;
    }

    py::pyobj_handle module{PyModule_Create(&module_def)};

    if (!module)
    {
        return nullptr;
    }

    auto inspectable_meta_type = py::get_inspectable_meta_type();
    if (!inspectable_meta_type)
    {
        return nullptr;
    }

    auto object_type = py::get_object_type();
    if (!object_type)
    {
        return nullptr;
    }

    py::pyobj_handle object_bases{PyTuple_Pack(1, object_type)};

    if (!object_bases)
    {
        return nullptr;
    }

    py::pyobj_handle AnalyticsInfo_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(inspectable_meta_type))};
    if (!AnalyticsInfo_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_AnalyticsInfo_Static{PyType_FromSpecWithBases(&type_spec_AnalyticsInfo_Static, AnalyticsInfo_Static_bases.get())};
    if (!type_AnalyticsInfo_Static)
    {
        return nullptr;
    }

    py::pytype_handle AnalyticsInfo_type{py::register_python_type(module.get(), &type_spec_AnalyticsInfo, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_AnalyticsInfo_Static.get()))};
    if (!AnalyticsInfo_type)
    {
        return nullptr;
    }

    py::pytype_handle AnalyticsVersionInfo_type{py::register_python_type(module.get(), &type_spec_AnalyticsVersionInfo, object_bases.get(), inspectable_meta_type)};
    if (!AnalyticsVersionInfo_type)
    {
        return nullptr;
    }

    py::pyobj_handle AppApplicability_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(inspectable_meta_type))};
    if (!AppApplicability_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_AppApplicability_Static{PyType_FromSpecWithBases(&type_spec_AppApplicability_Static, AppApplicability_Static_bases.get())};
    if (!type_AppApplicability_Static)
    {
        return nullptr;
    }

    py::pytype_handle AppApplicability_type{py::register_python_type(module.get(), &type_spec_AppApplicability, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_AppApplicability_Static.get()))};
    if (!AppApplicability_type)
    {
        return nullptr;
    }

    py::pyobj_handle EducationSettings_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(inspectable_meta_type))};
    if (!EducationSettings_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_EducationSettings_Static{PyType_FromSpecWithBases(&type_spec_EducationSettings_Static, EducationSettings_Static_bases.get())};
    if (!type_EducationSettings_Static)
    {
        return nullptr;
    }

    py::pytype_handle EducationSettings_type{py::register_python_type(module.get(), &type_spec_EducationSettings, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_EducationSettings_Static.get()))};
    if (!EducationSettings_type)
    {
        return nullptr;
    }

    py::pyobj_handle HardwareIdentification_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(inspectable_meta_type))};
    if (!HardwareIdentification_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_HardwareIdentification_Static{PyType_FromSpecWithBases(&type_spec_HardwareIdentification_Static, HardwareIdentification_Static_bases.get())};
    if (!type_HardwareIdentification_Static)
    {
        return nullptr;
    }

    py::pytype_handle HardwareIdentification_type{py::register_python_type(module.get(), &type_spec_HardwareIdentification, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_HardwareIdentification_Static.get()))};
    if (!HardwareIdentification_type)
    {
        return nullptr;
    }

    py::pytype_handle HardwareToken_type{py::register_python_type(module.get(), &type_spec_HardwareToken, object_bases.get(), inspectable_meta_type)};
    if (!HardwareToken_type)
    {
        return nullptr;
    }

    py::pyobj_handle KnownRetailInfoProperties_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(inspectable_meta_type))};
    if (!KnownRetailInfoProperties_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_KnownRetailInfoProperties_Static{PyType_FromSpecWithBases(&type_spec_KnownRetailInfoProperties_Static, KnownRetailInfoProperties_Static_bases.get())};
    if (!type_KnownRetailInfoProperties_Static)
    {
        return nullptr;
    }

    py::pytype_handle KnownRetailInfoProperties_type{py::register_python_type(module.get(), &type_spec_KnownRetailInfoProperties, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_KnownRetailInfoProperties_Static.get()))};
    if (!KnownRetailInfoProperties_type)
    {
        return nullptr;
    }

    py::pyobj_handle PlatformAutomaticAppSignInManager_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(inspectable_meta_type))};
    if (!PlatformAutomaticAppSignInManager_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_PlatformAutomaticAppSignInManager_Static{PyType_FromSpecWithBases(&type_spec_PlatformAutomaticAppSignInManager_Static, PlatformAutomaticAppSignInManager_Static_bases.get())};
    if (!type_PlatformAutomaticAppSignInManager_Static)
    {
        return nullptr;
    }

    py::pytype_handle PlatformAutomaticAppSignInManager_type{py::register_python_type(module.get(), &type_spec_PlatformAutomaticAppSignInManager, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_PlatformAutomaticAppSignInManager_Static.get()))};
    if (!PlatformAutomaticAppSignInManager_type)
    {
        return nullptr;
    }

    py::pyobj_handle PlatformDiagnosticsAndUsageDataSettings_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(inspectable_meta_type))};
    if (!PlatformDiagnosticsAndUsageDataSettings_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_PlatformDiagnosticsAndUsageDataSettings_Static{PyType_FromSpecWithBases(&type_spec_PlatformDiagnosticsAndUsageDataSettings_Static, PlatformDiagnosticsAndUsageDataSettings_Static_bases.get())};
    if (!type_PlatformDiagnosticsAndUsageDataSettings_Static)
    {
        return nullptr;
    }

    py::pytype_handle PlatformDiagnosticsAndUsageDataSettings_type{py::register_python_type(module.get(), &type_spec_PlatformDiagnosticsAndUsageDataSettings, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_PlatformDiagnosticsAndUsageDataSettings_Static.get()))};
    if (!PlatformDiagnosticsAndUsageDataSettings_type)
    {
        return nullptr;
    }

    py::pyobj_handle RetailInfo_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(inspectable_meta_type))};
    if (!RetailInfo_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_RetailInfo_Static{PyType_FromSpecWithBases(&type_spec_RetailInfo_Static, RetailInfo_Static_bases.get())};
    if (!type_RetailInfo_Static)
    {
        return nullptr;
    }

    py::pytype_handle RetailInfo_type{py::register_python_type(module.get(), &type_spec_RetailInfo, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_RetailInfo_Static.get()))};
    if (!RetailInfo_type)
    {
        return nullptr;
    }

    py::pyobj_handle SharedModeSettings_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(inspectable_meta_type))};
    if (!SharedModeSettings_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_SharedModeSettings_Static{PyType_FromSpecWithBases(&type_spec_SharedModeSettings_Static, SharedModeSettings_Static_bases.get())};
    if (!type_SharedModeSettings_Static)
    {
        return nullptr;
    }

    py::pytype_handle SharedModeSettings_type{py::register_python_type(module.get(), &type_spec_SharedModeSettings, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_SharedModeSettings_Static.get()))};
    if (!SharedModeSettings_type)
    {
        return nullptr;
    }

    py::pyobj_handle SmartAppControlPolicy_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(inspectable_meta_type))};
    if (!SmartAppControlPolicy_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_SmartAppControlPolicy_Static{PyType_FromSpecWithBases(&type_spec_SmartAppControlPolicy_Static, SmartAppControlPolicy_Static_bases.get())};
    if (!type_SmartAppControlPolicy_Static)
    {
        return nullptr;
    }

    py::pytype_handle SmartAppControlPolicy_type{py::register_python_type(module.get(), &type_spec_SmartAppControlPolicy, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_SmartAppControlPolicy_Static.get()))};
    if (!SmartAppControlPolicy_type)
    {
        return nullptr;
    }

    py::pyobj_handle SystemIdentification_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(inspectable_meta_type))};
    if (!SystemIdentification_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_SystemIdentification_Static{PyType_FromSpecWithBases(&type_spec_SystemIdentification_Static, SystemIdentification_Static_bases.get())};
    if (!type_SystemIdentification_Static)
    {
        return nullptr;
    }

    py::pytype_handle SystemIdentification_type{py::register_python_type(module.get(), &type_spec_SystemIdentification, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_SystemIdentification_Static.get()))};
    if (!SystemIdentification_type)
    {
        return nullptr;
    }

    py::pytype_handle SystemIdentificationInfo_type{py::register_python_type(module.get(), &type_spec_SystemIdentificationInfo, object_bases.get(), inspectable_meta_type)};
    if (!SystemIdentificationInfo_type)
    {
        return nullptr;
    }

    py::pyobj_handle SystemSetupInfo_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(inspectable_meta_type))};
    if (!SystemSetupInfo_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_SystemSetupInfo_Static{PyType_FromSpecWithBases(&type_spec_SystemSetupInfo_Static, SystemSetupInfo_Static_bases.get())};
    if (!type_SystemSetupInfo_Static)
    {
        return nullptr;
    }

    py::pytype_handle SystemSetupInfo_type{py::register_python_type(module.get(), &type_spec_SystemSetupInfo, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_SystemSetupInfo_Static.get()))};
    if (!SystemSetupInfo_type)
    {
        return nullptr;
    }

    py::pytype_handle UnsupportedAppRequirement_type{py::register_python_type(module.get(), &type_spec_UnsupportedAppRequirement, object_bases.get(), inspectable_meta_type)};
    if (!UnsupportedAppRequirement_type)
    {
        return nullptr;
    }

    py::pyobj_handle WindowsIntegrityPolicy_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(inspectable_meta_type))};
    if (!WindowsIntegrityPolicy_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_WindowsIntegrityPolicy_Static{PyType_FromSpecWithBases(&type_spec_WindowsIntegrityPolicy_Static, WindowsIntegrityPolicy_Static_bases.get())};
    if (!type_WindowsIntegrityPolicy_Static)
    {
        return nullptr;
    }

    py::pytype_handle WindowsIntegrityPolicy_type{py::register_python_type(module.get(), &type_spec_WindowsIntegrityPolicy, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_WindowsIntegrityPolicy_Static.get()))};
    if (!WindowsIntegrityPolicy_type)
    {
        return nullptr;
    }


    return module.detach();
}
