// WARNING: Please don't edit this file. It was generated by Python/WinRT v3.2.1

#include "py.Windows.Devices.Bluetooth.Advertisement.h"

namespace py::cpp::Windows::Devices::Bluetooth::Advertisement
{
    // ----- BluetoothLEAdvertisement class --------------------

    static PyObject* _new_BluetoothLEAdvertisement(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisement instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_BluetoothLEAdvertisement(py::wrapper::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisement* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* BluetoothLEAdvertisement_GetManufacturerDataByCompanyId(py::wrapper::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisement* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Bluetooth.Advertisement.BluetoothLEAdvertisement", L"GetManufacturerDataByCompanyId", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint16_t>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetManufacturerDataByCompanyId(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BluetoothLEAdvertisement_GetSectionsByType(py::wrapper::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisement* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Bluetooth.Advertisement.BluetoothLEAdvertisement", L"GetSectionsByType", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint8_t>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetSectionsByType(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BluetoothLEAdvertisement_get_LocalName(py::wrapper::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisement* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.Advertisement.BluetoothLEAdvertisement", L"LocalName");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.LocalName();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BluetoothLEAdvertisement_put_LocalName(py::wrapper::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisement* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.Advertisement.BluetoothLEAdvertisement", L"LocalName");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            {
                auto _gil = release_gil();
                self->obj.LocalName(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BluetoothLEAdvertisement_get_Flags(py::wrapper::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisement* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.Advertisement.BluetoothLEAdvertisement", L"Flags");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Flags();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BluetoothLEAdvertisement_put_Flags(py::wrapper::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisement* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.Advertisement.BluetoothLEAdvertisement", L"Flags");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementFlags>>(arg);

            {
                auto _gil = release_gil();
                self->obj.Flags(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BluetoothLEAdvertisement_get_DataSections(py::wrapper::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisement* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.Advertisement.BluetoothLEAdvertisement", L"DataSections");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.DataSections();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEAdvertisement_get_ManufacturerData(py::wrapper::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisement* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.Advertisement.BluetoothLEAdvertisement", L"ManufacturerData");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ManufacturerData();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEAdvertisement_get_ServiceUuids(py::wrapper::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisement* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.Advertisement.BluetoothLEAdvertisement", L"ServiceUuids");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ServiceUuids();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_BluetoothLEAdvertisement(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisement>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_BluetoothLEAdvertisement(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisement>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_BluetoothLEAdvertisement[] = {
        { "get_manufacturer_data_by_company_id", reinterpret_cast<PyCFunction>(BluetoothLEAdvertisement_GetManufacturerDataByCompanyId), METH_VARARGS, nullptr },
        { "get_sections_by_type", reinterpret_cast<PyCFunction>(BluetoothLEAdvertisement_GetSectionsByType), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_BluetoothLEAdvertisement, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_BluetoothLEAdvertisement), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_BluetoothLEAdvertisement[] = {
        { "local_name", reinterpret_cast<getter>(BluetoothLEAdvertisement_get_LocalName), reinterpret_cast<setter>(BluetoothLEAdvertisement_put_LocalName), nullptr, nullptr },
        { "flags", reinterpret_cast<getter>(BluetoothLEAdvertisement_get_Flags), reinterpret_cast<setter>(BluetoothLEAdvertisement_put_Flags), nullptr, nullptr },
        { "data_sections", reinterpret_cast<getter>(BluetoothLEAdvertisement_get_DataSections), nullptr, nullptr, nullptr },
        { "manufacturer_data", reinterpret_cast<getter>(BluetoothLEAdvertisement_get_ManufacturerData), nullptr, nullptr, nullptr },
        { "service_uuids", reinterpret_cast<getter>(BluetoothLEAdvertisement_get_ServiceUuids), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_BluetoothLEAdvertisement[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_BluetoothLEAdvertisement) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_BluetoothLEAdvertisement) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_BluetoothLEAdvertisement) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_BluetoothLEAdvertisement) },
        { }};

    static PyType_Spec type_spec_BluetoothLEAdvertisement = {
        "winrt._winrt_windows_devices_bluetooth_advertisement.BluetoothLEAdvertisement",
        sizeof(py::wrapper::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisement),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BluetoothLEAdvertisement};

    // ----- BluetoothLEAdvertisementBytePattern class --------------------

    static PyObject* _new_BluetoothLEAdvertisementBytePattern(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementBytePattern instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<uint8_t>(args, 0);
                auto param1 = py::convert_to<int16_t>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 2);

                winrt::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementBytePattern instance{param0, param1, param2};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_BluetoothLEAdvertisementBytePattern(py::wrapper::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementBytePattern* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* BluetoothLEAdvertisementBytePattern_get_Offset(py::wrapper::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementBytePattern* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.Advertisement.BluetoothLEAdvertisementBytePattern", L"Offset");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Offset();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BluetoothLEAdvertisementBytePattern_put_Offset(py::wrapper::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementBytePattern* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.Advertisement.BluetoothLEAdvertisementBytePattern", L"Offset");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<int16_t>(arg);

            {
                auto _gil = release_gil();
                self->obj.Offset(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BluetoothLEAdvertisementBytePattern_get_DataType(py::wrapper::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementBytePattern* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.Advertisement.BluetoothLEAdvertisementBytePattern", L"DataType");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.DataType();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BluetoothLEAdvertisementBytePattern_put_DataType(py::wrapper::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementBytePattern* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.Advertisement.BluetoothLEAdvertisementBytePattern", L"DataType");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<uint8_t>(arg);

            {
                auto _gil = release_gil();
                self->obj.DataType(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BluetoothLEAdvertisementBytePattern_get_Data(py::wrapper::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementBytePattern* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.Advertisement.BluetoothLEAdvertisementBytePattern", L"Data");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Data();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BluetoothLEAdvertisementBytePattern_put_Data(py::wrapper::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementBytePattern* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.Advertisement.BluetoothLEAdvertisementBytePattern", L"Data");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(arg);

            {
                auto _gil = release_gil();
                self->obj.Data(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_BluetoothLEAdvertisementBytePattern(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementBytePattern>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_BluetoothLEAdvertisementBytePattern(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementBytePattern>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_BluetoothLEAdvertisementBytePattern[] = {
        { "_assign_array_", _assign_array_BluetoothLEAdvertisementBytePattern, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_BluetoothLEAdvertisementBytePattern), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_BluetoothLEAdvertisementBytePattern[] = {
        { "offset", reinterpret_cast<getter>(BluetoothLEAdvertisementBytePattern_get_Offset), reinterpret_cast<setter>(BluetoothLEAdvertisementBytePattern_put_Offset), nullptr, nullptr },
        { "data_type", reinterpret_cast<getter>(BluetoothLEAdvertisementBytePattern_get_DataType), reinterpret_cast<setter>(BluetoothLEAdvertisementBytePattern_put_DataType), nullptr, nullptr },
        { "data", reinterpret_cast<getter>(BluetoothLEAdvertisementBytePattern_get_Data), reinterpret_cast<setter>(BluetoothLEAdvertisementBytePattern_put_Data), nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_BluetoothLEAdvertisementBytePattern[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_BluetoothLEAdvertisementBytePattern) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_BluetoothLEAdvertisementBytePattern) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_BluetoothLEAdvertisementBytePattern) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_BluetoothLEAdvertisementBytePattern) },
        { }};

    static PyType_Spec type_spec_BluetoothLEAdvertisementBytePattern = {
        "winrt._winrt_windows_devices_bluetooth_advertisement.BluetoothLEAdvertisementBytePattern",
        sizeof(py::wrapper::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementBytePattern),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BluetoothLEAdvertisementBytePattern};

    // ----- BluetoothLEAdvertisementDataSection class --------------------

    static PyObject* _new_BluetoothLEAdvertisementDataSection(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementDataSection instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<uint8_t>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 1);

                winrt::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementDataSection instance{param0, param1};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_BluetoothLEAdvertisementDataSection(py::wrapper::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementDataSection* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* BluetoothLEAdvertisementDataSection_get_DataType(py::wrapper::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementDataSection* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.Advertisement.BluetoothLEAdvertisementDataSection", L"DataType");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.DataType();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BluetoothLEAdvertisementDataSection_put_DataType(py::wrapper::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementDataSection* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.Advertisement.BluetoothLEAdvertisementDataSection", L"DataType");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<uint8_t>(arg);

            {
                auto _gil = release_gil();
                self->obj.DataType(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BluetoothLEAdvertisementDataSection_get_Data(py::wrapper::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementDataSection* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.Advertisement.BluetoothLEAdvertisementDataSection", L"Data");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Data();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BluetoothLEAdvertisementDataSection_put_Data(py::wrapper::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementDataSection* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.Advertisement.BluetoothLEAdvertisementDataSection", L"Data");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(arg);

            {
                auto _gil = release_gil();
                self->obj.Data(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_BluetoothLEAdvertisementDataSection(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementDataSection>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_BluetoothLEAdvertisementDataSection(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementDataSection>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_BluetoothLEAdvertisementDataSection[] = {
        { "_assign_array_", _assign_array_BluetoothLEAdvertisementDataSection, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_BluetoothLEAdvertisementDataSection), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_BluetoothLEAdvertisementDataSection[] = {
        { "data_type", reinterpret_cast<getter>(BluetoothLEAdvertisementDataSection_get_DataType), reinterpret_cast<setter>(BluetoothLEAdvertisementDataSection_put_DataType), nullptr, nullptr },
        { "data", reinterpret_cast<getter>(BluetoothLEAdvertisementDataSection_get_Data), reinterpret_cast<setter>(BluetoothLEAdvertisementDataSection_put_Data), nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_BluetoothLEAdvertisementDataSection[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_BluetoothLEAdvertisementDataSection) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_BluetoothLEAdvertisementDataSection) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_BluetoothLEAdvertisementDataSection) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_BluetoothLEAdvertisementDataSection) },
        { }};

    static PyType_Spec type_spec_BluetoothLEAdvertisementDataSection = {
        "winrt._winrt_windows_devices_bluetooth_advertisement.BluetoothLEAdvertisementDataSection",
        sizeof(py::wrapper::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementDataSection),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BluetoothLEAdvertisementDataSection};

    // ----- BluetoothLEAdvertisementDataTypes class --------------------

    static PyObject* _new_BluetoothLEAdvertisementDataTypes(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementDataTypes>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementDataTypes>::type_name);
        return nullptr;
    }

    static PyObject* BluetoothLEAdvertisementDataTypes_get_AdvertisingInterval(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.Advertisement.BluetoothLEAdvertisementDataTypes", L"AdvertisingInterval");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementDataTypes::AdvertisingInterval();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEAdvertisementDataTypes_get_Appearance(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.Advertisement.BluetoothLEAdvertisementDataTypes", L"Appearance");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementDataTypes::Appearance();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEAdvertisementDataTypes_get_CompleteLocalName(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.Advertisement.BluetoothLEAdvertisementDataTypes", L"CompleteLocalName");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementDataTypes::CompleteLocalName();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEAdvertisementDataTypes_get_CompleteService128BitUuids(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.Advertisement.BluetoothLEAdvertisementDataTypes", L"CompleteService128BitUuids");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementDataTypes::CompleteService128BitUuids();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEAdvertisementDataTypes_get_CompleteService16BitUuids(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.Advertisement.BluetoothLEAdvertisementDataTypes", L"CompleteService16BitUuids");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementDataTypes::CompleteService16BitUuids();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEAdvertisementDataTypes_get_CompleteService32BitUuids(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.Advertisement.BluetoothLEAdvertisementDataTypes", L"CompleteService32BitUuids");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementDataTypes::CompleteService32BitUuids();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEAdvertisementDataTypes_get_Flags(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.Advertisement.BluetoothLEAdvertisementDataTypes", L"Flags");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementDataTypes::Flags();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEAdvertisementDataTypes_get_IncompleteService128BitUuids(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.Advertisement.BluetoothLEAdvertisementDataTypes", L"IncompleteService128BitUuids");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementDataTypes::IncompleteService128BitUuids();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEAdvertisementDataTypes_get_IncompleteService16BitUuids(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.Advertisement.BluetoothLEAdvertisementDataTypes", L"IncompleteService16BitUuids");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementDataTypes::IncompleteService16BitUuids();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEAdvertisementDataTypes_get_IncompleteService32BitUuids(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.Advertisement.BluetoothLEAdvertisementDataTypes", L"IncompleteService32BitUuids");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementDataTypes::IncompleteService32BitUuids();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEAdvertisementDataTypes_get_ManufacturerSpecificData(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.Advertisement.BluetoothLEAdvertisementDataTypes", L"ManufacturerSpecificData");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementDataTypes::ManufacturerSpecificData();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEAdvertisementDataTypes_get_PeripheralConnectionIntervalRange(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.Advertisement.BluetoothLEAdvertisementDataTypes", L"PeripheralConnectionIntervalRange");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementDataTypes::PeripheralConnectionIntervalRange();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEAdvertisementDataTypes_get_PublicTargetAddress(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.Advertisement.BluetoothLEAdvertisementDataTypes", L"PublicTargetAddress");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementDataTypes::PublicTargetAddress();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEAdvertisementDataTypes_get_RandomTargetAddress(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.Advertisement.BluetoothLEAdvertisementDataTypes", L"RandomTargetAddress");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementDataTypes::RandomTargetAddress();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEAdvertisementDataTypes_get_ServiceData128BitUuids(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.Advertisement.BluetoothLEAdvertisementDataTypes", L"ServiceData128BitUuids");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementDataTypes::ServiceData128BitUuids();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEAdvertisementDataTypes_get_ServiceData16BitUuids(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.Advertisement.BluetoothLEAdvertisementDataTypes", L"ServiceData16BitUuids");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementDataTypes::ServiceData16BitUuids();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEAdvertisementDataTypes_get_ServiceData32BitUuids(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.Advertisement.BluetoothLEAdvertisementDataTypes", L"ServiceData32BitUuids");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementDataTypes::ServiceData32BitUuids();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEAdvertisementDataTypes_get_ServiceSolicitation128BitUuids(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.Advertisement.BluetoothLEAdvertisementDataTypes", L"ServiceSolicitation128BitUuids");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementDataTypes::ServiceSolicitation128BitUuids();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEAdvertisementDataTypes_get_ServiceSolicitation16BitUuids(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.Advertisement.BluetoothLEAdvertisementDataTypes", L"ServiceSolicitation16BitUuids");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementDataTypes::ServiceSolicitation16BitUuids();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEAdvertisementDataTypes_get_ServiceSolicitation32BitUuids(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.Advertisement.BluetoothLEAdvertisementDataTypes", L"ServiceSolicitation32BitUuids");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementDataTypes::ServiceSolicitation32BitUuids();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEAdvertisementDataTypes_get_ShortenedLocalName(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.Advertisement.BluetoothLEAdvertisementDataTypes", L"ShortenedLocalName");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementDataTypes::ShortenedLocalName();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEAdvertisementDataTypes_get_TxPowerLevel(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.Advertisement.BluetoothLEAdvertisementDataTypes", L"TxPowerLevel");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementDataTypes::TxPowerLevel();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_BluetoothLEAdvertisementDataTypes[] = {
        { }};

    static PyGetSetDef _getset_BluetoothLEAdvertisementDataTypes[] = {
        { }};

    static PyType_Slot _type_slots_BluetoothLEAdvertisementDataTypes[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_BluetoothLEAdvertisementDataTypes) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_BluetoothLEAdvertisementDataTypes) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_BluetoothLEAdvertisementDataTypes) },
        { }};

    static PyType_Spec type_spec_BluetoothLEAdvertisementDataTypes = {
        "winrt._winrt_windows_devices_bluetooth_advertisement.BluetoothLEAdvertisementDataTypes",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BluetoothLEAdvertisementDataTypes};

    static PyGetSetDef getset_BluetoothLEAdvertisementDataTypes_Static[] = {
        { "advertising_interval", reinterpret_cast<getter>(BluetoothLEAdvertisementDataTypes_get_AdvertisingInterval), nullptr, nullptr, nullptr },
        { "appearance", reinterpret_cast<getter>(BluetoothLEAdvertisementDataTypes_get_Appearance), nullptr, nullptr, nullptr },
        { "complete_local_name", reinterpret_cast<getter>(BluetoothLEAdvertisementDataTypes_get_CompleteLocalName), nullptr, nullptr, nullptr },
        { "complete_service128_bit_uuids", reinterpret_cast<getter>(BluetoothLEAdvertisementDataTypes_get_CompleteService128BitUuids), nullptr, nullptr, nullptr },
        { "complete_service16_bit_uuids", reinterpret_cast<getter>(BluetoothLEAdvertisementDataTypes_get_CompleteService16BitUuids), nullptr, nullptr, nullptr },
        { "complete_service32_bit_uuids", reinterpret_cast<getter>(BluetoothLEAdvertisementDataTypes_get_CompleteService32BitUuids), nullptr, nullptr, nullptr },
        { "flags", reinterpret_cast<getter>(BluetoothLEAdvertisementDataTypes_get_Flags), nullptr, nullptr, nullptr },
        { "incomplete_service128_bit_uuids", reinterpret_cast<getter>(BluetoothLEAdvertisementDataTypes_get_IncompleteService128BitUuids), nullptr, nullptr, nullptr },
        { "incomplete_service16_bit_uuids", reinterpret_cast<getter>(BluetoothLEAdvertisementDataTypes_get_IncompleteService16BitUuids), nullptr, nullptr, nullptr },
        { "incomplete_service32_bit_uuids", reinterpret_cast<getter>(BluetoothLEAdvertisementDataTypes_get_IncompleteService32BitUuids), nullptr, nullptr, nullptr },
        { "manufacturer_specific_data", reinterpret_cast<getter>(BluetoothLEAdvertisementDataTypes_get_ManufacturerSpecificData), nullptr, nullptr, nullptr },
        { "peripheral_connection_interval_range", reinterpret_cast<getter>(BluetoothLEAdvertisementDataTypes_get_PeripheralConnectionIntervalRange), nullptr, nullptr, nullptr },
        { "public_target_address", reinterpret_cast<getter>(BluetoothLEAdvertisementDataTypes_get_PublicTargetAddress), nullptr, nullptr, nullptr },
        { "random_target_address", reinterpret_cast<getter>(BluetoothLEAdvertisementDataTypes_get_RandomTargetAddress), nullptr, nullptr, nullptr },
        { "service_data128_bit_uuids", reinterpret_cast<getter>(BluetoothLEAdvertisementDataTypes_get_ServiceData128BitUuids), nullptr, nullptr, nullptr },
        { "service_data16_bit_uuids", reinterpret_cast<getter>(BluetoothLEAdvertisementDataTypes_get_ServiceData16BitUuids), nullptr, nullptr, nullptr },
        { "service_data32_bit_uuids", reinterpret_cast<getter>(BluetoothLEAdvertisementDataTypes_get_ServiceData32BitUuids), nullptr, nullptr, nullptr },
        { "service_solicitation128_bit_uuids", reinterpret_cast<getter>(BluetoothLEAdvertisementDataTypes_get_ServiceSolicitation128BitUuids), nullptr, nullptr, nullptr },
        { "service_solicitation16_bit_uuids", reinterpret_cast<getter>(BluetoothLEAdvertisementDataTypes_get_ServiceSolicitation16BitUuids), nullptr, nullptr, nullptr },
        { "service_solicitation32_bit_uuids", reinterpret_cast<getter>(BluetoothLEAdvertisementDataTypes_get_ServiceSolicitation32BitUuids), nullptr, nullptr, nullptr },
        { "shortened_local_name", reinterpret_cast<getter>(BluetoothLEAdvertisementDataTypes_get_ShortenedLocalName), nullptr, nullptr, nullptr },
        { "tx_power_level", reinterpret_cast<getter>(BluetoothLEAdvertisementDataTypes_get_TxPowerLevel), nullptr, nullptr, nullptr },
        { }};

    static PyMethodDef methods_BluetoothLEAdvertisementDataTypes_Static[] = {
        { }};

    static PyType_Slot type_slots_BluetoothLEAdvertisementDataTypes_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_BluetoothLEAdvertisementDataTypes_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_BluetoothLEAdvertisementDataTypes_Static) },
        { }
    };

    static PyType_Spec type_spec_BluetoothLEAdvertisementDataTypes_Static = {
        "winrt._winrt_windows_devices_bluetooth_advertisement.BluetoothLEAdvertisementDataTypes_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_BluetoothLEAdvertisementDataTypes_Static};

    // ----- BluetoothLEAdvertisementFilter class --------------------

    static PyObject* _new_BluetoothLEAdvertisementFilter(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementFilter instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_BluetoothLEAdvertisementFilter(py::wrapper::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementFilter* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* BluetoothLEAdvertisementFilter_get_Advertisement(py::wrapper::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementFilter* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.Advertisement.BluetoothLEAdvertisementFilter", L"Advertisement");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Advertisement();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BluetoothLEAdvertisementFilter_put_Advertisement(py::wrapper::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementFilter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.Advertisement.BluetoothLEAdvertisementFilter", L"Advertisement");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisement>(arg);

            {
                auto _gil = release_gil();
                self->obj.Advertisement(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BluetoothLEAdvertisementFilter_get_BytePatterns(py::wrapper::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementFilter* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.Advertisement.BluetoothLEAdvertisementFilter", L"BytePatterns");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.BytePatterns();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_BluetoothLEAdvertisementFilter(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementFilter>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_BluetoothLEAdvertisementFilter(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementFilter>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_BluetoothLEAdvertisementFilter[] = {
        { "_assign_array_", _assign_array_BluetoothLEAdvertisementFilter, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_BluetoothLEAdvertisementFilter), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_BluetoothLEAdvertisementFilter[] = {
        { "advertisement", reinterpret_cast<getter>(BluetoothLEAdvertisementFilter_get_Advertisement), reinterpret_cast<setter>(BluetoothLEAdvertisementFilter_put_Advertisement), nullptr, nullptr },
        { "byte_patterns", reinterpret_cast<getter>(BluetoothLEAdvertisementFilter_get_BytePatterns), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_BluetoothLEAdvertisementFilter[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_BluetoothLEAdvertisementFilter) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_BluetoothLEAdvertisementFilter) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_BluetoothLEAdvertisementFilter) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_BluetoothLEAdvertisementFilter) },
        { }};

    static PyType_Spec type_spec_BluetoothLEAdvertisementFilter = {
        "winrt._winrt_windows_devices_bluetooth_advertisement.BluetoothLEAdvertisementFilter",
        sizeof(py::wrapper::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementFilter),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BluetoothLEAdvertisementFilter};

    // ----- BluetoothLEAdvertisementPublisher class --------------------

    static PyObject* _new_BluetoothLEAdvertisementPublisher(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementPublisher instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisement>(args, 0);

                winrt::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementPublisher instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_BluetoothLEAdvertisementPublisher(py::wrapper::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementPublisher* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* BluetoothLEAdvertisementPublisher_Start(py::wrapper::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementPublisher* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Bluetooth.Advertisement.BluetoothLEAdvertisementPublisher", L"Start", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.Start();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BluetoothLEAdvertisementPublisher_Stop(py::wrapper::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementPublisher* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Bluetooth.Advertisement.BluetoothLEAdvertisementPublisher", L"Stop", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.Stop();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BluetoothLEAdvertisementPublisher_get_Advertisement(py::wrapper::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementPublisher* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.Advertisement.BluetoothLEAdvertisementPublisher", L"Advertisement");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Advertisement();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEAdvertisementPublisher_get_Status(py::wrapper::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementPublisher* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.Advertisement.BluetoothLEAdvertisementPublisher", L"Status");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Status();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEAdvertisementPublisher_get_UseExtendedAdvertisement(py::wrapper::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementPublisher* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.Advertisement.BluetoothLEAdvertisementPublisher", L"UseExtendedAdvertisement");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.UseExtendedAdvertisement();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BluetoothLEAdvertisementPublisher_put_UseExtendedAdvertisement(py::wrapper::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementPublisher* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.Advertisement.BluetoothLEAdvertisementPublisher", L"UseExtendedAdvertisement");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.UseExtendedAdvertisement(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BluetoothLEAdvertisementPublisher_get_PreferredTransmitPowerLevelInDBm(py::wrapper::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementPublisher* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.Advertisement.BluetoothLEAdvertisementPublisher", L"PreferredTransmitPowerLevelInDBm");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PreferredTransmitPowerLevelInDBm();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BluetoothLEAdvertisementPublisher_put_PreferredTransmitPowerLevelInDBm(py::wrapper::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementPublisher* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.Advertisement.BluetoothLEAdvertisementPublisher", L"PreferredTransmitPowerLevelInDBm");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<int16_t>>(arg);

            {
                auto _gil = release_gil();
                self->obj.PreferredTransmitPowerLevelInDBm(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BluetoothLEAdvertisementPublisher_get_IsAnonymous(py::wrapper::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementPublisher* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.Advertisement.BluetoothLEAdvertisementPublisher", L"IsAnonymous");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsAnonymous();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BluetoothLEAdvertisementPublisher_put_IsAnonymous(py::wrapper::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementPublisher* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.Advertisement.BluetoothLEAdvertisementPublisher", L"IsAnonymous");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.IsAnonymous(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BluetoothLEAdvertisementPublisher_get_IncludeTransmitPowerLevel(py::wrapper::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementPublisher* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.Advertisement.BluetoothLEAdvertisementPublisher", L"IncludeTransmitPowerLevel");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IncludeTransmitPowerLevel();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BluetoothLEAdvertisementPublisher_put_IncludeTransmitPowerLevel(py::wrapper::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementPublisher* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.Advertisement.BluetoothLEAdvertisementPublisher", L"IncludeTransmitPowerLevel");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.IncludeTransmitPowerLevel(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BluetoothLEAdvertisementPublisher_get_SecondaryPhy(py::wrapper::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementPublisher* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.Advertisement.BluetoothLEAdvertisementPublisher", L"SecondaryPhy");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SecondaryPhy();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BluetoothLEAdvertisementPublisher_put_SecondaryPhy(py::wrapper::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementPublisher* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.Advertisement.BluetoothLEAdvertisementPublisher", L"SecondaryPhy");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementPhyType>(arg);

            {
                auto _gil = release_gil();
                self->obj.SecondaryPhy(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BluetoothLEAdvertisementPublisher_get_PrimaryPhy(py::wrapper::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementPublisher* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.Advertisement.BluetoothLEAdvertisementPublisher", L"PrimaryPhy");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PrimaryPhy();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BluetoothLEAdvertisementPublisher_put_PrimaryPhy(py::wrapper::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementPublisher* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.Advertisement.BluetoothLEAdvertisementPublisher", L"PrimaryPhy");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementPhyType>(arg);

            {
                auto _gil = release_gil();
                self->obj.PrimaryPhy(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BluetoothLEAdvertisementPublisher_add_StatusChanged(py::wrapper::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementPublisher* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Bluetooth.Advertisement.BluetoothLEAdvertisementPublisher", L"StatusChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementPublisher, winrt::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementPublisherStatusChangedEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.StatusChanged(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEAdvertisementPublisher_remove_StatusChanged(py::wrapper::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementPublisher* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Bluetooth.Advertisement.BluetoothLEAdvertisementPublisher", L"StatusChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.StatusChanged(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_BluetoothLEAdvertisementPublisher(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementPublisher>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_BluetoothLEAdvertisementPublisher(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementPublisher>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_BluetoothLEAdvertisementPublisher[] = {
        { "start", reinterpret_cast<PyCFunction>(BluetoothLEAdvertisementPublisher_Start), METH_VARARGS, nullptr },
        { "stop", reinterpret_cast<PyCFunction>(BluetoothLEAdvertisementPublisher_Stop), METH_VARARGS, nullptr },
        { "add_status_changed", reinterpret_cast<PyCFunction>(BluetoothLEAdvertisementPublisher_add_StatusChanged), METH_O, nullptr },
        { "remove_status_changed", reinterpret_cast<PyCFunction>(BluetoothLEAdvertisementPublisher_remove_StatusChanged), METH_O, nullptr },
        { "_assign_array_", _assign_array_BluetoothLEAdvertisementPublisher, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_BluetoothLEAdvertisementPublisher), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_BluetoothLEAdvertisementPublisher[] = {
        { "advertisement", reinterpret_cast<getter>(BluetoothLEAdvertisementPublisher_get_Advertisement), nullptr, nullptr, nullptr },
        { "status", reinterpret_cast<getter>(BluetoothLEAdvertisementPublisher_get_Status), nullptr, nullptr, nullptr },
        { "use_extended_advertisement", reinterpret_cast<getter>(BluetoothLEAdvertisementPublisher_get_UseExtendedAdvertisement), reinterpret_cast<setter>(BluetoothLEAdvertisementPublisher_put_UseExtendedAdvertisement), nullptr, nullptr },
        { "preferred_transmit_power_level_in_dbm", reinterpret_cast<getter>(BluetoothLEAdvertisementPublisher_get_PreferredTransmitPowerLevelInDBm), reinterpret_cast<setter>(BluetoothLEAdvertisementPublisher_put_PreferredTransmitPowerLevelInDBm), nullptr, nullptr },
        { "is_anonymous", reinterpret_cast<getter>(BluetoothLEAdvertisementPublisher_get_IsAnonymous), reinterpret_cast<setter>(BluetoothLEAdvertisementPublisher_put_IsAnonymous), nullptr, nullptr },
        { "include_transmit_power_level", reinterpret_cast<getter>(BluetoothLEAdvertisementPublisher_get_IncludeTransmitPowerLevel), reinterpret_cast<setter>(BluetoothLEAdvertisementPublisher_put_IncludeTransmitPowerLevel), nullptr, nullptr },
        { "secondary_phy", reinterpret_cast<getter>(BluetoothLEAdvertisementPublisher_get_SecondaryPhy), reinterpret_cast<setter>(BluetoothLEAdvertisementPublisher_put_SecondaryPhy), nullptr, nullptr },
        { "primary_phy", reinterpret_cast<getter>(BluetoothLEAdvertisementPublisher_get_PrimaryPhy), reinterpret_cast<setter>(BluetoothLEAdvertisementPublisher_put_PrimaryPhy), nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_BluetoothLEAdvertisementPublisher[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_BluetoothLEAdvertisementPublisher) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_BluetoothLEAdvertisementPublisher) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_BluetoothLEAdvertisementPublisher) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_BluetoothLEAdvertisementPublisher) },
        { }};

    static PyType_Spec type_spec_BluetoothLEAdvertisementPublisher = {
        "winrt._winrt_windows_devices_bluetooth_advertisement.BluetoothLEAdvertisementPublisher",
        sizeof(py::wrapper::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementPublisher),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BluetoothLEAdvertisementPublisher};

    // ----- BluetoothLEAdvertisementPublisherStatusChangedEventArgs class --------------------

    static PyObject* _new_BluetoothLEAdvertisementPublisherStatusChangedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementPublisherStatusChangedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementPublisherStatusChangedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_BluetoothLEAdvertisementPublisherStatusChangedEventArgs(py::wrapper::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementPublisherStatusChangedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* BluetoothLEAdvertisementPublisherStatusChangedEventArgs_get_Error(py::wrapper::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementPublisherStatusChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.Advertisement.BluetoothLEAdvertisementPublisherStatusChangedEventArgs", L"Error");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Error();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEAdvertisementPublisherStatusChangedEventArgs_get_Status(py::wrapper::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementPublisherStatusChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.Advertisement.BluetoothLEAdvertisementPublisherStatusChangedEventArgs", L"Status");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Status();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEAdvertisementPublisherStatusChangedEventArgs_get_SelectedTransmitPowerLevelInDBm(py::wrapper::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementPublisherStatusChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.Advertisement.BluetoothLEAdvertisementPublisherStatusChangedEventArgs", L"SelectedTransmitPowerLevelInDBm");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SelectedTransmitPowerLevelInDBm();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_BluetoothLEAdvertisementPublisherStatusChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementPublisherStatusChangedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_BluetoothLEAdvertisementPublisherStatusChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementPublisherStatusChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_BluetoothLEAdvertisementPublisherStatusChangedEventArgs[] = {
        { "_assign_array_", _assign_array_BluetoothLEAdvertisementPublisherStatusChangedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_BluetoothLEAdvertisementPublisherStatusChangedEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_BluetoothLEAdvertisementPublisherStatusChangedEventArgs[] = {
        { "error", reinterpret_cast<getter>(BluetoothLEAdvertisementPublisherStatusChangedEventArgs_get_Error), nullptr, nullptr, nullptr },
        { "status", reinterpret_cast<getter>(BluetoothLEAdvertisementPublisherStatusChangedEventArgs_get_Status), nullptr, nullptr, nullptr },
        { "selected_transmit_power_level_in_dbm", reinterpret_cast<getter>(BluetoothLEAdvertisementPublisherStatusChangedEventArgs_get_SelectedTransmitPowerLevelInDBm), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_BluetoothLEAdvertisementPublisherStatusChangedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_BluetoothLEAdvertisementPublisherStatusChangedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_BluetoothLEAdvertisementPublisherStatusChangedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_BluetoothLEAdvertisementPublisherStatusChangedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_BluetoothLEAdvertisementPublisherStatusChangedEventArgs) },
        { }};

    static PyType_Spec type_spec_BluetoothLEAdvertisementPublisherStatusChangedEventArgs = {
        "winrt._winrt_windows_devices_bluetooth_advertisement.BluetoothLEAdvertisementPublisherStatusChangedEventArgs",
        sizeof(py::wrapper::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementPublisherStatusChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BluetoothLEAdvertisementPublisherStatusChangedEventArgs};

    // ----- BluetoothLEAdvertisementReceivedEventArgs class --------------------

    static PyObject* _new_BluetoothLEAdvertisementReceivedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementReceivedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementReceivedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_BluetoothLEAdvertisementReceivedEventArgs(py::wrapper::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementReceivedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* BluetoothLEAdvertisementReceivedEventArgs_get_Advertisement(py::wrapper::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementReceivedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.Advertisement.BluetoothLEAdvertisementReceivedEventArgs", L"Advertisement");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Advertisement();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEAdvertisementReceivedEventArgs_get_AdvertisementType(py::wrapper::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementReceivedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.Advertisement.BluetoothLEAdvertisementReceivedEventArgs", L"AdvertisementType");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.AdvertisementType();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEAdvertisementReceivedEventArgs_get_BluetoothAddress(py::wrapper::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementReceivedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.Advertisement.BluetoothLEAdvertisementReceivedEventArgs", L"BluetoothAddress");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.BluetoothAddress();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEAdvertisementReceivedEventArgs_get_RawSignalStrengthInDBm(py::wrapper::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementReceivedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.Advertisement.BluetoothLEAdvertisementReceivedEventArgs", L"RawSignalStrengthInDBm");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.RawSignalStrengthInDBm();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEAdvertisementReceivedEventArgs_get_Timestamp(py::wrapper::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementReceivedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.Advertisement.BluetoothLEAdvertisementReceivedEventArgs", L"Timestamp");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Timestamp();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEAdvertisementReceivedEventArgs_get_BluetoothAddressType(py::wrapper::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementReceivedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.Advertisement.BluetoothLEAdvertisementReceivedEventArgs", L"BluetoothAddressType");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.BluetoothAddressType();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEAdvertisementReceivedEventArgs_get_IsAnonymous(py::wrapper::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementReceivedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.Advertisement.BluetoothLEAdvertisementReceivedEventArgs", L"IsAnonymous");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsAnonymous();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEAdvertisementReceivedEventArgs_get_IsConnectable(py::wrapper::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementReceivedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.Advertisement.BluetoothLEAdvertisementReceivedEventArgs", L"IsConnectable");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsConnectable();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEAdvertisementReceivedEventArgs_get_IsDirected(py::wrapper::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementReceivedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.Advertisement.BluetoothLEAdvertisementReceivedEventArgs", L"IsDirected");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsDirected();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEAdvertisementReceivedEventArgs_get_IsScanResponse(py::wrapper::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementReceivedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.Advertisement.BluetoothLEAdvertisementReceivedEventArgs", L"IsScanResponse");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsScanResponse();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEAdvertisementReceivedEventArgs_get_IsScannable(py::wrapper::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementReceivedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.Advertisement.BluetoothLEAdvertisementReceivedEventArgs", L"IsScannable");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsScannable();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEAdvertisementReceivedEventArgs_get_TransmitPowerLevelInDBm(py::wrapper::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementReceivedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.Advertisement.BluetoothLEAdvertisementReceivedEventArgs", L"TransmitPowerLevelInDBm");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.TransmitPowerLevelInDBm();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEAdvertisementReceivedEventArgs_get_PrimaryPhy(py::wrapper::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementReceivedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.Advertisement.BluetoothLEAdvertisementReceivedEventArgs", L"PrimaryPhy");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PrimaryPhy();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEAdvertisementReceivedEventArgs_get_SecondaryPhy(py::wrapper::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementReceivedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.Advertisement.BluetoothLEAdvertisementReceivedEventArgs", L"SecondaryPhy");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SecondaryPhy();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_BluetoothLEAdvertisementReceivedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementReceivedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_BluetoothLEAdvertisementReceivedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementReceivedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_BluetoothLEAdvertisementReceivedEventArgs[] = {
        { "_assign_array_", _assign_array_BluetoothLEAdvertisementReceivedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_BluetoothLEAdvertisementReceivedEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_BluetoothLEAdvertisementReceivedEventArgs[] = {
        { "advertisement", reinterpret_cast<getter>(BluetoothLEAdvertisementReceivedEventArgs_get_Advertisement), nullptr, nullptr, nullptr },
        { "advertisement_type", reinterpret_cast<getter>(BluetoothLEAdvertisementReceivedEventArgs_get_AdvertisementType), nullptr, nullptr, nullptr },
        { "bluetooth_address", reinterpret_cast<getter>(BluetoothLEAdvertisementReceivedEventArgs_get_BluetoothAddress), nullptr, nullptr, nullptr },
        { "raw_signal_strength_in_dbm", reinterpret_cast<getter>(BluetoothLEAdvertisementReceivedEventArgs_get_RawSignalStrengthInDBm), nullptr, nullptr, nullptr },
        { "timestamp", reinterpret_cast<getter>(BluetoothLEAdvertisementReceivedEventArgs_get_Timestamp), nullptr, nullptr, nullptr },
        { "bluetooth_address_type", reinterpret_cast<getter>(BluetoothLEAdvertisementReceivedEventArgs_get_BluetoothAddressType), nullptr, nullptr, nullptr },
        { "is_anonymous", reinterpret_cast<getter>(BluetoothLEAdvertisementReceivedEventArgs_get_IsAnonymous), nullptr, nullptr, nullptr },
        { "is_connectable", reinterpret_cast<getter>(BluetoothLEAdvertisementReceivedEventArgs_get_IsConnectable), nullptr, nullptr, nullptr },
        { "is_directed", reinterpret_cast<getter>(BluetoothLEAdvertisementReceivedEventArgs_get_IsDirected), nullptr, nullptr, nullptr },
        { "is_scan_response", reinterpret_cast<getter>(BluetoothLEAdvertisementReceivedEventArgs_get_IsScanResponse), nullptr, nullptr, nullptr },
        { "is_scannable", reinterpret_cast<getter>(BluetoothLEAdvertisementReceivedEventArgs_get_IsScannable), nullptr, nullptr, nullptr },
        { "transmit_power_level_in_dbm", reinterpret_cast<getter>(BluetoothLEAdvertisementReceivedEventArgs_get_TransmitPowerLevelInDBm), nullptr, nullptr, nullptr },
        { "primary_phy", reinterpret_cast<getter>(BluetoothLEAdvertisementReceivedEventArgs_get_PrimaryPhy), nullptr, nullptr, nullptr },
        { "secondary_phy", reinterpret_cast<getter>(BluetoothLEAdvertisementReceivedEventArgs_get_SecondaryPhy), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_BluetoothLEAdvertisementReceivedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_BluetoothLEAdvertisementReceivedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_BluetoothLEAdvertisementReceivedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_BluetoothLEAdvertisementReceivedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_BluetoothLEAdvertisementReceivedEventArgs) },
        { }};

    static PyType_Spec type_spec_BluetoothLEAdvertisementReceivedEventArgs = {
        "winrt._winrt_windows_devices_bluetooth_advertisement.BluetoothLEAdvertisementReceivedEventArgs",
        sizeof(py::wrapper::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementReceivedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BluetoothLEAdvertisementReceivedEventArgs};

    // ----- BluetoothLEAdvertisementScanParameters class --------------------

    static PyObject* _new_BluetoothLEAdvertisementScanParameters(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementScanParameters>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementScanParameters>::type_name);
        return nullptr;
    }

    static void _dealloc_BluetoothLEAdvertisementScanParameters(py::wrapper::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementScanParameters* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* BluetoothLEAdvertisementScanParameters_CoexistenceOptimized(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Bluetooth.Advertisement.BluetoothLEAdvertisementScanParameters", L"CoexistenceOptimized", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementScanParameters::CoexistenceOptimized();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BluetoothLEAdvertisementScanParameters_LowLatency(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Bluetooth.Advertisement.BluetoothLEAdvertisementScanParameters", L"LowLatency", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementScanParameters::LowLatency();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BluetoothLEAdvertisementScanParameters_get_ScanInterval(py::wrapper::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementScanParameters* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.Advertisement.BluetoothLEAdvertisementScanParameters", L"ScanInterval");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ScanInterval();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEAdvertisementScanParameters_get_ScanWindow(py::wrapper::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementScanParameters* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.Advertisement.BluetoothLEAdvertisementScanParameters", L"ScanWindow");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ScanWindow();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_BluetoothLEAdvertisementScanParameters(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementScanParameters>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_BluetoothLEAdvertisementScanParameters(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementScanParameters>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_BluetoothLEAdvertisementScanParameters[] = {
        { "_assign_array_", _assign_array_BluetoothLEAdvertisementScanParameters, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_BluetoothLEAdvertisementScanParameters), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_BluetoothLEAdvertisementScanParameters[] = {
        { "scan_interval", reinterpret_cast<getter>(BluetoothLEAdvertisementScanParameters_get_ScanInterval), nullptr, nullptr, nullptr },
        { "scan_window", reinterpret_cast<getter>(BluetoothLEAdvertisementScanParameters_get_ScanWindow), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_BluetoothLEAdvertisementScanParameters[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_BluetoothLEAdvertisementScanParameters) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_BluetoothLEAdvertisementScanParameters) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_BluetoothLEAdvertisementScanParameters) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_BluetoothLEAdvertisementScanParameters) },
        { }};

    static PyType_Spec type_spec_BluetoothLEAdvertisementScanParameters = {
        "winrt._winrt_windows_devices_bluetooth_advertisement.BluetoothLEAdvertisementScanParameters",
        sizeof(py::wrapper::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementScanParameters),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BluetoothLEAdvertisementScanParameters};

    static PyGetSetDef getset_BluetoothLEAdvertisementScanParameters_Static[] = {
        { }};

    static PyMethodDef methods_BluetoothLEAdvertisementScanParameters_Static[] = {
        { "coexistence_optimized", reinterpret_cast<PyCFunction>(BluetoothLEAdvertisementScanParameters_CoexistenceOptimized), METH_VARARGS, nullptr },
        { "low_latency", reinterpret_cast<PyCFunction>(BluetoothLEAdvertisementScanParameters_LowLatency), METH_VARARGS, nullptr },
        { }};

    static PyType_Slot type_slots_BluetoothLEAdvertisementScanParameters_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_BluetoothLEAdvertisementScanParameters_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_BluetoothLEAdvertisementScanParameters_Static) },
        { }
    };

    static PyType_Spec type_spec_BluetoothLEAdvertisementScanParameters_Static = {
        "winrt._winrt_windows_devices_bluetooth_advertisement.BluetoothLEAdvertisementScanParameters_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_BluetoothLEAdvertisementScanParameters_Static};

    // ----- BluetoothLEAdvertisementWatcher class --------------------

    static PyObject* _new_BluetoothLEAdvertisementWatcher(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementWatcher instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementFilter>(args, 0);

                winrt::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementWatcher instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_BluetoothLEAdvertisementWatcher(py::wrapper::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementWatcher* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* BluetoothLEAdvertisementWatcher_Start(py::wrapper::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementWatcher* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Bluetooth.Advertisement.BluetoothLEAdvertisementWatcher", L"Start", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.Start();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BluetoothLEAdvertisementWatcher_Stop(py::wrapper::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementWatcher* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Bluetooth.Advertisement.BluetoothLEAdvertisementWatcher", L"Stop", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.Stop();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BluetoothLEAdvertisementWatcher_get_SignalStrengthFilter(py::wrapper::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementWatcher* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.Advertisement.BluetoothLEAdvertisementWatcher", L"SignalStrengthFilter");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SignalStrengthFilter();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BluetoothLEAdvertisementWatcher_put_SignalStrengthFilter(py::wrapper::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementWatcher* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.Advertisement.BluetoothLEAdvertisementWatcher", L"SignalStrengthFilter");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Devices::Bluetooth::BluetoothSignalStrengthFilter>(arg);

            {
                auto _gil = release_gil();
                self->obj.SignalStrengthFilter(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BluetoothLEAdvertisementWatcher_get_ScanningMode(py::wrapper::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementWatcher* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.Advertisement.BluetoothLEAdvertisementWatcher", L"ScanningMode");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ScanningMode();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BluetoothLEAdvertisementWatcher_put_ScanningMode(py::wrapper::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementWatcher* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.Advertisement.BluetoothLEAdvertisementWatcher", L"ScanningMode");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Devices::Bluetooth::Advertisement::BluetoothLEScanningMode>(arg);

            {
                auto _gil = release_gil();
                self->obj.ScanningMode(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BluetoothLEAdvertisementWatcher_get_AdvertisementFilter(py::wrapper::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementWatcher* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.Advertisement.BluetoothLEAdvertisementWatcher", L"AdvertisementFilter");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.AdvertisementFilter();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BluetoothLEAdvertisementWatcher_put_AdvertisementFilter(py::wrapper::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementWatcher* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.Advertisement.BluetoothLEAdvertisementWatcher", L"AdvertisementFilter");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementFilter>(arg);

            {
                auto _gil = release_gil();
                self->obj.AdvertisementFilter(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BluetoothLEAdvertisementWatcher_get_MaxOutOfRangeTimeout(py::wrapper::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementWatcher* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.Advertisement.BluetoothLEAdvertisementWatcher", L"MaxOutOfRangeTimeout");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.MaxOutOfRangeTimeout();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEAdvertisementWatcher_get_MaxSamplingInterval(py::wrapper::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementWatcher* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.Advertisement.BluetoothLEAdvertisementWatcher", L"MaxSamplingInterval");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.MaxSamplingInterval();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEAdvertisementWatcher_get_MinOutOfRangeTimeout(py::wrapper::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementWatcher* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.Advertisement.BluetoothLEAdvertisementWatcher", L"MinOutOfRangeTimeout");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.MinOutOfRangeTimeout();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEAdvertisementWatcher_get_MinSamplingInterval(py::wrapper::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementWatcher* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.Advertisement.BluetoothLEAdvertisementWatcher", L"MinSamplingInterval");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.MinSamplingInterval();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEAdvertisementWatcher_get_Status(py::wrapper::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementWatcher* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.Advertisement.BluetoothLEAdvertisementWatcher", L"Status");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Status();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEAdvertisementWatcher_get_AllowExtendedAdvertisements(py::wrapper::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementWatcher* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.Advertisement.BluetoothLEAdvertisementWatcher", L"AllowExtendedAdvertisements");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.AllowExtendedAdvertisements();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BluetoothLEAdvertisementWatcher_put_AllowExtendedAdvertisements(py::wrapper::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementWatcher* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.Advertisement.BluetoothLEAdvertisementWatcher", L"AllowExtendedAdvertisements");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.AllowExtendedAdvertisements(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BluetoothLEAdvertisementWatcher_get_UseUncoded1MPhy(py::wrapper::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementWatcher* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.Advertisement.BluetoothLEAdvertisementWatcher", L"UseUncoded1MPhy");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.UseUncoded1MPhy();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BluetoothLEAdvertisementWatcher_put_UseUncoded1MPhy(py::wrapper::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementWatcher* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.Advertisement.BluetoothLEAdvertisementWatcher", L"UseUncoded1MPhy");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.UseUncoded1MPhy(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BluetoothLEAdvertisementWatcher_get_UseHardwareFilter(py::wrapper::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementWatcher* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.Advertisement.BluetoothLEAdvertisementWatcher", L"UseHardwareFilter");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.UseHardwareFilter();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BluetoothLEAdvertisementWatcher_put_UseHardwareFilter(py::wrapper::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementWatcher* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.Advertisement.BluetoothLEAdvertisementWatcher", L"UseHardwareFilter");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.UseHardwareFilter(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BluetoothLEAdvertisementWatcher_get_UseCodedPhy(py::wrapper::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementWatcher* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.Advertisement.BluetoothLEAdvertisementWatcher", L"UseCodedPhy");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.UseCodedPhy();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BluetoothLEAdvertisementWatcher_put_UseCodedPhy(py::wrapper::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementWatcher* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.Advertisement.BluetoothLEAdvertisementWatcher", L"UseCodedPhy");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.UseCodedPhy(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BluetoothLEAdvertisementWatcher_get_ScanParameters(py::wrapper::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementWatcher* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.Advertisement.BluetoothLEAdvertisementWatcher", L"ScanParameters");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ScanParameters();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BluetoothLEAdvertisementWatcher_put_ScanParameters(py::wrapper::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementWatcher* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.Advertisement.BluetoothLEAdvertisementWatcher", L"ScanParameters");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementScanParameters>(arg);

            {
                auto _gil = release_gil();
                self->obj.ScanParameters(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BluetoothLEAdvertisementWatcher_add_Received(py::wrapper::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementWatcher* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Bluetooth.Advertisement.BluetoothLEAdvertisementWatcher", L"Received");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementWatcher, winrt::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementReceivedEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Received(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEAdvertisementWatcher_remove_Received(py::wrapper::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementWatcher* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Bluetooth.Advertisement.BluetoothLEAdvertisementWatcher", L"Received");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.Received(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEAdvertisementWatcher_add_Stopped(py::wrapper::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementWatcher* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Bluetooth.Advertisement.BluetoothLEAdvertisementWatcher", L"Stopped");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementWatcher, winrt::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementWatcherStoppedEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Stopped(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEAdvertisementWatcher_remove_Stopped(py::wrapper::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementWatcher* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Bluetooth.Advertisement.BluetoothLEAdvertisementWatcher", L"Stopped");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.Stopped(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_BluetoothLEAdvertisementWatcher(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementWatcher>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_BluetoothLEAdvertisementWatcher(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementWatcher>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_BluetoothLEAdvertisementWatcher[] = {
        { "start", reinterpret_cast<PyCFunction>(BluetoothLEAdvertisementWatcher_Start), METH_VARARGS, nullptr },
        { "stop", reinterpret_cast<PyCFunction>(BluetoothLEAdvertisementWatcher_Stop), METH_VARARGS, nullptr },
        { "add_received", reinterpret_cast<PyCFunction>(BluetoothLEAdvertisementWatcher_add_Received), METH_O, nullptr },
        { "remove_received", reinterpret_cast<PyCFunction>(BluetoothLEAdvertisementWatcher_remove_Received), METH_O, nullptr },
        { "add_stopped", reinterpret_cast<PyCFunction>(BluetoothLEAdvertisementWatcher_add_Stopped), METH_O, nullptr },
        { "remove_stopped", reinterpret_cast<PyCFunction>(BluetoothLEAdvertisementWatcher_remove_Stopped), METH_O, nullptr },
        { "_assign_array_", _assign_array_BluetoothLEAdvertisementWatcher, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_BluetoothLEAdvertisementWatcher), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_BluetoothLEAdvertisementWatcher[] = {
        { "signal_strength_filter", reinterpret_cast<getter>(BluetoothLEAdvertisementWatcher_get_SignalStrengthFilter), reinterpret_cast<setter>(BluetoothLEAdvertisementWatcher_put_SignalStrengthFilter), nullptr, nullptr },
        { "scanning_mode", reinterpret_cast<getter>(BluetoothLEAdvertisementWatcher_get_ScanningMode), reinterpret_cast<setter>(BluetoothLEAdvertisementWatcher_put_ScanningMode), nullptr, nullptr },
        { "advertisement_filter", reinterpret_cast<getter>(BluetoothLEAdvertisementWatcher_get_AdvertisementFilter), reinterpret_cast<setter>(BluetoothLEAdvertisementWatcher_put_AdvertisementFilter), nullptr, nullptr },
        { "max_out_of_range_timeout", reinterpret_cast<getter>(BluetoothLEAdvertisementWatcher_get_MaxOutOfRangeTimeout), nullptr, nullptr, nullptr },
        { "max_sampling_interval", reinterpret_cast<getter>(BluetoothLEAdvertisementWatcher_get_MaxSamplingInterval), nullptr, nullptr, nullptr },
        { "min_out_of_range_timeout", reinterpret_cast<getter>(BluetoothLEAdvertisementWatcher_get_MinOutOfRangeTimeout), nullptr, nullptr, nullptr },
        { "min_sampling_interval", reinterpret_cast<getter>(BluetoothLEAdvertisementWatcher_get_MinSamplingInterval), nullptr, nullptr, nullptr },
        { "status", reinterpret_cast<getter>(BluetoothLEAdvertisementWatcher_get_Status), nullptr, nullptr, nullptr },
        { "allow_extended_advertisements", reinterpret_cast<getter>(BluetoothLEAdvertisementWatcher_get_AllowExtendedAdvertisements), reinterpret_cast<setter>(BluetoothLEAdvertisementWatcher_put_AllowExtendedAdvertisements), nullptr, nullptr },
        { "use_uncoded1_m_phy", reinterpret_cast<getter>(BluetoothLEAdvertisementWatcher_get_UseUncoded1MPhy), reinterpret_cast<setter>(BluetoothLEAdvertisementWatcher_put_UseUncoded1MPhy), nullptr, nullptr },
        { "use_hardware_filter", reinterpret_cast<getter>(BluetoothLEAdvertisementWatcher_get_UseHardwareFilter), reinterpret_cast<setter>(BluetoothLEAdvertisementWatcher_put_UseHardwareFilter), nullptr, nullptr },
        { "use_coded_phy", reinterpret_cast<getter>(BluetoothLEAdvertisementWatcher_get_UseCodedPhy), reinterpret_cast<setter>(BluetoothLEAdvertisementWatcher_put_UseCodedPhy), nullptr, nullptr },
        { "scan_parameters", reinterpret_cast<getter>(BluetoothLEAdvertisementWatcher_get_ScanParameters), reinterpret_cast<setter>(BluetoothLEAdvertisementWatcher_put_ScanParameters), nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_BluetoothLEAdvertisementWatcher[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_BluetoothLEAdvertisementWatcher) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_BluetoothLEAdvertisementWatcher) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_BluetoothLEAdvertisementWatcher) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_BluetoothLEAdvertisementWatcher) },
        { }};

    static PyType_Spec type_spec_BluetoothLEAdvertisementWatcher = {
        "winrt._winrt_windows_devices_bluetooth_advertisement.BluetoothLEAdvertisementWatcher",
        sizeof(py::wrapper::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementWatcher),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BluetoothLEAdvertisementWatcher};

    // ----- BluetoothLEAdvertisementWatcherStoppedEventArgs class --------------------

    static PyObject* _new_BluetoothLEAdvertisementWatcherStoppedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementWatcherStoppedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementWatcherStoppedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_BluetoothLEAdvertisementWatcherStoppedEventArgs(py::wrapper::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementWatcherStoppedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* BluetoothLEAdvertisementWatcherStoppedEventArgs_get_Error(py::wrapper::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementWatcherStoppedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.Advertisement.BluetoothLEAdvertisementWatcherStoppedEventArgs", L"Error");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Error();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_BluetoothLEAdvertisementWatcherStoppedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementWatcherStoppedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_BluetoothLEAdvertisementWatcherStoppedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementWatcherStoppedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_BluetoothLEAdvertisementWatcherStoppedEventArgs[] = {
        { "_assign_array_", _assign_array_BluetoothLEAdvertisementWatcherStoppedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_BluetoothLEAdvertisementWatcherStoppedEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_BluetoothLEAdvertisementWatcherStoppedEventArgs[] = {
        { "error", reinterpret_cast<getter>(BluetoothLEAdvertisementWatcherStoppedEventArgs_get_Error), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_BluetoothLEAdvertisementWatcherStoppedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_BluetoothLEAdvertisementWatcherStoppedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_BluetoothLEAdvertisementWatcherStoppedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_BluetoothLEAdvertisementWatcherStoppedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_BluetoothLEAdvertisementWatcherStoppedEventArgs) },
        { }};

    static PyType_Spec type_spec_BluetoothLEAdvertisementWatcherStoppedEventArgs = {
        "winrt._winrt_windows_devices_bluetooth_advertisement.BluetoothLEAdvertisementWatcherStoppedEventArgs",
        sizeof(py::wrapper::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementWatcherStoppedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BluetoothLEAdvertisementWatcherStoppedEventArgs};

    // ----- BluetoothLEManufacturerData class --------------------

    static PyObject* _new_BluetoothLEManufacturerData(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Devices::Bluetooth::Advertisement::BluetoothLEManufacturerData instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<uint16_t>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 1);

                winrt::Windows::Devices::Bluetooth::Advertisement::BluetoothLEManufacturerData instance{param0, param1};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_BluetoothLEManufacturerData(py::wrapper::Windows::Devices::Bluetooth::Advertisement::BluetoothLEManufacturerData* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* BluetoothLEManufacturerData_get_Data(py::wrapper::Windows::Devices::Bluetooth::Advertisement::BluetoothLEManufacturerData* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.Advertisement.BluetoothLEManufacturerData", L"Data");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Data();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BluetoothLEManufacturerData_put_Data(py::wrapper::Windows::Devices::Bluetooth::Advertisement::BluetoothLEManufacturerData* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.Advertisement.BluetoothLEManufacturerData", L"Data");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(arg);

            {
                auto _gil = release_gil();
                self->obj.Data(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BluetoothLEManufacturerData_get_CompanyId(py::wrapper::Windows::Devices::Bluetooth::Advertisement::BluetoothLEManufacturerData* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.Advertisement.BluetoothLEManufacturerData", L"CompanyId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.CompanyId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BluetoothLEManufacturerData_put_CompanyId(py::wrapper::Windows::Devices::Bluetooth::Advertisement::BluetoothLEManufacturerData* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.Advertisement.BluetoothLEManufacturerData", L"CompanyId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<uint16_t>(arg);

            {
                auto _gil = release_gil();
                self->obj.CompanyId(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_BluetoothLEManufacturerData(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Bluetooth::Advertisement::BluetoothLEManufacturerData>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_BluetoothLEManufacturerData(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Bluetooth::Advertisement::BluetoothLEManufacturerData>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_BluetoothLEManufacturerData[] = {
        { "_assign_array_", _assign_array_BluetoothLEManufacturerData, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_BluetoothLEManufacturerData), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_BluetoothLEManufacturerData[] = {
        { "data", reinterpret_cast<getter>(BluetoothLEManufacturerData_get_Data), reinterpret_cast<setter>(BluetoothLEManufacturerData_put_Data), nullptr, nullptr },
        { "company_id", reinterpret_cast<getter>(BluetoothLEManufacturerData_get_CompanyId), reinterpret_cast<setter>(BluetoothLEManufacturerData_put_CompanyId), nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_BluetoothLEManufacturerData[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_BluetoothLEManufacturerData) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_BluetoothLEManufacturerData) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_BluetoothLEManufacturerData) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_BluetoothLEManufacturerData) },
        { }};

    static PyType_Spec type_spec_BluetoothLEManufacturerData = {
        "winrt._winrt_windows_devices_bluetooth_advertisement.BluetoothLEManufacturerData",
        sizeof(py::wrapper::Windows::Devices::Bluetooth::Advertisement::BluetoothLEManufacturerData),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BluetoothLEManufacturerData};

    // ----- Windows.Devices.Bluetooth.Advertisement Initialization --------------------

    PyDoc_STRVAR(module_doc, "Windows.Devices.Bluetooth.Advertisement");

    static PyModuleDef module_def = {
        PyModuleDef_HEAD_INIT,
        "_winrt_windows_devices_bluetooth_advertisement",
        module_doc,
        0,
        nullptr,
        nullptr,
        nullptr,
        nullptr,
        nullptr};
} // py::cpp::Windows::Devices::Bluetooth::Advertisement

PyMODINIT_FUNC PyInit__winrt_windows_devices_bluetooth_advertisement(void) noexcept
{
    using namespace py::cpp::Windows::Devices::Bluetooth::Advertisement;

    if (py::import_winrt_runtime() == -1)
    {
        return nullptr;
    }

    py::pyobj_handle module{PyModule_Create(&module_def)};

    if (!module)
    {
        return nullptr;
    }

    auto inspectable_meta_type = py::get_inspectable_meta_type();
    if (!inspectable_meta_type)
    {
        return nullptr;
    }

    auto object_type = py::get_object_type();
    if (!object_type)
    {
        return nullptr;
    }

    py::pyobj_handle object_bases{PyTuple_Pack(1, object_type)};

    if (!object_bases)
    {
        return nullptr;
    }

    py::pytype_handle BluetoothLEAdvertisement_type{py::register_python_type(module.get(), &type_spec_BluetoothLEAdvertisement, object_bases.get(), inspectable_meta_type)};
    if (!BluetoothLEAdvertisement_type)
    {
        return nullptr;
    }

    py::pytype_handle BluetoothLEAdvertisementBytePattern_type{py::register_python_type(module.get(), &type_spec_BluetoothLEAdvertisementBytePattern, object_bases.get(), inspectable_meta_type)};
    if (!BluetoothLEAdvertisementBytePattern_type)
    {
        return nullptr;
    }

    py::pytype_handle BluetoothLEAdvertisementDataSection_type{py::register_python_type(module.get(), &type_spec_BluetoothLEAdvertisementDataSection, object_bases.get(), inspectable_meta_type)};
    if (!BluetoothLEAdvertisementDataSection_type)
    {
        return nullptr;
    }

    py::pyobj_handle BluetoothLEAdvertisementDataTypes_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(inspectable_meta_type))};
    if (!BluetoothLEAdvertisementDataTypes_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_BluetoothLEAdvertisementDataTypes_Static{PyType_FromSpecWithBases(&type_spec_BluetoothLEAdvertisementDataTypes_Static, BluetoothLEAdvertisementDataTypes_Static_bases.get())};
    if (!type_BluetoothLEAdvertisementDataTypes_Static)
    {
        return nullptr;
    }

    py::pytype_handle BluetoothLEAdvertisementDataTypes_type{py::register_python_type(module.get(), &type_spec_BluetoothLEAdvertisementDataTypes, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_BluetoothLEAdvertisementDataTypes_Static.get()))};
    if (!BluetoothLEAdvertisementDataTypes_type)
    {
        return nullptr;
    }

    py::pytype_handle BluetoothLEAdvertisementFilter_type{py::register_python_type(module.get(), &type_spec_BluetoothLEAdvertisementFilter, object_bases.get(), inspectable_meta_type)};
    if (!BluetoothLEAdvertisementFilter_type)
    {
        return nullptr;
    }

    py::pytype_handle BluetoothLEAdvertisementPublisher_type{py::register_python_type(module.get(), &type_spec_BluetoothLEAdvertisementPublisher, object_bases.get(), inspectable_meta_type)};
    if (!BluetoothLEAdvertisementPublisher_type)
    {
        return nullptr;
    }

    py::pytype_handle BluetoothLEAdvertisementPublisherStatusChangedEventArgs_type{py::register_python_type(module.get(), &type_spec_BluetoothLEAdvertisementPublisherStatusChangedEventArgs, object_bases.get(), inspectable_meta_type)};
    if (!BluetoothLEAdvertisementPublisherStatusChangedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle BluetoothLEAdvertisementReceivedEventArgs_type{py::register_python_type(module.get(), &type_spec_BluetoothLEAdvertisementReceivedEventArgs, object_bases.get(), inspectable_meta_type)};
    if (!BluetoothLEAdvertisementReceivedEventArgs_type)
    {
        return nullptr;
    }

    py::pyobj_handle BluetoothLEAdvertisementScanParameters_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(inspectable_meta_type))};
    if (!BluetoothLEAdvertisementScanParameters_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_BluetoothLEAdvertisementScanParameters_Static{PyType_FromSpecWithBases(&type_spec_BluetoothLEAdvertisementScanParameters_Static, BluetoothLEAdvertisementScanParameters_Static_bases.get())};
    if (!type_BluetoothLEAdvertisementScanParameters_Static)
    {
        return nullptr;
    }

    py::pytype_handle BluetoothLEAdvertisementScanParameters_type{py::register_python_type(module.get(), &type_spec_BluetoothLEAdvertisementScanParameters, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_BluetoothLEAdvertisementScanParameters_Static.get()))};
    if (!BluetoothLEAdvertisementScanParameters_type)
    {
        return nullptr;
    }

    py::pytype_handle BluetoothLEAdvertisementWatcher_type{py::register_python_type(module.get(), &type_spec_BluetoothLEAdvertisementWatcher, object_bases.get(), inspectable_meta_type)};
    if (!BluetoothLEAdvertisementWatcher_type)
    {
        return nullptr;
    }

    py::pytype_handle BluetoothLEAdvertisementWatcherStoppedEventArgs_type{py::register_python_type(module.get(), &type_spec_BluetoothLEAdvertisementWatcherStoppedEventArgs, object_bases.get(), inspectable_meta_type)};
    if (!BluetoothLEAdvertisementWatcherStoppedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle BluetoothLEManufacturerData_type{py::register_python_type(module.get(), &type_spec_BluetoothLEManufacturerData, object_bases.get(), inspectable_meta_type)};
    if (!BluetoothLEManufacturerData_type)
    {
        return nullptr;
    }


    return module.detach();
}
