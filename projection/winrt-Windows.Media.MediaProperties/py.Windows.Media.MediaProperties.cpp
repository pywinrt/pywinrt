// WARNING: Please don't edit this file. It was generated by Python/WinRT v0.0.0

#include "py.Windows.Media.MediaProperties.h"


namespace py::cpp::Windows::Media::MediaProperties
{
    // ----- AudioEncodingProperties class --------------------

    static PyObject* _new_AudioEncodingProperties(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Media::MediaProperties::AudioEncodingProperties instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_AudioEncodingProperties(py::wrapper::Windows::Media::MediaProperties::AudioEncodingProperties* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AudioEncodingProperties_Copy(py::wrapper::Windows::Media::MediaProperties::AudioEncodingProperties* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.MediaProperties.AudioEncodingProperties", L"Copy", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.Copy());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioEncodingProperties_CreateAac(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.MediaProperties.AudioEncodingProperties", L"CreateAac", 3))
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);
                auto param2 = py::convert_to<uint32_t>(args, 2);

                return py::convert(winrt::Windows::Media::MediaProperties::AudioEncodingProperties::CreateAac(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioEncodingProperties_CreateAacAdts(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.MediaProperties.AudioEncodingProperties", L"CreateAacAdts", 3))
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);
                auto param2 = py::convert_to<uint32_t>(args, 2);

                return py::convert(winrt::Windows::Media::MediaProperties::AudioEncodingProperties::CreateAacAdts(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioEncodingProperties_CreateAlac(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.MediaProperties.AudioEncodingProperties", L"CreateAlac", 3))
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);
                auto param2 = py::convert_to<uint32_t>(args, 2);

                return py::convert(winrt::Windows::Media::MediaProperties::AudioEncodingProperties::CreateAlac(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioEncodingProperties_CreateFlac(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.MediaProperties.AudioEncodingProperties", L"CreateFlac", 3))
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);
                auto param2 = py::convert_to<uint32_t>(args, 2);

                return py::convert(winrt::Windows::Media::MediaProperties::AudioEncodingProperties::CreateFlac(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioEncodingProperties_CreateMp3(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.MediaProperties.AudioEncodingProperties", L"CreateMp3", 3))
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);
                auto param2 = py::convert_to<uint32_t>(args, 2);

                return py::convert(winrt::Windows::Media::MediaProperties::AudioEncodingProperties::CreateMp3(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioEncodingProperties_CreatePcm(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.MediaProperties.AudioEncodingProperties", L"CreatePcm", 3))
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);
                auto param2 = py::convert_to<uint32_t>(args, 2);

                return py::convert(winrt::Windows::Media::MediaProperties::AudioEncodingProperties::CreatePcm(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioEncodingProperties_CreateWma(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.MediaProperties.AudioEncodingProperties", L"CreateWma", 3))
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);
                auto param2 = py::convert_to<uint32_t>(args, 2);

                return py::convert(winrt::Windows::Media::MediaProperties::AudioEncodingProperties::CreateWma(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioEncodingProperties_GetFormatUserData(py::wrapper::Windows::Media::MediaProperties::AudioEncodingProperties* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.MediaProperties.AudioEncodingProperties", L"GetFormatUserData", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                winrt::com_array<uint8_t> param0 { };

                self->obj.GetFormatUserData(param0);

                py::pyobj_handle out0{ py::convert(param0) };
                if (!out0)
                {
                    return nullptr;
                }
                return out0.detach();
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioEncodingProperties_SetFormatUserData(py::wrapper::Windows::Media::MediaProperties::AudioEncodingProperties* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.MediaProperties.AudioEncodingProperties", L"SetFormatUserData", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<py::pybuf_view<uint8_t, false>>(args, 0);

                self->obj.SetFormatUserData(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioEncodingProperties_get_SampleRate(py::wrapper::Windows::Media::MediaProperties::AudioEncodingProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.AudioEncodingProperties", L"SampleRate"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SampleRate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AudioEncodingProperties_put_SampleRate(py::wrapper::Windows::Media::MediaProperties::AudioEncodingProperties* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.AudioEncodingProperties", L"SampleRate"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.SampleRate(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AudioEncodingProperties_get_ChannelCount(py::wrapper::Windows::Media::MediaProperties::AudioEncodingProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.AudioEncodingProperties", L"ChannelCount"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ChannelCount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AudioEncodingProperties_put_ChannelCount(py::wrapper::Windows::Media::MediaProperties::AudioEncodingProperties* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.AudioEncodingProperties", L"ChannelCount"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.ChannelCount(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AudioEncodingProperties_get_BitsPerSample(py::wrapper::Windows::Media::MediaProperties::AudioEncodingProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.AudioEncodingProperties", L"BitsPerSample"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.BitsPerSample());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AudioEncodingProperties_put_BitsPerSample(py::wrapper::Windows::Media::MediaProperties::AudioEncodingProperties* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.AudioEncodingProperties", L"BitsPerSample"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.BitsPerSample(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AudioEncodingProperties_get_Bitrate(py::wrapper::Windows::Media::MediaProperties::AudioEncodingProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.AudioEncodingProperties", L"Bitrate"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Bitrate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AudioEncodingProperties_put_Bitrate(py::wrapper::Windows::Media::MediaProperties::AudioEncodingProperties* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.AudioEncodingProperties", L"Bitrate"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.Bitrate(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AudioEncodingProperties_get_IsSpatial(py::wrapper::Windows::Media::MediaProperties::AudioEncodingProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.AudioEncodingProperties", L"IsSpatial"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsSpatial());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioEncodingProperties_get_Subtype(py::wrapper::Windows::Media::MediaProperties::AudioEncodingProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.AudioEncodingProperties", L"Subtype"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Subtype());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AudioEncodingProperties_put_Subtype(py::wrapper::Windows::Media::MediaProperties::AudioEncodingProperties* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.AudioEncodingProperties", L"Subtype"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Subtype(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AudioEncodingProperties_get_Properties(py::wrapper::Windows::Media::MediaProperties::AudioEncodingProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.AudioEncodingProperties", L"Properties"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Properties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioEncodingProperties_get_Type(py::wrapper::Windows::Media::MediaProperties::AudioEncodingProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.AudioEncodingProperties", L"Type"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Type());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AudioEncodingProperties(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::MediaProperties::AudioEncodingProperties>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AudioEncodingProperties(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::MediaProperties::AudioEncodingProperties>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AudioEncodingProperties[] = {
        { "copy", reinterpret_cast<PyCFunction>(AudioEncodingProperties_Copy), METH_VARARGS, nullptr },
        { "get_format_user_data", reinterpret_cast<PyCFunction>(AudioEncodingProperties_GetFormatUserData), METH_VARARGS, nullptr },
        { "set_format_user_data", reinterpret_cast<PyCFunction>(AudioEncodingProperties_SetFormatUserData), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_AudioEncodingProperties, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AudioEncodingProperties), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AudioEncodingProperties[] = {
        { "sample_rate", reinterpret_cast<getter>(AudioEncodingProperties_get_SampleRate), reinterpret_cast<setter>(AudioEncodingProperties_put_SampleRate), nullptr, nullptr },
        { "channel_count", reinterpret_cast<getter>(AudioEncodingProperties_get_ChannelCount), reinterpret_cast<setter>(AudioEncodingProperties_put_ChannelCount), nullptr, nullptr },
        { "bits_per_sample", reinterpret_cast<getter>(AudioEncodingProperties_get_BitsPerSample), reinterpret_cast<setter>(AudioEncodingProperties_put_BitsPerSample), nullptr, nullptr },
        { "bitrate", reinterpret_cast<getter>(AudioEncodingProperties_get_Bitrate), reinterpret_cast<setter>(AudioEncodingProperties_put_Bitrate), nullptr, nullptr },
        { "is_spatial", reinterpret_cast<getter>(AudioEncodingProperties_get_IsSpatial), nullptr, nullptr, nullptr },
        { "subtype", reinterpret_cast<getter>(AudioEncodingProperties_get_Subtype), reinterpret_cast<setter>(AudioEncodingProperties_put_Subtype), nullptr, nullptr },
        { "properties", reinterpret_cast<getter>(AudioEncodingProperties_get_Properties), nullptr, nullptr, nullptr },
        { "type", reinterpret_cast<getter>(AudioEncodingProperties_get_Type), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AudioEncodingProperties[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AudioEncodingProperties) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AudioEncodingProperties) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AudioEncodingProperties) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AudioEncodingProperties) },
        { },
    };

    static PyType_Spec type_spec_AudioEncodingProperties =
    {
        "winrt._winrt_windows_media_mediaproperties.AudioEncodingProperties",
        sizeof(py::wrapper::Windows::Media::MediaProperties::AudioEncodingProperties),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AudioEncodingProperties
    };

    static PyGetSetDef getset_AudioEncodingProperties_Static[] = {
        { }
    };

    static PyMethodDef methods_AudioEncodingProperties_Static[] = {
        { "create_aac", reinterpret_cast<PyCFunction>(AudioEncodingProperties_CreateAac), METH_VARARGS, nullptr },
        { "create_aac_adts", reinterpret_cast<PyCFunction>(AudioEncodingProperties_CreateAacAdts), METH_VARARGS, nullptr },
        { "create_alac", reinterpret_cast<PyCFunction>(AudioEncodingProperties_CreateAlac), METH_VARARGS, nullptr },
        { "create_flac", reinterpret_cast<PyCFunction>(AudioEncodingProperties_CreateFlac), METH_VARARGS, nullptr },
        { "create_mp3", reinterpret_cast<PyCFunction>(AudioEncodingProperties_CreateMp3), METH_VARARGS, nullptr },
        { "create_pcm", reinterpret_cast<PyCFunction>(AudioEncodingProperties_CreatePcm), METH_VARARGS, nullptr },
        { "create_wma", reinterpret_cast<PyCFunction>(AudioEncodingProperties_CreateWma), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_AudioEncodingProperties_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_AudioEncodingProperties_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_AudioEncodingProperties_Static) },
        { }
    };

    static PyType_Spec type_spec_AudioEncodingProperties_Static =
    {
        "winrt._winrt_windows_media_mediaproperties.AudioEncodingProperties_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_AudioEncodingProperties_Static
    };

    // ----- Av1ProfileIds class --------------------

    static PyObject* _new_Av1ProfileIds(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::MediaProperties::Av1ProfileIds>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::MediaProperties::Av1ProfileIds>::type_name);
        return nullptr;
    }

    static PyObject* Av1ProfileIds_get_HighChromaSubsampling444BitDepth10(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.Av1ProfileIds", L"HighChromaSubsampling444BitDepth10"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Media::MediaProperties::Av1ProfileIds::HighChromaSubsampling444BitDepth10());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Av1ProfileIds_get_HighChromaSubsampling444BitDepth8(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.Av1ProfileIds", L"HighChromaSubsampling444BitDepth8"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Media::MediaProperties::Av1ProfileIds::HighChromaSubsampling444BitDepth8());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Av1ProfileIds_get_MainChromaSubsampling400BitDepth10(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.Av1ProfileIds", L"MainChromaSubsampling400BitDepth10"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Media::MediaProperties::Av1ProfileIds::MainChromaSubsampling400BitDepth10());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Av1ProfileIds_get_MainChromaSubsampling400BitDepth8(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.Av1ProfileIds", L"MainChromaSubsampling400BitDepth8"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Media::MediaProperties::Av1ProfileIds::MainChromaSubsampling400BitDepth8());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Av1ProfileIds_get_MainChromaSubsampling420BitDepth10(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.Av1ProfileIds", L"MainChromaSubsampling420BitDepth10"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Media::MediaProperties::Av1ProfileIds::MainChromaSubsampling420BitDepth10());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Av1ProfileIds_get_MainChromaSubsampling420BitDepth8(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.Av1ProfileIds", L"MainChromaSubsampling420BitDepth8"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Media::MediaProperties::Av1ProfileIds::MainChromaSubsampling420BitDepth8());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Av1ProfileIds_get_ProfessionalChromaSubsampling400BitDepth12(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.Av1ProfileIds", L"ProfessionalChromaSubsampling400BitDepth12"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Media::MediaProperties::Av1ProfileIds::ProfessionalChromaSubsampling400BitDepth12());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Av1ProfileIds_get_ProfessionalChromaSubsampling420BitDepth12(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.Av1ProfileIds", L"ProfessionalChromaSubsampling420BitDepth12"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Media::MediaProperties::Av1ProfileIds::ProfessionalChromaSubsampling420BitDepth12());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Av1ProfileIds_get_ProfessionalChromaSubsampling422BitDepth10(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.Av1ProfileIds", L"ProfessionalChromaSubsampling422BitDepth10"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Media::MediaProperties::Av1ProfileIds::ProfessionalChromaSubsampling422BitDepth10());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Av1ProfileIds_get_ProfessionalChromaSubsampling422BitDepth12(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.Av1ProfileIds", L"ProfessionalChromaSubsampling422BitDepth12"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Media::MediaProperties::Av1ProfileIds::ProfessionalChromaSubsampling422BitDepth12());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Av1ProfileIds_get_ProfessionalChromaSubsampling422BitDepth8(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.Av1ProfileIds", L"ProfessionalChromaSubsampling422BitDepth8"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Media::MediaProperties::Av1ProfileIds::ProfessionalChromaSubsampling422BitDepth8());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Av1ProfileIds_get_ProfessionalChromaSubsampling444BitDepth12(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.Av1ProfileIds", L"ProfessionalChromaSubsampling444BitDepth12"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Media::MediaProperties::Av1ProfileIds::ProfessionalChromaSubsampling444BitDepth12());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_Av1ProfileIds[] = {
        { }
    };

    static PyGetSetDef _getset_Av1ProfileIds[] = {
        { }
    };

    static PyType_Slot _type_slots_Av1ProfileIds[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_Av1ProfileIds) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_Av1ProfileIds) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_Av1ProfileIds) },
        { },
    };

    static PyType_Spec type_spec_Av1ProfileIds =
    {
        "winrt._winrt_windows_media_mediaproperties.Av1ProfileIds",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_Av1ProfileIds
    };

    static PyGetSetDef getset_Av1ProfileIds_Static[] = {
        { "high_chroma_subsampling444_bit_depth10", reinterpret_cast<getter>(Av1ProfileIds_get_HighChromaSubsampling444BitDepth10), nullptr, nullptr, nullptr },
        { "high_chroma_subsampling444_bit_depth8", reinterpret_cast<getter>(Av1ProfileIds_get_HighChromaSubsampling444BitDepth8), nullptr, nullptr, nullptr },
        { "main_chroma_subsampling400_bit_depth10", reinterpret_cast<getter>(Av1ProfileIds_get_MainChromaSubsampling400BitDepth10), nullptr, nullptr, nullptr },
        { "main_chroma_subsampling400_bit_depth8", reinterpret_cast<getter>(Av1ProfileIds_get_MainChromaSubsampling400BitDepth8), nullptr, nullptr, nullptr },
        { "main_chroma_subsampling420_bit_depth10", reinterpret_cast<getter>(Av1ProfileIds_get_MainChromaSubsampling420BitDepth10), nullptr, nullptr, nullptr },
        { "main_chroma_subsampling420_bit_depth8", reinterpret_cast<getter>(Av1ProfileIds_get_MainChromaSubsampling420BitDepth8), nullptr, nullptr, nullptr },
        { "professional_chroma_subsampling400_bit_depth12", reinterpret_cast<getter>(Av1ProfileIds_get_ProfessionalChromaSubsampling400BitDepth12), nullptr, nullptr, nullptr },
        { "professional_chroma_subsampling420_bit_depth12", reinterpret_cast<getter>(Av1ProfileIds_get_ProfessionalChromaSubsampling420BitDepth12), nullptr, nullptr, nullptr },
        { "professional_chroma_subsampling422_bit_depth10", reinterpret_cast<getter>(Av1ProfileIds_get_ProfessionalChromaSubsampling422BitDepth10), nullptr, nullptr, nullptr },
        { "professional_chroma_subsampling422_bit_depth12", reinterpret_cast<getter>(Av1ProfileIds_get_ProfessionalChromaSubsampling422BitDepth12), nullptr, nullptr, nullptr },
        { "professional_chroma_subsampling422_bit_depth8", reinterpret_cast<getter>(Av1ProfileIds_get_ProfessionalChromaSubsampling422BitDepth8), nullptr, nullptr, nullptr },
        { "professional_chroma_subsampling444_bit_depth12", reinterpret_cast<getter>(Av1ProfileIds_get_ProfessionalChromaSubsampling444BitDepth12), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_Av1ProfileIds_Static[] = {
        { }
    };

    static PyType_Slot type_slots_Av1ProfileIds_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_Av1ProfileIds_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_Av1ProfileIds_Static) },
        { }
    };

    static PyType_Spec type_spec_Av1ProfileIds_Static =
    {
        "winrt._winrt_windows_media_mediaproperties.Av1ProfileIds_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_Av1ProfileIds_Static
    };

    // ----- ContainerEncodingProperties class --------------------

    static PyObject* _new_ContainerEncodingProperties(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Media::MediaProperties::ContainerEncodingProperties instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ContainerEncodingProperties(py::wrapper::Windows::Media::MediaProperties::ContainerEncodingProperties* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ContainerEncodingProperties_Copy(py::wrapper::Windows::Media::MediaProperties::ContainerEncodingProperties* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.MediaProperties.ContainerEncodingProperties", L"Copy", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.Copy());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContainerEncodingProperties_get_Subtype(py::wrapper::Windows::Media::MediaProperties::ContainerEncodingProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.ContainerEncodingProperties", L"Subtype"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Subtype());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContainerEncodingProperties_put_Subtype(py::wrapper::Windows::Media::MediaProperties::ContainerEncodingProperties* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.ContainerEncodingProperties", L"Subtype"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Subtype(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContainerEncodingProperties_get_Properties(py::wrapper::Windows::Media::MediaProperties::ContainerEncodingProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.ContainerEncodingProperties", L"Properties"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Properties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContainerEncodingProperties_get_Type(py::wrapper::Windows::Media::MediaProperties::ContainerEncodingProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.ContainerEncodingProperties", L"Type"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Type());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ContainerEncodingProperties(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::MediaProperties::ContainerEncodingProperties>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ContainerEncodingProperties(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::MediaProperties::ContainerEncodingProperties>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ContainerEncodingProperties[] = {
        { "copy", reinterpret_cast<PyCFunction>(ContainerEncodingProperties_Copy), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_ContainerEncodingProperties, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ContainerEncodingProperties), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ContainerEncodingProperties[] = {
        { "subtype", reinterpret_cast<getter>(ContainerEncodingProperties_get_Subtype), reinterpret_cast<setter>(ContainerEncodingProperties_put_Subtype), nullptr, nullptr },
        { "properties", reinterpret_cast<getter>(ContainerEncodingProperties_get_Properties), nullptr, nullptr, nullptr },
        { "type", reinterpret_cast<getter>(ContainerEncodingProperties_get_Type), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ContainerEncodingProperties[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ContainerEncodingProperties) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ContainerEncodingProperties) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ContainerEncodingProperties) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ContainerEncodingProperties) },
        { },
    };

    static PyType_Spec type_spec_ContainerEncodingProperties =
    {
        "winrt._winrt_windows_media_mediaproperties.ContainerEncodingProperties",
        sizeof(py::wrapper::Windows::Media::MediaProperties::ContainerEncodingProperties),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ContainerEncodingProperties
    };

    // ----- H264ProfileIds class --------------------

    static PyObject* _new_H264ProfileIds(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::MediaProperties::H264ProfileIds>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::MediaProperties::H264ProfileIds>::type_name);
        return nullptr;
    }

    static PyObject* H264ProfileIds_get_Baseline(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.H264ProfileIds", L"Baseline"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Media::MediaProperties::H264ProfileIds::Baseline());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* H264ProfileIds_get_ConstrainedBaseline(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.H264ProfileIds", L"ConstrainedBaseline"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Media::MediaProperties::H264ProfileIds::ConstrainedBaseline());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* H264ProfileIds_get_Extended(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.H264ProfileIds", L"Extended"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Media::MediaProperties::H264ProfileIds::Extended());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* H264ProfileIds_get_High(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.H264ProfileIds", L"High"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Media::MediaProperties::H264ProfileIds::High());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* H264ProfileIds_get_High10(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.H264ProfileIds", L"High10"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Media::MediaProperties::H264ProfileIds::High10());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* H264ProfileIds_get_High422(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.H264ProfileIds", L"High422"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Media::MediaProperties::H264ProfileIds::High422());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* H264ProfileIds_get_High444(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.H264ProfileIds", L"High444"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Media::MediaProperties::H264ProfileIds::High444());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* H264ProfileIds_get_Main(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.H264ProfileIds", L"Main"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Media::MediaProperties::H264ProfileIds::Main());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* H264ProfileIds_get_MultiviewHigh(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.H264ProfileIds", L"MultiviewHigh"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Media::MediaProperties::H264ProfileIds::MultiviewHigh());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* H264ProfileIds_get_StereoHigh(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.H264ProfileIds", L"StereoHigh"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Media::MediaProperties::H264ProfileIds::StereoHigh());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_H264ProfileIds[] = {
        { }
    };

    static PyGetSetDef _getset_H264ProfileIds[] = {
        { }
    };

    static PyType_Slot _type_slots_H264ProfileIds[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_H264ProfileIds) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_H264ProfileIds) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_H264ProfileIds) },
        { },
    };

    static PyType_Spec type_spec_H264ProfileIds =
    {
        "winrt._winrt_windows_media_mediaproperties.H264ProfileIds",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_H264ProfileIds
    };

    static PyGetSetDef getset_H264ProfileIds_Static[] = {
        { "baseline", reinterpret_cast<getter>(H264ProfileIds_get_Baseline), nullptr, nullptr, nullptr },
        { "constrained_baseline", reinterpret_cast<getter>(H264ProfileIds_get_ConstrainedBaseline), nullptr, nullptr, nullptr },
        { "extended", reinterpret_cast<getter>(H264ProfileIds_get_Extended), nullptr, nullptr, nullptr },
        { "high", reinterpret_cast<getter>(H264ProfileIds_get_High), nullptr, nullptr, nullptr },
        { "high10", reinterpret_cast<getter>(H264ProfileIds_get_High10), nullptr, nullptr, nullptr },
        { "high422", reinterpret_cast<getter>(H264ProfileIds_get_High422), nullptr, nullptr, nullptr },
        { "high444", reinterpret_cast<getter>(H264ProfileIds_get_High444), nullptr, nullptr, nullptr },
        { "main", reinterpret_cast<getter>(H264ProfileIds_get_Main), nullptr, nullptr, nullptr },
        { "multiview_high", reinterpret_cast<getter>(H264ProfileIds_get_MultiviewHigh), nullptr, nullptr, nullptr },
        { "stereo_high", reinterpret_cast<getter>(H264ProfileIds_get_StereoHigh), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_H264ProfileIds_Static[] = {
        { }
    };

    static PyType_Slot type_slots_H264ProfileIds_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_H264ProfileIds_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_H264ProfileIds_Static) },
        { }
    };

    static PyType_Spec type_spec_H264ProfileIds_Static =
    {
        "winrt._winrt_windows_media_mediaproperties.H264ProfileIds_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_H264ProfileIds_Static
    };

    // ----- HevcProfileIds class --------------------

    static PyObject* _new_HevcProfileIds(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::MediaProperties::HevcProfileIds>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::MediaProperties::HevcProfileIds>::type_name);
        return nullptr;
    }

    static PyObject* HevcProfileIds_get_MainChromaSubsampling420BitDepth10(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.HevcProfileIds", L"MainChromaSubsampling420BitDepth10"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Media::MediaProperties::HevcProfileIds::MainChromaSubsampling420BitDepth10());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HevcProfileIds_get_MainChromaSubsampling420BitDepth12(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.HevcProfileIds", L"MainChromaSubsampling420BitDepth12"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Media::MediaProperties::HevcProfileIds::MainChromaSubsampling420BitDepth12());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HevcProfileIds_get_MainChromaSubsampling420BitDepth8(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.HevcProfileIds", L"MainChromaSubsampling420BitDepth8"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Media::MediaProperties::HevcProfileIds::MainChromaSubsampling420BitDepth8());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HevcProfileIds_get_MainChromaSubsampling422BitDepth10(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.HevcProfileIds", L"MainChromaSubsampling422BitDepth10"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Media::MediaProperties::HevcProfileIds::MainChromaSubsampling422BitDepth10());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HevcProfileIds_get_MainChromaSubsampling422BitDepth12(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.HevcProfileIds", L"MainChromaSubsampling422BitDepth12"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Media::MediaProperties::HevcProfileIds::MainChromaSubsampling422BitDepth12());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HevcProfileIds_get_MainChromaSubsampling444BitDepth10(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.HevcProfileIds", L"MainChromaSubsampling444BitDepth10"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Media::MediaProperties::HevcProfileIds::MainChromaSubsampling444BitDepth10());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HevcProfileIds_get_MainChromaSubsampling444BitDepth12(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.HevcProfileIds", L"MainChromaSubsampling444BitDepth12"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Media::MediaProperties::HevcProfileIds::MainChromaSubsampling444BitDepth12());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HevcProfileIds_get_MainChromaSubsampling444BitDepth8(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.HevcProfileIds", L"MainChromaSubsampling444BitDepth8"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Media::MediaProperties::HevcProfileIds::MainChromaSubsampling444BitDepth8());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HevcProfileIds_get_MainIntraChromaSubsampling420BitDepth10(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.HevcProfileIds", L"MainIntraChromaSubsampling420BitDepth10"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Media::MediaProperties::HevcProfileIds::MainIntraChromaSubsampling420BitDepth10());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HevcProfileIds_get_MainIntraChromaSubsampling420BitDepth12(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.HevcProfileIds", L"MainIntraChromaSubsampling420BitDepth12"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Media::MediaProperties::HevcProfileIds::MainIntraChromaSubsampling420BitDepth12());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HevcProfileIds_get_MainIntraChromaSubsampling420BitDepth8(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.HevcProfileIds", L"MainIntraChromaSubsampling420BitDepth8"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Media::MediaProperties::HevcProfileIds::MainIntraChromaSubsampling420BitDepth8());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HevcProfileIds_get_MainIntraChromaSubsampling422BitDepth10(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.HevcProfileIds", L"MainIntraChromaSubsampling422BitDepth10"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Media::MediaProperties::HevcProfileIds::MainIntraChromaSubsampling422BitDepth10());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HevcProfileIds_get_MainIntraChromaSubsampling422BitDepth12(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.HevcProfileIds", L"MainIntraChromaSubsampling422BitDepth12"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Media::MediaProperties::HevcProfileIds::MainIntraChromaSubsampling422BitDepth12());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HevcProfileIds_get_MainIntraChromaSubsampling444BitDepth10(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.HevcProfileIds", L"MainIntraChromaSubsampling444BitDepth10"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Media::MediaProperties::HevcProfileIds::MainIntraChromaSubsampling444BitDepth10());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HevcProfileIds_get_MainIntraChromaSubsampling444BitDepth12(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.HevcProfileIds", L"MainIntraChromaSubsampling444BitDepth12"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Media::MediaProperties::HevcProfileIds::MainIntraChromaSubsampling444BitDepth12());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HevcProfileIds_get_MainIntraChromaSubsampling444BitDepth16(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.HevcProfileIds", L"MainIntraChromaSubsampling444BitDepth16"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Media::MediaProperties::HevcProfileIds::MainIntraChromaSubsampling444BitDepth16());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HevcProfileIds_get_MainIntraChromaSubsampling444BitDepth8(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.HevcProfileIds", L"MainIntraChromaSubsampling444BitDepth8"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Media::MediaProperties::HevcProfileIds::MainIntraChromaSubsampling444BitDepth8());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HevcProfileIds_get_MainStillChromaSubsampling420BitDepth8(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.HevcProfileIds", L"MainStillChromaSubsampling420BitDepth8"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Media::MediaProperties::HevcProfileIds::MainStillChromaSubsampling420BitDepth8());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HevcProfileIds_get_MainStillChromaSubsampling444BitDepth16(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.HevcProfileIds", L"MainStillChromaSubsampling444BitDepth16"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Media::MediaProperties::HevcProfileIds::MainStillChromaSubsampling444BitDepth16());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HevcProfileIds_get_MainStillChromaSubsampling444BitDepth8(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.HevcProfileIds", L"MainStillChromaSubsampling444BitDepth8"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Media::MediaProperties::HevcProfileIds::MainStillChromaSubsampling444BitDepth8());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HevcProfileIds_get_MonochromeBitDepth12(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.HevcProfileIds", L"MonochromeBitDepth12"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Media::MediaProperties::HevcProfileIds::MonochromeBitDepth12());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HevcProfileIds_get_MonochromeBitDepth16(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.HevcProfileIds", L"MonochromeBitDepth16"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Media::MediaProperties::HevcProfileIds::MonochromeBitDepth16());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_HevcProfileIds[] = {
        { }
    };

    static PyGetSetDef _getset_HevcProfileIds[] = {
        { }
    };

    static PyType_Slot _type_slots_HevcProfileIds[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_HevcProfileIds) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_HevcProfileIds) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_HevcProfileIds) },
        { },
    };

    static PyType_Spec type_spec_HevcProfileIds =
    {
        "winrt._winrt_windows_media_mediaproperties.HevcProfileIds",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_HevcProfileIds
    };

    static PyGetSetDef getset_HevcProfileIds_Static[] = {
        { "main_chroma_subsampling420_bit_depth10", reinterpret_cast<getter>(HevcProfileIds_get_MainChromaSubsampling420BitDepth10), nullptr, nullptr, nullptr },
        { "main_chroma_subsampling420_bit_depth12", reinterpret_cast<getter>(HevcProfileIds_get_MainChromaSubsampling420BitDepth12), nullptr, nullptr, nullptr },
        { "main_chroma_subsampling420_bit_depth8", reinterpret_cast<getter>(HevcProfileIds_get_MainChromaSubsampling420BitDepth8), nullptr, nullptr, nullptr },
        { "main_chroma_subsampling422_bit_depth10", reinterpret_cast<getter>(HevcProfileIds_get_MainChromaSubsampling422BitDepth10), nullptr, nullptr, nullptr },
        { "main_chroma_subsampling422_bit_depth12", reinterpret_cast<getter>(HevcProfileIds_get_MainChromaSubsampling422BitDepth12), nullptr, nullptr, nullptr },
        { "main_chroma_subsampling444_bit_depth10", reinterpret_cast<getter>(HevcProfileIds_get_MainChromaSubsampling444BitDepth10), nullptr, nullptr, nullptr },
        { "main_chroma_subsampling444_bit_depth12", reinterpret_cast<getter>(HevcProfileIds_get_MainChromaSubsampling444BitDepth12), nullptr, nullptr, nullptr },
        { "main_chroma_subsampling444_bit_depth8", reinterpret_cast<getter>(HevcProfileIds_get_MainChromaSubsampling444BitDepth8), nullptr, nullptr, nullptr },
        { "main_intra_chroma_subsampling420_bit_depth10", reinterpret_cast<getter>(HevcProfileIds_get_MainIntraChromaSubsampling420BitDepth10), nullptr, nullptr, nullptr },
        { "main_intra_chroma_subsampling420_bit_depth12", reinterpret_cast<getter>(HevcProfileIds_get_MainIntraChromaSubsampling420BitDepth12), nullptr, nullptr, nullptr },
        { "main_intra_chroma_subsampling420_bit_depth8", reinterpret_cast<getter>(HevcProfileIds_get_MainIntraChromaSubsampling420BitDepth8), nullptr, nullptr, nullptr },
        { "main_intra_chroma_subsampling422_bit_depth10", reinterpret_cast<getter>(HevcProfileIds_get_MainIntraChromaSubsampling422BitDepth10), nullptr, nullptr, nullptr },
        { "main_intra_chroma_subsampling422_bit_depth12", reinterpret_cast<getter>(HevcProfileIds_get_MainIntraChromaSubsampling422BitDepth12), nullptr, nullptr, nullptr },
        { "main_intra_chroma_subsampling444_bit_depth10", reinterpret_cast<getter>(HevcProfileIds_get_MainIntraChromaSubsampling444BitDepth10), nullptr, nullptr, nullptr },
        { "main_intra_chroma_subsampling444_bit_depth12", reinterpret_cast<getter>(HevcProfileIds_get_MainIntraChromaSubsampling444BitDepth12), nullptr, nullptr, nullptr },
        { "main_intra_chroma_subsampling444_bit_depth16", reinterpret_cast<getter>(HevcProfileIds_get_MainIntraChromaSubsampling444BitDepth16), nullptr, nullptr, nullptr },
        { "main_intra_chroma_subsampling444_bit_depth8", reinterpret_cast<getter>(HevcProfileIds_get_MainIntraChromaSubsampling444BitDepth8), nullptr, nullptr, nullptr },
        { "main_still_chroma_subsampling420_bit_depth8", reinterpret_cast<getter>(HevcProfileIds_get_MainStillChromaSubsampling420BitDepth8), nullptr, nullptr, nullptr },
        { "main_still_chroma_subsampling444_bit_depth16", reinterpret_cast<getter>(HevcProfileIds_get_MainStillChromaSubsampling444BitDepth16), nullptr, nullptr, nullptr },
        { "main_still_chroma_subsampling444_bit_depth8", reinterpret_cast<getter>(HevcProfileIds_get_MainStillChromaSubsampling444BitDepth8), nullptr, nullptr, nullptr },
        { "monochrome_bit_depth12", reinterpret_cast<getter>(HevcProfileIds_get_MonochromeBitDepth12), nullptr, nullptr, nullptr },
        { "monochrome_bit_depth16", reinterpret_cast<getter>(HevcProfileIds_get_MonochromeBitDepth16), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_HevcProfileIds_Static[] = {
        { }
    };

    static PyType_Slot type_slots_HevcProfileIds_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_HevcProfileIds_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_HevcProfileIds_Static) },
        { }
    };

    static PyType_Spec type_spec_HevcProfileIds_Static =
    {
        "winrt._winrt_windows_media_mediaproperties.HevcProfileIds_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_HevcProfileIds_Static
    };

    // ----- ImageEncodingProperties class --------------------

    static PyObject* _new_ImageEncodingProperties(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Media::MediaProperties::ImageEncodingProperties instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ImageEncodingProperties(py::wrapper::Windows::Media::MediaProperties::ImageEncodingProperties* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ImageEncodingProperties_Copy(py::wrapper::Windows::Media::MediaProperties::ImageEncodingProperties* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.MediaProperties.ImageEncodingProperties", L"Copy", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.Copy());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ImageEncodingProperties_CreateBmp(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.MediaProperties.ImageEncodingProperties", L"CreateBmp", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(winrt::Windows::Media::MediaProperties::ImageEncodingProperties::CreateBmp());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ImageEncodingProperties_CreateHeif(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.MediaProperties.ImageEncodingProperties", L"CreateHeif", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(winrt::Windows::Media::MediaProperties::ImageEncodingProperties::CreateHeif());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ImageEncodingProperties_CreateJpeg(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.MediaProperties.ImageEncodingProperties", L"CreateJpeg", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(winrt::Windows::Media::MediaProperties::ImageEncodingProperties::CreateJpeg());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ImageEncodingProperties_CreateJpegXR(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.MediaProperties.ImageEncodingProperties", L"CreateJpegXR", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(winrt::Windows::Media::MediaProperties::ImageEncodingProperties::CreateJpegXR());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ImageEncodingProperties_CreatePng(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.MediaProperties.ImageEncodingProperties", L"CreatePng", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(winrt::Windows::Media::MediaProperties::ImageEncodingProperties::CreatePng());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ImageEncodingProperties_CreateUncompressed(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.MediaProperties.ImageEncodingProperties", L"CreateUncompressed", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Media::MediaProperties::MediaPixelFormat>(args, 0);

                return py::convert(winrt::Windows::Media::MediaProperties::ImageEncodingProperties::CreateUncompressed(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ImageEncodingProperties_get_Width(py::wrapper::Windows::Media::MediaProperties::ImageEncodingProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.ImageEncodingProperties", L"Width"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Width());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ImageEncodingProperties_put_Width(py::wrapper::Windows::Media::MediaProperties::ImageEncodingProperties* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.ImageEncodingProperties", L"Width"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.Width(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ImageEncodingProperties_get_Height(py::wrapper::Windows::Media::MediaProperties::ImageEncodingProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.ImageEncodingProperties", L"Height"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Height());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ImageEncodingProperties_put_Height(py::wrapper::Windows::Media::MediaProperties::ImageEncodingProperties* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.ImageEncodingProperties", L"Height"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.Height(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ImageEncodingProperties_get_Subtype(py::wrapper::Windows::Media::MediaProperties::ImageEncodingProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.ImageEncodingProperties", L"Subtype"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Subtype());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ImageEncodingProperties_put_Subtype(py::wrapper::Windows::Media::MediaProperties::ImageEncodingProperties* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.ImageEncodingProperties", L"Subtype"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Subtype(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ImageEncodingProperties_get_Properties(py::wrapper::Windows::Media::MediaProperties::ImageEncodingProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.ImageEncodingProperties", L"Properties"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Properties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ImageEncodingProperties_get_Type(py::wrapper::Windows::Media::MediaProperties::ImageEncodingProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.ImageEncodingProperties", L"Type"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Type());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ImageEncodingProperties(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::MediaProperties::ImageEncodingProperties>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ImageEncodingProperties(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::MediaProperties::ImageEncodingProperties>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ImageEncodingProperties[] = {
        { "copy", reinterpret_cast<PyCFunction>(ImageEncodingProperties_Copy), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_ImageEncodingProperties, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ImageEncodingProperties), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ImageEncodingProperties[] = {
        { "width", reinterpret_cast<getter>(ImageEncodingProperties_get_Width), reinterpret_cast<setter>(ImageEncodingProperties_put_Width), nullptr, nullptr },
        { "height", reinterpret_cast<getter>(ImageEncodingProperties_get_Height), reinterpret_cast<setter>(ImageEncodingProperties_put_Height), nullptr, nullptr },
        { "subtype", reinterpret_cast<getter>(ImageEncodingProperties_get_Subtype), reinterpret_cast<setter>(ImageEncodingProperties_put_Subtype), nullptr, nullptr },
        { "properties", reinterpret_cast<getter>(ImageEncodingProperties_get_Properties), nullptr, nullptr, nullptr },
        { "type", reinterpret_cast<getter>(ImageEncodingProperties_get_Type), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ImageEncodingProperties[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ImageEncodingProperties) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ImageEncodingProperties) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ImageEncodingProperties) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ImageEncodingProperties) },
        { },
    };

    static PyType_Spec type_spec_ImageEncodingProperties =
    {
        "winrt._winrt_windows_media_mediaproperties.ImageEncodingProperties",
        sizeof(py::wrapper::Windows::Media::MediaProperties::ImageEncodingProperties),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ImageEncodingProperties
    };

    static PyGetSetDef getset_ImageEncodingProperties_Static[] = {
        { }
    };

    static PyMethodDef methods_ImageEncodingProperties_Static[] = {
        { "create_bmp", reinterpret_cast<PyCFunction>(ImageEncodingProperties_CreateBmp), METH_VARARGS, nullptr },
        { "create_heif", reinterpret_cast<PyCFunction>(ImageEncodingProperties_CreateHeif), METH_VARARGS, nullptr },
        { "create_jpeg", reinterpret_cast<PyCFunction>(ImageEncodingProperties_CreateJpeg), METH_VARARGS, nullptr },
        { "create_jpeg_x_r", reinterpret_cast<PyCFunction>(ImageEncodingProperties_CreateJpegXR), METH_VARARGS, nullptr },
        { "create_png", reinterpret_cast<PyCFunction>(ImageEncodingProperties_CreatePng), METH_VARARGS, nullptr },
        { "create_uncompressed", reinterpret_cast<PyCFunction>(ImageEncodingProperties_CreateUncompressed), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_ImageEncodingProperties_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_ImageEncodingProperties_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_ImageEncodingProperties_Static) },
        { }
    };

    static PyType_Spec type_spec_ImageEncodingProperties_Static =
    {
        "winrt._winrt_windows_media_mediaproperties.ImageEncodingProperties_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_ImageEncodingProperties_Static
    };

    // ----- MediaEncodingProfile class --------------------

    static PyObject* _new_MediaEncodingProfile(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Media::MediaProperties::MediaEncodingProfile instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MediaEncodingProfile(py::wrapper::Windows::Media::MediaProperties::MediaEncodingProfile* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MediaEncodingProfile_CreateAlac(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.MediaProperties.MediaEncodingProfile", L"CreateAlac", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Media::MediaProperties::AudioEncodingQuality>(args, 0);

                return py::convert(winrt::Windows::Media::MediaProperties::MediaEncodingProfile::CreateAlac(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaEncodingProfile_CreateAv1(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.MediaProperties.MediaEncodingProfile", L"CreateAv1", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Media::MediaProperties::VideoEncodingQuality>(args, 0);

                return py::convert(winrt::Windows::Media::MediaProperties::MediaEncodingProfile::CreateAv1(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaEncodingProfile_CreateAvi(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.MediaProperties.MediaEncodingProfile", L"CreateAvi", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Media::MediaProperties::VideoEncodingQuality>(args, 0);

                return py::convert(winrt::Windows::Media::MediaProperties::MediaEncodingProfile::CreateAvi(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaEncodingProfile_CreateFlac(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.MediaProperties.MediaEncodingProfile", L"CreateFlac", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Media::MediaProperties::AudioEncodingQuality>(args, 0);

                return py::convert(winrt::Windows::Media::MediaProperties::MediaEncodingProfile::CreateFlac(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaEncodingProfile_CreateFromFileAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.MediaProperties.MediaEncodingProfile", L"CreateFromFileAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFile>(args, 0);

                return py::convert(winrt::Windows::Media::MediaProperties::MediaEncodingProfile::CreateFromFileAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaEncodingProfile_CreateFromStreamAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.MediaProperties.MediaEncodingProfile", L"CreateFromStreamAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStream>(args, 0);

                return py::convert(winrt::Windows::Media::MediaProperties::MediaEncodingProfile::CreateFromStreamAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaEncodingProfile_CreateHevc(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.MediaProperties.MediaEncodingProfile", L"CreateHevc", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Media::MediaProperties::VideoEncodingQuality>(args, 0);

                return py::convert(winrt::Windows::Media::MediaProperties::MediaEncodingProfile::CreateHevc(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaEncodingProfile_CreateM4a(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.MediaProperties.MediaEncodingProfile", L"CreateM4a", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Media::MediaProperties::AudioEncodingQuality>(args, 0);

                return py::convert(winrt::Windows::Media::MediaProperties::MediaEncodingProfile::CreateM4a(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaEncodingProfile_CreateMp3(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.MediaProperties.MediaEncodingProfile", L"CreateMp3", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Media::MediaProperties::AudioEncodingQuality>(args, 0);

                return py::convert(winrt::Windows::Media::MediaProperties::MediaEncodingProfile::CreateMp3(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaEncodingProfile_CreateMp4(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.MediaProperties.MediaEncodingProfile", L"CreateMp4", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Media::MediaProperties::VideoEncodingQuality>(args, 0);

                return py::convert(winrt::Windows::Media::MediaProperties::MediaEncodingProfile::CreateMp4(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaEncodingProfile_CreateVp9(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.MediaProperties.MediaEncodingProfile", L"CreateVp9", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Media::MediaProperties::VideoEncodingQuality>(args, 0);

                return py::convert(winrt::Windows::Media::MediaProperties::MediaEncodingProfile::CreateVp9(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaEncodingProfile_CreateWav(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.MediaProperties.MediaEncodingProfile", L"CreateWav", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Media::MediaProperties::AudioEncodingQuality>(args, 0);

                return py::convert(winrt::Windows::Media::MediaProperties::MediaEncodingProfile::CreateWav(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaEncodingProfile_CreateWma(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.MediaProperties.MediaEncodingProfile", L"CreateWma", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Media::MediaProperties::AudioEncodingQuality>(args, 0);

                return py::convert(winrt::Windows::Media::MediaProperties::MediaEncodingProfile::CreateWma(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaEncodingProfile_CreateWmv(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.MediaProperties.MediaEncodingProfile", L"CreateWmv", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Media::MediaProperties::VideoEncodingQuality>(args, 0);

                return py::convert(winrt::Windows::Media::MediaProperties::MediaEncodingProfile::CreateWmv(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaEncodingProfile_GetAudioTracks(py::wrapper::Windows::Media::MediaProperties::MediaEncodingProfile* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.MediaProperties.MediaEncodingProfile", L"GetAudioTracks", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetAudioTracks());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaEncodingProfile_GetTimedMetadataTracks(py::wrapper::Windows::Media::MediaProperties::MediaEncodingProfile* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.MediaProperties.MediaEncodingProfile", L"GetTimedMetadataTracks", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetTimedMetadataTracks());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaEncodingProfile_GetVideoTracks(py::wrapper::Windows::Media::MediaProperties::MediaEncodingProfile* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.MediaProperties.MediaEncodingProfile", L"GetVideoTracks", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetVideoTracks());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaEncodingProfile_SetAudioTracks(py::wrapper::Windows::Media::MediaProperties::MediaEncodingProfile* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.MediaProperties.MediaEncodingProfile", L"SetAudioTracks", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Media::Core::AudioStreamDescriptor>>(args, 0);

                self->obj.SetAudioTracks(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaEncodingProfile_SetTimedMetadataTracks(py::wrapper::Windows::Media::MediaProperties::MediaEncodingProfile* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.MediaProperties.MediaEncodingProfile", L"SetTimedMetadataTracks", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Media::Core::TimedMetadataStreamDescriptor>>(args, 0);

                self->obj.SetTimedMetadataTracks(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaEncodingProfile_SetVideoTracks(py::wrapper::Windows::Media::MediaProperties::MediaEncodingProfile* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.MediaProperties.MediaEncodingProfile", L"SetVideoTracks", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Media::Core::VideoStreamDescriptor>>(args, 0);

                self->obj.SetVideoTracks(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaEncodingProfile_get_Video(py::wrapper::Windows::Media::MediaProperties::MediaEncodingProfile* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.MediaEncodingProfile", L"Video"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Video());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaEncodingProfile_put_Video(py::wrapper::Windows::Media::MediaProperties::MediaEncodingProfile* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.MediaEncodingProfile", L"Video"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Media::MediaProperties::VideoEncodingProperties>(arg);

            self->obj.Video(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaEncodingProfile_get_Container(py::wrapper::Windows::Media::MediaProperties::MediaEncodingProfile* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.MediaEncodingProfile", L"Container"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Container());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaEncodingProfile_put_Container(py::wrapper::Windows::Media::MediaProperties::MediaEncodingProfile* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.MediaEncodingProfile", L"Container"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Media::MediaProperties::ContainerEncodingProperties>(arg);

            self->obj.Container(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaEncodingProfile_get_Audio(py::wrapper::Windows::Media::MediaProperties::MediaEncodingProfile* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.MediaEncodingProfile", L"Audio"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Audio());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaEncodingProfile_put_Audio(py::wrapper::Windows::Media::MediaProperties::MediaEncodingProfile* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.MediaEncodingProfile", L"Audio"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Media::MediaProperties::AudioEncodingProperties>(arg);

            self->obj.Audio(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_MediaEncodingProfile(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::MediaProperties::MediaEncodingProfile>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MediaEncodingProfile(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::MediaProperties::MediaEncodingProfile>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaEncodingProfile[] = {
        { "get_audio_tracks", reinterpret_cast<PyCFunction>(MediaEncodingProfile_GetAudioTracks), METH_VARARGS, nullptr },
        { "get_timed_metadata_tracks", reinterpret_cast<PyCFunction>(MediaEncodingProfile_GetTimedMetadataTracks), METH_VARARGS, nullptr },
        { "get_video_tracks", reinterpret_cast<PyCFunction>(MediaEncodingProfile_GetVideoTracks), METH_VARARGS, nullptr },
        { "set_audio_tracks", reinterpret_cast<PyCFunction>(MediaEncodingProfile_SetAudioTracks), METH_VARARGS, nullptr },
        { "set_timed_metadata_tracks", reinterpret_cast<PyCFunction>(MediaEncodingProfile_SetTimedMetadataTracks), METH_VARARGS, nullptr },
        { "set_video_tracks", reinterpret_cast<PyCFunction>(MediaEncodingProfile_SetVideoTracks), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_MediaEncodingProfile, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MediaEncodingProfile), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MediaEncodingProfile[] = {
        { "video", reinterpret_cast<getter>(MediaEncodingProfile_get_Video), reinterpret_cast<setter>(MediaEncodingProfile_put_Video), nullptr, nullptr },
        { "container", reinterpret_cast<getter>(MediaEncodingProfile_get_Container), reinterpret_cast<setter>(MediaEncodingProfile_put_Container), nullptr, nullptr },
        { "audio", reinterpret_cast<getter>(MediaEncodingProfile_get_Audio), reinterpret_cast<setter>(MediaEncodingProfile_put_Audio), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MediaEncodingProfile[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MediaEncodingProfile) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MediaEncodingProfile) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MediaEncodingProfile) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MediaEncodingProfile) },
        { },
    };

    static PyType_Spec type_spec_MediaEncodingProfile =
    {
        "winrt._winrt_windows_media_mediaproperties.MediaEncodingProfile",
        sizeof(py::wrapper::Windows::Media::MediaProperties::MediaEncodingProfile),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaEncodingProfile
    };

    static PyGetSetDef getset_MediaEncodingProfile_Static[] = {
        { }
    };

    static PyMethodDef methods_MediaEncodingProfile_Static[] = {
        { "create_alac", reinterpret_cast<PyCFunction>(MediaEncodingProfile_CreateAlac), METH_VARARGS, nullptr },
        { "create_av1", reinterpret_cast<PyCFunction>(MediaEncodingProfile_CreateAv1), METH_VARARGS, nullptr },
        { "create_avi", reinterpret_cast<PyCFunction>(MediaEncodingProfile_CreateAvi), METH_VARARGS, nullptr },
        { "create_flac", reinterpret_cast<PyCFunction>(MediaEncodingProfile_CreateFlac), METH_VARARGS, nullptr },
        { "create_from_file_async", reinterpret_cast<PyCFunction>(MediaEncodingProfile_CreateFromFileAsync), METH_VARARGS, nullptr },
        { "create_from_stream_async", reinterpret_cast<PyCFunction>(MediaEncodingProfile_CreateFromStreamAsync), METH_VARARGS, nullptr },
        { "create_hevc", reinterpret_cast<PyCFunction>(MediaEncodingProfile_CreateHevc), METH_VARARGS, nullptr },
        { "create_m4a", reinterpret_cast<PyCFunction>(MediaEncodingProfile_CreateM4a), METH_VARARGS, nullptr },
        { "create_mp3", reinterpret_cast<PyCFunction>(MediaEncodingProfile_CreateMp3), METH_VARARGS, nullptr },
        { "create_mp4", reinterpret_cast<PyCFunction>(MediaEncodingProfile_CreateMp4), METH_VARARGS, nullptr },
        { "create_vp9", reinterpret_cast<PyCFunction>(MediaEncodingProfile_CreateVp9), METH_VARARGS, nullptr },
        { "create_wav", reinterpret_cast<PyCFunction>(MediaEncodingProfile_CreateWav), METH_VARARGS, nullptr },
        { "create_wma", reinterpret_cast<PyCFunction>(MediaEncodingProfile_CreateWma), METH_VARARGS, nullptr },
        { "create_wmv", reinterpret_cast<PyCFunction>(MediaEncodingProfile_CreateWmv), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_MediaEncodingProfile_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_MediaEncodingProfile_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_MediaEncodingProfile_Static) },
        { }
    };

    static PyType_Spec type_spec_MediaEncodingProfile_Static =
    {
        "winrt._winrt_windows_media_mediaproperties.MediaEncodingProfile_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_MediaEncodingProfile_Static
    };

    // ----- MediaEncodingSubtypes class --------------------

    static PyObject* _new_MediaEncodingSubtypes(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::MediaProperties::MediaEncodingSubtypes>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::MediaProperties::MediaEncodingSubtypes>::type_name);
        return nullptr;
    }

    static PyObject* MediaEncodingSubtypes_get_Argb32(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.MediaEncodingSubtypes", L"Argb32"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Media::MediaProperties::MediaEncodingSubtypes::Argb32());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaEncodingSubtypes_get_Aac(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.MediaEncodingSubtypes", L"Aac"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Media::MediaProperties::MediaEncodingSubtypes::Aac());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaEncodingSubtypes_get_AacAdts(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.MediaEncodingSubtypes", L"AacAdts"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Media::MediaProperties::MediaEncodingSubtypes::AacAdts());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaEncodingSubtypes_get_Ac3(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.MediaEncodingSubtypes", L"Ac3"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Media::MediaProperties::MediaEncodingSubtypes::Ac3());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaEncodingSubtypes_get_AmrNb(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.MediaEncodingSubtypes", L"AmrNb"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Media::MediaProperties::MediaEncodingSubtypes::AmrNb());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaEncodingSubtypes_get_AmrWb(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.MediaEncodingSubtypes", L"AmrWb"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Media::MediaProperties::MediaEncodingSubtypes::AmrWb());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaEncodingSubtypes_get_Mpeg(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.MediaEncodingSubtypes", L"Mpeg"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Media::MediaProperties::MediaEncodingSubtypes::Mpeg());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaEncodingSubtypes_get_Asf(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.MediaEncodingSubtypes", L"Asf"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Media::MediaProperties::MediaEncodingSubtypes::Asf());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaEncodingSubtypes_get_Avi(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.MediaEncodingSubtypes", L"Avi"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Media::MediaProperties::MediaEncodingSubtypes::Avi());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaEncodingSubtypes_get_Bgra8(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.MediaEncodingSubtypes", L"Bgra8"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Media::MediaProperties::MediaEncodingSubtypes::Bgra8());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaEncodingSubtypes_get_Bmp(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.MediaEncodingSubtypes", L"Bmp"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Media::MediaProperties::MediaEncodingSubtypes::Bmp());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaEncodingSubtypes_get_Eac3(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.MediaEncodingSubtypes", L"Eac3"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Media::MediaProperties::MediaEncodingSubtypes::Eac3());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaEncodingSubtypes_get_Float(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.MediaEncodingSubtypes", L"Float"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Media::MediaProperties::MediaEncodingSubtypes::Float());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaEncodingSubtypes_get_Gif(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.MediaEncodingSubtypes", L"Gif"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Media::MediaProperties::MediaEncodingSubtypes::Gif());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaEncodingSubtypes_get_H263(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.MediaEncodingSubtypes", L"H263"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Media::MediaProperties::MediaEncodingSubtypes::H263());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaEncodingSubtypes_get_H264(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.MediaEncodingSubtypes", L"H264"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Media::MediaProperties::MediaEncodingSubtypes::H264());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaEncodingSubtypes_get_H264Es(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.MediaEncodingSubtypes", L"H264Es"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Media::MediaProperties::MediaEncodingSubtypes::H264Es());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaEncodingSubtypes_get_Hevc(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.MediaEncodingSubtypes", L"Hevc"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Media::MediaProperties::MediaEncodingSubtypes::Hevc());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaEncodingSubtypes_get_HevcEs(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.MediaEncodingSubtypes", L"HevcEs"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Media::MediaProperties::MediaEncodingSubtypes::HevcEs());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaEncodingSubtypes_get_Iyuv(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.MediaEncodingSubtypes", L"Iyuv"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Media::MediaProperties::MediaEncodingSubtypes::Iyuv());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaEncodingSubtypes_get_Jpeg(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.MediaEncodingSubtypes", L"Jpeg"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Media::MediaProperties::MediaEncodingSubtypes::Jpeg());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaEncodingSubtypes_get_JpegXr(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.MediaEncodingSubtypes", L"JpegXr"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Media::MediaProperties::MediaEncodingSubtypes::JpegXr());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaEncodingSubtypes_get_Mjpg(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.MediaEncodingSubtypes", L"Mjpg"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Media::MediaProperties::MediaEncodingSubtypes::Mjpg());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaEncodingSubtypes_get_Mp3(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.MediaEncodingSubtypes", L"Mp3"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Media::MediaProperties::MediaEncodingSubtypes::Mp3());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaEncodingSubtypes_get_Mpeg1(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.MediaEncodingSubtypes", L"Mpeg1"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Media::MediaProperties::MediaEncodingSubtypes::Mpeg1());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaEncodingSubtypes_get_Mpeg2(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.MediaEncodingSubtypes", L"Mpeg2"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Media::MediaProperties::MediaEncodingSubtypes::Mpeg2());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaEncodingSubtypes_get_Mpeg4(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.MediaEncodingSubtypes", L"Mpeg4"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Media::MediaProperties::MediaEncodingSubtypes::Mpeg4());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaEncodingSubtypes_get_Nv12(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.MediaEncodingSubtypes", L"Nv12"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Media::MediaProperties::MediaEncodingSubtypes::Nv12());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaEncodingSubtypes_get_Pcm(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.MediaEncodingSubtypes", L"Pcm"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Media::MediaProperties::MediaEncodingSubtypes::Pcm());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaEncodingSubtypes_get_Png(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.MediaEncodingSubtypes", L"Png"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Media::MediaProperties::MediaEncodingSubtypes::Png());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaEncodingSubtypes_get_Rgb24(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.MediaEncodingSubtypes", L"Rgb24"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Media::MediaProperties::MediaEncodingSubtypes::Rgb24());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaEncodingSubtypes_get_Rgb32(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.MediaEncodingSubtypes", L"Rgb32"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Media::MediaProperties::MediaEncodingSubtypes::Rgb32());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaEncodingSubtypes_get_Tiff(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.MediaEncodingSubtypes", L"Tiff"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Media::MediaProperties::MediaEncodingSubtypes::Tiff());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaEncodingSubtypes_get_Wave(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.MediaEncodingSubtypes", L"Wave"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Media::MediaProperties::MediaEncodingSubtypes::Wave());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaEncodingSubtypes_get_Wma8(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.MediaEncodingSubtypes", L"Wma8"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Media::MediaProperties::MediaEncodingSubtypes::Wma8());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaEncodingSubtypes_get_Wma9(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.MediaEncodingSubtypes", L"Wma9"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Media::MediaProperties::MediaEncodingSubtypes::Wma9());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaEncodingSubtypes_get_Wmv3(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.MediaEncodingSubtypes", L"Wmv3"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Media::MediaProperties::MediaEncodingSubtypes::Wmv3());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaEncodingSubtypes_get_Wvc1(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.MediaEncodingSubtypes", L"Wvc1"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Media::MediaProperties::MediaEncodingSubtypes::Wvc1());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaEncodingSubtypes_get_Yuy2(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.MediaEncodingSubtypes", L"Yuy2"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Media::MediaProperties::MediaEncodingSubtypes::Yuy2());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaEncodingSubtypes_get_Yv12(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.MediaEncodingSubtypes", L"Yv12"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Media::MediaProperties::MediaEncodingSubtypes::Yv12());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaEncodingSubtypes_get_D16(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.MediaEncodingSubtypes", L"D16"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Media::MediaProperties::MediaEncodingSubtypes::D16());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaEncodingSubtypes_get_L16(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.MediaEncodingSubtypes", L"L16"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Media::MediaProperties::MediaEncodingSubtypes::L16());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaEncodingSubtypes_get_L8(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.MediaEncodingSubtypes", L"L8"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Media::MediaProperties::MediaEncodingSubtypes::L8());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaEncodingSubtypes_get_Vp9(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.MediaEncodingSubtypes", L"Vp9"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Media::MediaProperties::MediaEncodingSubtypes::Vp9());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaEncodingSubtypes_get_Alac(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.MediaEncodingSubtypes", L"Alac"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Media::MediaProperties::MediaEncodingSubtypes::Alac());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaEncodingSubtypes_get_Flac(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.MediaEncodingSubtypes", L"Flac"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Media::MediaProperties::MediaEncodingSubtypes::Flac());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaEncodingSubtypes_get_P010(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.MediaEncodingSubtypes", L"P010"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Media::MediaProperties::MediaEncodingSubtypes::P010());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaEncodingSubtypes_get_Heif(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.MediaEncodingSubtypes", L"Heif"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Media::MediaProperties::MediaEncodingSubtypes::Heif());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaEncodingSubtypes_get_Pgs(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.MediaEncodingSubtypes", L"Pgs"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Media::MediaProperties::MediaEncodingSubtypes::Pgs());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaEncodingSubtypes_get_Srt(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.MediaEncodingSubtypes", L"Srt"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Media::MediaProperties::MediaEncodingSubtypes::Srt());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaEncodingSubtypes_get_Ssa(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.MediaEncodingSubtypes", L"Ssa"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Media::MediaProperties::MediaEncodingSubtypes::Ssa());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaEncodingSubtypes_get_VobSub(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.MediaEncodingSubtypes", L"VobSub"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Media::MediaProperties::MediaEncodingSubtypes::VobSub());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaEncodingSubtypes_get_Av1(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.MediaEncodingSubtypes", L"Av1"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Media::MediaProperties::MediaEncodingSubtypes::Av1());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaEncodingSubtypes[] = {
        { }
    };

    static PyGetSetDef _getset_MediaEncodingSubtypes[] = {
        { }
    };

    static PyType_Slot _type_slots_MediaEncodingSubtypes[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MediaEncodingSubtypes) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MediaEncodingSubtypes) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MediaEncodingSubtypes) },
        { },
    };

    static PyType_Spec type_spec_MediaEncodingSubtypes =
    {
        "winrt._winrt_windows_media_mediaproperties.MediaEncodingSubtypes",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaEncodingSubtypes
    };

    static PyGetSetDef getset_MediaEncodingSubtypes_Static[] = {
        { "argb32", reinterpret_cast<getter>(MediaEncodingSubtypes_get_Argb32), nullptr, nullptr, nullptr },
        { "aac", reinterpret_cast<getter>(MediaEncodingSubtypes_get_Aac), nullptr, nullptr, nullptr },
        { "aac_adts", reinterpret_cast<getter>(MediaEncodingSubtypes_get_AacAdts), nullptr, nullptr, nullptr },
        { "ac3", reinterpret_cast<getter>(MediaEncodingSubtypes_get_Ac3), nullptr, nullptr, nullptr },
        { "amr_nb", reinterpret_cast<getter>(MediaEncodingSubtypes_get_AmrNb), nullptr, nullptr, nullptr },
        { "amr_wb", reinterpret_cast<getter>(MediaEncodingSubtypes_get_AmrWb), nullptr, nullptr, nullptr },
        { "mpeg", reinterpret_cast<getter>(MediaEncodingSubtypes_get_Mpeg), nullptr, nullptr, nullptr },
        { "asf", reinterpret_cast<getter>(MediaEncodingSubtypes_get_Asf), nullptr, nullptr, nullptr },
        { "avi", reinterpret_cast<getter>(MediaEncodingSubtypes_get_Avi), nullptr, nullptr, nullptr },
        { "bgra8", reinterpret_cast<getter>(MediaEncodingSubtypes_get_Bgra8), nullptr, nullptr, nullptr },
        { "bmp", reinterpret_cast<getter>(MediaEncodingSubtypes_get_Bmp), nullptr, nullptr, nullptr },
        { "eac3", reinterpret_cast<getter>(MediaEncodingSubtypes_get_Eac3), nullptr, nullptr, nullptr },
        { "float", reinterpret_cast<getter>(MediaEncodingSubtypes_get_Float), nullptr, nullptr, nullptr },
        { "gif", reinterpret_cast<getter>(MediaEncodingSubtypes_get_Gif), nullptr, nullptr, nullptr },
        { "h263", reinterpret_cast<getter>(MediaEncodingSubtypes_get_H263), nullptr, nullptr, nullptr },
        { "h264", reinterpret_cast<getter>(MediaEncodingSubtypes_get_H264), nullptr, nullptr, nullptr },
        { "h264_es", reinterpret_cast<getter>(MediaEncodingSubtypes_get_H264Es), nullptr, nullptr, nullptr },
        { "hevc", reinterpret_cast<getter>(MediaEncodingSubtypes_get_Hevc), nullptr, nullptr, nullptr },
        { "hevc_es", reinterpret_cast<getter>(MediaEncodingSubtypes_get_HevcEs), nullptr, nullptr, nullptr },
        { "iyuv", reinterpret_cast<getter>(MediaEncodingSubtypes_get_Iyuv), nullptr, nullptr, nullptr },
        { "jpeg", reinterpret_cast<getter>(MediaEncodingSubtypes_get_Jpeg), nullptr, nullptr, nullptr },
        { "jpeg_xr", reinterpret_cast<getter>(MediaEncodingSubtypes_get_JpegXr), nullptr, nullptr, nullptr },
        { "mjpg", reinterpret_cast<getter>(MediaEncodingSubtypes_get_Mjpg), nullptr, nullptr, nullptr },
        { "mp3", reinterpret_cast<getter>(MediaEncodingSubtypes_get_Mp3), nullptr, nullptr, nullptr },
        { "mpeg1", reinterpret_cast<getter>(MediaEncodingSubtypes_get_Mpeg1), nullptr, nullptr, nullptr },
        { "mpeg2", reinterpret_cast<getter>(MediaEncodingSubtypes_get_Mpeg2), nullptr, nullptr, nullptr },
        { "mpeg4", reinterpret_cast<getter>(MediaEncodingSubtypes_get_Mpeg4), nullptr, nullptr, nullptr },
        { "nv12", reinterpret_cast<getter>(MediaEncodingSubtypes_get_Nv12), nullptr, nullptr, nullptr },
        { "pcm", reinterpret_cast<getter>(MediaEncodingSubtypes_get_Pcm), nullptr, nullptr, nullptr },
        { "png", reinterpret_cast<getter>(MediaEncodingSubtypes_get_Png), nullptr, nullptr, nullptr },
        { "rgb24", reinterpret_cast<getter>(MediaEncodingSubtypes_get_Rgb24), nullptr, nullptr, nullptr },
        { "rgb32", reinterpret_cast<getter>(MediaEncodingSubtypes_get_Rgb32), nullptr, nullptr, nullptr },
        { "tiff", reinterpret_cast<getter>(MediaEncodingSubtypes_get_Tiff), nullptr, nullptr, nullptr },
        { "wave", reinterpret_cast<getter>(MediaEncodingSubtypes_get_Wave), nullptr, nullptr, nullptr },
        { "wma8", reinterpret_cast<getter>(MediaEncodingSubtypes_get_Wma8), nullptr, nullptr, nullptr },
        { "wma9", reinterpret_cast<getter>(MediaEncodingSubtypes_get_Wma9), nullptr, nullptr, nullptr },
        { "wmv3", reinterpret_cast<getter>(MediaEncodingSubtypes_get_Wmv3), nullptr, nullptr, nullptr },
        { "wvc1", reinterpret_cast<getter>(MediaEncodingSubtypes_get_Wvc1), nullptr, nullptr, nullptr },
        { "yuy2", reinterpret_cast<getter>(MediaEncodingSubtypes_get_Yuy2), nullptr, nullptr, nullptr },
        { "yv12", reinterpret_cast<getter>(MediaEncodingSubtypes_get_Yv12), nullptr, nullptr, nullptr },
        { "d16", reinterpret_cast<getter>(MediaEncodingSubtypes_get_D16), nullptr, nullptr, nullptr },
        { "l16", reinterpret_cast<getter>(MediaEncodingSubtypes_get_L16), nullptr, nullptr, nullptr },
        { "l8", reinterpret_cast<getter>(MediaEncodingSubtypes_get_L8), nullptr, nullptr, nullptr },
        { "vp9", reinterpret_cast<getter>(MediaEncodingSubtypes_get_Vp9), nullptr, nullptr, nullptr },
        { "alac", reinterpret_cast<getter>(MediaEncodingSubtypes_get_Alac), nullptr, nullptr, nullptr },
        { "flac", reinterpret_cast<getter>(MediaEncodingSubtypes_get_Flac), nullptr, nullptr, nullptr },
        { "p010", reinterpret_cast<getter>(MediaEncodingSubtypes_get_P010), nullptr, nullptr, nullptr },
        { "heif", reinterpret_cast<getter>(MediaEncodingSubtypes_get_Heif), nullptr, nullptr, nullptr },
        { "pgs", reinterpret_cast<getter>(MediaEncodingSubtypes_get_Pgs), nullptr, nullptr, nullptr },
        { "srt", reinterpret_cast<getter>(MediaEncodingSubtypes_get_Srt), nullptr, nullptr, nullptr },
        { "ssa", reinterpret_cast<getter>(MediaEncodingSubtypes_get_Ssa), nullptr, nullptr, nullptr },
        { "vob_sub", reinterpret_cast<getter>(MediaEncodingSubtypes_get_VobSub), nullptr, nullptr, nullptr },
        { "av1", reinterpret_cast<getter>(MediaEncodingSubtypes_get_Av1), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_MediaEncodingSubtypes_Static[] = {
        { }
    };

    static PyType_Slot type_slots_MediaEncodingSubtypes_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_MediaEncodingSubtypes_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_MediaEncodingSubtypes_Static) },
        { }
    };

    static PyType_Spec type_spec_MediaEncodingSubtypes_Static =
    {
        "winrt._winrt_windows_media_mediaproperties.MediaEncodingSubtypes_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_MediaEncodingSubtypes_Static
    };

    // ----- MediaPropertySet class --------------------

    static PyObject* _new_MediaPropertySet(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Media::MediaProperties::MediaPropertySet instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MediaPropertySet(py::wrapper::Windows::Media::MediaProperties::MediaPropertySet* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MediaPropertySet_Clear(py::wrapper::Windows::Media::MediaProperties::MediaPropertySet* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.MediaProperties.MediaPropertySet", L"Clear", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Clear();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaPropertySet_First(py::wrapper::Windows::Media::MediaProperties::MediaPropertySet* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.MediaProperties.MediaPropertySet", L"First", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.First());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaPropertySet_GetView(py::wrapper::Windows::Media::MediaProperties::MediaPropertySet* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.MediaProperties.MediaPropertySet", L"GetView", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetView());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaPropertySet_HasKey(py::wrapper::Windows::Media::MediaProperties::MediaPropertySet* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.MediaProperties.MediaPropertySet", L"HasKey", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::guid>(args, 0);

                return py::convert(self->obj.HasKey(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaPropertySet_Insert(py::wrapper::Windows::Media::MediaProperties::MediaPropertySet* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.MediaProperties.MediaPropertySet", L"Insert", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::guid>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 1);

                return py::convert(self->obj.Insert(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaPropertySet_Lookup(py::wrapper::Windows::Media::MediaProperties::MediaPropertySet* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.MediaProperties.MediaPropertySet", L"Lookup", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::guid>(args, 0);

                return py::convert(self->obj.Lookup(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaPropertySet_Remove(py::wrapper::Windows::Media::MediaProperties::MediaPropertySet* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.MediaProperties.MediaPropertySet", L"Remove", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::guid>(args, 0);

                self->obj.Remove(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaPropertySet_get_Size(py::wrapper::Windows::Media::MediaProperties::MediaPropertySet* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.MediaPropertySet", L"Size"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MediaPropertySet(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::MediaProperties::MediaPropertySet>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MediaPropertySet(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::MediaProperties::MediaPropertySet>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _iterator_MediaPropertySet(py::wrapper::Windows::Media::MediaProperties::MediaPropertySet* self) noexcept
    {
        try
        {
            py::pyobj_handle iter{py::convert(self->obj.First())};

            if (!iter)
            {
                return nullptr;
            }

            return py::wrap_mapping_iter(iter.get());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int _map_contains_MediaPropertySet(py::wrapper::Windows::Media::MediaProperties::MediaPropertySet* self, PyObject* key) noexcept
    {
        try
        {
            return static_cast<int>(self->obj.HasKey(py::convert_to<winrt::guid>(key)));
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static Py_ssize_t _map_length_MediaPropertySet(py::wrapper::Windows::Media::MediaProperties::MediaPropertySet* self) noexcept
    {
        try
        {
            return static_cast<Py_ssize_t>(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _map_subscript_MediaPropertySet(py::wrapper::Windows::Media::MediaProperties::MediaPropertySet* self, PyObject* key) noexcept
    {
        try
        {
            auto _key = py::convert_to<winrt::guid>(key);
            auto value = self->obj.TryLookup(_key);

            if (!value) {
                if constexpr (std::is_base_of_v<winrt::Windows::Foundation::IUnknown, decltype(value)>)
                {
                    if (self->obj.HasKey(_key))
                    {
                        Py_RETURN_NONE;
                    }
                }

                PyErr_SetObject(PyExc_KeyError, key);
                return nullptr;
            }

            return py::convert(value);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int _map_assign_MediaPropertySet(py::wrapper::Windows::Media::MediaProperties::MediaPropertySet* self, PyObject* key, PyObject* value) noexcept
    {
        try
        {
            auto _key = py::convert_to<winrt::guid>(key);

            if (value == nullptr) {
                if (!self->obj.TryRemove(_key)) {
                    PyErr_SetObject(PyExc_KeyError, key);
                    return -1;
                }

                return 0;
            }

            self->obj.Insert(_key, py::convert_to<winrt::Windows::Foundation::IInspectable>(value));

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyMethodDef _methods_MediaPropertySet[] = {
        { "clear", reinterpret_cast<PyCFunction>(MediaPropertySet_Clear), METH_VARARGS, nullptr },
        { "first", reinterpret_cast<PyCFunction>(MediaPropertySet_First), METH_VARARGS, nullptr },
        { "get_view", reinterpret_cast<PyCFunction>(MediaPropertySet_GetView), METH_VARARGS, nullptr },
        { "has_key", reinterpret_cast<PyCFunction>(MediaPropertySet_HasKey), METH_VARARGS, nullptr },
        { "insert", reinterpret_cast<PyCFunction>(MediaPropertySet_Insert), METH_VARARGS, nullptr },
        { "lookup", reinterpret_cast<PyCFunction>(MediaPropertySet_Lookup), METH_VARARGS, nullptr },
        { "remove", reinterpret_cast<PyCFunction>(MediaPropertySet_Remove), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_MediaPropertySet, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MediaPropertySet), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MediaPropertySet[] = {
        { "size", reinterpret_cast<getter>(MediaPropertySet_get_Size), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MediaPropertySet[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MediaPropertySet) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MediaPropertySet) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MediaPropertySet) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MediaPropertySet) },
        { Py_tp_iter, reinterpret_cast<void*>(_iterator_MediaPropertySet) },
        { Py_sq_contains, reinterpret_cast<void*>(_map_contains_MediaPropertySet) },
        { Py_mp_length, reinterpret_cast<void*>(_map_length_MediaPropertySet) },
        { Py_mp_subscript, reinterpret_cast<void*>(_map_subscript_MediaPropertySet) },
        { Py_mp_ass_subscript, reinterpret_cast<void*>(_map_assign_MediaPropertySet) },
        { },
    };

    static PyType_Spec type_spec_MediaPropertySet =
    {
        "winrt._winrt_windows_media_mediaproperties.MediaPropertySet",
        sizeof(py::wrapper::Windows::Media::MediaProperties::MediaPropertySet),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaPropertySet
    };

    // ----- MediaRatio class --------------------

    static PyObject* _new_MediaRatio(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::MediaProperties::MediaRatio>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::MediaProperties::MediaRatio>::type_name);
        return nullptr;
    }

    static void _dealloc_MediaRatio(py::wrapper::Windows::Media::MediaProperties::MediaRatio* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MediaRatio_get_Numerator(py::wrapper::Windows::Media::MediaProperties::MediaRatio* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.MediaRatio", L"Numerator"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Numerator());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaRatio_put_Numerator(py::wrapper::Windows::Media::MediaProperties::MediaRatio* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.MediaRatio", L"Numerator"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.Numerator(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaRatio_get_Denominator(py::wrapper::Windows::Media::MediaProperties::MediaRatio* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.MediaRatio", L"Denominator"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Denominator());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaRatio_put_Denominator(py::wrapper::Windows::Media::MediaProperties::MediaRatio* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.MediaRatio", L"Denominator"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.Denominator(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_MediaRatio(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::MediaProperties::MediaRatio>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MediaRatio(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::MediaProperties::MediaRatio>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaRatio[] = {
        { "_assign_array_", _assign_array_MediaRatio, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MediaRatio), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MediaRatio[] = {
        { "numerator", reinterpret_cast<getter>(MediaRatio_get_Numerator), reinterpret_cast<setter>(MediaRatio_put_Numerator), nullptr, nullptr },
        { "denominator", reinterpret_cast<getter>(MediaRatio_get_Denominator), reinterpret_cast<setter>(MediaRatio_put_Denominator), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MediaRatio[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MediaRatio) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MediaRatio) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MediaRatio) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MediaRatio) },
        { },
    };

    static PyType_Spec type_spec_MediaRatio =
    {
        "winrt._winrt_windows_media_mediaproperties.MediaRatio",
        sizeof(py::wrapper::Windows::Media::MediaProperties::MediaRatio),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaRatio
    };

    // ----- Mpeg2ProfileIds class --------------------

    static PyObject* _new_Mpeg2ProfileIds(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::MediaProperties::Mpeg2ProfileIds>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::MediaProperties::Mpeg2ProfileIds>::type_name);
        return nullptr;
    }

    static PyObject* Mpeg2ProfileIds_get_High(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.Mpeg2ProfileIds", L"High"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Media::MediaProperties::Mpeg2ProfileIds::High());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Mpeg2ProfileIds_get_Main(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.Mpeg2ProfileIds", L"Main"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Media::MediaProperties::Mpeg2ProfileIds::Main());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Mpeg2ProfileIds_get_SignalNoiseRatioScalable(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.Mpeg2ProfileIds", L"SignalNoiseRatioScalable"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Media::MediaProperties::Mpeg2ProfileIds::SignalNoiseRatioScalable());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Mpeg2ProfileIds_get_Simple(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.Mpeg2ProfileIds", L"Simple"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Media::MediaProperties::Mpeg2ProfileIds::Simple());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Mpeg2ProfileIds_get_SpatiallyScalable(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.Mpeg2ProfileIds", L"SpatiallyScalable"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Media::MediaProperties::Mpeg2ProfileIds::SpatiallyScalable());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_Mpeg2ProfileIds[] = {
        { }
    };

    static PyGetSetDef _getset_Mpeg2ProfileIds[] = {
        { }
    };

    static PyType_Slot _type_slots_Mpeg2ProfileIds[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_Mpeg2ProfileIds) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_Mpeg2ProfileIds) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_Mpeg2ProfileIds) },
        { },
    };

    static PyType_Spec type_spec_Mpeg2ProfileIds =
    {
        "winrt._winrt_windows_media_mediaproperties.Mpeg2ProfileIds",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_Mpeg2ProfileIds
    };

    static PyGetSetDef getset_Mpeg2ProfileIds_Static[] = {
        { "high", reinterpret_cast<getter>(Mpeg2ProfileIds_get_High), nullptr, nullptr, nullptr },
        { "main", reinterpret_cast<getter>(Mpeg2ProfileIds_get_Main), nullptr, nullptr, nullptr },
        { "signal_noise_ratio_scalable", reinterpret_cast<getter>(Mpeg2ProfileIds_get_SignalNoiseRatioScalable), nullptr, nullptr, nullptr },
        { "simple", reinterpret_cast<getter>(Mpeg2ProfileIds_get_Simple), nullptr, nullptr, nullptr },
        { "spatially_scalable", reinterpret_cast<getter>(Mpeg2ProfileIds_get_SpatiallyScalable), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_Mpeg2ProfileIds_Static[] = {
        { }
    };

    static PyType_Slot type_slots_Mpeg2ProfileIds_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_Mpeg2ProfileIds_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_Mpeg2ProfileIds_Static) },
        { }
    };

    static PyType_Spec type_spec_Mpeg2ProfileIds_Static =
    {
        "winrt._winrt_windows_media_mediaproperties.Mpeg2ProfileIds_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_Mpeg2ProfileIds_Static
    };

    // ----- TimedMetadataEncodingProperties class --------------------

    static PyObject* _new_TimedMetadataEncodingProperties(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Media::MediaProperties::TimedMetadataEncodingProperties instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_TimedMetadataEncodingProperties(py::wrapper::Windows::Media::MediaProperties::TimedMetadataEncodingProperties* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* TimedMetadataEncodingProperties_Copy(py::wrapper::Windows::Media::MediaProperties::TimedMetadataEncodingProperties* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.MediaProperties.TimedMetadataEncodingProperties", L"Copy", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.Copy());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TimedMetadataEncodingProperties_CreatePgs(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.MediaProperties.TimedMetadataEncodingProperties", L"CreatePgs", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(winrt::Windows::Media::MediaProperties::TimedMetadataEncodingProperties::CreatePgs());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TimedMetadataEncodingProperties_CreateSrt(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.MediaProperties.TimedMetadataEncodingProperties", L"CreateSrt", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(winrt::Windows::Media::MediaProperties::TimedMetadataEncodingProperties::CreateSrt());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TimedMetadataEncodingProperties_CreateSsa(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.MediaProperties.TimedMetadataEncodingProperties", L"CreateSsa", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<py::pybuf_view<uint8_t, false>>(args, 0);

                return py::convert(winrt::Windows::Media::MediaProperties::TimedMetadataEncodingProperties::CreateSsa(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TimedMetadataEncodingProperties_CreateVobSub(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.MediaProperties.TimedMetadataEncodingProperties", L"CreateVobSub", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<py::pybuf_view<uint8_t, false>>(args, 0);

                return py::convert(winrt::Windows::Media::MediaProperties::TimedMetadataEncodingProperties::CreateVobSub(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TimedMetadataEncodingProperties_GetFormatUserData(py::wrapper::Windows::Media::MediaProperties::TimedMetadataEncodingProperties* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.MediaProperties.TimedMetadataEncodingProperties", L"GetFormatUserData", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                winrt::com_array<uint8_t> param0 { };

                self->obj.GetFormatUserData(param0);

                py::pyobj_handle out0{ py::convert(param0) };
                if (!out0)
                {
                    return nullptr;
                }
                return out0.detach();
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TimedMetadataEncodingProperties_SetFormatUserData(py::wrapper::Windows::Media::MediaProperties::TimedMetadataEncodingProperties* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.MediaProperties.TimedMetadataEncodingProperties", L"SetFormatUserData", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<py::pybuf_view<uint8_t, false>>(args, 0);

                self->obj.SetFormatUserData(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TimedMetadataEncodingProperties_get_Subtype(py::wrapper::Windows::Media::MediaProperties::TimedMetadataEncodingProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.TimedMetadataEncodingProperties", L"Subtype"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Subtype());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedMetadataEncodingProperties_put_Subtype(py::wrapper::Windows::Media::MediaProperties::TimedMetadataEncodingProperties* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.TimedMetadataEncodingProperties", L"Subtype"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Subtype(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedMetadataEncodingProperties_get_Properties(py::wrapper::Windows::Media::MediaProperties::TimedMetadataEncodingProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.TimedMetadataEncodingProperties", L"Properties"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Properties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TimedMetadataEncodingProperties_get_Type(py::wrapper::Windows::Media::MediaProperties::TimedMetadataEncodingProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.TimedMetadataEncodingProperties", L"Type"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Type());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_TimedMetadataEncodingProperties(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::MediaProperties::TimedMetadataEncodingProperties>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_TimedMetadataEncodingProperties(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::MediaProperties::TimedMetadataEncodingProperties>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TimedMetadataEncodingProperties[] = {
        { "copy", reinterpret_cast<PyCFunction>(TimedMetadataEncodingProperties_Copy), METH_VARARGS, nullptr },
        { "get_format_user_data", reinterpret_cast<PyCFunction>(TimedMetadataEncodingProperties_GetFormatUserData), METH_VARARGS, nullptr },
        { "set_format_user_data", reinterpret_cast<PyCFunction>(TimedMetadataEncodingProperties_SetFormatUserData), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_TimedMetadataEncodingProperties, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_TimedMetadataEncodingProperties), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_TimedMetadataEncodingProperties[] = {
        { "subtype", reinterpret_cast<getter>(TimedMetadataEncodingProperties_get_Subtype), reinterpret_cast<setter>(TimedMetadataEncodingProperties_put_Subtype), nullptr, nullptr },
        { "properties", reinterpret_cast<getter>(TimedMetadataEncodingProperties_get_Properties), nullptr, nullptr, nullptr },
        { "type", reinterpret_cast<getter>(TimedMetadataEncodingProperties_get_Type), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_TimedMetadataEncodingProperties[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_TimedMetadataEncodingProperties) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_TimedMetadataEncodingProperties) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_TimedMetadataEncodingProperties) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_TimedMetadataEncodingProperties) },
        { },
    };

    static PyType_Spec type_spec_TimedMetadataEncodingProperties =
    {
        "winrt._winrt_windows_media_mediaproperties.TimedMetadataEncodingProperties",
        sizeof(py::wrapper::Windows::Media::MediaProperties::TimedMetadataEncodingProperties),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TimedMetadataEncodingProperties
    };

    static PyGetSetDef getset_TimedMetadataEncodingProperties_Static[] = {
        { }
    };

    static PyMethodDef methods_TimedMetadataEncodingProperties_Static[] = {
        { "create_pgs", reinterpret_cast<PyCFunction>(TimedMetadataEncodingProperties_CreatePgs), METH_VARARGS, nullptr },
        { "create_srt", reinterpret_cast<PyCFunction>(TimedMetadataEncodingProperties_CreateSrt), METH_VARARGS, nullptr },
        { "create_ssa", reinterpret_cast<PyCFunction>(TimedMetadataEncodingProperties_CreateSsa), METH_VARARGS, nullptr },
        { "create_vob_sub", reinterpret_cast<PyCFunction>(TimedMetadataEncodingProperties_CreateVobSub), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_TimedMetadataEncodingProperties_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_TimedMetadataEncodingProperties_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_TimedMetadataEncodingProperties_Static) },
        { }
    };

    static PyType_Spec type_spec_TimedMetadataEncodingProperties_Static =
    {
        "winrt._winrt_windows_media_mediaproperties.TimedMetadataEncodingProperties_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_TimedMetadataEncodingProperties_Static
    };

    // ----- VideoEncodingProperties class --------------------

    static PyObject* _new_VideoEncodingProperties(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Media::MediaProperties::VideoEncodingProperties instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_VideoEncodingProperties(py::wrapper::Windows::Media::MediaProperties::VideoEncodingProperties* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* VideoEncodingProperties_Copy(py::wrapper::Windows::Media::MediaProperties::VideoEncodingProperties* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.MediaProperties.VideoEncodingProperties", L"Copy", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.Copy());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VideoEncodingProperties_CreateAv1(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.MediaProperties.VideoEncodingProperties", L"CreateAv1", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(winrt::Windows::Media::MediaProperties::VideoEncodingProperties::CreateAv1());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VideoEncodingProperties_CreateH264(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.MediaProperties.VideoEncodingProperties", L"CreateH264", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(winrt::Windows::Media::MediaProperties::VideoEncodingProperties::CreateH264());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VideoEncodingProperties_CreateHevc(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.MediaProperties.VideoEncodingProperties", L"CreateHevc", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(winrt::Windows::Media::MediaProperties::VideoEncodingProperties::CreateHevc());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VideoEncodingProperties_CreateMpeg2(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.MediaProperties.VideoEncodingProperties", L"CreateMpeg2", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(winrt::Windows::Media::MediaProperties::VideoEncodingProperties::CreateMpeg2());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VideoEncodingProperties_CreateUncompressed(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.MediaProperties.VideoEncodingProperties", L"CreateUncompressed", 3))
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);
                auto param2 = py::convert_to<uint32_t>(args, 2);

                return py::convert(winrt::Windows::Media::MediaProperties::VideoEncodingProperties::CreateUncompressed(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VideoEncodingProperties_CreateVp9(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.MediaProperties.VideoEncodingProperties", L"CreateVp9", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(winrt::Windows::Media::MediaProperties::VideoEncodingProperties::CreateVp9());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VideoEncodingProperties_GetFormatUserData(py::wrapper::Windows::Media::MediaProperties::VideoEncodingProperties* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.MediaProperties.VideoEncodingProperties", L"GetFormatUserData", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                winrt::com_array<uint8_t> param0 { };

                self->obj.GetFormatUserData(param0);

                py::pyobj_handle out0{ py::convert(param0) };
                if (!out0)
                {
                    return nullptr;
                }
                return out0.detach();
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VideoEncodingProperties_SetFormatUserData(py::wrapper::Windows::Media::MediaProperties::VideoEncodingProperties* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.MediaProperties.VideoEncodingProperties", L"SetFormatUserData", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<py::pybuf_view<uint8_t, false>>(args, 0);

                self->obj.SetFormatUserData(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VideoEncodingProperties_get_Subtype(py::wrapper::Windows::Media::MediaProperties::VideoEncodingProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.VideoEncodingProperties", L"Subtype"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Subtype());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VideoEncodingProperties_put_Subtype(py::wrapper::Windows::Media::MediaProperties::VideoEncodingProperties* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.VideoEncodingProperties", L"Subtype"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Subtype(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VideoEncodingProperties_get_Type(py::wrapper::Windows::Media::MediaProperties::VideoEncodingProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.VideoEncodingProperties", L"Type"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Type());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VideoEncodingProperties_get_Properties(py::wrapper::Windows::Media::MediaProperties::VideoEncodingProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.VideoEncodingProperties", L"Properties"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Properties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VideoEncodingProperties_get_Width(py::wrapper::Windows::Media::MediaProperties::VideoEncodingProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.VideoEncodingProperties", L"Width"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Width());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VideoEncodingProperties_put_Width(py::wrapper::Windows::Media::MediaProperties::VideoEncodingProperties* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.VideoEncodingProperties", L"Width"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.Width(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VideoEncodingProperties_get_Height(py::wrapper::Windows::Media::MediaProperties::VideoEncodingProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.VideoEncodingProperties", L"Height"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Height());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VideoEncodingProperties_put_Height(py::wrapper::Windows::Media::MediaProperties::VideoEncodingProperties* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.VideoEncodingProperties", L"Height"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.Height(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VideoEncodingProperties_get_Bitrate(py::wrapper::Windows::Media::MediaProperties::VideoEncodingProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.VideoEncodingProperties", L"Bitrate"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Bitrate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VideoEncodingProperties_put_Bitrate(py::wrapper::Windows::Media::MediaProperties::VideoEncodingProperties* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.VideoEncodingProperties", L"Bitrate"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.Bitrate(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VideoEncodingProperties_get_PixelAspectRatio(py::wrapper::Windows::Media::MediaProperties::VideoEncodingProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.VideoEncodingProperties", L"PixelAspectRatio"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PixelAspectRatio());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VideoEncodingProperties_get_FrameRate(py::wrapper::Windows::Media::MediaProperties::VideoEncodingProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.VideoEncodingProperties", L"FrameRate"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.FrameRate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VideoEncodingProperties_get_ProfileId(py::wrapper::Windows::Media::MediaProperties::VideoEncodingProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.VideoEncodingProperties", L"ProfileId"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ProfileId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VideoEncodingProperties_put_ProfileId(py::wrapper::Windows::Media::MediaProperties::VideoEncodingProperties* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.VideoEncodingProperties", L"ProfileId"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.ProfileId(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VideoEncodingProperties_get_StereoscopicVideoPackingMode(py::wrapper::Windows::Media::MediaProperties::VideoEncodingProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.VideoEncodingProperties", L"StereoscopicVideoPackingMode"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.StereoscopicVideoPackingMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VideoEncodingProperties_get_SphericalVideoFrameFormat(py::wrapper::Windows::Media::MediaProperties::VideoEncodingProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.VideoEncodingProperties", L"SphericalVideoFrameFormat"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SphericalVideoFrameFormat());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_VideoEncodingProperties(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::MediaProperties::VideoEncodingProperties>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_VideoEncodingProperties(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::MediaProperties::VideoEncodingProperties>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_VideoEncodingProperties[] = {
        { "copy", reinterpret_cast<PyCFunction>(VideoEncodingProperties_Copy), METH_VARARGS, nullptr },
        { "get_format_user_data", reinterpret_cast<PyCFunction>(VideoEncodingProperties_GetFormatUserData), METH_VARARGS, nullptr },
        { "set_format_user_data", reinterpret_cast<PyCFunction>(VideoEncodingProperties_SetFormatUserData), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_VideoEncodingProperties, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_VideoEncodingProperties), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_VideoEncodingProperties[] = {
        { "subtype", reinterpret_cast<getter>(VideoEncodingProperties_get_Subtype), reinterpret_cast<setter>(VideoEncodingProperties_put_Subtype), nullptr, nullptr },
        { "type", reinterpret_cast<getter>(VideoEncodingProperties_get_Type), nullptr, nullptr, nullptr },
        { "properties", reinterpret_cast<getter>(VideoEncodingProperties_get_Properties), nullptr, nullptr, nullptr },
        { "width", reinterpret_cast<getter>(VideoEncodingProperties_get_Width), reinterpret_cast<setter>(VideoEncodingProperties_put_Width), nullptr, nullptr },
        { "height", reinterpret_cast<getter>(VideoEncodingProperties_get_Height), reinterpret_cast<setter>(VideoEncodingProperties_put_Height), nullptr, nullptr },
        { "bitrate", reinterpret_cast<getter>(VideoEncodingProperties_get_Bitrate), reinterpret_cast<setter>(VideoEncodingProperties_put_Bitrate), nullptr, nullptr },
        { "pixel_aspect_ratio", reinterpret_cast<getter>(VideoEncodingProperties_get_PixelAspectRatio), nullptr, nullptr, nullptr },
        { "frame_rate", reinterpret_cast<getter>(VideoEncodingProperties_get_FrameRate), nullptr, nullptr, nullptr },
        { "profile_id", reinterpret_cast<getter>(VideoEncodingProperties_get_ProfileId), reinterpret_cast<setter>(VideoEncodingProperties_put_ProfileId), nullptr, nullptr },
        { "stereoscopic_video_packing_mode", reinterpret_cast<getter>(VideoEncodingProperties_get_StereoscopicVideoPackingMode), nullptr, nullptr, nullptr },
        { "spherical_video_frame_format", reinterpret_cast<getter>(VideoEncodingProperties_get_SphericalVideoFrameFormat), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_VideoEncodingProperties[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_VideoEncodingProperties) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_VideoEncodingProperties) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_VideoEncodingProperties) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_VideoEncodingProperties) },
        { },
    };

    static PyType_Spec type_spec_VideoEncodingProperties =
    {
        "winrt._winrt_windows_media_mediaproperties.VideoEncodingProperties",
        sizeof(py::wrapper::Windows::Media::MediaProperties::VideoEncodingProperties),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_VideoEncodingProperties
    };

    static PyGetSetDef getset_VideoEncodingProperties_Static[] = {
        { }
    };

    static PyMethodDef methods_VideoEncodingProperties_Static[] = {
        { "create_av1", reinterpret_cast<PyCFunction>(VideoEncodingProperties_CreateAv1), METH_VARARGS, nullptr },
        { "create_h264", reinterpret_cast<PyCFunction>(VideoEncodingProperties_CreateH264), METH_VARARGS, nullptr },
        { "create_hevc", reinterpret_cast<PyCFunction>(VideoEncodingProperties_CreateHevc), METH_VARARGS, nullptr },
        { "create_mpeg2", reinterpret_cast<PyCFunction>(VideoEncodingProperties_CreateMpeg2), METH_VARARGS, nullptr },
        { "create_uncompressed", reinterpret_cast<PyCFunction>(VideoEncodingProperties_CreateUncompressed), METH_VARARGS, nullptr },
        { "create_vp9", reinterpret_cast<PyCFunction>(VideoEncodingProperties_CreateVp9), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_VideoEncodingProperties_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_VideoEncodingProperties_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_VideoEncodingProperties_Static) },
        { }
    };

    static PyType_Spec type_spec_VideoEncodingProperties_Static =
    {
        "winrt._winrt_windows_media_mediaproperties.VideoEncodingProperties_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_VideoEncodingProperties_Static
    };

    // ----- Vp9ProfileIds class --------------------

    static PyObject* _new_Vp9ProfileIds(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::MediaProperties::Vp9ProfileIds>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::MediaProperties::Vp9ProfileIds>::type_name);
        return nullptr;
    }

    static PyObject* Vp9ProfileIds_get_Profile0ChromaSubsampling420BitDepth8(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.Vp9ProfileIds", L"Profile0ChromaSubsampling420BitDepth8"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Media::MediaProperties::Vp9ProfileIds::Profile0ChromaSubsampling420BitDepth8());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Vp9ProfileIds_get_Profile2ChromaSubsampling420BitDepth10(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.Vp9ProfileIds", L"Profile2ChromaSubsampling420BitDepth10"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Media::MediaProperties::Vp9ProfileIds::Profile2ChromaSubsampling420BitDepth10());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Vp9ProfileIds_get_Profile2ChromaSubsampling420BitDepth12(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.Vp9ProfileIds", L"Profile2ChromaSubsampling420BitDepth12"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Media::MediaProperties::Vp9ProfileIds::Profile2ChromaSubsampling420BitDepth12());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_Vp9ProfileIds[] = {
        { }
    };

    static PyGetSetDef _getset_Vp9ProfileIds[] = {
        { }
    };

    static PyType_Slot _type_slots_Vp9ProfileIds[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_Vp9ProfileIds) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_Vp9ProfileIds) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_Vp9ProfileIds) },
        { },
    };

    static PyType_Spec type_spec_Vp9ProfileIds =
    {
        "winrt._winrt_windows_media_mediaproperties.Vp9ProfileIds",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_Vp9ProfileIds
    };

    static PyGetSetDef getset_Vp9ProfileIds_Static[] = {
        { "profile0_chroma_subsampling420_bit_depth8", reinterpret_cast<getter>(Vp9ProfileIds_get_Profile0ChromaSubsampling420BitDepth8), nullptr, nullptr, nullptr },
        { "profile2_chroma_subsampling420_bit_depth10", reinterpret_cast<getter>(Vp9ProfileIds_get_Profile2ChromaSubsampling420BitDepth10), nullptr, nullptr, nullptr },
        { "profile2_chroma_subsampling420_bit_depth12", reinterpret_cast<getter>(Vp9ProfileIds_get_Profile2ChromaSubsampling420BitDepth12), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_Vp9ProfileIds_Static[] = {
        { }
    };

    static PyType_Slot type_slots_Vp9ProfileIds_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_Vp9ProfileIds_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_Vp9ProfileIds_Static) },
        { }
    };

    static PyType_Spec type_spec_Vp9ProfileIds_Static =
    {
        "winrt._winrt_windows_media_mediaproperties.Vp9ProfileIds_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_Vp9ProfileIds_Static
    };

    // ----- IMediaEncodingProperties interface --------------------

    static PyObject* _new_IMediaEncodingProperties(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::MediaProperties::IMediaEncodingProperties>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::MediaProperties::IMediaEncodingProperties>::type_name);
        return nullptr;
    }

    static void _dealloc_IMediaEncodingProperties(py::wrapper::Windows::Media::MediaProperties::IMediaEncodingProperties* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IMediaEncodingProperties_get_Properties(py::wrapper::Windows::Media::MediaProperties::IMediaEncodingProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.IMediaEncodingProperties", L"Properties"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Properties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IMediaEncodingProperties_get_Subtype(py::wrapper::Windows::Media::MediaProperties::IMediaEncodingProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.IMediaEncodingProperties", L"Subtype"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Subtype());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IMediaEncodingProperties_put_Subtype(py::wrapper::Windows::Media::MediaProperties::IMediaEncodingProperties* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.IMediaEncodingProperties", L"Subtype"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Subtype(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IMediaEncodingProperties_get_Type(py::wrapper::Windows::Media::MediaProperties::IMediaEncodingProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.IMediaEncodingProperties", L"Type"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Type());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_IMediaEncodingProperties(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::MediaProperties::IMediaEncodingProperties>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IMediaEncodingProperties(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::MediaProperties::IMediaEncodingProperties>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IMediaEncodingProperties[] = {
        { "_assign_array_", _assign_array_IMediaEncodingProperties, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IMediaEncodingProperties), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IMediaEncodingProperties[] = {
        { "properties", reinterpret_cast<getter>(IMediaEncodingProperties_get_Properties), nullptr, nullptr, nullptr },
        { "subtype", reinterpret_cast<getter>(IMediaEncodingProperties_get_Subtype), reinterpret_cast<setter>(IMediaEncodingProperties_put_Subtype), nullptr, nullptr },
        { "type", reinterpret_cast<getter>(IMediaEncodingProperties_get_Type), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IMediaEncodingProperties[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_IMediaEncodingProperties) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IMediaEncodingProperties) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IMediaEncodingProperties) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IMediaEncodingProperties) },
        { },
    };

    static PyType_Spec type_spec_IMediaEncodingProperties =
    {
        "winrt._winrt_windows_media_mediaproperties.IMediaEncodingProperties",
        sizeof(py::wrapper::Windows::Media::MediaProperties::IMediaEncodingProperties),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IMediaEncodingProperties
    };

    // ----- Windows.Media.MediaProperties Initialization --------------------

    PyDoc_STRVAR(module_doc, "Windows.Media.MediaProperties");

    static PyModuleDef module_def = {
        PyModuleDef_HEAD_INIT,
        "_winrt_windows_media_mediaproperties",
        module_doc,
        0,
        nullptr,
        nullptr,
        nullptr,
        nullptr,
        nullptr};
} // py::cpp::Windows::Media::MediaProperties

PyMODINIT_FUNC PyInit__winrt_windows_media_mediaproperties(void) noexcept
{
    using namespace py::cpp::Windows::Media::MediaProperties;

    if (py::import_winrt_runtime() == -1)
    {
        return nullptr;
    }

    py::pyobj_handle module{PyModule_Create(&module_def)};

    if (!module)
    {
        return nullptr;
    }

    auto object_type = py::get_object_type();
    if (!object_type)
    {
        return nullptr;
    }

    py::pyobj_handle object_bases{PyTuple_Pack(1, object_type)};

    if (!object_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_AudioEncodingProperties_Static{PyType_FromSpec(&type_spec_AudioEncodingProperties_Static)};
    if (!type_AudioEncodingProperties_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_AudioEncodingProperties, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_AudioEncodingProperties_Static.get())) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_Av1ProfileIds_Static{PyType_FromSpec(&type_spec_Av1ProfileIds_Static)};
    if (!type_Av1ProfileIds_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_Av1ProfileIds, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_Av1ProfileIds_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ContainerEncodingProperties, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_H264ProfileIds_Static{PyType_FromSpec(&type_spec_H264ProfileIds_Static)};
    if (!type_H264ProfileIds_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_H264ProfileIds, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_H264ProfileIds_Static.get())) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_HevcProfileIds_Static{PyType_FromSpec(&type_spec_HevcProfileIds_Static)};
    if (!type_HevcProfileIds_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_HevcProfileIds, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_HevcProfileIds_Static.get())) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_ImageEncodingProperties_Static{PyType_FromSpec(&type_spec_ImageEncodingProperties_Static)};
    if (!type_ImageEncodingProperties_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ImageEncodingProperties, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_ImageEncodingProperties_Static.get())) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_MediaEncodingProfile_Static{PyType_FromSpec(&type_spec_MediaEncodingProfile_Static)};
    if (!type_MediaEncodingProfile_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_MediaEncodingProfile, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_MediaEncodingProfile_Static.get())) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_MediaEncodingSubtypes_Static{PyType_FromSpec(&type_spec_MediaEncodingSubtypes_Static)};
    if (!type_MediaEncodingSubtypes_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_MediaEncodingSubtypes, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_MediaEncodingSubtypes_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_MediaPropertySet, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_MediaRatio, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_Mpeg2ProfileIds_Static{PyType_FromSpec(&type_spec_Mpeg2ProfileIds_Static)};
    if (!type_Mpeg2ProfileIds_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_Mpeg2ProfileIds, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_Mpeg2ProfileIds_Static.get())) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_TimedMetadataEncodingProperties_Static{PyType_FromSpec(&type_spec_TimedMetadataEncodingProperties_Static)};
    if (!type_TimedMetadataEncodingProperties_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_TimedMetadataEncodingProperties, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_TimedMetadataEncodingProperties_Static.get())) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_VideoEncodingProperties_Static{PyType_FromSpec(&type_spec_VideoEncodingProperties_Static)};
    if (!type_VideoEncodingProperties_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_VideoEncodingProperties, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_VideoEncodingProperties_Static.get())) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_Vp9ProfileIds_Static{PyType_FromSpec(&type_spec_Vp9ProfileIds_Static)};
    if (!type_Vp9ProfileIds_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_Vp9ProfileIds, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_Vp9ProfileIds_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_IMediaEncodingProperties, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }


    return module.detach();
}
