// WARNING: Please don't edit this file. It was generated by Python/WinRT v0.0.0

#include "pybase.h"
#include "py.Windows.Media.MediaProperties.h"


namespace py::cpp::Windows::Media::MediaProperties
{
    // ----- AudioEncodingProperties class --------------------
    static constexpr const char* const type_name_AudioEncodingProperties = "AudioEncodingProperties";

    static PyObject* _new_AudioEncodingProperties(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Media::MediaProperties::AudioEncodingProperties instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_AudioEncodingProperties(py::wrapper::Windows::Media::MediaProperties::AudioEncodingProperties* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AudioEncodingProperties_Copy(py::wrapper::Windows::Media::MediaProperties::AudioEncodingProperties* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.MediaProperties.AudioEncodingProperties", L"Copy", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.Copy());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioEncodingProperties_CreateAac(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.MediaProperties.AudioEncodingProperties", L"CreateAac", 3))
            {
                py::set_arg_count_version_error(3);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);
                auto param2 = py::convert_to<uint32_t>(args, 2);

                return py::convert(winrt::Windows::Media::MediaProperties::AudioEncodingProperties::CreateAac(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioEncodingProperties_CreateAacAdts(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.MediaProperties.AudioEncodingProperties", L"CreateAacAdts", 3))
            {
                py::set_arg_count_version_error(3);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);
                auto param2 = py::convert_to<uint32_t>(args, 2);

                return py::convert(winrt::Windows::Media::MediaProperties::AudioEncodingProperties::CreateAacAdts(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioEncodingProperties_CreateAlac(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.MediaProperties.AudioEncodingProperties", L"CreateAlac", 3))
            {
                py::set_arg_count_version_error(3);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);
                auto param2 = py::convert_to<uint32_t>(args, 2);

                return py::convert(winrt::Windows::Media::MediaProperties::AudioEncodingProperties::CreateAlac(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioEncodingProperties_CreateFlac(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.MediaProperties.AudioEncodingProperties", L"CreateFlac", 3))
            {
                py::set_arg_count_version_error(3);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);
                auto param2 = py::convert_to<uint32_t>(args, 2);

                return py::convert(winrt::Windows::Media::MediaProperties::AudioEncodingProperties::CreateFlac(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioEncodingProperties_CreateMp3(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.MediaProperties.AudioEncodingProperties", L"CreateMp3", 3))
            {
                py::set_arg_count_version_error(3);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);
                auto param2 = py::convert_to<uint32_t>(args, 2);

                return py::convert(winrt::Windows::Media::MediaProperties::AudioEncodingProperties::CreateMp3(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioEncodingProperties_CreatePcm(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.MediaProperties.AudioEncodingProperties", L"CreatePcm", 3))
            {
                py::set_arg_count_version_error(3);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);
                auto param2 = py::convert_to<uint32_t>(args, 2);

                return py::convert(winrt::Windows::Media::MediaProperties::AudioEncodingProperties::CreatePcm(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioEncodingProperties_CreateWma(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.MediaProperties.AudioEncodingProperties", L"CreateWma", 3))
            {
                py::set_arg_count_version_error(3);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);
                auto param2 = py::convert_to<uint32_t>(args, 2);

                return py::convert(winrt::Windows::Media::MediaProperties::AudioEncodingProperties::CreateWma(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioEncodingProperties_GetFormatUserData(py::wrapper::Windows::Media::MediaProperties::AudioEncodingProperties* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.MediaProperties.AudioEncodingProperties", L"GetFormatUserData", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                winrt::com_array<uint8_t> param0 { };

                self->obj.GetFormatUserData(param0);

                py::pyobj_handle out0{ py::convert(param0) };
                if (!out0)
                {
                    return nullptr;
                }
                return out0.detach();
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioEncodingProperties_SetFormatUserData(py::wrapper::Windows::Media::MediaProperties::AudioEncodingProperties* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.MediaProperties.AudioEncodingProperties", L"SetFormatUserData", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<py::pybuf_view<uint8_t, false>>(args, 0);

                self->obj.SetFormatUserData(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioEncodingProperties_get_SampleRate(py::wrapper::Windows::Media::MediaProperties::AudioEncodingProperties* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.AudioEncodingProperties", L"SampleRate"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SampleRate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AudioEncodingProperties_put_SampleRate(py::wrapper::Windows::Media::MediaProperties::AudioEncodingProperties* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.AudioEncodingProperties", L"SampleRate"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.SampleRate(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AudioEncodingProperties_get_ChannelCount(py::wrapper::Windows::Media::MediaProperties::AudioEncodingProperties* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.AudioEncodingProperties", L"ChannelCount"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ChannelCount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AudioEncodingProperties_put_ChannelCount(py::wrapper::Windows::Media::MediaProperties::AudioEncodingProperties* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.AudioEncodingProperties", L"ChannelCount"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.ChannelCount(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AudioEncodingProperties_get_BitsPerSample(py::wrapper::Windows::Media::MediaProperties::AudioEncodingProperties* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.AudioEncodingProperties", L"BitsPerSample"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.BitsPerSample());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AudioEncodingProperties_put_BitsPerSample(py::wrapper::Windows::Media::MediaProperties::AudioEncodingProperties* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.AudioEncodingProperties", L"BitsPerSample"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.BitsPerSample(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AudioEncodingProperties_get_Bitrate(py::wrapper::Windows::Media::MediaProperties::AudioEncodingProperties* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.AudioEncodingProperties", L"Bitrate"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Bitrate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AudioEncodingProperties_put_Bitrate(py::wrapper::Windows::Media::MediaProperties::AudioEncodingProperties* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.AudioEncodingProperties", L"Bitrate"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.Bitrate(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AudioEncodingProperties_get_IsSpatial(py::wrapper::Windows::Media::MediaProperties::AudioEncodingProperties* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.AudioEncodingProperties", L"IsSpatial"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsSpatial());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioEncodingProperties_get_Subtype(py::wrapper::Windows::Media::MediaProperties::AudioEncodingProperties* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.AudioEncodingProperties", L"Subtype"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Subtype());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AudioEncodingProperties_put_Subtype(py::wrapper::Windows::Media::MediaProperties::AudioEncodingProperties* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.AudioEncodingProperties", L"Subtype"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Subtype(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AudioEncodingProperties_get_Properties(py::wrapper::Windows::Media::MediaProperties::AudioEncodingProperties* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.AudioEncodingProperties", L"Properties"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Properties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioEncodingProperties_get_Type(py::wrapper::Windows::Media::MediaProperties::AudioEncodingProperties* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.AudioEncodingProperties", L"Type"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Type());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AudioEncodingProperties(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::MediaProperties::AudioEncodingProperties>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AudioEncodingProperties(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::MediaProperties::AudioEncodingProperties>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AudioEncodingProperties[] = {
        { "copy", reinterpret_cast<PyCFunction>(AudioEncodingProperties_Copy), METH_VARARGS, nullptr },
        { "create_aac", reinterpret_cast<PyCFunction>(AudioEncodingProperties_CreateAac), METH_VARARGS | METH_STATIC, nullptr },
        { "create_aac_adts", reinterpret_cast<PyCFunction>(AudioEncodingProperties_CreateAacAdts), METH_VARARGS | METH_STATIC, nullptr },
        { "create_alac", reinterpret_cast<PyCFunction>(AudioEncodingProperties_CreateAlac), METH_VARARGS | METH_STATIC, nullptr },
        { "create_flac", reinterpret_cast<PyCFunction>(AudioEncodingProperties_CreateFlac), METH_VARARGS | METH_STATIC, nullptr },
        { "create_mp3", reinterpret_cast<PyCFunction>(AudioEncodingProperties_CreateMp3), METH_VARARGS | METH_STATIC, nullptr },
        { "create_pcm", reinterpret_cast<PyCFunction>(AudioEncodingProperties_CreatePcm), METH_VARARGS | METH_STATIC, nullptr },
        { "create_wma", reinterpret_cast<PyCFunction>(AudioEncodingProperties_CreateWma), METH_VARARGS | METH_STATIC, nullptr },
        { "get_format_user_data", reinterpret_cast<PyCFunction>(AudioEncodingProperties_GetFormatUserData), METH_VARARGS, nullptr },
        { "set_format_user_data", reinterpret_cast<PyCFunction>(AudioEncodingProperties_SetFormatUserData), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_AudioEncodingProperties, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AudioEncodingProperties), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AudioEncodingProperties[] = {
        { "sample_rate", reinterpret_cast<getter>(AudioEncodingProperties_get_SampleRate), reinterpret_cast<setter>(AudioEncodingProperties_put_SampleRate), nullptr, nullptr },
        { "channel_count", reinterpret_cast<getter>(AudioEncodingProperties_get_ChannelCount), reinterpret_cast<setter>(AudioEncodingProperties_put_ChannelCount), nullptr, nullptr },
        { "bits_per_sample", reinterpret_cast<getter>(AudioEncodingProperties_get_BitsPerSample), reinterpret_cast<setter>(AudioEncodingProperties_put_BitsPerSample), nullptr, nullptr },
        { "bitrate", reinterpret_cast<getter>(AudioEncodingProperties_get_Bitrate), reinterpret_cast<setter>(AudioEncodingProperties_put_Bitrate), nullptr, nullptr },
        { "is_spatial", reinterpret_cast<getter>(AudioEncodingProperties_get_IsSpatial), nullptr, nullptr, nullptr },
        { "subtype", reinterpret_cast<getter>(AudioEncodingProperties_get_Subtype), reinterpret_cast<setter>(AudioEncodingProperties_put_Subtype), nullptr, nullptr },
        { "properties", reinterpret_cast<getter>(AudioEncodingProperties_get_Properties), nullptr, nullptr, nullptr },
        { "type", reinterpret_cast<getter>(AudioEncodingProperties_get_Type), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AudioEncodingProperties[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AudioEncodingProperties) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AudioEncodingProperties) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AudioEncodingProperties) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AudioEncodingProperties) },
        { },
    };

    static PyType_Spec type_spec_AudioEncodingProperties =
    {
        "_winrt_windows_media_mediaproperties.AudioEncodingProperties",
        sizeof(py::wrapper::Windows::Media::MediaProperties::AudioEncodingProperties),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AudioEncodingProperties
    };

    // ----- ContainerEncodingProperties class --------------------
    static constexpr const char* const type_name_ContainerEncodingProperties = "ContainerEncodingProperties";

    static PyObject* _new_ContainerEncodingProperties(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Media::MediaProperties::ContainerEncodingProperties instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ContainerEncodingProperties(py::wrapper::Windows::Media::MediaProperties::ContainerEncodingProperties* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ContainerEncodingProperties_Copy(py::wrapper::Windows::Media::MediaProperties::ContainerEncodingProperties* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.MediaProperties.ContainerEncodingProperties", L"Copy", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.Copy());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContainerEncodingProperties_get_Subtype(py::wrapper::Windows::Media::MediaProperties::ContainerEncodingProperties* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.ContainerEncodingProperties", L"Subtype"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Subtype());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContainerEncodingProperties_put_Subtype(py::wrapper::Windows::Media::MediaProperties::ContainerEncodingProperties* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.ContainerEncodingProperties", L"Subtype"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Subtype(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContainerEncodingProperties_get_Properties(py::wrapper::Windows::Media::MediaProperties::ContainerEncodingProperties* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.ContainerEncodingProperties", L"Properties"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Properties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContainerEncodingProperties_get_Type(py::wrapper::Windows::Media::MediaProperties::ContainerEncodingProperties* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.ContainerEncodingProperties", L"Type"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Type());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ContainerEncodingProperties(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::MediaProperties::ContainerEncodingProperties>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ContainerEncodingProperties(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::MediaProperties::ContainerEncodingProperties>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ContainerEncodingProperties[] = {
        { "copy", reinterpret_cast<PyCFunction>(ContainerEncodingProperties_Copy), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_ContainerEncodingProperties, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ContainerEncodingProperties), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ContainerEncodingProperties[] = {
        { "subtype", reinterpret_cast<getter>(ContainerEncodingProperties_get_Subtype), reinterpret_cast<setter>(ContainerEncodingProperties_put_Subtype), nullptr, nullptr },
        { "properties", reinterpret_cast<getter>(ContainerEncodingProperties_get_Properties), nullptr, nullptr, nullptr },
        { "type", reinterpret_cast<getter>(ContainerEncodingProperties_get_Type), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ContainerEncodingProperties[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ContainerEncodingProperties) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ContainerEncodingProperties) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ContainerEncodingProperties) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ContainerEncodingProperties) },
        { },
    };

    static PyType_Spec type_spec_ContainerEncodingProperties =
    {
        "_winrt_windows_media_mediaproperties.ContainerEncodingProperties",
        sizeof(py::wrapper::Windows::Media::MediaProperties::ContainerEncodingProperties),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ContainerEncodingProperties
    };

    // ----- H264ProfileIds class --------------------
    static constexpr const char* const type_name_H264ProfileIds = "H264ProfileIds";

    static PyObject* _new_H264ProfileIds(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_H264ProfileIds);
        return nullptr;
    }

    static PyObject* H264ProfileIds_get_Baseline(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.H264ProfileIds", L"Baseline"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Media::MediaProperties::H264ProfileIds::Baseline());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* H264ProfileIds_get_ConstrainedBaseline(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.H264ProfileIds", L"ConstrainedBaseline"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Media::MediaProperties::H264ProfileIds::ConstrainedBaseline());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* H264ProfileIds_get_Extended(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.H264ProfileIds", L"Extended"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Media::MediaProperties::H264ProfileIds::Extended());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* H264ProfileIds_get_High(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.H264ProfileIds", L"High"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Media::MediaProperties::H264ProfileIds::High());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* H264ProfileIds_get_High10(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.H264ProfileIds", L"High10"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Media::MediaProperties::H264ProfileIds::High10());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* H264ProfileIds_get_High422(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.H264ProfileIds", L"High422"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Media::MediaProperties::H264ProfileIds::High422());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* H264ProfileIds_get_High444(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.H264ProfileIds", L"High444"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Media::MediaProperties::H264ProfileIds::High444());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* H264ProfileIds_get_Main(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.H264ProfileIds", L"Main"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Media::MediaProperties::H264ProfileIds::Main());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* H264ProfileIds_get_MultiviewHigh(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.H264ProfileIds", L"MultiviewHigh"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Media::MediaProperties::H264ProfileIds::MultiviewHigh());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* H264ProfileIds_get_StereoHigh(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.H264ProfileIds", L"StereoHigh"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Media::MediaProperties::H264ProfileIds::StereoHigh());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_H264ProfileIds[] = {
        { }
    };

    static PyGetSetDef _getset_H264ProfileIds[] = {
        { }
    };

    static PyType_Slot _type_slots_H264ProfileIds[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_H264ProfileIds) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_H264ProfileIds) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_H264ProfileIds) },
        { },
    };

    static PyType_Spec type_spec_H264ProfileIds =
    {
        "_winrt_windows_media_mediaproperties.H264ProfileIds",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_H264ProfileIds
    };

    static PyGetSetDef getset_H264ProfileIds_Meta[] = {
        { "baseline", reinterpret_cast<getter>(H264ProfileIds_get_Baseline), nullptr, nullptr, nullptr },
        { "constrained_baseline", reinterpret_cast<getter>(H264ProfileIds_get_ConstrainedBaseline), nullptr, nullptr, nullptr },
        { "extended", reinterpret_cast<getter>(H264ProfileIds_get_Extended), nullptr, nullptr, nullptr },
        { "high", reinterpret_cast<getter>(H264ProfileIds_get_High), nullptr, nullptr, nullptr },
        { "high10", reinterpret_cast<getter>(H264ProfileIds_get_High10), nullptr, nullptr, nullptr },
        { "high422", reinterpret_cast<getter>(H264ProfileIds_get_High422), nullptr, nullptr, nullptr },
        { "high444", reinterpret_cast<getter>(H264ProfileIds_get_High444), nullptr, nullptr, nullptr },
        { "main", reinterpret_cast<getter>(H264ProfileIds_get_Main), nullptr, nullptr, nullptr },
        { "multiview_high", reinterpret_cast<getter>(H264ProfileIds_get_MultiviewHigh), nullptr, nullptr, nullptr },
        { "stereo_high", reinterpret_cast<getter>(H264ProfileIds_get_StereoHigh), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot type_slots_H264ProfileIds_Meta[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_H264ProfileIds_Meta) },
        { }
    };

    static PyType_Spec type_spec_H264ProfileIds_Meta =
    {
        "_winrt_windows_media_mediaproperties.H264ProfileIds_Meta",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_H264ProfileIds_Meta
    };

    // ----- ImageEncodingProperties class --------------------
    static constexpr const char* const type_name_ImageEncodingProperties = "ImageEncodingProperties";

    static PyObject* _new_ImageEncodingProperties(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Media::MediaProperties::ImageEncodingProperties instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ImageEncodingProperties(py::wrapper::Windows::Media::MediaProperties::ImageEncodingProperties* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ImageEncodingProperties_Copy(py::wrapper::Windows::Media::MediaProperties::ImageEncodingProperties* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.MediaProperties.ImageEncodingProperties", L"Copy", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.Copy());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ImageEncodingProperties_CreateBmp(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.MediaProperties.ImageEncodingProperties", L"CreateBmp", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::Media::MediaProperties::ImageEncodingProperties::CreateBmp());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ImageEncodingProperties_CreateHeif(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.MediaProperties.ImageEncodingProperties", L"CreateHeif", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::Media::MediaProperties::ImageEncodingProperties::CreateHeif());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ImageEncodingProperties_CreateJpeg(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.MediaProperties.ImageEncodingProperties", L"CreateJpeg", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::Media::MediaProperties::ImageEncodingProperties::CreateJpeg());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ImageEncodingProperties_CreateJpegXR(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.MediaProperties.ImageEncodingProperties", L"CreateJpegXR", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::Media::MediaProperties::ImageEncodingProperties::CreateJpegXR());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ImageEncodingProperties_CreatePng(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.MediaProperties.ImageEncodingProperties", L"CreatePng", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::Media::MediaProperties::ImageEncodingProperties::CreatePng());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ImageEncodingProperties_CreateUncompressed(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.MediaProperties.ImageEncodingProperties", L"CreateUncompressed", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::MediaProperties::MediaPixelFormat>(args, 0);

                return py::convert(winrt::Windows::Media::MediaProperties::ImageEncodingProperties::CreateUncompressed(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ImageEncodingProperties_get_Width(py::wrapper::Windows::Media::MediaProperties::ImageEncodingProperties* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.ImageEncodingProperties", L"Width"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Width());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ImageEncodingProperties_put_Width(py::wrapper::Windows::Media::MediaProperties::ImageEncodingProperties* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.ImageEncodingProperties", L"Width"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.Width(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ImageEncodingProperties_get_Height(py::wrapper::Windows::Media::MediaProperties::ImageEncodingProperties* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.ImageEncodingProperties", L"Height"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Height());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ImageEncodingProperties_put_Height(py::wrapper::Windows::Media::MediaProperties::ImageEncodingProperties* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.ImageEncodingProperties", L"Height"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.Height(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ImageEncodingProperties_get_Subtype(py::wrapper::Windows::Media::MediaProperties::ImageEncodingProperties* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.ImageEncodingProperties", L"Subtype"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Subtype());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ImageEncodingProperties_put_Subtype(py::wrapper::Windows::Media::MediaProperties::ImageEncodingProperties* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.ImageEncodingProperties", L"Subtype"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Subtype(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ImageEncodingProperties_get_Properties(py::wrapper::Windows::Media::MediaProperties::ImageEncodingProperties* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.ImageEncodingProperties", L"Properties"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Properties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ImageEncodingProperties_get_Type(py::wrapper::Windows::Media::MediaProperties::ImageEncodingProperties* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.ImageEncodingProperties", L"Type"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Type());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ImageEncodingProperties(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::MediaProperties::ImageEncodingProperties>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ImageEncodingProperties(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::MediaProperties::ImageEncodingProperties>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ImageEncodingProperties[] = {
        { "copy", reinterpret_cast<PyCFunction>(ImageEncodingProperties_Copy), METH_VARARGS, nullptr },
        { "create_bmp", reinterpret_cast<PyCFunction>(ImageEncodingProperties_CreateBmp), METH_VARARGS | METH_STATIC, nullptr },
        { "create_heif", reinterpret_cast<PyCFunction>(ImageEncodingProperties_CreateHeif), METH_VARARGS | METH_STATIC, nullptr },
        { "create_jpeg", reinterpret_cast<PyCFunction>(ImageEncodingProperties_CreateJpeg), METH_VARARGS | METH_STATIC, nullptr },
        { "create_jpeg_x_r", reinterpret_cast<PyCFunction>(ImageEncodingProperties_CreateJpegXR), METH_VARARGS | METH_STATIC, nullptr },
        { "create_png", reinterpret_cast<PyCFunction>(ImageEncodingProperties_CreatePng), METH_VARARGS | METH_STATIC, nullptr },
        { "create_uncompressed", reinterpret_cast<PyCFunction>(ImageEncodingProperties_CreateUncompressed), METH_VARARGS | METH_STATIC, nullptr },
        { "_assign_array_", _assign_array_ImageEncodingProperties, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ImageEncodingProperties), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ImageEncodingProperties[] = {
        { "width", reinterpret_cast<getter>(ImageEncodingProperties_get_Width), reinterpret_cast<setter>(ImageEncodingProperties_put_Width), nullptr, nullptr },
        { "height", reinterpret_cast<getter>(ImageEncodingProperties_get_Height), reinterpret_cast<setter>(ImageEncodingProperties_put_Height), nullptr, nullptr },
        { "subtype", reinterpret_cast<getter>(ImageEncodingProperties_get_Subtype), reinterpret_cast<setter>(ImageEncodingProperties_put_Subtype), nullptr, nullptr },
        { "properties", reinterpret_cast<getter>(ImageEncodingProperties_get_Properties), nullptr, nullptr, nullptr },
        { "type", reinterpret_cast<getter>(ImageEncodingProperties_get_Type), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ImageEncodingProperties[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ImageEncodingProperties) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ImageEncodingProperties) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ImageEncodingProperties) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ImageEncodingProperties) },
        { },
    };

    static PyType_Spec type_spec_ImageEncodingProperties =
    {
        "_winrt_windows_media_mediaproperties.ImageEncodingProperties",
        sizeof(py::wrapper::Windows::Media::MediaProperties::ImageEncodingProperties),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ImageEncodingProperties
    };

    // ----- MediaEncodingProfile class --------------------
    static constexpr const char* const type_name_MediaEncodingProfile = "MediaEncodingProfile";

    static PyObject* _new_MediaEncodingProfile(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Media::MediaProperties::MediaEncodingProfile instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MediaEncodingProfile(py::wrapper::Windows::Media::MediaProperties::MediaEncodingProfile* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MediaEncodingProfile_CreateAlac(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.MediaProperties.MediaEncodingProfile", L"CreateAlac", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::MediaProperties::AudioEncodingQuality>(args, 0);

                return py::convert(winrt::Windows::Media::MediaProperties::MediaEncodingProfile::CreateAlac(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaEncodingProfile_CreateAvi(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.MediaProperties.MediaEncodingProfile", L"CreateAvi", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::MediaProperties::VideoEncodingQuality>(args, 0);

                return py::convert(winrt::Windows::Media::MediaProperties::MediaEncodingProfile::CreateAvi(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaEncodingProfile_CreateFlac(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.MediaProperties.MediaEncodingProfile", L"CreateFlac", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::MediaProperties::AudioEncodingQuality>(args, 0);

                return py::convert(winrt::Windows::Media::MediaProperties::MediaEncodingProfile::CreateFlac(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaEncodingProfile_CreateFromFileAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.MediaProperties.MediaEncodingProfile", L"CreateFromFileAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFile>(args, 0);

                return py::convert(winrt::Windows::Media::MediaProperties::MediaEncodingProfile::CreateFromFileAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaEncodingProfile_CreateFromStreamAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.MediaProperties.MediaEncodingProfile", L"CreateFromStreamAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStream>(args, 0);

                return py::convert(winrt::Windows::Media::MediaProperties::MediaEncodingProfile::CreateFromStreamAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaEncodingProfile_CreateHevc(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.MediaProperties.MediaEncodingProfile", L"CreateHevc", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::MediaProperties::VideoEncodingQuality>(args, 0);

                return py::convert(winrt::Windows::Media::MediaProperties::MediaEncodingProfile::CreateHevc(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaEncodingProfile_CreateM4a(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.MediaProperties.MediaEncodingProfile", L"CreateM4a", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::MediaProperties::AudioEncodingQuality>(args, 0);

                return py::convert(winrt::Windows::Media::MediaProperties::MediaEncodingProfile::CreateM4a(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaEncodingProfile_CreateMp3(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.MediaProperties.MediaEncodingProfile", L"CreateMp3", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::MediaProperties::AudioEncodingQuality>(args, 0);

                return py::convert(winrt::Windows::Media::MediaProperties::MediaEncodingProfile::CreateMp3(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaEncodingProfile_CreateMp4(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.MediaProperties.MediaEncodingProfile", L"CreateMp4", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::MediaProperties::VideoEncodingQuality>(args, 0);

                return py::convert(winrt::Windows::Media::MediaProperties::MediaEncodingProfile::CreateMp4(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaEncodingProfile_CreateWav(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.MediaProperties.MediaEncodingProfile", L"CreateWav", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::MediaProperties::AudioEncodingQuality>(args, 0);

                return py::convert(winrt::Windows::Media::MediaProperties::MediaEncodingProfile::CreateWav(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaEncodingProfile_CreateWma(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.MediaProperties.MediaEncodingProfile", L"CreateWma", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::MediaProperties::AudioEncodingQuality>(args, 0);

                return py::convert(winrt::Windows::Media::MediaProperties::MediaEncodingProfile::CreateWma(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaEncodingProfile_CreateWmv(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.MediaProperties.MediaEncodingProfile", L"CreateWmv", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::MediaProperties::VideoEncodingQuality>(args, 0);

                return py::convert(winrt::Windows::Media::MediaProperties::MediaEncodingProfile::CreateWmv(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaEncodingProfile_GetAudioTracks(py::wrapper::Windows::Media::MediaProperties::MediaEncodingProfile* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.MediaProperties.MediaEncodingProfile", L"GetAudioTracks", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetAudioTracks());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaEncodingProfile_GetTimedMetadataTracks(py::wrapper::Windows::Media::MediaProperties::MediaEncodingProfile* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.MediaProperties.MediaEncodingProfile", L"GetTimedMetadataTracks", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetTimedMetadataTracks());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaEncodingProfile_GetVideoTracks(py::wrapper::Windows::Media::MediaProperties::MediaEncodingProfile* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.MediaProperties.MediaEncodingProfile", L"GetVideoTracks", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetVideoTracks());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaEncodingProfile_SetAudioTracks(py::wrapper::Windows::Media::MediaProperties::MediaEncodingProfile* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.MediaProperties.MediaEncodingProfile", L"SetAudioTracks", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Media::Core::AudioStreamDescriptor>>(args, 0);

                self->obj.SetAudioTracks(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaEncodingProfile_SetTimedMetadataTracks(py::wrapper::Windows::Media::MediaProperties::MediaEncodingProfile* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.MediaProperties.MediaEncodingProfile", L"SetTimedMetadataTracks", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Media::Core::TimedMetadataStreamDescriptor>>(args, 0);

                self->obj.SetTimedMetadataTracks(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaEncodingProfile_SetVideoTracks(py::wrapper::Windows::Media::MediaProperties::MediaEncodingProfile* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.MediaProperties.MediaEncodingProfile", L"SetVideoTracks", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Media::Core::VideoStreamDescriptor>>(args, 0);

                self->obj.SetVideoTracks(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaEncodingProfile_get_Video(py::wrapper::Windows::Media::MediaProperties::MediaEncodingProfile* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.MediaEncodingProfile", L"Video"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Video());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaEncodingProfile_put_Video(py::wrapper::Windows::Media::MediaProperties::MediaEncodingProfile* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.MediaEncodingProfile", L"Video"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::MediaProperties::VideoEncodingProperties>(arg);

            self->obj.Video(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaEncodingProfile_get_Container(py::wrapper::Windows::Media::MediaProperties::MediaEncodingProfile* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.MediaEncodingProfile", L"Container"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Container());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaEncodingProfile_put_Container(py::wrapper::Windows::Media::MediaProperties::MediaEncodingProfile* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.MediaEncodingProfile", L"Container"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::MediaProperties::ContainerEncodingProperties>(arg);

            self->obj.Container(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaEncodingProfile_get_Audio(py::wrapper::Windows::Media::MediaProperties::MediaEncodingProfile* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.MediaEncodingProfile", L"Audio"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Audio());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaEncodingProfile_put_Audio(py::wrapper::Windows::Media::MediaProperties::MediaEncodingProfile* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.MediaEncodingProfile", L"Audio"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::MediaProperties::AudioEncodingProperties>(arg);

            self->obj.Audio(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_MediaEncodingProfile(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::MediaProperties::MediaEncodingProfile>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MediaEncodingProfile(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::MediaProperties::MediaEncodingProfile>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaEncodingProfile[] = {
        { "create_alac", reinterpret_cast<PyCFunction>(MediaEncodingProfile_CreateAlac), METH_VARARGS | METH_STATIC, nullptr },
        { "create_avi", reinterpret_cast<PyCFunction>(MediaEncodingProfile_CreateAvi), METH_VARARGS | METH_STATIC, nullptr },
        { "create_flac", reinterpret_cast<PyCFunction>(MediaEncodingProfile_CreateFlac), METH_VARARGS | METH_STATIC, nullptr },
        { "create_from_file_async", reinterpret_cast<PyCFunction>(MediaEncodingProfile_CreateFromFileAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "create_from_stream_async", reinterpret_cast<PyCFunction>(MediaEncodingProfile_CreateFromStreamAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "create_hevc", reinterpret_cast<PyCFunction>(MediaEncodingProfile_CreateHevc), METH_VARARGS | METH_STATIC, nullptr },
        { "create_m4a", reinterpret_cast<PyCFunction>(MediaEncodingProfile_CreateM4a), METH_VARARGS | METH_STATIC, nullptr },
        { "create_mp3", reinterpret_cast<PyCFunction>(MediaEncodingProfile_CreateMp3), METH_VARARGS | METH_STATIC, nullptr },
        { "create_mp4", reinterpret_cast<PyCFunction>(MediaEncodingProfile_CreateMp4), METH_VARARGS | METH_STATIC, nullptr },
        { "create_wav", reinterpret_cast<PyCFunction>(MediaEncodingProfile_CreateWav), METH_VARARGS | METH_STATIC, nullptr },
        { "create_wma", reinterpret_cast<PyCFunction>(MediaEncodingProfile_CreateWma), METH_VARARGS | METH_STATIC, nullptr },
        { "create_wmv", reinterpret_cast<PyCFunction>(MediaEncodingProfile_CreateWmv), METH_VARARGS | METH_STATIC, nullptr },
        { "get_audio_tracks", reinterpret_cast<PyCFunction>(MediaEncodingProfile_GetAudioTracks), METH_VARARGS, nullptr },
        { "get_timed_metadata_tracks", reinterpret_cast<PyCFunction>(MediaEncodingProfile_GetTimedMetadataTracks), METH_VARARGS, nullptr },
        { "get_video_tracks", reinterpret_cast<PyCFunction>(MediaEncodingProfile_GetVideoTracks), METH_VARARGS, nullptr },
        { "set_audio_tracks", reinterpret_cast<PyCFunction>(MediaEncodingProfile_SetAudioTracks), METH_VARARGS, nullptr },
        { "set_timed_metadata_tracks", reinterpret_cast<PyCFunction>(MediaEncodingProfile_SetTimedMetadataTracks), METH_VARARGS, nullptr },
        { "set_video_tracks", reinterpret_cast<PyCFunction>(MediaEncodingProfile_SetVideoTracks), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_MediaEncodingProfile, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MediaEncodingProfile), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MediaEncodingProfile[] = {
        { "video", reinterpret_cast<getter>(MediaEncodingProfile_get_Video), reinterpret_cast<setter>(MediaEncodingProfile_put_Video), nullptr, nullptr },
        { "container", reinterpret_cast<getter>(MediaEncodingProfile_get_Container), reinterpret_cast<setter>(MediaEncodingProfile_put_Container), nullptr, nullptr },
        { "audio", reinterpret_cast<getter>(MediaEncodingProfile_get_Audio), reinterpret_cast<setter>(MediaEncodingProfile_put_Audio), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MediaEncodingProfile[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MediaEncodingProfile) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MediaEncodingProfile) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MediaEncodingProfile) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MediaEncodingProfile) },
        { },
    };

    static PyType_Spec type_spec_MediaEncodingProfile =
    {
        "_winrt_windows_media_mediaproperties.MediaEncodingProfile",
        sizeof(py::wrapper::Windows::Media::MediaProperties::MediaEncodingProfile),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaEncodingProfile
    };

    // ----- MediaEncodingSubtypes class --------------------
    static constexpr const char* const type_name_MediaEncodingSubtypes = "MediaEncodingSubtypes";

    static PyObject* _new_MediaEncodingSubtypes(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_MediaEncodingSubtypes);
        return nullptr;
    }

    static PyObject* MediaEncodingSubtypes_get_Asf(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.MediaEncodingSubtypes", L"Asf"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Media::MediaProperties::MediaEncodingSubtypes::Asf());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaEncodingSubtypes_get_Aac(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.MediaEncodingSubtypes", L"Aac"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Media::MediaProperties::MediaEncodingSubtypes::Aac());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaEncodingSubtypes_get_AacAdts(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.MediaEncodingSubtypes", L"AacAdts"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Media::MediaProperties::MediaEncodingSubtypes::AacAdts());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaEncodingSubtypes_get_Ac3(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.MediaEncodingSubtypes", L"Ac3"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Media::MediaProperties::MediaEncodingSubtypes::Ac3());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaEncodingSubtypes_get_AmrNb(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.MediaEncodingSubtypes", L"AmrNb"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Media::MediaProperties::MediaEncodingSubtypes::AmrNb());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaEncodingSubtypes_get_AmrWb(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.MediaEncodingSubtypes", L"AmrWb"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Media::MediaProperties::MediaEncodingSubtypes::AmrWb());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaEncodingSubtypes_get_Argb32(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.MediaEncodingSubtypes", L"Argb32"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Media::MediaProperties::MediaEncodingSubtypes::Argb32());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaEncodingSubtypes_get_Mpeg1(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.MediaEncodingSubtypes", L"Mpeg1"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Media::MediaProperties::MediaEncodingSubtypes::Mpeg1());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaEncodingSubtypes_get_Avi(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.MediaEncodingSubtypes", L"Avi"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Media::MediaProperties::MediaEncodingSubtypes::Avi());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaEncodingSubtypes_get_Bgra8(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.MediaEncodingSubtypes", L"Bgra8"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Media::MediaProperties::MediaEncodingSubtypes::Bgra8());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaEncodingSubtypes_get_Bmp(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.MediaEncodingSubtypes", L"Bmp"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Media::MediaProperties::MediaEncodingSubtypes::Bmp());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaEncodingSubtypes_get_Eac3(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.MediaEncodingSubtypes", L"Eac3"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Media::MediaProperties::MediaEncodingSubtypes::Eac3());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaEncodingSubtypes_get_Float(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.MediaEncodingSubtypes", L"Float"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Media::MediaProperties::MediaEncodingSubtypes::Float());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaEncodingSubtypes_get_Gif(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.MediaEncodingSubtypes", L"Gif"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Media::MediaProperties::MediaEncodingSubtypes::Gif());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaEncodingSubtypes_get_H263(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.MediaEncodingSubtypes", L"H263"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Media::MediaProperties::MediaEncodingSubtypes::H263());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaEncodingSubtypes_get_H264(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.MediaEncodingSubtypes", L"H264"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Media::MediaProperties::MediaEncodingSubtypes::H264());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaEncodingSubtypes_get_H264Es(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.MediaEncodingSubtypes", L"H264Es"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Media::MediaProperties::MediaEncodingSubtypes::H264Es());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaEncodingSubtypes_get_Hevc(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.MediaEncodingSubtypes", L"Hevc"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Media::MediaProperties::MediaEncodingSubtypes::Hevc());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaEncodingSubtypes_get_HevcEs(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.MediaEncodingSubtypes", L"HevcEs"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Media::MediaProperties::MediaEncodingSubtypes::HevcEs());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaEncodingSubtypes_get_Iyuv(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.MediaEncodingSubtypes", L"Iyuv"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Media::MediaProperties::MediaEncodingSubtypes::Iyuv());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaEncodingSubtypes_get_Jpeg(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.MediaEncodingSubtypes", L"Jpeg"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Media::MediaProperties::MediaEncodingSubtypes::Jpeg());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaEncodingSubtypes_get_JpegXr(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.MediaEncodingSubtypes", L"JpegXr"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Media::MediaProperties::MediaEncodingSubtypes::JpegXr());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaEncodingSubtypes_get_Mjpg(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.MediaEncodingSubtypes", L"Mjpg"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Media::MediaProperties::MediaEncodingSubtypes::Mjpg());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaEncodingSubtypes_get_Mp3(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.MediaEncodingSubtypes", L"Mp3"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Media::MediaProperties::MediaEncodingSubtypes::Mp3());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaEncodingSubtypes_get_Mpeg(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.MediaEncodingSubtypes", L"Mpeg"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Media::MediaProperties::MediaEncodingSubtypes::Mpeg());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaEncodingSubtypes_get_Mpeg2(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.MediaEncodingSubtypes", L"Mpeg2"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Media::MediaProperties::MediaEncodingSubtypes::Mpeg2());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaEncodingSubtypes_get_Mpeg4(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.MediaEncodingSubtypes", L"Mpeg4"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Media::MediaProperties::MediaEncodingSubtypes::Mpeg4());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaEncodingSubtypes_get_Nv12(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.MediaEncodingSubtypes", L"Nv12"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Media::MediaProperties::MediaEncodingSubtypes::Nv12());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaEncodingSubtypes_get_Pcm(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.MediaEncodingSubtypes", L"Pcm"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Media::MediaProperties::MediaEncodingSubtypes::Pcm());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaEncodingSubtypes_get_Png(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.MediaEncodingSubtypes", L"Png"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Media::MediaProperties::MediaEncodingSubtypes::Png());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaEncodingSubtypes_get_Rgb24(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.MediaEncodingSubtypes", L"Rgb24"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Media::MediaProperties::MediaEncodingSubtypes::Rgb24());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaEncodingSubtypes_get_Rgb32(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.MediaEncodingSubtypes", L"Rgb32"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Media::MediaProperties::MediaEncodingSubtypes::Rgb32());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaEncodingSubtypes_get_Tiff(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.MediaEncodingSubtypes", L"Tiff"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Media::MediaProperties::MediaEncodingSubtypes::Tiff());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaEncodingSubtypes_get_Wave(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.MediaEncodingSubtypes", L"Wave"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Media::MediaProperties::MediaEncodingSubtypes::Wave());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaEncodingSubtypes_get_Wma8(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.MediaEncodingSubtypes", L"Wma8"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Media::MediaProperties::MediaEncodingSubtypes::Wma8());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaEncodingSubtypes_get_Wma9(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.MediaEncodingSubtypes", L"Wma9"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Media::MediaProperties::MediaEncodingSubtypes::Wma9());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaEncodingSubtypes_get_Wmv3(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.MediaEncodingSubtypes", L"Wmv3"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Media::MediaProperties::MediaEncodingSubtypes::Wmv3());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaEncodingSubtypes_get_Wvc1(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.MediaEncodingSubtypes", L"Wvc1"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Media::MediaProperties::MediaEncodingSubtypes::Wvc1());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaEncodingSubtypes_get_Yuy2(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.MediaEncodingSubtypes", L"Yuy2"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Media::MediaProperties::MediaEncodingSubtypes::Yuy2());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaEncodingSubtypes_get_Yv12(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.MediaEncodingSubtypes", L"Yv12"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Media::MediaProperties::MediaEncodingSubtypes::Yv12());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaEncodingSubtypes_get_D16(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.MediaEncodingSubtypes", L"D16"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Media::MediaProperties::MediaEncodingSubtypes::D16());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaEncodingSubtypes_get_L16(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.MediaEncodingSubtypes", L"L16"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Media::MediaProperties::MediaEncodingSubtypes::L16());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaEncodingSubtypes_get_L8(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.MediaEncodingSubtypes", L"L8"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Media::MediaProperties::MediaEncodingSubtypes::L8());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaEncodingSubtypes_get_Vp9(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.MediaEncodingSubtypes", L"Vp9"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Media::MediaProperties::MediaEncodingSubtypes::Vp9());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaEncodingSubtypes_get_Alac(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.MediaEncodingSubtypes", L"Alac"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Media::MediaProperties::MediaEncodingSubtypes::Alac());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaEncodingSubtypes_get_Flac(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.MediaEncodingSubtypes", L"Flac"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Media::MediaProperties::MediaEncodingSubtypes::Flac());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaEncodingSubtypes_get_P010(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.MediaEncodingSubtypes", L"P010"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Media::MediaProperties::MediaEncodingSubtypes::P010());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaEncodingSubtypes_get_Heif(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.MediaEncodingSubtypes", L"Heif"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Media::MediaProperties::MediaEncodingSubtypes::Heif());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaEncodingSubtypes_get_Srt(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.MediaEncodingSubtypes", L"Srt"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Media::MediaProperties::MediaEncodingSubtypes::Srt());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaEncodingSubtypes_get_Ssa(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.MediaEncodingSubtypes", L"Ssa"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Media::MediaProperties::MediaEncodingSubtypes::Ssa());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaEncodingSubtypes_get_VobSub(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.MediaEncodingSubtypes", L"VobSub"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Media::MediaProperties::MediaEncodingSubtypes::VobSub());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaEncodingSubtypes_get_Pgs(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.MediaEncodingSubtypes", L"Pgs"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Media::MediaProperties::MediaEncodingSubtypes::Pgs());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaEncodingSubtypes[] = {
        { }
    };

    static PyGetSetDef _getset_MediaEncodingSubtypes[] = {
        { }
    };

    static PyType_Slot _type_slots_MediaEncodingSubtypes[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MediaEncodingSubtypes) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MediaEncodingSubtypes) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MediaEncodingSubtypes) },
        { },
    };

    static PyType_Spec type_spec_MediaEncodingSubtypes =
    {
        "_winrt_windows_media_mediaproperties.MediaEncodingSubtypes",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaEncodingSubtypes
    };

    static PyGetSetDef getset_MediaEncodingSubtypes_Meta[] = {
        { "asf", reinterpret_cast<getter>(MediaEncodingSubtypes_get_Asf), nullptr, nullptr, nullptr },
        { "aac", reinterpret_cast<getter>(MediaEncodingSubtypes_get_Aac), nullptr, nullptr, nullptr },
        { "aac_adts", reinterpret_cast<getter>(MediaEncodingSubtypes_get_AacAdts), nullptr, nullptr, nullptr },
        { "ac3", reinterpret_cast<getter>(MediaEncodingSubtypes_get_Ac3), nullptr, nullptr, nullptr },
        { "amr_nb", reinterpret_cast<getter>(MediaEncodingSubtypes_get_AmrNb), nullptr, nullptr, nullptr },
        { "amr_wb", reinterpret_cast<getter>(MediaEncodingSubtypes_get_AmrWb), nullptr, nullptr, nullptr },
        { "argb32", reinterpret_cast<getter>(MediaEncodingSubtypes_get_Argb32), nullptr, nullptr, nullptr },
        { "mpeg1", reinterpret_cast<getter>(MediaEncodingSubtypes_get_Mpeg1), nullptr, nullptr, nullptr },
        { "avi", reinterpret_cast<getter>(MediaEncodingSubtypes_get_Avi), nullptr, nullptr, nullptr },
        { "bgra8", reinterpret_cast<getter>(MediaEncodingSubtypes_get_Bgra8), nullptr, nullptr, nullptr },
        { "bmp", reinterpret_cast<getter>(MediaEncodingSubtypes_get_Bmp), nullptr, nullptr, nullptr },
        { "eac3", reinterpret_cast<getter>(MediaEncodingSubtypes_get_Eac3), nullptr, nullptr, nullptr },
        { "float", reinterpret_cast<getter>(MediaEncodingSubtypes_get_Float), nullptr, nullptr, nullptr },
        { "gif", reinterpret_cast<getter>(MediaEncodingSubtypes_get_Gif), nullptr, nullptr, nullptr },
        { "h263", reinterpret_cast<getter>(MediaEncodingSubtypes_get_H263), nullptr, nullptr, nullptr },
        { "h264", reinterpret_cast<getter>(MediaEncodingSubtypes_get_H264), nullptr, nullptr, nullptr },
        { "h264_es", reinterpret_cast<getter>(MediaEncodingSubtypes_get_H264Es), nullptr, nullptr, nullptr },
        { "hevc", reinterpret_cast<getter>(MediaEncodingSubtypes_get_Hevc), nullptr, nullptr, nullptr },
        { "hevc_es", reinterpret_cast<getter>(MediaEncodingSubtypes_get_HevcEs), nullptr, nullptr, nullptr },
        { "iyuv", reinterpret_cast<getter>(MediaEncodingSubtypes_get_Iyuv), nullptr, nullptr, nullptr },
        { "jpeg", reinterpret_cast<getter>(MediaEncodingSubtypes_get_Jpeg), nullptr, nullptr, nullptr },
        { "jpeg_xr", reinterpret_cast<getter>(MediaEncodingSubtypes_get_JpegXr), nullptr, nullptr, nullptr },
        { "mjpg", reinterpret_cast<getter>(MediaEncodingSubtypes_get_Mjpg), nullptr, nullptr, nullptr },
        { "mp3", reinterpret_cast<getter>(MediaEncodingSubtypes_get_Mp3), nullptr, nullptr, nullptr },
        { "mpeg", reinterpret_cast<getter>(MediaEncodingSubtypes_get_Mpeg), nullptr, nullptr, nullptr },
        { "mpeg2", reinterpret_cast<getter>(MediaEncodingSubtypes_get_Mpeg2), nullptr, nullptr, nullptr },
        { "mpeg4", reinterpret_cast<getter>(MediaEncodingSubtypes_get_Mpeg4), nullptr, nullptr, nullptr },
        { "nv12", reinterpret_cast<getter>(MediaEncodingSubtypes_get_Nv12), nullptr, nullptr, nullptr },
        { "pcm", reinterpret_cast<getter>(MediaEncodingSubtypes_get_Pcm), nullptr, nullptr, nullptr },
        { "png", reinterpret_cast<getter>(MediaEncodingSubtypes_get_Png), nullptr, nullptr, nullptr },
        { "rgb24", reinterpret_cast<getter>(MediaEncodingSubtypes_get_Rgb24), nullptr, nullptr, nullptr },
        { "rgb32", reinterpret_cast<getter>(MediaEncodingSubtypes_get_Rgb32), nullptr, nullptr, nullptr },
        { "tiff", reinterpret_cast<getter>(MediaEncodingSubtypes_get_Tiff), nullptr, nullptr, nullptr },
        { "wave", reinterpret_cast<getter>(MediaEncodingSubtypes_get_Wave), nullptr, nullptr, nullptr },
        { "wma8", reinterpret_cast<getter>(MediaEncodingSubtypes_get_Wma8), nullptr, nullptr, nullptr },
        { "wma9", reinterpret_cast<getter>(MediaEncodingSubtypes_get_Wma9), nullptr, nullptr, nullptr },
        { "wmv3", reinterpret_cast<getter>(MediaEncodingSubtypes_get_Wmv3), nullptr, nullptr, nullptr },
        { "wvc1", reinterpret_cast<getter>(MediaEncodingSubtypes_get_Wvc1), nullptr, nullptr, nullptr },
        { "yuy2", reinterpret_cast<getter>(MediaEncodingSubtypes_get_Yuy2), nullptr, nullptr, nullptr },
        { "yv12", reinterpret_cast<getter>(MediaEncodingSubtypes_get_Yv12), nullptr, nullptr, nullptr },
        { "d16", reinterpret_cast<getter>(MediaEncodingSubtypes_get_D16), nullptr, nullptr, nullptr },
        { "l16", reinterpret_cast<getter>(MediaEncodingSubtypes_get_L16), nullptr, nullptr, nullptr },
        { "l8", reinterpret_cast<getter>(MediaEncodingSubtypes_get_L8), nullptr, nullptr, nullptr },
        { "vp9", reinterpret_cast<getter>(MediaEncodingSubtypes_get_Vp9), nullptr, nullptr, nullptr },
        { "alac", reinterpret_cast<getter>(MediaEncodingSubtypes_get_Alac), nullptr, nullptr, nullptr },
        { "flac", reinterpret_cast<getter>(MediaEncodingSubtypes_get_Flac), nullptr, nullptr, nullptr },
        { "p010", reinterpret_cast<getter>(MediaEncodingSubtypes_get_P010), nullptr, nullptr, nullptr },
        { "heif", reinterpret_cast<getter>(MediaEncodingSubtypes_get_Heif), nullptr, nullptr, nullptr },
        { "srt", reinterpret_cast<getter>(MediaEncodingSubtypes_get_Srt), nullptr, nullptr, nullptr },
        { "ssa", reinterpret_cast<getter>(MediaEncodingSubtypes_get_Ssa), nullptr, nullptr, nullptr },
        { "vob_sub", reinterpret_cast<getter>(MediaEncodingSubtypes_get_VobSub), nullptr, nullptr, nullptr },
        { "pgs", reinterpret_cast<getter>(MediaEncodingSubtypes_get_Pgs), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot type_slots_MediaEncodingSubtypes_Meta[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_MediaEncodingSubtypes_Meta) },
        { }
    };

    static PyType_Spec type_spec_MediaEncodingSubtypes_Meta =
    {
        "_winrt_windows_media_mediaproperties.MediaEncodingSubtypes_Meta",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_MediaEncodingSubtypes_Meta
    };

    // ----- MediaPropertySet class --------------------
    static constexpr const char* const type_name_MediaPropertySet = "MediaPropertySet";

    static PyObject* _new_MediaPropertySet(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Media::MediaProperties::MediaPropertySet instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MediaPropertySet(py::wrapper::Windows::Media::MediaProperties::MediaPropertySet* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MediaPropertySet_Clear(py::wrapper::Windows::Media::MediaProperties::MediaPropertySet* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.MediaProperties.MediaPropertySet", L"Clear", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Clear();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaPropertySet_First(py::wrapper::Windows::Media::MediaProperties::MediaPropertySet* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.MediaProperties.MediaPropertySet", L"First", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.First());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaPropertySet_GetView(py::wrapper::Windows::Media::MediaProperties::MediaPropertySet* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.MediaProperties.MediaPropertySet", L"GetView", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetView());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaPropertySet_HasKey(py::wrapper::Windows::Media::MediaProperties::MediaPropertySet* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.MediaProperties.MediaPropertySet", L"HasKey", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::guid>(args, 0);

                return py::convert(self->obj.HasKey(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaPropertySet_Insert(py::wrapper::Windows::Media::MediaProperties::MediaPropertySet* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.MediaProperties.MediaPropertySet", L"Insert", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::guid>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 1);

                return py::convert(self->obj.Insert(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaPropertySet_Lookup(py::wrapper::Windows::Media::MediaProperties::MediaPropertySet* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.MediaProperties.MediaPropertySet", L"Lookup", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::guid>(args, 0);

                return py::convert(self->obj.Lookup(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaPropertySet_Remove(py::wrapper::Windows::Media::MediaProperties::MediaPropertySet* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.MediaProperties.MediaPropertySet", L"Remove", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::guid>(args, 0);

                self->obj.Remove(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaPropertySet_get_Size(py::wrapper::Windows::Media::MediaProperties::MediaPropertySet* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.MediaPropertySet", L"Size"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MediaPropertySet(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::MediaProperties::MediaPropertySet>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MediaPropertySet(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::MediaProperties::MediaPropertySet>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _iterator_MediaPropertySet(py::wrapper::Windows::Media::MediaProperties::MediaPropertySet* self) noexcept
    {
        try
        {
            py::pyobj_handle iter{py::convert(self->obj.First())};
            return py::wrap_mapping_iter(iter.get());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int _map_contains_MediaPropertySet(py::wrapper::Windows::Media::MediaProperties::MediaPropertySet* self, PyObject* key) noexcept
    {
        try
        {
            return static_cast<int>(self->obj.HasKey(py::convert_to<winrt::guid>(key)));
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static Py_ssize_t _map_length_MediaPropertySet(py::wrapper::Windows::Media::MediaProperties::MediaPropertySet* self) noexcept
    {
        try
        {
            return static_cast<Py_ssize_t>(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _map_subscript_MediaPropertySet(py::wrapper::Windows::Media::MediaProperties::MediaPropertySet* self, PyObject* key) noexcept
    {
        try
        {
            auto value = self->obj.TryLookup(py::convert_to<winrt::guid>(key));

            if (!value) {
                PyErr_SetObject(PyExc_KeyError, key);
                return nullptr;
            }

            return py::convert(value);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int _map_assign_MediaPropertySet(py::wrapper::Windows::Media::MediaProperties::MediaPropertySet* self, PyObject* key, PyObject* value) noexcept
    {
        try
        {
            auto _key = py::convert_to<winrt::guid>(key);

            if (value == nullptr) {
                if (!self->obj.TryRemove(_key)) {
                    PyErr_SetObject(PyExc_KeyError, key);
                    return -1;
                }

                return 0;
            }

            self->obj.Insert(_key, py::convert_to<winrt::Windows::Foundation::IInspectable>(value));

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyMethodDef _methods_MediaPropertySet[] = {
        { "clear", reinterpret_cast<PyCFunction>(MediaPropertySet_Clear), METH_VARARGS, nullptr },
        { "first", reinterpret_cast<PyCFunction>(MediaPropertySet_First), METH_VARARGS, nullptr },
        { "get_view", reinterpret_cast<PyCFunction>(MediaPropertySet_GetView), METH_VARARGS, nullptr },
        { "has_key", reinterpret_cast<PyCFunction>(MediaPropertySet_HasKey), METH_VARARGS, nullptr },
        { "insert", reinterpret_cast<PyCFunction>(MediaPropertySet_Insert), METH_VARARGS, nullptr },
        { "lookup", reinterpret_cast<PyCFunction>(MediaPropertySet_Lookup), METH_VARARGS, nullptr },
        { "remove", reinterpret_cast<PyCFunction>(MediaPropertySet_Remove), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_MediaPropertySet, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MediaPropertySet), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MediaPropertySet[] = {
        { "size", reinterpret_cast<getter>(MediaPropertySet_get_Size), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MediaPropertySet[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MediaPropertySet) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MediaPropertySet) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MediaPropertySet) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MediaPropertySet) },
        { Py_tp_iter, reinterpret_cast<void*>(_iterator_MediaPropertySet) },
        { Py_sq_contains, reinterpret_cast<void*>(_map_contains_MediaPropertySet) },
        { Py_mp_length, reinterpret_cast<void*>(_map_length_MediaPropertySet) },
        { Py_mp_subscript, reinterpret_cast<void*>(_map_subscript_MediaPropertySet) },
        { Py_mp_ass_subscript, reinterpret_cast<void*>(_map_assign_MediaPropertySet) },
        { },
    };

    static PyType_Spec type_spec_MediaPropertySet =
    {
        "_winrt_windows_media_mediaproperties.MediaPropertySet",
        sizeof(py::wrapper::Windows::Media::MediaProperties::MediaPropertySet),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaPropertySet
    };

    // ----- MediaRatio class --------------------
    static constexpr const char* const type_name_MediaRatio = "MediaRatio";

    static PyObject* _new_MediaRatio(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_MediaRatio);
        return nullptr;
    }

    static void _dealloc_MediaRatio(py::wrapper::Windows::Media::MediaProperties::MediaRatio* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MediaRatio_get_Numerator(py::wrapper::Windows::Media::MediaProperties::MediaRatio* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.MediaRatio", L"Numerator"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Numerator());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaRatio_put_Numerator(py::wrapper::Windows::Media::MediaProperties::MediaRatio* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.MediaRatio", L"Numerator"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.Numerator(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaRatio_get_Denominator(py::wrapper::Windows::Media::MediaProperties::MediaRatio* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.MediaRatio", L"Denominator"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Denominator());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaRatio_put_Denominator(py::wrapper::Windows::Media::MediaProperties::MediaRatio* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.MediaRatio", L"Denominator"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.Denominator(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_MediaRatio(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::MediaProperties::MediaRatio>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MediaRatio(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::MediaProperties::MediaRatio>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaRatio[] = {
        { "_assign_array_", _assign_array_MediaRatio, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MediaRatio), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MediaRatio[] = {
        { "numerator", reinterpret_cast<getter>(MediaRatio_get_Numerator), reinterpret_cast<setter>(MediaRatio_put_Numerator), nullptr, nullptr },
        { "denominator", reinterpret_cast<getter>(MediaRatio_get_Denominator), reinterpret_cast<setter>(MediaRatio_put_Denominator), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MediaRatio[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MediaRatio) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MediaRatio) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MediaRatio) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MediaRatio) },
        { },
    };

    static PyType_Spec type_spec_MediaRatio =
    {
        "_winrt_windows_media_mediaproperties.MediaRatio",
        sizeof(py::wrapper::Windows::Media::MediaProperties::MediaRatio),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaRatio
    };

    // ----- Mpeg2ProfileIds class --------------------
    static constexpr const char* const type_name_Mpeg2ProfileIds = "Mpeg2ProfileIds";

    static PyObject* _new_Mpeg2ProfileIds(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_Mpeg2ProfileIds);
        return nullptr;
    }

    static PyObject* Mpeg2ProfileIds_get_High(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.Mpeg2ProfileIds", L"High"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Media::MediaProperties::Mpeg2ProfileIds::High());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Mpeg2ProfileIds_get_Main(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.Mpeg2ProfileIds", L"Main"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Media::MediaProperties::Mpeg2ProfileIds::Main());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Mpeg2ProfileIds_get_SignalNoiseRatioScalable(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.Mpeg2ProfileIds", L"SignalNoiseRatioScalable"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Media::MediaProperties::Mpeg2ProfileIds::SignalNoiseRatioScalable());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Mpeg2ProfileIds_get_Simple(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.Mpeg2ProfileIds", L"Simple"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Media::MediaProperties::Mpeg2ProfileIds::Simple());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Mpeg2ProfileIds_get_SpatiallyScalable(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.Mpeg2ProfileIds", L"SpatiallyScalable"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Media::MediaProperties::Mpeg2ProfileIds::SpatiallyScalable());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_Mpeg2ProfileIds[] = {
        { }
    };

    static PyGetSetDef _getset_Mpeg2ProfileIds[] = {
        { }
    };

    static PyType_Slot _type_slots_Mpeg2ProfileIds[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_Mpeg2ProfileIds) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_Mpeg2ProfileIds) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_Mpeg2ProfileIds) },
        { },
    };

    static PyType_Spec type_spec_Mpeg2ProfileIds =
    {
        "_winrt_windows_media_mediaproperties.Mpeg2ProfileIds",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_Mpeg2ProfileIds
    };

    static PyGetSetDef getset_Mpeg2ProfileIds_Meta[] = {
        { "high", reinterpret_cast<getter>(Mpeg2ProfileIds_get_High), nullptr, nullptr, nullptr },
        { "main", reinterpret_cast<getter>(Mpeg2ProfileIds_get_Main), nullptr, nullptr, nullptr },
        { "signal_noise_ratio_scalable", reinterpret_cast<getter>(Mpeg2ProfileIds_get_SignalNoiseRatioScalable), nullptr, nullptr, nullptr },
        { "simple", reinterpret_cast<getter>(Mpeg2ProfileIds_get_Simple), nullptr, nullptr, nullptr },
        { "spatially_scalable", reinterpret_cast<getter>(Mpeg2ProfileIds_get_SpatiallyScalable), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot type_slots_Mpeg2ProfileIds_Meta[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_Mpeg2ProfileIds_Meta) },
        { }
    };

    static PyType_Spec type_spec_Mpeg2ProfileIds_Meta =
    {
        "_winrt_windows_media_mediaproperties.Mpeg2ProfileIds_Meta",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_Mpeg2ProfileIds_Meta
    };

    // ----- TimedMetadataEncodingProperties class --------------------
    static constexpr const char* const type_name_TimedMetadataEncodingProperties = "TimedMetadataEncodingProperties";

    static PyObject* _new_TimedMetadataEncodingProperties(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Media::MediaProperties::TimedMetadataEncodingProperties instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_TimedMetadataEncodingProperties(py::wrapper::Windows::Media::MediaProperties::TimedMetadataEncodingProperties* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* TimedMetadataEncodingProperties_Copy(py::wrapper::Windows::Media::MediaProperties::TimedMetadataEncodingProperties* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.MediaProperties.TimedMetadataEncodingProperties", L"Copy", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.Copy());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TimedMetadataEncodingProperties_CreatePgs(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.MediaProperties.TimedMetadataEncodingProperties", L"CreatePgs", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::Media::MediaProperties::TimedMetadataEncodingProperties::CreatePgs());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TimedMetadataEncodingProperties_CreateSrt(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.MediaProperties.TimedMetadataEncodingProperties", L"CreateSrt", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::Media::MediaProperties::TimedMetadataEncodingProperties::CreateSrt());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TimedMetadataEncodingProperties_CreateSsa(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.MediaProperties.TimedMetadataEncodingProperties", L"CreateSsa", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<py::pybuf_view<uint8_t, false>>(args, 0);

                return py::convert(winrt::Windows::Media::MediaProperties::TimedMetadataEncodingProperties::CreateSsa(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TimedMetadataEncodingProperties_CreateVobSub(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.MediaProperties.TimedMetadataEncodingProperties", L"CreateVobSub", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<py::pybuf_view<uint8_t, false>>(args, 0);

                return py::convert(winrt::Windows::Media::MediaProperties::TimedMetadataEncodingProperties::CreateVobSub(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TimedMetadataEncodingProperties_GetFormatUserData(py::wrapper::Windows::Media::MediaProperties::TimedMetadataEncodingProperties* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.MediaProperties.TimedMetadataEncodingProperties", L"GetFormatUserData", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                winrt::com_array<uint8_t> param0 { };

                self->obj.GetFormatUserData(param0);

                py::pyobj_handle out0{ py::convert(param0) };
                if (!out0)
                {
                    return nullptr;
                }
                return out0.detach();
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TimedMetadataEncodingProperties_SetFormatUserData(py::wrapper::Windows::Media::MediaProperties::TimedMetadataEncodingProperties* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.MediaProperties.TimedMetadataEncodingProperties", L"SetFormatUserData", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<py::pybuf_view<uint8_t, false>>(args, 0);

                self->obj.SetFormatUserData(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TimedMetadataEncodingProperties_get_Subtype(py::wrapper::Windows::Media::MediaProperties::TimedMetadataEncodingProperties* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.TimedMetadataEncodingProperties", L"Subtype"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Subtype());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedMetadataEncodingProperties_put_Subtype(py::wrapper::Windows::Media::MediaProperties::TimedMetadataEncodingProperties* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.TimedMetadataEncodingProperties", L"Subtype"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Subtype(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedMetadataEncodingProperties_get_Properties(py::wrapper::Windows::Media::MediaProperties::TimedMetadataEncodingProperties* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.TimedMetadataEncodingProperties", L"Properties"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Properties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TimedMetadataEncodingProperties_get_Type(py::wrapper::Windows::Media::MediaProperties::TimedMetadataEncodingProperties* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.TimedMetadataEncodingProperties", L"Type"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Type());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_TimedMetadataEncodingProperties(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::MediaProperties::TimedMetadataEncodingProperties>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_TimedMetadataEncodingProperties(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::MediaProperties::TimedMetadataEncodingProperties>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TimedMetadataEncodingProperties[] = {
        { "copy", reinterpret_cast<PyCFunction>(TimedMetadataEncodingProperties_Copy), METH_VARARGS, nullptr },
        { "create_pgs", reinterpret_cast<PyCFunction>(TimedMetadataEncodingProperties_CreatePgs), METH_VARARGS | METH_STATIC, nullptr },
        { "create_srt", reinterpret_cast<PyCFunction>(TimedMetadataEncodingProperties_CreateSrt), METH_VARARGS | METH_STATIC, nullptr },
        { "create_ssa", reinterpret_cast<PyCFunction>(TimedMetadataEncodingProperties_CreateSsa), METH_VARARGS | METH_STATIC, nullptr },
        { "create_vob_sub", reinterpret_cast<PyCFunction>(TimedMetadataEncodingProperties_CreateVobSub), METH_VARARGS | METH_STATIC, nullptr },
        { "get_format_user_data", reinterpret_cast<PyCFunction>(TimedMetadataEncodingProperties_GetFormatUserData), METH_VARARGS, nullptr },
        { "set_format_user_data", reinterpret_cast<PyCFunction>(TimedMetadataEncodingProperties_SetFormatUserData), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_TimedMetadataEncodingProperties, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_TimedMetadataEncodingProperties), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_TimedMetadataEncodingProperties[] = {
        { "subtype", reinterpret_cast<getter>(TimedMetadataEncodingProperties_get_Subtype), reinterpret_cast<setter>(TimedMetadataEncodingProperties_put_Subtype), nullptr, nullptr },
        { "properties", reinterpret_cast<getter>(TimedMetadataEncodingProperties_get_Properties), nullptr, nullptr, nullptr },
        { "type", reinterpret_cast<getter>(TimedMetadataEncodingProperties_get_Type), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_TimedMetadataEncodingProperties[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_TimedMetadataEncodingProperties) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_TimedMetadataEncodingProperties) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_TimedMetadataEncodingProperties) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_TimedMetadataEncodingProperties) },
        { },
    };

    static PyType_Spec type_spec_TimedMetadataEncodingProperties =
    {
        "_winrt_windows_media_mediaproperties.TimedMetadataEncodingProperties",
        sizeof(py::wrapper::Windows::Media::MediaProperties::TimedMetadataEncodingProperties),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TimedMetadataEncodingProperties
    };

    // ----- VideoEncodingProperties class --------------------
    static constexpr const char* const type_name_VideoEncodingProperties = "VideoEncodingProperties";

    static PyObject* _new_VideoEncodingProperties(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Media::MediaProperties::VideoEncodingProperties instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_VideoEncodingProperties(py::wrapper::Windows::Media::MediaProperties::VideoEncodingProperties* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* VideoEncodingProperties_Copy(py::wrapper::Windows::Media::MediaProperties::VideoEncodingProperties* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.MediaProperties.VideoEncodingProperties", L"Copy", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.Copy());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VideoEncodingProperties_CreateH264(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.MediaProperties.VideoEncodingProperties", L"CreateH264", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::Media::MediaProperties::VideoEncodingProperties::CreateH264());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VideoEncodingProperties_CreateHevc(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.MediaProperties.VideoEncodingProperties", L"CreateHevc", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::Media::MediaProperties::VideoEncodingProperties::CreateHevc());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VideoEncodingProperties_CreateMpeg2(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.MediaProperties.VideoEncodingProperties", L"CreateMpeg2", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::Media::MediaProperties::VideoEncodingProperties::CreateMpeg2());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VideoEncodingProperties_CreateUncompressed(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.MediaProperties.VideoEncodingProperties", L"CreateUncompressed", 3))
            {
                py::set_arg_count_version_error(3);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);
                auto param2 = py::convert_to<uint32_t>(args, 2);

                return py::convert(winrt::Windows::Media::MediaProperties::VideoEncodingProperties::CreateUncompressed(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VideoEncodingProperties_GetFormatUserData(py::wrapper::Windows::Media::MediaProperties::VideoEncodingProperties* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.MediaProperties.VideoEncodingProperties", L"GetFormatUserData", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                winrt::com_array<uint8_t> param0 { };

                self->obj.GetFormatUserData(param0);

                py::pyobj_handle out0{ py::convert(param0) };
                if (!out0)
                {
                    return nullptr;
                }
                return out0.detach();
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VideoEncodingProperties_SetFormatUserData(py::wrapper::Windows::Media::MediaProperties::VideoEncodingProperties* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.MediaProperties.VideoEncodingProperties", L"SetFormatUserData", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<py::pybuf_view<uint8_t, false>>(args, 0);

                self->obj.SetFormatUserData(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VideoEncodingProperties_get_Subtype(py::wrapper::Windows::Media::MediaProperties::VideoEncodingProperties* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.VideoEncodingProperties", L"Subtype"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Subtype());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VideoEncodingProperties_put_Subtype(py::wrapper::Windows::Media::MediaProperties::VideoEncodingProperties* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.VideoEncodingProperties", L"Subtype"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Subtype(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VideoEncodingProperties_get_Type(py::wrapper::Windows::Media::MediaProperties::VideoEncodingProperties* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.VideoEncodingProperties", L"Type"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Type());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VideoEncodingProperties_get_Properties(py::wrapper::Windows::Media::MediaProperties::VideoEncodingProperties* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.VideoEncodingProperties", L"Properties"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Properties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VideoEncodingProperties_get_Width(py::wrapper::Windows::Media::MediaProperties::VideoEncodingProperties* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.VideoEncodingProperties", L"Width"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Width());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VideoEncodingProperties_put_Width(py::wrapper::Windows::Media::MediaProperties::VideoEncodingProperties* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.VideoEncodingProperties", L"Width"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.Width(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VideoEncodingProperties_get_Height(py::wrapper::Windows::Media::MediaProperties::VideoEncodingProperties* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.VideoEncodingProperties", L"Height"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Height());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VideoEncodingProperties_put_Height(py::wrapper::Windows::Media::MediaProperties::VideoEncodingProperties* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.VideoEncodingProperties", L"Height"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.Height(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VideoEncodingProperties_get_Bitrate(py::wrapper::Windows::Media::MediaProperties::VideoEncodingProperties* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.VideoEncodingProperties", L"Bitrate"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Bitrate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VideoEncodingProperties_put_Bitrate(py::wrapper::Windows::Media::MediaProperties::VideoEncodingProperties* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.VideoEncodingProperties", L"Bitrate"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.Bitrate(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VideoEncodingProperties_get_PixelAspectRatio(py::wrapper::Windows::Media::MediaProperties::VideoEncodingProperties* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.VideoEncodingProperties", L"PixelAspectRatio"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PixelAspectRatio());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VideoEncodingProperties_get_FrameRate(py::wrapper::Windows::Media::MediaProperties::VideoEncodingProperties* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.VideoEncodingProperties", L"FrameRate"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.FrameRate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VideoEncodingProperties_get_ProfileId(py::wrapper::Windows::Media::MediaProperties::VideoEncodingProperties* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.VideoEncodingProperties", L"ProfileId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ProfileId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VideoEncodingProperties_put_ProfileId(py::wrapper::Windows::Media::MediaProperties::VideoEncodingProperties* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.VideoEncodingProperties", L"ProfileId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.ProfileId(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VideoEncodingProperties_get_StereoscopicVideoPackingMode(py::wrapper::Windows::Media::MediaProperties::VideoEncodingProperties* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.VideoEncodingProperties", L"StereoscopicVideoPackingMode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.StereoscopicVideoPackingMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VideoEncodingProperties_get_SphericalVideoFrameFormat(py::wrapper::Windows::Media::MediaProperties::VideoEncodingProperties* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.VideoEncodingProperties", L"SphericalVideoFrameFormat"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SphericalVideoFrameFormat());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_VideoEncodingProperties(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::MediaProperties::VideoEncodingProperties>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_VideoEncodingProperties(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::MediaProperties::VideoEncodingProperties>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_VideoEncodingProperties[] = {
        { "copy", reinterpret_cast<PyCFunction>(VideoEncodingProperties_Copy), METH_VARARGS, nullptr },
        { "create_h264", reinterpret_cast<PyCFunction>(VideoEncodingProperties_CreateH264), METH_VARARGS | METH_STATIC, nullptr },
        { "create_hevc", reinterpret_cast<PyCFunction>(VideoEncodingProperties_CreateHevc), METH_VARARGS | METH_STATIC, nullptr },
        { "create_mpeg2", reinterpret_cast<PyCFunction>(VideoEncodingProperties_CreateMpeg2), METH_VARARGS | METH_STATIC, nullptr },
        { "create_uncompressed", reinterpret_cast<PyCFunction>(VideoEncodingProperties_CreateUncompressed), METH_VARARGS | METH_STATIC, nullptr },
        { "get_format_user_data", reinterpret_cast<PyCFunction>(VideoEncodingProperties_GetFormatUserData), METH_VARARGS, nullptr },
        { "set_format_user_data", reinterpret_cast<PyCFunction>(VideoEncodingProperties_SetFormatUserData), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_VideoEncodingProperties, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_VideoEncodingProperties), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_VideoEncodingProperties[] = {
        { "subtype", reinterpret_cast<getter>(VideoEncodingProperties_get_Subtype), reinterpret_cast<setter>(VideoEncodingProperties_put_Subtype), nullptr, nullptr },
        { "type", reinterpret_cast<getter>(VideoEncodingProperties_get_Type), nullptr, nullptr, nullptr },
        { "properties", reinterpret_cast<getter>(VideoEncodingProperties_get_Properties), nullptr, nullptr, nullptr },
        { "width", reinterpret_cast<getter>(VideoEncodingProperties_get_Width), reinterpret_cast<setter>(VideoEncodingProperties_put_Width), nullptr, nullptr },
        { "height", reinterpret_cast<getter>(VideoEncodingProperties_get_Height), reinterpret_cast<setter>(VideoEncodingProperties_put_Height), nullptr, nullptr },
        { "bitrate", reinterpret_cast<getter>(VideoEncodingProperties_get_Bitrate), reinterpret_cast<setter>(VideoEncodingProperties_put_Bitrate), nullptr, nullptr },
        { "pixel_aspect_ratio", reinterpret_cast<getter>(VideoEncodingProperties_get_PixelAspectRatio), nullptr, nullptr, nullptr },
        { "frame_rate", reinterpret_cast<getter>(VideoEncodingProperties_get_FrameRate), nullptr, nullptr, nullptr },
        { "profile_id", reinterpret_cast<getter>(VideoEncodingProperties_get_ProfileId), reinterpret_cast<setter>(VideoEncodingProperties_put_ProfileId), nullptr, nullptr },
        { "stereoscopic_video_packing_mode", reinterpret_cast<getter>(VideoEncodingProperties_get_StereoscopicVideoPackingMode), nullptr, nullptr, nullptr },
        { "spherical_video_frame_format", reinterpret_cast<getter>(VideoEncodingProperties_get_SphericalVideoFrameFormat), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_VideoEncodingProperties[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_VideoEncodingProperties) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_VideoEncodingProperties) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_VideoEncodingProperties) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_VideoEncodingProperties) },
        { },
    };

    static PyType_Spec type_spec_VideoEncodingProperties =
    {
        "_winrt_windows_media_mediaproperties.VideoEncodingProperties",
        sizeof(py::wrapper::Windows::Media::MediaProperties::VideoEncodingProperties),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_VideoEncodingProperties
    };

    // ----- IMediaEncodingProperties interface --------------------
    static constexpr const char* const type_name_IMediaEncodingProperties = "IMediaEncodingProperties";

    static PyObject* _new_IMediaEncodingProperties(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */) noexcept
    {
        py::set_invalid_activation_error(type_name_IMediaEncodingProperties);
        return nullptr;
    }

    static void _dealloc_IMediaEncodingProperties(py::wrapper::Windows::Media::MediaProperties::IMediaEncodingProperties* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IMediaEncodingProperties_get_Properties(py::wrapper::Windows::Media::MediaProperties::IMediaEncodingProperties* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.IMediaEncodingProperties", L"Properties"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Properties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IMediaEncodingProperties_get_Subtype(py::wrapper::Windows::Media::MediaProperties::IMediaEncodingProperties* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.IMediaEncodingProperties", L"Subtype"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Subtype());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IMediaEncodingProperties_put_Subtype(py::wrapper::Windows::Media::MediaProperties::IMediaEncodingProperties* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.IMediaEncodingProperties", L"Subtype"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Subtype(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IMediaEncodingProperties_get_Type(py::wrapper::Windows::Media::MediaProperties::IMediaEncodingProperties* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.MediaProperties.IMediaEncodingProperties", L"Type"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Type());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_IMediaEncodingProperties(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::MediaProperties::IMediaEncodingProperties>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IMediaEncodingProperties(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::MediaProperties::IMediaEncodingProperties>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IMediaEncodingProperties[] = {
        { "_assign_array_", _assign_array_IMediaEncodingProperties, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IMediaEncodingProperties), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IMediaEncodingProperties[] = {
        { "properties", reinterpret_cast<getter>(IMediaEncodingProperties_get_Properties), nullptr, nullptr, nullptr },
        { "subtype", reinterpret_cast<getter>(IMediaEncodingProperties_get_Subtype), reinterpret_cast<setter>(IMediaEncodingProperties_put_Subtype), nullptr, nullptr },
        { "type", reinterpret_cast<getter>(IMediaEncodingProperties_get_Type), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IMediaEncodingProperties[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_IMediaEncodingProperties) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IMediaEncodingProperties) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IMediaEncodingProperties) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IMediaEncodingProperties) },
        { },
    };

    static PyType_Spec type_spec_IMediaEncodingProperties =
    {
        "_winrt_windows_media_mediaproperties.IMediaEncodingProperties",
        sizeof(py::wrapper::Windows::Media::MediaProperties::IMediaEncodingProperties),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IMediaEncodingProperties
    };

    // ----- Windows.Media.MediaProperties Initialization --------------------
    PyDoc_STRVAR(module_doc, "Windows::Media::MediaProperties");


    static PyModuleDef module_def
        = {PyModuleDef_HEAD_INIT,
           "_winrt_windows_media_mediaproperties",
           module_doc,
           0,
           nullptr,
           nullptr,
           nullptr,
           nullptr,
           nullptr};

} // py::cpp::Windows::Media::MediaProperties

PyMODINIT_FUNC PyInit__winrt_windows_media_mediaproperties(void) noexcept
{
    using namespace py::cpp::Windows::Media::MediaProperties;

    if (py::import_winrt_runtime() == -1)
    {
        return nullptr;
    }

    py::pyobj_handle module{PyModule_Create(&module_def)};

    if (!module)
    {
        return nullptr;
    }

    auto object_type = py::get_object_type();
    if (!object_type)
    {
        return nullptr;
    }

    py::pyobj_handle object_bases{PyTuple_Pack(1, object_type)};

    if (!object_bases)
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_AudioEncodingProperties, &type_spec_AudioEncodingProperties, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_AudioEncodingProperties, &type_spec_AudioEncodingProperties, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_ContainerEncodingProperties, &type_spec_ContainerEncodingProperties, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_ContainerEncodingProperties, &type_spec_ContainerEncodingProperties, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    py::pyobj_handle type_H264ProfileIds_Meta{PyType_FromSpec(&type_spec_H264ProfileIds_Meta)};
    if (!type_H264ProfileIds_Meta)
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_H264ProfileIds, &type_spec_H264ProfileIds, nullptr, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_H264ProfileIds_Meta.get())) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_H264ProfileIds, &type_spec_H264ProfileIds, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_H264ProfileIds_Meta.get())) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_ImageEncodingProperties, &type_spec_ImageEncodingProperties, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_ImageEncodingProperties, &type_spec_ImageEncodingProperties, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_MediaEncodingProfile, &type_spec_MediaEncodingProfile, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_MediaEncodingProfile, &type_spec_MediaEncodingProfile, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    py::pyobj_handle type_MediaEncodingSubtypes_Meta{PyType_FromSpec(&type_spec_MediaEncodingSubtypes_Meta)};
    if (!type_MediaEncodingSubtypes_Meta)
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_MediaEncodingSubtypes, &type_spec_MediaEncodingSubtypes, nullptr, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_MediaEncodingSubtypes_Meta.get())) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_MediaEncodingSubtypes, &type_spec_MediaEncodingSubtypes, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_MediaEncodingSubtypes_Meta.get())) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_MediaPropertySet, &type_spec_MediaPropertySet, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_MediaPropertySet, &type_spec_MediaPropertySet, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_MediaRatio, &type_spec_MediaRatio, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_MediaRatio, &type_spec_MediaRatio, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    py::pyobj_handle type_Mpeg2ProfileIds_Meta{PyType_FromSpec(&type_spec_Mpeg2ProfileIds_Meta)};
    if (!type_Mpeg2ProfileIds_Meta)
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_Mpeg2ProfileIds, &type_spec_Mpeg2ProfileIds, nullptr, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_Mpeg2ProfileIds_Meta.get())) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_Mpeg2ProfileIds, &type_spec_Mpeg2ProfileIds, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_Mpeg2ProfileIds_Meta.get())) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_TimedMetadataEncodingProperties, &type_spec_TimedMetadataEncodingProperties, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_TimedMetadataEncodingProperties, &type_spec_TimedMetadataEncodingProperties, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_VideoEncodingProperties, &type_spec_VideoEncodingProperties, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_VideoEncodingProperties, &type_spec_VideoEncodingProperties, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_IMediaEncodingProperties, &type_spec_IMediaEncodingProperties, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_IMediaEncodingProperties, &type_spec_IMediaEncodingProperties, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }


    return module.detach();
}
