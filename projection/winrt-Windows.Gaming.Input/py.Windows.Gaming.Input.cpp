// WARNING: Please don't edit this file. It was generated by Python/WinRT v0.0.0

#include "py.Windows.Gaming.Input.h"

namespace py::cpp::Windows::Gaming::Input
{
    // ----- ArcadeStick class --------------------

    static PyObject* _new_ArcadeStick(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Gaming::Input::ArcadeStick>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Gaming::Input::ArcadeStick>::type_name);
        return nullptr;
    }

    static void _dealloc_ArcadeStick(py::wrapper::Windows::Gaming::Input::ArcadeStick* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ArcadeStick_FromGameController(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Gaming.Input.ArcadeStick", L"FromGameController", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Gaming::Input::IGameController>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::Gaming::Input::ArcadeStick::FromGameController(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ArcadeStick_GetButtonLabel(py::wrapper::Windows::Gaming::Input::ArcadeStick* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Gaming.Input.ArcadeStick", L"GetButtonLabel", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Gaming::Input::ArcadeStickButtons>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetButtonLabel(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ArcadeStick_GetCurrentReading(py::wrapper::Windows::Gaming::Input::ArcadeStick* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Gaming.Input.ArcadeStick", L"GetCurrentReading", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetCurrentReading();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ArcadeStick_TryGetBatteryReport(py::wrapper::Windows::Gaming::Input::ArcadeStick* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Gaming.Input.ArcadeStick", L"TryGetBatteryReport", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.TryGetBatteryReport();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ArcadeStick_get_Headset(py::wrapper::Windows::Gaming::Input::ArcadeStick* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Gaming.Input.ArcadeStick", L"Headset");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Headset();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ArcadeStick_get_IsWireless(py::wrapper::Windows::Gaming::Input::ArcadeStick* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Gaming.Input.ArcadeStick", L"IsWireless");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsWireless();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ArcadeStick_get_User(py::wrapper::Windows::Gaming::Input::ArcadeStick* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Gaming.Input.ArcadeStick", L"User");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.User();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ArcadeStick_get_ArcadeSticks(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Gaming.Input.ArcadeStick", L"ArcadeSticks");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::Gaming::Input::ArcadeStick::ArcadeSticks();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ArcadeStick_add_HeadsetConnected(py::wrapper::Windows::Gaming::Input::ArcadeStick* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Gaming.Input.ArcadeStick", L"HeadsetConnected");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Gaming::Input::IGameController, winrt::Windows::Gaming::Input::Headset>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.HeadsetConnected(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ArcadeStick_remove_HeadsetConnected(py::wrapper::Windows::Gaming::Input::ArcadeStick* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Gaming.Input.ArcadeStick", L"HeadsetConnected");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.HeadsetConnected(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ArcadeStick_add_HeadsetDisconnected(py::wrapper::Windows::Gaming::Input::ArcadeStick* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Gaming.Input.ArcadeStick", L"HeadsetDisconnected");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Gaming::Input::IGameController, winrt::Windows::Gaming::Input::Headset>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.HeadsetDisconnected(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ArcadeStick_remove_HeadsetDisconnected(py::wrapper::Windows::Gaming::Input::ArcadeStick* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Gaming.Input.ArcadeStick", L"HeadsetDisconnected");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.HeadsetDisconnected(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ArcadeStick_add_UserChanged(py::wrapper::Windows::Gaming::Input::ArcadeStick* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Gaming.Input.ArcadeStick", L"UserChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Gaming::Input::IGameController, winrt::Windows::System::UserChangedEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.UserChanged(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ArcadeStick_remove_UserChanged(py::wrapper::Windows::Gaming::Input::ArcadeStick* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Gaming.Input.ArcadeStick", L"UserChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.UserChanged(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ArcadeStick_add_ArcadeStickAdded(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Gaming.Input.ArcadeStick", L"ArcadeStickAdded");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::EventHandler<winrt::Windows::Gaming::Input::ArcadeStick>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::Gaming::Input::ArcadeStick::ArcadeStickAdded(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ArcadeStick_remove_ArcadeStickAdded(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Gaming.Input.ArcadeStick", L"ArcadeStickAdded");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                winrt::Windows::Gaming::Input::ArcadeStick::ArcadeStickAdded(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ArcadeStick_add_ArcadeStickRemoved(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Gaming.Input.ArcadeStick", L"ArcadeStickRemoved");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::EventHandler<winrt::Windows::Gaming::Input::ArcadeStick>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::Gaming::Input::ArcadeStick::ArcadeStickRemoved(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ArcadeStick_remove_ArcadeStickRemoved(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Gaming.Input.ArcadeStick", L"ArcadeStickRemoved");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                winrt::Windows::Gaming::Input::ArcadeStick::ArcadeStickRemoved(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ArcadeStick(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Gaming::Input::ArcadeStick>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ArcadeStick(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Gaming::Input::ArcadeStick>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ArcadeStick[] = {
        { "get_button_label", reinterpret_cast<PyCFunction>(ArcadeStick_GetButtonLabel), METH_VARARGS, nullptr },
        { "get_current_reading", reinterpret_cast<PyCFunction>(ArcadeStick_GetCurrentReading), METH_VARARGS, nullptr },
        { "try_get_battery_report", reinterpret_cast<PyCFunction>(ArcadeStick_TryGetBatteryReport), METH_VARARGS, nullptr },
        { "add_headset_connected", reinterpret_cast<PyCFunction>(ArcadeStick_add_HeadsetConnected), METH_O, nullptr },
        { "remove_headset_connected", reinterpret_cast<PyCFunction>(ArcadeStick_remove_HeadsetConnected), METH_O, nullptr },
        { "add_headset_disconnected", reinterpret_cast<PyCFunction>(ArcadeStick_add_HeadsetDisconnected), METH_O, nullptr },
        { "remove_headset_disconnected", reinterpret_cast<PyCFunction>(ArcadeStick_remove_HeadsetDisconnected), METH_O, nullptr },
        { "add_user_changed", reinterpret_cast<PyCFunction>(ArcadeStick_add_UserChanged), METH_O, nullptr },
        { "remove_user_changed", reinterpret_cast<PyCFunction>(ArcadeStick_remove_UserChanged), METH_O, nullptr },
        { "_assign_array_", _assign_array_ArcadeStick, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ArcadeStick), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ArcadeStick[] = {
        { "headset", reinterpret_cast<getter>(ArcadeStick_get_Headset), nullptr, nullptr, nullptr },
        { "is_wireless", reinterpret_cast<getter>(ArcadeStick_get_IsWireless), nullptr, nullptr, nullptr },
        { "user", reinterpret_cast<getter>(ArcadeStick_get_User), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ArcadeStick[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ArcadeStick) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ArcadeStick) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ArcadeStick) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ArcadeStick) },
        { }
    };

    static PyType_Spec type_spec_ArcadeStick = {
        "winrt._winrt_windows_gaming_input.ArcadeStick",
        sizeof(py::wrapper::Windows::Gaming::Input::ArcadeStick),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ArcadeStick};

    static PyGetSetDef getset_ArcadeStick_Static[] = {
        { "arcade_sticks", reinterpret_cast<getter>(ArcadeStick_get_ArcadeSticks), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_ArcadeStick_Static[] = {
        { "from_game_controller", reinterpret_cast<PyCFunction>(ArcadeStick_FromGameController), METH_VARARGS, nullptr },
        { "add_arcade_stick_added", reinterpret_cast<PyCFunction>(ArcadeStick_add_ArcadeStickAdded), METH_O, nullptr },
        { "remove_arcade_stick_added", reinterpret_cast<PyCFunction>(ArcadeStick_remove_ArcadeStickAdded), METH_O, nullptr },
        { "add_arcade_stick_removed", reinterpret_cast<PyCFunction>(ArcadeStick_add_ArcadeStickRemoved), METH_O, nullptr },
        { "remove_arcade_stick_removed", reinterpret_cast<PyCFunction>(ArcadeStick_remove_ArcadeStickRemoved), METH_O, nullptr },
        { }
    };

    static PyType_Slot type_slots_ArcadeStick_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_ArcadeStick_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_ArcadeStick_Static) },
        { }
    };

    static PyType_Spec type_spec_ArcadeStick_Static =
    {
        "winrt._winrt_windows_gaming_input.ArcadeStick_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_ArcadeStick_Static
    };

    // ----- FlightStick class --------------------

    static PyObject* _new_FlightStick(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Gaming::Input::FlightStick>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Gaming::Input::FlightStick>::type_name);
        return nullptr;
    }

    static void _dealloc_FlightStick(py::wrapper::Windows::Gaming::Input::FlightStick* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* FlightStick_FromGameController(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Gaming.Input.FlightStick", L"FromGameController", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Gaming::Input::IGameController>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::Gaming::Input::FlightStick::FromGameController(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* FlightStick_GetButtonLabel(py::wrapper::Windows::Gaming::Input::FlightStick* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Gaming.Input.FlightStick", L"GetButtonLabel", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Gaming::Input::FlightStickButtons>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetButtonLabel(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* FlightStick_GetCurrentReading(py::wrapper::Windows::Gaming::Input::FlightStick* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Gaming.Input.FlightStick", L"GetCurrentReading", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetCurrentReading();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* FlightStick_TryGetBatteryReport(py::wrapper::Windows::Gaming::Input::FlightStick* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Gaming.Input.FlightStick", L"TryGetBatteryReport", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.TryGetBatteryReport();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* FlightStick_get_HatSwitchKind(py::wrapper::Windows::Gaming::Input::FlightStick* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Gaming.Input.FlightStick", L"HatSwitchKind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.HatSwitchKind();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FlightStick_get_Headset(py::wrapper::Windows::Gaming::Input::FlightStick* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Gaming.Input.FlightStick", L"Headset");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Headset();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FlightStick_get_IsWireless(py::wrapper::Windows::Gaming::Input::FlightStick* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Gaming.Input.FlightStick", L"IsWireless");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsWireless();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FlightStick_get_User(py::wrapper::Windows::Gaming::Input::FlightStick* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Gaming.Input.FlightStick", L"User");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.User();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FlightStick_get_FlightSticks(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Gaming.Input.FlightStick", L"FlightSticks");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::Gaming::Input::FlightStick::FlightSticks();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FlightStick_add_HeadsetConnected(py::wrapper::Windows::Gaming::Input::FlightStick* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Gaming.Input.FlightStick", L"HeadsetConnected");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Gaming::Input::IGameController, winrt::Windows::Gaming::Input::Headset>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.HeadsetConnected(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FlightStick_remove_HeadsetConnected(py::wrapper::Windows::Gaming::Input::FlightStick* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Gaming.Input.FlightStick", L"HeadsetConnected");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.HeadsetConnected(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FlightStick_add_HeadsetDisconnected(py::wrapper::Windows::Gaming::Input::FlightStick* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Gaming.Input.FlightStick", L"HeadsetDisconnected");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Gaming::Input::IGameController, winrt::Windows::Gaming::Input::Headset>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.HeadsetDisconnected(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FlightStick_remove_HeadsetDisconnected(py::wrapper::Windows::Gaming::Input::FlightStick* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Gaming.Input.FlightStick", L"HeadsetDisconnected");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.HeadsetDisconnected(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FlightStick_add_UserChanged(py::wrapper::Windows::Gaming::Input::FlightStick* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Gaming.Input.FlightStick", L"UserChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Gaming::Input::IGameController, winrt::Windows::System::UserChangedEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.UserChanged(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FlightStick_remove_UserChanged(py::wrapper::Windows::Gaming::Input::FlightStick* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Gaming.Input.FlightStick", L"UserChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.UserChanged(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FlightStick_add_FlightStickAdded(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Gaming.Input.FlightStick", L"FlightStickAdded");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::EventHandler<winrt::Windows::Gaming::Input::FlightStick>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::Gaming::Input::FlightStick::FlightStickAdded(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FlightStick_remove_FlightStickAdded(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Gaming.Input.FlightStick", L"FlightStickAdded");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                winrt::Windows::Gaming::Input::FlightStick::FlightStickAdded(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FlightStick_add_FlightStickRemoved(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Gaming.Input.FlightStick", L"FlightStickRemoved");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::EventHandler<winrt::Windows::Gaming::Input::FlightStick>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::Gaming::Input::FlightStick::FlightStickRemoved(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FlightStick_remove_FlightStickRemoved(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Gaming.Input.FlightStick", L"FlightStickRemoved");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                winrt::Windows::Gaming::Input::FlightStick::FlightStickRemoved(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_FlightStick(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Gaming::Input::FlightStick>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_FlightStick(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Gaming::Input::FlightStick>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_FlightStick[] = {
        { "get_button_label", reinterpret_cast<PyCFunction>(FlightStick_GetButtonLabel), METH_VARARGS, nullptr },
        { "get_current_reading", reinterpret_cast<PyCFunction>(FlightStick_GetCurrentReading), METH_VARARGS, nullptr },
        { "try_get_battery_report", reinterpret_cast<PyCFunction>(FlightStick_TryGetBatteryReport), METH_VARARGS, nullptr },
        { "add_headset_connected", reinterpret_cast<PyCFunction>(FlightStick_add_HeadsetConnected), METH_O, nullptr },
        { "remove_headset_connected", reinterpret_cast<PyCFunction>(FlightStick_remove_HeadsetConnected), METH_O, nullptr },
        { "add_headset_disconnected", reinterpret_cast<PyCFunction>(FlightStick_add_HeadsetDisconnected), METH_O, nullptr },
        { "remove_headset_disconnected", reinterpret_cast<PyCFunction>(FlightStick_remove_HeadsetDisconnected), METH_O, nullptr },
        { "add_user_changed", reinterpret_cast<PyCFunction>(FlightStick_add_UserChanged), METH_O, nullptr },
        { "remove_user_changed", reinterpret_cast<PyCFunction>(FlightStick_remove_UserChanged), METH_O, nullptr },
        { "_assign_array_", _assign_array_FlightStick, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_FlightStick), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_FlightStick[] = {
        { "hat_switch_kind", reinterpret_cast<getter>(FlightStick_get_HatSwitchKind), nullptr, nullptr, nullptr },
        { "headset", reinterpret_cast<getter>(FlightStick_get_Headset), nullptr, nullptr, nullptr },
        { "is_wireless", reinterpret_cast<getter>(FlightStick_get_IsWireless), nullptr, nullptr, nullptr },
        { "user", reinterpret_cast<getter>(FlightStick_get_User), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_FlightStick[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_FlightStick) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_FlightStick) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_FlightStick) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_FlightStick) },
        { }
    };

    static PyType_Spec type_spec_FlightStick = {
        "winrt._winrt_windows_gaming_input.FlightStick",
        sizeof(py::wrapper::Windows::Gaming::Input::FlightStick),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_FlightStick};

    static PyGetSetDef getset_FlightStick_Static[] = {
        { "flight_sticks", reinterpret_cast<getter>(FlightStick_get_FlightSticks), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_FlightStick_Static[] = {
        { "from_game_controller", reinterpret_cast<PyCFunction>(FlightStick_FromGameController), METH_VARARGS, nullptr },
        { "add_flight_stick_added", reinterpret_cast<PyCFunction>(FlightStick_add_FlightStickAdded), METH_O, nullptr },
        { "remove_flight_stick_added", reinterpret_cast<PyCFunction>(FlightStick_remove_FlightStickAdded), METH_O, nullptr },
        { "add_flight_stick_removed", reinterpret_cast<PyCFunction>(FlightStick_add_FlightStickRemoved), METH_O, nullptr },
        { "remove_flight_stick_removed", reinterpret_cast<PyCFunction>(FlightStick_remove_FlightStickRemoved), METH_O, nullptr },
        { }
    };

    static PyType_Slot type_slots_FlightStick_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_FlightStick_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_FlightStick_Static) },
        { }
    };

    static PyType_Spec type_spec_FlightStick_Static =
    {
        "winrt._winrt_windows_gaming_input.FlightStick_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_FlightStick_Static
    };

    // ----- Gamepad class --------------------

    static PyObject* _new_Gamepad(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Gaming::Input::Gamepad>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Gaming::Input::Gamepad>::type_name);
        return nullptr;
    }

    static void _dealloc_Gamepad(py::wrapper::Windows::Gaming::Input::Gamepad* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* Gamepad_FromGameController(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Gaming.Input.Gamepad", L"FromGameController", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Gaming::Input::IGameController>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::Gaming::Input::Gamepad::FromGameController(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Gamepad_GetButtonLabel(py::wrapper::Windows::Gaming::Input::Gamepad* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Gaming.Input.Gamepad", L"GetButtonLabel", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Gaming::Input::GamepadButtons>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetButtonLabel(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Gamepad_GetCurrentReading(py::wrapper::Windows::Gaming::Input::Gamepad* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Gaming.Input.Gamepad", L"GetCurrentReading", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetCurrentReading();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Gamepad_TryGetBatteryReport(py::wrapper::Windows::Gaming::Input::Gamepad* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Gaming.Input.Gamepad", L"TryGetBatteryReport", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.TryGetBatteryReport();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Gamepad_get_Headset(py::wrapper::Windows::Gaming::Input::Gamepad* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Gaming.Input.Gamepad", L"Headset");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Headset();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Gamepad_get_IsWireless(py::wrapper::Windows::Gaming::Input::Gamepad* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Gaming.Input.Gamepad", L"IsWireless");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsWireless();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Gamepad_get_User(py::wrapper::Windows::Gaming::Input::Gamepad* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Gaming.Input.Gamepad", L"User");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.User();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Gamepad_get_Vibration(py::wrapper::Windows::Gaming::Input::Gamepad* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Gaming.Input.Gamepad", L"Vibration");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Vibration();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Gamepad_put_Vibration(py::wrapper::Windows::Gaming::Input::Gamepad* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Gaming.Input.Gamepad", L"Vibration");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Gaming::Input::GamepadVibration>(arg);

            {
                auto _gil = release_gil();
                self->obj.Vibration(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Gamepad_get_Gamepads(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Gaming.Input.Gamepad", L"Gamepads");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::Gaming::Input::Gamepad::Gamepads();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Gamepad_add_HeadsetConnected(py::wrapper::Windows::Gaming::Input::Gamepad* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Gaming.Input.Gamepad", L"HeadsetConnected");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Gaming::Input::IGameController, winrt::Windows::Gaming::Input::Headset>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.HeadsetConnected(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Gamepad_remove_HeadsetConnected(py::wrapper::Windows::Gaming::Input::Gamepad* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Gaming.Input.Gamepad", L"HeadsetConnected");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.HeadsetConnected(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Gamepad_add_HeadsetDisconnected(py::wrapper::Windows::Gaming::Input::Gamepad* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Gaming.Input.Gamepad", L"HeadsetDisconnected");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Gaming::Input::IGameController, winrt::Windows::Gaming::Input::Headset>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.HeadsetDisconnected(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Gamepad_remove_HeadsetDisconnected(py::wrapper::Windows::Gaming::Input::Gamepad* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Gaming.Input.Gamepad", L"HeadsetDisconnected");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.HeadsetDisconnected(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Gamepad_add_UserChanged(py::wrapper::Windows::Gaming::Input::Gamepad* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Gaming.Input.Gamepad", L"UserChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Gaming::Input::IGameController, winrt::Windows::System::UserChangedEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.UserChanged(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Gamepad_remove_UserChanged(py::wrapper::Windows::Gaming::Input::Gamepad* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Gaming.Input.Gamepad", L"UserChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.UserChanged(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Gamepad_add_GamepadAdded(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Gaming.Input.Gamepad", L"GamepadAdded");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::EventHandler<winrt::Windows::Gaming::Input::Gamepad>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::Gaming::Input::Gamepad::GamepadAdded(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Gamepad_remove_GamepadAdded(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Gaming.Input.Gamepad", L"GamepadAdded");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                winrt::Windows::Gaming::Input::Gamepad::GamepadAdded(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Gamepad_add_GamepadRemoved(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Gaming.Input.Gamepad", L"GamepadRemoved");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::EventHandler<winrt::Windows::Gaming::Input::Gamepad>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::Gaming::Input::Gamepad::GamepadRemoved(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Gamepad_remove_GamepadRemoved(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Gaming.Input.Gamepad", L"GamepadRemoved");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                winrt::Windows::Gaming::Input::Gamepad::GamepadRemoved(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_Gamepad(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Gaming::Input::Gamepad>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_Gamepad(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Gaming::Input::Gamepad>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_Gamepad[] = {
        { "get_button_label", reinterpret_cast<PyCFunction>(Gamepad_GetButtonLabel), METH_VARARGS, nullptr },
        { "get_current_reading", reinterpret_cast<PyCFunction>(Gamepad_GetCurrentReading), METH_VARARGS, nullptr },
        { "try_get_battery_report", reinterpret_cast<PyCFunction>(Gamepad_TryGetBatteryReport), METH_VARARGS, nullptr },
        { "add_headset_connected", reinterpret_cast<PyCFunction>(Gamepad_add_HeadsetConnected), METH_O, nullptr },
        { "remove_headset_connected", reinterpret_cast<PyCFunction>(Gamepad_remove_HeadsetConnected), METH_O, nullptr },
        { "add_headset_disconnected", reinterpret_cast<PyCFunction>(Gamepad_add_HeadsetDisconnected), METH_O, nullptr },
        { "remove_headset_disconnected", reinterpret_cast<PyCFunction>(Gamepad_remove_HeadsetDisconnected), METH_O, nullptr },
        { "add_user_changed", reinterpret_cast<PyCFunction>(Gamepad_add_UserChanged), METH_O, nullptr },
        { "remove_user_changed", reinterpret_cast<PyCFunction>(Gamepad_remove_UserChanged), METH_O, nullptr },
        { "_assign_array_", _assign_array_Gamepad, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_Gamepad), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_Gamepad[] = {
        { "headset", reinterpret_cast<getter>(Gamepad_get_Headset), nullptr, nullptr, nullptr },
        { "is_wireless", reinterpret_cast<getter>(Gamepad_get_IsWireless), nullptr, nullptr, nullptr },
        { "user", reinterpret_cast<getter>(Gamepad_get_User), nullptr, nullptr, nullptr },
        { "vibration", reinterpret_cast<getter>(Gamepad_get_Vibration), reinterpret_cast<setter>(Gamepad_put_Vibration), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_Gamepad[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_Gamepad) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_Gamepad) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_Gamepad) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_Gamepad) },
        { }
    };

    static PyType_Spec type_spec_Gamepad = {
        "winrt._winrt_windows_gaming_input.Gamepad",
        sizeof(py::wrapper::Windows::Gaming::Input::Gamepad),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_Gamepad};

    static PyGetSetDef getset_Gamepad_Static[] = {
        { "gamepads", reinterpret_cast<getter>(Gamepad_get_Gamepads), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_Gamepad_Static[] = {
        { "from_game_controller", reinterpret_cast<PyCFunction>(Gamepad_FromGameController), METH_VARARGS, nullptr },
        { "add_gamepad_added", reinterpret_cast<PyCFunction>(Gamepad_add_GamepadAdded), METH_O, nullptr },
        { "remove_gamepad_added", reinterpret_cast<PyCFunction>(Gamepad_remove_GamepadAdded), METH_O, nullptr },
        { "add_gamepad_removed", reinterpret_cast<PyCFunction>(Gamepad_add_GamepadRemoved), METH_O, nullptr },
        { "remove_gamepad_removed", reinterpret_cast<PyCFunction>(Gamepad_remove_GamepadRemoved), METH_O, nullptr },
        { }
    };

    static PyType_Slot type_slots_Gamepad_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_Gamepad_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_Gamepad_Static) },
        { }
    };

    static PyType_Spec type_spec_Gamepad_Static =
    {
        "winrt._winrt_windows_gaming_input.Gamepad_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_Gamepad_Static
    };

    // ----- Headset class --------------------

    static PyObject* _new_Headset(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Gaming::Input::Headset>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Gaming::Input::Headset>::type_name);
        return nullptr;
    }

    static void _dealloc_Headset(py::wrapper::Windows::Gaming::Input::Headset* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* Headset_TryGetBatteryReport(py::wrapper::Windows::Gaming::Input::Headset* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Gaming.Input.Headset", L"TryGetBatteryReport", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.TryGetBatteryReport();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Headset_get_CaptureDeviceId(py::wrapper::Windows::Gaming::Input::Headset* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Gaming.Input.Headset", L"CaptureDeviceId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.CaptureDeviceId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Headset_get_RenderDeviceId(py::wrapper::Windows::Gaming::Input::Headset* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Gaming.Input.Headset", L"RenderDeviceId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.RenderDeviceId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_Headset(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Gaming::Input::Headset>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_Headset(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Gaming::Input::Headset>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_Headset[] = {
        { "try_get_battery_report", reinterpret_cast<PyCFunction>(Headset_TryGetBatteryReport), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_Headset, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_Headset), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_Headset[] = {
        { "capture_device_id", reinterpret_cast<getter>(Headset_get_CaptureDeviceId), nullptr, nullptr, nullptr },
        { "render_device_id", reinterpret_cast<getter>(Headset_get_RenderDeviceId), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_Headset[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_Headset) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_Headset) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_Headset) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_Headset) },
        { }
    };

    static PyType_Spec type_spec_Headset = {
        "winrt._winrt_windows_gaming_input.Headset",
        sizeof(py::wrapper::Windows::Gaming::Input::Headset),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_Headset};

    // ----- RacingWheel class --------------------

    static PyObject* _new_RacingWheel(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Gaming::Input::RacingWheel>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Gaming::Input::RacingWheel>::type_name);
        return nullptr;
    }

    static void _dealloc_RacingWheel(py::wrapper::Windows::Gaming::Input::RacingWheel* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* RacingWheel_FromGameController(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Gaming.Input.RacingWheel", L"FromGameController", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Gaming::Input::IGameController>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::Gaming::Input::RacingWheel::FromGameController(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RacingWheel_GetButtonLabel(py::wrapper::Windows::Gaming::Input::RacingWheel* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Gaming.Input.RacingWheel", L"GetButtonLabel", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Gaming::Input::RacingWheelButtons>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetButtonLabel(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RacingWheel_GetCurrentReading(py::wrapper::Windows::Gaming::Input::RacingWheel* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Gaming.Input.RacingWheel", L"GetCurrentReading", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetCurrentReading();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RacingWheel_TryGetBatteryReport(py::wrapper::Windows::Gaming::Input::RacingWheel* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Gaming.Input.RacingWheel", L"TryGetBatteryReport", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.TryGetBatteryReport();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RacingWheel_get_Headset(py::wrapper::Windows::Gaming::Input::RacingWheel* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Gaming.Input.RacingWheel", L"Headset");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Headset();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RacingWheel_get_IsWireless(py::wrapper::Windows::Gaming::Input::RacingWheel* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Gaming.Input.RacingWheel", L"IsWireless");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsWireless();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RacingWheel_get_User(py::wrapper::Windows::Gaming::Input::RacingWheel* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Gaming.Input.RacingWheel", L"User");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.User();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RacingWheel_get_HasClutch(py::wrapper::Windows::Gaming::Input::RacingWheel* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Gaming.Input.RacingWheel", L"HasClutch");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.HasClutch();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RacingWheel_get_HasHandbrake(py::wrapper::Windows::Gaming::Input::RacingWheel* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Gaming.Input.RacingWheel", L"HasHandbrake");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.HasHandbrake();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RacingWheel_get_HasPatternShifter(py::wrapper::Windows::Gaming::Input::RacingWheel* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Gaming.Input.RacingWheel", L"HasPatternShifter");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.HasPatternShifter();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RacingWheel_get_MaxPatternShifterGear(py::wrapper::Windows::Gaming::Input::RacingWheel* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Gaming.Input.RacingWheel", L"MaxPatternShifterGear");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.MaxPatternShifterGear();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RacingWheel_get_MaxWheelAngle(py::wrapper::Windows::Gaming::Input::RacingWheel* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Gaming.Input.RacingWheel", L"MaxWheelAngle");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.MaxWheelAngle();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RacingWheel_get_WheelMotor(py::wrapper::Windows::Gaming::Input::RacingWheel* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Gaming.Input.RacingWheel", L"WheelMotor");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.WheelMotor();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RacingWheel_get_RacingWheels(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Gaming.Input.RacingWheel", L"RacingWheels");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::Gaming::Input::RacingWheel::RacingWheels();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RacingWheel_add_HeadsetConnected(py::wrapper::Windows::Gaming::Input::RacingWheel* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Gaming.Input.RacingWheel", L"HeadsetConnected");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Gaming::Input::IGameController, winrt::Windows::Gaming::Input::Headset>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.HeadsetConnected(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RacingWheel_remove_HeadsetConnected(py::wrapper::Windows::Gaming::Input::RacingWheel* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Gaming.Input.RacingWheel", L"HeadsetConnected");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.HeadsetConnected(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RacingWheel_add_HeadsetDisconnected(py::wrapper::Windows::Gaming::Input::RacingWheel* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Gaming.Input.RacingWheel", L"HeadsetDisconnected");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Gaming::Input::IGameController, winrt::Windows::Gaming::Input::Headset>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.HeadsetDisconnected(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RacingWheel_remove_HeadsetDisconnected(py::wrapper::Windows::Gaming::Input::RacingWheel* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Gaming.Input.RacingWheel", L"HeadsetDisconnected");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.HeadsetDisconnected(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RacingWheel_add_UserChanged(py::wrapper::Windows::Gaming::Input::RacingWheel* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Gaming.Input.RacingWheel", L"UserChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Gaming::Input::IGameController, winrt::Windows::System::UserChangedEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.UserChanged(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RacingWheel_remove_UserChanged(py::wrapper::Windows::Gaming::Input::RacingWheel* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Gaming.Input.RacingWheel", L"UserChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.UserChanged(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RacingWheel_add_RacingWheelAdded(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Gaming.Input.RacingWheel", L"RacingWheelAdded");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::EventHandler<winrt::Windows::Gaming::Input::RacingWheel>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::Gaming::Input::RacingWheel::RacingWheelAdded(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RacingWheel_remove_RacingWheelAdded(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Gaming.Input.RacingWheel", L"RacingWheelAdded");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                winrt::Windows::Gaming::Input::RacingWheel::RacingWheelAdded(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RacingWheel_add_RacingWheelRemoved(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Gaming.Input.RacingWheel", L"RacingWheelRemoved");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::EventHandler<winrt::Windows::Gaming::Input::RacingWheel>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::Gaming::Input::RacingWheel::RacingWheelRemoved(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RacingWheel_remove_RacingWheelRemoved(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Gaming.Input.RacingWheel", L"RacingWheelRemoved");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                winrt::Windows::Gaming::Input::RacingWheel::RacingWheelRemoved(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_RacingWheel(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Gaming::Input::RacingWheel>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_RacingWheel(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Gaming::Input::RacingWheel>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RacingWheel[] = {
        { "get_button_label", reinterpret_cast<PyCFunction>(RacingWheel_GetButtonLabel), METH_VARARGS, nullptr },
        { "get_current_reading", reinterpret_cast<PyCFunction>(RacingWheel_GetCurrentReading), METH_VARARGS, nullptr },
        { "try_get_battery_report", reinterpret_cast<PyCFunction>(RacingWheel_TryGetBatteryReport), METH_VARARGS, nullptr },
        { "add_headset_connected", reinterpret_cast<PyCFunction>(RacingWheel_add_HeadsetConnected), METH_O, nullptr },
        { "remove_headset_connected", reinterpret_cast<PyCFunction>(RacingWheel_remove_HeadsetConnected), METH_O, nullptr },
        { "add_headset_disconnected", reinterpret_cast<PyCFunction>(RacingWheel_add_HeadsetDisconnected), METH_O, nullptr },
        { "remove_headset_disconnected", reinterpret_cast<PyCFunction>(RacingWheel_remove_HeadsetDisconnected), METH_O, nullptr },
        { "add_user_changed", reinterpret_cast<PyCFunction>(RacingWheel_add_UserChanged), METH_O, nullptr },
        { "remove_user_changed", reinterpret_cast<PyCFunction>(RacingWheel_remove_UserChanged), METH_O, nullptr },
        { "_assign_array_", _assign_array_RacingWheel, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_RacingWheel), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_RacingWheel[] = {
        { "headset", reinterpret_cast<getter>(RacingWheel_get_Headset), nullptr, nullptr, nullptr },
        { "is_wireless", reinterpret_cast<getter>(RacingWheel_get_IsWireless), nullptr, nullptr, nullptr },
        { "user", reinterpret_cast<getter>(RacingWheel_get_User), nullptr, nullptr, nullptr },
        { "has_clutch", reinterpret_cast<getter>(RacingWheel_get_HasClutch), nullptr, nullptr, nullptr },
        { "has_handbrake", reinterpret_cast<getter>(RacingWheel_get_HasHandbrake), nullptr, nullptr, nullptr },
        { "has_pattern_shifter", reinterpret_cast<getter>(RacingWheel_get_HasPatternShifter), nullptr, nullptr, nullptr },
        { "max_pattern_shifter_gear", reinterpret_cast<getter>(RacingWheel_get_MaxPatternShifterGear), nullptr, nullptr, nullptr },
        { "max_wheel_angle", reinterpret_cast<getter>(RacingWheel_get_MaxWheelAngle), nullptr, nullptr, nullptr },
        { "wheel_motor", reinterpret_cast<getter>(RacingWheel_get_WheelMotor), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_RacingWheel[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_RacingWheel) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_RacingWheel) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_RacingWheel) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_RacingWheel) },
        { }
    };

    static PyType_Spec type_spec_RacingWheel = {
        "winrt._winrt_windows_gaming_input.RacingWheel",
        sizeof(py::wrapper::Windows::Gaming::Input::RacingWheel),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RacingWheel};

    static PyGetSetDef getset_RacingWheel_Static[] = {
        { "racing_wheels", reinterpret_cast<getter>(RacingWheel_get_RacingWheels), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_RacingWheel_Static[] = {
        { "from_game_controller", reinterpret_cast<PyCFunction>(RacingWheel_FromGameController), METH_VARARGS, nullptr },
        { "add_racing_wheel_added", reinterpret_cast<PyCFunction>(RacingWheel_add_RacingWheelAdded), METH_O, nullptr },
        { "remove_racing_wheel_added", reinterpret_cast<PyCFunction>(RacingWheel_remove_RacingWheelAdded), METH_O, nullptr },
        { "add_racing_wheel_removed", reinterpret_cast<PyCFunction>(RacingWheel_add_RacingWheelRemoved), METH_O, nullptr },
        { "remove_racing_wheel_removed", reinterpret_cast<PyCFunction>(RacingWheel_remove_RacingWheelRemoved), METH_O, nullptr },
        { }
    };

    static PyType_Slot type_slots_RacingWheel_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_RacingWheel_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_RacingWheel_Static) },
        { }
    };

    static PyType_Spec type_spec_RacingWheel_Static =
    {
        "winrt._winrt_windows_gaming_input.RacingWheel_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_RacingWheel_Static
    };

    // ----- RawGameController class --------------------

    static PyObject* _new_RawGameController(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Gaming::Input::RawGameController>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Gaming::Input::RawGameController>::type_name);
        return nullptr;
    }

    static void _dealloc_RawGameController(py::wrapper::Windows::Gaming::Input::RawGameController* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* RawGameController_FromGameController(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Gaming.Input.RawGameController", L"FromGameController", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Gaming::Input::IGameController>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::Gaming::Input::RawGameController::FromGameController(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RawGameController_GetButtonLabel(py::wrapper::Windows::Gaming::Input::RawGameController* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Gaming.Input.RawGameController", L"GetButtonLabel", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<int32_t>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetButtonLabel(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RawGameController_GetCurrentReading(py::wrapper::Windows::Gaming::Input::RawGameController* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Gaming.Input.RawGameController", L"GetCurrentReading", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                auto param0 = py::convert_to<py::pybuf_view<bool, true>>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<winrt::Windows::Gaming::Input::GameControllerSwitchPosition, true>>(args, 1);
                auto param2 = py::convert_to<py::pybuf_view<double, true>>(args, 2);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetCurrentReading(param0, param1, param2);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RawGameController_GetSwitchKind(py::wrapper::Windows::Gaming::Input::RawGameController* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Gaming.Input.RawGameController", L"GetSwitchKind", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<int32_t>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetSwitchKind(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RawGameController_TryGetBatteryReport(py::wrapper::Windows::Gaming::Input::RawGameController* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Gaming.Input.RawGameController", L"TryGetBatteryReport", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.TryGetBatteryReport();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RawGameController_get_Headset(py::wrapper::Windows::Gaming::Input::RawGameController* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Gaming.Input.RawGameController", L"Headset");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Headset();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RawGameController_get_IsWireless(py::wrapper::Windows::Gaming::Input::RawGameController* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Gaming.Input.RawGameController", L"IsWireless");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsWireless();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RawGameController_get_User(py::wrapper::Windows::Gaming::Input::RawGameController* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Gaming.Input.RawGameController", L"User");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.User();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RawGameController_get_AxisCount(py::wrapper::Windows::Gaming::Input::RawGameController* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Gaming.Input.RawGameController", L"AxisCount");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.AxisCount();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RawGameController_get_ButtonCount(py::wrapper::Windows::Gaming::Input::RawGameController* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Gaming.Input.RawGameController", L"ButtonCount");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ButtonCount();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RawGameController_get_ForceFeedbackMotors(py::wrapper::Windows::Gaming::Input::RawGameController* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Gaming.Input.RawGameController", L"ForceFeedbackMotors");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ForceFeedbackMotors();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RawGameController_get_HardwareProductId(py::wrapper::Windows::Gaming::Input::RawGameController* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Gaming.Input.RawGameController", L"HardwareProductId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.HardwareProductId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RawGameController_get_HardwareVendorId(py::wrapper::Windows::Gaming::Input::RawGameController* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Gaming.Input.RawGameController", L"HardwareVendorId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.HardwareVendorId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RawGameController_get_SwitchCount(py::wrapper::Windows::Gaming::Input::RawGameController* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Gaming.Input.RawGameController", L"SwitchCount");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SwitchCount();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RawGameController_get_DisplayName(py::wrapper::Windows::Gaming::Input::RawGameController* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Gaming.Input.RawGameController", L"DisplayName");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.DisplayName();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RawGameController_get_NonRoamableId(py::wrapper::Windows::Gaming::Input::RawGameController* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Gaming.Input.RawGameController", L"NonRoamableId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.NonRoamableId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RawGameController_get_SimpleHapticsControllers(py::wrapper::Windows::Gaming::Input::RawGameController* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Gaming.Input.RawGameController", L"SimpleHapticsControllers");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SimpleHapticsControllers();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RawGameController_get_RawGameControllers(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Gaming.Input.RawGameController", L"RawGameControllers");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::Gaming::Input::RawGameController::RawGameControllers();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RawGameController_add_HeadsetConnected(py::wrapper::Windows::Gaming::Input::RawGameController* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Gaming.Input.RawGameController", L"HeadsetConnected");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Gaming::Input::IGameController, winrt::Windows::Gaming::Input::Headset>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.HeadsetConnected(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RawGameController_remove_HeadsetConnected(py::wrapper::Windows::Gaming::Input::RawGameController* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Gaming.Input.RawGameController", L"HeadsetConnected");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.HeadsetConnected(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RawGameController_add_HeadsetDisconnected(py::wrapper::Windows::Gaming::Input::RawGameController* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Gaming.Input.RawGameController", L"HeadsetDisconnected");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Gaming::Input::IGameController, winrt::Windows::Gaming::Input::Headset>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.HeadsetDisconnected(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RawGameController_remove_HeadsetDisconnected(py::wrapper::Windows::Gaming::Input::RawGameController* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Gaming.Input.RawGameController", L"HeadsetDisconnected");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.HeadsetDisconnected(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RawGameController_add_UserChanged(py::wrapper::Windows::Gaming::Input::RawGameController* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Gaming.Input.RawGameController", L"UserChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Gaming::Input::IGameController, winrt::Windows::System::UserChangedEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.UserChanged(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RawGameController_remove_UserChanged(py::wrapper::Windows::Gaming::Input::RawGameController* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Gaming.Input.RawGameController", L"UserChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.UserChanged(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RawGameController_add_RawGameControllerAdded(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Gaming.Input.RawGameController", L"RawGameControllerAdded");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::EventHandler<winrt::Windows::Gaming::Input::RawGameController>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::Gaming::Input::RawGameController::RawGameControllerAdded(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RawGameController_remove_RawGameControllerAdded(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Gaming.Input.RawGameController", L"RawGameControllerAdded");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                winrt::Windows::Gaming::Input::RawGameController::RawGameControllerAdded(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RawGameController_add_RawGameControllerRemoved(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Gaming.Input.RawGameController", L"RawGameControllerRemoved");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::EventHandler<winrt::Windows::Gaming::Input::RawGameController>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::Gaming::Input::RawGameController::RawGameControllerRemoved(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RawGameController_remove_RawGameControllerRemoved(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Gaming.Input.RawGameController", L"RawGameControllerRemoved");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                winrt::Windows::Gaming::Input::RawGameController::RawGameControllerRemoved(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_RawGameController(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Gaming::Input::RawGameController>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_RawGameController(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Gaming::Input::RawGameController>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RawGameController[] = {
        { "get_button_label", reinterpret_cast<PyCFunction>(RawGameController_GetButtonLabel), METH_VARARGS, nullptr },
        { "get_current_reading", reinterpret_cast<PyCFunction>(RawGameController_GetCurrentReading), METH_VARARGS, nullptr },
        { "get_switch_kind", reinterpret_cast<PyCFunction>(RawGameController_GetSwitchKind), METH_VARARGS, nullptr },
        { "try_get_battery_report", reinterpret_cast<PyCFunction>(RawGameController_TryGetBatteryReport), METH_VARARGS, nullptr },
        { "add_headset_connected", reinterpret_cast<PyCFunction>(RawGameController_add_HeadsetConnected), METH_O, nullptr },
        { "remove_headset_connected", reinterpret_cast<PyCFunction>(RawGameController_remove_HeadsetConnected), METH_O, nullptr },
        { "add_headset_disconnected", reinterpret_cast<PyCFunction>(RawGameController_add_HeadsetDisconnected), METH_O, nullptr },
        { "remove_headset_disconnected", reinterpret_cast<PyCFunction>(RawGameController_remove_HeadsetDisconnected), METH_O, nullptr },
        { "add_user_changed", reinterpret_cast<PyCFunction>(RawGameController_add_UserChanged), METH_O, nullptr },
        { "remove_user_changed", reinterpret_cast<PyCFunction>(RawGameController_remove_UserChanged), METH_O, nullptr },
        { "_assign_array_", _assign_array_RawGameController, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_RawGameController), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_RawGameController[] = {
        { "headset", reinterpret_cast<getter>(RawGameController_get_Headset), nullptr, nullptr, nullptr },
        { "is_wireless", reinterpret_cast<getter>(RawGameController_get_IsWireless), nullptr, nullptr, nullptr },
        { "user", reinterpret_cast<getter>(RawGameController_get_User), nullptr, nullptr, nullptr },
        { "axis_count", reinterpret_cast<getter>(RawGameController_get_AxisCount), nullptr, nullptr, nullptr },
        { "button_count", reinterpret_cast<getter>(RawGameController_get_ButtonCount), nullptr, nullptr, nullptr },
        { "force_feedback_motors", reinterpret_cast<getter>(RawGameController_get_ForceFeedbackMotors), nullptr, nullptr, nullptr },
        { "hardware_product_id", reinterpret_cast<getter>(RawGameController_get_HardwareProductId), nullptr, nullptr, nullptr },
        { "hardware_vendor_id", reinterpret_cast<getter>(RawGameController_get_HardwareVendorId), nullptr, nullptr, nullptr },
        { "switch_count", reinterpret_cast<getter>(RawGameController_get_SwitchCount), nullptr, nullptr, nullptr },
        { "display_name", reinterpret_cast<getter>(RawGameController_get_DisplayName), nullptr, nullptr, nullptr },
        { "non_roamable_id", reinterpret_cast<getter>(RawGameController_get_NonRoamableId), nullptr, nullptr, nullptr },
        { "simple_haptics_controllers", reinterpret_cast<getter>(RawGameController_get_SimpleHapticsControllers), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_RawGameController[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_RawGameController) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_RawGameController) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_RawGameController) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_RawGameController) },
        { }
    };

    static PyType_Spec type_spec_RawGameController = {
        "winrt._winrt_windows_gaming_input.RawGameController",
        sizeof(py::wrapper::Windows::Gaming::Input::RawGameController),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RawGameController};

    static PyGetSetDef getset_RawGameController_Static[] = {
        { "raw_game_controllers", reinterpret_cast<getter>(RawGameController_get_RawGameControllers), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_RawGameController_Static[] = {
        { "from_game_controller", reinterpret_cast<PyCFunction>(RawGameController_FromGameController), METH_VARARGS, nullptr },
        { "add_raw_game_controller_added", reinterpret_cast<PyCFunction>(RawGameController_add_RawGameControllerAdded), METH_O, nullptr },
        { "remove_raw_game_controller_added", reinterpret_cast<PyCFunction>(RawGameController_remove_RawGameControllerAdded), METH_O, nullptr },
        { "add_raw_game_controller_removed", reinterpret_cast<PyCFunction>(RawGameController_add_RawGameControllerRemoved), METH_O, nullptr },
        { "remove_raw_game_controller_removed", reinterpret_cast<PyCFunction>(RawGameController_remove_RawGameControllerRemoved), METH_O, nullptr },
        { }
    };

    static PyType_Slot type_slots_RawGameController_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_RawGameController_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_RawGameController_Static) },
        { }
    };

    static PyType_Spec type_spec_RawGameController_Static =
    {
        "winrt._winrt_windows_gaming_input.RawGameController_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_RawGameController_Static
    };

    // ----- UINavigationController class --------------------

    static PyObject* _new_UINavigationController(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Gaming::Input::UINavigationController>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Gaming::Input::UINavigationController>::type_name);
        return nullptr;
    }

    static void _dealloc_UINavigationController(py::wrapper::Windows::Gaming::Input::UINavigationController* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* UINavigationController_FromGameController(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Gaming.Input.UINavigationController", L"FromGameController", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Gaming::Input::IGameController>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::Gaming::Input::UINavigationController::FromGameController(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* UINavigationController_GetCurrentReading(py::wrapper::Windows::Gaming::Input::UINavigationController* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Gaming.Input.UINavigationController", L"GetCurrentReading", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetCurrentReading();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* UINavigationController_GetOptionalButtonLabel(py::wrapper::Windows::Gaming::Input::UINavigationController* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Gaming.Input.UINavigationController", L"GetOptionalButtonLabel", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Gaming::Input::OptionalUINavigationButtons>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetOptionalButtonLabel(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* UINavigationController_GetRequiredButtonLabel(py::wrapper::Windows::Gaming::Input::UINavigationController* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Gaming.Input.UINavigationController", L"GetRequiredButtonLabel", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Gaming::Input::RequiredUINavigationButtons>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetRequiredButtonLabel(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* UINavigationController_TryGetBatteryReport(py::wrapper::Windows::Gaming::Input::UINavigationController* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Gaming.Input.UINavigationController", L"TryGetBatteryReport", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.TryGetBatteryReport();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* UINavigationController_get_Headset(py::wrapper::Windows::Gaming::Input::UINavigationController* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Gaming.Input.UINavigationController", L"Headset");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Headset();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UINavigationController_get_IsWireless(py::wrapper::Windows::Gaming::Input::UINavigationController* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Gaming.Input.UINavigationController", L"IsWireless");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsWireless();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UINavigationController_get_User(py::wrapper::Windows::Gaming::Input::UINavigationController* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Gaming.Input.UINavigationController", L"User");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.User();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UINavigationController_get_UINavigationControllers(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Gaming.Input.UINavigationController", L"UINavigationControllers");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::Gaming::Input::UINavigationController::UINavigationControllers();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UINavigationController_add_HeadsetConnected(py::wrapper::Windows::Gaming::Input::UINavigationController* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Gaming.Input.UINavigationController", L"HeadsetConnected");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Gaming::Input::IGameController, winrt::Windows::Gaming::Input::Headset>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.HeadsetConnected(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UINavigationController_remove_HeadsetConnected(py::wrapper::Windows::Gaming::Input::UINavigationController* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Gaming.Input.UINavigationController", L"HeadsetConnected");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.HeadsetConnected(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UINavigationController_add_HeadsetDisconnected(py::wrapper::Windows::Gaming::Input::UINavigationController* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Gaming.Input.UINavigationController", L"HeadsetDisconnected");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Gaming::Input::IGameController, winrt::Windows::Gaming::Input::Headset>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.HeadsetDisconnected(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UINavigationController_remove_HeadsetDisconnected(py::wrapper::Windows::Gaming::Input::UINavigationController* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Gaming.Input.UINavigationController", L"HeadsetDisconnected");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.HeadsetDisconnected(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UINavigationController_add_UserChanged(py::wrapper::Windows::Gaming::Input::UINavigationController* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Gaming.Input.UINavigationController", L"UserChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Gaming::Input::IGameController, winrt::Windows::System::UserChangedEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.UserChanged(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UINavigationController_remove_UserChanged(py::wrapper::Windows::Gaming::Input::UINavigationController* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Gaming.Input.UINavigationController", L"UserChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.UserChanged(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UINavigationController_add_UINavigationControllerAdded(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Gaming.Input.UINavigationController", L"UINavigationControllerAdded");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::EventHandler<winrt::Windows::Gaming::Input::UINavigationController>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::Gaming::Input::UINavigationController::UINavigationControllerAdded(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UINavigationController_remove_UINavigationControllerAdded(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Gaming.Input.UINavigationController", L"UINavigationControllerAdded");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                winrt::Windows::Gaming::Input::UINavigationController::UINavigationControllerAdded(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UINavigationController_add_UINavigationControllerRemoved(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Gaming.Input.UINavigationController", L"UINavigationControllerRemoved");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::EventHandler<winrt::Windows::Gaming::Input::UINavigationController>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::Gaming::Input::UINavigationController::UINavigationControllerRemoved(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UINavigationController_remove_UINavigationControllerRemoved(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Gaming.Input.UINavigationController", L"UINavigationControllerRemoved");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                winrt::Windows::Gaming::Input::UINavigationController::UINavigationControllerRemoved(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_UINavigationController(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Gaming::Input::UINavigationController>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_UINavigationController(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Gaming::Input::UINavigationController>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_UINavigationController[] = {
        { "get_current_reading", reinterpret_cast<PyCFunction>(UINavigationController_GetCurrentReading), METH_VARARGS, nullptr },
        { "get_optional_button_label", reinterpret_cast<PyCFunction>(UINavigationController_GetOptionalButtonLabel), METH_VARARGS, nullptr },
        { "get_required_button_label", reinterpret_cast<PyCFunction>(UINavigationController_GetRequiredButtonLabel), METH_VARARGS, nullptr },
        { "try_get_battery_report", reinterpret_cast<PyCFunction>(UINavigationController_TryGetBatteryReport), METH_VARARGS, nullptr },
        { "add_headset_connected", reinterpret_cast<PyCFunction>(UINavigationController_add_HeadsetConnected), METH_O, nullptr },
        { "remove_headset_connected", reinterpret_cast<PyCFunction>(UINavigationController_remove_HeadsetConnected), METH_O, nullptr },
        { "add_headset_disconnected", reinterpret_cast<PyCFunction>(UINavigationController_add_HeadsetDisconnected), METH_O, nullptr },
        { "remove_headset_disconnected", reinterpret_cast<PyCFunction>(UINavigationController_remove_HeadsetDisconnected), METH_O, nullptr },
        { "add_user_changed", reinterpret_cast<PyCFunction>(UINavigationController_add_UserChanged), METH_O, nullptr },
        { "remove_user_changed", reinterpret_cast<PyCFunction>(UINavigationController_remove_UserChanged), METH_O, nullptr },
        { "_assign_array_", _assign_array_UINavigationController, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_UINavigationController), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_UINavigationController[] = {
        { "headset", reinterpret_cast<getter>(UINavigationController_get_Headset), nullptr, nullptr, nullptr },
        { "is_wireless", reinterpret_cast<getter>(UINavigationController_get_IsWireless), nullptr, nullptr, nullptr },
        { "user", reinterpret_cast<getter>(UINavigationController_get_User), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_UINavigationController[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_UINavigationController) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_UINavigationController) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_UINavigationController) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_UINavigationController) },
        { }
    };

    static PyType_Spec type_spec_UINavigationController = {
        "winrt._winrt_windows_gaming_input.UINavigationController",
        sizeof(py::wrapper::Windows::Gaming::Input::UINavigationController),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_UINavigationController};

    static PyGetSetDef getset_UINavigationController_Static[] = {
        { "ui_navigation_controllers", reinterpret_cast<getter>(UINavigationController_get_UINavigationControllers), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_UINavigationController_Static[] = {
        { "from_game_controller", reinterpret_cast<PyCFunction>(UINavigationController_FromGameController), METH_VARARGS, nullptr },
        { "add_ui_navigation_controller_added", reinterpret_cast<PyCFunction>(UINavigationController_add_UINavigationControllerAdded), METH_O, nullptr },
        { "remove_ui_navigation_controller_added", reinterpret_cast<PyCFunction>(UINavigationController_remove_UINavigationControllerAdded), METH_O, nullptr },
        { "add_ui_navigation_controller_removed", reinterpret_cast<PyCFunction>(UINavigationController_add_UINavigationControllerRemoved), METH_O, nullptr },
        { "remove_ui_navigation_controller_removed", reinterpret_cast<PyCFunction>(UINavigationController_remove_UINavigationControllerRemoved), METH_O, nullptr },
        { }
    };

    static PyType_Slot type_slots_UINavigationController_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_UINavigationController_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_UINavigationController_Static) },
        { }
    };

    static PyType_Spec type_spec_UINavigationController_Static =
    {
        "winrt._winrt_windows_gaming_input.UINavigationController_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_UINavigationController_Static
    };

    // ----- IGameController interface --------------------

    static PyObject* _new_IGameController(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Gaming::Input::IGameController>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Gaming::Input::IGameController>::type_name);
        return nullptr;
    }

    static void _dealloc_IGameController(py::wrapper::Windows::Gaming::Input::IGameController* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IGameController_get_Headset(py::wrapper::Windows::Gaming::Input::IGameController* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Gaming.Input.IGameController", L"Headset");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Headset();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IGameController_get_IsWireless(py::wrapper::Windows::Gaming::Input::IGameController* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Gaming.Input.IGameController", L"IsWireless");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsWireless();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IGameController_get_User(py::wrapper::Windows::Gaming::Input::IGameController* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Gaming.Input.IGameController", L"User");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.User();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IGameController_add_HeadsetConnected(py::wrapper::Windows::Gaming::Input::IGameController* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Gaming.Input.IGameController", L"HeadsetConnected");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Gaming::Input::IGameController, winrt::Windows::Gaming::Input::Headset>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.HeadsetConnected(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IGameController_remove_HeadsetConnected(py::wrapper::Windows::Gaming::Input::IGameController* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Gaming.Input.IGameController", L"HeadsetConnected");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.HeadsetConnected(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IGameController_add_HeadsetDisconnected(py::wrapper::Windows::Gaming::Input::IGameController* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Gaming.Input.IGameController", L"HeadsetDisconnected");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Gaming::Input::IGameController, winrt::Windows::Gaming::Input::Headset>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.HeadsetDisconnected(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IGameController_remove_HeadsetDisconnected(py::wrapper::Windows::Gaming::Input::IGameController* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Gaming.Input.IGameController", L"HeadsetDisconnected");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.HeadsetDisconnected(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IGameController_add_UserChanged(py::wrapper::Windows::Gaming::Input::IGameController* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Gaming.Input.IGameController", L"UserChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Gaming::Input::IGameController, winrt::Windows::System::UserChangedEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.UserChanged(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IGameController_remove_UserChanged(py::wrapper::Windows::Gaming::Input::IGameController* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Gaming.Input.IGameController", L"UserChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.UserChanged(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_IGameController(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Gaming::Input::IGameController>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IGameController(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Gaming::Input::IGameController>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IGameController[] = {
        { "add_headset_connected", reinterpret_cast<PyCFunction>(IGameController_add_HeadsetConnected), METH_O, nullptr },
        { "remove_headset_connected", reinterpret_cast<PyCFunction>(IGameController_remove_HeadsetConnected), METH_O, nullptr },
        { "add_headset_disconnected", reinterpret_cast<PyCFunction>(IGameController_add_HeadsetDisconnected), METH_O, nullptr },
        { "remove_headset_disconnected", reinterpret_cast<PyCFunction>(IGameController_remove_HeadsetDisconnected), METH_O, nullptr },
        { "add_user_changed", reinterpret_cast<PyCFunction>(IGameController_add_UserChanged), METH_O, nullptr },
        { "remove_user_changed", reinterpret_cast<PyCFunction>(IGameController_remove_UserChanged), METH_O, nullptr },
        { "_assign_array_", _assign_array_IGameController, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IGameController), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IGameController[] = {
        { "headset", reinterpret_cast<getter>(IGameController_get_Headset), nullptr, nullptr, nullptr },
        { "is_wireless", reinterpret_cast<getter>(IGameController_get_IsWireless), nullptr, nullptr, nullptr },
        { "user", reinterpret_cast<getter>(IGameController_get_User), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IGameController[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_IGameController) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IGameController) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IGameController) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IGameController) },
        { }
    };

    static PyType_Spec type_spec_IGameController = {
        "winrt._winrt_windows_gaming_input.IGameController",
        sizeof(py::wrapper::Windows::Gaming::Input::IGameController),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IGameController};

    struct ImplementsIGameController : py::ImplementsInterfaceT<ImplementsIGameController, winrt::Windows::Gaming::Input::IGameController>
    {
        ImplementsIGameController() = delete;
        ImplementsIGameController(PyObject* py_obj, winrt::impl::inspectable_abi* runtime_class) : py::ImplementsInterfaceT<ImplementsIGameController, winrt::Windows::Gaming::Input::IGameController>(py_obj, runtime_class)
        {
        }

        auto Headset()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "headset")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Gaming::Input::Headset>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto IsWireless()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "is_wireless")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<bool>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto User()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "user")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::System::User>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto HeadsetConnected(winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Gaming::Input::IGameController, winrt::Windows::Gaming::Input::Headset> const& param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "add_headset_connected")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallOneArg(method.get(), py_param0.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::event_token>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto HeadsetConnected(winrt::event_token param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "remove_headset_connected")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallOneArg(method.get(), py_param0.get())};
                if (!return_value)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto HeadsetDisconnected(winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Gaming::Input::IGameController, winrt::Windows::Gaming::Input::Headset> const& param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "add_headset_disconnected")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallOneArg(method.get(), py_param0.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::event_token>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto HeadsetDisconnected(winrt::event_token param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "remove_headset_disconnected")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallOneArg(method.get(), py_param0.get())};
                if (!return_value)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto UserChanged(winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Gaming::Input::IGameController, winrt::Windows::System::UserChangedEventArgs> const& param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "add_user_changed")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallOneArg(method.get(), py_param0.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::event_token>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto UserChanged(winrt::event_token param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "remove_user_changed")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallOneArg(method.get(), py_param0.get())};
                if (!return_value)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }
    };

    static PyObject* _guid_ImplementsIGameController(PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::guid_of<winrt::Windows::Gaming::Input::IGameController>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _make_ImplementsIGameController(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            PyObject* py_obj;
            winrt::impl::inspectable_abi* runtime_class;

            if (!PyArg_ParseTuple(args, "On", &py_obj, &runtime_class))
            {
                return nullptr;
            }

            auto iface{std::make_unique<ImplementsIGameController>(py_obj, runtime_class)};

            return PyLong_FromVoidPtr(iface.release());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef methods_ImplementsIGameController[] = {
        { "_guid_", reinterpret_cast<PyCFunction>(_guid_ImplementsIGameController), METH_NOARGS | METH_STATIC, nullptr },
        { "_make_", reinterpret_cast<PyCFunction>(_make_ImplementsIGameController), METH_VARARGS | METH_STATIC, nullptr },
        { }
    };

    static PyType_Slot type_slots_ImplementsIGameController[] = {
        { Py_tp_methods, reinterpret_cast<void*>(methods_ImplementsIGameController) },
        { }
    };

    static PyType_Spec type_spec_ImplementsIGameController = {
        "winrt._winrt_windows_gaming_input.ImplementsIGameController",
        0,
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_ImplementsIGameController};

    // ----- IGameControllerBatteryInfo interface --------------------

    static PyObject* _new_IGameControllerBatteryInfo(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Gaming::Input::IGameControllerBatteryInfo>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Gaming::Input::IGameControllerBatteryInfo>::type_name);
        return nullptr;
    }

    static void _dealloc_IGameControllerBatteryInfo(py::wrapper::Windows::Gaming::Input::IGameControllerBatteryInfo* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IGameControllerBatteryInfo_TryGetBatteryReport(py::wrapper::Windows::Gaming::Input::IGameControllerBatteryInfo* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Gaming.Input.IGameControllerBatteryInfo", L"TryGetBatteryReport", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.TryGetBatteryReport();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_IGameControllerBatteryInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Gaming::Input::IGameControllerBatteryInfo>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IGameControllerBatteryInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Gaming::Input::IGameControllerBatteryInfo>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IGameControllerBatteryInfo[] = {
        { "try_get_battery_report", reinterpret_cast<PyCFunction>(IGameControllerBatteryInfo_TryGetBatteryReport), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_IGameControllerBatteryInfo, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IGameControllerBatteryInfo), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IGameControllerBatteryInfo[] = {
        { }
    };

    static PyType_Slot _type_slots_IGameControllerBatteryInfo[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_IGameControllerBatteryInfo) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IGameControllerBatteryInfo) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IGameControllerBatteryInfo) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IGameControllerBatteryInfo) },
        { }
    };

    static PyType_Spec type_spec_IGameControllerBatteryInfo = {
        "winrt._winrt_windows_gaming_input.IGameControllerBatteryInfo",
        sizeof(py::wrapper::Windows::Gaming::Input::IGameControllerBatteryInfo),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IGameControllerBatteryInfo};

    struct ImplementsIGameControllerBatteryInfo : py::ImplementsInterfaceT<ImplementsIGameControllerBatteryInfo, winrt::Windows::Gaming::Input::IGameControllerBatteryInfo>
    {
        ImplementsIGameControllerBatteryInfo() = delete;
        ImplementsIGameControllerBatteryInfo(PyObject* py_obj, winrt::impl::inspectable_abi* runtime_class) : py::ImplementsInterfaceT<ImplementsIGameControllerBatteryInfo, winrt::Windows::Gaming::Input::IGameControllerBatteryInfo>(py_obj, runtime_class)
        {
        }

        auto TryGetBatteryReport()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "try_get_battery_report")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallNoArgs(method.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Devices::Power::BatteryReport>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }
    };

    static PyObject* _guid_ImplementsIGameControllerBatteryInfo(PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::guid_of<winrt::Windows::Gaming::Input::IGameControllerBatteryInfo>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _make_ImplementsIGameControllerBatteryInfo(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            PyObject* py_obj;
            winrt::impl::inspectable_abi* runtime_class;

            if (!PyArg_ParseTuple(args, "On", &py_obj, &runtime_class))
            {
                return nullptr;
            }

            auto iface{std::make_unique<ImplementsIGameControllerBatteryInfo>(py_obj, runtime_class)};

            return PyLong_FromVoidPtr(iface.release());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef methods_ImplementsIGameControllerBatteryInfo[] = {
        { "_guid_", reinterpret_cast<PyCFunction>(_guid_ImplementsIGameControllerBatteryInfo), METH_NOARGS | METH_STATIC, nullptr },
        { "_make_", reinterpret_cast<PyCFunction>(_make_ImplementsIGameControllerBatteryInfo), METH_VARARGS | METH_STATIC, nullptr },
        { }
    };

    static PyType_Slot type_slots_ImplementsIGameControllerBatteryInfo[] = {
        { Py_tp_methods, reinterpret_cast<void*>(methods_ImplementsIGameControllerBatteryInfo) },
        { }
    };

    static PyType_Spec type_spec_ImplementsIGameControllerBatteryInfo = {
        "winrt._winrt_windows_gaming_input.ImplementsIGameControllerBatteryInfo",
        0,
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_ImplementsIGameControllerBatteryInfo};

    // ----- ArcadeStickReading struct --------------------

    winrt_struct_wrapper<winrt::Windows::Gaming::Input::ArcadeStickReading>* _new_ArcadeStickReading(PyTypeObject* subclass, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        auto self = reinterpret_cast<winrt_struct_wrapper<winrt::Windows::Gaming::Input::ArcadeStickReading>*>(subclass->tp_alloc(subclass, 0));

        if (!self)
        {
            return nullptr;
        }

        std::construct_at(&self->obj);

        return self;
    }

    int _init_ArcadeStickReading(winrt_struct_wrapper<winrt::Windows::Gaming::Input::ArcadeStickReading>* self, PyObject* args, PyObject* kwds) noexcept
    {
        auto tuple_size = PyTuple_Size(args);

        if ((tuple_size == 0) && (kwds == nullptr))
        {
            self->obj = {};
            return 0;
        }

        uint64_t _Timestamp{};
        uint32_t _Buttons{};

        static const char* kwlist[] = {"timestamp", "buttons", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "KI", const_cast<char**>(kwlist), &_Timestamp, &_Buttons))
        {
            return -1;
        }

        try
        {
            self->obj.Timestamp = _Timestamp;
            self->obj.Buttons = static_cast<winrt::Windows::Gaming::Input::ArcadeStickButtons>(_Buttons);

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static void _dealloc_ArcadeStickReading(py::wrapper::Windows::Gaming::Input::ArcadeStickReading* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_ArcadeStickReading(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Gaming::Input::ArcadeStickReading>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyMethodDef _methods_ArcadeStickReading[] = {
        { "_assign_array_", _assign_array_ArcadeStickReading, METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyObject* ArcadeStickReading_get_Timestamp(py::wrapper::Windows::Gaming::Input::ArcadeStickReading* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Timestamp);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ArcadeStickReading_set_Timestamp(py::wrapper::Windows::Gaming::Input::ArcadeStickReading* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.Timestamp = py::convert_to<uint64_t>(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ArcadeStickReading_get_Buttons(py::wrapper::Windows::Gaming::Input::ArcadeStickReading* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Buttons);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ArcadeStickReading_set_Buttons(py::wrapper::Windows::Gaming::Input::ArcadeStickReading* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.Buttons = py::convert_to<winrt::Windows::Gaming::Input::ArcadeStickButtons>(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyGetSetDef _getset_ArcadeStickReading[] = {
        { "timestamp", reinterpret_cast<getter>(ArcadeStickReading_get_Timestamp), reinterpret_cast<setter>(ArcadeStickReading_set_Timestamp), nullptr, nullptr },
        { "buttons", reinterpret_cast<getter>(ArcadeStickReading_get_Buttons), reinterpret_cast<setter>(ArcadeStickReading_set_Buttons), nullptr, nullptr },
        { }
    };

    static PyObject* _richcompare_ArcadeStickReading(py::wrapper::Windows::Gaming::Input::ArcadeStickReading* self, PyObject* other, int op) noexcept
    {
        try
        {
            auto _other = py::convert_to<winrt::Windows::Gaming::Input::ArcadeStickReading>(other);

            if (op == Py_EQ)
            {
                if (self->obj == _other)
                {
                    Py_RETURN_TRUE;
                }

                Py_RETURN_FALSE;
            }

            if (op == Py_NE)
            {
                if (self->obj != _other)
                {
                    Py_RETURN_TRUE;
                }

                Py_RETURN_FALSE;
            }

            Py_RETURN_NOTIMPLEMENTED;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _repr_ArcadeStickReading(PyObject* self) noexcept
    {
        py::pyobj_handle Timestamp{PyObject_GetAttrString(self, "timestamp")};
        if (!Timestamp)
        {
            return nullptr;
        }

        py::pyobj_handle Buttons{PyObject_GetAttrString(self, "buttons")};
        if (!Buttons)
        {
            return nullptr;
        }

        return PyUnicode_FromFormat("ArcadeStickReading(timestamp=%R, buttons=%R)", Timestamp.get(), Buttons.get());
    }

    static PyType_Slot _type_slots_ArcadeStickReading[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ArcadeStickReading) },
        { Py_tp_init, reinterpret_cast<void*>(_init_ArcadeStickReading) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ArcadeStickReading) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ArcadeStickReading) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ArcadeStickReading) },
        { Py_tp_richcompare, reinterpret_cast<void*>(_richcompare_ArcadeStickReading) },
        { Py_tp_repr, reinterpret_cast<void*>(_repr_ArcadeStickReading) },
        { }
    };

    static PyType_Spec type_spec_ArcadeStickReading = {
        "winrt._winrt_windows_gaming_input.ArcadeStickReading",
        sizeof(py::wrapper::Windows::Gaming::Input::ArcadeStickReading),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ArcadeStickReading};

    // ----- FlightStickReading struct --------------------

    winrt_struct_wrapper<winrt::Windows::Gaming::Input::FlightStickReading>* _new_FlightStickReading(PyTypeObject* subclass, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        auto self = reinterpret_cast<winrt_struct_wrapper<winrt::Windows::Gaming::Input::FlightStickReading>*>(subclass->tp_alloc(subclass, 0));

        if (!self)
        {
            return nullptr;
        }

        std::construct_at(&self->obj);

        return self;
    }

    int _init_FlightStickReading(winrt_struct_wrapper<winrt::Windows::Gaming::Input::FlightStickReading>* self, PyObject* args, PyObject* kwds) noexcept
    {
        auto tuple_size = PyTuple_Size(args);

        if ((tuple_size == 0) && (kwds == nullptr))
        {
            self->obj = {};
            return 0;
        }

        uint64_t _Timestamp{};
        uint32_t _Buttons{};
        int32_t _HatSwitch{};
        double _Roll{};
        double _Pitch{};
        double _Yaw{};
        double _Throttle{};

        static const char* kwlist[] = {"timestamp", "buttons", "hat_switch", "roll", "pitch", "yaw", "throttle", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "KIidddd", const_cast<char**>(kwlist), &_Timestamp, &_Buttons, &_HatSwitch, &_Roll, &_Pitch, &_Yaw, &_Throttle))
        {
            return -1;
        }

        try
        {
            self->obj.Timestamp = _Timestamp;
            self->obj.Buttons = static_cast<winrt::Windows::Gaming::Input::FlightStickButtons>(_Buttons);
            self->obj.HatSwitch = static_cast<winrt::Windows::Gaming::Input::GameControllerSwitchPosition>(_HatSwitch);
            self->obj.Roll = _Roll;
            self->obj.Pitch = _Pitch;
            self->obj.Yaw = _Yaw;
            self->obj.Throttle = _Throttle;

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static void _dealloc_FlightStickReading(py::wrapper::Windows::Gaming::Input::FlightStickReading* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_FlightStickReading(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Gaming::Input::FlightStickReading>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyMethodDef _methods_FlightStickReading[] = {
        { "_assign_array_", _assign_array_FlightStickReading, METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyObject* FlightStickReading_get_Timestamp(py::wrapper::Windows::Gaming::Input::FlightStickReading* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Timestamp);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FlightStickReading_set_Timestamp(py::wrapper::Windows::Gaming::Input::FlightStickReading* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.Timestamp = py::convert_to<uint64_t>(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* FlightStickReading_get_Buttons(py::wrapper::Windows::Gaming::Input::FlightStickReading* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Buttons);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FlightStickReading_set_Buttons(py::wrapper::Windows::Gaming::Input::FlightStickReading* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.Buttons = py::convert_to<winrt::Windows::Gaming::Input::FlightStickButtons>(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* FlightStickReading_get_HatSwitch(py::wrapper::Windows::Gaming::Input::FlightStickReading* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.HatSwitch);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FlightStickReading_set_HatSwitch(py::wrapper::Windows::Gaming::Input::FlightStickReading* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.HatSwitch = py::convert_to<winrt::Windows::Gaming::Input::GameControllerSwitchPosition>(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* FlightStickReading_get_Roll(py::wrapper::Windows::Gaming::Input::FlightStickReading* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Roll);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FlightStickReading_set_Roll(py::wrapper::Windows::Gaming::Input::FlightStickReading* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.Roll = py::convert_to<double>(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* FlightStickReading_get_Pitch(py::wrapper::Windows::Gaming::Input::FlightStickReading* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Pitch);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FlightStickReading_set_Pitch(py::wrapper::Windows::Gaming::Input::FlightStickReading* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.Pitch = py::convert_to<double>(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* FlightStickReading_get_Yaw(py::wrapper::Windows::Gaming::Input::FlightStickReading* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Yaw);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FlightStickReading_set_Yaw(py::wrapper::Windows::Gaming::Input::FlightStickReading* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.Yaw = py::convert_to<double>(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* FlightStickReading_get_Throttle(py::wrapper::Windows::Gaming::Input::FlightStickReading* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Throttle);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FlightStickReading_set_Throttle(py::wrapper::Windows::Gaming::Input::FlightStickReading* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.Throttle = py::convert_to<double>(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyGetSetDef _getset_FlightStickReading[] = {
        { "timestamp", reinterpret_cast<getter>(FlightStickReading_get_Timestamp), reinterpret_cast<setter>(FlightStickReading_set_Timestamp), nullptr, nullptr },
        { "buttons", reinterpret_cast<getter>(FlightStickReading_get_Buttons), reinterpret_cast<setter>(FlightStickReading_set_Buttons), nullptr, nullptr },
        { "hat_switch", reinterpret_cast<getter>(FlightStickReading_get_HatSwitch), reinterpret_cast<setter>(FlightStickReading_set_HatSwitch), nullptr, nullptr },
        { "roll", reinterpret_cast<getter>(FlightStickReading_get_Roll), reinterpret_cast<setter>(FlightStickReading_set_Roll), nullptr, nullptr },
        { "pitch", reinterpret_cast<getter>(FlightStickReading_get_Pitch), reinterpret_cast<setter>(FlightStickReading_set_Pitch), nullptr, nullptr },
        { "yaw", reinterpret_cast<getter>(FlightStickReading_get_Yaw), reinterpret_cast<setter>(FlightStickReading_set_Yaw), nullptr, nullptr },
        { "throttle", reinterpret_cast<getter>(FlightStickReading_get_Throttle), reinterpret_cast<setter>(FlightStickReading_set_Throttle), nullptr, nullptr },
        { }
    };

    static PyObject* _richcompare_FlightStickReading(py::wrapper::Windows::Gaming::Input::FlightStickReading* self, PyObject* other, int op) noexcept
    {
        try
        {
            auto _other = py::convert_to<winrt::Windows::Gaming::Input::FlightStickReading>(other);

            if (op == Py_EQ)
            {
                if (self->obj == _other)
                {
                    Py_RETURN_TRUE;
                }

                Py_RETURN_FALSE;
            }

            if (op == Py_NE)
            {
                if (self->obj != _other)
                {
                    Py_RETURN_TRUE;
                }

                Py_RETURN_FALSE;
            }

            Py_RETURN_NOTIMPLEMENTED;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _repr_FlightStickReading(PyObject* self) noexcept
    {
        py::pyobj_handle Timestamp{PyObject_GetAttrString(self, "timestamp")};
        if (!Timestamp)
        {
            return nullptr;
        }

        py::pyobj_handle Buttons{PyObject_GetAttrString(self, "buttons")};
        if (!Buttons)
        {
            return nullptr;
        }

        py::pyobj_handle HatSwitch{PyObject_GetAttrString(self, "hat_switch")};
        if (!HatSwitch)
        {
            return nullptr;
        }

        py::pyobj_handle Roll{PyObject_GetAttrString(self, "roll")};
        if (!Roll)
        {
            return nullptr;
        }

        py::pyobj_handle Pitch{PyObject_GetAttrString(self, "pitch")};
        if (!Pitch)
        {
            return nullptr;
        }

        py::pyobj_handle Yaw{PyObject_GetAttrString(self, "yaw")};
        if (!Yaw)
        {
            return nullptr;
        }

        py::pyobj_handle Throttle{PyObject_GetAttrString(self, "throttle")};
        if (!Throttle)
        {
            return nullptr;
        }

        return PyUnicode_FromFormat("FlightStickReading(timestamp=%R, buttons=%R, hat_switch=%R, roll=%R, pitch=%R, yaw=%R, throttle=%R)", Timestamp.get(), Buttons.get(), HatSwitch.get(), Roll.get(), Pitch.get(), Yaw.get(), Throttle.get());
    }

    static PyType_Slot _type_slots_FlightStickReading[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_FlightStickReading) },
        { Py_tp_init, reinterpret_cast<void*>(_init_FlightStickReading) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_FlightStickReading) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_FlightStickReading) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_FlightStickReading) },
        { Py_tp_richcompare, reinterpret_cast<void*>(_richcompare_FlightStickReading) },
        { Py_tp_repr, reinterpret_cast<void*>(_repr_FlightStickReading) },
        { }
    };

    static PyType_Spec type_spec_FlightStickReading = {
        "winrt._winrt_windows_gaming_input.FlightStickReading",
        sizeof(py::wrapper::Windows::Gaming::Input::FlightStickReading),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_FlightStickReading};

    // ----- GamepadReading struct --------------------

    winrt_struct_wrapper<winrt::Windows::Gaming::Input::GamepadReading>* _new_GamepadReading(PyTypeObject* subclass, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        auto self = reinterpret_cast<winrt_struct_wrapper<winrt::Windows::Gaming::Input::GamepadReading>*>(subclass->tp_alloc(subclass, 0));

        if (!self)
        {
            return nullptr;
        }

        std::construct_at(&self->obj);

        return self;
    }

    int _init_GamepadReading(winrt_struct_wrapper<winrt::Windows::Gaming::Input::GamepadReading>* self, PyObject* args, PyObject* kwds) noexcept
    {
        auto tuple_size = PyTuple_Size(args);

        if ((tuple_size == 0) && (kwds == nullptr))
        {
            self->obj = {};
            return 0;
        }

        uint64_t _Timestamp{};
        uint32_t _Buttons{};
        double _LeftTrigger{};
        double _RightTrigger{};
        double _LeftThumbstickX{};
        double _LeftThumbstickY{};
        double _RightThumbstickX{};
        double _RightThumbstickY{};

        static const char* kwlist[] = {"timestamp", "buttons", "left_trigger", "right_trigger", "left_thumbstick_x", "left_thumbstick_y", "right_thumbstick_x", "right_thumbstick_y", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "KIdddddd", const_cast<char**>(kwlist), &_Timestamp, &_Buttons, &_LeftTrigger, &_RightTrigger, &_LeftThumbstickX, &_LeftThumbstickY, &_RightThumbstickX, &_RightThumbstickY))
        {
            return -1;
        }

        try
        {
            self->obj.Timestamp = _Timestamp;
            self->obj.Buttons = static_cast<winrt::Windows::Gaming::Input::GamepadButtons>(_Buttons);
            self->obj.LeftTrigger = _LeftTrigger;
            self->obj.RightTrigger = _RightTrigger;
            self->obj.LeftThumbstickX = _LeftThumbstickX;
            self->obj.LeftThumbstickY = _LeftThumbstickY;
            self->obj.RightThumbstickX = _RightThumbstickX;
            self->obj.RightThumbstickY = _RightThumbstickY;

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static void _dealloc_GamepadReading(py::wrapper::Windows::Gaming::Input::GamepadReading* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_GamepadReading(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Gaming::Input::GamepadReading>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyMethodDef _methods_GamepadReading[] = {
        { "_assign_array_", _assign_array_GamepadReading, METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyObject* GamepadReading_get_Timestamp(py::wrapper::Windows::Gaming::Input::GamepadReading* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Timestamp);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GamepadReading_set_Timestamp(py::wrapper::Windows::Gaming::Input::GamepadReading* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.Timestamp = py::convert_to<uint64_t>(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* GamepadReading_get_Buttons(py::wrapper::Windows::Gaming::Input::GamepadReading* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Buttons);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GamepadReading_set_Buttons(py::wrapper::Windows::Gaming::Input::GamepadReading* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.Buttons = py::convert_to<winrt::Windows::Gaming::Input::GamepadButtons>(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* GamepadReading_get_LeftTrigger(py::wrapper::Windows::Gaming::Input::GamepadReading* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.LeftTrigger);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GamepadReading_set_LeftTrigger(py::wrapper::Windows::Gaming::Input::GamepadReading* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.LeftTrigger = py::convert_to<double>(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* GamepadReading_get_RightTrigger(py::wrapper::Windows::Gaming::Input::GamepadReading* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RightTrigger);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GamepadReading_set_RightTrigger(py::wrapper::Windows::Gaming::Input::GamepadReading* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.RightTrigger = py::convert_to<double>(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* GamepadReading_get_LeftThumbstickX(py::wrapper::Windows::Gaming::Input::GamepadReading* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.LeftThumbstickX);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GamepadReading_set_LeftThumbstickX(py::wrapper::Windows::Gaming::Input::GamepadReading* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.LeftThumbstickX = py::convert_to<double>(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* GamepadReading_get_LeftThumbstickY(py::wrapper::Windows::Gaming::Input::GamepadReading* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.LeftThumbstickY);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GamepadReading_set_LeftThumbstickY(py::wrapper::Windows::Gaming::Input::GamepadReading* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.LeftThumbstickY = py::convert_to<double>(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* GamepadReading_get_RightThumbstickX(py::wrapper::Windows::Gaming::Input::GamepadReading* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RightThumbstickX);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GamepadReading_set_RightThumbstickX(py::wrapper::Windows::Gaming::Input::GamepadReading* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.RightThumbstickX = py::convert_to<double>(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* GamepadReading_get_RightThumbstickY(py::wrapper::Windows::Gaming::Input::GamepadReading* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RightThumbstickY);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GamepadReading_set_RightThumbstickY(py::wrapper::Windows::Gaming::Input::GamepadReading* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.RightThumbstickY = py::convert_to<double>(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyGetSetDef _getset_GamepadReading[] = {
        { "timestamp", reinterpret_cast<getter>(GamepadReading_get_Timestamp), reinterpret_cast<setter>(GamepadReading_set_Timestamp), nullptr, nullptr },
        { "buttons", reinterpret_cast<getter>(GamepadReading_get_Buttons), reinterpret_cast<setter>(GamepadReading_set_Buttons), nullptr, nullptr },
        { "left_trigger", reinterpret_cast<getter>(GamepadReading_get_LeftTrigger), reinterpret_cast<setter>(GamepadReading_set_LeftTrigger), nullptr, nullptr },
        { "right_trigger", reinterpret_cast<getter>(GamepadReading_get_RightTrigger), reinterpret_cast<setter>(GamepadReading_set_RightTrigger), nullptr, nullptr },
        { "left_thumbstick_x", reinterpret_cast<getter>(GamepadReading_get_LeftThumbstickX), reinterpret_cast<setter>(GamepadReading_set_LeftThumbstickX), nullptr, nullptr },
        { "left_thumbstick_y", reinterpret_cast<getter>(GamepadReading_get_LeftThumbstickY), reinterpret_cast<setter>(GamepadReading_set_LeftThumbstickY), nullptr, nullptr },
        { "right_thumbstick_x", reinterpret_cast<getter>(GamepadReading_get_RightThumbstickX), reinterpret_cast<setter>(GamepadReading_set_RightThumbstickX), nullptr, nullptr },
        { "right_thumbstick_y", reinterpret_cast<getter>(GamepadReading_get_RightThumbstickY), reinterpret_cast<setter>(GamepadReading_set_RightThumbstickY), nullptr, nullptr },
        { }
    };

    static PyObject* _richcompare_GamepadReading(py::wrapper::Windows::Gaming::Input::GamepadReading* self, PyObject* other, int op) noexcept
    {
        try
        {
            auto _other = py::convert_to<winrt::Windows::Gaming::Input::GamepadReading>(other);

            if (op == Py_EQ)
            {
                if (self->obj == _other)
                {
                    Py_RETURN_TRUE;
                }

                Py_RETURN_FALSE;
            }

            if (op == Py_NE)
            {
                if (self->obj != _other)
                {
                    Py_RETURN_TRUE;
                }

                Py_RETURN_FALSE;
            }

            Py_RETURN_NOTIMPLEMENTED;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _repr_GamepadReading(PyObject* self) noexcept
    {
        py::pyobj_handle Timestamp{PyObject_GetAttrString(self, "timestamp")};
        if (!Timestamp)
        {
            return nullptr;
        }

        py::pyobj_handle Buttons{PyObject_GetAttrString(self, "buttons")};
        if (!Buttons)
        {
            return nullptr;
        }

        py::pyobj_handle LeftTrigger{PyObject_GetAttrString(self, "left_trigger")};
        if (!LeftTrigger)
        {
            return nullptr;
        }

        py::pyobj_handle RightTrigger{PyObject_GetAttrString(self, "right_trigger")};
        if (!RightTrigger)
        {
            return nullptr;
        }

        py::pyobj_handle LeftThumbstickX{PyObject_GetAttrString(self, "left_thumbstick_x")};
        if (!LeftThumbstickX)
        {
            return nullptr;
        }

        py::pyobj_handle LeftThumbstickY{PyObject_GetAttrString(self, "left_thumbstick_y")};
        if (!LeftThumbstickY)
        {
            return nullptr;
        }

        py::pyobj_handle RightThumbstickX{PyObject_GetAttrString(self, "right_thumbstick_x")};
        if (!RightThumbstickX)
        {
            return nullptr;
        }

        py::pyobj_handle RightThumbstickY{PyObject_GetAttrString(self, "right_thumbstick_y")};
        if (!RightThumbstickY)
        {
            return nullptr;
        }

        return PyUnicode_FromFormat("GamepadReading(timestamp=%R, buttons=%R, left_trigger=%R, right_trigger=%R, left_thumbstick_x=%R, left_thumbstick_y=%R, right_thumbstick_x=%R, right_thumbstick_y=%R)", Timestamp.get(), Buttons.get(), LeftTrigger.get(), RightTrigger.get(), LeftThumbstickX.get(), LeftThumbstickY.get(), RightThumbstickX.get(), RightThumbstickY.get());
    }

    static PyType_Slot _type_slots_GamepadReading[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_GamepadReading) },
        { Py_tp_init, reinterpret_cast<void*>(_init_GamepadReading) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_GamepadReading) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_GamepadReading) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_GamepadReading) },
        { Py_tp_richcompare, reinterpret_cast<void*>(_richcompare_GamepadReading) },
        { Py_tp_repr, reinterpret_cast<void*>(_repr_GamepadReading) },
        { }
    };

    static PyType_Spec type_spec_GamepadReading = {
        "winrt._winrt_windows_gaming_input.GamepadReading",
        sizeof(py::wrapper::Windows::Gaming::Input::GamepadReading),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_GamepadReading};

    // ----- GamepadVibration struct --------------------

    winrt_struct_wrapper<winrt::Windows::Gaming::Input::GamepadVibration>* _new_GamepadVibration(PyTypeObject* subclass, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        auto self = reinterpret_cast<winrt_struct_wrapper<winrt::Windows::Gaming::Input::GamepadVibration>*>(subclass->tp_alloc(subclass, 0));

        if (!self)
        {
            return nullptr;
        }

        std::construct_at(&self->obj);

        return self;
    }

    int _init_GamepadVibration(winrt_struct_wrapper<winrt::Windows::Gaming::Input::GamepadVibration>* self, PyObject* args, PyObject* kwds) noexcept
    {
        auto tuple_size = PyTuple_Size(args);

        if ((tuple_size == 0) && (kwds == nullptr))
        {
            self->obj = {};
            return 0;
        }

        double _LeftMotor{};
        double _RightMotor{};
        double _LeftTrigger{};
        double _RightTrigger{};

        static const char* kwlist[] = {"left_motor", "right_motor", "left_trigger", "right_trigger", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "dddd", const_cast<char**>(kwlist), &_LeftMotor, &_RightMotor, &_LeftTrigger, &_RightTrigger))
        {
            return -1;
        }

        try
        {
            self->obj.LeftMotor = _LeftMotor;
            self->obj.RightMotor = _RightMotor;
            self->obj.LeftTrigger = _LeftTrigger;
            self->obj.RightTrigger = _RightTrigger;

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static void _dealloc_GamepadVibration(py::wrapper::Windows::Gaming::Input::GamepadVibration* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_GamepadVibration(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Gaming::Input::GamepadVibration>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyMethodDef _methods_GamepadVibration[] = {
        { "_assign_array_", _assign_array_GamepadVibration, METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyObject* GamepadVibration_get_LeftMotor(py::wrapper::Windows::Gaming::Input::GamepadVibration* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.LeftMotor);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GamepadVibration_set_LeftMotor(py::wrapper::Windows::Gaming::Input::GamepadVibration* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.LeftMotor = py::convert_to<double>(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* GamepadVibration_get_RightMotor(py::wrapper::Windows::Gaming::Input::GamepadVibration* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RightMotor);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GamepadVibration_set_RightMotor(py::wrapper::Windows::Gaming::Input::GamepadVibration* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.RightMotor = py::convert_to<double>(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* GamepadVibration_get_LeftTrigger(py::wrapper::Windows::Gaming::Input::GamepadVibration* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.LeftTrigger);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GamepadVibration_set_LeftTrigger(py::wrapper::Windows::Gaming::Input::GamepadVibration* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.LeftTrigger = py::convert_to<double>(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* GamepadVibration_get_RightTrigger(py::wrapper::Windows::Gaming::Input::GamepadVibration* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RightTrigger);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GamepadVibration_set_RightTrigger(py::wrapper::Windows::Gaming::Input::GamepadVibration* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.RightTrigger = py::convert_to<double>(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyGetSetDef _getset_GamepadVibration[] = {
        { "left_motor", reinterpret_cast<getter>(GamepadVibration_get_LeftMotor), reinterpret_cast<setter>(GamepadVibration_set_LeftMotor), nullptr, nullptr },
        { "right_motor", reinterpret_cast<getter>(GamepadVibration_get_RightMotor), reinterpret_cast<setter>(GamepadVibration_set_RightMotor), nullptr, nullptr },
        { "left_trigger", reinterpret_cast<getter>(GamepadVibration_get_LeftTrigger), reinterpret_cast<setter>(GamepadVibration_set_LeftTrigger), nullptr, nullptr },
        { "right_trigger", reinterpret_cast<getter>(GamepadVibration_get_RightTrigger), reinterpret_cast<setter>(GamepadVibration_set_RightTrigger), nullptr, nullptr },
        { }
    };

    static PyObject* _richcompare_GamepadVibration(py::wrapper::Windows::Gaming::Input::GamepadVibration* self, PyObject* other, int op) noexcept
    {
        try
        {
            auto _other = py::convert_to<winrt::Windows::Gaming::Input::GamepadVibration>(other);

            if (op == Py_EQ)
            {
                if (self->obj == _other)
                {
                    Py_RETURN_TRUE;
                }

                Py_RETURN_FALSE;
            }

            if (op == Py_NE)
            {
                if (self->obj != _other)
                {
                    Py_RETURN_TRUE;
                }

                Py_RETURN_FALSE;
            }

            Py_RETURN_NOTIMPLEMENTED;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _repr_GamepadVibration(PyObject* self) noexcept
    {
        py::pyobj_handle LeftMotor{PyObject_GetAttrString(self, "left_motor")};
        if (!LeftMotor)
        {
            return nullptr;
        }

        py::pyobj_handle RightMotor{PyObject_GetAttrString(self, "right_motor")};
        if (!RightMotor)
        {
            return nullptr;
        }

        py::pyobj_handle LeftTrigger{PyObject_GetAttrString(self, "left_trigger")};
        if (!LeftTrigger)
        {
            return nullptr;
        }

        py::pyobj_handle RightTrigger{PyObject_GetAttrString(self, "right_trigger")};
        if (!RightTrigger)
        {
            return nullptr;
        }

        return PyUnicode_FromFormat("GamepadVibration(left_motor=%R, right_motor=%R, left_trigger=%R, right_trigger=%R)", LeftMotor.get(), RightMotor.get(), LeftTrigger.get(), RightTrigger.get());
    }

    static PyType_Slot _type_slots_GamepadVibration[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_GamepadVibration) },
        { Py_tp_init, reinterpret_cast<void*>(_init_GamepadVibration) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_GamepadVibration) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_GamepadVibration) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_GamepadVibration) },
        { Py_tp_richcompare, reinterpret_cast<void*>(_richcompare_GamepadVibration) },
        { Py_tp_repr, reinterpret_cast<void*>(_repr_GamepadVibration) },
        { }
    };

    static PyType_Spec type_spec_GamepadVibration = {
        "winrt._winrt_windows_gaming_input.GamepadVibration",
        sizeof(py::wrapper::Windows::Gaming::Input::GamepadVibration),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_GamepadVibration};

    // ----- RacingWheelReading struct --------------------

    winrt_struct_wrapper<winrt::Windows::Gaming::Input::RacingWheelReading>* _new_RacingWheelReading(PyTypeObject* subclass, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        auto self = reinterpret_cast<winrt_struct_wrapper<winrt::Windows::Gaming::Input::RacingWheelReading>*>(subclass->tp_alloc(subclass, 0));

        if (!self)
        {
            return nullptr;
        }

        std::construct_at(&self->obj);

        return self;
    }

    int _init_RacingWheelReading(winrt_struct_wrapper<winrt::Windows::Gaming::Input::RacingWheelReading>* self, PyObject* args, PyObject* kwds) noexcept
    {
        auto tuple_size = PyTuple_Size(args);

        if ((tuple_size == 0) && (kwds == nullptr))
        {
            self->obj = {};
            return 0;
        }

        uint64_t _Timestamp{};
        uint32_t _Buttons{};
        int32_t _PatternShifterGear{};
        double _Wheel{};
        double _Throttle{};
        double _Brake{};
        double _Clutch{};
        double _Handbrake{};

        static const char* kwlist[] = {"timestamp", "buttons", "pattern_shifter_gear", "wheel", "throttle", "brake", "clutch", "handbrake", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "KIiddddd", const_cast<char**>(kwlist), &_Timestamp, &_Buttons, &_PatternShifterGear, &_Wheel, &_Throttle, &_Brake, &_Clutch, &_Handbrake))
        {
            return -1;
        }

        try
        {
            self->obj.Timestamp = _Timestamp;
            self->obj.Buttons = static_cast<winrt::Windows::Gaming::Input::RacingWheelButtons>(_Buttons);
            self->obj.PatternShifterGear = _PatternShifterGear;
            self->obj.Wheel = _Wheel;
            self->obj.Throttle = _Throttle;
            self->obj.Brake = _Brake;
            self->obj.Clutch = _Clutch;
            self->obj.Handbrake = _Handbrake;

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static void _dealloc_RacingWheelReading(py::wrapper::Windows::Gaming::Input::RacingWheelReading* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_RacingWheelReading(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Gaming::Input::RacingWheelReading>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyMethodDef _methods_RacingWheelReading[] = {
        { "_assign_array_", _assign_array_RacingWheelReading, METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyObject* RacingWheelReading_get_Timestamp(py::wrapper::Windows::Gaming::Input::RacingWheelReading* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Timestamp);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RacingWheelReading_set_Timestamp(py::wrapper::Windows::Gaming::Input::RacingWheelReading* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.Timestamp = py::convert_to<uint64_t>(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* RacingWheelReading_get_Buttons(py::wrapper::Windows::Gaming::Input::RacingWheelReading* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Buttons);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RacingWheelReading_set_Buttons(py::wrapper::Windows::Gaming::Input::RacingWheelReading* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.Buttons = py::convert_to<winrt::Windows::Gaming::Input::RacingWheelButtons>(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* RacingWheelReading_get_PatternShifterGear(py::wrapper::Windows::Gaming::Input::RacingWheelReading* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PatternShifterGear);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RacingWheelReading_set_PatternShifterGear(py::wrapper::Windows::Gaming::Input::RacingWheelReading* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.PatternShifterGear = py::convert_to<int32_t>(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* RacingWheelReading_get_Wheel(py::wrapper::Windows::Gaming::Input::RacingWheelReading* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Wheel);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RacingWheelReading_set_Wheel(py::wrapper::Windows::Gaming::Input::RacingWheelReading* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.Wheel = py::convert_to<double>(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* RacingWheelReading_get_Throttle(py::wrapper::Windows::Gaming::Input::RacingWheelReading* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Throttle);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RacingWheelReading_set_Throttle(py::wrapper::Windows::Gaming::Input::RacingWheelReading* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.Throttle = py::convert_to<double>(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* RacingWheelReading_get_Brake(py::wrapper::Windows::Gaming::Input::RacingWheelReading* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Brake);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RacingWheelReading_set_Brake(py::wrapper::Windows::Gaming::Input::RacingWheelReading* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.Brake = py::convert_to<double>(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* RacingWheelReading_get_Clutch(py::wrapper::Windows::Gaming::Input::RacingWheelReading* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Clutch);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RacingWheelReading_set_Clutch(py::wrapper::Windows::Gaming::Input::RacingWheelReading* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.Clutch = py::convert_to<double>(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* RacingWheelReading_get_Handbrake(py::wrapper::Windows::Gaming::Input::RacingWheelReading* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Handbrake);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RacingWheelReading_set_Handbrake(py::wrapper::Windows::Gaming::Input::RacingWheelReading* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.Handbrake = py::convert_to<double>(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyGetSetDef _getset_RacingWheelReading[] = {
        { "timestamp", reinterpret_cast<getter>(RacingWheelReading_get_Timestamp), reinterpret_cast<setter>(RacingWheelReading_set_Timestamp), nullptr, nullptr },
        { "buttons", reinterpret_cast<getter>(RacingWheelReading_get_Buttons), reinterpret_cast<setter>(RacingWheelReading_set_Buttons), nullptr, nullptr },
        { "pattern_shifter_gear", reinterpret_cast<getter>(RacingWheelReading_get_PatternShifterGear), reinterpret_cast<setter>(RacingWheelReading_set_PatternShifterGear), nullptr, nullptr },
        { "wheel", reinterpret_cast<getter>(RacingWheelReading_get_Wheel), reinterpret_cast<setter>(RacingWheelReading_set_Wheel), nullptr, nullptr },
        { "throttle", reinterpret_cast<getter>(RacingWheelReading_get_Throttle), reinterpret_cast<setter>(RacingWheelReading_set_Throttle), nullptr, nullptr },
        { "brake", reinterpret_cast<getter>(RacingWheelReading_get_Brake), reinterpret_cast<setter>(RacingWheelReading_set_Brake), nullptr, nullptr },
        { "clutch", reinterpret_cast<getter>(RacingWheelReading_get_Clutch), reinterpret_cast<setter>(RacingWheelReading_set_Clutch), nullptr, nullptr },
        { "handbrake", reinterpret_cast<getter>(RacingWheelReading_get_Handbrake), reinterpret_cast<setter>(RacingWheelReading_set_Handbrake), nullptr, nullptr },
        { }
    };

    static PyObject* _richcompare_RacingWheelReading(py::wrapper::Windows::Gaming::Input::RacingWheelReading* self, PyObject* other, int op) noexcept
    {
        try
        {
            auto _other = py::convert_to<winrt::Windows::Gaming::Input::RacingWheelReading>(other);

            if (op == Py_EQ)
            {
                if (self->obj == _other)
                {
                    Py_RETURN_TRUE;
                }

                Py_RETURN_FALSE;
            }

            if (op == Py_NE)
            {
                if (self->obj != _other)
                {
                    Py_RETURN_TRUE;
                }

                Py_RETURN_FALSE;
            }

            Py_RETURN_NOTIMPLEMENTED;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _repr_RacingWheelReading(PyObject* self) noexcept
    {
        py::pyobj_handle Timestamp{PyObject_GetAttrString(self, "timestamp")};
        if (!Timestamp)
        {
            return nullptr;
        }

        py::pyobj_handle Buttons{PyObject_GetAttrString(self, "buttons")};
        if (!Buttons)
        {
            return nullptr;
        }

        py::pyobj_handle PatternShifterGear{PyObject_GetAttrString(self, "pattern_shifter_gear")};
        if (!PatternShifterGear)
        {
            return nullptr;
        }

        py::pyobj_handle Wheel{PyObject_GetAttrString(self, "wheel")};
        if (!Wheel)
        {
            return nullptr;
        }

        py::pyobj_handle Throttle{PyObject_GetAttrString(self, "throttle")};
        if (!Throttle)
        {
            return nullptr;
        }

        py::pyobj_handle Brake{PyObject_GetAttrString(self, "brake")};
        if (!Brake)
        {
            return nullptr;
        }

        py::pyobj_handle Clutch{PyObject_GetAttrString(self, "clutch")};
        if (!Clutch)
        {
            return nullptr;
        }

        py::pyobj_handle Handbrake{PyObject_GetAttrString(self, "handbrake")};
        if (!Handbrake)
        {
            return nullptr;
        }

        return PyUnicode_FromFormat("RacingWheelReading(timestamp=%R, buttons=%R, pattern_shifter_gear=%R, wheel=%R, throttle=%R, brake=%R, clutch=%R, handbrake=%R)", Timestamp.get(), Buttons.get(), PatternShifterGear.get(), Wheel.get(), Throttle.get(), Brake.get(), Clutch.get(), Handbrake.get());
    }

    static PyType_Slot _type_slots_RacingWheelReading[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_RacingWheelReading) },
        { Py_tp_init, reinterpret_cast<void*>(_init_RacingWheelReading) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_RacingWheelReading) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_RacingWheelReading) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_RacingWheelReading) },
        { Py_tp_richcompare, reinterpret_cast<void*>(_richcompare_RacingWheelReading) },
        { Py_tp_repr, reinterpret_cast<void*>(_repr_RacingWheelReading) },
        { }
    };

    static PyType_Spec type_spec_RacingWheelReading = {
        "winrt._winrt_windows_gaming_input.RacingWheelReading",
        sizeof(py::wrapper::Windows::Gaming::Input::RacingWheelReading),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RacingWheelReading};

    // ----- UINavigationReading struct --------------------

    winrt_struct_wrapper<winrt::Windows::Gaming::Input::UINavigationReading>* _new_UINavigationReading(PyTypeObject* subclass, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        auto self = reinterpret_cast<winrt_struct_wrapper<winrt::Windows::Gaming::Input::UINavigationReading>*>(subclass->tp_alloc(subclass, 0));

        if (!self)
        {
            return nullptr;
        }

        std::construct_at(&self->obj);

        return self;
    }

    int _init_UINavigationReading(winrt_struct_wrapper<winrt::Windows::Gaming::Input::UINavigationReading>* self, PyObject* args, PyObject* kwds) noexcept
    {
        auto tuple_size = PyTuple_Size(args);

        if ((tuple_size == 0) && (kwds == nullptr))
        {
            self->obj = {};
            return 0;
        }

        uint64_t _Timestamp{};
        uint32_t _RequiredButtons{};
        uint32_t _OptionalButtons{};

        static const char* kwlist[] = {"timestamp", "required_buttons", "optional_buttons", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "KII", const_cast<char**>(kwlist), &_Timestamp, &_RequiredButtons, &_OptionalButtons))
        {
            return -1;
        }

        try
        {
            self->obj.Timestamp = _Timestamp;
            self->obj.RequiredButtons = static_cast<winrt::Windows::Gaming::Input::RequiredUINavigationButtons>(_RequiredButtons);
            self->obj.OptionalButtons = static_cast<winrt::Windows::Gaming::Input::OptionalUINavigationButtons>(_OptionalButtons);

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static void _dealloc_UINavigationReading(py::wrapper::Windows::Gaming::Input::UINavigationReading* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_UINavigationReading(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Gaming::Input::UINavigationReading>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyMethodDef _methods_UINavigationReading[] = {
        { "_assign_array_", _assign_array_UINavigationReading, METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyObject* UINavigationReading_get_Timestamp(py::wrapper::Windows::Gaming::Input::UINavigationReading* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Timestamp);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int UINavigationReading_set_Timestamp(py::wrapper::Windows::Gaming::Input::UINavigationReading* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.Timestamp = py::convert_to<uint64_t>(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* UINavigationReading_get_RequiredButtons(py::wrapper::Windows::Gaming::Input::UINavigationReading* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RequiredButtons);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int UINavigationReading_set_RequiredButtons(py::wrapper::Windows::Gaming::Input::UINavigationReading* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.RequiredButtons = py::convert_to<winrt::Windows::Gaming::Input::RequiredUINavigationButtons>(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* UINavigationReading_get_OptionalButtons(py::wrapper::Windows::Gaming::Input::UINavigationReading* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.OptionalButtons);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int UINavigationReading_set_OptionalButtons(py::wrapper::Windows::Gaming::Input::UINavigationReading* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.OptionalButtons = py::convert_to<winrt::Windows::Gaming::Input::OptionalUINavigationButtons>(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyGetSetDef _getset_UINavigationReading[] = {
        { "timestamp", reinterpret_cast<getter>(UINavigationReading_get_Timestamp), reinterpret_cast<setter>(UINavigationReading_set_Timestamp), nullptr, nullptr },
        { "required_buttons", reinterpret_cast<getter>(UINavigationReading_get_RequiredButtons), reinterpret_cast<setter>(UINavigationReading_set_RequiredButtons), nullptr, nullptr },
        { "optional_buttons", reinterpret_cast<getter>(UINavigationReading_get_OptionalButtons), reinterpret_cast<setter>(UINavigationReading_set_OptionalButtons), nullptr, nullptr },
        { }
    };

    static PyObject* _richcompare_UINavigationReading(py::wrapper::Windows::Gaming::Input::UINavigationReading* self, PyObject* other, int op) noexcept
    {
        try
        {
            auto _other = py::convert_to<winrt::Windows::Gaming::Input::UINavigationReading>(other);

            if (op == Py_EQ)
            {
                if (self->obj == _other)
                {
                    Py_RETURN_TRUE;
                }

                Py_RETURN_FALSE;
            }

            if (op == Py_NE)
            {
                if (self->obj != _other)
                {
                    Py_RETURN_TRUE;
                }

                Py_RETURN_FALSE;
            }

            Py_RETURN_NOTIMPLEMENTED;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _repr_UINavigationReading(PyObject* self) noexcept
    {
        py::pyobj_handle Timestamp{PyObject_GetAttrString(self, "timestamp")};
        if (!Timestamp)
        {
            return nullptr;
        }

        py::pyobj_handle RequiredButtons{PyObject_GetAttrString(self, "required_buttons")};
        if (!RequiredButtons)
        {
            return nullptr;
        }

        py::pyobj_handle OptionalButtons{PyObject_GetAttrString(self, "optional_buttons")};
        if (!OptionalButtons)
        {
            return nullptr;
        }

        return PyUnicode_FromFormat("UINavigationReading(timestamp=%R, required_buttons=%R, optional_buttons=%R)", Timestamp.get(), RequiredButtons.get(), OptionalButtons.get());
    }

    static PyType_Slot _type_slots_UINavigationReading[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_UINavigationReading) },
        { Py_tp_init, reinterpret_cast<void*>(_init_UINavigationReading) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_UINavigationReading) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_UINavigationReading) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_UINavigationReading) },
        { Py_tp_richcompare, reinterpret_cast<void*>(_richcompare_UINavigationReading) },
        { Py_tp_repr, reinterpret_cast<void*>(_repr_UINavigationReading) },
        { }
    };

    static PyType_Spec type_spec_UINavigationReading = {
        "winrt._winrt_windows_gaming_input.UINavigationReading",
        sizeof(py::wrapper::Windows::Gaming::Input::UINavigationReading),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_UINavigationReading};

    // ----- Windows.Gaming.Input Initialization --------------------

    PyDoc_STRVAR(module_doc, "Windows.Gaming.Input");

    static PyModuleDef module_def = {
        PyModuleDef_HEAD_INIT,
        "_winrt_windows_gaming_input",
        module_doc,
        0,
        nullptr,
        nullptr,
        nullptr,
        nullptr,
        nullptr};
} // py::cpp::Windows::Gaming::Input

PyMODINIT_FUNC PyInit__winrt_windows_gaming_input(void) noexcept
{
    using namespace py::cpp::Windows::Gaming::Input;

    if (py::import_winrt_runtime() == -1)
    {
        return nullptr;
    }

    py::pyobj_handle module{PyModule_Create(&module_def)};

    if (!module)
    {
        return nullptr;
    }

    auto object_type = py::get_object_type();
    if (!object_type)
    {
        return nullptr;
    }

    py::pyobj_handle object_bases{PyTuple_Pack(1, object_type)};

    if (!object_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_ArcadeStick_Static{PyType_FromSpec(&type_spec_ArcadeStick_Static)};
    if (!type_ArcadeStick_Static)
    {
        return nullptr;
    }

    py::pytype_handle ArcadeStick_type{py::register_python_type(module.get(), &type_spec_ArcadeStick, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_ArcadeStick_Static.get()))};
    if (!ArcadeStick_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_FlightStick_Static{PyType_FromSpec(&type_spec_FlightStick_Static)};
    if (!type_FlightStick_Static)
    {
        return nullptr;
    }

    py::pytype_handle FlightStick_type{py::register_python_type(module.get(), &type_spec_FlightStick, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_FlightStick_Static.get()))};
    if (!FlightStick_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_Gamepad_Static{PyType_FromSpec(&type_spec_Gamepad_Static)};
    if (!type_Gamepad_Static)
    {
        return nullptr;
    }

    py::pytype_handle Gamepad_type{py::register_python_type(module.get(), &type_spec_Gamepad, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_Gamepad_Static.get()))};
    if (!Gamepad_type)
    {
        return nullptr;
    }

    py::pytype_handle Headset_type{py::register_python_type(module.get(), &type_spec_Headset, object_bases.get(), nullptr)};
    if (!Headset_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_RacingWheel_Static{PyType_FromSpec(&type_spec_RacingWheel_Static)};
    if (!type_RacingWheel_Static)
    {
        return nullptr;
    }

    py::pytype_handle RacingWheel_type{py::register_python_type(module.get(), &type_spec_RacingWheel, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_RacingWheel_Static.get()))};
    if (!RacingWheel_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_RawGameController_Static{PyType_FromSpec(&type_spec_RawGameController_Static)};
    if (!type_RawGameController_Static)
    {
        return nullptr;
    }

    py::pytype_handle RawGameController_type{py::register_python_type(module.get(), &type_spec_RawGameController, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_RawGameController_Static.get()))};
    if (!RawGameController_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_UINavigationController_Static{PyType_FromSpec(&type_spec_UINavigationController_Static)};
    if (!type_UINavigationController_Static)
    {
        return nullptr;
    }

    py::pytype_handle UINavigationController_type{py::register_python_type(module.get(), &type_spec_UINavigationController, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_UINavigationController_Static.get()))};
    if (!UINavigationController_type)
    {
        return nullptr;
    }

    py::pytype_handle IGameController_type{py::register_python_type(module.get(), &type_spec_IGameController, object_bases.get(), nullptr)};
    if (!IGameController_type)
    {
        return nullptr;
    }

    py::pytype_handle ImplementsIGameController_type{reinterpret_cast<PyTypeObject*>(PyType_FromModuleAndSpec(module.get(), &type_spec_ImplementsIGameController, nullptr))};
    if (!ImplementsIGameController_type)
    {
        return nullptr;
    }

    if (PyModule_AddType(module.get(), ImplementsIGameController_type.get()) == -1)
    {
        return nullptr;
    }

    py::pytype_handle IGameControllerBatteryInfo_type{py::register_python_type(module.get(), &type_spec_IGameControllerBatteryInfo, object_bases.get(), nullptr)};
    if (!IGameControllerBatteryInfo_type)
    {
        return nullptr;
    }

    py::pytype_handle ImplementsIGameControllerBatteryInfo_type{reinterpret_cast<PyTypeObject*>(PyType_FromModuleAndSpec(module.get(), &type_spec_ImplementsIGameControllerBatteryInfo, nullptr))};
    if (!ImplementsIGameControllerBatteryInfo_type)
    {
        return nullptr;
    }

    if (PyModule_AddType(module.get(), ImplementsIGameControllerBatteryInfo_type.get()) == -1)
    {
        return nullptr;
    }

    py::pytype_handle ArcadeStickReading_type{py::register_python_type(module.get(), &type_spec_ArcadeStickReading, nullptr, nullptr)};
    if (!ArcadeStickReading_type)
    {
        return nullptr;
    }

    py::pytype_handle FlightStickReading_type{py::register_python_type(module.get(), &type_spec_FlightStickReading, nullptr, nullptr)};
    if (!FlightStickReading_type)
    {
        return nullptr;
    }

    py::pytype_handle GamepadReading_type{py::register_python_type(module.get(), &type_spec_GamepadReading, nullptr, nullptr)};
    if (!GamepadReading_type)
    {
        return nullptr;
    }

    py::pytype_handle GamepadVibration_type{py::register_python_type(module.get(), &type_spec_GamepadVibration, nullptr, nullptr)};
    if (!GamepadVibration_type)
    {
        return nullptr;
    }

    py::pytype_handle RacingWheelReading_type{py::register_python_type(module.get(), &type_spec_RacingWheelReading, nullptr, nullptr)};
    if (!RacingWheelReading_type)
    {
        return nullptr;
    }

    py::pytype_handle UINavigationReading_type{py::register_python_type(module.get(), &type_spec_UINavigationReading, nullptr, nullptr)};
    if (!UINavigationReading_type)
    {
        return nullptr;
    }


    return module.detach();
}
