// WARNING: Please don't edit this file. It was generated by Python/WinRT v0.0.0

#include "py.Windows.Gaming.Input.h"


namespace py::cpp::Windows::Gaming::Input
{
    // ----- ArcadeStick class --------------------

    static PyObject* _new_ArcadeStick(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Gaming::Input::ArcadeStick>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Gaming::Input::ArcadeStick>::type_name);
        return nullptr;
    }

    static void _dealloc_ArcadeStick(py::wrapper::Windows::Gaming::Input::ArcadeStick* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ArcadeStick_FromGameController(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Gaming.Input.ArcadeStick", L"FromGameController", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Gaming::Input::IGameController>(args, 0);

                return py::convert(winrt::Windows::Gaming::Input::ArcadeStick::FromGameController(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ArcadeStick_GetButtonLabel(py::wrapper::Windows::Gaming::Input::ArcadeStick* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Gaming.Input.ArcadeStick", L"GetButtonLabel", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Gaming::Input::ArcadeStickButtons>(args, 0);

                return py::convert(self->obj.GetButtonLabel(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ArcadeStick_GetCurrentReading(py::wrapper::Windows::Gaming::Input::ArcadeStick* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Gaming.Input.ArcadeStick", L"GetCurrentReading", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetCurrentReading());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ArcadeStick_TryGetBatteryReport(py::wrapper::Windows::Gaming::Input::ArcadeStick* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Gaming.Input.ArcadeStick", L"TryGetBatteryReport", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.TryGetBatteryReport());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ArcadeStick_get_Headset(py::wrapper::Windows::Gaming::Input::ArcadeStick* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Gaming.Input.ArcadeStick", L"Headset"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Headset());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ArcadeStick_get_IsWireless(py::wrapper::Windows::Gaming::Input::ArcadeStick* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Gaming.Input.ArcadeStick", L"IsWireless"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsWireless());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ArcadeStick_get_User(py::wrapper::Windows::Gaming::Input::ArcadeStick* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Gaming.Input.ArcadeStick", L"User"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.User());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ArcadeStick_get_ArcadeSticks(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Gaming.Input.ArcadeStick", L"ArcadeSticks"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Gaming::Input::ArcadeStick::ArcadeSticks());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ArcadeStick_add_HeadsetConnected(py::wrapper::Windows::Gaming::Input::ArcadeStick* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Gaming.Input.ArcadeStick", L"HeadsetConnected"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Gaming::Input::IGameController, winrt::Windows::Gaming::Input::Headset>>(arg);

            return py::convert(self->obj.HeadsetConnected(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ArcadeStick_remove_HeadsetConnected(py::wrapper::Windows::Gaming::Input::ArcadeStick* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Gaming.Input.ArcadeStick", L"HeadsetConnected"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.HeadsetConnected(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ArcadeStick_add_HeadsetDisconnected(py::wrapper::Windows::Gaming::Input::ArcadeStick* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Gaming.Input.ArcadeStick", L"HeadsetDisconnected"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Gaming::Input::IGameController, winrt::Windows::Gaming::Input::Headset>>(arg);

            return py::convert(self->obj.HeadsetDisconnected(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ArcadeStick_remove_HeadsetDisconnected(py::wrapper::Windows::Gaming::Input::ArcadeStick* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Gaming.Input.ArcadeStick", L"HeadsetDisconnected"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.HeadsetDisconnected(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ArcadeStick_add_UserChanged(py::wrapper::Windows::Gaming::Input::ArcadeStick* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Gaming.Input.ArcadeStick", L"UserChanged"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Gaming::Input::IGameController, winrt::Windows::System::UserChangedEventArgs>>(arg);

            return py::convert(self->obj.UserChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ArcadeStick_remove_UserChanged(py::wrapper::Windows::Gaming::Input::ArcadeStick* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Gaming.Input.ArcadeStick", L"UserChanged"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.UserChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ArcadeStick_add_ArcadeStickAdded(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Gaming.Input.ArcadeStick", L"ArcadeStickAdded"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::EventHandler<winrt::Windows::Gaming::Input::ArcadeStick>>(arg);

            return py::convert(winrt::Windows::Gaming::Input::ArcadeStick::ArcadeStickAdded(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ArcadeStick_remove_ArcadeStickAdded(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Gaming.Input.ArcadeStick", L"ArcadeStickAdded"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            winrt::Windows::Gaming::Input::ArcadeStick::ArcadeStickAdded(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ArcadeStick_add_ArcadeStickRemoved(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Gaming.Input.ArcadeStick", L"ArcadeStickRemoved"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::EventHandler<winrt::Windows::Gaming::Input::ArcadeStick>>(arg);

            return py::convert(winrt::Windows::Gaming::Input::ArcadeStick::ArcadeStickRemoved(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ArcadeStick_remove_ArcadeStickRemoved(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Gaming.Input.ArcadeStick", L"ArcadeStickRemoved"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            winrt::Windows::Gaming::Input::ArcadeStick::ArcadeStickRemoved(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ArcadeStick(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Gaming::Input::ArcadeStick>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ArcadeStick(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Gaming::Input::ArcadeStick>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ArcadeStick[] = {
        { "get_button_label", reinterpret_cast<PyCFunction>(ArcadeStick_GetButtonLabel), METH_VARARGS, nullptr },
        { "get_current_reading", reinterpret_cast<PyCFunction>(ArcadeStick_GetCurrentReading), METH_VARARGS, nullptr },
        { "try_get_battery_report", reinterpret_cast<PyCFunction>(ArcadeStick_TryGetBatteryReport), METH_VARARGS, nullptr },
        { "add_headset_connected", reinterpret_cast<PyCFunction>(ArcadeStick_add_HeadsetConnected), METH_O, nullptr },
        { "remove_headset_connected", reinterpret_cast<PyCFunction>(ArcadeStick_remove_HeadsetConnected), METH_O, nullptr },
        { "add_headset_disconnected", reinterpret_cast<PyCFunction>(ArcadeStick_add_HeadsetDisconnected), METH_O, nullptr },
        { "remove_headset_disconnected", reinterpret_cast<PyCFunction>(ArcadeStick_remove_HeadsetDisconnected), METH_O, nullptr },
        { "add_user_changed", reinterpret_cast<PyCFunction>(ArcadeStick_add_UserChanged), METH_O, nullptr },
        { "remove_user_changed", reinterpret_cast<PyCFunction>(ArcadeStick_remove_UserChanged), METH_O, nullptr },
        { "add_arcade_stick_added", reinterpret_cast<PyCFunction>(ArcadeStick_add_ArcadeStickAdded), METH_O | METH_STATIC, nullptr },
        { "remove_arcade_stick_added", reinterpret_cast<PyCFunction>(ArcadeStick_remove_ArcadeStickAdded), METH_O | METH_STATIC, nullptr },
        { "add_arcade_stick_removed", reinterpret_cast<PyCFunction>(ArcadeStick_add_ArcadeStickRemoved), METH_O | METH_STATIC, nullptr },
        { "remove_arcade_stick_removed", reinterpret_cast<PyCFunction>(ArcadeStick_remove_ArcadeStickRemoved), METH_O | METH_STATIC, nullptr },
        { "_assign_array_", _assign_array_ArcadeStick, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ArcadeStick), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ArcadeStick[] = {
        { "headset", reinterpret_cast<getter>(ArcadeStick_get_Headset), nullptr, nullptr, nullptr },
        { "is_wireless", reinterpret_cast<getter>(ArcadeStick_get_IsWireless), nullptr, nullptr, nullptr },
        { "user", reinterpret_cast<getter>(ArcadeStick_get_User), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ArcadeStick[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ArcadeStick) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ArcadeStick) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ArcadeStick) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ArcadeStick) },
        { }
    };

    static PyType_Spec type_spec_ArcadeStick = {
        "winrt._winrt_windows_gaming_input.ArcadeStick",
        sizeof(py::wrapper::Windows::Gaming::Input::ArcadeStick),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ArcadeStick};

    static PyGetSetDef getset_ArcadeStick_Static[] = {
        { "arcade_sticks", reinterpret_cast<getter>(ArcadeStick_get_ArcadeSticks), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_ArcadeStick_Static[] = {
        { "from_game_controller", reinterpret_cast<PyCFunction>(ArcadeStick_FromGameController), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_ArcadeStick_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_ArcadeStick_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_ArcadeStick_Static) },
        { }
    };

    static PyType_Spec type_spec_ArcadeStick_Static =
    {
        "winrt._winrt_windows_gaming_input.ArcadeStick_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_ArcadeStick_Static
    };

    // ----- FlightStick class --------------------

    static PyObject* _new_FlightStick(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Gaming::Input::FlightStick>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Gaming::Input::FlightStick>::type_name);
        return nullptr;
    }

    static void _dealloc_FlightStick(py::wrapper::Windows::Gaming::Input::FlightStick* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* FlightStick_FromGameController(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Gaming.Input.FlightStick", L"FromGameController", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Gaming::Input::IGameController>(args, 0);

                return py::convert(winrt::Windows::Gaming::Input::FlightStick::FromGameController(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* FlightStick_GetButtonLabel(py::wrapper::Windows::Gaming::Input::FlightStick* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Gaming.Input.FlightStick", L"GetButtonLabel", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Gaming::Input::FlightStickButtons>(args, 0);

                return py::convert(self->obj.GetButtonLabel(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* FlightStick_GetCurrentReading(py::wrapper::Windows::Gaming::Input::FlightStick* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Gaming.Input.FlightStick", L"GetCurrentReading", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetCurrentReading());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* FlightStick_TryGetBatteryReport(py::wrapper::Windows::Gaming::Input::FlightStick* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Gaming.Input.FlightStick", L"TryGetBatteryReport", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.TryGetBatteryReport());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* FlightStick_get_HatSwitchKind(py::wrapper::Windows::Gaming::Input::FlightStick* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Gaming.Input.FlightStick", L"HatSwitchKind"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.HatSwitchKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FlightStick_get_Headset(py::wrapper::Windows::Gaming::Input::FlightStick* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Gaming.Input.FlightStick", L"Headset"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Headset());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FlightStick_get_IsWireless(py::wrapper::Windows::Gaming::Input::FlightStick* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Gaming.Input.FlightStick", L"IsWireless"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsWireless());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FlightStick_get_User(py::wrapper::Windows::Gaming::Input::FlightStick* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Gaming.Input.FlightStick", L"User"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.User());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FlightStick_get_FlightSticks(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Gaming.Input.FlightStick", L"FlightSticks"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Gaming::Input::FlightStick::FlightSticks());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FlightStick_add_HeadsetConnected(py::wrapper::Windows::Gaming::Input::FlightStick* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Gaming.Input.FlightStick", L"HeadsetConnected"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Gaming::Input::IGameController, winrt::Windows::Gaming::Input::Headset>>(arg);

            return py::convert(self->obj.HeadsetConnected(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FlightStick_remove_HeadsetConnected(py::wrapper::Windows::Gaming::Input::FlightStick* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Gaming.Input.FlightStick", L"HeadsetConnected"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.HeadsetConnected(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FlightStick_add_HeadsetDisconnected(py::wrapper::Windows::Gaming::Input::FlightStick* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Gaming.Input.FlightStick", L"HeadsetDisconnected"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Gaming::Input::IGameController, winrt::Windows::Gaming::Input::Headset>>(arg);

            return py::convert(self->obj.HeadsetDisconnected(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FlightStick_remove_HeadsetDisconnected(py::wrapper::Windows::Gaming::Input::FlightStick* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Gaming.Input.FlightStick", L"HeadsetDisconnected"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.HeadsetDisconnected(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FlightStick_add_UserChanged(py::wrapper::Windows::Gaming::Input::FlightStick* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Gaming.Input.FlightStick", L"UserChanged"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Gaming::Input::IGameController, winrt::Windows::System::UserChangedEventArgs>>(arg);

            return py::convert(self->obj.UserChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FlightStick_remove_UserChanged(py::wrapper::Windows::Gaming::Input::FlightStick* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Gaming.Input.FlightStick", L"UserChanged"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.UserChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FlightStick_add_FlightStickAdded(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Gaming.Input.FlightStick", L"FlightStickAdded"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::EventHandler<winrt::Windows::Gaming::Input::FlightStick>>(arg);

            return py::convert(winrt::Windows::Gaming::Input::FlightStick::FlightStickAdded(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FlightStick_remove_FlightStickAdded(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Gaming.Input.FlightStick", L"FlightStickAdded"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            winrt::Windows::Gaming::Input::FlightStick::FlightStickAdded(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FlightStick_add_FlightStickRemoved(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Gaming.Input.FlightStick", L"FlightStickRemoved"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::EventHandler<winrt::Windows::Gaming::Input::FlightStick>>(arg);

            return py::convert(winrt::Windows::Gaming::Input::FlightStick::FlightStickRemoved(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FlightStick_remove_FlightStickRemoved(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Gaming.Input.FlightStick", L"FlightStickRemoved"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            winrt::Windows::Gaming::Input::FlightStick::FlightStickRemoved(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_FlightStick(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Gaming::Input::FlightStick>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_FlightStick(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Gaming::Input::FlightStick>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_FlightStick[] = {
        { "get_button_label", reinterpret_cast<PyCFunction>(FlightStick_GetButtonLabel), METH_VARARGS, nullptr },
        { "get_current_reading", reinterpret_cast<PyCFunction>(FlightStick_GetCurrentReading), METH_VARARGS, nullptr },
        { "try_get_battery_report", reinterpret_cast<PyCFunction>(FlightStick_TryGetBatteryReport), METH_VARARGS, nullptr },
        { "add_headset_connected", reinterpret_cast<PyCFunction>(FlightStick_add_HeadsetConnected), METH_O, nullptr },
        { "remove_headset_connected", reinterpret_cast<PyCFunction>(FlightStick_remove_HeadsetConnected), METH_O, nullptr },
        { "add_headset_disconnected", reinterpret_cast<PyCFunction>(FlightStick_add_HeadsetDisconnected), METH_O, nullptr },
        { "remove_headset_disconnected", reinterpret_cast<PyCFunction>(FlightStick_remove_HeadsetDisconnected), METH_O, nullptr },
        { "add_user_changed", reinterpret_cast<PyCFunction>(FlightStick_add_UserChanged), METH_O, nullptr },
        { "remove_user_changed", reinterpret_cast<PyCFunction>(FlightStick_remove_UserChanged), METH_O, nullptr },
        { "add_flight_stick_added", reinterpret_cast<PyCFunction>(FlightStick_add_FlightStickAdded), METH_O | METH_STATIC, nullptr },
        { "remove_flight_stick_added", reinterpret_cast<PyCFunction>(FlightStick_remove_FlightStickAdded), METH_O | METH_STATIC, nullptr },
        { "add_flight_stick_removed", reinterpret_cast<PyCFunction>(FlightStick_add_FlightStickRemoved), METH_O | METH_STATIC, nullptr },
        { "remove_flight_stick_removed", reinterpret_cast<PyCFunction>(FlightStick_remove_FlightStickRemoved), METH_O | METH_STATIC, nullptr },
        { "_assign_array_", _assign_array_FlightStick, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_FlightStick), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_FlightStick[] = {
        { "hat_switch_kind", reinterpret_cast<getter>(FlightStick_get_HatSwitchKind), nullptr, nullptr, nullptr },
        { "headset", reinterpret_cast<getter>(FlightStick_get_Headset), nullptr, nullptr, nullptr },
        { "is_wireless", reinterpret_cast<getter>(FlightStick_get_IsWireless), nullptr, nullptr, nullptr },
        { "user", reinterpret_cast<getter>(FlightStick_get_User), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_FlightStick[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_FlightStick) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_FlightStick) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_FlightStick) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_FlightStick) },
        { }
    };

    static PyType_Spec type_spec_FlightStick = {
        "winrt._winrt_windows_gaming_input.FlightStick",
        sizeof(py::wrapper::Windows::Gaming::Input::FlightStick),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_FlightStick};

    static PyGetSetDef getset_FlightStick_Static[] = {
        { "flight_sticks", reinterpret_cast<getter>(FlightStick_get_FlightSticks), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_FlightStick_Static[] = {
        { "from_game_controller", reinterpret_cast<PyCFunction>(FlightStick_FromGameController), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_FlightStick_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_FlightStick_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_FlightStick_Static) },
        { }
    };

    static PyType_Spec type_spec_FlightStick_Static =
    {
        "winrt._winrt_windows_gaming_input.FlightStick_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_FlightStick_Static
    };

    // ----- Gamepad class --------------------

    static PyObject* _new_Gamepad(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Gaming::Input::Gamepad>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Gaming::Input::Gamepad>::type_name);
        return nullptr;
    }

    static void _dealloc_Gamepad(py::wrapper::Windows::Gaming::Input::Gamepad* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* Gamepad_FromGameController(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Gaming.Input.Gamepad", L"FromGameController", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Gaming::Input::IGameController>(args, 0);

                return py::convert(winrt::Windows::Gaming::Input::Gamepad::FromGameController(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Gamepad_GetButtonLabel(py::wrapper::Windows::Gaming::Input::Gamepad* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Gaming.Input.Gamepad", L"GetButtonLabel", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Gaming::Input::GamepadButtons>(args, 0);

                return py::convert(self->obj.GetButtonLabel(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Gamepad_GetCurrentReading(py::wrapper::Windows::Gaming::Input::Gamepad* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Gaming.Input.Gamepad", L"GetCurrentReading", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetCurrentReading());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Gamepad_TryGetBatteryReport(py::wrapper::Windows::Gaming::Input::Gamepad* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Gaming.Input.Gamepad", L"TryGetBatteryReport", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.TryGetBatteryReport());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Gamepad_get_Headset(py::wrapper::Windows::Gaming::Input::Gamepad* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Gaming.Input.Gamepad", L"Headset"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Headset());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Gamepad_get_IsWireless(py::wrapper::Windows::Gaming::Input::Gamepad* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Gaming.Input.Gamepad", L"IsWireless"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsWireless());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Gamepad_get_User(py::wrapper::Windows::Gaming::Input::Gamepad* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Gaming.Input.Gamepad", L"User"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.User());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Gamepad_get_Vibration(py::wrapper::Windows::Gaming::Input::Gamepad* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Gaming.Input.Gamepad", L"Vibration"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Vibration());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Gamepad_put_Vibration(py::wrapper::Windows::Gaming::Input::Gamepad* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Gaming.Input.Gamepad", L"Vibration"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Gaming::Input::GamepadVibration>(arg);

            self->obj.Vibration(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Gamepad_get_Gamepads(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Gaming.Input.Gamepad", L"Gamepads"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Gaming::Input::Gamepad::Gamepads());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Gamepad_add_HeadsetConnected(py::wrapper::Windows::Gaming::Input::Gamepad* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Gaming.Input.Gamepad", L"HeadsetConnected"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Gaming::Input::IGameController, winrt::Windows::Gaming::Input::Headset>>(arg);

            return py::convert(self->obj.HeadsetConnected(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Gamepad_remove_HeadsetConnected(py::wrapper::Windows::Gaming::Input::Gamepad* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Gaming.Input.Gamepad", L"HeadsetConnected"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.HeadsetConnected(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Gamepad_add_HeadsetDisconnected(py::wrapper::Windows::Gaming::Input::Gamepad* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Gaming.Input.Gamepad", L"HeadsetDisconnected"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Gaming::Input::IGameController, winrt::Windows::Gaming::Input::Headset>>(arg);

            return py::convert(self->obj.HeadsetDisconnected(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Gamepad_remove_HeadsetDisconnected(py::wrapper::Windows::Gaming::Input::Gamepad* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Gaming.Input.Gamepad", L"HeadsetDisconnected"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.HeadsetDisconnected(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Gamepad_add_UserChanged(py::wrapper::Windows::Gaming::Input::Gamepad* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Gaming.Input.Gamepad", L"UserChanged"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Gaming::Input::IGameController, winrt::Windows::System::UserChangedEventArgs>>(arg);

            return py::convert(self->obj.UserChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Gamepad_remove_UserChanged(py::wrapper::Windows::Gaming::Input::Gamepad* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Gaming.Input.Gamepad", L"UserChanged"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.UserChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Gamepad_add_GamepadAdded(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Gaming.Input.Gamepad", L"GamepadAdded"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::EventHandler<winrt::Windows::Gaming::Input::Gamepad>>(arg);

            return py::convert(winrt::Windows::Gaming::Input::Gamepad::GamepadAdded(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Gamepad_remove_GamepadAdded(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Gaming.Input.Gamepad", L"GamepadAdded"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            winrt::Windows::Gaming::Input::Gamepad::GamepadAdded(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Gamepad_add_GamepadRemoved(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Gaming.Input.Gamepad", L"GamepadRemoved"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::EventHandler<winrt::Windows::Gaming::Input::Gamepad>>(arg);

            return py::convert(winrt::Windows::Gaming::Input::Gamepad::GamepadRemoved(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Gamepad_remove_GamepadRemoved(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Gaming.Input.Gamepad", L"GamepadRemoved"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            winrt::Windows::Gaming::Input::Gamepad::GamepadRemoved(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_Gamepad(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Gaming::Input::Gamepad>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_Gamepad(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Gaming::Input::Gamepad>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_Gamepad[] = {
        { "get_button_label", reinterpret_cast<PyCFunction>(Gamepad_GetButtonLabel), METH_VARARGS, nullptr },
        { "get_current_reading", reinterpret_cast<PyCFunction>(Gamepad_GetCurrentReading), METH_VARARGS, nullptr },
        { "try_get_battery_report", reinterpret_cast<PyCFunction>(Gamepad_TryGetBatteryReport), METH_VARARGS, nullptr },
        { "add_headset_connected", reinterpret_cast<PyCFunction>(Gamepad_add_HeadsetConnected), METH_O, nullptr },
        { "remove_headset_connected", reinterpret_cast<PyCFunction>(Gamepad_remove_HeadsetConnected), METH_O, nullptr },
        { "add_headset_disconnected", reinterpret_cast<PyCFunction>(Gamepad_add_HeadsetDisconnected), METH_O, nullptr },
        { "remove_headset_disconnected", reinterpret_cast<PyCFunction>(Gamepad_remove_HeadsetDisconnected), METH_O, nullptr },
        { "add_user_changed", reinterpret_cast<PyCFunction>(Gamepad_add_UserChanged), METH_O, nullptr },
        { "remove_user_changed", reinterpret_cast<PyCFunction>(Gamepad_remove_UserChanged), METH_O, nullptr },
        { "add_gamepad_added", reinterpret_cast<PyCFunction>(Gamepad_add_GamepadAdded), METH_O | METH_STATIC, nullptr },
        { "remove_gamepad_added", reinterpret_cast<PyCFunction>(Gamepad_remove_GamepadAdded), METH_O | METH_STATIC, nullptr },
        { "add_gamepad_removed", reinterpret_cast<PyCFunction>(Gamepad_add_GamepadRemoved), METH_O | METH_STATIC, nullptr },
        { "remove_gamepad_removed", reinterpret_cast<PyCFunction>(Gamepad_remove_GamepadRemoved), METH_O | METH_STATIC, nullptr },
        { "_assign_array_", _assign_array_Gamepad, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_Gamepad), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_Gamepad[] = {
        { "headset", reinterpret_cast<getter>(Gamepad_get_Headset), nullptr, nullptr, nullptr },
        { "is_wireless", reinterpret_cast<getter>(Gamepad_get_IsWireless), nullptr, nullptr, nullptr },
        { "user", reinterpret_cast<getter>(Gamepad_get_User), nullptr, nullptr, nullptr },
        { "vibration", reinterpret_cast<getter>(Gamepad_get_Vibration), reinterpret_cast<setter>(Gamepad_put_Vibration), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_Gamepad[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_Gamepad) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_Gamepad) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_Gamepad) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_Gamepad) },
        { }
    };

    static PyType_Spec type_spec_Gamepad = {
        "winrt._winrt_windows_gaming_input.Gamepad",
        sizeof(py::wrapper::Windows::Gaming::Input::Gamepad),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_Gamepad};

    static PyGetSetDef getset_Gamepad_Static[] = {
        { "gamepads", reinterpret_cast<getter>(Gamepad_get_Gamepads), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_Gamepad_Static[] = {
        { "from_game_controller", reinterpret_cast<PyCFunction>(Gamepad_FromGameController), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_Gamepad_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_Gamepad_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_Gamepad_Static) },
        { }
    };

    static PyType_Spec type_spec_Gamepad_Static =
    {
        "winrt._winrt_windows_gaming_input.Gamepad_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_Gamepad_Static
    };

    // ----- Headset class --------------------

    static PyObject* _new_Headset(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Gaming::Input::Headset>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Gaming::Input::Headset>::type_name);
        return nullptr;
    }

    static void _dealloc_Headset(py::wrapper::Windows::Gaming::Input::Headset* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* Headset_TryGetBatteryReport(py::wrapper::Windows::Gaming::Input::Headset* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Gaming.Input.Headset", L"TryGetBatteryReport", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.TryGetBatteryReport());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Headset_get_CaptureDeviceId(py::wrapper::Windows::Gaming::Input::Headset* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Gaming.Input.Headset", L"CaptureDeviceId"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CaptureDeviceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Headset_get_RenderDeviceId(py::wrapper::Windows::Gaming::Input::Headset* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Gaming.Input.Headset", L"RenderDeviceId"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.RenderDeviceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_Headset(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Gaming::Input::Headset>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_Headset(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Gaming::Input::Headset>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_Headset[] = {
        { "try_get_battery_report", reinterpret_cast<PyCFunction>(Headset_TryGetBatteryReport), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_Headset, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_Headset), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_Headset[] = {
        { "capture_device_id", reinterpret_cast<getter>(Headset_get_CaptureDeviceId), nullptr, nullptr, nullptr },
        { "render_device_id", reinterpret_cast<getter>(Headset_get_RenderDeviceId), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_Headset[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_Headset) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_Headset) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_Headset) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_Headset) },
        { }
    };

    static PyType_Spec type_spec_Headset = {
        "winrt._winrt_windows_gaming_input.Headset",
        sizeof(py::wrapper::Windows::Gaming::Input::Headset),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_Headset};

    // ----- RacingWheel class --------------------

    static PyObject* _new_RacingWheel(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Gaming::Input::RacingWheel>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Gaming::Input::RacingWheel>::type_name);
        return nullptr;
    }

    static void _dealloc_RacingWheel(py::wrapper::Windows::Gaming::Input::RacingWheel* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* RacingWheel_FromGameController(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Gaming.Input.RacingWheel", L"FromGameController", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Gaming::Input::IGameController>(args, 0);

                return py::convert(winrt::Windows::Gaming::Input::RacingWheel::FromGameController(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RacingWheel_GetButtonLabel(py::wrapper::Windows::Gaming::Input::RacingWheel* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Gaming.Input.RacingWheel", L"GetButtonLabel", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Gaming::Input::RacingWheelButtons>(args, 0);

                return py::convert(self->obj.GetButtonLabel(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RacingWheel_GetCurrentReading(py::wrapper::Windows::Gaming::Input::RacingWheel* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Gaming.Input.RacingWheel", L"GetCurrentReading", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetCurrentReading());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RacingWheel_TryGetBatteryReport(py::wrapper::Windows::Gaming::Input::RacingWheel* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Gaming.Input.RacingWheel", L"TryGetBatteryReport", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.TryGetBatteryReport());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RacingWheel_get_Headset(py::wrapper::Windows::Gaming::Input::RacingWheel* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Gaming.Input.RacingWheel", L"Headset"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Headset());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RacingWheel_get_IsWireless(py::wrapper::Windows::Gaming::Input::RacingWheel* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Gaming.Input.RacingWheel", L"IsWireless"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsWireless());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RacingWheel_get_User(py::wrapper::Windows::Gaming::Input::RacingWheel* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Gaming.Input.RacingWheel", L"User"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.User());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RacingWheel_get_HasClutch(py::wrapper::Windows::Gaming::Input::RacingWheel* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Gaming.Input.RacingWheel", L"HasClutch"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.HasClutch());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RacingWheel_get_HasHandbrake(py::wrapper::Windows::Gaming::Input::RacingWheel* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Gaming.Input.RacingWheel", L"HasHandbrake"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.HasHandbrake());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RacingWheel_get_HasPatternShifter(py::wrapper::Windows::Gaming::Input::RacingWheel* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Gaming.Input.RacingWheel", L"HasPatternShifter"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.HasPatternShifter());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RacingWheel_get_MaxPatternShifterGear(py::wrapper::Windows::Gaming::Input::RacingWheel* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Gaming.Input.RacingWheel", L"MaxPatternShifterGear"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.MaxPatternShifterGear());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RacingWheel_get_MaxWheelAngle(py::wrapper::Windows::Gaming::Input::RacingWheel* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Gaming.Input.RacingWheel", L"MaxWheelAngle"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.MaxWheelAngle());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RacingWheel_get_WheelMotor(py::wrapper::Windows::Gaming::Input::RacingWheel* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Gaming.Input.RacingWheel", L"WheelMotor"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.WheelMotor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RacingWheel_get_RacingWheels(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Gaming.Input.RacingWheel", L"RacingWheels"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Gaming::Input::RacingWheel::RacingWheels());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RacingWheel_add_HeadsetConnected(py::wrapper::Windows::Gaming::Input::RacingWheel* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Gaming.Input.RacingWheel", L"HeadsetConnected"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Gaming::Input::IGameController, winrt::Windows::Gaming::Input::Headset>>(arg);

            return py::convert(self->obj.HeadsetConnected(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RacingWheel_remove_HeadsetConnected(py::wrapper::Windows::Gaming::Input::RacingWheel* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Gaming.Input.RacingWheel", L"HeadsetConnected"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.HeadsetConnected(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RacingWheel_add_HeadsetDisconnected(py::wrapper::Windows::Gaming::Input::RacingWheel* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Gaming.Input.RacingWheel", L"HeadsetDisconnected"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Gaming::Input::IGameController, winrt::Windows::Gaming::Input::Headset>>(arg);

            return py::convert(self->obj.HeadsetDisconnected(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RacingWheel_remove_HeadsetDisconnected(py::wrapper::Windows::Gaming::Input::RacingWheel* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Gaming.Input.RacingWheel", L"HeadsetDisconnected"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.HeadsetDisconnected(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RacingWheel_add_UserChanged(py::wrapper::Windows::Gaming::Input::RacingWheel* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Gaming.Input.RacingWheel", L"UserChanged"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Gaming::Input::IGameController, winrt::Windows::System::UserChangedEventArgs>>(arg);

            return py::convert(self->obj.UserChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RacingWheel_remove_UserChanged(py::wrapper::Windows::Gaming::Input::RacingWheel* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Gaming.Input.RacingWheel", L"UserChanged"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.UserChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RacingWheel_add_RacingWheelAdded(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Gaming.Input.RacingWheel", L"RacingWheelAdded"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::EventHandler<winrt::Windows::Gaming::Input::RacingWheel>>(arg);

            return py::convert(winrt::Windows::Gaming::Input::RacingWheel::RacingWheelAdded(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RacingWheel_remove_RacingWheelAdded(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Gaming.Input.RacingWheel", L"RacingWheelAdded"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            winrt::Windows::Gaming::Input::RacingWheel::RacingWheelAdded(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RacingWheel_add_RacingWheelRemoved(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Gaming.Input.RacingWheel", L"RacingWheelRemoved"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::EventHandler<winrt::Windows::Gaming::Input::RacingWheel>>(arg);

            return py::convert(winrt::Windows::Gaming::Input::RacingWheel::RacingWheelRemoved(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RacingWheel_remove_RacingWheelRemoved(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Gaming.Input.RacingWheel", L"RacingWheelRemoved"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            winrt::Windows::Gaming::Input::RacingWheel::RacingWheelRemoved(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_RacingWheel(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Gaming::Input::RacingWheel>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_RacingWheel(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Gaming::Input::RacingWheel>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RacingWheel[] = {
        { "get_button_label", reinterpret_cast<PyCFunction>(RacingWheel_GetButtonLabel), METH_VARARGS, nullptr },
        { "get_current_reading", reinterpret_cast<PyCFunction>(RacingWheel_GetCurrentReading), METH_VARARGS, nullptr },
        { "try_get_battery_report", reinterpret_cast<PyCFunction>(RacingWheel_TryGetBatteryReport), METH_VARARGS, nullptr },
        { "add_headset_connected", reinterpret_cast<PyCFunction>(RacingWheel_add_HeadsetConnected), METH_O, nullptr },
        { "remove_headset_connected", reinterpret_cast<PyCFunction>(RacingWheel_remove_HeadsetConnected), METH_O, nullptr },
        { "add_headset_disconnected", reinterpret_cast<PyCFunction>(RacingWheel_add_HeadsetDisconnected), METH_O, nullptr },
        { "remove_headset_disconnected", reinterpret_cast<PyCFunction>(RacingWheel_remove_HeadsetDisconnected), METH_O, nullptr },
        { "add_user_changed", reinterpret_cast<PyCFunction>(RacingWheel_add_UserChanged), METH_O, nullptr },
        { "remove_user_changed", reinterpret_cast<PyCFunction>(RacingWheel_remove_UserChanged), METH_O, nullptr },
        { "add_racing_wheel_added", reinterpret_cast<PyCFunction>(RacingWheel_add_RacingWheelAdded), METH_O | METH_STATIC, nullptr },
        { "remove_racing_wheel_added", reinterpret_cast<PyCFunction>(RacingWheel_remove_RacingWheelAdded), METH_O | METH_STATIC, nullptr },
        { "add_racing_wheel_removed", reinterpret_cast<PyCFunction>(RacingWheel_add_RacingWheelRemoved), METH_O | METH_STATIC, nullptr },
        { "remove_racing_wheel_removed", reinterpret_cast<PyCFunction>(RacingWheel_remove_RacingWheelRemoved), METH_O | METH_STATIC, nullptr },
        { "_assign_array_", _assign_array_RacingWheel, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_RacingWheel), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_RacingWheel[] = {
        { "headset", reinterpret_cast<getter>(RacingWheel_get_Headset), nullptr, nullptr, nullptr },
        { "is_wireless", reinterpret_cast<getter>(RacingWheel_get_IsWireless), nullptr, nullptr, nullptr },
        { "user", reinterpret_cast<getter>(RacingWheel_get_User), nullptr, nullptr, nullptr },
        { "has_clutch", reinterpret_cast<getter>(RacingWheel_get_HasClutch), nullptr, nullptr, nullptr },
        { "has_handbrake", reinterpret_cast<getter>(RacingWheel_get_HasHandbrake), nullptr, nullptr, nullptr },
        { "has_pattern_shifter", reinterpret_cast<getter>(RacingWheel_get_HasPatternShifter), nullptr, nullptr, nullptr },
        { "max_pattern_shifter_gear", reinterpret_cast<getter>(RacingWheel_get_MaxPatternShifterGear), nullptr, nullptr, nullptr },
        { "max_wheel_angle", reinterpret_cast<getter>(RacingWheel_get_MaxWheelAngle), nullptr, nullptr, nullptr },
        { "wheel_motor", reinterpret_cast<getter>(RacingWheel_get_WheelMotor), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_RacingWheel[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_RacingWheel) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_RacingWheel) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_RacingWheel) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_RacingWheel) },
        { }
    };

    static PyType_Spec type_spec_RacingWheel = {
        "winrt._winrt_windows_gaming_input.RacingWheel",
        sizeof(py::wrapper::Windows::Gaming::Input::RacingWheel),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RacingWheel};

    static PyGetSetDef getset_RacingWheel_Static[] = {
        { "racing_wheels", reinterpret_cast<getter>(RacingWheel_get_RacingWheels), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_RacingWheel_Static[] = {
        { "from_game_controller", reinterpret_cast<PyCFunction>(RacingWheel_FromGameController), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_RacingWheel_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_RacingWheel_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_RacingWheel_Static) },
        { }
    };

    static PyType_Spec type_spec_RacingWheel_Static =
    {
        "winrt._winrt_windows_gaming_input.RacingWheel_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_RacingWheel_Static
    };

    // ----- RawGameController class --------------------

    static PyObject* _new_RawGameController(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Gaming::Input::RawGameController>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Gaming::Input::RawGameController>::type_name);
        return nullptr;
    }

    static void _dealloc_RawGameController(py::wrapper::Windows::Gaming::Input::RawGameController* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* RawGameController_FromGameController(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Gaming.Input.RawGameController", L"FromGameController", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Gaming::Input::IGameController>(args, 0);

                return py::convert(winrt::Windows::Gaming::Input::RawGameController::FromGameController(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RawGameController_GetButtonLabel(py::wrapper::Windows::Gaming::Input::RawGameController* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Gaming.Input.RawGameController", L"GetButtonLabel", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<int32_t>(args, 0);

                return py::convert(self->obj.GetButtonLabel(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RawGameController_GetCurrentReading(py::wrapper::Windows::Gaming::Input::RawGameController* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Gaming.Input.RawGameController", L"GetCurrentReading", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                auto param0 = py::convert_to<py::pybuf_view<bool, true>>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<winrt::Windows::Gaming::Input::GameControllerSwitchPosition, true>>(args, 1);
                auto param2 = py::convert_to<py::pybuf_view<double, true>>(args, 2);

                return py::convert(self->obj.GetCurrentReading(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RawGameController_GetSwitchKind(py::wrapper::Windows::Gaming::Input::RawGameController* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Gaming.Input.RawGameController", L"GetSwitchKind", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<int32_t>(args, 0);

                return py::convert(self->obj.GetSwitchKind(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RawGameController_TryGetBatteryReport(py::wrapper::Windows::Gaming::Input::RawGameController* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Gaming.Input.RawGameController", L"TryGetBatteryReport", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.TryGetBatteryReport());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RawGameController_get_Headset(py::wrapper::Windows::Gaming::Input::RawGameController* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Gaming.Input.RawGameController", L"Headset"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Headset());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RawGameController_get_IsWireless(py::wrapper::Windows::Gaming::Input::RawGameController* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Gaming.Input.RawGameController", L"IsWireless"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsWireless());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RawGameController_get_User(py::wrapper::Windows::Gaming::Input::RawGameController* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Gaming.Input.RawGameController", L"User"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.User());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RawGameController_get_AxisCount(py::wrapper::Windows::Gaming::Input::RawGameController* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Gaming.Input.RawGameController", L"AxisCount"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.AxisCount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RawGameController_get_ButtonCount(py::wrapper::Windows::Gaming::Input::RawGameController* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Gaming.Input.RawGameController", L"ButtonCount"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ButtonCount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RawGameController_get_ForceFeedbackMotors(py::wrapper::Windows::Gaming::Input::RawGameController* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Gaming.Input.RawGameController", L"ForceFeedbackMotors"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ForceFeedbackMotors());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RawGameController_get_HardwareProductId(py::wrapper::Windows::Gaming::Input::RawGameController* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Gaming.Input.RawGameController", L"HardwareProductId"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.HardwareProductId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RawGameController_get_HardwareVendorId(py::wrapper::Windows::Gaming::Input::RawGameController* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Gaming.Input.RawGameController", L"HardwareVendorId"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.HardwareVendorId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RawGameController_get_SwitchCount(py::wrapper::Windows::Gaming::Input::RawGameController* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Gaming.Input.RawGameController", L"SwitchCount"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SwitchCount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RawGameController_get_DisplayName(py::wrapper::Windows::Gaming::Input::RawGameController* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Gaming.Input.RawGameController", L"DisplayName"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DisplayName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RawGameController_get_NonRoamableId(py::wrapper::Windows::Gaming::Input::RawGameController* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Gaming.Input.RawGameController", L"NonRoamableId"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.NonRoamableId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RawGameController_get_SimpleHapticsControllers(py::wrapper::Windows::Gaming::Input::RawGameController* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Gaming.Input.RawGameController", L"SimpleHapticsControllers"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SimpleHapticsControllers());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RawGameController_get_RawGameControllers(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Gaming.Input.RawGameController", L"RawGameControllers"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Gaming::Input::RawGameController::RawGameControllers());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RawGameController_add_HeadsetConnected(py::wrapper::Windows::Gaming::Input::RawGameController* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Gaming.Input.RawGameController", L"HeadsetConnected"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Gaming::Input::IGameController, winrt::Windows::Gaming::Input::Headset>>(arg);

            return py::convert(self->obj.HeadsetConnected(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RawGameController_remove_HeadsetConnected(py::wrapper::Windows::Gaming::Input::RawGameController* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Gaming.Input.RawGameController", L"HeadsetConnected"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.HeadsetConnected(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RawGameController_add_HeadsetDisconnected(py::wrapper::Windows::Gaming::Input::RawGameController* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Gaming.Input.RawGameController", L"HeadsetDisconnected"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Gaming::Input::IGameController, winrt::Windows::Gaming::Input::Headset>>(arg);

            return py::convert(self->obj.HeadsetDisconnected(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RawGameController_remove_HeadsetDisconnected(py::wrapper::Windows::Gaming::Input::RawGameController* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Gaming.Input.RawGameController", L"HeadsetDisconnected"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.HeadsetDisconnected(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RawGameController_add_UserChanged(py::wrapper::Windows::Gaming::Input::RawGameController* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Gaming.Input.RawGameController", L"UserChanged"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Gaming::Input::IGameController, winrt::Windows::System::UserChangedEventArgs>>(arg);

            return py::convert(self->obj.UserChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RawGameController_remove_UserChanged(py::wrapper::Windows::Gaming::Input::RawGameController* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Gaming.Input.RawGameController", L"UserChanged"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.UserChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RawGameController_add_RawGameControllerAdded(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Gaming.Input.RawGameController", L"RawGameControllerAdded"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::EventHandler<winrt::Windows::Gaming::Input::RawGameController>>(arg);

            return py::convert(winrt::Windows::Gaming::Input::RawGameController::RawGameControllerAdded(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RawGameController_remove_RawGameControllerAdded(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Gaming.Input.RawGameController", L"RawGameControllerAdded"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            winrt::Windows::Gaming::Input::RawGameController::RawGameControllerAdded(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RawGameController_add_RawGameControllerRemoved(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Gaming.Input.RawGameController", L"RawGameControllerRemoved"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::EventHandler<winrt::Windows::Gaming::Input::RawGameController>>(arg);

            return py::convert(winrt::Windows::Gaming::Input::RawGameController::RawGameControllerRemoved(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RawGameController_remove_RawGameControllerRemoved(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Gaming.Input.RawGameController", L"RawGameControllerRemoved"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            winrt::Windows::Gaming::Input::RawGameController::RawGameControllerRemoved(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_RawGameController(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Gaming::Input::RawGameController>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_RawGameController(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Gaming::Input::RawGameController>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RawGameController[] = {
        { "get_button_label", reinterpret_cast<PyCFunction>(RawGameController_GetButtonLabel), METH_VARARGS, nullptr },
        { "get_current_reading", reinterpret_cast<PyCFunction>(RawGameController_GetCurrentReading), METH_VARARGS, nullptr },
        { "get_switch_kind", reinterpret_cast<PyCFunction>(RawGameController_GetSwitchKind), METH_VARARGS, nullptr },
        { "try_get_battery_report", reinterpret_cast<PyCFunction>(RawGameController_TryGetBatteryReport), METH_VARARGS, nullptr },
        { "add_headset_connected", reinterpret_cast<PyCFunction>(RawGameController_add_HeadsetConnected), METH_O, nullptr },
        { "remove_headset_connected", reinterpret_cast<PyCFunction>(RawGameController_remove_HeadsetConnected), METH_O, nullptr },
        { "add_headset_disconnected", reinterpret_cast<PyCFunction>(RawGameController_add_HeadsetDisconnected), METH_O, nullptr },
        { "remove_headset_disconnected", reinterpret_cast<PyCFunction>(RawGameController_remove_HeadsetDisconnected), METH_O, nullptr },
        { "add_user_changed", reinterpret_cast<PyCFunction>(RawGameController_add_UserChanged), METH_O, nullptr },
        { "remove_user_changed", reinterpret_cast<PyCFunction>(RawGameController_remove_UserChanged), METH_O, nullptr },
        { "add_raw_game_controller_added", reinterpret_cast<PyCFunction>(RawGameController_add_RawGameControllerAdded), METH_O | METH_STATIC, nullptr },
        { "remove_raw_game_controller_added", reinterpret_cast<PyCFunction>(RawGameController_remove_RawGameControllerAdded), METH_O | METH_STATIC, nullptr },
        { "add_raw_game_controller_removed", reinterpret_cast<PyCFunction>(RawGameController_add_RawGameControllerRemoved), METH_O | METH_STATIC, nullptr },
        { "remove_raw_game_controller_removed", reinterpret_cast<PyCFunction>(RawGameController_remove_RawGameControllerRemoved), METH_O | METH_STATIC, nullptr },
        { "_assign_array_", _assign_array_RawGameController, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_RawGameController), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_RawGameController[] = {
        { "headset", reinterpret_cast<getter>(RawGameController_get_Headset), nullptr, nullptr, nullptr },
        { "is_wireless", reinterpret_cast<getter>(RawGameController_get_IsWireless), nullptr, nullptr, nullptr },
        { "user", reinterpret_cast<getter>(RawGameController_get_User), nullptr, nullptr, nullptr },
        { "axis_count", reinterpret_cast<getter>(RawGameController_get_AxisCount), nullptr, nullptr, nullptr },
        { "button_count", reinterpret_cast<getter>(RawGameController_get_ButtonCount), nullptr, nullptr, nullptr },
        { "force_feedback_motors", reinterpret_cast<getter>(RawGameController_get_ForceFeedbackMotors), nullptr, nullptr, nullptr },
        { "hardware_product_id", reinterpret_cast<getter>(RawGameController_get_HardwareProductId), nullptr, nullptr, nullptr },
        { "hardware_vendor_id", reinterpret_cast<getter>(RawGameController_get_HardwareVendorId), nullptr, nullptr, nullptr },
        { "switch_count", reinterpret_cast<getter>(RawGameController_get_SwitchCount), nullptr, nullptr, nullptr },
        { "display_name", reinterpret_cast<getter>(RawGameController_get_DisplayName), nullptr, nullptr, nullptr },
        { "non_roamable_id", reinterpret_cast<getter>(RawGameController_get_NonRoamableId), nullptr, nullptr, nullptr },
        { "simple_haptics_controllers", reinterpret_cast<getter>(RawGameController_get_SimpleHapticsControllers), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_RawGameController[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_RawGameController) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_RawGameController) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_RawGameController) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_RawGameController) },
        { }
    };

    static PyType_Spec type_spec_RawGameController = {
        "winrt._winrt_windows_gaming_input.RawGameController",
        sizeof(py::wrapper::Windows::Gaming::Input::RawGameController),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RawGameController};

    static PyGetSetDef getset_RawGameController_Static[] = {
        { "raw_game_controllers", reinterpret_cast<getter>(RawGameController_get_RawGameControllers), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_RawGameController_Static[] = {
        { "from_game_controller", reinterpret_cast<PyCFunction>(RawGameController_FromGameController), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_RawGameController_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_RawGameController_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_RawGameController_Static) },
        { }
    };

    static PyType_Spec type_spec_RawGameController_Static =
    {
        "winrt._winrt_windows_gaming_input.RawGameController_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_RawGameController_Static
    };

    // ----- UINavigationController class --------------------

    static PyObject* _new_UINavigationController(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Gaming::Input::UINavigationController>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Gaming::Input::UINavigationController>::type_name);
        return nullptr;
    }

    static void _dealloc_UINavigationController(py::wrapper::Windows::Gaming::Input::UINavigationController* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* UINavigationController_FromGameController(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Gaming.Input.UINavigationController", L"FromGameController", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Gaming::Input::IGameController>(args, 0);

                return py::convert(winrt::Windows::Gaming::Input::UINavigationController::FromGameController(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* UINavigationController_GetCurrentReading(py::wrapper::Windows::Gaming::Input::UINavigationController* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Gaming.Input.UINavigationController", L"GetCurrentReading", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetCurrentReading());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* UINavigationController_GetOptionalButtonLabel(py::wrapper::Windows::Gaming::Input::UINavigationController* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Gaming.Input.UINavigationController", L"GetOptionalButtonLabel", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Gaming::Input::OptionalUINavigationButtons>(args, 0);

                return py::convert(self->obj.GetOptionalButtonLabel(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* UINavigationController_GetRequiredButtonLabel(py::wrapper::Windows::Gaming::Input::UINavigationController* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Gaming.Input.UINavigationController", L"GetRequiredButtonLabel", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Gaming::Input::RequiredUINavigationButtons>(args, 0);

                return py::convert(self->obj.GetRequiredButtonLabel(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* UINavigationController_TryGetBatteryReport(py::wrapper::Windows::Gaming::Input::UINavigationController* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Gaming.Input.UINavigationController", L"TryGetBatteryReport", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.TryGetBatteryReport());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* UINavigationController_get_Headset(py::wrapper::Windows::Gaming::Input::UINavigationController* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Gaming.Input.UINavigationController", L"Headset"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Headset());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UINavigationController_get_IsWireless(py::wrapper::Windows::Gaming::Input::UINavigationController* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Gaming.Input.UINavigationController", L"IsWireless"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsWireless());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UINavigationController_get_User(py::wrapper::Windows::Gaming::Input::UINavigationController* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Gaming.Input.UINavigationController", L"User"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.User());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UINavigationController_get_UINavigationControllers(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Gaming.Input.UINavigationController", L"UINavigationControllers"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Gaming::Input::UINavigationController::UINavigationControllers());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UINavigationController_add_HeadsetConnected(py::wrapper::Windows::Gaming::Input::UINavigationController* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Gaming.Input.UINavigationController", L"HeadsetConnected"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Gaming::Input::IGameController, winrt::Windows::Gaming::Input::Headset>>(arg);

            return py::convert(self->obj.HeadsetConnected(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UINavigationController_remove_HeadsetConnected(py::wrapper::Windows::Gaming::Input::UINavigationController* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Gaming.Input.UINavigationController", L"HeadsetConnected"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.HeadsetConnected(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UINavigationController_add_HeadsetDisconnected(py::wrapper::Windows::Gaming::Input::UINavigationController* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Gaming.Input.UINavigationController", L"HeadsetDisconnected"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Gaming::Input::IGameController, winrt::Windows::Gaming::Input::Headset>>(arg);

            return py::convert(self->obj.HeadsetDisconnected(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UINavigationController_remove_HeadsetDisconnected(py::wrapper::Windows::Gaming::Input::UINavigationController* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Gaming.Input.UINavigationController", L"HeadsetDisconnected"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.HeadsetDisconnected(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UINavigationController_add_UserChanged(py::wrapper::Windows::Gaming::Input::UINavigationController* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Gaming.Input.UINavigationController", L"UserChanged"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Gaming::Input::IGameController, winrt::Windows::System::UserChangedEventArgs>>(arg);

            return py::convert(self->obj.UserChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UINavigationController_remove_UserChanged(py::wrapper::Windows::Gaming::Input::UINavigationController* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Gaming.Input.UINavigationController", L"UserChanged"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.UserChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UINavigationController_add_UINavigationControllerAdded(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Gaming.Input.UINavigationController", L"UINavigationControllerAdded"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::EventHandler<winrt::Windows::Gaming::Input::UINavigationController>>(arg);

            return py::convert(winrt::Windows::Gaming::Input::UINavigationController::UINavigationControllerAdded(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UINavigationController_remove_UINavigationControllerAdded(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Gaming.Input.UINavigationController", L"UINavigationControllerAdded"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            winrt::Windows::Gaming::Input::UINavigationController::UINavigationControllerAdded(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UINavigationController_add_UINavigationControllerRemoved(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Gaming.Input.UINavigationController", L"UINavigationControllerRemoved"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::EventHandler<winrt::Windows::Gaming::Input::UINavigationController>>(arg);

            return py::convert(winrt::Windows::Gaming::Input::UINavigationController::UINavigationControllerRemoved(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UINavigationController_remove_UINavigationControllerRemoved(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Gaming.Input.UINavigationController", L"UINavigationControllerRemoved"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            winrt::Windows::Gaming::Input::UINavigationController::UINavigationControllerRemoved(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_UINavigationController(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Gaming::Input::UINavigationController>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_UINavigationController(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Gaming::Input::UINavigationController>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_UINavigationController[] = {
        { "get_current_reading", reinterpret_cast<PyCFunction>(UINavigationController_GetCurrentReading), METH_VARARGS, nullptr },
        { "get_optional_button_label", reinterpret_cast<PyCFunction>(UINavigationController_GetOptionalButtonLabel), METH_VARARGS, nullptr },
        { "get_required_button_label", reinterpret_cast<PyCFunction>(UINavigationController_GetRequiredButtonLabel), METH_VARARGS, nullptr },
        { "try_get_battery_report", reinterpret_cast<PyCFunction>(UINavigationController_TryGetBatteryReport), METH_VARARGS, nullptr },
        { "add_headset_connected", reinterpret_cast<PyCFunction>(UINavigationController_add_HeadsetConnected), METH_O, nullptr },
        { "remove_headset_connected", reinterpret_cast<PyCFunction>(UINavigationController_remove_HeadsetConnected), METH_O, nullptr },
        { "add_headset_disconnected", reinterpret_cast<PyCFunction>(UINavigationController_add_HeadsetDisconnected), METH_O, nullptr },
        { "remove_headset_disconnected", reinterpret_cast<PyCFunction>(UINavigationController_remove_HeadsetDisconnected), METH_O, nullptr },
        { "add_user_changed", reinterpret_cast<PyCFunction>(UINavigationController_add_UserChanged), METH_O, nullptr },
        { "remove_user_changed", reinterpret_cast<PyCFunction>(UINavigationController_remove_UserChanged), METH_O, nullptr },
        { "add_u_i_navigation_controller_added", reinterpret_cast<PyCFunction>(UINavigationController_add_UINavigationControllerAdded), METH_O | METH_STATIC, nullptr },
        { "remove_u_i_navigation_controller_added", reinterpret_cast<PyCFunction>(UINavigationController_remove_UINavigationControllerAdded), METH_O | METH_STATIC, nullptr },
        { "add_u_i_navigation_controller_removed", reinterpret_cast<PyCFunction>(UINavigationController_add_UINavigationControllerRemoved), METH_O | METH_STATIC, nullptr },
        { "remove_u_i_navigation_controller_removed", reinterpret_cast<PyCFunction>(UINavigationController_remove_UINavigationControllerRemoved), METH_O | METH_STATIC, nullptr },
        { "_assign_array_", _assign_array_UINavigationController, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_UINavigationController), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_UINavigationController[] = {
        { "headset", reinterpret_cast<getter>(UINavigationController_get_Headset), nullptr, nullptr, nullptr },
        { "is_wireless", reinterpret_cast<getter>(UINavigationController_get_IsWireless), nullptr, nullptr, nullptr },
        { "user", reinterpret_cast<getter>(UINavigationController_get_User), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_UINavigationController[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_UINavigationController) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_UINavigationController) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_UINavigationController) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_UINavigationController) },
        { }
    };

    static PyType_Spec type_spec_UINavigationController = {
        "winrt._winrt_windows_gaming_input.UINavigationController",
        sizeof(py::wrapper::Windows::Gaming::Input::UINavigationController),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_UINavigationController};

    static PyGetSetDef getset_UINavigationController_Static[] = {
        { "u_i_navigation_controllers", reinterpret_cast<getter>(UINavigationController_get_UINavigationControllers), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_UINavigationController_Static[] = {
        { "from_game_controller", reinterpret_cast<PyCFunction>(UINavigationController_FromGameController), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_UINavigationController_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_UINavigationController_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_UINavigationController_Static) },
        { }
    };

    static PyType_Spec type_spec_UINavigationController_Static =
    {
        "winrt._winrt_windows_gaming_input.UINavigationController_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_UINavigationController_Static
    };

    // ----- IGameController interface --------------------

    static PyObject* _new_IGameController(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Gaming::Input::IGameController>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Gaming::Input::IGameController>::type_name);
        return nullptr;
    }

    static void _dealloc_IGameController(py::wrapper::Windows::Gaming::Input::IGameController* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IGameController_get_Headset(py::wrapper::Windows::Gaming::Input::IGameController* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Gaming.Input.IGameController", L"Headset"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Headset());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IGameController_get_IsWireless(py::wrapper::Windows::Gaming::Input::IGameController* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Gaming.Input.IGameController", L"IsWireless"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsWireless());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IGameController_get_User(py::wrapper::Windows::Gaming::Input::IGameController* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Gaming.Input.IGameController", L"User"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.User());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IGameController_add_HeadsetConnected(py::wrapper::Windows::Gaming::Input::IGameController* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Gaming.Input.IGameController", L"HeadsetConnected"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Gaming::Input::IGameController, winrt::Windows::Gaming::Input::Headset>>(arg);

            return py::convert(self->obj.HeadsetConnected(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IGameController_remove_HeadsetConnected(py::wrapper::Windows::Gaming::Input::IGameController* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Gaming.Input.IGameController", L"HeadsetConnected"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.HeadsetConnected(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IGameController_add_HeadsetDisconnected(py::wrapper::Windows::Gaming::Input::IGameController* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Gaming.Input.IGameController", L"HeadsetDisconnected"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Gaming::Input::IGameController, winrt::Windows::Gaming::Input::Headset>>(arg);

            return py::convert(self->obj.HeadsetDisconnected(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IGameController_remove_HeadsetDisconnected(py::wrapper::Windows::Gaming::Input::IGameController* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Gaming.Input.IGameController", L"HeadsetDisconnected"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.HeadsetDisconnected(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IGameController_add_UserChanged(py::wrapper::Windows::Gaming::Input::IGameController* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Gaming.Input.IGameController", L"UserChanged"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Gaming::Input::IGameController, winrt::Windows::System::UserChangedEventArgs>>(arg);

            return py::convert(self->obj.UserChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IGameController_remove_UserChanged(py::wrapper::Windows::Gaming::Input::IGameController* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Gaming.Input.IGameController", L"UserChanged"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.UserChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_IGameController(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Gaming::Input::IGameController>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IGameController(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Gaming::Input::IGameController>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IGameController[] = {
        { "add_headset_connected", reinterpret_cast<PyCFunction>(IGameController_add_HeadsetConnected), METH_O, nullptr },
        { "remove_headset_connected", reinterpret_cast<PyCFunction>(IGameController_remove_HeadsetConnected), METH_O, nullptr },
        { "add_headset_disconnected", reinterpret_cast<PyCFunction>(IGameController_add_HeadsetDisconnected), METH_O, nullptr },
        { "remove_headset_disconnected", reinterpret_cast<PyCFunction>(IGameController_remove_HeadsetDisconnected), METH_O, nullptr },
        { "add_user_changed", reinterpret_cast<PyCFunction>(IGameController_add_UserChanged), METH_O, nullptr },
        { "remove_user_changed", reinterpret_cast<PyCFunction>(IGameController_remove_UserChanged), METH_O, nullptr },
        { "_assign_array_", _assign_array_IGameController, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IGameController), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IGameController[] = {
        { "headset", reinterpret_cast<getter>(IGameController_get_Headset), nullptr, nullptr, nullptr },
        { "is_wireless", reinterpret_cast<getter>(IGameController_get_IsWireless), nullptr, nullptr, nullptr },
        { "user", reinterpret_cast<getter>(IGameController_get_User), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IGameController[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_IGameController) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IGameController) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IGameController) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IGameController) },
        { }
    };

    static PyType_Spec type_spec_IGameController = {
        "winrt._winrt_windows_gaming_input.IGameController",
        sizeof(py::wrapper::Windows::Gaming::Input::IGameController),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IGameController};

    // ----- IGameControllerBatteryInfo interface --------------------

    static PyObject* _new_IGameControllerBatteryInfo(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Gaming::Input::IGameControllerBatteryInfo>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Gaming::Input::IGameControllerBatteryInfo>::type_name);
        return nullptr;
    }

    static void _dealloc_IGameControllerBatteryInfo(py::wrapper::Windows::Gaming::Input::IGameControllerBatteryInfo* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IGameControllerBatteryInfo_TryGetBatteryReport(py::wrapper::Windows::Gaming::Input::IGameControllerBatteryInfo* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Gaming.Input.IGameControllerBatteryInfo", L"TryGetBatteryReport", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.TryGetBatteryReport());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_IGameControllerBatteryInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Gaming::Input::IGameControllerBatteryInfo>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IGameControllerBatteryInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Gaming::Input::IGameControllerBatteryInfo>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IGameControllerBatteryInfo[] = {
        { "try_get_battery_report", reinterpret_cast<PyCFunction>(IGameControllerBatteryInfo_TryGetBatteryReport), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_IGameControllerBatteryInfo, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IGameControllerBatteryInfo), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IGameControllerBatteryInfo[] = {
        { }
    };

    static PyType_Slot _type_slots_IGameControllerBatteryInfo[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_IGameControllerBatteryInfo) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IGameControllerBatteryInfo) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IGameControllerBatteryInfo) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IGameControllerBatteryInfo) },
        { }
    };

    static PyType_Spec type_spec_IGameControllerBatteryInfo = {
        "winrt._winrt_windows_gaming_input.IGameControllerBatteryInfo",
        sizeof(py::wrapper::Windows::Gaming::Input::IGameControllerBatteryInfo),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IGameControllerBatteryInfo};

    // ----- ArcadeStickReading struct --------------------

    winrt_struct_wrapper<winrt::Windows::Gaming::Input::ArcadeStickReading>* _new_ArcadeStickReading(PyTypeObject* subclass, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        auto self = reinterpret_cast<winrt_struct_wrapper<winrt::Windows::Gaming::Input::ArcadeStickReading>*>(subclass->tp_alloc(subclass, 0));

        if (!self)
        {
            return nullptr;
        }

        std::construct_at(&self->obj);

        return self;
    }

    int _init_ArcadeStickReading(winrt_struct_wrapper<winrt::Windows::Gaming::Input::ArcadeStickReading>* self, PyObject* args, PyObject* kwds) noexcept
    {
        auto tuple_size = PyTuple_Size(args);

        if ((tuple_size == 0) && (kwds == nullptr))
        {
            self->obj = {};
            return 0;
        }

        uint64_t _Timestamp{};
        uint32_t _Buttons{};

        static const char* kwlist[] = {"timestamp", "buttons", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "KI", const_cast<char**>(kwlist), &_Timestamp, &_Buttons))
        {
            return -1;
        }

        try
        {
            self->obj = {_Timestamp, static_cast<winrt::Windows::Gaming::Input::ArcadeStickButtons>(_Buttons)};
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static void _dealloc_ArcadeStickReading(py::wrapper::Windows::Gaming::Input::ArcadeStickReading* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_ArcadeStickReading(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Gaming::Input::ArcadeStickReading>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyMethodDef _methods_ArcadeStickReading[] = {
        { "_assign_array_", _assign_array_ArcadeStickReading, METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyObject* ArcadeStickReading_get_Timestamp(py::wrapper::Windows::Gaming::Input::ArcadeStickReading* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Timestamp);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ArcadeStickReading_set_Timestamp(py::wrapper::Windows::Gaming::Input::ArcadeStickReading* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.Timestamp = py::converter<uint64_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ArcadeStickReading_get_Buttons(py::wrapper::Windows::Gaming::Input::ArcadeStickReading* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Buttons);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ArcadeStickReading_set_Buttons(py::wrapper::Windows::Gaming::Input::ArcadeStickReading* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.Buttons = py::converter<winrt::Windows::Gaming::Input::ArcadeStickButtons>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyGetSetDef _getset_ArcadeStickReading[] = {
        { "timestamp", reinterpret_cast<getter>(ArcadeStickReading_get_Timestamp), reinterpret_cast<setter>(ArcadeStickReading_set_Timestamp), nullptr, nullptr },
        { "buttons", reinterpret_cast<getter>(ArcadeStickReading_get_Buttons), reinterpret_cast<setter>(ArcadeStickReading_set_Buttons), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ArcadeStickReading[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ArcadeStickReading) },
        { Py_tp_init, reinterpret_cast<void*>(_init_ArcadeStickReading) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ArcadeStickReading) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ArcadeStickReading) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ArcadeStickReading) },
        { }
    };

    static PyType_Spec type_spec_ArcadeStickReading = {
        "winrt._winrt_windows_gaming_input.ArcadeStickReading",
        sizeof(py::wrapper::Windows::Gaming::Input::ArcadeStickReading),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ArcadeStickReading};

    // ----- FlightStickReading struct --------------------

    winrt_struct_wrapper<winrt::Windows::Gaming::Input::FlightStickReading>* _new_FlightStickReading(PyTypeObject* subclass, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        auto self = reinterpret_cast<winrt_struct_wrapper<winrt::Windows::Gaming::Input::FlightStickReading>*>(subclass->tp_alloc(subclass, 0));

        if (!self)
        {
            return nullptr;
        }

        std::construct_at(&self->obj);

        return self;
    }

    int _init_FlightStickReading(winrt_struct_wrapper<winrt::Windows::Gaming::Input::FlightStickReading>* self, PyObject* args, PyObject* kwds) noexcept
    {
        auto tuple_size = PyTuple_Size(args);

        if ((tuple_size == 0) && (kwds == nullptr))
        {
            self->obj = {};
            return 0;
        }

        uint64_t _Timestamp{};
        uint32_t _Buttons{};
        int32_t _HatSwitch{};
        double _Roll{};
        double _Pitch{};
        double _Yaw{};
        double _Throttle{};

        static const char* kwlist[] = {"timestamp", "buttons", "hat_switch", "roll", "pitch", "yaw", "throttle", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "KIidddd", const_cast<char**>(kwlist), &_Timestamp, &_Buttons, &_HatSwitch, &_Roll, &_Pitch, &_Yaw, &_Throttle))
        {
            return -1;
        }

        try
        {
            self->obj = {_Timestamp, static_cast<winrt::Windows::Gaming::Input::FlightStickButtons>(_Buttons), static_cast<winrt::Windows::Gaming::Input::GameControllerSwitchPosition>(_HatSwitch), _Roll, _Pitch, _Yaw, _Throttle};
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static void _dealloc_FlightStickReading(py::wrapper::Windows::Gaming::Input::FlightStickReading* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_FlightStickReading(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Gaming::Input::FlightStickReading>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyMethodDef _methods_FlightStickReading[] = {
        { "_assign_array_", _assign_array_FlightStickReading, METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyObject* FlightStickReading_get_Timestamp(py::wrapper::Windows::Gaming::Input::FlightStickReading* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Timestamp);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FlightStickReading_set_Timestamp(py::wrapper::Windows::Gaming::Input::FlightStickReading* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.Timestamp = py::converter<uint64_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* FlightStickReading_get_Buttons(py::wrapper::Windows::Gaming::Input::FlightStickReading* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Buttons);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FlightStickReading_set_Buttons(py::wrapper::Windows::Gaming::Input::FlightStickReading* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.Buttons = py::converter<winrt::Windows::Gaming::Input::FlightStickButtons>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* FlightStickReading_get_HatSwitch(py::wrapper::Windows::Gaming::Input::FlightStickReading* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.HatSwitch);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FlightStickReading_set_HatSwitch(py::wrapper::Windows::Gaming::Input::FlightStickReading* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.HatSwitch = py::converter<winrt::Windows::Gaming::Input::GameControllerSwitchPosition>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* FlightStickReading_get_Roll(py::wrapper::Windows::Gaming::Input::FlightStickReading* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Roll);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FlightStickReading_set_Roll(py::wrapper::Windows::Gaming::Input::FlightStickReading* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.Roll = py::converter<double>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* FlightStickReading_get_Pitch(py::wrapper::Windows::Gaming::Input::FlightStickReading* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Pitch);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FlightStickReading_set_Pitch(py::wrapper::Windows::Gaming::Input::FlightStickReading* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.Pitch = py::converter<double>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* FlightStickReading_get_Yaw(py::wrapper::Windows::Gaming::Input::FlightStickReading* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Yaw);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FlightStickReading_set_Yaw(py::wrapper::Windows::Gaming::Input::FlightStickReading* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.Yaw = py::converter<double>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* FlightStickReading_get_Throttle(py::wrapper::Windows::Gaming::Input::FlightStickReading* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Throttle);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FlightStickReading_set_Throttle(py::wrapper::Windows::Gaming::Input::FlightStickReading* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.Throttle = py::converter<double>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyGetSetDef _getset_FlightStickReading[] = {
        { "timestamp", reinterpret_cast<getter>(FlightStickReading_get_Timestamp), reinterpret_cast<setter>(FlightStickReading_set_Timestamp), nullptr, nullptr },
        { "buttons", reinterpret_cast<getter>(FlightStickReading_get_Buttons), reinterpret_cast<setter>(FlightStickReading_set_Buttons), nullptr, nullptr },
        { "hat_switch", reinterpret_cast<getter>(FlightStickReading_get_HatSwitch), reinterpret_cast<setter>(FlightStickReading_set_HatSwitch), nullptr, nullptr },
        { "roll", reinterpret_cast<getter>(FlightStickReading_get_Roll), reinterpret_cast<setter>(FlightStickReading_set_Roll), nullptr, nullptr },
        { "pitch", reinterpret_cast<getter>(FlightStickReading_get_Pitch), reinterpret_cast<setter>(FlightStickReading_set_Pitch), nullptr, nullptr },
        { "yaw", reinterpret_cast<getter>(FlightStickReading_get_Yaw), reinterpret_cast<setter>(FlightStickReading_set_Yaw), nullptr, nullptr },
        { "throttle", reinterpret_cast<getter>(FlightStickReading_get_Throttle), reinterpret_cast<setter>(FlightStickReading_set_Throttle), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_FlightStickReading[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_FlightStickReading) },
        { Py_tp_init, reinterpret_cast<void*>(_init_FlightStickReading) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_FlightStickReading) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_FlightStickReading) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_FlightStickReading) },
        { }
    };

    static PyType_Spec type_spec_FlightStickReading = {
        "winrt._winrt_windows_gaming_input.FlightStickReading",
        sizeof(py::wrapper::Windows::Gaming::Input::FlightStickReading),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_FlightStickReading};

    // ----- GamepadReading struct --------------------

    winrt_struct_wrapper<winrt::Windows::Gaming::Input::GamepadReading>* _new_GamepadReading(PyTypeObject* subclass, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        auto self = reinterpret_cast<winrt_struct_wrapper<winrt::Windows::Gaming::Input::GamepadReading>*>(subclass->tp_alloc(subclass, 0));

        if (!self)
        {
            return nullptr;
        }

        std::construct_at(&self->obj);

        return self;
    }

    int _init_GamepadReading(winrt_struct_wrapper<winrt::Windows::Gaming::Input::GamepadReading>* self, PyObject* args, PyObject* kwds) noexcept
    {
        auto tuple_size = PyTuple_Size(args);

        if ((tuple_size == 0) && (kwds == nullptr))
        {
            self->obj = {};
            return 0;
        }

        uint64_t _Timestamp{};
        uint32_t _Buttons{};
        double _LeftTrigger{};
        double _RightTrigger{};
        double _LeftThumbstickX{};
        double _LeftThumbstickY{};
        double _RightThumbstickX{};
        double _RightThumbstickY{};

        static const char* kwlist[] = {"timestamp", "buttons", "left_trigger", "right_trigger", "left_thumbstick_x", "left_thumbstick_y", "right_thumbstick_x", "right_thumbstick_y", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "KIdddddd", const_cast<char**>(kwlist), &_Timestamp, &_Buttons, &_LeftTrigger, &_RightTrigger, &_LeftThumbstickX, &_LeftThumbstickY, &_RightThumbstickX, &_RightThumbstickY))
        {
            return -1;
        }

        try
        {
            self->obj = {_Timestamp, static_cast<winrt::Windows::Gaming::Input::GamepadButtons>(_Buttons), _LeftTrigger, _RightTrigger, _LeftThumbstickX, _LeftThumbstickY, _RightThumbstickX, _RightThumbstickY};
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static void _dealloc_GamepadReading(py::wrapper::Windows::Gaming::Input::GamepadReading* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_GamepadReading(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Gaming::Input::GamepadReading>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyMethodDef _methods_GamepadReading[] = {
        { "_assign_array_", _assign_array_GamepadReading, METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyObject* GamepadReading_get_Timestamp(py::wrapper::Windows::Gaming::Input::GamepadReading* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Timestamp);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GamepadReading_set_Timestamp(py::wrapper::Windows::Gaming::Input::GamepadReading* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.Timestamp = py::converter<uint64_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* GamepadReading_get_Buttons(py::wrapper::Windows::Gaming::Input::GamepadReading* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Buttons);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GamepadReading_set_Buttons(py::wrapper::Windows::Gaming::Input::GamepadReading* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.Buttons = py::converter<winrt::Windows::Gaming::Input::GamepadButtons>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* GamepadReading_get_LeftTrigger(py::wrapper::Windows::Gaming::Input::GamepadReading* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.LeftTrigger);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GamepadReading_set_LeftTrigger(py::wrapper::Windows::Gaming::Input::GamepadReading* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.LeftTrigger = py::converter<double>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* GamepadReading_get_RightTrigger(py::wrapper::Windows::Gaming::Input::GamepadReading* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RightTrigger);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GamepadReading_set_RightTrigger(py::wrapper::Windows::Gaming::Input::GamepadReading* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.RightTrigger = py::converter<double>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* GamepadReading_get_LeftThumbstickX(py::wrapper::Windows::Gaming::Input::GamepadReading* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.LeftThumbstickX);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GamepadReading_set_LeftThumbstickX(py::wrapper::Windows::Gaming::Input::GamepadReading* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.LeftThumbstickX = py::converter<double>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* GamepadReading_get_LeftThumbstickY(py::wrapper::Windows::Gaming::Input::GamepadReading* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.LeftThumbstickY);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GamepadReading_set_LeftThumbstickY(py::wrapper::Windows::Gaming::Input::GamepadReading* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.LeftThumbstickY = py::converter<double>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* GamepadReading_get_RightThumbstickX(py::wrapper::Windows::Gaming::Input::GamepadReading* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RightThumbstickX);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GamepadReading_set_RightThumbstickX(py::wrapper::Windows::Gaming::Input::GamepadReading* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.RightThumbstickX = py::converter<double>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* GamepadReading_get_RightThumbstickY(py::wrapper::Windows::Gaming::Input::GamepadReading* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RightThumbstickY);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GamepadReading_set_RightThumbstickY(py::wrapper::Windows::Gaming::Input::GamepadReading* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.RightThumbstickY = py::converter<double>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyGetSetDef _getset_GamepadReading[] = {
        { "timestamp", reinterpret_cast<getter>(GamepadReading_get_Timestamp), reinterpret_cast<setter>(GamepadReading_set_Timestamp), nullptr, nullptr },
        { "buttons", reinterpret_cast<getter>(GamepadReading_get_Buttons), reinterpret_cast<setter>(GamepadReading_set_Buttons), nullptr, nullptr },
        { "left_trigger", reinterpret_cast<getter>(GamepadReading_get_LeftTrigger), reinterpret_cast<setter>(GamepadReading_set_LeftTrigger), nullptr, nullptr },
        { "right_trigger", reinterpret_cast<getter>(GamepadReading_get_RightTrigger), reinterpret_cast<setter>(GamepadReading_set_RightTrigger), nullptr, nullptr },
        { "left_thumbstick_x", reinterpret_cast<getter>(GamepadReading_get_LeftThumbstickX), reinterpret_cast<setter>(GamepadReading_set_LeftThumbstickX), nullptr, nullptr },
        { "left_thumbstick_y", reinterpret_cast<getter>(GamepadReading_get_LeftThumbstickY), reinterpret_cast<setter>(GamepadReading_set_LeftThumbstickY), nullptr, nullptr },
        { "right_thumbstick_x", reinterpret_cast<getter>(GamepadReading_get_RightThumbstickX), reinterpret_cast<setter>(GamepadReading_set_RightThumbstickX), nullptr, nullptr },
        { "right_thumbstick_y", reinterpret_cast<getter>(GamepadReading_get_RightThumbstickY), reinterpret_cast<setter>(GamepadReading_set_RightThumbstickY), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_GamepadReading[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_GamepadReading) },
        { Py_tp_init, reinterpret_cast<void*>(_init_GamepadReading) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_GamepadReading) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_GamepadReading) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_GamepadReading) },
        { }
    };

    static PyType_Spec type_spec_GamepadReading = {
        "winrt._winrt_windows_gaming_input.GamepadReading",
        sizeof(py::wrapper::Windows::Gaming::Input::GamepadReading),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_GamepadReading};

    // ----- GamepadVibration struct --------------------

    winrt_struct_wrapper<winrt::Windows::Gaming::Input::GamepadVibration>* _new_GamepadVibration(PyTypeObject* subclass, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        auto self = reinterpret_cast<winrt_struct_wrapper<winrt::Windows::Gaming::Input::GamepadVibration>*>(subclass->tp_alloc(subclass, 0));

        if (!self)
        {
            return nullptr;
        }

        std::construct_at(&self->obj);

        return self;
    }

    int _init_GamepadVibration(winrt_struct_wrapper<winrt::Windows::Gaming::Input::GamepadVibration>* self, PyObject* args, PyObject* kwds) noexcept
    {
        auto tuple_size = PyTuple_Size(args);

        if ((tuple_size == 0) && (kwds == nullptr))
        {
            self->obj = {};
            return 0;
        }

        double _LeftMotor{};
        double _RightMotor{};
        double _LeftTrigger{};
        double _RightTrigger{};

        static const char* kwlist[] = {"left_motor", "right_motor", "left_trigger", "right_trigger", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "dddd", const_cast<char**>(kwlist), &_LeftMotor, &_RightMotor, &_LeftTrigger, &_RightTrigger))
        {
            return -1;
        }

        try
        {
            self->obj = {_LeftMotor, _RightMotor, _LeftTrigger, _RightTrigger};
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static void _dealloc_GamepadVibration(py::wrapper::Windows::Gaming::Input::GamepadVibration* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_GamepadVibration(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Gaming::Input::GamepadVibration>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyMethodDef _methods_GamepadVibration[] = {
        { "_assign_array_", _assign_array_GamepadVibration, METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyObject* GamepadVibration_get_LeftMotor(py::wrapper::Windows::Gaming::Input::GamepadVibration* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.LeftMotor);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GamepadVibration_set_LeftMotor(py::wrapper::Windows::Gaming::Input::GamepadVibration* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.LeftMotor = py::converter<double>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* GamepadVibration_get_RightMotor(py::wrapper::Windows::Gaming::Input::GamepadVibration* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RightMotor);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GamepadVibration_set_RightMotor(py::wrapper::Windows::Gaming::Input::GamepadVibration* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.RightMotor = py::converter<double>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* GamepadVibration_get_LeftTrigger(py::wrapper::Windows::Gaming::Input::GamepadVibration* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.LeftTrigger);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GamepadVibration_set_LeftTrigger(py::wrapper::Windows::Gaming::Input::GamepadVibration* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.LeftTrigger = py::converter<double>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* GamepadVibration_get_RightTrigger(py::wrapper::Windows::Gaming::Input::GamepadVibration* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RightTrigger);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GamepadVibration_set_RightTrigger(py::wrapper::Windows::Gaming::Input::GamepadVibration* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.RightTrigger = py::converter<double>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyGetSetDef _getset_GamepadVibration[] = {
        { "left_motor", reinterpret_cast<getter>(GamepadVibration_get_LeftMotor), reinterpret_cast<setter>(GamepadVibration_set_LeftMotor), nullptr, nullptr },
        { "right_motor", reinterpret_cast<getter>(GamepadVibration_get_RightMotor), reinterpret_cast<setter>(GamepadVibration_set_RightMotor), nullptr, nullptr },
        { "left_trigger", reinterpret_cast<getter>(GamepadVibration_get_LeftTrigger), reinterpret_cast<setter>(GamepadVibration_set_LeftTrigger), nullptr, nullptr },
        { "right_trigger", reinterpret_cast<getter>(GamepadVibration_get_RightTrigger), reinterpret_cast<setter>(GamepadVibration_set_RightTrigger), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_GamepadVibration[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_GamepadVibration) },
        { Py_tp_init, reinterpret_cast<void*>(_init_GamepadVibration) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_GamepadVibration) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_GamepadVibration) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_GamepadVibration) },
        { }
    };

    static PyType_Spec type_spec_GamepadVibration = {
        "winrt._winrt_windows_gaming_input.GamepadVibration",
        sizeof(py::wrapper::Windows::Gaming::Input::GamepadVibration),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_GamepadVibration};

    // ----- RacingWheelReading struct --------------------

    winrt_struct_wrapper<winrt::Windows::Gaming::Input::RacingWheelReading>* _new_RacingWheelReading(PyTypeObject* subclass, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        auto self = reinterpret_cast<winrt_struct_wrapper<winrt::Windows::Gaming::Input::RacingWheelReading>*>(subclass->tp_alloc(subclass, 0));

        if (!self)
        {
            return nullptr;
        }

        std::construct_at(&self->obj);

        return self;
    }

    int _init_RacingWheelReading(winrt_struct_wrapper<winrt::Windows::Gaming::Input::RacingWheelReading>* self, PyObject* args, PyObject* kwds) noexcept
    {
        auto tuple_size = PyTuple_Size(args);

        if ((tuple_size == 0) && (kwds == nullptr))
        {
            self->obj = {};
            return 0;
        }

        uint64_t _Timestamp{};
        uint32_t _Buttons{};
        int32_t _PatternShifterGear{};
        double _Wheel{};
        double _Throttle{};
        double _Brake{};
        double _Clutch{};
        double _Handbrake{};

        static const char* kwlist[] = {"timestamp", "buttons", "pattern_shifter_gear", "wheel", "throttle", "brake", "clutch", "handbrake", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "KIiddddd", const_cast<char**>(kwlist), &_Timestamp, &_Buttons, &_PatternShifterGear, &_Wheel, &_Throttle, &_Brake, &_Clutch, &_Handbrake))
        {
            return -1;
        }

        try
        {
            self->obj = {_Timestamp, static_cast<winrt::Windows::Gaming::Input::RacingWheelButtons>(_Buttons), _PatternShifterGear, _Wheel, _Throttle, _Brake, _Clutch, _Handbrake};
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static void _dealloc_RacingWheelReading(py::wrapper::Windows::Gaming::Input::RacingWheelReading* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_RacingWheelReading(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Gaming::Input::RacingWheelReading>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyMethodDef _methods_RacingWheelReading[] = {
        { "_assign_array_", _assign_array_RacingWheelReading, METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyObject* RacingWheelReading_get_Timestamp(py::wrapper::Windows::Gaming::Input::RacingWheelReading* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Timestamp);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RacingWheelReading_set_Timestamp(py::wrapper::Windows::Gaming::Input::RacingWheelReading* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.Timestamp = py::converter<uint64_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* RacingWheelReading_get_Buttons(py::wrapper::Windows::Gaming::Input::RacingWheelReading* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Buttons);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RacingWheelReading_set_Buttons(py::wrapper::Windows::Gaming::Input::RacingWheelReading* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.Buttons = py::converter<winrt::Windows::Gaming::Input::RacingWheelButtons>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* RacingWheelReading_get_PatternShifterGear(py::wrapper::Windows::Gaming::Input::RacingWheelReading* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PatternShifterGear);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RacingWheelReading_set_PatternShifterGear(py::wrapper::Windows::Gaming::Input::RacingWheelReading* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.PatternShifterGear = py::converter<int32_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* RacingWheelReading_get_Wheel(py::wrapper::Windows::Gaming::Input::RacingWheelReading* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Wheel);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RacingWheelReading_set_Wheel(py::wrapper::Windows::Gaming::Input::RacingWheelReading* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.Wheel = py::converter<double>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* RacingWheelReading_get_Throttle(py::wrapper::Windows::Gaming::Input::RacingWheelReading* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Throttle);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RacingWheelReading_set_Throttle(py::wrapper::Windows::Gaming::Input::RacingWheelReading* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.Throttle = py::converter<double>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* RacingWheelReading_get_Brake(py::wrapper::Windows::Gaming::Input::RacingWheelReading* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Brake);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RacingWheelReading_set_Brake(py::wrapper::Windows::Gaming::Input::RacingWheelReading* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.Brake = py::converter<double>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* RacingWheelReading_get_Clutch(py::wrapper::Windows::Gaming::Input::RacingWheelReading* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Clutch);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RacingWheelReading_set_Clutch(py::wrapper::Windows::Gaming::Input::RacingWheelReading* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.Clutch = py::converter<double>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* RacingWheelReading_get_Handbrake(py::wrapper::Windows::Gaming::Input::RacingWheelReading* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Handbrake);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RacingWheelReading_set_Handbrake(py::wrapper::Windows::Gaming::Input::RacingWheelReading* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.Handbrake = py::converter<double>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyGetSetDef _getset_RacingWheelReading[] = {
        { "timestamp", reinterpret_cast<getter>(RacingWheelReading_get_Timestamp), reinterpret_cast<setter>(RacingWheelReading_set_Timestamp), nullptr, nullptr },
        { "buttons", reinterpret_cast<getter>(RacingWheelReading_get_Buttons), reinterpret_cast<setter>(RacingWheelReading_set_Buttons), nullptr, nullptr },
        { "pattern_shifter_gear", reinterpret_cast<getter>(RacingWheelReading_get_PatternShifterGear), reinterpret_cast<setter>(RacingWheelReading_set_PatternShifterGear), nullptr, nullptr },
        { "wheel", reinterpret_cast<getter>(RacingWheelReading_get_Wheel), reinterpret_cast<setter>(RacingWheelReading_set_Wheel), nullptr, nullptr },
        { "throttle", reinterpret_cast<getter>(RacingWheelReading_get_Throttle), reinterpret_cast<setter>(RacingWheelReading_set_Throttle), nullptr, nullptr },
        { "brake", reinterpret_cast<getter>(RacingWheelReading_get_Brake), reinterpret_cast<setter>(RacingWheelReading_set_Brake), nullptr, nullptr },
        { "clutch", reinterpret_cast<getter>(RacingWheelReading_get_Clutch), reinterpret_cast<setter>(RacingWheelReading_set_Clutch), nullptr, nullptr },
        { "handbrake", reinterpret_cast<getter>(RacingWheelReading_get_Handbrake), reinterpret_cast<setter>(RacingWheelReading_set_Handbrake), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_RacingWheelReading[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_RacingWheelReading) },
        { Py_tp_init, reinterpret_cast<void*>(_init_RacingWheelReading) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_RacingWheelReading) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_RacingWheelReading) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_RacingWheelReading) },
        { }
    };

    static PyType_Spec type_spec_RacingWheelReading = {
        "winrt._winrt_windows_gaming_input.RacingWheelReading",
        sizeof(py::wrapper::Windows::Gaming::Input::RacingWheelReading),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RacingWheelReading};

    // ----- UINavigationReading struct --------------------

    winrt_struct_wrapper<winrt::Windows::Gaming::Input::UINavigationReading>* _new_UINavigationReading(PyTypeObject* subclass, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        auto self = reinterpret_cast<winrt_struct_wrapper<winrt::Windows::Gaming::Input::UINavigationReading>*>(subclass->tp_alloc(subclass, 0));

        if (!self)
        {
            return nullptr;
        }

        std::construct_at(&self->obj);

        return self;
    }

    int _init_UINavigationReading(winrt_struct_wrapper<winrt::Windows::Gaming::Input::UINavigationReading>* self, PyObject* args, PyObject* kwds) noexcept
    {
        auto tuple_size = PyTuple_Size(args);

        if ((tuple_size == 0) && (kwds == nullptr))
        {
            self->obj = {};
            return 0;
        }

        uint64_t _Timestamp{};
        uint32_t _RequiredButtons{};
        uint32_t _OptionalButtons{};

        static const char* kwlist[] = {"timestamp", "required_buttons", "optional_buttons", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "KII", const_cast<char**>(kwlist), &_Timestamp, &_RequiredButtons, &_OptionalButtons))
        {
            return -1;
        }

        try
        {
            self->obj = {_Timestamp, static_cast<winrt::Windows::Gaming::Input::RequiredUINavigationButtons>(_RequiredButtons), static_cast<winrt::Windows::Gaming::Input::OptionalUINavigationButtons>(_OptionalButtons)};
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static void _dealloc_UINavigationReading(py::wrapper::Windows::Gaming::Input::UINavigationReading* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_UINavigationReading(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Gaming::Input::UINavigationReading>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyMethodDef _methods_UINavigationReading[] = {
        { "_assign_array_", _assign_array_UINavigationReading, METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyObject* UINavigationReading_get_Timestamp(py::wrapper::Windows::Gaming::Input::UINavigationReading* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Timestamp);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int UINavigationReading_set_Timestamp(py::wrapper::Windows::Gaming::Input::UINavigationReading* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.Timestamp = py::converter<uint64_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* UINavigationReading_get_RequiredButtons(py::wrapper::Windows::Gaming::Input::UINavigationReading* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RequiredButtons);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int UINavigationReading_set_RequiredButtons(py::wrapper::Windows::Gaming::Input::UINavigationReading* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.RequiredButtons = py::converter<winrt::Windows::Gaming::Input::RequiredUINavigationButtons>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* UINavigationReading_get_OptionalButtons(py::wrapper::Windows::Gaming::Input::UINavigationReading* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.OptionalButtons);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int UINavigationReading_set_OptionalButtons(py::wrapper::Windows::Gaming::Input::UINavigationReading* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.OptionalButtons = py::converter<winrt::Windows::Gaming::Input::OptionalUINavigationButtons>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyGetSetDef _getset_UINavigationReading[] = {
        { "timestamp", reinterpret_cast<getter>(UINavigationReading_get_Timestamp), reinterpret_cast<setter>(UINavigationReading_set_Timestamp), nullptr, nullptr },
        { "required_buttons", reinterpret_cast<getter>(UINavigationReading_get_RequiredButtons), reinterpret_cast<setter>(UINavigationReading_set_RequiredButtons), nullptr, nullptr },
        { "optional_buttons", reinterpret_cast<getter>(UINavigationReading_get_OptionalButtons), reinterpret_cast<setter>(UINavigationReading_set_OptionalButtons), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_UINavigationReading[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_UINavigationReading) },
        { Py_tp_init, reinterpret_cast<void*>(_init_UINavigationReading) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_UINavigationReading) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_UINavigationReading) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_UINavigationReading) },
        { }
    };

    static PyType_Spec type_spec_UINavigationReading = {
        "winrt._winrt_windows_gaming_input.UINavigationReading",
        sizeof(py::wrapper::Windows::Gaming::Input::UINavigationReading),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_UINavigationReading};

    // ----- Windows.Gaming.Input Initialization --------------------

    PyDoc_STRVAR(module_doc, "Windows.Gaming.Input");

    static PyModuleDef module_def = {
        PyModuleDef_HEAD_INIT,
        "_winrt_windows_gaming_input",
        module_doc,
        0,
        nullptr,
        nullptr,
        nullptr,
        nullptr,
        nullptr};
} // py::cpp::Windows::Gaming::Input

PyMODINIT_FUNC PyInit__winrt_windows_gaming_input(void) noexcept
{
    using namespace py::cpp::Windows::Gaming::Input;

    if (py::import_winrt_runtime() == -1)
    {
        return nullptr;
    }

    py::pyobj_handle module{PyModule_Create(&module_def)};

    if (!module)
    {
        return nullptr;
    }

    auto object_type = py::get_object_type();
    if (!object_type)
    {
        return nullptr;
    }

    py::pyobj_handle object_bases{PyTuple_Pack(1, object_type)};

    if (!object_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_ArcadeStick_Static{PyType_FromSpec(&type_spec_ArcadeStick_Static)};
    if (!type_ArcadeStick_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ArcadeStick, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_ArcadeStick_Static.get())) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_FlightStick_Static{PyType_FromSpec(&type_spec_FlightStick_Static)};
    if (!type_FlightStick_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_FlightStick, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_FlightStick_Static.get())) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_Gamepad_Static{PyType_FromSpec(&type_spec_Gamepad_Static)};
    if (!type_Gamepad_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_Gamepad, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_Gamepad_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_Headset, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_RacingWheel_Static{PyType_FromSpec(&type_spec_RacingWheel_Static)};
    if (!type_RacingWheel_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_RacingWheel, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_RacingWheel_Static.get())) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_RawGameController_Static{PyType_FromSpec(&type_spec_RawGameController_Static)};
    if (!type_RawGameController_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_RawGameController, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_RawGameController_Static.get())) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_UINavigationController_Static{PyType_FromSpec(&type_spec_UINavigationController_Static)};
    if (!type_UINavigationController_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_UINavigationController, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_UINavigationController_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_IGameController, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_IGameControllerBatteryInfo, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ArcadeStickReading, nullptr, nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_FlightStickReading, nullptr, nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_GamepadReading, nullptr, nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_GamepadVibration, nullptr, nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_RacingWheelReading, nullptr, nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_UINavigationReading, nullptr, nullptr) == -1)
    {
        return nullptr;
    }


    return module.detach();
}
