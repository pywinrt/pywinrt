# WARNING: Please don't edit this file. It was generated by Python/WinRT v2.0.0-beta.2

import datetime
import sys
import types
import typing
import uuid as _uuid
from builtins import property as _property

import winrt._winrt
import winrt.system
import winrt.windows.foundation
import winrt.windows.foundation.collections
import winrt.windows.foundation.numerics
import winrt.windows.storage.streams
import winrt.windows.ui
import winrt.windows.ui.core
import winrt.windows.ui.input

from winrt.windows.ui.input.inking import HandwritingLineHeight, InkDrawingAttributesKind, InkHighContrastAdjustment, InkInputProcessingMode, InkInputRightDragAction, InkManipulationMode, InkPersistenceFormat, InkPresenterPredefinedConfiguration, InkPresenterStencilKind, InkRecognitionTarget, PenHandedness, PenTipShape

Self = typing.TypeVar('Self')

@typing.final
class InkDrawingAttributes_Static(type):
    def create_for_pencil(cls) -> typing.Optional[InkDrawingAttributes]: ...

@typing.final
class InkDrawingAttributes(winrt.system.Object, metaclass=InkDrawingAttributes_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> InkDrawingAttributes: ...
    def __new__(cls: typing.Type[InkDrawingAttributes]) -> InkDrawingAttributes:...
    @_property
    def size(self) -> winrt.windows.foundation.Size: ...
    @size.setter
    def size(self, value: winrt.windows.foundation.Size) -> None: ...
    @_property
    def pen_tip(self) -> PenTipShape: ...
    @pen_tip.setter
    def pen_tip(self, value: PenTipShape) -> None: ...
    @_property
    def ignore_pressure(self) -> bool: ...
    @ignore_pressure.setter
    def ignore_pressure(self, value: bool) -> None: ...
    @_property
    def fit_to_curve(self) -> bool: ...
    @fit_to_curve.setter
    def fit_to_curve(self, value: bool) -> None: ...
    @_property
    def color(self) -> winrt.windows.ui.Color: ...
    @color.setter
    def color(self, value: winrt.windows.ui.Color) -> None: ...
    @_property
    def pen_tip_transform(self) -> winrt.windows.foundation.numerics.Matrix3x2: ...
    @pen_tip_transform.setter
    def pen_tip_transform(self, value: winrt.windows.foundation.numerics.Matrix3x2) -> None: ...
    @_property
    def draw_as_highlighter(self) -> bool: ...
    @draw_as_highlighter.setter
    def draw_as_highlighter(self, value: bool) -> None: ...
    @_property
    def kind(self) -> InkDrawingAttributesKind: ...
    @_property
    def pencil_properties(self) -> typing.Optional[InkDrawingAttributesPencilProperties]: ...
    @_property
    def ignore_tilt(self) -> bool: ...
    @ignore_tilt.setter
    def ignore_tilt(self, value: bool) -> None: ...
    @_property
    def modeler_attributes(self) -> typing.Optional[InkModelerAttributes]: ...

@typing.final
class InkDrawingAttributesPencilProperties(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> InkDrawingAttributesPencilProperties: ...
    @_property
    def opacity(self) -> winrt.system.Double: ...
    @opacity.setter
    def opacity(self, value: winrt.system.Double) -> None: ...

@typing.final
class InkInputConfiguration(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> InkInputConfiguration: ...
    @_property
    def is_primary_barrel_button_input_enabled(self) -> bool: ...
    @is_primary_barrel_button_input_enabled.setter
    def is_primary_barrel_button_input_enabled(self, value: bool) -> None: ...
    @_property
    def is_eraser_input_enabled(self) -> bool: ...
    @is_eraser_input_enabled.setter
    def is_eraser_input_enabled(self, value: bool) -> None: ...
    @_property
    def is_pen_haptic_feedback_enabled(self) -> bool: ...
    @is_pen_haptic_feedback_enabled.setter
    def is_pen_haptic_feedback_enabled(self, value: bool) -> None: ...

@typing.final
class InkInputProcessingConfiguration(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> InkInputProcessingConfiguration: ...
    @_property
    def right_drag_action(self) -> InkInputRightDragAction: ...
    @right_drag_action.setter
    def right_drag_action(self, value: InkInputRightDragAction) -> None: ...
    @_property
    def mode(self) -> InkInputProcessingMode: ...
    @mode.setter
    def mode(self, value: InkInputProcessingMode) -> None: ...

@typing.final
class InkManager(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> InkManager: ...
    def __new__(cls: typing.Type[InkManager]) -> InkManager:...
    def add_stroke(self, stroke: typing.Optional[InkStroke], /) -> None: ...
    def can_paste_from_clipboard(self) -> bool: ...
    def copy_selected_to_clipboard(self) -> None: ...
    def delete_selected(self) -> winrt.windows.foundation.Rect: ...
    def get_recognition_results(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[InkRecognitionResult]]: ...
    def get_recognizers(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[InkRecognizer]]: ...
    def get_strokes(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[InkStroke]]: ...
    def load_async(self, input_stream: typing.Optional[winrt.windows.storage.streams.IInputStream], /) -> winrt.windows.foundation.IAsyncActionWithProgress[winrt.system.UInt64]: ...
    def move_selected(self, translation: winrt.windows.foundation.Point, /) -> winrt.windows.foundation.Rect: ...
    def paste_from_clipboard(self, position: winrt.windows.foundation.Point, /) -> winrt.windows.foundation.Rect: ...
    def process_pointer_down(self, pointer_point: typing.Optional[winrt.windows.ui.input.PointerPoint], /) -> None: ...
    def process_pointer_up(self, pointer_point: typing.Optional[winrt.windows.ui.input.PointerPoint], /) -> winrt.windows.foundation.Rect: ...
    def process_pointer_update(self, pointer_point: typing.Optional[winrt.windows.ui.input.PointerPoint], /) -> typing.Optional[winrt.system.Object]: ...
    @typing.overload
    def recognize_async(self, recognition_target: InkRecognitionTarget, /) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.foundation.collections.IVectorView[InkRecognitionResult]]: ...
    @typing.overload
    def recognize_async(self, stroke_collection: typing.Optional[InkStrokeContainer], recognition_target: InkRecognitionTarget, /) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.foundation.collections.IVectorView[InkRecognitionResult]]: ...
    def save_async(self, output_stream: typing.Optional[winrt.windows.storage.streams.IOutputStream], /) -> winrt.windows.foundation.IAsyncOperationWithProgress[winrt.system.UInt32, winrt.system.UInt32]: ...
    def select_with_line(self, from_: winrt.windows.foundation.Point, to: winrt.windows.foundation.Point, /) -> winrt.windows.foundation.Rect: ...
    def select_with_poly_line(self, polyline: typing.Iterable[winrt.windows.foundation.Point], /) -> winrt.windows.foundation.Rect: ...
    def set_default_drawing_attributes(self, drawing_attributes: typing.Optional[InkDrawingAttributes], /) -> None: ...
    def set_default_recognizer(self, recognizer: typing.Optional[InkRecognizer], /) -> None: ...
    def update_recognition_results(self, recognition_results: winrt.windows.foundation.collections.IVectorView[InkRecognitionResult], /) -> None: ...
    @_property
    def mode(self) -> InkManipulationMode: ...
    @mode.setter
    def mode(self, value: InkManipulationMode) -> None: ...
    @_property
    def bounding_rect(self) -> winrt.windows.foundation.Rect: ...

@typing.final
class InkModelerAttributes(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> InkModelerAttributes: ...
    @_property
    def scaling_factor(self) -> winrt.system.Single: ...
    @scaling_factor.setter
    def scaling_factor(self, value: winrt.system.Single) -> None: ...
    @_property
    def prediction_time(self) -> datetime.timedelta: ...
    @prediction_time.setter
    def prediction_time(self, value: datetime.timedelta) -> None: ...
    @_property
    def use_velocity_based_pressure(self) -> bool: ...
    @use_velocity_based_pressure.setter
    def use_velocity_based_pressure(self, value: bool) -> None: ...

@typing.final
class InkPoint(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> InkPoint: ...
    @typing.overload
    def __new__(cls: typing.Type[InkPoint], position: winrt.windows.foundation.Point, pressure: winrt.system.Single, tilt_x: winrt.system.Single, tilt_y: winrt.system.Single, timestamp: winrt.system.UInt64) -> InkPoint:...
    @typing.overload
    def __new__(cls: typing.Type[InkPoint], position: winrt.windows.foundation.Point, pressure: winrt.system.Single) -> InkPoint:...
    @_property
    def position(self) -> winrt.windows.foundation.Point: ...
    @_property
    def pressure(self) -> winrt.system.Single: ...
    @_property
    def tilt_x(self) -> winrt.system.Single: ...
    @_property
    def tilt_y(self) -> winrt.system.Single: ...
    @_property
    def timestamp(self) -> winrt.system.UInt64: ...

@typing.final
class InkPresenter(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> InkPresenter: ...
    def activate_custom_drying(self) -> typing.Optional[InkSynchronizer]: ...
    def copy_default_drawing_attributes(self) -> typing.Optional[InkDrawingAttributes]: ...
    def set_predefined_configuration(self, value: InkPresenterPredefinedConfiguration, /) -> None: ...
    def update_default_drawing_attributes(self, value: typing.Optional[InkDrawingAttributes], /) -> None: ...
    def add_strokes_collected(self, handler: winrt.windows.foundation.TypedEventHandler[InkPresenter, InkStrokesCollectedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_strokes_collected(self, cookie: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_strokes_erased(self, handler: winrt.windows.foundation.TypedEventHandler[InkPresenter, InkStrokesErasedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_strokes_erased(self, cookie: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    @_property
    def stroke_container(self) -> typing.Optional[InkStrokeContainer]: ...
    @stroke_container.setter
    def stroke_container(self, value: typing.Optional[InkStrokeContainer]) -> None: ...
    @_property
    def is_input_enabled(self) -> bool: ...
    @is_input_enabled.setter
    def is_input_enabled(self, value: bool) -> None: ...
    @_property
    def input_device_types(self) -> winrt.windows.ui.core.CoreInputDeviceTypes: ...
    @input_device_types.setter
    def input_device_types(self, value: winrt.windows.ui.core.CoreInputDeviceTypes) -> None: ...
    @_property
    def input_processing_configuration(self) -> typing.Optional[InkInputProcessingConfiguration]: ...
    @_property
    def stroke_input(self) -> typing.Optional[InkStrokeInput]: ...
    @_property
    def unprocessed_input(self) -> typing.Optional[InkUnprocessedInput]: ...
    @_property
    def high_contrast_adjustment(self) -> InkHighContrastAdjustment: ...
    @high_contrast_adjustment.setter
    def high_contrast_adjustment(self, value: InkHighContrastAdjustment) -> None: ...
    @_property
    def input_configuration(self) -> typing.Optional[InkInputConfiguration]: ...

@typing.final
class InkPresenterProtractor(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> InkPresenterProtractor: ...
    def __new__(cls: typing.Type[InkPresenterProtractor], ink_presenter: typing.Optional[InkPresenter]) -> InkPresenterProtractor:...
    @_property
    def radius(self) -> winrt.system.Double: ...
    @radius.setter
    def radius(self, value: winrt.system.Double) -> None: ...
    @_property
    def is_resizable(self) -> bool: ...
    @is_resizable.setter
    def is_resizable(self, value: bool) -> None: ...
    @_property
    def is_center_marker_visible(self) -> bool: ...
    @is_center_marker_visible.setter
    def is_center_marker_visible(self, value: bool) -> None: ...
    @_property
    def is_angle_readout_visible(self) -> bool: ...
    @is_angle_readout_visible.setter
    def is_angle_readout_visible(self, value: bool) -> None: ...
    @_property
    def are_tick_marks_visible(self) -> bool: ...
    @are_tick_marks_visible.setter
    def are_tick_marks_visible(self, value: bool) -> None: ...
    @_property
    def are_rays_visible(self) -> bool: ...
    @are_rays_visible.setter
    def are_rays_visible(self, value: bool) -> None: ...
    @_property
    def accent_color(self) -> winrt.windows.ui.Color: ...
    @accent_color.setter
    def accent_color(self, value: winrt.windows.ui.Color) -> None: ...
    @_property
    def transform(self) -> winrt.windows.foundation.numerics.Matrix3x2: ...
    @transform.setter
    def transform(self, value: winrt.windows.foundation.numerics.Matrix3x2) -> None: ...
    @_property
    def is_visible(self) -> bool: ...
    @is_visible.setter
    def is_visible(self, value: bool) -> None: ...
    @_property
    def foreground_color(self) -> winrt.windows.ui.Color: ...
    @foreground_color.setter
    def foreground_color(self, value: winrt.windows.ui.Color) -> None: ...
    @_property
    def background_color(self) -> winrt.windows.ui.Color: ...
    @background_color.setter
    def background_color(self, value: winrt.windows.ui.Color) -> None: ...
    @_property
    def kind(self) -> InkPresenterStencilKind: ...

@typing.final
class InkPresenterRuler(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> InkPresenterRuler: ...
    def __new__(cls: typing.Type[InkPresenterRuler], ink_presenter: typing.Optional[InkPresenter]) -> InkPresenterRuler:...
    @_property
    def width(self) -> winrt.system.Double: ...
    @width.setter
    def width(self, value: winrt.system.Double) -> None: ...
    @_property
    def length(self) -> winrt.system.Double: ...
    @length.setter
    def length(self, value: winrt.system.Double) -> None: ...
    @_property
    def is_compass_visible(self) -> bool: ...
    @is_compass_visible.setter
    def is_compass_visible(self, value: bool) -> None: ...
    @_property
    def are_tick_marks_visible(self) -> bool: ...
    @are_tick_marks_visible.setter
    def are_tick_marks_visible(self, value: bool) -> None: ...
    @_property
    def transform(self) -> winrt.windows.foundation.numerics.Matrix3x2: ...
    @transform.setter
    def transform(self, value: winrt.windows.foundation.numerics.Matrix3x2) -> None: ...
    @_property
    def is_visible(self) -> bool: ...
    @is_visible.setter
    def is_visible(self, value: bool) -> None: ...
    @_property
    def foreground_color(self) -> winrt.windows.ui.Color: ...
    @foreground_color.setter
    def foreground_color(self, value: winrt.windows.ui.Color) -> None: ...
    @_property
    def background_color(self) -> winrt.windows.ui.Color: ...
    @background_color.setter
    def background_color(self, value: winrt.windows.ui.Color) -> None: ...
    @_property
    def kind(self) -> InkPresenterStencilKind: ...

@typing.final
class InkRecognitionResult(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> InkRecognitionResult: ...
    def get_strokes(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[InkStroke]]: ...
    def get_text_candidates(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[str]]: ...
    @_property
    def bounding_rect(self) -> winrt.windows.foundation.Rect: ...

@typing.final
class InkRecognizer(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> InkRecognizer: ...
    @_property
    def name(self) -> str: ...

@typing.final
class InkRecognizerContainer(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> InkRecognizerContainer: ...
    def __new__(cls: typing.Type[InkRecognizerContainer]) -> InkRecognizerContainer:...
    def get_recognizers(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[InkRecognizer]]: ...
    def recognize_async(self, stroke_collection: typing.Optional[InkStrokeContainer], recognition_target: InkRecognitionTarget, /) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.foundation.collections.IVectorView[InkRecognitionResult]]: ...
    def set_default_recognizer(self, recognizer: typing.Optional[InkRecognizer], /) -> None: ...

@typing.final
class InkStroke(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> InkStroke: ...
    def clone(self) -> typing.Optional[InkStroke]: ...
    def get_ink_points(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[InkPoint]]: ...
    def get_rendering_segments(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[InkStrokeRenderingSegment]]: ...
    @_property
    def selected(self) -> bool: ...
    @selected.setter
    def selected(self, value: bool) -> None: ...
    @_property
    def drawing_attributes(self) -> typing.Optional[InkDrawingAttributes]: ...
    @drawing_attributes.setter
    def drawing_attributes(self, value: typing.Optional[InkDrawingAttributes]) -> None: ...
    @_property
    def bounding_rect(self) -> winrt.windows.foundation.Rect: ...
    @_property
    def recognized(self) -> bool: ...
    @_property
    def point_transform(self) -> winrt.windows.foundation.numerics.Matrix3x2: ...
    @point_transform.setter
    def point_transform(self, value: winrt.windows.foundation.numerics.Matrix3x2) -> None: ...
    @_property
    def stroke_started_time(self) -> typing.Optional[typing.Optional[datetime.datetime]]: ...
    @stroke_started_time.setter
    def stroke_started_time(self, value: typing.Optional[typing.Optional[datetime.datetime]]) -> None: ...
    @_property
    def stroke_duration(self) -> typing.Optional[typing.Optional[datetime.timedelta]]: ...
    @stroke_duration.setter
    def stroke_duration(self, value: typing.Optional[typing.Optional[datetime.timedelta]]) -> None: ...
    @_property
    def id(self) -> winrt.system.UInt32: ...
    @_property
    def pointer_id(self) -> winrt.system.UInt32: ...

@typing.final
class InkStrokeBuilder(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> InkStrokeBuilder: ...
    def __new__(cls: typing.Type[InkStrokeBuilder]) -> InkStrokeBuilder:...
    def append_to_stroke(self, pointer_point: typing.Optional[winrt.windows.ui.input.PointerPoint], /) -> typing.Optional[winrt.windows.ui.input.PointerPoint]: ...
    def begin_stroke(self, pointer_point: typing.Optional[winrt.windows.ui.input.PointerPoint], /) -> None: ...
    def create_stroke(self, points: typing.Iterable[winrt.windows.foundation.Point], /) -> typing.Optional[InkStroke]: ...
    @typing.overload
    def create_stroke_from_ink_points(self, ink_points: typing.Iterable[InkPoint], transform: winrt.windows.foundation.numerics.Matrix3x2, /) -> typing.Optional[InkStroke]: ...
    @typing.overload
    def create_stroke_from_ink_points(self, ink_points: typing.Iterable[InkPoint], transform: winrt.windows.foundation.numerics.Matrix3x2, stroke_started_time: typing.Optional[datetime.datetime], stroke_duration: typing.Optional[datetime.timedelta], /) -> typing.Optional[InkStroke]: ...
    def end_stroke(self, pointer_point: typing.Optional[winrt.windows.ui.input.PointerPoint], /) -> typing.Optional[InkStroke]: ...
    def set_default_drawing_attributes(self, drawing_attributes: typing.Optional[InkDrawingAttributes], /) -> None: ...

@typing.final
class InkStrokeContainer(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> InkStrokeContainer: ...
    def __new__(cls: typing.Type[InkStrokeContainer]) -> InkStrokeContainer:...
    def add_stroke(self, stroke: typing.Optional[InkStroke], /) -> None: ...
    def add_strokes(self, strokes: typing.Iterable[InkStroke], /) -> None: ...
    def can_paste_from_clipboard(self) -> bool: ...
    def clear(self) -> None: ...
    def copy_selected_to_clipboard(self) -> None: ...
    def delete_selected(self) -> winrt.windows.foundation.Rect: ...
    def get_recognition_results(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[InkRecognitionResult]]: ...
    def get_stroke_by_id(self, id: winrt.system.UInt32, /) -> typing.Optional[InkStroke]: ...
    def get_strokes(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[InkStroke]]: ...
    def load_async(self, input_stream: typing.Optional[winrt.windows.storage.streams.IInputStream], /) -> winrt.windows.foundation.IAsyncActionWithProgress[winrt.system.UInt64]: ...
    def move_selected(self, translation: winrt.windows.foundation.Point, /) -> winrt.windows.foundation.Rect: ...
    def paste_from_clipboard(self, position: winrt.windows.foundation.Point, /) -> winrt.windows.foundation.Rect: ...
    @typing.overload
    def save_async(self, output_stream: typing.Optional[winrt.windows.storage.streams.IOutputStream], /) -> winrt.windows.foundation.IAsyncOperationWithProgress[winrt.system.UInt32, winrt.system.UInt32]: ...
    @typing.overload
    def save_async(self, output_stream: typing.Optional[winrt.windows.storage.streams.IOutputStream], ink_persistence_format: InkPersistenceFormat, /) -> winrt.windows.foundation.IAsyncOperationWithProgress[winrt.system.UInt32, winrt.system.UInt32]: ...
    def select_with_line(self, from_: winrt.windows.foundation.Point, to: winrt.windows.foundation.Point, /) -> winrt.windows.foundation.Rect: ...
    def select_with_poly_line(self, polyline: typing.Iterable[winrt.windows.foundation.Point], /) -> winrt.windows.foundation.Rect: ...
    def update_recognition_results(self, recognition_results: winrt.windows.foundation.collections.IVectorView[InkRecognitionResult], /) -> None: ...
    @_property
    def bounding_rect(self) -> winrt.windows.foundation.Rect: ...

@typing.final
class InkStrokeInput(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> InkStrokeInput: ...
    def add_stroke_canceled(self, handler: winrt.windows.foundation.TypedEventHandler[InkStrokeInput, winrt.windows.ui.core.PointerEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_stroke_canceled(self, cookie: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_stroke_continued(self, handler: winrt.windows.foundation.TypedEventHandler[InkStrokeInput, winrt.windows.ui.core.PointerEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_stroke_continued(self, cookie: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_stroke_ended(self, handler: winrt.windows.foundation.TypedEventHandler[InkStrokeInput, winrt.windows.ui.core.PointerEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_stroke_ended(self, cookie: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_stroke_started(self, handler: winrt.windows.foundation.TypedEventHandler[InkStrokeInput, winrt.windows.ui.core.PointerEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_stroke_started(self, cookie: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    @_property
    def ink_presenter(self) -> typing.Optional[InkPresenter]: ...

@typing.final
class InkStrokeRenderingSegment(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> InkStrokeRenderingSegment: ...
    @_property
    def bezier_control_point1(self) -> winrt.windows.foundation.Point: ...
    @_property
    def bezier_control_point2(self) -> winrt.windows.foundation.Point: ...
    @_property
    def position(self) -> winrt.windows.foundation.Point: ...
    @_property
    def pressure(self) -> winrt.system.Single: ...
    @_property
    def tilt_x(self) -> winrt.system.Single: ...
    @_property
    def tilt_y(self) -> winrt.system.Single: ...
    @_property
    def twist(self) -> winrt.system.Single: ...

@typing.final
class InkStrokesCollectedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> InkStrokesCollectedEventArgs: ...
    @_property
    def strokes(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[InkStroke]]: ...

@typing.final
class InkStrokesErasedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> InkStrokesErasedEventArgs: ...
    @_property
    def strokes(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[InkStroke]]: ...

@typing.final
class InkSynchronizer(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> InkSynchronizer: ...
    def begin_dry(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[InkStroke]]: ...
    def end_dry(self) -> None: ...

@typing.final
class InkUnprocessedInput(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> InkUnprocessedInput: ...
    def add_pointer_entered(self, handler: winrt.windows.foundation.TypedEventHandler[InkUnprocessedInput, winrt.windows.ui.core.PointerEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_pointer_entered(self, cookie: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_pointer_exited(self, handler: winrt.windows.foundation.TypedEventHandler[InkUnprocessedInput, winrt.windows.ui.core.PointerEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_pointer_exited(self, cookie: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_pointer_hovered(self, handler: winrt.windows.foundation.TypedEventHandler[InkUnprocessedInput, winrt.windows.ui.core.PointerEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_pointer_hovered(self, cookie: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_pointer_lost(self, handler: winrt.windows.foundation.TypedEventHandler[InkUnprocessedInput, winrt.windows.ui.core.PointerEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_pointer_lost(self, cookie: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_pointer_moved(self, handler: winrt.windows.foundation.TypedEventHandler[InkUnprocessedInput, winrt.windows.ui.core.PointerEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_pointer_moved(self, cookie: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_pointer_pressed(self, handler: winrt.windows.foundation.TypedEventHandler[InkUnprocessedInput, winrt.windows.ui.core.PointerEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_pointer_pressed(self, cookie: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_pointer_released(self, handler: winrt.windows.foundation.TypedEventHandler[InkUnprocessedInput, winrt.windows.ui.core.PointerEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_pointer_released(self, cookie: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    @_property
    def ink_presenter(self) -> typing.Optional[InkPresenter]: ...

@typing.final
class PenAndInkSettings_Static(type):
    def get_default(cls) -> typing.Optional[PenAndInkSettings]: ...

@typing.final
class PenAndInkSettings(winrt.system.Object, metaclass=PenAndInkSettings_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> PenAndInkSettings: ...
    def set_pen_handedness(self, value: PenHandedness, /) -> None: ...
    @_property
    def font_family_name(self) -> str: ...
    @_property
    def handwriting_line_height(self) -> HandwritingLineHeight: ...
    @_property
    def is_handwriting_directly_into_text_field_enabled(self) -> bool: ...
    @_property
    def is_touch_handwriting_enabled(self) -> bool: ...
    @_property
    def pen_handedness(self) -> PenHandedness: ...
    @_property
    def user_consents_to_handwriting_telemetry_collection(self) -> bool: ...

@typing.final
class IInkPointFactory(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> IInkPointFactory: ...
    def create_ink_point(self, position: winrt.windows.foundation.Point, pressure: winrt.system.Single, /) -> typing.Optional[InkPoint]: ...

@typing.final
class IInkPresenterRulerFactory(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> IInkPresenterRulerFactory: ...
    def create(self, ink_presenter: typing.Optional[InkPresenter], /) -> typing.Optional[InkPresenterRuler]: ...

@typing.final
class IInkPresenterStencil(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> IInkPresenterStencil: ...
    @_property
    def background_color(self) -> winrt.windows.ui.Color: ...
    @background_color.setter
    def background_color(self, value: winrt.windows.ui.Color) -> None: ...
    @_property
    def foreground_color(self) -> winrt.windows.ui.Color: ...
    @foreground_color.setter
    def foreground_color(self, value: winrt.windows.ui.Color) -> None: ...
    @_property
    def is_visible(self) -> bool: ...
    @is_visible.setter
    def is_visible(self, value: bool) -> None: ...
    @_property
    def kind(self) -> InkPresenterStencilKind: ...
    @_property
    def transform(self) -> winrt.windows.foundation.numerics.Matrix3x2: ...
    @transform.setter
    def transform(self, value: winrt.windows.foundation.numerics.Matrix3x2) -> None: ...

@typing.final
class IInkRecognizerContainer(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> IInkRecognizerContainer: ...
    def get_recognizers(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[InkRecognizer]]: ...
    def recognize_async(self, stroke_collection: typing.Optional[InkStrokeContainer], recognition_target: InkRecognitionTarget, /) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.foundation.collections.IVectorView[InkRecognitionResult]]: ...
    def set_default_recognizer(self, recognizer: typing.Optional[InkRecognizer], /) -> None: ...

@typing.final
class IInkStrokeContainer(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> IInkStrokeContainer: ...
    def add_stroke(self, stroke: typing.Optional[InkStroke], /) -> None: ...
    def can_paste_from_clipboard(self) -> bool: ...
    def copy_selected_to_clipboard(self) -> None: ...
    def delete_selected(self) -> winrt.windows.foundation.Rect: ...
    def get_recognition_results(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[InkRecognitionResult]]: ...
    def get_strokes(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[InkStroke]]: ...
    def load_async(self, input_stream: typing.Optional[winrt.windows.storage.streams.IInputStream], /) -> winrt.windows.foundation.IAsyncActionWithProgress[winrt.system.UInt64]: ...
    def move_selected(self, translation: winrt.windows.foundation.Point, /) -> winrt.windows.foundation.Rect: ...
    def paste_from_clipboard(self, position: winrt.windows.foundation.Point, /) -> winrt.windows.foundation.Rect: ...
    def save_async(self, output_stream: typing.Optional[winrt.windows.storage.streams.IOutputStream], /) -> winrt.windows.foundation.IAsyncOperationWithProgress[winrt.system.UInt32, winrt.system.UInt32]: ...
    def select_with_line(self, from_: winrt.windows.foundation.Point, to: winrt.windows.foundation.Point, /) -> winrt.windows.foundation.Rect: ...
    def select_with_poly_line(self, polyline: typing.Iterable[winrt.windows.foundation.Point], /) -> winrt.windows.foundation.Rect: ...
    def update_recognition_results(self, recognition_results: winrt.windows.foundation.collections.IVectorView[InkRecognitionResult], /) -> None: ...
    @_property
    def bounding_rect(self) -> winrt.windows.foundation.Rect: ...

