// WARNING: Please don't edit this file. It was generated by Python/WinRT v0.0.0

#include "py.Windows.UI.Input.Inking.h"

namespace py::cpp::Windows::UI::Input::Inking
{
    // ----- InkDrawingAttributes class --------------------

    static PyObject* _new_InkDrawingAttributes(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Input::Inking::InkDrawingAttributes instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_InkDrawingAttributes(py::wrapper::Windows::UI::Input::Inking::InkDrawingAttributes* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* InkDrawingAttributes_CreateForPencil(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Input.Inking.InkDrawingAttributes", L"CreateForPencil", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(winrt::Windows::UI::Input::Inking::InkDrawingAttributes::CreateForPencil());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InkDrawingAttributes_get_Size(py::wrapper::Windows::UI::Input::Inking::InkDrawingAttributes* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Inking.InkDrawingAttributes", L"Size");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InkDrawingAttributes_put_Size(py::wrapper::Windows::UI::Input::Inking::InkDrawingAttributes* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Inking.InkDrawingAttributes", L"Size");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::Size>(arg);

            self->obj.Size(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InkDrawingAttributes_get_PenTip(py::wrapper::Windows::UI::Input::Inking::InkDrawingAttributes* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Inking.InkDrawingAttributes", L"PenTip");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PenTip());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InkDrawingAttributes_put_PenTip(py::wrapper::Windows::UI::Input::Inking::InkDrawingAttributes* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Inking.InkDrawingAttributes", L"PenTip");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Input::Inking::PenTipShape>(arg);

            self->obj.PenTip(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InkDrawingAttributes_get_IgnorePressure(py::wrapper::Windows::UI::Input::Inking::InkDrawingAttributes* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Inking.InkDrawingAttributes", L"IgnorePressure");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IgnorePressure());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InkDrawingAttributes_put_IgnorePressure(py::wrapper::Windows::UI::Input::Inking::InkDrawingAttributes* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Inking.InkDrawingAttributes", L"IgnorePressure");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.IgnorePressure(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InkDrawingAttributes_get_FitToCurve(py::wrapper::Windows::UI::Input::Inking::InkDrawingAttributes* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Inking.InkDrawingAttributes", L"FitToCurve");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.FitToCurve());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InkDrawingAttributes_put_FitToCurve(py::wrapper::Windows::UI::Input::Inking::InkDrawingAttributes* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Inking.InkDrawingAttributes", L"FitToCurve");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.FitToCurve(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InkDrawingAttributes_get_Color(py::wrapper::Windows::UI::Input::Inking::InkDrawingAttributes* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Inking.InkDrawingAttributes", L"Color");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Color());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InkDrawingAttributes_put_Color(py::wrapper::Windows::UI::Input::Inking::InkDrawingAttributes* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Inking.InkDrawingAttributes", L"Color");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Color>(arg);

            self->obj.Color(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InkDrawingAttributes_get_PenTipTransform(py::wrapper::Windows::UI::Input::Inking::InkDrawingAttributes* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Inking.InkDrawingAttributes", L"PenTipTransform");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PenTipTransform());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InkDrawingAttributes_put_PenTipTransform(py::wrapper::Windows::UI::Input::Inking::InkDrawingAttributes* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Inking.InkDrawingAttributes", L"PenTipTransform");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::Numerics::float3x2>(arg);

            self->obj.PenTipTransform(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InkDrawingAttributes_get_DrawAsHighlighter(py::wrapper::Windows::UI::Input::Inking::InkDrawingAttributes* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Inking.InkDrawingAttributes", L"DrawAsHighlighter");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DrawAsHighlighter());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InkDrawingAttributes_put_DrawAsHighlighter(py::wrapper::Windows::UI::Input::Inking::InkDrawingAttributes* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Inking.InkDrawingAttributes", L"DrawAsHighlighter");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.DrawAsHighlighter(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InkDrawingAttributes_get_Kind(py::wrapper::Windows::UI::Input::Inking::InkDrawingAttributes* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Inking.InkDrawingAttributes", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InkDrawingAttributes_get_PencilProperties(py::wrapper::Windows::UI::Input::Inking::InkDrawingAttributes* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Inking.InkDrawingAttributes", L"PencilProperties");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PencilProperties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InkDrawingAttributes_get_IgnoreTilt(py::wrapper::Windows::UI::Input::Inking::InkDrawingAttributes* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Inking.InkDrawingAttributes", L"IgnoreTilt");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IgnoreTilt());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InkDrawingAttributes_put_IgnoreTilt(py::wrapper::Windows::UI::Input::Inking::InkDrawingAttributes* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Inking.InkDrawingAttributes", L"IgnoreTilt");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.IgnoreTilt(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InkDrawingAttributes_get_ModelerAttributes(py::wrapper::Windows::UI::Input::Inking::InkDrawingAttributes* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Inking.InkDrawingAttributes", L"ModelerAttributes");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ModelerAttributes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_InkDrawingAttributes(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Input::Inking::InkDrawingAttributes>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_InkDrawingAttributes(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Input::Inking::InkDrawingAttributes>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_InkDrawingAttributes[] = {
        { "_assign_array_", _assign_array_InkDrawingAttributes, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_InkDrawingAttributes), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_InkDrawingAttributes[] = {
        { "size", reinterpret_cast<getter>(InkDrawingAttributes_get_Size), reinterpret_cast<setter>(InkDrawingAttributes_put_Size), nullptr, nullptr },
        { "pen_tip", reinterpret_cast<getter>(InkDrawingAttributes_get_PenTip), reinterpret_cast<setter>(InkDrawingAttributes_put_PenTip), nullptr, nullptr },
        { "ignore_pressure", reinterpret_cast<getter>(InkDrawingAttributes_get_IgnorePressure), reinterpret_cast<setter>(InkDrawingAttributes_put_IgnorePressure), nullptr, nullptr },
        { "fit_to_curve", reinterpret_cast<getter>(InkDrawingAttributes_get_FitToCurve), reinterpret_cast<setter>(InkDrawingAttributes_put_FitToCurve), nullptr, nullptr },
        { "color", reinterpret_cast<getter>(InkDrawingAttributes_get_Color), reinterpret_cast<setter>(InkDrawingAttributes_put_Color), nullptr, nullptr },
        { "pen_tip_transform", reinterpret_cast<getter>(InkDrawingAttributes_get_PenTipTransform), reinterpret_cast<setter>(InkDrawingAttributes_put_PenTipTransform), nullptr, nullptr },
        { "draw_as_highlighter", reinterpret_cast<getter>(InkDrawingAttributes_get_DrawAsHighlighter), reinterpret_cast<setter>(InkDrawingAttributes_put_DrawAsHighlighter), nullptr, nullptr },
        { "kind", reinterpret_cast<getter>(InkDrawingAttributes_get_Kind), nullptr, nullptr, nullptr },
        { "pencil_properties", reinterpret_cast<getter>(InkDrawingAttributes_get_PencilProperties), nullptr, nullptr, nullptr },
        { "ignore_tilt", reinterpret_cast<getter>(InkDrawingAttributes_get_IgnoreTilt), reinterpret_cast<setter>(InkDrawingAttributes_put_IgnoreTilt), nullptr, nullptr },
        { "modeler_attributes", reinterpret_cast<getter>(InkDrawingAttributes_get_ModelerAttributes), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_InkDrawingAttributes[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_InkDrawingAttributes) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_InkDrawingAttributes) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_InkDrawingAttributes) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_InkDrawingAttributes) },
        { }
    };

    static PyType_Spec type_spec_InkDrawingAttributes = {
        "winrt._winrt_windows_ui_input_inking.InkDrawingAttributes",
        sizeof(py::wrapper::Windows::UI::Input::Inking::InkDrawingAttributes),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_InkDrawingAttributes};

    static PyGetSetDef getset_InkDrawingAttributes_Static[] = {
        { }
    };

    static PyMethodDef methods_InkDrawingAttributes_Static[] = {
        { "create_for_pencil", reinterpret_cast<PyCFunction>(InkDrawingAttributes_CreateForPencil), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_InkDrawingAttributes_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_InkDrawingAttributes_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_InkDrawingAttributes_Static) },
        { }
    };

    static PyType_Spec type_spec_InkDrawingAttributes_Static =
    {
        "winrt._winrt_windows_ui_input_inking.InkDrawingAttributes_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_InkDrawingAttributes_Static
    };

    // ----- InkDrawingAttributesPencilProperties class --------------------

    static PyObject* _new_InkDrawingAttributesPencilProperties(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Input::Inking::InkDrawingAttributesPencilProperties>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Input::Inking::InkDrawingAttributesPencilProperties>::type_name);
        return nullptr;
    }

    static void _dealloc_InkDrawingAttributesPencilProperties(py::wrapper::Windows::UI::Input::Inking::InkDrawingAttributesPencilProperties* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* InkDrawingAttributesPencilProperties_get_Opacity(py::wrapper::Windows::UI::Input::Inking::InkDrawingAttributesPencilProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Inking.InkDrawingAttributesPencilProperties", L"Opacity");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Opacity());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InkDrawingAttributesPencilProperties_put_Opacity(py::wrapper::Windows::UI::Input::Inking::InkDrawingAttributesPencilProperties* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Inking.InkDrawingAttributesPencilProperties", L"Opacity");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            self->obj.Opacity(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_InkDrawingAttributesPencilProperties(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Input::Inking::InkDrawingAttributesPencilProperties>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_InkDrawingAttributesPencilProperties(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Input::Inking::InkDrawingAttributesPencilProperties>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_InkDrawingAttributesPencilProperties[] = {
        { "_assign_array_", _assign_array_InkDrawingAttributesPencilProperties, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_InkDrawingAttributesPencilProperties), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_InkDrawingAttributesPencilProperties[] = {
        { "opacity", reinterpret_cast<getter>(InkDrawingAttributesPencilProperties_get_Opacity), reinterpret_cast<setter>(InkDrawingAttributesPencilProperties_put_Opacity), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_InkDrawingAttributesPencilProperties[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_InkDrawingAttributesPencilProperties) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_InkDrawingAttributesPencilProperties) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_InkDrawingAttributesPencilProperties) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_InkDrawingAttributesPencilProperties) },
        { }
    };

    static PyType_Spec type_spec_InkDrawingAttributesPencilProperties = {
        "winrt._winrt_windows_ui_input_inking.InkDrawingAttributesPencilProperties",
        sizeof(py::wrapper::Windows::UI::Input::Inking::InkDrawingAttributesPencilProperties),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_InkDrawingAttributesPencilProperties};

    // ----- InkInputConfiguration class --------------------

    static PyObject* _new_InkInputConfiguration(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Input::Inking::InkInputConfiguration>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Input::Inking::InkInputConfiguration>::type_name);
        return nullptr;
    }

    static void _dealloc_InkInputConfiguration(py::wrapper::Windows::UI::Input::Inking::InkInputConfiguration* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* InkInputConfiguration_get_IsPrimaryBarrelButtonInputEnabled(py::wrapper::Windows::UI::Input::Inking::InkInputConfiguration* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Inking.InkInputConfiguration", L"IsPrimaryBarrelButtonInputEnabled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsPrimaryBarrelButtonInputEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InkInputConfiguration_put_IsPrimaryBarrelButtonInputEnabled(py::wrapper::Windows::UI::Input::Inking::InkInputConfiguration* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Inking.InkInputConfiguration", L"IsPrimaryBarrelButtonInputEnabled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsPrimaryBarrelButtonInputEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InkInputConfiguration_get_IsEraserInputEnabled(py::wrapper::Windows::UI::Input::Inking::InkInputConfiguration* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Inking.InkInputConfiguration", L"IsEraserInputEnabled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsEraserInputEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InkInputConfiguration_put_IsEraserInputEnabled(py::wrapper::Windows::UI::Input::Inking::InkInputConfiguration* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Inking.InkInputConfiguration", L"IsEraserInputEnabled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsEraserInputEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InkInputConfiguration_get_IsPenHapticFeedbackEnabled(py::wrapper::Windows::UI::Input::Inking::InkInputConfiguration* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Inking.InkInputConfiguration", L"IsPenHapticFeedbackEnabled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsPenHapticFeedbackEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InkInputConfiguration_put_IsPenHapticFeedbackEnabled(py::wrapper::Windows::UI::Input::Inking::InkInputConfiguration* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Inking.InkInputConfiguration", L"IsPenHapticFeedbackEnabled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsPenHapticFeedbackEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_InkInputConfiguration(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Input::Inking::InkInputConfiguration>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_InkInputConfiguration(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Input::Inking::InkInputConfiguration>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_InkInputConfiguration[] = {
        { "_assign_array_", _assign_array_InkInputConfiguration, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_InkInputConfiguration), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_InkInputConfiguration[] = {
        { "is_primary_barrel_button_input_enabled", reinterpret_cast<getter>(InkInputConfiguration_get_IsPrimaryBarrelButtonInputEnabled), reinterpret_cast<setter>(InkInputConfiguration_put_IsPrimaryBarrelButtonInputEnabled), nullptr, nullptr },
        { "is_eraser_input_enabled", reinterpret_cast<getter>(InkInputConfiguration_get_IsEraserInputEnabled), reinterpret_cast<setter>(InkInputConfiguration_put_IsEraserInputEnabled), nullptr, nullptr },
        { "is_pen_haptic_feedback_enabled", reinterpret_cast<getter>(InkInputConfiguration_get_IsPenHapticFeedbackEnabled), reinterpret_cast<setter>(InkInputConfiguration_put_IsPenHapticFeedbackEnabled), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_InkInputConfiguration[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_InkInputConfiguration) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_InkInputConfiguration) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_InkInputConfiguration) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_InkInputConfiguration) },
        { }
    };

    static PyType_Spec type_spec_InkInputConfiguration = {
        "winrt._winrt_windows_ui_input_inking.InkInputConfiguration",
        sizeof(py::wrapper::Windows::UI::Input::Inking::InkInputConfiguration),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_InkInputConfiguration};

    // ----- InkInputProcessingConfiguration class --------------------

    static PyObject* _new_InkInputProcessingConfiguration(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Input::Inking::InkInputProcessingConfiguration>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Input::Inking::InkInputProcessingConfiguration>::type_name);
        return nullptr;
    }

    static void _dealloc_InkInputProcessingConfiguration(py::wrapper::Windows::UI::Input::Inking::InkInputProcessingConfiguration* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* InkInputProcessingConfiguration_get_RightDragAction(py::wrapper::Windows::UI::Input::Inking::InkInputProcessingConfiguration* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Inking.InkInputProcessingConfiguration", L"RightDragAction");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.RightDragAction());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InkInputProcessingConfiguration_put_RightDragAction(py::wrapper::Windows::UI::Input::Inking::InkInputProcessingConfiguration* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Inking.InkInputProcessingConfiguration", L"RightDragAction");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Input::Inking::InkInputRightDragAction>(arg);

            self->obj.RightDragAction(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InkInputProcessingConfiguration_get_Mode(py::wrapper::Windows::UI::Input::Inking::InkInputProcessingConfiguration* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Inking.InkInputProcessingConfiguration", L"Mode");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Mode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InkInputProcessingConfiguration_put_Mode(py::wrapper::Windows::UI::Input::Inking::InkInputProcessingConfiguration* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Inking.InkInputProcessingConfiguration", L"Mode");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Input::Inking::InkInputProcessingMode>(arg);

            self->obj.Mode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_InkInputProcessingConfiguration(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Input::Inking::InkInputProcessingConfiguration>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_InkInputProcessingConfiguration(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Input::Inking::InkInputProcessingConfiguration>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_InkInputProcessingConfiguration[] = {
        { "_assign_array_", _assign_array_InkInputProcessingConfiguration, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_InkInputProcessingConfiguration), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_InkInputProcessingConfiguration[] = {
        { "right_drag_action", reinterpret_cast<getter>(InkInputProcessingConfiguration_get_RightDragAction), reinterpret_cast<setter>(InkInputProcessingConfiguration_put_RightDragAction), nullptr, nullptr },
        { "mode", reinterpret_cast<getter>(InkInputProcessingConfiguration_get_Mode), reinterpret_cast<setter>(InkInputProcessingConfiguration_put_Mode), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_InkInputProcessingConfiguration[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_InkInputProcessingConfiguration) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_InkInputProcessingConfiguration) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_InkInputProcessingConfiguration) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_InkInputProcessingConfiguration) },
        { }
    };

    static PyType_Spec type_spec_InkInputProcessingConfiguration = {
        "winrt._winrt_windows_ui_input_inking.InkInputProcessingConfiguration",
        sizeof(py::wrapper::Windows::UI::Input::Inking::InkInputProcessingConfiguration),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_InkInputProcessingConfiguration};

    // ----- InkManager class --------------------

    static PyObject* _new_InkManager(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Input::Inking::InkManager instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_InkManager(py::wrapper::Windows::UI::Input::Inking::InkManager* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* InkManager_AddStroke(py::wrapper::Windows::UI::Input::Inking::InkManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Input.Inking.InkManager", L"AddStroke", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Input::Inking::InkStroke>(args, 0);

                self->obj.AddStroke(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InkManager_CanPasteFromClipboard(py::wrapper::Windows::UI::Input::Inking::InkManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Input.Inking.InkManager", L"CanPasteFromClipboard", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.CanPasteFromClipboard());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InkManager_CopySelectedToClipboard(py::wrapper::Windows::UI::Input::Inking::InkManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Input.Inking.InkManager", L"CopySelectedToClipboard", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.CopySelectedToClipboard();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InkManager_DeleteSelected(py::wrapper::Windows::UI::Input::Inking::InkManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Input.Inking.InkManager", L"DeleteSelected", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.DeleteSelected());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InkManager_GetRecognitionResults(py::wrapper::Windows::UI::Input::Inking::InkManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Input.Inking.InkManager", L"GetRecognitionResults", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetRecognitionResults());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InkManager_GetRecognizers(py::wrapper::Windows::UI::Input::Inking::InkManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Input.Inking.InkManager", L"GetRecognizers", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetRecognizers());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InkManager_GetStrokes(py::wrapper::Windows::UI::Input::Inking::InkManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Input.Inking.InkManager", L"GetStrokes", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetStrokes());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InkManager_LoadAsync(py::wrapper::Windows::UI::Input::Inking::InkManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Input.Inking.InkManager", L"LoadAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IInputStream>(args, 0);

                return py::convert(self->obj.LoadAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InkManager_MoveSelected(py::wrapper::Windows::UI::Input::Inking::InkManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Input.Inking.InkManager", L"MoveSelected", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Point>(args, 0);

                return py::convert(self->obj.MoveSelected(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InkManager_PasteFromClipboard(py::wrapper::Windows::UI::Input::Inking::InkManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Input.Inking.InkManager", L"PasteFromClipboard", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Point>(args, 0);

                return py::convert(self->obj.PasteFromClipboard(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InkManager_ProcessPointerDown(py::wrapper::Windows::UI::Input::Inking::InkManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Input.Inking.InkManager", L"ProcessPointerDown", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Input::PointerPoint>(args, 0);

                self->obj.ProcessPointerDown(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InkManager_ProcessPointerUp(py::wrapper::Windows::UI::Input::Inking::InkManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Input.Inking.InkManager", L"ProcessPointerUp", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Input::PointerPoint>(args, 0);

                return py::convert(self->obj.ProcessPointerUp(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InkManager_ProcessPointerUpdate(py::wrapper::Windows::UI::Input::Inking::InkManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Input.Inking.InkManager", L"ProcessPointerUpdate", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Input::PointerPoint>(args, 0);

                return py::convert(self->obj.ProcessPointerUpdate(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InkManager_RecognizeAsync(py::wrapper::Windows::UI::Input::Inking::InkManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Input.Inking.InkManager", L"RecognizeAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Input::Inking::InkRecognitionTarget>(args, 0);

                return py::convert(self->obj.RecognizeAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Input.Inking.InkManager", L"RecognizeAsync", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Input::Inking::InkStrokeContainer>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Input::Inking::InkRecognitionTarget>(args, 1);

                return py::convert(self->obj.RecognizeAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InkManager_SaveAsync(py::wrapper::Windows::UI::Input::Inking::InkManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Input.Inking.InkManager", L"SaveAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IOutputStream>(args, 0);

                return py::convert(self->obj.SaveAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InkManager_SelectWithLine(py::wrapper::Windows::UI::Input::Inking::InkManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Input.Inking.InkManager", L"SelectWithLine", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Point>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Point>(args, 1);

                return py::convert(self->obj.SelectWithLine(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InkManager_SelectWithPolyLine(py::wrapper::Windows::UI::Input::Inking::InkManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Input.Inking.InkManager", L"SelectWithPolyLine", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Foundation::Point>>(args, 0);

                return py::convert(self->obj.SelectWithPolyLine(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InkManager_SetDefaultDrawingAttributes(py::wrapper::Windows::UI::Input::Inking::InkManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Input.Inking.InkManager", L"SetDefaultDrawingAttributes", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Input::Inking::InkDrawingAttributes>(args, 0);

                self->obj.SetDefaultDrawingAttributes(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InkManager_SetDefaultRecognizer(py::wrapper::Windows::UI::Input::Inking::InkManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Input.Inking.InkManager", L"SetDefaultRecognizer", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Input::Inking::InkRecognizer>(args, 0);

                self->obj.SetDefaultRecognizer(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InkManager_UpdateRecognitionResults(py::wrapper::Windows::UI::Input::Inking::InkManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Input.Inking.InkManager", L"UpdateRecognitionResults", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::UI::Input::Inking::InkRecognitionResult>>(args, 0);

                self->obj.UpdateRecognitionResults(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InkManager_get_Mode(py::wrapper::Windows::UI::Input::Inking::InkManager* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Inking.InkManager", L"Mode");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Mode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InkManager_put_Mode(py::wrapper::Windows::UI::Input::Inking::InkManager* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Inking.InkManager", L"Mode");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Input::Inking::InkManipulationMode>(arg);

            self->obj.Mode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InkManager_get_BoundingRect(py::wrapper::Windows::UI::Input::Inking::InkManager* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Inking.InkManager", L"BoundingRect");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.BoundingRect());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_InkManager(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Input::Inking::InkManager>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_InkManager(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Input::Inking::InkManager>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_InkManager[] = {
        { "add_stroke", reinterpret_cast<PyCFunction>(InkManager_AddStroke), METH_VARARGS, nullptr },
        { "can_paste_from_clipboard", reinterpret_cast<PyCFunction>(InkManager_CanPasteFromClipboard), METH_VARARGS, nullptr },
        { "copy_selected_to_clipboard", reinterpret_cast<PyCFunction>(InkManager_CopySelectedToClipboard), METH_VARARGS, nullptr },
        { "delete_selected", reinterpret_cast<PyCFunction>(InkManager_DeleteSelected), METH_VARARGS, nullptr },
        { "get_recognition_results", reinterpret_cast<PyCFunction>(InkManager_GetRecognitionResults), METH_VARARGS, nullptr },
        { "get_recognizers", reinterpret_cast<PyCFunction>(InkManager_GetRecognizers), METH_VARARGS, nullptr },
        { "get_strokes", reinterpret_cast<PyCFunction>(InkManager_GetStrokes), METH_VARARGS, nullptr },
        { "load_async", reinterpret_cast<PyCFunction>(InkManager_LoadAsync), METH_VARARGS, nullptr },
        { "move_selected", reinterpret_cast<PyCFunction>(InkManager_MoveSelected), METH_VARARGS, nullptr },
        { "paste_from_clipboard", reinterpret_cast<PyCFunction>(InkManager_PasteFromClipboard), METH_VARARGS, nullptr },
        { "process_pointer_down", reinterpret_cast<PyCFunction>(InkManager_ProcessPointerDown), METH_VARARGS, nullptr },
        { "process_pointer_up", reinterpret_cast<PyCFunction>(InkManager_ProcessPointerUp), METH_VARARGS, nullptr },
        { "process_pointer_update", reinterpret_cast<PyCFunction>(InkManager_ProcessPointerUpdate), METH_VARARGS, nullptr },
        { "recognize_async", reinterpret_cast<PyCFunction>(InkManager_RecognizeAsync), METH_VARARGS, nullptr },
        { "save_async", reinterpret_cast<PyCFunction>(InkManager_SaveAsync), METH_VARARGS, nullptr },
        { "select_with_line", reinterpret_cast<PyCFunction>(InkManager_SelectWithLine), METH_VARARGS, nullptr },
        { "select_with_poly_line", reinterpret_cast<PyCFunction>(InkManager_SelectWithPolyLine), METH_VARARGS, nullptr },
        { "set_default_drawing_attributes", reinterpret_cast<PyCFunction>(InkManager_SetDefaultDrawingAttributes), METH_VARARGS, nullptr },
        { "set_default_recognizer", reinterpret_cast<PyCFunction>(InkManager_SetDefaultRecognizer), METH_VARARGS, nullptr },
        { "update_recognition_results", reinterpret_cast<PyCFunction>(InkManager_UpdateRecognitionResults), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_InkManager, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_InkManager), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_InkManager[] = {
        { "mode", reinterpret_cast<getter>(InkManager_get_Mode), reinterpret_cast<setter>(InkManager_put_Mode), nullptr, nullptr },
        { "bounding_rect", reinterpret_cast<getter>(InkManager_get_BoundingRect), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_InkManager[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_InkManager) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_InkManager) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_InkManager) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_InkManager) },
        { }
    };

    static PyType_Spec type_spec_InkManager = {
        "winrt._winrt_windows_ui_input_inking.InkManager",
        sizeof(py::wrapper::Windows::UI::Input::Inking::InkManager),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_InkManager};

    // ----- InkModelerAttributes class --------------------

    static PyObject* _new_InkModelerAttributes(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Input::Inking::InkModelerAttributes>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Input::Inking::InkModelerAttributes>::type_name);
        return nullptr;
    }

    static void _dealloc_InkModelerAttributes(py::wrapper::Windows::UI::Input::Inking::InkModelerAttributes* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* InkModelerAttributes_get_ScalingFactor(py::wrapper::Windows::UI::Input::Inking::InkModelerAttributes* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Inking.InkModelerAttributes", L"ScalingFactor");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ScalingFactor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InkModelerAttributes_put_ScalingFactor(py::wrapper::Windows::UI::Input::Inking::InkModelerAttributes* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Inking.InkModelerAttributes", L"ScalingFactor");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<float>(arg);

            self->obj.ScalingFactor(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InkModelerAttributes_get_PredictionTime(py::wrapper::Windows::UI::Input::Inking::InkModelerAttributes* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Inking.InkModelerAttributes", L"PredictionTime");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PredictionTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InkModelerAttributes_put_PredictionTime(py::wrapper::Windows::UI::Input::Inking::InkModelerAttributes* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Inking.InkModelerAttributes", L"PredictionTime");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            self->obj.PredictionTime(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InkModelerAttributes_get_UseVelocityBasedPressure(py::wrapper::Windows::UI::Input::Inking::InkModelerAttributes* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Inking.InkModelerAttributes", L"UseVelocityBasedPressure");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.UseVelocityBasedPressure());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InkModelerAttributes_put_UseVelocityBasedPressure(py::wrapper::Windows::UI::Input::Inking::InkModelerAttributes* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Inking.InkModelerAttributes", L"UseVelocityBasedPressure");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.UseVelocityBasedPressure(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_InkModelerAttributes(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Input::Inking::InkModelerAttributes>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_InkModelerAttributes(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Input::Inking::InkModelerAttributes>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_InkModelerAttributes[] = {
        { "_assign_array_", _assign_array_InkModelerAttributes, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_InkModelerAttributes), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_InkModelerAttributes[] = {
        { "scaling_factor", reinterpret_cast<getter>(InkModelerAttributes_get_ScalingFactor), reinterpret_cast<setter>(InkModelerAttributes_put_ScalingFactor), nullptr, nullptr },
        { "prediction_time", reinterpret_cast<getter>(InkModelerAttributes_get_PredictionTime), reinterpret_cast<setter>(InkModelerAttributes_put_PredictionTime), nullptr, nullptr },
        { "use_velocity_based_pressure", reinterpret_cast<getter>(InkModelerAttributes_get_UseVelocityBasedPressure), reinterpret_cast<setter>(InkModelerAttributes_put_UseVelocityBasedPressure), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_InkModelerAttributes[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_InkModelerAttributes) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_InkModelerAttributes) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_InkModelerAttributes) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_InkModelerAttributes) },
        { }
    };

    static PyType_Spec type_spec_InkModelerAttributes = {
        "winrt._winrt_windows_ui_input_inking.InkModelerAttributes",
        sizeof(py::wrapper::Windows::UI::Input::Inking::InkModelerAttributes),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_InkModelerAttributes};

    // ----- InkPoint class --------------------

    static PyObject* _new_InkPoint(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 5)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Point>(args, 0);
                auto param1 = py::convert_to<float>(args, 1);
                auto param2 = py::convert_to<float>(args, 2);
                auto param3 = py::convert_to<float>(args, 3);
                auto param4 = py::convert_to<uint64_t>(args, 4);

                winrt::Windows::UI::Input::Inking::InkPoint instance{param0, param1, param2, param3, param4};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Point>(args, 0);
                auto param1 = py::convert_to<float>(args, 1);

                winrt::Windows::UI::Input::Inking::InkPoint instance{param0, param1};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_InkPoint(py::wrapper::Windows::UI::Input::Inking::InkPoint* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* InkPoint_get_Position(py::wrapper::Windows::UI::Input::Inking::InkPoint* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Inking.InkPoint", L"Position");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Position());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InkPoint_get_Pressure(py::wrapper::Windows::UI::Input::Inking::InkPoint* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Inking.InkPoint", L"Pressure");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Pressure());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InkPoint_get_TiltX(py::wrapper::Windows::UI::Input::Inking::InkPoint* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Inking.InkPoint", L"TiltX");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.TiltX());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InkPoint_get_TiltY(py::wrapper::Windows::UI::Input::Inking::InkPoint* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Inking.InkPoint", L"TiltY");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.TiltY());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InkPoint_get_Timestamp(py::wrapper::Windows::UI::Input::Inking::InkPoint* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Inking.InkPoint", L"Timestamp");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Timestamp());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_InkPoint(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Input::Inking::InkPoint>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_InkPoint(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Input::Inking::InkPoint>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_InkPoint[] = {
        { "_assign_array_", _assign_array_InkPoint, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_InkPoint), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_InkPoint[] = {
        { "position", reinterpret_cast<getter>(InkPoint_get_Position), nullptr, nullptr, nullptr },
        { "pressure", reinterpret_cast<getter>(InkPoint_get_Pressure), nullptr, nullptr, nullptr },
        { "tilt_x", reinterpret_cast<getter>(InkPoint_get_TiltX), nullptr, nullptr, nullptr },
        { "tilt_y", reinterpret_cast<getter>(InkPoint_get_TiltY), nullptr, nullptr, nullptr },
        { "timestamp", reinterpret_cast<getter>(InkPoint_get_Timestamp), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_InkPoint[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_InkPoint) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_InkPoint) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_InkPoint) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_InkPoint) },
        { }
    };

    static PyType_Spec type_spec_InkPoint = {
        "winrt._winrt_windows_ui_input_inking.InkPoint",
        sizeof(py::wrapper::Windows::UI::Input::Inking::InkPoint),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_InkPoint};

    // ----- InkPresenter class --------------------

    static PyObject* _new_InkPresenter(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Input::Inking::InkPresenter>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Input::Inking::InkPresenter>::type_name);
        return nullptr;
    }

    static void _dealloc_InkPresenter(py::wrapper::Windows::UI::Input::Inking::InkPresenter* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* InkPresenter_ActivateCustomDrying(py::wrapper::Windows::UI::Input::Inking::InkPresenter* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Input.Inking.InkPresenter", L"ActivateCustomDrying", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.ActivateCustomDrying());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InkPresenter_CopyDefaultDrawingAttributes(py::wrapper::Windows::UI::Input::Inking::InkPresenter* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Input.Inking.InkPresenter", L"CopyDefaultDrawingAttributes", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.CopyDefaultDrawingAttributes());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InkPresenter_SetPredefinedConfiguration(py::wrapper::Windows::UI::Input::Inking::InkPresenter* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Input.Inking.InkPresenter", L"SetPredefinedConfiguration", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Input::Inking::InkPresenterPredefinedConfiguration>(args, 0);

                self->obj.SetPredefinedConfiguration(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InkPresenter_UpdateDefaultDrawingAttributes(py::wrapper::Windows::UI::Input::Inking::InkPresenter* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Input.Inking.InkPresenter", L"UpdateDefaultDrawingAttributes", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Input::Inking::InkDrawingAttributes>(args, 0);

                self->obj.UpdateDefaultDrawingAttributes(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InkPresenter_get_StrokeContainer(py::wrapper::Windows::UI::Input::Inking::InkPresenter* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Inking.InkPresenter", L"StrokeContainer");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.StrokeContainer());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InkPresenter_put_StrokeContainer(py::wrapper::Windows::UI::Input::Inking::InkPresenter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Inking.InkPresenter", L"StrokeContainer");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Input::Inking::InkStrokeContainer>(arg);

            self->obj.StrokeContainer(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InkPresenter_get_IsInputEnabled(py::wrapper::Windows::UI::Input::Inking::InkPresenter* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Inking.InkPresenter", L"IsInputEnabled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsInputEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InkPresenter_put_IsInputEnabled(py::wrapper::Windows::UI::Input::Inking::InkPresenter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Inking.InkPresenter", L"IsInputEnabled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsInputEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InkPresenter_get_InputDeviceTypes(py::wrapper::Windows::UI::Input::Inking::InkPresenter* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Inking.InkPresenter", L"InputDeviceTypes");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.InputDeviceTypes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InkPresenter_put_InputDeviceTypes(py::wrapper::Windows::UI::Input::Inking::InkPresenter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Inking.InkPresenter", L"InputDeviceTypes");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Core::CoreInputDeviceTypes>(arg);

            self->obj.InputDeviceTypes(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InkPresenter_get_InputProcessingConfiguration(py::wrapper::Windows::UI::Input::Inking::InkPresenter* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Inking.InkPresenter", L"InputProcessingConfiguration");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.InputProcessingConfiguration());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InkPresenter_get_StrokeInput(py::wrapper::Windows::UI::Input::Inking::InkPresenter* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Inking.InkPresenter", L"StrokeInput");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.StrokeInput());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InkPresenter_get_UnprocessedInput(py::wrapper::Windows::UI::Input::Inking::InkPresenter* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Inking.InkPresenter", L"UnprocessedInput");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.UnprocessedInput());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InkPresenter_get_HighContrastAdjustment(py::wrapper::Windows::UI::Input::Inking::InkPresenter* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Inking.InkPresenter", L"HighContrastAdjustment");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.HighContrastAdjustment());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InkPresenter_put_HighContrastAdjustment(py::wrapper::Windows::UI::Input::Inking::InkPresenter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Inking.InkPresenter", L"HighContrastAdjustment");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Input::Inking::InkHighContrastAdjustment>(arg);

            self->obj.HighContrastAdjustment(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InkPresenter_get_InputConfiguration(py::wrapper::Windows::UI::Input::Inking::InkPresenter* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Inking.InkPresenter", L"InputConfiguration");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.InputConfiguration());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InkPresenter_add_StrokesCollected(py::wrapper::Windows::UI::Input::Inking::InkPresenter* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Input.Inking.InkPresenter", L"StrokesCollected");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Input::Inking::InkPresenter, winrt::Windows::UI::Input::Inking::InkStrokesCollectedEventArgs>>(arg);

            return py::convert(self->obj.StrokesCollected(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InkPresenter_remove_StrokesCollected(py::wrapper::Windows::UI::Input::Inking::InkPresenter* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Input.Inking.InkPresenter", L"StrokesCollected");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.StrokesCollected(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InkPresenter_add_StrokesErased(py::wrapper::Windows::UI::Input::Inking::InkPresenter* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Input.Inking.InkPresenter", L"StrokesErased");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Input::Inking::InkPresenter, winrt::Windows::UI::Input::Inking::InkStrokesErasedEventArgs>>(arg);

            return py::convert(self->obj.StrokesErased(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InkPresenter_remove_StrokesErased(py::wrapper::Windows::UI::Input::Inking::InkPresenter* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Input.Inking.InkPresenter", L"StrokesErased");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.StrokesErased(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_InkPresenter(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Input::Inking::InkPresenter>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_InkPresenter(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Input::Inking::InkPresenter>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_InkPresenter[] = {
        { "activate_custom_drying", reinterpret_cast<PyCFunction>(InkPresenter_ActivateCustomDrying), METH_VARARGS, nullptr },
        { "copy_default_drawing_attributes", reinterpret_cast<PyCFunction>(InkPresenter_CopyDefaultDrawingAttributes), METH_VARARGS, nullptr },
        { "set_predefined_configuration", reinterpret_cast<PyCFunction>(InkPresenter_SetPredefinedConfiguration), METH_VARARGS, nullptr },
        { "update_default_drawing_attributes", reinterpret_cast<PyCFunction>(InkPresenter_UpdateDefaultDrawingAttributes), METH_VARARGS, nullptr },
        { "add_strokes_collected", reinterpret_cast<PyCFunction>(InkPresenter_add_StrokesCollected), METH_O, nullptr },
        { "remove_strokes_collected", reinterpret_cast<PyCFunction>(InkPresenter_remove_StrokesCollected), METH_O, nullptr },
        { "add_strokes_erased", reinterpret_cast<PyCFunction>(InkPresenter_add_StrokesErased), METH_O, nullptr },
        { "remove_strokes_erased", reinterpret_cast<PyCFunction>(InkPresenter_remove_StrokesErased), METH_O, nullptr },
        { "_assign_array_", _assign_array_InkPresenter, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_InkPresenter), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_InkPresenter[] = {
        { "stroke_container", reinterpret_cast<getter>(InkPresenter_get_StrokeContainer), reinterpret_cast<setter>(InkPresenter_put_StrokeContainer), nullptr, nullptr },
        { "is_input_enabled", reinterpret_cast<getter>(InkPresenter_get_IsInputEnabled), reinterpret_cast<setter>(InkPresenter_put_IsInputEnabled), nullptr, nullptr },
        { "input_device_types", reinterpret_cast<getter>(InkPresenter_get_InputDeviceTypes), reinterpret_cast<setter>(InkPresenter_put_InputDeviceTypes), nullptr, nullptr },
        { "input_processing_configuration", reinterpret_cast<getter>(InkPresenter_get_InputProcessingConfiguration), nullptr, nullptr, nullptr },
        { "stroke_input", reinterpret_cast<getter>(InkPresenter_get_StrokeInput), nullptr, nullptr, nullptr },
        { "unprocessed_input", reinterpret_cast<getter>(InkPresenter_get_UnprocessedInput), nullptr, nullptr, nullptr },
        { "high_contrast_adjustment", reinterpret_cast<getter>(InkPresenter_get_HighContrastAdjustment), reinterpret_cast<setter>(InkPresenter_put_HighContrastAdjustment), nullptr, nullptr },
        { "input_configuration", reinterpret_cast<getter>(InkPresenter_get_InputConfiguration), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_InkPresenter[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_InkPresenter) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_InkPresenter) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_InkPresenter) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_InkPresenter) },
        { }
    };

    static PyType_Spec type_spec_InkPresenter = {
        "winrt._winrt_windows_ui_input_inking.InkPresenter",
        sizeof(py::wrapper::Windows::UI::Input::Inking::InkPresenter),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_InkPresenter};

    // ----- InkPresenterProtractor class --------------------

    static PyObject* _new_InkPresenterProtractor(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Input::Inking::InkPresenter>(args, 0);

                winrt::Windows::UI::Input::Inking::InkPresenterProtractor instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_InkPresenterProtractor(py::wrapper::Windows::UI::Input::Inking::InkPresenterProtractor* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* InkPresenterProtractor_get_Radius(py::wrapper::Windows::UI::Input::Inking::InkPresenterProtractor* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Inking.InkPresenterProtractor", L"Radius");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Radius());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InkPresenterProtractor_put_Radius(py::wrapper::Windows::UI::Input::Inking::InkPresenterProtractor* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Inking.InkPresenterProtractor", L"Radius");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            self->obj.Radius(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InkPresenterProtractor_get_IsResizable(py::wrapper::Windows::UI::Input::Inking::InkPresenterProtractor* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Inking.InkPresenterProtractor", L"IsResizable");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsResizable());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InkPresenterProtractor_put_IsResizable(py::wrapper::Windows::UI::Input::Inking::InkPresenterProtractor* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Inking.InkPresenterProtractor", L"IsResizable");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsResizable(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InkPresenterProtractor_get_IsCenterMarkerVisible(py::wrapper::Windows::UI::Input::Inking::InkPresenterProtractor* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Inking.InkPresenterProtractor", L"IsCenterMarkerVisible");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsCenterMarkerVisible());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InkPresenterProtractor_put_IsCenterMarkerVisible(py::wrapper::Windows::UI::Input::Inking::InkPresenterProtractor* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Inking.InkPresenterProtractor", L"IsCenterMarkerVisible");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsCenterMarkerVisible(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InkPresenterProtractor_get_IsAngleReadoutVisible(py::wrapper::Windows::UI::Input::Inking::InkPresenterProtractor* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Inking.InkPresenterProtractor", L"IsAngleReadoutVisible");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsAngleReadoutVisible());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InkPresenterProtractor_put_IsAngleReadoutVisible(py::wrapper::Windows::UI::Input::Inking::InkPresenterProtractor* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Inking.InkPresenterProtractor", L"IsAngleReadoutVisible");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsAngleReadoutVisible(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InkPresenterProtractor_get_AreTickMarksVisible(py::wrapper::Windows::UI::Input::Inking::InkPresenterProtractor* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Inking.InkPresenterProtractor", L"AreTickMarksVisible");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.AreTickMarksVisible());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InkPresenterProtractor_put_AreTickMarksVisible(py::wrapper::Windows::UI::Input::Inking::InkPresenterProtractor* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Inking.InkPresenterProtractor", L"AreTickMarksVisible");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.AreTickMarksVisible(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InkPresenterProtractor_get_AreRaysVisible(py::wrapper::Windows::UI::Input::Inking::InkPresenterProtractor* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Inking.InkPresenterProtractor", L"AreRaysVisible");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.AreRaysVisible());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InkPresenterProtractor_put_AreRaysVisible(py::wrapper::Windows::UI::Input::Inking::InkPresenterProtractor* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Inking.InkPresenterProtractor", L"AreRaysVisible");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.AreRaysVisible(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InkPresenterProtractor_get_AccentColor(py::wrapper::Windows::UI::Input::Inking::InkPresenterProtractor* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Inking.InkPresenterProtractor", L"AccentColor");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.AccentColor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InkPresenterProtractor_put_AccentColor(py::wrapper::Windows::UI::Input::Inking::InkPresenterProtractor* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Inking.InkPresenterProtractor", L"AccentColor");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Color>(arg);

            self->obj.AccentColor(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InkPresenterProtractor_get_Transform(py::wrapper::Windows::UI::Input::Inking::InkPresenterProtractor* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Inking.InkPresenterProtractor", L"Transform");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Transform());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InkPresenterProtractor_put_Transform(py::wrapper::Windows::UI::Input::Inking::InkPresenterProtractor* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Inking.InkPresenterProtractor", L"Transform");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::Numerics::float3x2>(arg);

            self->obj.Transform(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InkPresenterProtractor_get_IsVisible(py::wrapper::Windows::UI::Input::Inking::InkPresenterProtractor* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Inking.InkPresenterProtractor", L"IsVisible");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsVisible());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InkPresenterProtractor_put_IsVisible(py::wrapper::Windows::UI::Input::Inking::InkPresenterProtractor* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Inking.InkPresenterProtractor", L"IsVisible");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsVisible(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InkPresenterProtractor_get_ForegroundColor(py::wrapper::Windows::UI::Input::Inking::InkPresenterProtractor* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Inking.InkPresenterProtractor", L"ForegroundColor");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ForegroundColor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InkPresenterProtractor_put_ForegroundColor(py::wrapper::Windows::UI::Input::Inking::InkPresenterProtractor* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Inking.InkPresenterProtractor", L"ForegroundColor");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Color>(arg);

            self->obj.ForegroundColor(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InkPresenterProtractor_get_BackgroundColor(py::wrapper::Windows::UI::Input::Inking::InkPresenterProtractor* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Inking.InkPresenterProtractor", L"BackgroundColor");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.BackgroundColor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InkPresenterProtractor_put_BackgroundColor(py::wrapper::Windows::UI::Input::Inking::InkPresenterProtractor* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Inking.InkPresenterProtractor", L"BackgroundColor");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Color>(arg);

            self->obj.BackgroundColor(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InkPresenterProtractor_get_Kind(py::wrapper::Windows::UI::Input::Inking::InkPresenterProtractor* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Inking.InkPresenterProtractor", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_InkPresenterProtractor(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Input::Inking::InkPresenterProtractor>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_InkPresenterProtractor(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Input::Inking::InkPresenterProtractor>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_InkPresenterProtractor[] = {
        { "_assign_array_", _assign_array_InkPresenterProtractor, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_InkPresenterProtractor), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_InkPresenterProtractor[] = {
        { "radius", reinterpret_cast<getter>(InkPresenterProtractor_get_Radius), reinterpret_cast<setter>(InkPresenterProtractor_put_Radius), nullptr, nullptr },
        { "is_resizable", reinterpret_cast<getter>(InkPresenterProtractor_get_IsResizable), reinterpret_cast<setter>(InkPresenterProtractor_put_IsResizable), nullptr, nullptr },
        { "is_center_marker_visible", reinterpret_cast<getter>(InkPresenterProtractor_get_IsCenterMarkerVisible), reinterpret_cast<setter>(InkPresenterProtractor_put_IsCenterMarkerVisible), nullptr, nullptr },
        { "is_angle_readout_visible", reinterpret_cast<getter>(InkPresenterProtractor_get_IsAngleReadoutVisible), reinterpret_cast<setter>(InkPresenterProtractor_put_IsAngleReadoutVisible), nullptr, nullptr },
        { "are_tick_marks_visible", reinterpret_cast<getter>(InkPresenterProtractor_get_AreTickMarksVisible), reinterpret_cast<setter>(InkPresenterProtractor_put_AreTickMarksVisible), nullptr, nullptr },
        { "are_rays_visible", reinterpret_cast<getter>(InkPresenterProtractor_get_AreRaysVisible), reinterpret_cast<setter>(InkPresenterProtractor_put_AreRaysVisible), nullptr, nullptr },
        { "accent_color", reinterpret_cast<getter>(InkPresenterProtractor_get_AccentColor), reinterpret_cast<setter>(InkPresenterProtractor_put_AccentColor), nullptr, nullptr },
        { "transform", reinterpret_cast<getter>(InkPresenterProtractor_get_Transform), reinterpret_cast<setter>(InkPresenterProtractor_put_Transform), nullptr, nullptr },
        { "is_visible", reinterpret_cast<getter>(InkPresenterProtractor_get_IsVisible), reinterpret_cast<setter>(InkPresenterProtractor_put_IsVisible), nullptr, nullptr },
        { "foreground_color", reinterpret_cast<getter>(InkPresenterProtractor_get_ForegroundColor), reinterpret_cast<setter>(InkPresenterProtractor_put_ForegroundColor), nullptr, nullptr },
        { "background_color", reinterpret_cast<getter>(InkPresenterProtractor_get_BackgroundColor), reinterpret_cast<setter>(InkPresenterProtractor_put_BackgroundColor), nullptr, nullptr },
        { "kind", reinterpret_cast<getter>(InkPresenterProtractor_get_Kind), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_InkPresenterProtractor[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_InkPresenterProtractor) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_InkPresenterProtractor) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_InkPresenterProtractor) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_InkPresenterProtractor) },
        { }
    };

    static PyType_Spec type_spec_InkPresenterProtractor = {
        "winrt._winrt_windows_ui_input_inking.InkPresenterProtractor",
        sizeof(py::wrapper::Windows::UI::Input::Inking::InkPresenterProtractor),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_InkPresenterProtractor};

    // ----- InkPresenterRuler class --------------------

    static PyObject* _new_InkPresenterRuler(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Input::Inking::InkPresenter>(args, 0);

                winrt::Windows::UI::Input::Inking::InkPresenterRuler instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_InkPresenterRuler(py::wrapper::Windows::UI::Input::Inking::InkPresenterRuler* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* InkPresenterRuler_get_Width(py::wrapper::Windows::UI::Input::Inking::InkPresenterRuler* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Inking.InkPresenterRuler", L"Width");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Width());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InkPresenterRuler_put_Width(py::wrapper::Windows::UI::Input::Inking::InkPresenterRuler* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Inking.InkPresenterRuler", L"Width");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            self->obj.Width(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InkPresenterRuler_get_Length(py::wrapper::Windows::UI::Input::Inking::InkPresenterRuler* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Inking.InkPresenterRuler", L"Length");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Length());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InkPresenterRuler_put_Length(py::wrapper::Windows::UI::Input::Inking::InkPresenterRuler* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Inking.InkPresenterRuler", L"Length");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            self->obj.Length(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InkPresenterRuler_get_IsCompassVisible(py::wrapper::Windows::UI::Input::Inking::InkPresenterRuler* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Inking.InkPresenterRuler", L"IsCompassVisible");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsCompassVisible());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InkPresenterRuler_put_IsCompassVisible(py::wrapper::Windows::UI::Input::Inking::InkPresenterRuler* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Inking.InkPresenterRuler", L"IsCompassVisible");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsCompassVisible(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InkPresenterRuler_get_AreTickMarksVisible(py::wrapper::Windows::UI::Input::Inking::InkPresenterRuler* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Inking.InkPresenterRuler", L"AreTickMarksVisible");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.AreTickMarksVisible());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InkPresenterRuler_put_AreTickMarksVisible(py::wrapper::Windows::UI::Input::Inking::InkPresenterRuler* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Inking.InkPresenterRuler", L"AreTickMarksVisible");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.AreTickMarksVisible(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InkPresenterRuler_get_Transform(py::wrapper::Windows::UI::Input::Inking::InkPresenterRuler* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Inking.InkPresenterRuler", L"Transform");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Transform());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InkPresenterRuler_put_Transform(py::wrapper::Windows::UI::Input::Inking::InkPresenterRuler* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Inking.InkPresenterRuler", L"Transform");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::Numerics::float3x2>(arg);

            self->obj.Transform(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InkPresenterRuler_get_IsVisible(py::wrapper::Windows::UI::Input::Inking::InkPresenterRuler* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Inking.InkPresenterRuler", L"IsVisible");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsVisible());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InkPresenterRuler_put_IsVisible(py::wrapper::Windows::UI::Input::Inking::InkPresenterRuler* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Inking.InkPresenterRuler", L"IsVisible");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsVisible(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InkPresenterRuler_get_ForegroundColor(py::wrapper::Windows::UI::Input::Inking::InkPresenterRuler* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Inking.InkPresenterRuler", L"ForegroundColor");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ForegroundColor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InkPresenterRuler_put_ForegroundColor(py::wrapper::Windows::UI::Input::Inking::InkPresenterRuler* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Inking.InkPresenterRuler", L"ForegroundColor");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Color>(arg);

            self->obj.ForegroundColor(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InkPresenterRuler_get_BackgroundColor(py::wrapper::Windows::UI::Input::Inking::InkPresenterRuler* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Inking.InkPresenterRuler", L"BackgroundColor");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.BackgroundColor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InkPresenterRuler_put_BackgroundColor(py::wrapper::Windows::UI::Input::Inking::InkPresenterRuler* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Inking.InkPresenterRuler", L"BackgroundColor");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Color>(arg);

            self->obj.BackgroundColor(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InkPresenterRuler_get_Kind(py::wrapper::Windows::UI::Input::Inking::InkPresenterRuler* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Inking.InkPresenterRuler", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_InkPresenterRuler(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Input::Inking::InkPresenterRuler>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_InkPresenterRuler(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Input::Inking::InkPresenterRuler>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_InkPresenterRuler[] = {
        { "_assign_array_", _assign_array_InkPresenterRuler, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_InkPresenterRuler), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_InkPresenterRuler[] = {
        { "width", reinterpret_cast<getter>(InkPresenterRuler_get_Width), reinterpret_cast<setter>(InkPresenterRuler_put_Width), nullptr, nullptr },
        { "length", reinterpret_cast<getter>(InkPresenterRuler_get_Length), reinterpret_cast<setter>(InkPresenterRuler_put_Length), nullptr, nullptr },
        { "is_compass_visible", reinterpret_cast<getter>(InkPresenterRuler_get_IsCompassVisible), reinterpret_cast<setter>(InkPresenterRuler_put_IsCompassVisible), nullptr, nullptr },
        { "are_tick_marks_visible", reinterpret_cast<getter>(InkPresenterRuler_get_AreTickMarksVisible), reinterpret_cast<setter>(InkPresenterRuler_put_AreTickMarksVisible), nullptr, nullptr },
        { "transform", reinterpret_cast<getter>(InkPresenterRuler_get_Transform), reinterpret_cast<setter>(InkPresenterRuler_put_Transform), nullptr, nullptr },
        { "is_visible", reinterpret_cast<getter>(InkPresenterRuler_get_IsVisible), reinterpret_cast<setter>(InkPresenterRuler_put_IsVisible), nullptr, nullptr },
        { "foreground_color", reinterpret_cast<getter>(InkPresenterRuler_get_ForegroundColor), reinterpret_cast<setter>(InkPresenterRuler_put_ForegroundColor), nullptr, nullptr },
        { "background_color", reinterpret_cast<getter>(InkPresenterRuler_get_BackgroundColor), reinterpret_cast<setter>(InkPresenterRuler_put_BackgroundColor), nullptr, nullptr },
        { "kind", reinterpret_cast<getter>(InkPresenterRuler_get_Kind), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_InkPresenterRuler[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_InkPresenterRuler) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_InkPresenterRuler) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_InkPresenterRuler) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_InkPresenterRuler) },
        { }
    };

    static PyType_Spec type_spec_InkPresenterRuler = {
        "winrt._winrt_windows_ui_input_inking.InkPresenterRuler",
        sizeof(py::wrapper::Windows::UI::Input::Inking::InkPresenterRuler),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_InkPresenterRuler};

    // ----- InkRecognitionResult class --------------------

    static PyObject* _new_InkRecognitionResult(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Input::Inking::InkRecognitionResult>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Input::Inking::InkRecognitionResult>::type_name);
        return nullptr;
    }

    static void _dealloc_InkRecognitionResult(py::wrapper::Windows::UI::Input::Inking::InkRecognitionResult* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* InkRecognitionResult_GetStrokes(py::wrapper::Windows::UI::Input::Inking::InkRecognitionResult* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Input.Inking.InkRecognitionResult", L"GetStrokes", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetStrokes());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InkRecognitionResult_GetTextCandidates(py::wrapper::Windows::UI::Input::Inking::InkRecognitionResult* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Input.Inking.InkRecognitionResult", L"GetTextCandidates", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetTextCandidates());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InkRecognitionResult_get_BoundingRect(py::wrapper::Windows::UI::Input::Inking::InkRecognitionResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Inking.InkRecognitionResult", L"BoundingRect");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.BoundingRect());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_InkRecognitionResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Input::Inking::InkRecognitionResult>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_InkRecognitionResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Input::Inking::InkRecognitionResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_InkRecognitionResult[] = {
        { "get_strokes", reinterpret_cast<PyCFunction>(InkRecognitionResult_GetStrokes), METH_VARARGS, nullptr },
        { "get_text_candidates", reinterpret_cast<PyCFunction>(InkRecognitionResult_GetTextCandidates), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_InkRecognitionResult, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_InkRecognitionResult), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_InkRecognitionResult[] = {
        { "bounding_rect", reinterpret_cast<getter>(InkRecognitionResult_get_BoundingRect), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_InkRecognitionResult[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_InkRecognitionResult) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_InkRecognitionResult) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_InkRecognitionResult) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_InkRecognitionResult) },
        { }
    };

    static PyType_Spec type_spec_InkRecognitionResult = {
        "winrt._winrt_windows_ui_input_inking.InkRecognitionResult",
        sizeof(py::wrapper::Windows::UI::Input::Inking::InkRecognitionResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_InkRecognitionResult};

    // ----- InkRecognizer class --------------------

    static PyObject* _new_InkRecognizer(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Input::Inking::InkRecognizer>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Input::Inking::InkRecognizer>::type_name);
        return nullptr;
    }

    static void _dealloc_InkRecognizer(py::wrapper::Windows::UI::Input::Inking::InkRecognizer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* InkRecognizer_get_Name(py::wrapper::Windows::UI::Input::Inking::InkRecognizer* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Inking.InkRecognizer", L"Name");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Name());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_InkRecognizer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Input::Inking::InkRecognizer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_InkRecognizer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Input::Inking::InkRecognizer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_InkRecognizer[] = {
        { "_assign_array_", _assign_array_InkRecognizer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_InkRecognizer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_InkRecognizer[] = {
        { "name", reinterpret_cast<getter>(InkRecognizer_get_Name), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_InkRecognizer[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_InkRecognizer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_InkRecognizer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_InkRecognizer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_InkRecognizer) },
        { }
    };

    static PyType_Spec type_spec_InkRecognizer = {
        "winrt._winrt_windows_ui_input_inking.InkRecognizer",
        sizeof(py::wrapper::Windows::UI::Input::Inking::InkRecognizer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_InkRecognizer};

    // ----- InkRecognizerContainer class --------------------

    static PyObject* _new_InkRecognizerContainer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Input::Inking::InkRecognizerContainer instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_InkRecognizerContainer(py::wrapper::Windows::UI::Input::Inking::InkRecognizerContainer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* InkRecognizerContainer_GetRecognizers(py::wrapper::Windows::UI::Input::Inking::InkRecognizerContainer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Input.Inking.InkRecognizerContainer", L"GetRecognizers", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetRecognizers());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InkRecognizerContainer_RecognizeAsync(py::wrapper::Windows::UI::Input::Inking::InkRecognizerContainer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Input.Inking.InkRecognizerContainer", L"RecognizeAsync", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Input::Inking::InkStrokeContainer>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Input::Inking::InkRecognitionTarget>(args, 1);

                return py::convert(self->obj.RecognizeAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InkRecognizerContainer_SetDefaultRecognizer(py::wrapper::Windows::UI::Input::Inking::InkRecognizerContainer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Input.Inking.InkRecognizerContainer", L"SetDefaultRecognizer", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Input::Inking::InkRecognizer>(args, 0);

                self->obj.SetDefaultRecognizer(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_InkRecognizerContainer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Input::Inking::InkRecognizerContainer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_InkRecognizerContainer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Input::Inking::InkRecognizerContainer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_InkRecognizerContainer[] = {
        { "get_recognizers", reinterpret_cast<PyCFunction>(InkRecognizerContainer_GetRecognizers), METH_VARARGS, nullptr },
        { "recognize_async", reinterpret_cast<PyCFunction>(InkRecognizerContainer_RecognizeAsync), METH_VARARGS, nullptr },
        { "set_default_recognizer", reinterpret_cast<PyCFunction>(InkRecognizerContainer_SetDefaultRecognizer), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_InkRecognizerContainer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_InkRecognizerContainer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_InkRecognizerContainer[] = {
        { }
    };

    static PyType_Slot _type_slots_InkRecognizerContainer[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_InkRecognizerContainer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_InkRecognizerContainer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_InkRecognizerContainer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_InkRecognizerContainer) },
        { }
    };

    static PyType_Spec type_spec_InkRecognizerContainer = {
        "winrt._winrt_windows_ui_input_inking.InkRecognizerContainer",
        sizeof(py::wrapper::Windows::UI::Input::Inking::InkRecognizerContainer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_InkRecognizerContainer};

    // ----- InkStroke class --------------------

    static PyObject* _new_InkStroke(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Input::Inking::InkStroke>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Input::Inking::InkStroke>::type_name);
        return nullptr;
    }

    static void _dealloc_InkStroke(py::wrapper::Windows::UI::Input::Inking::InkStroke* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* InkStroke_Clone(py::wrapper::Windows::UI::Input::Inking::InkStroke* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Input.Inking.InkStroke", L"Clone", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.Clone());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InkStroke_GetInkPoints(py::wrapper::Windows::UI::Input::Inking::InkStroke* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Input.Inking.InkStroke", L"GetInkPoints", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetInkPoints());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InkStroke_GetRenderingSegments(py::wrapper::Windows::UI::Input::Inking::InkStroke* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Input.Inking.InkStroke", L"GetRenderingSegments", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetRenderingSegments());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InkStroke_get_Selected(py::wrapper::Windows::UI::Input::Inking::InkStroke* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Inking.InkStroke", L"Selected");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Selected());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InkStroke_put_Selected(py::wrapper::Windows::UI::Input::Inking::InkStroke* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Inking.InkStroke", L"Selected");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.Selected(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InkStroke_get_DrawingAttributes(py::wrapper::Windows::UI::Input::Inking::InkStroke* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Inking.InkStroke", L"DrawingAttributes");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DrawingAttributes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InkStroke_put_DrawingAttributes(py::wrapper::Windows::UI::Input::Inking::InkStroke* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Inking.InkStroke", L"DrawingAttributes");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Input::Inking::InkDrawingAttributes>(arg);

            self->obj.DrawingAttributes(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InkStroke_get_BoundingRect(py::wrapper::Windows::UI::Input::Inking::InkStroke* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Inking.InkStroke", L"BoundingRect");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.BoundingRect());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InkStroke_get_Recognized(py::wrapper::Windows::UI::Input::Inking::InkStroke* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Inking.InkStroke", L"Recognized");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Recognized());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InkStroke_get_PointTransform(py::wrapper::Windows::UI::Input::Inking::InkStroke* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Inking.InkStroke", L"PointTransform");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PointTransform());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InkStroke_put_PointTransform(py::wrapper::Windows::UI::Input::Inking::InkStroke* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Inking.InkStroke", L"PointTransform");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::Numerics::float3x2>(arg);

            self->obj.PointTransform(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InkStroke_get_StrokeStartedTime(py::wrapper::Windows::UI::Input::Inking::InkStroke* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Inking.InkStroke", L"StrokeStartedTime");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.StrokeStartedTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InkStroke_put_StrokeStartedTime(py::wrapper::Windows::UI::Input::Inking::InkStroke* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Inking.InkStroke", L"StrokeStartedTime");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::DateTime>>(arg);

            self->obj.StrokeStartedTime(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InkStroke_get_StrokeDuration(py::wrapper::Windows::UI::Input::Inking::InkStroke* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Inking.InkStroke", L"StrokeDuration");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.StrokeDuration());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InkStroke_put_StrokeDuration(py::wrapper::Windows::UI::Input::Inking::InkStroke* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Inking.InkStroke", L"StrokeDuration");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::TimeSpan>>(arg);

            self->obj.StrokeDuration(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InkStroke_get_Id(py::wrapper::Windows::UI::Input::Inking::InkStroke* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Inking.InkStroke", L"Id");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InkStroke_get_PointerId(py::wrapper::Windows::UI::Input::Inking::InkStroke* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Inking.InkStroke", L"PointerId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PointerId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_InkStroke(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Input::Inking::InkStroke>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_InkStroke(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Input::Inking::InkStroke>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_InkStroke[] = {
        { "clone", reinterpret_cast<PyCFunction>(InkStroke_Clone), METH_VARARGS, nullptr },
        { "get_ink_points", reinterpret_cast<PyCFunction>(InkStroke_GetInkPoints), METH_VARARGS, nullptr },
        { "get_rendering_segments", reinterpret_cast<PyCFunction>(InkStroke_GetRenderingSegments), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_InkStroke, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_InkStroke), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_InkStroke[] = {
        { "selected", reinterpret_cast<getter>(InkStroke_get_Selected), reinterpret_cast<setter>(InkStroke_put_Selected), nullptr, nullptr },
        { "drawing_attributes", reinterpret_cast<getter>(InkStroke_get_DrawingAttributes), reinterpret_cast<setter>(InkStroke_put_DrawingAttributes), nullptr, nullptr },
        { "bounding_rect", reinterpret_cast<getter>(InkStroke_get_BoundingRect), nullptr, nullptr, nullptr },
        { "recognized", reinterpret_cast<getter>(InkStroke_get_Recognized), nullptr, nullptr, nullptr },
        { "point_transform", reinterpret_cast<getter>(InkStroke_get_PointTransform), reinterpret_cast<setter>(InkStroke_put_PointTransform), nullptr, nullptr },
        { "stroke_started_time", reinterpret_cast<getter>(InkStroke_get_StrokeStartedTime), reinterpret_cast<setter>(InkStroke_put_StrokeStartedTime), nullptr, nullptr },
        { "stroke_duration", reinterpret_cast<getter>(InkStroke_get_StrokeDuration), reinterpret_cast<setter>(InkStroke_put_StrokeDuration), nullptr, nullptr },
        { "id", reinterpret_cast<getter>(InkStroke_get_Id), nullptr, nullptr, nullptr },
        { "pointer_id", reinterpret_cast<getter>(InkStroke_get_PointerId), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_InkStroke[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_InkStroke) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_InkStroke) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_InkStroke) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_InkStroke) },
        { }
    };

    static PyType_Spec type_spec_InkStroke = {
        "winrt._winrt_windows_ui_input_inking.InkStroke",
        sizeof(py::wrapper::Windows::UI::Input::Inking::InkStroke),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_InkStroke};

    // ----- InkStrokeBuilder class --------------------

    static PyObject* _new_InkStrokeBuilder(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Input::Inking::InkStrokeBuilder instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_InkStrokeBuilder(py::wrapper::Windows::UI::Input::Inking::InkStrokeBuilder* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* InkStrokeBuilder_AppendToStroke(py::wrapper::Windows::UI::Input::Inking::InkStrokeBuilder* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Input.Inking.InkStrokeBuilder", L"AppendToStroke", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Input::PointerPoint>(args, 0);

                return py::convert(self->obj.AppendToStroke(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InkStrokeBuilder_BeginStroke(py::wrapper::Windows::UI::Input::Inking::InkStrokeBuilder* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Input.Inking.InkStrokeBuilder", L"BeginStroke", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Input::PointerPoint>(args, 0);

                self->obj.BeginStroke(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InkStrokeBuilder_CreateStroke(py::wrapper::Windows::UI::Input::Inking::InkStrokeBuilder* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Input.Inking.InkStrokeBuilder", L"CreateStroke", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Foundation::Point>>(args, 0);

                return py::convert(self->obj.CreateStroke(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InkStrokeBuilder_CreateStrokeFromInkPoints(py::wrapper::Windows::UI::Input::Inking::InkStrokeBuilder* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Input.Inking.InkStrokeBuilder", L"CreateStrokeFromInkPoints", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::UI::Input::Inking::InkPoint>>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Numerics::float3x2>(args, 1);

                return py::convert(self->obj.CreateStrokeFromInkPoints(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 4)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Input.Inking.InkStrokeBuilder", L"CreateStrokeFromInkPoints", 4);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(4);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::UI::Input::Inking::InkPoint>>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Numerics::float3x2>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::DateTime>>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::TimeSpan>>(args, 3);

                return py::convert(self->obj.CreateStrokeFromInkPoints(param0, param1, param2, param3));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InkStrokeBuilder_EndStroke(py::wrapper::Windows::UI::Input::Inking::InkStrokeBuilder* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Input.Inking.InkStrokeBuilder", L"EndStroke", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Input::PointerPoint>(args, 0);

                return py::convert(self->obj.EndStroke(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InkStrokeBuilder_SetDefaultDrawingAttributes(py::wrapper::Windows::UI::Input::Inking::InkStrokeBuilder* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Input.Inking.InkStrokeBuilder", L"SetDefaultDrawingAttributes", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Input::Inking::InkDrawingAttributes>(args, 0);

                self->obj.SetDefaultDrawingAttributes(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_InkStrokeBuilder(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Input::Inking::InkStrokeBuilder>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_InkStrokeBuilder(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Input::Inking::InkStrokeBuilder>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_InkStrokeBuilder[] = {
        { "append_to_stroke", reinterpret_cast<PyCFunction>(InkStrokeBuilder_AppendToStroke), METH_VARARGS, nullptr },
        { "begin_stroke", reinterpret_cast<PyCFunction>(InkStrokeBuilder_BeginStroke), METH_VARARGS, nullptr },
        { "create_stroke", reinterpret_cast<PyCFunction>(InkStrokeBuilder_CreateStroke), METH_VARARGS, nullptr },
        { "create_stroke_from_ink_points", reinterpret_cast<PyCFunction>(InkStrokeBuilder_CreateStrokeFromInkPoints), METH_VARARGS, nullptr },
        { "end_stroke", reinterpret_cast<PyCFunction>(InkStrokeBuilder_EndStroke), METH_VARARGS, nullptr },
        { "set_default_drawing_attributes", reinterpret_cast<PyCFunction>(InkStrokeBuilder_SetDefaultDrawingAttributes), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_InkStrokeBuilder, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_InkStrokeBuilder), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_InkStrokeBuilder[] = {
        { }
    };

    static PyType_Slot _type_slots_InkStrokeBuilder[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_InkStrokeBuilder) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_InkStrokeBuilder) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_InkStrokeBuilder) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_InkStrokeBuilder) },
        { }
    };

    static PyType_Spec type_spec_InkStrokeBuilder = {
        "winrt._winrt_windows_ui_input_inking.InkStrokeBuilder",
        sizeof(py::wrapper::Windows::UI::Input::Inking::InkStrokeBuilder),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_InkStrokeBuilder};

    // ----- InkStrokeContainer class --------------------

    static PyObject* _new_InkStrokeContainer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Input::Inking::InkStrokeContainer instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_InkStrokeContainer(py::wrapper::Windows::UI::Input::Inking::InkStrokeContainer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* InkStrokeContainer_AddStroke(py::wrapper::Windows::UI::Input::Inking::InkStrokeContainer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Input.Inking.InkStrokeContainer", L"AddStroke", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Input::Inking::InkStroke>(args, 0);

                self->obj.AddStroke(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InkStrokeContainer_AddStrokes(py::wrapper::Windows::UI::Input::Inking::InkStrokeContainer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Input.Inking.InkStrokeContainer", L"AddStrokes", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::UI::Input::Inking::InkStroke>>(args, 0);

                self->obj.AddStrokes(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InkStrokeContainer_CanPasteFromClipboard(py::wrapper::Windows::UI::Input::Inking::InkStrokeContainer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Input.Inking.InkStrokeContainer", L"CanPasteFromClipboard", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.CanPasteFromClipboard());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InkStrokeContainer_Clear(py::wrapper::Windows::UI::Input::Inking::InkStrokeContainer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Input.Inking.InkStrokeContainer", L"Clear", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Clear();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InkStrokeContainer_CopySelectedToClipboard(py::wrapper::Windows::UI::Input::Inking::InkStrokeContainer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Input.Inking.InkStrokeContainer", L"CopySelectedToClipboard", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.CopySelectedToClipboard();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InkStrokeContainer_DeleteSelected(py::wrapper::Windows::UI::Input::Inking::InkStrokeContainer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Input.Inking.InkStrokeContainer", L"DeleteSelected", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.DeleteSelected());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InkStrokeContainer_GetRecognitionResults(py::wrapper::Windows::UI::Input::Inking::InkStrokeContainer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Input.Inking.InkStrokeContainer", L"GetRecognitionResults", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetRecognitionResults());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InkStrokeContainer_GetStrokeById(py::wrapper::Windows::UI::Input::Inking::InkStrokeContainer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Input.Inking.InkStrokeContainer", L"GetStrokeById", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint32_t>(args, 0);

                return py::convert(self->obj.GetStrokeById(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InkStrokeContainer_GetStrokes(py::wrapper::Windows::UI::Input::Inking::InkStrokeContainer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Input.Inking.InkStrokeContainer", L"GetStrokes", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetStrokes());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InkStrokeContainer_LoadAsync(py::wrapper::Windows::UI::Input::Inking::InkStrokeContainer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Input.Inking.InkStrokeContainer", L"LoadAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IInputStream>(args, 0);

                return py::convert(self->obj.LoadAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InkStrokeContainer_MoveSelected(py::wrapper::Windows::UI::Input::Inking::InkStrokeContainer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Input.Inking.InkStrokeContainer", L"MoveSelected", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Point>(args, 0);

                return py::convert(self->obj.MoveSelected(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InkStrokeContainer_PasteFromClipboard(py::wrapper::Windows::UI::Input::Inking::InkStrokeContainer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Input.Inking.InkStrokeContainer", L"PasteFromClipboard", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Point>(args, 0);

                return py::convert(self->obj.PasteFromClipboard(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InkStrokeContainer_SaveAsync(py::wrapper::Windows::UI::Input::Inking::InkStrokeContainer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Input.Inking.InkStrokeContainer", L"SaveAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IOutputStream>(args, 0);

                return py::convert(self->obj.SaveAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Input.Inking.InkStrokeContainer", L"SaveAsync", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IOutputStream>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Input::Inking::InkPersistenceFormat>(args, 1);

                return py::convert(self->obj.SaveAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InkStrokeContainer_SelectWithLine(py::wrapper::Windows::UI::Input::Inking::InkStrokeContainer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Input.Inking.InkStrokeContainer", L"SelectWithLine", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Point>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Point>(args, 1);

                return py::convert(self->obj.SelectWithLine(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InkStrokeContainer_SelectWithPolyLine(py::wrapper::Windows::UI::Input::Inking::InkStrokeContainer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Input.Inking.InkStrokeContainer", L"SelectWithPolyLine", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Foundation::Point>>(args, 0);

                return py::convert(self->obj.SelectWithPolyLine(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InkStrokeContainer_UpdateRecognitionResults(py::wrapper::Windows::UI::Input::Inking::InkStrokeContainer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Input.Inking.InkStrokeContainer", L"UpdateRecognitionResults", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::UI::Input::Inking::InkRecognitionResult>>(args, 0);

                self->obj.UpdateRecognitionResults(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InkStrokeContainer_get_BoundingRect(py::wrapper::Windows::UI::Input::Inking::InkStrokeContainer* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Inking.InkStrokeContainer", L"BoundingRect");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.BoundingRect());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_InkStrokeContainer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Input::Inking::InkStrokeContainer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_InkStrokeContainer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Input::Inking::InkStrokeContainer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_InkStrokeContainer[] = {
        { "add_stroke", reinterpret_cast<PyCFunction>(InkStrokeContainer_AddStroke), METH_VARARGS, nullptr },
        { "add_strokes", reinterpret_cast<PyCFunction>(InkStrokeContainer_AddStrokes), METH_VARARGS, nullptr },
        { "can_paste_from_clipboard", reinterpret_cast<PyCFunction>(InkStrokeContainer_CanPasteFromClipboard), METH_VARARGS, nullptr },
        { "clear", reinterpret_cast<PyCFunction>(InkStrokeContainer_Clear), METH_VARARGS, nullptr },
        { "copy_selected_to_clipboard", reinterpret_cast<PyCFunction>(InkStrokeContainer_CopySelectedToClipboard), METH_VARARGS, nullptr },
        { "delete_selected", reinterpret_cast<PyCFunction>(InkStrokeContainer_DeleteSelected), METH_VARARGS, nullptr },
        { "get_recognition_results", reinterpret_cast<PyCFunction>(InkStrokeContainer_GetRecognitionResults), METH_VARARGS, nullptr },
        { "get_stroke_by_id", reinterpret_cast<PyCFunction>(InkStrokeContainer_GetStrokeById), METH_VARARGS, nullptr },
        { "get_strokes", reinterpret_cast<PyCFunction>(InkStrokeContainer_GetStrokes), METH_VARARGS, nullptr },
        { "load_async", reinterpret_cast<PyCFunction>(InkStrokeContainer_LoadAsync), METH_VARARGS, nullptr },
        { "move_selected", reinterpret_cast<PyCFunction>(InkStrokeContainer_MoveSelected), METH_VARARGS, nullptr },
        { "paste_from_clipboard", reinterpret_cast<PyCFunction>(InkStrokeContainer_PasteFromClipboard), METH_VARARGS, nullptr },
        { "save_async", reinterpret_cast<PyCFunction>(InkStrokeContainer_SaveAsync), METH_VARARGS, nullptr },
        { "select_with_line", reinterpret_cast<PyCFunction>(InkStrokeContainer_SelectWithLine), METH_VARARGS, nullptr },
        { "select_with_poly_line", reinterpret_cast<PyCFunction>(InkStrokeContainer_SelectWithPolyLine), METH_VARARGS, nullptr },
        { "update_recognition_results", reinterpret_cast<PyCFunction>(InkStrokeContainer_UpdateRecognitionResults), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_InkStrokeContainer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_InkStrokeContainer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_InkStrokeContainer[] = {
        { "bounding_rect", reinterpret_cast<getter>(InkStrokeContainer_get_BoundingRect), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_InkStrokeContainer[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_InkStrokeContainer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_InkStrokeContainer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_InkStrokeContainer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_InkStrokeContainer) },
        { }
    };

    static PyType_Spec type_spec_InkStrokeContainer = {
        "winrt._winrt_windows_ui_input_inking.InkStrokeContainer",
        sizeof(py::wrapper::Windows::UI::Input::Inking::InkStrokeContainer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_InkStrokeContainer};

    // ----- InkStrokeInput class --------------------

    static PyObject* _new_InkStrokeInput(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Input::Inking::InkStrokeInput>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Input::Inking::InkStrokeInput>::type_name);
        return nullptr;
    }

    static void _dealloc_InkStrokeInput(py::wrapper::Windows::UI::Input::Inking::InkStrokeInput* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* InkStrokeInput_get_InkPresenter(py::wrapper::Windows::UI::Input::Inking::InkStrokeInput* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Inking.InkStrokeInput", L"InkPresenter");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.InkPresenter());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InkStrokeInput_add_StrokeCanceled(py::wrapper::Windows::UI::Input::Inking::InkStrokeInput* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Input.Inking.InkStrokeInput", L"StrokeCanceled");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Input::Inking::InkStrokeInput, winrt::Windows::UI::Core::PointerEventArgs>>(arg);

            return py::convert(self->obj.StrokeCanceled(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InkStrokeInput_remove_StrokeCanceled(py::wrapper::Windows::UI::Input::Inking::InkStrokeInput* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Input.Inking.InkStrokeInput", L"StrokeCanceled");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.StrokeCanceled(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InkStrokeInput_add_StrokeContinued(py::wrapper::Windows::UI::Input::Inking::InkStrokeInput* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Input.Inking.InkStrokeInput", L"StrokeContinued");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Input::Inking::InkStrokeInput, winrt::Windows::UI::Core::PointerEventArgs>>(arg);

            return py::convert(self->obj.StrokeContinued(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InkStrokeInput_remove_StrokeContinued(py::wrapper::Windows::UI::Input::Inking::InkStrokeInput* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Input.Inking.InkStrokeInput", L"StrokeContinued");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.StrokeContinued(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InkStrokeInput_add_StrokeEnded(py::wrapper::Windows::UI::Input::Inking::InkStrokeInput* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Input.Inking.InkStrokeInput", L"StrokeEnded");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Input::Inking::InkStrokeInput, winrt::Windows::UI::Core::PointerEventArgs>>(arg);

            return py::convert(self->obj.StrokeEnded(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InkStrokeInput_remove_StrokeEnded(py::wrapper::Windows::UI::Input::Inking::InkStrokeInput* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Input.Inking.InkStrokeInput", L"StrokeEnded");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.StrokeEnded(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InkStrokeInput_add_StrokeStarted(py::wrapper::Windows::UI::Input::Inking::InkStrokeInput* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Input.Inking.InkStrokeInput", L"StrokeStarted");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Input::Inking::InkStrokeInput, winrt::Windows::UI::Core::PointerEventArgs>>(arg);

            return py::convert(self->obj.StrokeStarted(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InkStrokeInput_remove_StrokeStarted(py::wrapper::Windows::UI::Input::Inking::InkStrokeInput* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Input.Inking.InkStrokeInput", L"StrokeStarted");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.StrokeStarted(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_InkStrokeInput(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Input::Inking::InkStrokeInput>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_InkStrokeInput(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Input::Inking::InkStrokeInput>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_InkStrokeInput[] = {
        { "add_stroke_canceled", reinterpret_cast<PyCFunction>(InkStrokeInput_add_StrokeCanceled), METH_O, nullptr },
        { "remove_stroke_canceled", reinterpret_cast<PyCFunction>(InkStrokeInput_remove_StrokeCanceled), METH_O, nullptr },
        { "add_stroke_continued", reinterpret_cast<PyCFunction>(InkStrokeInput_add_StrokeContinued), METH_O, nullptr },
        { "remove_stroke_continued", reinterpret_cast<PyCFunction>(InkStrokeInput_remove_StrokeContinued), METH_O, nullptr },
        { "add_stroke_ended", reinterpret_cast<PyCFunction>(InkStrokeInput_add_StrokeEnded), METH_O, nullptr },
        { "remove_stroke_ended", reinterpret_cast<PyCFunction>(InkStrokeInput_remove_StrokeEnded), METH_O, nullptr },
        { "add_stroke_started", reinterpret_cast<PyCFunction>(InkStrokeInput_add_StrokeStarted), METH_O, nullptr },
        { "remove_stroke_started", reinterpret_cast<PyCFunction>(InkStrokeInput_remove_StrokeStarted), METH_O, nullptr },
        { "_assign_array_", _assign_array_InkStrokeInput, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_InkStrokeInput), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_InkStrokeInput[] = {
        { "ink_presenter", reinterpret_cast<getter>(InkStrokeInput_get_InkPresenter), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_InkStrokeInput[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_InkStrokeInput) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_InkStrokeInput) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_InkStrokeInput) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_InkStrokeInput) },
        { }
    };

    static PyType_Spec type_spec_InkStrokeInput = {
        "winrt._winrt_windows_ui_input_inking.InkStrokeInput",
        sizeof(py::wrapper::Windows::UI::Input::Inking::InkStrokeInput),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_InkStrokeInput};

    // ----- InkStrokeRenderingSegment class --------------------

    static PyObject* _new_InkStrokeRenderingSegment(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Input::Inking::InkStrokeRenderingSegment>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Input::Inking::InkStrokeRenderingSegment>::type_name);
        return nullptr;
    }

    static void _dealloc_InkStrokeRenderingSegment(py::wrapper::Windows::UI::Input::Inking::InkStrokeRenderingSegment* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* InkStrokeRenderingSegment_get_BezierControlPoint1(py::wrapper::Windows::UI::Input::Inking::InkStrokeRenderingSegment* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Inking.InkStrokeRenderingSegment", L"BezierControlPoint1");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.BezierControlPoint1());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InkStrokeRenderingSegment_get_BezierControlPoint2(py::wrapper::Windows::UI::Input::Inking::InkStrokeRenderingSegment* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Inking.InkStrokeRenderingSegment", L"BezierControlPoint2");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.BezierControlPoint2());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InkStrokeRenderingSegment_get_Position(py::wrapper::Windows::UI::Input::Inking::InkStrokeRenderingSegment* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Inking.InkStrokeRenderingSegment", L"Position");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Position());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InkStrokeRenderingSegment_get_Pressure(py::wrapper::Windows::UI::Input::Inking::InkStrokeRenderingSegment* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Inking.InkStrokeRenderingSegment", L"Pressure");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Pressure());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InkStrokeRenderingSegment_get_TiltX(py::wrapper::Windows::UI::Input::Inking::InkStrokeRenderingSegment* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Inking.InkStrokeRenderingSegment", L"TiltX");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.TiltX());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InkStrokeRenderingSegment_get_TiltY(py::wrapper::Windows::UI::Input::Inking::InkStrokeRenderingSegment* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Inking.InkStrokeRenderingSegment", L"TiltY");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.TiltY());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InkStrokeRenderingSegment_get_Twist(py::wrapper::Windows::UI::Input::Inking::InkStrokeRenderingSegment* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Inking.InkStrokeRenderingSegment", L"Twist");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Twist());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_InkStrokeRenderingSegment(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Input::Inking::InkStrokeRenderingSegment>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_InkStrokeRenderingSegment(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Input::Inking::InkStrokeRenderingSegment>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_InkStrokeRenderingSegment[] = {
        { "_assign_array_", _assign_array_InkStrokeRenderingSegment, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_InkStrokeRenderingSegment), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_InkStrokeRenderingSegment[] = {
        { "bezier_control_point1", reinterpret_cast<getter>(InkStrokeRenderingSegment_get_BezierControlPoint1), nullptr, nullptr, nullptr },
        { "bezier_control_point2", reinterpret_cast<getter>(InkStrokeRenderingSegment_get_BezierControlPoint2), nullptr, nullptr, nullptr },
        { "position", reinterpret_cast<getter>(InkStrokeRenderingSegment_get_Position), nullptr, nullptr, nullptr },
        { "pressure", reinterpret_cast<getter>(InkStrokeRenderingSegment_get_Pressure), nullptr, nullptr, nullptr },
        { "tilt_x", reinterpret_cast<getter>(InkStrokeRenderingSegment_get_TiltX), nullptr, nullptr, nullptr },
        { "tilt_y", reinterpret_cast<getter>(InkStrokeRenderingSegment_get_TiltY), nullptr, nullptr, nullptr },
        { "twist", reinterpret_cast<getter>(InkStrokeRenderingSegment_get_Twist), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_InkStrokeRenderingSegment[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_InkStrokeRenderingSegment) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_InkStrokeRenderingSegment) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_InkStrokeRenderingSegment) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_InkStrokeRenderingSegment) },
        { }
    };

    static PyType_Spec type_spec_InkStrokeRenderingSegment = {
        "winrt._winrt_windows_ui_input_inking.InkStrokeRenderingSegment",
        sizeof(py::wrapper::Windows::UI::Input::Inking::InkStrokeRenderingSegment),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_InkStrokeRenderingSegment};

    // ----- InkStrokesCollectedEventArgs class --------------------

    static PyObject* _new_InkStrokesCollectedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Input::Inking::InkStrokesCollectedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Input::Inking::InkStrokesCollectedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_InkStrokesCollectedEventArgs(py::wrapper::Windows::UI::Input::Inking::InkStrokesCollectedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* InkStrokesCollectedEventArgs_get_Strokes(py::wrapper::Windows::UI::Input::Inking::InkStrokesCollectedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Inking.InkStrokesCollectedEventArgs", L"Strokes");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Strokes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_InkStrokesCollectedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Input::Inking::InkStrokesCollectedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_InkStrokesCollectedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Input::Inking::InkStrokesCollectedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_InkStrokesCollectedEventArgs[] = {
        { "_assign_array_", _assign_array_InkStrokesCollectedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_InkStrokesCollectedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_InkStrokesCollectedEventArgs[] = {
        { "strokes", reinterpret_cast<getter>(InkStrokesCollectedEventArgs_get_Strokes), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_InkStrokesCollectedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_InkStrokesCollectedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_InkStrokesCollectedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_InkStrokesCollectedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_InkStrokesCollectedEventArgs) },
        { }
    };

    static PyType_Spec type_spec_InkStrokesCollectedEventArgs = {
        "winrt._winrt_windows_ui_input_inking.InkStrokesCollectedEventArgs",
        sizeof(py::wrapper::Windows::UI::Input::Inking::InkStrokesCollectedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_InkStrokesCollectedEventArgs};

    // ----- InkStrokesErasedEventArgs class --------------------

    static PyObject* _new_InkStrokesErasedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Input::Inking::InkStrokesErasedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Input::Inking::InkStrokesErasedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_InkStrokesErasedEventArgs(py::wrapper::Windows::UI::Input::Inking::InkStrokesErasedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* InkStrokesErasedEventArgs_get_Strokes(py::wrapper::Windows::UI::Input::Inking::InkStrokesErasedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Inking.InkStrokesErasedEventArgs", L"Strokes");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Strokes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_InkStrokesErasedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Input::Inking::InkStrokesErasedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_InkStrokesErasedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Input::Inking::InkStrokesErasedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_InkStrokesErasedEventArgs[] = {
        { "_assign_array_", _assign_array_InkStrokesErasedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_InkStrokesErasedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_InkStrokesErasedEventArgs[] = {
        { "strokes", reinterpret_cast<getter>(InkStrokesErasedEventArgs_get_Strokes), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_InkStrokesErasedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_InkStrokesErasedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_InkStrokesErasedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_InkStrokesErasedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_InkStrokesErasedEventArgs) },
        { }
    };

    static PyType_Spec type_spec_InkStrokesErasedEventArgs = {
        "winrt._winrt_windows_ui_input_inking.InkStrokesErasedEventArgs",
        sizeof(py::wrapper::Windows::UI::Input::Inking::InkStrokesErasedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_InkStrokesErasedEventArgs};

    // ----- InkSynchronizer class --------------------

    static PyObject* _new_InkSynchronizer(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Input::Inking::InkSynchronizer>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Input::Inking::InkSynchronizer>::type_name);
        return nullptr;
    }

    static void _dealloc_InkSynchronizer(py::wrapper::Windows::UI::Input::Inking::InkSynchronizer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* InkSynchronizer_BeginDry(py::wrapper::Windows::UI::Input::Inking::InkSynchronizer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Input.Inking.InkSynchronizer", L"BeginDry", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.BeginDry());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InkSynchronizer_EndDry(py::wrapper::Windows::UI::Input::Inking::InkSynchronizer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Input.Inking.InkSynchronizer", L"EndDry", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.EndDry();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_InkSynchronizer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Input::Inking::InkSynchronizer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_InkSynchronizer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Input::Inking::InkSynchronizer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_InkSynchronizer[] = {
        { "begin_dry", reinterpret_cast<PyCFunction>(InkSynchronizer_BeginDry), METH_VARARGS, nullptr },
        { "end_dry", reinterpret_cast<PyCFunction>(InkSynchronizer_EndDry), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_InkSynchronizer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_InkSynchronizer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_InkSynchronizer[] = {
        { }
    };

    static PyType_Slot _type_slots_InkSynchronizer[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_InkSynchronizer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_InkSynchronizer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_InkSynchronizer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_InkSynchronizer) },
        { }
    };

    static PyType_Spec type_spec_InkSynchronizer = {
        "winrt._winrt_windows_ui_input_inking.InkSynchronizer",
        sizeof(py::wrapper::Windows::UI::Input::Inking::InkSynchronizer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_InkSynchronizer};

    // ----- InkUnprocessedInput class --------------------

    static PyObject* _new_InkUnprocessedInput(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Input::Inking::InkUnprocessedInput>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Input::Inking::InkUnprocessedInput>::type_name);
        return nullptr;
    }

    static void _dealloc_InkUnprocessedInput(py::wrapper::Windows::UI::Input::Inking::InkUnprocessedInput* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* InkUnprocessedInput_get_InkPresenter(py::wrapper::Windows::UI::Input::Inking::InkUnprocessedInput* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Inking.InkUnprocessedInput", L"InkPresenter");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.InkPresenter());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InkUnprocessedInput_add_PointerEntered(py::wrapper::Windows::UI::Input::Inking::InkUnprocessedInput* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Input.Inking.InkUnprocessedInput", L"PointerEntered");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Input::Inking::InkUnprocessedInput, winrt::Windows::UI::Core::PointerEventArgs>>(arg);

            return py::convert(self->obj.PointerEntered(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InkUnprocessedInput_remove_PointerEntered(py::wrapper::Windows::UI::Input::Inking::InkUnprocessedInput* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Input.Inking.InkUnprocessedInput", L"PointerEntered");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.PointerEntered(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InkUnprocessedInput_add_PointerExited(py::wrapper::Windows::UI::Input::Inking::InkUnprocessedInput* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Input.Inking.InkUnprocessedInput", L"PointerExited");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Input::Inking::InkUnprocessedInput, winrt::Windows::UI::Core::PointerEventArgs>>(arg);

            return py::convert(self->obj.PointerExited(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InkUnprocessedInput_remove_PointerExited(py::wrapper::Windows::UI::Input::Inking::InkUnprocessedInput* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Input.Inking.InkUnprocessedInput", L"PointerExited");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.PointerExited(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InkUnprocessedInput_add_PointerHovered(py::wrapper::Windows::UI::Input::Inking::InkUnprocessedInput* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Input.Inking.InkUnprocessedInput", L"PointerHovered");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Input::Inking::InkUnprocessedInput, winrt::Windows::UI::Core::PointerEventArgs>>(arg);

            return py::convert(self->obj.PointerHovered(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InkUnprocessedInput_remove_PointerHovered(py::wrapper::Windows::UI::Input::Inking::InkUnprocessedInput* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Input.Inking.InkUnprocessedInput", L"PointerHovered");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.PointerHovered(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InkUnprocessedInput_add_PointerLost(py::wrapper::Windows::UI::Input::Inking::InkUnprocessedInput* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Input.Inking.InkUnprocessedInput", L"PointerLost");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Input::Inking::InkUnprocessedInput, winrt::Windows::UI::Core::PointerEventArgs>>(arg);

            return py::convert(self->obj.PointerLost(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InkUnprocessedInput_remove_PointerLost(py::wrapper::Windows::UI::Input::Inking::InkUnprocessedInput* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Input.Inking.InkUnprocessedInput", L"PointerLost");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.PointerLost(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InkUnprocessedInput_add_PointerMoved(py::wrapper::Windows::UI::Input::Inking::InkUnprocessedInput* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Input.Inking.InkUnprocessedInput", L"PointerMoved");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Input::Inking::InkUnprocessedInput, winrt::Windows::UI::Core::PointerEventArgs>>(arg);

            return py::convert(self->obj.PointerMoved(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InkUnprocessedInput_remove_PointerMoved(py::wrapper::Windows::UI::Input::Inking::InkUnprocessedInput* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Input.Inking.InkUnprocessedInput", L"PointerMoved");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.PointerMoved(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InkUnprocessedInput_add_PointerPressed(py::wrapper::Windows::UI::Input::Inking::InkUnprocessedInput* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Input.Inking.InkUnprocessedInput", L"PointerPressed");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Input::Inking::InkUnprocessedInput, winrt::Windows::UI::Core::PointerEventArgs>>(arg);

            return py::convert(self->obj.PointerPressed(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InkUnprocessedInput_remove_PointerPressed(py::wrapper::Windows::UI::Input::Inking::InkUnprocessedInput* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Input.Inking.InkUnprocessedInput", L"PointerPressed");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.PointerPressed(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InkUnprocessedInput_add_PointerReleased(py::wrapper::Windows::UI::Input::Inking::InkUnprocessedInput* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Input.Inking.InkUnprocessedInput", L"PointerReleased");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Input::Inking::InkUnprocessedInput, winrt::Windows::UI::Core::PointerEventArgs>>(arg);

            return py::convert(self->obj.PointerReleased(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InkUnprocessedInput_remove_PointerReleased(py::wrapper::Windows::UI::Input::Inking::InkUnprocessedInput* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Input.Inking.InkUnprocessedInput", L"PointerReleased");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.PointerReleased(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_InkUnprocessedInput(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Input::Inking::InkUnprocessedInput>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_InkUnprocessedInput(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Input::Inking::InkUnprocessedInput>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_InkUnprocessedInput[] = {
        { "add_pointer_entered", reinterpret_cast<PyCFunction>(InkUnprocessedInput_add_PointerEntered), METH_O, nullptr },
        { "remove_pointer_entered", reinterpret_cast<PyCFunction>(InkUnprocessedInput_remove_PointerEntered), METH_O, nullptr },
        { "add_pointer_exited", reinterpret_cast<PyCFunction>(InkUnprocessedInput_add_PointerExited), METH_O, nullptr },
        { "remove_pointer_exited", reinterpret_cast<PyCFunction>(InkUnprocessedInput_remove_PointerExited), METH_O, nullptr },
        { "add_pointer_hovered", reinterpret_cast<PyCFunction>(InkUnprocessedInput_add_PointerHovered), METH_O, nullptr },
        { "remove_pointer_hovered", reinterpret_cast<PyCFunction>(InkUnprocessedInput_remove_PointerHovered), METH_O, nullptr },
        { "add_pointer_lost", reinterpret_cast<PyCFunction>(InkUnprocessedInput_add_PointerLost), METH_O, nullptr },
        { "remove_pointer_lost", reinterpret_cast<PyCFunction>(InkUnprocessedInput_remove_PointerLost), METH_O, nullptr },
        { "add_pointer_moved", reinterpret_cast<PyCFunction>(InkUnprocessedInput_add_PointerMoved), METH_O, nullptr },
        { "remove_pointer_moved", reinterpret_cast<PyCFunction>(InkUnprocessedInput_remove_PointerMoved), METH_O, nullptr },
        { "add_pointer_pressed", reinterpret_cast<PyCFunction>(InkUnprocessedInput_add_PointerPressed), METH_O, nullptr },
        { "remove_pointer_pressed", reinterpret_cast<PyCFunction>(InkUnprocessedInput_remove_PointerPressed), METH_O, nullptr },
        { "add_pointer_released", reinterpret_cast<PyCFunction>(InkUnprocessedInput_add_PointerReleased), METH_O, nullptr },
        { "remove_pointer_released", reinterpret_cast<PyCFunction>(InkUnprocessedInput_remove_PointerReleased), METH_O, nullptr },
        { "_assign_array_", _assign_array_InkUnprocessedInput, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_InkUnprocessedInput), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_InkUnprocessedInput[] = {
        { "ink_presenter", reinterpret_cast<getter>(InkUnprocessedInput_get_InkPresenter), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_InkUnprocessedInput[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_InkUnprocessedInput) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_InkUnprocessedInput) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_InkUnprocessedInput) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_InkUnprocessedInput) },
        { }
    };

    static PyType_Spec type_spec_InkUnprocessedInput = {
        "winrt._winrt_windows_ui_input_inking.InkUnprocessedInput",
        sizeof(py::wrapper::Windows::UI::Input::Inking::InkUnprocessedInput),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_InkUnprocessedInput};

    // ----- PenAndInkSettings class --------------------

    static PyObject* _new_PenAndInkSettings(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Input::Inking::PenAndInkSettings>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Input::Inking::PenAndInkSettings>::type_name);
        return nullptr;
    }

    static void _dealloc_PenAndInkSettings(py::wrapper::Windows::UI::Input::Inking::PenAndInkSettings* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PenAndInkSettings_GetDefault(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Input.Inking.PenAndInkSettings", L"GetDefault", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(winrt::Windows::UI::Input::Inking::PenAndInkSettings::GetDefault());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PenAndInkSettings_SetPenHandedness(py::wrapper::Windows::UI::Input::Inking::PenAndInkSettings* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Input.Inking.PenAndInkSettings", L"SetPenHandedness", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Input::Inking::PenHandedness>(args, 0);

                self->obj.SetPenHandedness(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PenAndInkSettings_get_FontFamilyName(py::wrapper::Windows::UI::Input::Inking::PenAndInkSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Inking.PenAndInkSettings", L"FontFamilyName");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.FontFamilyName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PenAndInkSettings_get_HandwritingLineHeight(py::wrapper::Windows::UI::Input::Inking::PenAndInkSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Inking.PenAndInkSettings", L"HandwritingLineHeight");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.HandwritingLineHeight());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PenAndInkSettings_get_IsHandwritingDirectlyIntoTextFieldEnabled(py::wrapper::Windows::UI::Input::Inking::PenAndInkSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Inking.PenAndInkSettings", L"IsHandwritingDirectlyIntoTextFieldEnabled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsHandwritingDirectlyIntoTextFieldEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PenAndInkSettings_get_IsTouchHandwritingEnabled(py::wrapper::Windows::UI::Input::Inking::PenAndInkSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Inking.PenAndInkSettings", L"IsTouchHandwritingEnabled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsTouchHandwritingEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PenAndInkSettings_get_PenHandedness(py::wrapper::Windows::UI::Input::Inking::PenAndInkSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Inking.PenAndInkSettings", L"PenHandedness");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PenHandedness());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PenAndInkSettings_get_UserConsentsToHandwritingTelemetryCollection(py::wrapper::Windows::UI::Input::Inking::PenAndInkSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Inking.PenAndInkSettings", L"UserConsentsToHandwritingTelemetryCollection");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.UserConsentsToHandwritingTelemetryCollection());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PenAndInkSettings(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Input::Inking::PenAndInkSettings>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PenAndInkSettings(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Input::Inking::PenAndInkSettings>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PenAndInkSettings[] = {
        { "set_pen_handedness", reinterpret_cast<PyCFunction>(PenAndInkSettings_SetPenHandedness), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_PenAndInkSettings, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PenAndInkSettings), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PenAndInkSettings[] = {
        { "font_family_name", reinterpret_cast<getter>(PenAndInkSettings_get_FontFamilyName), nullptr, nullptr, nullptr },
        { "handwriting_line_height", reinterpret_cast<getter>(PenAndInkSettings_get_HandwritingLineHeight), nullptr, nullptr, nullptr },
        { "is_handwriting_directly_into_text_field_enabled", reinterpret_cast<getter>(PenAndInkSettings_get_IsHandwritingDirectlyIntoTextFieldEnabled), nullptr, nullptr, nullptr },
        { "is_touch_handwriting_enabled", reinterpret_cast<getter>(PenAndInkSettings_get_IsTouchHandwritingEnabled), nullptr, nullptr, nullptr },
        { "pen_handedness", reinterpret_cast<getter>(PenAndInkSettings_get_PenHandedness), nullptr, nullptr, nullptr },
        { "user_consents_to_handwriting_telemetry_collection", reinterpret_cast<getter>(PenAndInkSettings_get_UserConsentsToHandwritingTelemetryCollection), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PenAndInkSettings[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PenAndInkSettings) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PenAndInkSettings) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PenAndInkSettings) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PenAndInkSettings) },
        { }
    };

    static PyType_Spec type_spec_PenAndInkSettings = {
        "winrt._winrt_windows_ui_input_inking.PenAndInkSettings",
        sizeof(py::wrapper::Windows::UI::Input::Inking::PenAndInkSettings),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PenAndInkSettings};

    static PyGetSetDef getset_PenAndInkSettings_Static[] = {
        { }
    };

    static PyMethodDef methods_PenAndInkSettings_Static[] = {
        { "get_default", reinterpret_cast<PyCFunction>(PenAndInkSettings_GetDefault), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_PenAndInkSettings_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_PenAndInkSettings_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_PenAndInkSettings_Static) },
        { }
    };

    static PyType_Spec type_spec_PenAndInkSettings_Static =
    {
        "winrt._winrt_windows_ui_input_inking.PenAndInkSettings_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_PenAndInkSettings_Static
    };

    // ----- IInkPointFactory interface --------------------

    static PyObject* _new_IInkPointFactory(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Input::Inking::IInkPointFactory>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Input::Inking::IInkPointFactory>::type_name);
        return nullptr;
    }

    static void _dealloc_IInkPointFactory(py::wrapper::Windows::UI::Input::Inking::IInkPointFactory* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IInkPointFactory_CreateInkPoint(py::wrapper::Windows::UI::Input::Inking::IInkPointFactory* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Input.Inking.IInkPointFactory", L"CreateInkPoint", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Point>(args, 0);
                auto param1 = py::convert_to<float>(args, 1);

                return py::convert(self->obj.CreateInkPoint(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_IInkPointFactory(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Input::Inking::IInkPointFactory>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IInkPointFactory(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Input::Inking::IInkPointFactory>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IInkPointFactory[] = {
        { "create_ink_point", reinterpret_cast<PyCFunction>(IInkPointFactory_CreateInkPoint), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_IInkPointFactory, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IInkPointFactory), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IInkPointFactory[] = {
        { }
    };

    static PyType_Slot _type_slots_IInkPointFactory[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_IInkPointFactory) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IInkPointFactory) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IInkPointFactory) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IInkPointFactory) },
        { }
    };

    static PyType_Spec type_spec_IInkPointFactory = {
        "winrt._winrt_windows_ui_input_inking.IInkPointFactory",
        sizeof(py::wrapper::Windows::UI::Input::Inking::IInkPointFactory),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IInkPointFactory};

    // ----- IInkPresenterRulerFactory interface --------------------

    static PyObject* _new_IInkPresenterRulerFactory(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Input::Inking::IInkPresenterRulerFactory>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Input::Inking::IInkPresenterRulerFactory>::type_name);
        return nullptr;
    }

    static void _dealloc_IInkPresenterRulerFactory(py::wrapper::Windows::UI::Input::Inking::IInkPresenterRulerFactory* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IInkPresenterRulerFactory_Create(py::wrapper::Windows::UI::Input::Inking::IInkPresenterRulerFactory* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Input.Inking.IInkPresenterRulerFactory", L"Create", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Input::Inking::InkPresenter>(args, 0);

                return py::convert(self->obj.Create(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_IInkPresenterRulerFactory(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Input::Inking::IInkPresenterRulerFactory>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IInkPresenterRulerFactory(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Input::Inking::IInkPresenterRulerFactory>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IInkPresenterRulerFactory[] = {
        { "create", reinterpret_cast<PyCFunction>(IInkPresenterRulerFactory_Create), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_IInkPresenterRulerFactory, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IInkPresenterRulerFactory), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IInkPresenterRulerFactory[] = {
        { }
    };

    static PyType_Slot _type_slots_IInkPresenterRulerFactory[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_IInkPresenterRulerFactory) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IInkPresenterRulerFactory) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IInkPresenterRulerFactory) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IInkPresenterRulerFactory) },
        { }
    };

    static PyType_Spec type_spec_IInkPresenterRulerFactory = {
        "winrt._winrt_windows_ui_input_inking.IInkPresenterRulerFactory",
        sizeof(py::wrapper::Windows::UI::Input::Inking::IInkPresenterRulerFactory),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IInkPresenterRulerFactory};

    // ----- IInkPresenterStencil interface --------------------

    static PyObject* _new_IInkPresenterStencil(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Input::Inking::IInkPresenterStencil>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Input::Inking::IInkPresenterStencil>::type_name);
        return nullptr;
    }

    static void _dealloc_IInkPresenterStencil(py::wrapper::Windows::UI::Input::Inking::IInkPresenterStencil* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IInkPresenterStencil_get_BackgroundColor(py::wrapper::Windows::UI::Input::Inking::IInkPresenterStencil* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Inking.IInkPresenterStencil", L"BackgroundColor");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.BackgroundColor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IInkPresenterStencil_put_BackgroundColor(py::wrapper::Windows::UI::Input::Inking::IInkPresenterStencil* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Inking.IInkPresenterStencil", L"BackgroundColor");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Color>(arg);

            self->obj.BackgroundColor(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IInkPresenterStencil_get_ForegroundColor(py::wrapper::Windows::UI::Input::Inking::IInkPresenterStencil* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Inking.IInkPresenterStencil", L"ForegroundColor");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ForegroundColor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IInkPresenterStencil_put_ForegroundColor(py::wrapper::Windows::UI::Input::Inking::IInkPresenterStencil* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Inking.IInkPresenterStencil", L"ForegroundColor");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Color>(arg);

            self->obj.ForegroundColor(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IInkPresenterStencil_get_IsVisible(py::wrapper::Windows::UI::Input::Inking::IInkPresenterStencil* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Inking.IInkPresenterStencil", L"IsVisible");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsVisible());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IInkPresenterStencil_put_IsVisible(py::wrapper::Windows::UI::Input::Inking::IInkPresenterStencil* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Inking.IInkPresenterStencil", L"IsVisible");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsVisible(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IInkPresenterStencil_get_Kind(py::wrapper::Windows::UI::Input::Inking::IInkPresenterStencil* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Inking.IInkPresenterStencil", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IInkPresenterStencil_get_Transform(py::wrapper::Windows::UI::Input::Inking::IInkPresenterStencil* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Inking.IInkPresenterStencil", L"Transform");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Transform());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IInkPresenterStencil_put_Transform(py::wrapper::Windows::UI::Input::Inking::IInkPresenterStencil* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Inking.IInkPresenterStencil", L"Transform");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::Numerics::float3x2>(arg);

            self->obj.Transform(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_IInkPresenterStencil(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Input::Inking::IInkPresenterStencil>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IInkPresenterStencil(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Input::Inking::IInkPresenterStencil>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IInkPresenterStencil[] = {
        { "_assign_array_", _assign_array_IInkPresenterStencil, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IInkPresenterStencil), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IInkPresenterStencil[] = {
        { "background_color", reinterpret_cast<getter>(IInkPresenterStencil_get_BackgroundColor), reinterpret_cast<setter>(IInkPresenterStencil_put_BackgroundColor), nullptr, nullptr },
        { "foreground_color", reinterpret_cast<getter>(IInkPresenterStencil_get_ForegroundColor), reinterpret_cast<setter>(IInkPresenterStencil_put_ForegroundColor), nullptr, nullptr },
        { "is_visible", reinterpret_cast<getter>(IInkPresenterStencil_get_IsVisible), reinterpret_cast<setter>(IInkPresenterStencil_put_IsVisible), nullptr, nullptr },
        { "kind", reinterpret_cast<getter>(IInkPresenterStencil_get_Kind), nullptr, nullptr, nullptr },
        { "transform", reinterpret_cast<getter>(IInkPresenterStencil_get_Transform), reinterpret_cast<setter>(IInkPresenterStencil_put_Transform), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IInkPresenterStencil[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_IInkPresenterStencil) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IInkPresenterStencil) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IInkPresenterStencil) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IInkPresenterStencil) },
        { }
    };

    static PyType_Spec type_spec_IInkPresenterStencil = {
        "winrt._winrt_windows_ui_input_inking.IInkPresenterStencil",
        sizeof(py::wrapper::Windows::UI::Input::Inking::IInkPresenterStencil),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IInkPresenterStencil};

    // ----- IInkRecognizerContainer interface --------------------

    static PyObject* _new_IInkRecognizerContainer(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Input::Inking::IInkRecognizerContainer>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Input::Inking::IInkRecognizerContainer>::type_name);
        return nullptr;
    }

    static void _dealloc_IInkRecognizerContainer(py::wrapper::Windows::UI::Input::Inking::IInkRecognizerContainer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IInkRecognizerContainer_GetRecognizers(py::wrapper::Windows::UI::Input::Inking::IInkRecognizerContainer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Input.Inking.IInkRecognizerContainer", L"GetRecognizers", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetRecognizers());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IInkRecognizerContainer_RecognizeAsync(py::wrapper::Windows::UI::Input::Inking::IInkRecognizerContainer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Input.Inking.IInkRecognizerContainer", L"RecognizeAsync", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Input::Inking::InkStrokeContainer>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Input::Inking::InkRecognitionTarget>(args, 1);

                return py::convert(self->obj.RecognizeAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IInkRecognizerContainer_SetDefaultRecognizer(py::wrapper::Windows::UI::Input::Inking::IInkRecognizerContainer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Input.Inking.IInkRecognizerContainer", L"SetDefaultRecognizer", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Input::Inking::InkRecognizer>(args, 0);

                self->obj.SetDefaultRecognizer(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_IInkRecognizerContainer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Input::Inking::IInkRecognizerContainer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IInkRecognizerContainer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Input::Inking::IInkRecognizerContainer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IInkRecognizerContainer[] = {
        { "get_recognizers", reinterpret_cast<PyCFunction>(IInkRecognizerContainer_GetRecognizers), METH_VARARGS, nullptr },
        { "recognize_async", reinterpret_cast<PyCFunction>(IInkRecognizerContainer_RecognizeAsync), METH_VARARGS, nullptr },
        { "set_default_recognizer", reinterpret_cast<PyCFunction>(IInkRecognizerContainer_SetDefaultRecognizer), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_IInkRecognizerContainer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IInkRecognizerContainer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IInkRecognizerContainer[] = {
        { }
    };

    static PyType_Slot _type_slots_IInkRecognizerContainer[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_IInkRecognizerContainer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IInkRecognizerContainer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IInkRecognizerContainer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IInkRecognizerContainer) },
        { }
    };

    static PyType_Spec type_spec_IInkRecognizerContainer = {
        "winrt._winrt_windows_ui_input_inking.IInkRecognizerContainer",
        sizeof(py::wrapper::Windows::UI::Input::Inking::IInkRecognizerContainer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IInkRecognizerContainer};

    // ----- IInkStrokeContainer interface --------------------

    static PyObject* _new_IInkStrokeContainer(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Input::Inking::IInkStrokeContainer>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Input::Inking::IInkStrokeContainer>::type_name);
        return nullptr;
    }

    static void _dealloc_IInkStrokeContainer(py::wrapper::Windows::UI::Input::Inking::IInkStrokeContainer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IInkStrokeContainer_AddStroke(py::wrapper::Windows::UI::Input::Inking::IInkStrokeContainer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Input.Inking.IInkStrokeContainer", L"AddStroke", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Input::Inking::InkStroke>(args, 0);

                self->obj.AddStroke(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IInkStrokeContainer_CanPasteFromClipboard(py::wrapper::Windows::UI::Input::Inking::IInkStrokeContainer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Input.Inking.IInkStrokeContainer", L"CanPasteFromClipboard", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.CanPasteFromClipboard());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IInkStrokeContainer_CopySelectedToClipboard(py::wrapper::Windows::UI::Input::Inking::IInkStrokeContainer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Input.Inking.IInkStrokeContainer", L"CopySelectedToClipboard", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.CopySelectedToClipboard();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IInkStrokeContainer_DeleteSelected(py::wrapper::Windows::UI::Input::Inking::IInkStrokeContainer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Input.Inking.IInkStrokeContainer", L"DeleteSelected", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.DeleteSelected());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IInkStrokeContainer_GetRecognitionResults(py::wrapper::Windows::UI::Input::Inking::IInkStrokeContainer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Input.Inking.IInkStrokeContainer", L"GetRecognitionResults", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetRecognitionResults());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IInkStrokeContainer_GetStrokes(py::wrapper::Windows::UI::Input::Inking::IInkStrokeContainer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Input.Inking.IInkStrokeContainer", L"GetStrokes", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetStrokes());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IInkStrokeContainer_LoadAsync(py::wrapper::Windows::UI::Input::Inking::IInkStrokeContainer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Input.Inking.IInkStrokeContainer", L"LoadAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IInputStream>(args, 0);

                return py::convert(self->obj.LoadAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IInkStrokeContainer_MoveSelected(py::wrapper::Windows::UI::Input::Inking::IInkStrokeContainer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Input.Inking.IInkStrokeContainer", L"MoveSelected", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Point>(args, 0);

                return py::convert(self->obj.MoveSelected(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IInkStrokeContainer_PasteFromClipboard(py::wrapper::Windows::UI::Input::Inking::IInkStrokeContainer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Input.Inking.IInkStrokeContainer", L"PasteFromClipboard", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Point>(args, 0);

                return py::convert(self->obj.PasteFromClipboard(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IInkStrokeContainer_SaveAsync(py::wrapper::Windows::UI::Input::Inking::IInkStrokeContainer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Input.Inking.IInkStrokeContainer", L"SaveAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IOutputStream>(args, 0);

                return py::convert(self->obj.SaveAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IInkStrokeContainer_SelectWithLine(py::wrapper::Windows::UI::Input::Inking::IInkStrokeContainer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Input.Inking.IInkStrokeContainer", L"SelectWithLine", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Point>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Point>(args, 1);

                return py::convert(self->obj.SelectWithLine(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IInkStrokeContainer_SelectWithPolyLine(py::wrapper::Windows::UI::Input::Inking::IInkStrokeContainer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Input.Inking.IInkStrokeContainer", L"SelectWithPolyLine", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Foundation::Point>>(args, 0);

                return py::convert(self->obj.SelectWithPolyLine(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IInkStrokeContainer_UpdateRecognitionResults(py::wrapper::Windows::UI::Input::Inking::IInkStrokeContainer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Input.Inking.IInkStrokeContainer", L"UpdateRecognitionResults", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::UI::Input::Inking::InkRecognitionResult>>(args, 0);

                self->obj.UpdateRecognitionResults(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IInkStrokeContainer_get_BoundingRect(py::wrapper::Windows::UI::Input::Inking::IInkStrokeContainer* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Inking.IInkStrokeContainer", L"BoundingRect");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.BoundingRect());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_IInkStrokeContainer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Input::Inking::IInkStrokeContainer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IInkStrokeContainer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Input::Inking::IInkStrokeContainer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IInkStrokeContainer[] = {
        { "add_stroke", reinterpret_cast<PyCFunction>(IInkStrokeContainer_AddStroke), METH_VARARGS, nullptr },
        { "can_paste_from_clipboard", reinterpret_cast<PyCFunction>(IInkStrokeContainer_CanPasteFromClipboard), METH_VARARGS, nullptr },
        { "copy_selected_to_clipboard", reinterpret_cast<PyCFunction>(IInkStrokeContainer_CopySelectedToClipboard), METH_VARARGS, nullptr },
        { "delete_selected", reinterpret_cast<PyCFunction>(IInkStrokeContainer_DeleteSelected), METH_VARARGS, nullptr },
        { "get_recognition_results", reinterpret_cast<PyCFunction>(IInkStrokeContainer_GetRecognitionResults), METH_VARARGS, nullptr },
        { "get_strokes", reinterpret_cast<PyCFunction>(IInkStrokeContainer_GetStrokes), METH_VARARGS, nullptr },
        { "load_async", reinterpret_cast<PyCFunction>(IInkStrokeContainer_LoadAsync), METH_VARARGS, nullptr },
        { "move_selected", reinterpret_cast<PyCFunction>(IInkStrokeContainer_MoveSelected), METH_VARARGS, nullptr },
        { "paste_from_clipboard", reinterpret_cast<PyCFunction>(IInkStrokeContainer_PasteFromClipboard), METH_VARARGS, nullptr },
        { "save_async", reinterpret_cast<PyCFunction>(IInkStrokeContainer_SaveAsync), METH_VARARGS, nullptr },
        { "select_with_line", reinterpret_cast<PyCFunction>(IInkStrokeContainer_SelectWithLine), METH_VARARGS, nullptr },
        { "select_with_poly_line", reinterpret_cast<PyCFunction>(IInkStrokeContainer_SelectWithPolyLine), METH_VARARGS, nullptr },
        { "update_recognition_results", reinterpret_cast<PyCFunction>(IInkStrokeContainer_UpdateRecognitionResults), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_IInkStrokeContainer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IInkStrokeContainer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IInkStrokeContainer[] = {
        { "bounding_rect", reinterpret_cast<getter>(IInkStrokeContainer_get_BoundingRect), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IInkStrokeContainer[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_IInkStrokeContainer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IInkStrokeContainer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IInkStrokeContainer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IInkStrokeContainer) },
        { }
    };

    static PyType_Spec type_spec_IInkStrokeContainer = {
        "winrt._winrt_windows_ui_input_inking.IInkStrokeContainer",
        sizeof(py::wrapper::Windows::UI::Input::Inking::IInkStrokeContainer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IInkStrokeContainer};

    // ----- Windows.UI.Input.Inking Initialization --------------------

    PyDoc_STRVAR(module_doc, "Windows.UI.Input.Inking");

    static PyModuleDef module_def = {
        PyModuleDef_HEAD_INIT,
        "_winrt_windows_ui_input_inking",
        module_doc,
        0,
        nullptr,
        nullptr,
        nullptr,
        nullptr,
        nullptr};
} // py::cpp::Windows::UI::Input::Inking

PyMODINIT_FUNC PyInit__winrt_windows_ui_input_inking(void) noexcept
{
    using namespace py::cpp::Windows::UI::Input::Inking;

    if (py::import_winrt_runtime() == -1)
    {
        return nullptr;
    }

    py::pyobj_handle module{PyModule_Create(&module_def)};

    if (!module)
    {
        return nullptr;
    }

    auto object_type = py::get_object_type();
    if (!object_type)
    {
        return nullptr;
    }

    py::pyobj_handle object_bases{PyTuple_Pack(1, object_type)};

    if (!object_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_InkDrawingAttributes_Static{PyType_FromSpec(&type_spec_InkDrawingAttributes_Static)};
    if (!type_InkDrawingAttributes_Static)
    {
        return nullptr;
    }

    py::pytype_handle InkDrawingAttributes_type{py::register_python_type(module.get(), &type_spec_InkDrawingAttributes, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_InkDrawingAttributes_Static.get()))};
    if (!InkDrawingAttributes_type)
    {
        return nullptr;
    }

    py::pytype_handle InkDrawingAttributesPencilProperties_type{py::register_python_type(module.get(), &type_spec_InkDrawingAttributesPencilProperties, object_bases.get(), nullptr)};
    if (!InkDrawingAttributesPencilProperties_type)
    {
        return nullptr;
    }

    py::pytype_handle InkInputConfiguration_type{py::register_python_type(module.get(), &type_spec_InkInputConfiguration, object_bases.get(), nullptr)};
    if (!InkInputConfiguration_type)
    {
        return nullptr;
    }

    py::pytype_handle InkInputProcessingConfiguration_type{py::register_python_type(module.get(), &type_spec_InkInputProcessingConfiguration, object_bases.get(), nullptr)};
    if (!InkInputProcessingConfiguration_type)
    {
        return nullptr;
    }

    py::pytype_handle InkManager_type{py::register_python_type(module.get(), &type_spec_InkManager, object_bases.get(), nullptr)};
    if (!InkManager_type)
    {
        return nullptr;
    }

    py::pytype_handle InkModelerAttributes_type{py::register_python_type(module.get(), &type_spec_InkModelerAttributes, object_bases.get(), nullptr)};
    if (!InkModelerAttributes_type)
    {
        return nullptr;
    }

    py::pytype_handle InkPoint_type{py::register_python_type(module.get(), &type_spec_InkPoint, object_bases.get(), nullptr)};
    if (!InkPoint_type)
    {
        return nullptr;
    }

    py::pytype_handle InkPresenter_type{py::register_python_type(module.get(), &type_spec_InkPresenter, object_bases.get(), nullptr)};
    if (!InkPresenter_type)
    {
        return nullptr;
    }

    py::pytype_handle InkPresenterProtractor_type{py::register_python_type(module.get(), &type_spec_InkPresenterProtractor, object_bases.get(), nullptr)};
    if (!InkPresenterProtractor_type)
    {
        return nullptr;
    }

    py::pytype_handle InkPresenterRuler_type{py::register_python_type(module.get(), &type_spec_InkPresenterRuler, object_bases.get(), nullptr)};
    if (!InkPresenterRuler_type)
    {
        return nullptr;
    }

    py::pytype_handle InkRecognitionResult_type{py::register_python_type(module.get(), &type_spec_InkRecognitionResult, object_bases.get(), nullptr)};
    if (!InkRecognitionResult_type)
    {
        return nullptr;
    }

    py::pytype_handle InkRecognizer_type{py::register_python_type(module.get(), &type_spec_InkRecognizer, object_bases.get(), nullptr)};
    if (!InkRecognizer_type)
    {
        return nullptr;
    }

    py::pytype_handle InkRecognizerContainer_type{py::register_python_type(module.get(), &type_spec_InkRecognizerContainer, object_bases.get(), nullptr)};
    if (!InkRecognizerContainer_type)
    {
        return nullptr;
    }

    py::pytype_handle InkStroke_type{py::register_python_type(module.get(), &type_spec_InkStroke, object_bases.get(), nullptr)};
    if (!InkStroke_type)
    {
        return nullptr;
    }

    py::pytype_handle InkStrokeBuilder_type{py::register_python_type(module.get(), &type_spec_InkStrokeBuilder, object_bases.get(), nullptr)};
    if (!InkStrokeBuilder_type)
    {
        return nullptr;
    }

    py::pytype_handle InkStrokeContainer_type{py::register_python_type(module.get(), &type_spec_InkStrokeContainer, object_bases.get(), nullptr)};
    if (!InkStrokeContainer_type)
    {
        return nullptr;
    }

    py::pytype_handle InkStrokeInput_type{py::register_python_type(module.get(), &type_spec_InkStrokeInput, object_bases.get(), nullptr)};
    if (!InkStrokeInput_type)
    {
        return nullptr;
    }

    py::pytype_handle InkStrokeRenderingSegment_type{py::register_python_type(module.get(), &type_spec_InkStrokeRenderingSegment, object_bases.get(), nullptr)};
    if (!InkStrokeRenderingSegment_type)
    {
        return nullptr;
    }

    py::pytype_handle InkStrokesCollectedEventArgs_type{py::register_python_type(module.get(), &type_spec_InkStrokesCollectedEventArgs, object_bases.get(), nullptr)};
    if (!InkStrokesCollectedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle InkStrokesErasedEventArgs_type{py::register_python_type(module.get(), &type_spec_InkStrokesErasedEventArgs, object_bases.get(), nullptr)};
    if (!InkStrokesErasedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle InkSynchronizer_type{py::register_python_type(module.get(), &type_spec_InkSynchronizer, object_bases.get(), nullptr)};
    if (!InkSynchronizer_type)
    {
        return nullptr;
    }

    py::pytype_handle InkUnprocessedInput_type{py::register_python_type(module.get(), &type_spec_InkUnprocessedInput, object_bases.get(), nullptr)};
    if (!InkUnprocessedInput_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_PenAndInkSettings_Static{PyType_FromSpec(&type_spec_PenAndInkSettings_Static)};
    if (!type_PenAndInkSettings_Static)
    {
        return nullptr;
    }

    py::pytype_handle PenAndInkSettings_type{py::register_python_type(module.get(), &type_spec_PenAndInkSettings, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_PenAndInkSettings_Static.get()))};
    if (!PenAndInkSettings_type)
    {
        return nullptr;
    }

    py::pytype_handle IInkPointFactory_type{py::register_python_type(module.get(), &type_spec_IInkPointFactory, object_bases.get(), nullptr)};
    if (!IInkPointFactory_type)
    {
        return nullptr;
    }

    py::pytype_handle IInkPresenterRulerFactory_type{py::register_python_type(module.get(), &type_spec_IInkPresenterRulerFactory, object_bases.get(), nullptr)};
    if (!IInkPresenterRulerFactory_type)
    {
        return nullptr;
    }

    py::pytype_handle IInkPresenterStencil_type{py::register_python_type(module.get(), &type_spec_IInkPresenterStencil, object_bases.get(), nullptr)};
    if (!IInkPresenterStencil_type)
    {
        return nullptr;
    }

    py::pytype_handle IInkRecognizerContainer_type{py::register_python_type(module.get(), &type_spec_IInkRecognizerContainer, object_bases.get(), nullptr)};
    if (!IInkRecognizerContainer_type)
    {
        return nullptr;
    }

    py::pytype_handle IInkStrokeContainer_type{py::register_python_type(module.get(), &type_spec_IInkStrokeContainer, object_bases.get(), nullptr)};
    if (!IInkStrokeContainer_type)
    {
        return nullptr;
    }


    return module.detach();
}
