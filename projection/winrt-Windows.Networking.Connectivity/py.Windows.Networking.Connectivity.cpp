// WARNING: Please don't edit this file. It was generated by Python/WinRT v2.0.0-beta.2

#include "py.Windows.Networking.Connectivity.h"


namespace py::cpp::Windows::Networking::Connectivity
{
    // ----- AttributedNetworkUsage class --------------------

    static PyObject* _new_AttributedNetworkUsage(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Networking::Connectivity::AttributedNetworkUsage>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Networking::Connectivity::AttributedNetworkUsage>::type_name);
        return nullptr;
    }

    static void _dealloc_AttributedNetworkUsage(py::wrapper::Windows::Networking::Connectivity::AttributedNetworkUsage* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AttributedNetworkUsage_get_AttributionId(py::wrapper::Windows::Networking::Connectivity::AttributedNetworkUsage* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Connectivity.AttributedNetworkUsage", L"AttributionId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AttributionId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AttributedNetworkUsage_get_AttributionName(py::wrapper::Windows::Networking::Connectivity::AttributedNetworkUsage* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Connectivity.AttributedNetworkUsage", L"AttributionName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AttributionName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AttributedNetworkUsage_get_AttributionThumbnail(py::wrapper::Windows::Networking::Connectivity::AttributedNetworkUsage* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Connectivity.AttributedNetworkUsage", L"AttributionThumbnail"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AttributionThumbnail());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AttributedNetworkUsage_get_BytesReceived(py::wrapper::Windows::Networking::Connectivity::AttributedNetworkUsage* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Connectivity.AttributedNetworkUsage", L"BytesReceived"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.BytesReceived());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AttributedNetworkUsage_get_BytesSent(py::wrapper::Windows::Networking::Connectivity::AttributedNetworkUsage* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Connectivity.AttributedNetworkUsage", L"BytesSent"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.BytesSent());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AttributedNetworkUsage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::Connectivity::AttributedNetworkUsage>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AttributedNetworkUsage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Connectivity::AttributedNetworkUsage>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AttributedNetworkUsage[] = {
        { "_assign_array_", _assign_array_AttributedNetworkUsage, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AttributedNetworkUsage), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AttributedNetworkUsage[] = {
        { "attribution_id", reinterpret_cast<getter>(AttributedNetworkUsage_get_AttributionId), nullptr, nullptr, nullptr },
        { "attribution_name", reinterpret_cast<getter>(AttributedNetworkUsage_get_AttributionName), nullptr, nullptr, nullptr },
        { "attribution_thumbnail", reinterpret_cast<getter>(AttributedNetworkUsage_get_AttributionThumbnail), nullptr, nullptr, nullptr },
        { "bytes_received", reinterpret_cast<getter>(AttributedNetworkUsage_get_BytesReceived), nullptr, nullptr, nullptr },
        { "bytes_sent", reinterpret_cast<getter>(AttributedNetworkUsage_get_BytesSent), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AttributedNetworkUsage[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AttributedNetworkUsage) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AttributedNetworkUsage) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AttributedNetworkUsage) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AttributedNetworkUsage) },
        { },
    };

    static PyType_Spec type_spec_AttributedNetworkUsage =
    {
        "winrt._winrt_windows_networking_connectivity.AttributedNetworkUsage",
        sizeof(py::wrapper::Windows::Networking::Connectivity::AttributedNetworkUsage),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AttributedNetworkUsage
    };

    // ----- CellularApnContext class --------------------

    static PyObject* _new_CellularApnContext(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Networking::Connectivity::CellularApnContext instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_CellularApnContext(py::wrapper::Windows::Networking::Connectivity::CellularApnContext* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CellularApnContext_get_UserName(py::wrapper::Windows::Networking::Connectivity::CellularApnContext* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Connectivity.CellularApnContext", L"UserName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.UserName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CellularApnContext_put_UserName(py::wrapper::Windows::Networking::Connectivity::CellularApnContext* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Connectivity.CellularApnContext", L"UserName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.UserName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CellularApnContext_get_ProviderId(py::wrapper::Windows::Networking::Connectivity::CellularApnContext* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Connectivity.CellularApnContext", L"ProviderId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ProviderId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CellularApnContext_put_ProviderId(py::wrapper::Windows::Networking::Connectivity::CellularApnContext* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Connectivity.CellularApnContext", L"ProviderId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.ProviderId(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CellularApnContext_get_Password(py::wrapper::Windows::Networking::Connectivity::CellularApnContext* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Connectivity.CellularApnContext", L"Password"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Password());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CellularApnContext_put_Password(py::wrapper::Windows::Networking::Connectivity::CellularApnContext* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Connectivity.CellularApnContext", L"Password"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Password(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CellularApnContext_get_IsCompressionEnabled(py::wrapper::Windows::Networking::Connectivity::CellularApnContext* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Connectivity.CellularApnContext", L"IsCompressionEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsCompressionEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CellularApnContext_put_IsCompressionEnabled(py::wrapper::Windows::Networking::Connectivity::CellularApnContext* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Connectivity.CellularApnContext", L"IsCompressionEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsCompressionEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CellularApnContext_get_AuthenticationType(py::wrapper::Windows::Networking::Connectivity::CellularApnContext* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Connectivity.CellularApnContext", L"AuthenticationType"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AuthenticationType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CellularApnContext_put_AuthenticationType(py::wrapper::Windows::Networking::Connectivity::CellularApnContext* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Connectivity.CellularApnContext", L"AuthenticationType"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Networking::Connectivity::CellularApnAuthenticationType>(arg);

            self->obj.AuthenticationType(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CellularApnContext_get_AccessPointName(py::wrapper::Windows::Networking::Connectivity::CellularApnContext* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Connectivity.CellularApnContext", L"AccessPointName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AccessPointName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CellularApnContext_put_AccessPointName(py::wrapper::Windows::Networking::Connectivity::CellularApnContext* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Connectivity.CellularApnContext", L"AccessPointName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.AccessPointName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CellularApnContext_get_ProfileName(py::wrapper::Windows::Networking::Connectivity::CellularApnContext* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Connectivity.CellularApnContext", L"ProfileName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ProfileName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CellularApnContext_put_ProfileName(py::wrapper::Windows::Networking::Connectivity::CellularApnContext* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Connectivity.CellularApnContext", L"ProfileName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.ProfileName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_CellularApnContext(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::Connectivity::CellularApnContext>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CellularApnContext(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Connectivity::CellularApnContext>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CellularApnContext[] = {
        { "_assign_array_", _assign_array_CellularApnContext, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CellularApnContext), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CellularApnContext[] = {
        { "user_name", reinterpret_cast<getter>(CellularApnContext_get_UserName), reinterpret_cast<setter>(CellularApnContext_put_UserName), nullptr, nullptr },
        { "provider_id", reinterpret_cast<getter>(CellularApnContext_get_ProviderId), reinterpret_cast<setter>(CellularApnContext_put_ProviderId), nullptr, nullptr },
        { "password", reinterpret_cast<getter>(CellularApnContext_get_Password), reinterpret_cast<setter>(CellularApnContext_put_Password), nullptr, nullptr },
        { "is_compression_enabled", reinterpret_cast<getter>(CellularApnContext_get_IsCompressionEnabled), reinterpret_cast<setter>(CellularApnContext_put_IsCompressionEnabled), nullptr, nullptr },
        { "authentication_type", reinterpret_cast<getter>(CellularApnContext_get_AuthenticationType), reinterpret_cast<setter>(CellularApnContext_put_AuthenticationType), nullptr, nullptr },
        { "access_point_name", reinterpret_cast<getter>(CellularApnContext_get_AccessPointName), reinterpret_cast<setter>(CellularApnContext_put_AccessPointName), nullptr, nullptr },
        { "profile_name", reinterpret_cast<getter>(CellularApnContext_get_ProfileName), reinterpret_cast<setter>(CellularApnContext_put_ProfileName), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CellularApnContext[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_CellularApnContext) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CellularApnContext) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CellularApnContext) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CellularApnContext) },
        { },
    };

    static PyType_Spec type_spec_CellularApnContext =
    {
        "winrt._winrt_windows_networking_connectivity.CellularApnContext",
        sizeof(py::wrapper::Windows::Networking::Connectivity::CellularApnContext),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CellularApnContext
    };

    // ----- ConnectionCost class --------------------

    static PyObject* _new_ConnectionCost(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Networking::Connectivity::ConnectionCost>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Networking::Connectivity::ConnectionCost>::type_name);
        return nullptr;
    }

    static void _dealloc_ConnectionCost(py::wrapper::Windows::Networking::Connectivity::ConnectionCost* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ConnectionCost_get_ApproachingDataLimit(py::wrapper::Windows::Networking::Connectivity::ConnectionCost* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Connectivity.ConnectionCost", L"ApproachingDataLimit"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ApproachingDataLimit());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ConnectionCost_get_NetworkCostType(py::wrapper::Windows::Networking::Connectivity::ConnectionCost* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Connectivity.ConnectionCost", L"NetworkCostType"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.NetworkCostType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ConnectionCost_get_OverDataLimit(py::wrapper::Windows::Networking::Connectivity::ConnectionCost* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Connectivity.ConnectionCost", L"OverDataLimit"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.OverDataLimit());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ConnectionCost_get_Roaming(py::wrapper::Windows::Networking::Connectivity::ConnectionCost* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Connectivity.ConnectionCost", L"Roaming"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Roaming());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ConnectionCost_get_BackgroundDataUsageRestricted(py::wrapper::Windows::Networking::Connectivity::ConnectionCost* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Connectivity.ConnectionCost", L"BackgroundDataUsageRestricted"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.BackgroundDataUsageRestricted());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ConnectionCost(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::Connectivity::ConnectionCost>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ConnectionCost(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Connectivity::ConnectionCost>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ConnectionCost[] = {
        { "_assign_array_", _assign_array_ConnectionCost, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ConnectionCost), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ConnectionCost[] = {
        { "approaching_data_limit", reinterpret_cast<getter>(ConnectionCost_get_ApproachingDataLimit), nullptr, nullptr, nullptr },
        { "network_cost_type", reinterpret_cast<getter>(ConnectionCost_get_NetworkCostType), nullptr, nullptr, nullptr },
        { "over_data_limit", reinterpret_cast<getter>(ConnectionCost_get_OverDataLimit), nullptr, nullptr, nullptr },
        { "roaming", reinterpret_cast<getter>(ConnectionCost_get_Roaming), nullptr, nullptr, nullptr },
        { "background_data_usage_restricted", reinterpret_cast<getter>(ConnectionCost_get_BackgroundDataUsageRestricted), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ConnectionCost[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ConnectionCost) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ConnectionCost) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ConnectionCost) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ConnectionCost) },
        { },
    };

    static PyType_Spec type_spec_ConnectionCost =
    {
        "winrt._winrt_windows_networking_connectivity.ConnectionCost",
        sizeof(py::wrapper::Windows::Networking::Connectivity::ConnectionCost),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ConnectionCost
    };

    // ----- ConnectionProfile class --------------------

    static PyObject* _new_ConnectionProfile(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Networking::Connectivity::ConnectionProfile>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Networking::Connectivity::ConnectionProfile>::type_name);
        return nullptr;
    }

    static void _dealloc_ConnectionProfile(py::wrapper::Windows::Networking::Connectivity::ConnectionProfile* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ConnectionProfile_GetAttributedNetworkUsageAsync(py::wrapper::Windows::Networking::Connectivity::ConnectionProfile* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Connectivity.ConnectionProfile", L"GetAttributedNetworkUsageAsync", 3))
            {
                py::set_arg_count_version_error(3);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::DateTime>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::DateTime>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Networking::Connectivity::NetworkUsageStates>(args, 2);

                return py::convert(self->obj.GetAttributedNetworkUsageAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ConnectionProfile_GetConnectionCost(py::wrapper::Windows::Networking::Connectivity::ConnectionProfile* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Connectivity.ConnectionProfile", L"GetConnectionCost", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetConnectionCost());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ConnectionProfile_GetConnectivityIntervalsAsync(py::wrapper::Windows::Networking::Connectivity::ConnectionProfile* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Connectivity.ConnectionProfile", L"GetConnectivityIntervalsAsync", 3))
            {
                py::set_arg_count_version_error(3);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::DateTime>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::DateTime>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Networking::Connectivity::NetworkUsageStates>(args, 2);

                return py::convert(self->obj.GetConnectivityIntervalsAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ConnectionProfile_GetDataPlanStatus(py::wrapper::Windows::Networking::Connectivity::ConnectionProfile* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Connectivity.ConnectionProfile", L"GetDataPlanStatus", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetDataPlanStatus());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ConnectionProfile_GetDomainConnectivityLevel(py::wrapper::Windows::Networking::Connectivity::ConnectionProfile* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Connectivity.ConnectionProfile", L"GetDomainConnectivityLevel", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetDomainConnectivityLevel());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ConnectionProfile_GetLocalUsage(py::wrapper::Windows::Networking::Connectivity::ConnectionProfile* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Connectivity.ConnectionProfile", L"GetLocalUsage", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::DateTime>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::DateTime>(args, 1);

                return py::convert(self->obj.GetLocalUsage(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Connectivity.ConnectionProfile", L"GetLocalUsage", 3))
            {
                py::set_arg_count_version_error(3);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::DateTime>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::DateTime>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Networking::Connectivity::RoamingStates>(args, 2);

                return py::convert(self->obj.GetLocalUsage(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ConnectionProfile_GetNetworkConnectivityLevel(py::wrapper::Windows::Networking::Connectivity::ConnectionProfile* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Connectivity.ConnectionProfile", L"GetNetworkConnectivityLevel", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetNetworkConnectivityLevel());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ConnectionProfile_GetNetworkNames(py::wrapper::Windows::Networking::Connectivity::ConnectionProfile* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Connectivity.ConnectionProfile", L"GetNetworkNames", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetNetworkNames());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ConnectionProfile_GetNetworkUsageAsync(py::wrapper::Windows::Networking::Connectivity::ConnectionProfile* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 4)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Connectivity.ConnectionProfile", L"GetNetworkUsageAsync", 4))
            {
                py::set_arg_count_version_error(4);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::DateTime>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::DateTime>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Networking::Connectivity::DataUsageGranularity>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Networking::Connectivity::NetworkUsageStates>(args, 3);

                return py::convert(self->obj.GetNetworkUsageAsync(param0, param1, param2, param3));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ConnectionProfile_GetProviderNetworkUsageAsync(py::wrapper::Windows::Networking::Connectivity::ConnectionProfile* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Connectivity.ConnectionProfile", L"GetProviderNetworkUsageAsync", 3))
            {
                py::set_arg_count_version_error(3);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::DateTime>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::DateTime>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Networking::Connectivity::NetworkUsageStates>(args, 2);

                return py::convert(self->obj.GetProviderNetworkUsageAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ConnectionProfile_GetSignalBars(py::wrapper::Windows::Networking::Connectivity::ConnectionProfile* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Connectivity.ConnectionProfile", L"GetSignalBars", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetSignalBars());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ConnectionProfile_IsDomainAuthenticatedBy(py::wrapper::Windows::Networking::Connectivity::ConnectionProfile* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Connectivity.ConnectionProfile", L"IsDomainAuthenticatedBy", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Networking::Connectivity::DomainAuthenticationKind>(args, 0);

                return py::convert(self->obj.IsDomainAuthenticatedBy(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ConnectionProfile_TryDeleteAsync(py::wrapper::Windows::Networking::Connectivity::ConnectionProfile* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Connectivity.ConnectionProfile", L"TryDeleteAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.TryDeleteAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ConnectionProfile_get_NetworkAdapter(py::wrapper::Windows::Networking::Connectivity::ConnectionProfile* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Connectivity.ConnectionProfile", L"NetworkAdapter"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.NetworkAdapter());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ConnectionProfile_get_NetworkSecuritySettings(py::wrapper::Windows::Networking::Connectivity::ConnectionProfile* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Connectivity.ConnectionProfile", L"NetworkSecuritySettings"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.NetworkSecuritySettings());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ConnectionProfile_get_ProfileName(py::wrapper::Windows::Networking::Connectivity::ConnectionProfile* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Connectivity.ConnectionProfile", L"ProfileName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ProfileName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ConnectionProfile_get_IsWlanConnectionProfile(py::wrapper::Windows::Networking::Connectivity::ConnectionProfile* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Connectivity.ConnectionProfile", L"IsWlanConnectionProfile"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsWlanConnectionProfile());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ConnectionProfile_get_IsWwanConnectionProfile(py::wrapper::Windows::Networking::Connectivity::ConnectionProfile* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Connectivity.ConnectionProfile", L"IsWwanConnectionProfile"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsWwanConnectionProfile());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ConnectionProfile_get_ServiceProviderGuid(py::wrapper::Windows::Networking::Connectivity::ConnectionProfile* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Connectivity.ConnectionProfile", L"ServiceProviderGuid"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ServiceProviderGuid());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ConnectionProfile_get_WlanConnectionProfileDetails(py::wrapper::Windows::Networking::Connectivity::ConnectionProfile* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Connectivity.ConnectionProfile", L"WlanConnectionProfileDetails"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.WlanConnectionProfileDetails());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ConnectionProfile_get_WwanConnectionProfileDetails(py::wrapper::Windows::Networking::Connectivity::ConnectionProfile* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Connectivity.ConnectionProfile", L"WwanConnectionProfileDetails"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.WwanConnectionProfileDetails());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ConnectionProfile_get_CanDelete(py::wrapper::Windows::Networking::Connectivity::ConnectionProfile* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Connectivity.ConnectionProfile", L"CanDelete"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CanDelete());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ConnectionProfile(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::Connectivity::ConnectionProfile>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ConnectionProfile(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Connectivity::ConnectionProfile>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ConnectionProfile[] = {
        { "get_attributed_network_usage_async", reinterpret_cast<PyCFunction>(ConnectionProfile_GetAttributedNetworkUsageAsync), METH_VARARGS, nullptr },
        { "get_connection_cost", reinterpret_cast<PyCFunction>(ConnectionProfile_GetConnectionCost), METH_VARARGS, nullptr },
        { "get_connectivity_intervals_async", reinterpret_cast<PyCFunction>(ConnectionProfile_GetConnectivityIntervalsAsync), METH_VARARGS, nullptr },
        { "get_data_plan_status", reinterpret_cast<PyCFunction>(ConnectionProfile_GetDataPlanStatus), METH_VARARGS, nullptr },
        { "get_domain_connectivity_level", reinterpret_cast<PyCFunction>(ConnectionProfile_GetDomainConnectivityLevel), METH_VARARGS, nullptr },
        { "get_local_usage", reinterpret_cast<PyCFunction>(ConnectionProfile_GetLocalUsage), METH_VARARGS, nullptr },
        { "get_network_connectivity_level", reinterpret_cast<PyCFunction>(ConnectionProfile_GetNetworkConnectivityLevel), METH_VARARGS, nullptr },
        { "get_network_names", reinterpret_cast<PyCFunction>(ConnectionProfile_GetNetworkNames), METH_VARARGS, nullptr },
        { "get_network_usage_async", reinterpret_cast<PyCFunction>(ConnectionProfile_GetNetworkUsageAsync), METH_VARARGS, nullptr },
        { "get_provider_network_usage_async", reinterpret_cast<PyCFunction>(ConnectionProfile_GetProviderNetworkUsageAsync), METH_VARARGS, nullptr },
        { "get_signal_bars", reinterpret_cast<PyCFunction>(ConnectionProfile_GetSignalBars), METH_VARARGS, nullptr },
        { "is_domain_authenticated_by", reinterpret_cast<PyCFunction>(ConnectionProfile_IsDomainAuthenticatedBy), METH_VARARGS, nullptr },
        { "try_delete_async", reinterpret_cast<PyCFunction>(ConnectionProfile_TryDeleteAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_ConnectionProfile, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ConnectionProfile), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ConnectionProfile[] = {
        { "network_adapter", reinterpret_cast<getter>(ConnectionProfile_get_NetworkAdapter), nullptr, nullptr, nullptr },
        { "network_security_settings", reinterpret_cast<getter>(ConnectionProfile_get_NetworkSecuritySettings), nullptr, nullptr, nullptr },
        { "profile_name", reinterpret_cast<getter>(ConnectionProfile_get_ProfileName), nullptr, nullptr, nullptr },
        { "is_wlan_connection_profile", reinterpret_cast<getter>(ConnectionProfile_get_IsWlanConnectionProfile), nullptr, nullptr, nullptr },
        { "is_wwan_connection_profile", reinterpret_cast<getter>(ConnectionProfile_get_IsWwanConnectionProfile), nullptr, nullptr, nullptr },
        { "service_provider_guid", reinterpret_cast<getter>(ConnectionProfile_get_ServiceProviderGuid), nullptr, nullptr, nullptr },
        { "wlan_connection_profile_details", reinterpret_cast<getter>(ConnectionProfile_get_WlanConnectionProfileDetails), nullptr, nullptr, nullptr },
        { "wwan_connection_profile_details", reinterpret_cast<getter>(ConnectionProfile_get_WwanConnectionProfileDetails), nullptr, nullptr, nullptr },
        { "can_delete", reinterpret_cast<getter>(ConnectionProfile_get_CanDelete), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ConnectionProfile[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ConnectionProfile) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ConnectionProfile) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ConnectionProfile) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ConnectionProfile) },
        { },
    };

    static PyType_Spec type_spec_ConnectionProfile =
    {
        "winrt._winrt_windows_networking_connectivity.ConnectionProfile",
        sizeof(py::wrapper::Windows::Networking::Connectivity::ConnectionProfile),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ConnectionProfile
    };

    // ----- ConnectionProfileFilter class --------------------

    static PyObject* _new_ConnectionProfileFilter(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Networking::Connectivity::ConnectionProfileFilter instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ConnectionProfileFilter(py::wrapper::Windows::Networking::Connectivity::ConnectionProfileFilter* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ConnectionProfileFilter_get_ServiceProviderGuid(py::wrapper::Windows::Networking::Connectivity::ConnectionProfileFilter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Connectivity.ConnectionProfileFilter", L"ServiceProviderGuid"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ServiceProviderGuid());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ConnectionProfileFilter_put_ServiceProviderGuid(py::wrapper::Windows::Networking::Connectivity::ConnectionProfileFilter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Connectivity.ConnectionProfileFilter", L"ServiceProviderGuid"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::guid>>(arg);

            self->obj.ServiceProviderGuid(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ConnectionProfileFilter_get_NetworkCostType(py::wrapper::Windows::Networking::Connectivity::ConnectionProfileFilter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Connectivity.ConnectionProfileFilter", L"NetworkCostType"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.NetworkCostType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ConnectionProfileFilter_put_NetworkCostType(py::wrapper::Windows::Networking::Connectivity::ConnectionProfileFilter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Connectivity.ConnectionProfileFilter", L"NetworkCostType"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Networking::Connectivity::NetworkCostType>(arg);

            self->obj.NetworkCostType(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ConnectionProfileFilter_get_IsWwanConnectionProfile(py::wrapper::Windows::Networking::Connectivity::ConnectionProfileFilter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Connectivity.ConnectionProfileFilter", L"IsWwanConnectionProfile"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsWwanConnectionProfile());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ConnectionProfileFilter_put_IsWwanConnectionProfile(py::wrapper::Windows::Networking::Connectivity::ConnectionProfileFilter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Connectivity.ConnectionProfileFilter", L"IsWwanConnectionProfile"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsWwanConnectionProfile(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ConnectionProfileFilter_get_IsWlanConnectionProfile(py::wrapper::Windows::Networking::Connectivity::ConnectionProfileFilter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Connectivity.ConnectionProfileFilter", L"IsWlanConnectionProfile"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsWlanConnectionProfile());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ConnectionProfileFilter_put_IsWlanConnectionProfile(py::wrapper::Windows::Networking::Connectivity::ConnectionProfileFilter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Connectivity.ConnectionProfileFilter", L"IsWlanConnectionProfile"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsWlanConnectionProfile(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ConnectionProfileFilter_get_IsConnected(py::wrapper::Windows::Networking::Connectivity::ConnectionProfileFilter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Connectivity.ConnectionProfileFilter", L"IsConnected"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsConnected());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ConnectionProfileFilter_put_IsConnected(py::wrapper::Windows::Networking::Connectivity::ConnectionProfileFilter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Connectivity.ConnectionProfileFilter", L"IsConnected"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsConnected(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ConnectionProfileFilter_get_IsRoaming(py::wrapper::Windows::Networking::Connectivity::ConnectionProfileFilter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Connectivity.ConnectionProfileFilter", L"IsRoaming"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsRoaming());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ConnectionProfileFilter_put_IsRoaming(py::wrapper::Windows::Networking::Connectivity::ConnectionProfileFilter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Connectivity.ConnectionProfileFilter", L"IsRoaming"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<bool>>(arg);

            self->obj.IsRoaming(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ConnectionProfileFilter_get_IsOverDataLimit(py::wrapper::Windows::Networking::Connectivity::ConnectionProfileFilter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Connectivity.ConnectionProfileFilter", L"IsOverDataLimit"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsOverDataLimit());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ConnectionProfileFilter_put_IsOverDataLimit(py::wrapper::Windows::Networking::Connectivity::ConnectionProfileFilter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Connectivity.ConnectionProfileFilter", L"IsOverDataLimit"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<bool>>(arg);

            self->obj.IsOverDataLimit(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ConnectionProfileFilter_get_IsBackgroundDataUsageRestricted(py::wrapper::Windows::Networking::Connectivity::ConnectionProfileFilter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Connectivity.ConnectionProfileFilter", L"IsBackgroundDataUsageRestricted"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsBackgroundDataUsageRestricted());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ConnectionProfileFilter_put_IsBackgroundDataUsageRestricted(py::wrapper::Windows::Networking::Connectivity::ConnectionProfileFilter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Connectivity.ConnectionProfileFilter", L"IsBackgroundDataUsageRestricted"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<bool>>(arg);

            self->obj.IsBackgroundDataUsageRestricted(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ConnectionProfileFilter_get_RawData(py::wrapper::Windows::Networking::Connectivity::ConnectionProfileFilter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Connectivity.ConnectionProfileFilter", L"RawData"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RawData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ConnectionProfileFilter_get_PurposeGuid(py::wrapper::Windows::Networking::Connectivity::ConnectionProfileFilter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Connectivity.ConnectionProfileFilter", L"PurposeGuid"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PurposeGuid());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ConnectionProfileFilter_put_PurposeGuid(py::wrapper::Windows::Networking::Connectivity::ConnectionProfileFilter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Connectivity.ConnectionProfileFilter", L"PurposeGuid"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::guid>>(arg);

            self->obj.PurposeGuid(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_ConnectionProfileFilter(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::Connectivity::ConnectionProfileFilter>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ConnectionProfileFilter(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Connectivity::ConnectionProfileFilter>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ConnectionProfileFilter[] = {
        { "_assign_array_", _assign_array_ConnectionProfileFilter, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ConnectionProfileFilter), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ConnectionProfileFilter[] = {
        { "service_provider_guid", reinterpret_cast<getter>(ConnectionProfileFilter_get_ServiceProviderGuid), reinterpret_cast<setter>(ConnectionProfileFilter_put_ServiceProviderGuid), nullptr, nullptr },
        { "network_cost_type", reinterpret_cast<getter>(ConnectionProfileFilter_get_NetworkCostType), reinterpret_cast<setter>(ConnectionProfileFilter_put_NetworkCostType), nullptr, nullptr },
        { "is_wwan_connection_profile", reinterpret_cast<getter>(ConnectionProfileFilter_get_IsWwanConnectionProfile), reinterpret_cast<setter>(ConnectionProfileFilter_put_IsWwanConnectionProfile), nullptr, nullptr },
        { "is_wlan_connection_profile", reinterpret_cast<getter>(ConnectionProfileFilter_get_IsWlanConnectionProfile), reinterpret_cast<setter>(ConnectionProfileFilter_put_IsWlanConnectionProfile), nullptr, nullptr },
        { "is_connected", reinterpret_cast<getter>(ConnectionProfileFilter_get_IsConnected), reinterpret_cast<setter>(ConnectionProfileFilter_put_IsConnected), nullptr, nullptr },
        { "is_roaming", reinterpret_cast<getter>(ConnectionProfileFilter_get_IsRoaming), reinterpret_cast<setter>(ConnectionProfileFilter_put_IsRoaming), nullptr, nullptr },
        { "is_over_data_limit", reinterpret_cast<getter>(ConnectionProfileFilter_get_IsOverDataLimit), reinterpret_cast<setter>(ConnectionProfileFilter_put_IsOverDataLimit), nullptr, nullptr },
        { "is_background_data_usage_restricted", reinterpret_cast<getter>(ConnectionProfileFilter_get_IsBackgroundDataUsageRestricted), reinterpret_cast<setter>(ConnectionProfileFilter_put_IsBackgroundDataUsageRestricted), nullptr, nullptr },
        { "raw_data", reinterpret_cast<getter>(ConnectionProfileFilter_get_RawData), nullptr, nullptr, nullptr },
        { "purpose_guid", reinterpret_cast<getter>(ConnectionProfileFilter_get_PurposeGuid), reinterpret_cast<setter>(ConnectionProfileFilter_put_PurposeGuid), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ConnectionProfileFilter[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ConnectionProfileFilter) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ConnectionProfileFilter) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ConnectionProfileFilter) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ConnectionProfileFilter) },
        { },
    };

    static PyType_Spec type_spec_ConnectionProfileFilter =
    {
        "winrt._winrt_windows_networking_connectivity.ConnectionProfileFilter",
        sizeof(py::wrapper::Windows::Networking::Connectivity::ConnectionProfileFilter),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ConnectionProfileFilter
    };

    // ----- ConnectionSession class --------------------

    static PyObject* _new_ConnectionSession(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Networking::Connectivity::ConnectionSession>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Networking::Connectivity::ConnectionSession>::type_name);
        return nullptr;
    }

    static void _dealloc_ConnectionSession(py::wrapper::Windows::Networking::Connectivity::ConnectionSession* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ConnectionSession_Close(py::wrapper::Windows::Networking::Connectivity::ConnectionSession* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Connectivity.ConnectionSession", L"Close", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ConnectionSession_get_ConnectionProfile(py::wrapper::Windows::Networking::Connectivity::ConnectionSession* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Connectivity.ConnectionSession", L"ConnectionProfile"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ConnectionProfile());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ConnectionSession(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::Connectivity::ConnectionSession>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ConnectionSession(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Connectivity::ConnectionSession>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_ConnectionSession(py::wrapper::Windows::Networking::Connectivity::ConnectionSession* self, PyObject* /*unused*/) noexcept
    {
        return Py_NewRef(self);
    }

    static PyObject* _exit_ConnectionSession(py::wrapper::Windows::Networking::Connectivity::ConnectionSession* self, PyObject* /*unused*/) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ConnectionSession[] = {
        { "close", reinterpret_cast<PyCFunction>(ConnectionSession_Close), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_ConnectionSession, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ConnectionSession), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_ConnectionSession), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_ConnectionSession), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_ConnectionSession[] = {
        { "connection_profile", reinterpret_cast<getter>(ConnectionSession_get_ConnectionProfile), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ConnectionSession[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ConnectionSession) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ConnectionSession) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ConnectionSession) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ConnectionSession) },
        { },
    };

    static PyType_Spec type_spec_ConnectionSession =
    {
        "winrt._winrt_windows_networking_connectivity.ConnectionSession",
        sizeof(py::wrapper::Windows::Networking::Connectivity::ConnectionSession),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ConnectionSession
    };

    // ----- ConnectivityInterval class --------------------

    static PyObject* _new_ConnectivityInterval(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Networking::Connectivity::ConnectivityInterval>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Networking::Connectivity::ConnectivityInterval>::type_name);
        return nullptr;
    }

    static void _dealloc_ConnectivityInterval(py::wrapper::Windows::Networking::Connectivity::ConnectivityInterval* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ConnectivityInterval_get_ConnectionDuration(py::wrapper::Windows::Networking::Connectivity::ConnectivityInterval* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Connectivity.ConnectivityInterval", L"ConnectionDuration"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ConnectionDuration());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ConnectivityInterval_get_StartTime(py::wrapper::Windows::Networking::Connectivity::ConnectivityInterval* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Connectivity.ConnectivityInterval", L"StartTime"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.StartTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ConnectivityInterval(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::Connectivity::ConnectivityInterval>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ConnectivityInterval(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Connectivity::ConnectivityInterval>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ConnectivityInterval[] = {
        { "_assign_array_", _assign_array_ConnectivityInterval, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ConnectivityInterval), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ConnectivityInterval[] = {
        { "connection_duration", reinterpret_cast<getter>(ConnectivityInterval_get_ConnectionDuration), nullptr, nullptr, nullptr },
        { "start_time", reinterpret_cast<getter>(ConnectivityInterval_get_StartTime), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ConnectivityInterval[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ConnectivityInterval) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ConnectivityInterval) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ConnectivityInterval) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ConnectivityInterval) },
        { },
    };

    static PyType_Spec type_spec_ConnectivityInterval =
    {
        "winrt._winrt_windows_networking_connectivity.ConnectivityInterval",
        sizeof(py::wrapper::Windows::Networking::Connectivity::ConnectivityInterval),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ConnectivityInterval
    };

    // ----- ConnectivityManager class --------------------

    static PyObject* _new_ConnectivityManager(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Networking::Connectivity::ConnectivityManager>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Networking::Connectivity::ConnectivityManager>::type_name);
        return nullptr;
    }

    static PyObject* ConnectivityManager_AcquireConnectionAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Connectivity.ConnectivityManager", L"AcquireConnectionAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Networking::Connectivity::CellularApnContext>(args, 0);

                return py::convert(winrt::Windows::Networking::Connectivity::ConnectivityManager::AcquireConnectionAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ConnectivityManager_AddHttpRoutePolicy(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Connectivity.ConnectivityManager", L"AddHttpRoutePolicy", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Networking::Connectivity::RoutePolicy>(args, 0);

                winrt::Windows::Networking::Connectivity::ConnectivityManager::AddHttpRoutePolicy(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ConnectivityManager_RemoveHttpRoutePolicy(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Connectivity.ConnectivityManager", L"RemoveHttpRoutePolicy", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Networking::Connectivity::RoutePolicy>(args, 0);

                winrt::Windows::Networking::Connectivity::ConnectivityManager::RemoveHttpRoutePolicy(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyMethodDef _methods_ConnectivityManager[] = {
        { }
    };

    static PyGetSetDef _getset_ConnectivityManager[] = {
        { }
    };

    static PyType_Slot _type_slots_ConnectivityManager[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ConnectivityManager) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ConnectivityManager) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ConnectivityManager) },
        { },
    };

    static PyType_Spec type_spec_ConnectivityManager =
    {
        "winrt._winrt_windows_networking_connectivity.ConnectivityManager",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ConnectivityManager
    };

    static PyGetSetDef getset_ConnectivityManager_Static[] = {
        { }
    };

    static PyMethodDef methods_ConnectivityManager_Static[] = {
        { "acquire_connection_async", reinterpret_cast<PyCFunction>(ConnectivityManager_AcquireConnectionAsync), METH_VARARGS, nullptr },
        { "add_http_route_policy", reinterpret_cast<PyCFunction>(ConnectivityManager_AddHttpRoutePolicy), METH_VARARGS, nullptr },
        { "remove_http_route_policy", reinterpret_cast<PyCFunction>(ConnectivityManager_RemoveHttpRoutePolicy), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_ConnectivityManager_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_ConnectivityManager_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_ConnectivityManager_Static) },
        { }
    };

    static PyType_Spec type_spec_ConnectivityManager_Static =
    {
        "winrt._winrt_windows_networking_connectivity.ConnectivityManager_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_ConnectivityManager_Static
    };

    // ----- DataPlanStatus class --------------------

    static PyObject* _new_DataPlanStatus(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Networking::Connectivity::DataPlanStatus>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Networking::Connectivity::DataPlanStatus>::type_name);
        return nullptr;
    }

    static void _dealloc_DataPlanStatus(py::wrapper::Windows::Networking::Connectivity::DataPlanStatus* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* DataPlanStatus_get_DataLimitInMegabytes(py::wrapper::Windows::Networking::Connectivity::DataPlanStatus* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Connectivity.DataPlanStatus", L"DataLimitInMegabytes"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DataLimitInMegabytes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DataPlanStatus_get_DataPlanUsage(py::wrapper::Windows::Networking::Connectivity::DataPlanStatus* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Connectivity.DataPlanStatus", L"DataPlanUsage"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DataPlanUsage());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DataPlanStatus_get_InboundBitsPerSecond(py::wrapper::Windows::Networking::Connectivity::DataPlanStatus* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Connectivity.DataPlanStatus", L"InboundBitsPerSecond"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.InboundBitsPerSecond());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DataPlanStatus_get_MaxTransferSizeInMegabytes(py::wrapper::Windows::Networking::Connectivity::DataPlanStatus* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Connectivity.DataPlanStatus", L"MaxTransferSizeInMegabytes"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MaxTransferSizeInMegabytes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DataPlanStatus_get_NextBillingCycle(py::wrapper::Windows::Networking::Connectivity::DataPlanStatus* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Connectivity.DataPlanStatus", L"NextBillingCycle"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.NextBillingCycle());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DataPlanStatus_get_OutboundBitsPerSecond(py::wrapper::Windows::Networking::Connectivity::DataPlanStatus* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Connectivity.DataPlanStatus", L"OutboundBitsPerSecond"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.OutboundBitsPerSecond());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_DataPlanStatus(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::Connectivity::DataPlanStatus>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_DataPlanStatus(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Connectivity::DataPlanStatus>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DataPlanStatus[] = {
        { "_assign_array_", _assign_array_DataPlanStatus, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DataPlanStatus), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DataPlanStatus[] = {
        { "data_limit_in_megabytes", reinterpret_cast<getter>(DataPlanStatus_get_DataLimitInMegabytes), nullptr, nullptr, nullptr },
        { "data_plan_usage", reinterpret_cast<getter>(DataPlanStatus_get_DataPlanUsage), nullptr, nullptr, nullptr },
        { "inbound_bits_per_second", reinterpret_cast<getter>(DataPlanStatus_get_InboundBitsPerSecond), nullptr, nullptr, nullptr },
        { "max_transfer_size_in_megabytes", reinterpret_cast<getter>(DataPlanStatus_get_MaxTransferSizeInMegabytes), nullptr, nullptr, nullptr },
        { "next_billing_cycle", reinterpret_cast<getter>(DataPlanStatus_get_NextBillingCycle), nullptr, nullptr, nullptr },
        { "outbound_bits_per_second", reinterpret_cast<getter>(DataPlanStatus_get_OutboundBitsPerSecond), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_DataPlanStatus[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_DataPlanStatus) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_DataPlanStatus) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_DataPlanStatus) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_DataPlanStatus) },
        { },
    };

    static PyType_Spec type_spec_DataPlanStatus =
    {
        "winrt._winrt_windows_networking_connectivity.DataPlanStatus",
        sizeof(py::wrapper::Windows::Networking::Connectivity::DataPlanStatus),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DataPlanStatus
    };

    // ----- DataPlanUsage class --------------------

    static PyObject* _new_DataPlanUsage(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Networking::Connectivity::DataPlanUsage>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Networking::Connectivity::DataPlanUsage>::type_name);
        return nullptr;
    }

    static void _dealloc_DataPlanUsage(py::wrapper::Windows::Networking::Connectivity::DataPlanUsage* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* DataPlanUsage_get_LastSyncTime(py::wrapper::Windows::Networking::Connectivity::DataPlanUsage* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Connectivity.DataPlanUsage", L"LastSyncTime"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.LastSyncTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DataPlanUsage_get_MegabytesUsed(py::wrapper::Windows::Networking::Connectivity::DataPlanUsage* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Connectivity.DataPlanUsage", L"MegabytesUsed"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MegabytesUsed());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_DataPlanUsage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::Connectivity::DataPlanUsage>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_DataPlanUsage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Connectivity::DataPlanUsage>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DataPlanUsage[] = {
        { "_assign_array_", _assign_array_DataPlanUsage, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DataPlanUsage), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DataPlanUsage[] = {
        { "last_sync_time", reinterpret_cast<getter>(DataPlanUsage_get_LastSyncTime), nullptr, nullptr, nullptr },
        { "megabytes_used", reinterpret_cast<getter>(DataPlanUsage_get_MegabytesUsed), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_DataPlanUsage[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_DataPlanUsage) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_DataPlanUsage) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_DataPlanUsage) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_DataPlanUsage) },
        { },
    };

    static PyType_Spec type_spec_DataPlanUsage =
    {
        "winrt._winrt_windows_networking_connectivity.DataPlanUsage",
        sizeof(py::wrapper::Windows::Networking::Connectivity::DataPlanUsage),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DataPlanUsage
    };

    // ----- DataUsage class --------------------

    static PyObject* _new_DataUsage(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Networking::Connectivity::DataUsage>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Networking::Connectivity::DataUsage>::type_name);
        return nullptr;
    }

    static void _dealloc_DataUsage(py::wrapper::Windows::Networking::Connectivity::DataUsage* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* DataUsage_get_BytesReceived(py::wrapper::Windows::Networking::Connectivity::DataUsage* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Connectivity.DataUsage", L"BytesReceived"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.BytesReceived());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DataUsage_get_BytesSent(py::wrapper::Windows::Networking::Connectivity::DataUsage* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Connectivity.DataUsage", L"BytesSent"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.BytesSent());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_DataUsage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::Connectivity::DataUsage>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_DataUsage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Connectivity::DataUsage>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DataUsage[] = {
        { "_assign_array_", _assign_array_DataUsage, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DataUsage), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DataUsage[] = {
        { "bytes_received", reinterpret_cast<getter>(DataUsage_get_BytesReceived), nullptr, nullptr, nullptr },
        { "bytes_sent", reinterpret_cast<getter>(DataUsage_get_BytesSent), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_DataUsage[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_DataUsage) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_DataUsage) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_DataUsage) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_DataUsage) },
        { },
    };

    static PyType_Spec type_spec_DataUsage =
    {
        "winrt._winrt_windows_networking_connectivity.DataUsage",
        sizeof(py::wrapper::Windows::Networking::Connectivity::DataUsage),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DataUsage
    };

    // ----- IPInformation class --------------------

    static PyObject* _new_IPInformation(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Networking::Connectivity::IPInformation>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Networking::Connectivity::IPInformation>::type_name);
        return nullptr;
    }

    static void _dealloc_IPInformation(py::wrapper::Windows::Networking::Connectivity::IPInformation* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IPInformation_get_NetworkAdapter(py::wrapper::Windows::Networking::Connectivity::IPInformation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Connectivity.IPInformation", L"NetworkAdapter"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.NetworkAdapter());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IPInformation_get_PrefixLength(py::wrapper::Windows::Networking::Connectivity::IPInformation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Connectivity.IPInformation", L"PrefixLength"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PrefixLength());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_IPInformation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::Connectivity::IPInformation>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IPInformation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Connectivity::IPInformation>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IPInformation[] = {
        { "_assign_array_", _assign_array_IPInformation, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IPInformation), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IPInformation[] = {
        { "network_adapter", reinterpret_cast<getter>(IPInformation_get_NetworkAdapter), nullptr, nullptr, nullptr },
        { "prefix_length", reinterpret_cast<getter>(IPInformation_get_PrefixLength), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IPInformation[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_IPInformation) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IPInformation) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IPInformation) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IPInformation) },
        { },
    };

    static PyType_Spec type_spec_IPInformation =
    {
        "winrt._winrt_windows_networking_connectivity.IPInformation",
        sizeof(py::wrapper::Windows::Networking::Connectivity::IPInformation),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IPInformation
    };

    // ----- LanIdentifier class --------------------

    static PyObject* _new_LanIdentifier(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Networking::Connectivity::LanIdentifier>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Networking::Connectivity::LanIdentifier>::type_name);
        return nullptr;
    }

    static void _dealloc_LanIdentifier(py::wrapper::Windows::Networking::Connectivity::LanIdentifier* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* LanIdentifier_get_InfrastructureId(py::wrapper::Windows::Networking::Connectivity::LanIdentifier* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Connectivity.LanIdentifier", L"InfrastructureId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.InfrastructureId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LanIdentifier_get_NetworkAdapterId(py::wrapper::Windows::Networking::Connectivity::LanIdentifier* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Connectivity.LanIdentifier", L"NetworkAdapterId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.NetworkAdapterId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LanIdentifier_get_PortId(py::wrapper::Windows::Networking::Connectivity::LanIdentifier* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Connectivity.LanIdentifier", L"PortId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PortId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_LanIdentifier(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::Connectivity::LanIdentifier>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_LanIdentifier(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Connectivity::LanIdentifier>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_LanIdentifier[] = {
        { "_assign_array_", _assign_array_LanIdentifier, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_LanIdentifier), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_LanIdentifier[] = {
        { "infrastructure_id", reinterpret_cast<getter>(LanIdentifier_get_InfrastructureId), nullptr, nullptr, nullptr },
        { "network_adapter_id", reinterpret_cast<getter>(LanIdentifier_get_NetworkAdapterId), nullptr, nullptr, nullptr },
        { "port_id", reinterpret_cast<getter>(LanIdentifier_get_PortId), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_LanIdentifier[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_LanIdentifier) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_LanIdentifier) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_LanIdentifier) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_LanIdentifier) },
        { },
    };

    static PyType_Spec type_spec_LanIdentifier =
    {
        "winrt._winrt_windows_networking_connectivity.LanIdentifier",
        sizeof(py::wrapper::Windows::Networking::Connectivity::LanIdentifier),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_LanIdentifier
    };

    // ----- LanIdentifierData class --------------------

    static PyObject* _new_LanIdentifierData(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Networking::Connectivity::LanIdentifierData>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Networking::Connectivity::LanIdentifierData>::type_name);
        return nullptr;
    }

    static void _dealloc_LanIdentifierData(py::wrapper::Windows::Networking::Connectivity::LanIdentifierData* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* LanIdentifierData_get_Type(py::wrapper::Windows::Networking::Connectivity::LanIdentifierData* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Connectivity.LanIdentifierData", L"Type"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Type());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LanIdentifierData_get_Value(py::wrapper::Windows::Networking::Connectivity::LanIdentifierData* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Connectivity.LanIdentifierData", L"Value"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Value());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_LanIdentifierData(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::Connectivity::LanIdentifierData>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_LanIdentifierData(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Connectivity::LanIdentifierData>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_LanIdentifierData[] = {
        { "_assign_array_", _assign_array_LanIdentifierData, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_LanIdentifierData), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_LanIdentifierData[] = {
        { "type", reinterpret_cast<getter>(LanIdentifierData_get_Type), nullptr, nullptr, nullptr },
        { "value", reinterpret_cast<getter>(LanIdentifierData_get_Value), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_LanIdentifierData[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_LanIdentifierData) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_LanIdentifierData) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_LanIdentifierData) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_LanIdentifierData) },
        { },
    };

    static PyType_Spec type_spec_LanIdentifierData =
    {
        "winrt._winrt_windows_networking_connectivity.LanIdentifierData",
        sizeof(py::wrapper::Windows::Networking::Connectivity::LanIdentifierData),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_LanIdentifierData
    };

    // ----- NetworkAdapter class --------------------

    static PyObject* _new_NetworkAdapter(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Networking::Connectivity::NetworkAdapter>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Networking::Connectivity::NetworkAdapter>::type_name);
        return nullptr;
    }

    static void _dealloc_NetworkAdapter(py::wrapper::Windows::Networking::Connectivity::NetworkAdapter* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* NetworkAdapter_GetConnectedProfileAsync(py::wrapper::Windows::Networking::Connectivity::NetworkAdapter* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Connectivity.NetworkAdapter", L"GetConnectedProfileAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetConnectedProfileAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* NetworkAdapter_get_IanaInterfaceType(py::wrapper::Windows::Networking::Connectivity::NetworkAdapter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Connectivity.NetworkAdapter", L"IanaInterfaceType"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IanaInterfaceType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NetworkAdapter_get_InboundMaxBitsPerSecond(py::wrapper::Windows::Networking::Connectivity::NetworkAdapter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Connectivity.NetworkAdapter", L"InboundMaxBitsPerSecond"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.InboundMaxBitsPerSecond());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NetworkAdapter_get_NetworkAdapterId(py::wrapper::Windows::Networking::Connectivity::NetworkAdapter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Connectivity.NetworkAdapter", L"NetworkAdapterId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.NetworkAdapterId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NetworkAdapter_get_NetworkItem(py::wrapper::Windows::Networking::Connectivity::NetworkAdapter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Connectivity.NetworkAdapter", L"NetworkItem"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.NetworkItem());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NetworkAdapter_get_OutboundMaxBitsPerSecond(py::wrapper::Windows::Networking::Connectivity::NetworkAdapter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Connectivity.NetworkAdapter", L"OutboundMaxBitsPerSecond"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.OutboundMaxBitsPerSecond());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_NetworkAdapter(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::Connectivity::NetworkAdapter>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_NetworkAdapter(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Connectivity::NetworkAdapter>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_NetworkAdapter[] = {
        { "get_connected_profile_async", reinterpret_cast<PyCFunction>(NetworkAdapter_GetConnectedProfileAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_NetworkAdapter, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_NetworkAdapter), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_NetworkAdapter[] = {
        { "iana_interface_type", reinterpret_cast<getter>(NetworkAdapter_get_IanaInterfaceType), nullptr, nullptr, nullptr },
        { "inbound_max_bits_per_second", reinterpret_cast<getter>(NetworkAdapter_get_InboundMaxBitsPerSecond), nullptr, nullptr, nullptr },
        { "network_adapter_id", reinterpret_cast<getter>(NetworkAdapter_get_NetworkAdapterId), nullptr, nullptr, nullptr },
        { "network_item", reinterpret_cast<getter>(NetworkAdapter_get_NetworkItem), nullptr, nullptr, nullptr },
        { "outbound_max_bits_per_second", reinterpret_cast<getter>(NetworkAdapter_get_OutboundMaxBitsPerSecond), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_NetworkAdapter[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_NetworkAdapter) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_NetworkAdapter) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_NetworkAdapter) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_NetworkAdapter) },
        { },
    };

    static PyType_Spec type_spec_NetworkAdapter =
    {
        "winrt._winrt_windows_networking_connectivity.NetworkAdapter",
        sizeof(py::wrapper::Windows::Networking::Connectivity::NetworkAdapter),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_NetworkAdapter
    };

    // ----- NetworkInformation class --------------------

    static PyObject* _new_NetworkInformation(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Networking::Connectivity::NetworkInformation>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Networking::Connectivity::NetworkInformation>::type_name);
        return nullptr;
    }

    static PyObject* NetworkInformation_FindConnectionProfilesAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Connectivity.NetworkInformation", L"FindConnectionProfilesAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Networking::Connectivity::ConnectionProfileFilter>(args, 0);

                return py::convert(winrt::Windows::Networking::Connectivity::NetworkInformation::FindConnectionProfilesAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* NetworkInformation_GetConnectionProfiles(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Connectivity.NetworkInformation", L"GetConnectionProfiles", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::Networking::Connectivity::NetworkInformation::GetConnectionProfiles());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* NetworkInformation_GetHostNames(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Connectivity.NetworkInformation", L"GetHostNames", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::Networking::Connectivity::NetworkInformation::GetHostNames());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* NetworkInformation_GetInternetConnectionProfile(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Connectivity.NetworkInformation", L"GetInternetConnectionProfile", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::Networking::Connectivity::NetworkInformation::GetInternetConnectionProfile());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* NetworkInformation_GetLanIdentifiers(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Connectivity.NetworkInformation", L"GetLanIdentifiers", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::Networking::Connectivity::NetworkInformation::GetLanIdentifiers());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* NetworkInformation_GetProxyConfigurationAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Connectivity.NetworkInformation", L"GetProxyConfigurationAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);

                return py::convert(winrt::Windows::Networking::Connectivity::NetworkInformation::GetProxyConfigurationAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* NetworkInformation_GetSortedEndpointPairs(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Connectivity.NetworkInformation", L"GetSortedEndpointPairs", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Networking::EndpointPair>>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Networking::HostNameSortOptions>(args, 1);

                return py::convert(winrt::Windows::Networking::Connectivity::NetworkInformation::GetSortedEndpointPairs(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* NetworkInformation_add_NetworkStatusChanged(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Networking.Connectivity.NetworkInformation", L"NetworkStatusChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Networking::Connectivity::NetworkStatusChangedEventHandler>(arg);

            return py::convert(winrt::Windows::Networking::Connectivity::NetworkInformation::NetworkStatusChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NetworkInformation_remove_NetworkStatusChanged(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Networking.Connectivity.NetworkInformation", L"NetworkStatusChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            winrt::Windows::Networking::Connectivity::NetworkInformation::NetworkStatusChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_NetworkInformation[] = {
        { "add_network_status_changed", reinterpret_cast<PyCFunction>(NetworkInformation_add_NetworkStatusChanged), METH_O | METH_STATIC, nullptr },
        { "remove_network_status_changed", reinterpret_cast<PyCFunction>(NetworkInformation_remove_NetworkStatusChanged), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_NetworkInformation[] = {
        { }
    };

    static PyType_Slot _type_slots_NetworkInformation[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_NetworkInformation) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_NetworkInformation) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_NetworkInformation) },
        { },
    };

    static PyType_Spec type_spec_NetworkInformation =
    {
        "winrt._winrt_windows_networking_connectivity.NetworkInformation",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_NetworkInformation
    };

    static PyGetSetDef getset_NetworkInformation_Static[] = {
        { }
    };

    static PyMethodDef methods_NetworkInformation_Static[] = {
        { "find_connection_profiles_async", reinterpret_cast<PyCFunction>(NetworkInformation_FindConnectionProfilesAsync), METH_VARARGS, nullptr },
        { "get_connection_profiles", reinterpret_cast<PyCFunction>(NetworkInformation_GetConnectionProfiles), METH_VARARGS, nullptr },
        { "get_host_names", reinterpret_cast<PyCFunction>(NetworkInformation_GetHostNames), METH_VARARGS, nullptr },
        { "get_internet_connection_profile", reinterpret_cast<PyCFunction>(NetworkInformation_GetInternetConnectionProfile), METH_VARARGS, nullptr },
        { "get_lan_identifiers", reinterpret_cast<PyCFunction>(NetworkInformation_GetLanIdentifiers), METH_VARARGS, nullptr },
        { "get_proxy_configuration_async", reinterpret_cast<PyCFunction>(NetworkInformation_GetProxyConfigurationAsync), METH_VARARGS, nullptr },
        { "get_sorted_endpoint_pairs", reinterpret_cast<PyCFunction>(NetworkInformation_GetSortedEndpointPairs), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_NetworkInformation_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_NetworkInformation_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_NetworkInformation_Static) },
        { }
    };

    static PyType_Spec type_spec_NetworkInformation_Static =
    {
        "winrt._winrt_windows_networking_connectivity.NetworkInformation_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_NetworkInformation_Static
    };

    // ----- NetworkItem class --------------------

    static PyObject* _new_NetworkItem(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Networking::Connectivity::NetworkItem>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Networking::Connectivity::NetworkItem>::type_name);
        return nullptr;
    }

    static void _dealloc_NetworkItem(py::wrapper::Windows::Networking::Connectivity::NetworkItem* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* NetworkItem_GetNetworkTypes(py::wrapper::Windows::Networking::Connectivity::NetworkItem* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Connectivity.NetworkItem", L"GetNetworkTypes", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetNetworkTypes());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* NetworkItem_get_NetworkId(py::wrapper::Windows::Networking::Connectivity::NetworkItem* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Connectivity.NetworkItem", L"NetworkId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.NetworkId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_NetworkItem(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::Connectivity::NetworkItem>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_NetworkItem(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Connectivity::NetworkItem>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_NetworkItem[] = {
        { "get_network_types", reinterpret_cast<PyCFunction>(NetworkItem_GetNetworkTypes), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_NetworkItem, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_NetworkItem), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_NetworkItem[] = {
        { "network_id", reinterpret_cast<getter>(NetworkItem_get_NetworkId), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_NetworkItem[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_NetworkItem) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_NetworkItem) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_NetworkItem) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_NetworkItem) },
        { },
    };

    static PyType_Spec type_spec_NetworkItem =
    {
        "winrt._winrt_windows_networking_connectivity.NetworkItem",
        sizeof(py::wrapper::Windows::Networking::Connectivity::NetworkItem),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_NetworkItem
    };

    // ----- NetworkSecuritySettings class --------------------

    static PyObject* _new_NetworkSecuritySettings(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Networking::Connectivity::NetworkSecuritySettings>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Networking::Connectivity::NetworkSecuritySettings>::type_name);
        return nullptr;
    }

    static void _dealloc_NetworkSecuritySettings(py::wrapper::Windows::Networking::Connectivity::NetworkSecuritySettings* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* NetworkSecuritySettings_get_NetworkAuthenticationType(py::wrapper::Windows::Networking::Connectivity::NetworkSecuritySettings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Connectivity.NetworkSecuritySettings", L"NetworkAuthenticationType"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.NetworkAuthenticationType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NetworkSecuritySettings_get_NetworkEncryptionType(py::wrapper::Windows::Networking::Connectivity::NetworkSecuritySettings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Connectivity.NetworkSecuritySettings", L"NetworkEncryptionType"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.NetworkEncryptionType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_NetworkSecuritySettings(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::Connectivity::NetworkSecuritySettings>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_NetworkSecuritySettings(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Connectivity::NetworkSecuritySettings>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_NetworkSecuritySettings[] = {
        { "_assign_array_", _assign_array_NetworkSecuritySettings, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_NetworkSecuritySettings), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_NetworkSecuritySettings[] = {
        { "network_authentication_type", reinterpret_cast<getter>(NetworkSecuritySettings_get_NetworkAuthenticationType), nullptr, nullptr, nullptr },
        { "network_encryption_type", reinterpret_cast<getter>(NetworkSecuritySettings_get_NetworkEncryptionType), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_NetworkSecuritySettings[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_NetworkSecuritySettings) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_NetworkSecuritySettings) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_NetworkSecuritySettings) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_NetworkSecuritySettings) },
        { },
    };

    static PyType_Spec type_spec_NetworkSecuritySettings =
    {
        "winrt._winrt_windows_networking_connectivity.NetworkSecuritySettings",
        sizeof(py::wrapper::Windows::Networking::Connectivity::NetworkSecuritySettings),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_NetworkSecuritySettings
    };

    // ----- NetworkStateChangeEventDetails class --------------------

    static PyObject* _new_NetworkStateChangeEventDetails(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Networking::Connectivity::NetworkStateChangeEventDetails>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Networking::Connectivity::NetworkStateChangeEventDetails>::type_name);
        return nullptr;
    }

    static void _dealloc_NetworkStateChangeEventDetails(py::wrapper::Windows::Networking::Connectivity::NetworkStateChangeEventDetails* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* NetworkStateChangeEventDetails_get_HasNewConnectionCost(py::wrapper::Windows::Networking::Connectivity::NetworkStateChangeEventDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Connectivity.NetworkStateChangeEventDetails", L"HasNewConnectionCost"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.HasNewConnectionCost());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NetworkStateChangeEventDetails_get_HasNewDomainConnectivityLevel(py::wrapper::Windows::Networking::Connectivity::NetworkStateChangeEventDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Connectivity.NetworkStateChangeEventDetails", L"HasNewDomainConnectivityLevel"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.HasNewDomainConnectivityLevel());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NetworkStateChangeEventDetails_get_HasNewHostNameList(py::wrapper::Windows::Networking::Connectivity::NetworkStateChangeEventDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Connectivity.NetworkStateChangeEventDetails", L"HasNewHostNameList"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.HasNewHostNameList());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NetworkStateChangeEventDetails_get_HasNewInternetConnectionProfile(py::wrapper::Windows::Networking::Connectivity::NetworkStateChangeEventDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Connectivity.NetworkStateChangeEventDetails", L"HasNewInternetConnectionProfile"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.HasNewInternetConnectionProfile());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NetworkStateChangeEventDetails_get_HasNewNetworkConnectivityLevel(py::wrapper::Windows::Networking::Connectivity::NetworkStateChangeEventDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Connectivity.NetworkStateChangeEventDetails", L"HasNewNetworkConnectivityLevel"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.HasNewNetworkConnectivityLevel());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NetworkStateChangeEventDetails_get_HasNewWwanRegistrationState(py::wrapper::Windows::Networking::Connectivity::NetworkStateChangeEventDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Connectivity.NetworkStateChangeEventDetails", L"HasNewWwanRegistrationState"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.HasNewWwanRegistrationState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NetworkStateChangeEventDetails_get_HasNewTetheringClientCount(py::wrapper::Windows::Networking::Connectivity::NetworkStateChangeEventDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Connectivity.NetworkStateChangeEventDetails", L"HasNewTetheringClientCount"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.HasNewTetheringClientCount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NetworkStateChangeEventDetails_get_HasNewTetheringOperationalState(py::wrapper::Windows::Networking::Connectivity::NetworkStateChangeEventDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Connectivity.NetworkStateChangeEventDetails", L"HasNewTetheringOperationalState"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.HasNewTetheringOperationalState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_NetworkStateChangeEventDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::Connectivity::NetworkStateChangeEventDetails>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_NetworkStateChangeEventDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Connectivity::NetworkStateChangeEventDetails>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_NetworkStateChangeEventDetails[] = {
        { "_assign_array_", _assign_array_NetworkStateChangeEventDetails, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_NetworkStateChangeEventDetails), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_NetworkStateChangeEventDetails[] = {
        { "has_new_connection_cost", reinterpret_cast<getter>(NetworkStateChangeEventDetails_get_HasNewConnectionCost), nullptr, nullptr, nullptr },
        { "has_new_domain_connectivity_level", reinterpret_cast<getter>(NetworkStateChangeEventDetails_get_HasNewDomainConnectivityLevel), nullptr, nullptr, nullptr },
        { "has_new_host_name_list", reinterpret_cast<getter>(NetworkStateChangeEventDetails_get_HasNewHostNameList), nullptr, nullptr, nullptr },
        { "has_new_internet_connection_profile", reinterpret_cast<getter>(NetworkStateChangeEventDetails_get_HasNewInternetConnectionProfile), nullptr, nullptr, nullptr },
        { "has_new_network_connectivity_level", reinterpret_cast<getter>(NetworkStateChangeEventDetails_get_HasNewNetworkConnectivityLevel), nullptr, nullptr, nullptr },
        { "has_new_wwan_registration_state", reinterpret_cast<getter>(NetworkStateChangeEventDetails_get_HasNewWwanRegistrationState), nullptr, nullptr, nullptr },
        { "has_new_tethering_client_count", reinterpret_cast<getter>(NetworkStateChangeEventDetails_get_HasNewTetheringClientCount), nullptr, nullptr, nullptr },
        { "has_new_tethering_operational_state", reinterpret_cast<getter>(NetworkStateChangeEventDetails_get_HasNewTetheringOperationalState), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_NetworkStateChangeEventDetails[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_NetworkStateChangeEventDetails) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_NetworkStateChangeEventDetails) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_NetworkStateChangeEventDetails) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_NetworkStateChangeEventDetails) },
        { },
    };

    static PyType_Spec type_spec_NetworkStateChangeEventDetails =
    {
        "winrt._winrt_windows_networking_connectivity.NetworkStateChangeEventDetails",
        sizeof(py::wrapper::Windows::Networking::Connectivity::NetworkStateChangeEventDetails),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_NetworkStateChangeEventDetails
    };

    // ----- NetworkUsage class --------------------

    static PyObject* _new_NetworkUsage(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Networking::Connectivity::NetworkUsage>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Networking::Connectivity::NetworkUsage>::type_name);
        return nullptr;
    }

    static void _dealloc_NetworkUsage(py::wrapper::Windows::Networking::Connectivity::NetworkUsage* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* NetworkUsage_get_BytesReceived(py::wrapper::Windows::Networking::Connectivity::NetworkUsage* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Connectivity.NetworkUsage", L"BytesReceived"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.BytesReceived());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NetworkUsage_get_BytesSent(py::wrapper::Windows::Networking::Connectivity::NetworkUsage* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Connectivity.NetworkUsage", L"BytesSent"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.BytesSent());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NetworkUsage_get_ConnectionDuration(py::wrapper::Windows::Networking::Connectivity::NetworkUsage* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Connectivity.NetworkUsage", L"ConnectionDuration"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ConnectionDuration());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_NetworkUsage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::Connectivity::NetworkUsage>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_NetworkUsage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Connectivity::NetworkUsage>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_NetworkUsage[] = {
        { "_assign_array_", _assign_array_NetworkUsage, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_NetworkUsage), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_NetworkUsage[] = {
        { "bytes_received", reinterpret_cast<getter>(NetworkUsage_get_BytesReceived), nullptr, nullptr, nullptr },
        { "bytes_sent", reinterpret_cast<getter>(NetworkUsage_get_BytesSent), nullptr, nullptr, nullptr },
        { "connection_duration", reinterpret_cast<getter>(NetworkUsage_get_ConnectionDuration), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_NetworkUsage[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_NetworkUsage) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_NetworkUsage) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_NetworkUsage) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_NetworkUsage) },
        { },
    };

    static PyType_Spec type_spec_NetworkUsage =
    {
        "winrt._winrt_windows_networking_connectivity.NetworkUsage",
        sizeof(py::wrapper::Windows::Networking::Connectivity::NetworkUsage),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_NetworkUsage
    };

    // ----- ProviderNetworkUsage class --------------------

    static PyObject* _new_ProviderNetworkUsage(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Networking::Connectivity::ProviderNetworkUsage>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Networking::Connectivity::ProviderNetworkUsage>::type_name);
        return nullptr;
    }

    static void _dealloc_ProviderNetworkUsage(py::wrapper::Windows::Networking::Connectivity::ProviderNetworkUsage* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ProviderNetworkUsage_get_BytesReceived(py::wrapper::Windows::Networking::Connectivity::ProviderNetworkUsage* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Connectivity.ProviderNetworkUsage", L"BytesReceived"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.BytesReceived());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProviderNetworkUsage_get_BytesSent(py::wrapper::Windows::Networking::Connectivity::ProviderNetworkUsage* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Connectivity.ProviderNetworkUsage", L"BytesSent"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.BytesSent());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProviderNetworkUsage_get_ProviderId(py::wrapper::Windows::Networking::Connectivity::ProviderNetworkUsage* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Connectivity.ProviderNetworkUsage", L"ProviderId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ProviderId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ProviderNetworkUsage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::Connectivity::ProviderNetworkUsage>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ProviderNetworkUsage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Connectivity::ProviderNetworkUsage>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ProviderNetworkUsage[] = {
        { "_assign_array_", _assign_array_ProviderNetworkUsage, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ProviderNetworkUsage), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ProviderNetworkUsage[] = {
        { "bytes_received", reinterpret_cast<getter>(ProviderNetworkUsage_get_BytesReceived), nullptr, nullptr, nullptr },
        { "bytes_sent", reinterpret_cast<getter>(ProviderNetworkUsage_get_BytesSent), nullptr, nullptr, nullptr },
        { "provider_id", reinterpret_cast<getter>(ProviderNetworkUsage_get_ProviderId), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ProviderNetworkUsage[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ProviderNetworkUsage) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ProviderNetworkUsage) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ProviderNetworkUsage) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ProviderNetworkUsage) },
        { },
    };

    static PyType_Spec type_spec_ProviderNetworkUsage =
    {
        "winrt._winrt_windows_networking_connectivity.ProviderNetworkUsage",
        sizeof(py::wrapper::Windows::Networking::Connectivity::ProviderNetworkUsage),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ProviderNetworkUsage
    };

    // ----- ProxyConfiguration class --------------------

    static PyObject* _new_ProxyConfiguration(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Networking::Connectivity::ProxyConfiguration>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Networking::Connectivity::ProxyConfiguration>::type_name);
        return nullptr;
    }

    static void _dealloc_ProxyConfiguration(py::wrapper::Windows::Networking::Connectivity::ProxyConfiguration* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ProxyConfiguration_get_CanConnectDirectly(py::wrapper::Windows::Networking::Connectivity::ProxyConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Connectivity.ProxyConfiguration", L"CanConnectDirectly"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CanConnectDirectly());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProxyConfiguration_get_ProxyUris(py::wrapper::Windows::Networking::Connectivity::ProxyConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Connectivity.ProxyConfiguration", L"ProxyUris"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ProxyUris());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ProxyConfiguration(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::Connectivity::ProxyConfiguration>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ProxyConfiguration(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Connectivity::ProxyConfiguration>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ProxyConfiguration[] = {
        { "_assign_array_", _assign_array_ProxyConfiguration, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ProxyConfiguration), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ProxyConfiguration[] = {
        { "can_connect_directly", reinterpret_cast<getter>(ProxyConfiguration_get_CanConnectDirectly), nullptr, nullptr, nullptr },
        { "proxy_uris", reinterpret_cast<getter>(ProxyConfiguration_get_ProxyUris), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ProxyConfiguration[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ProxyConfiguration) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ProxyConfiguration) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ProxyConfiguration) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ProxyConfiguration) },
        { },
    };

    static PyType_Spec type_spec_ProxyConfiguration =
    {
        "winrt._winrt_windows_networking_connectivity.ProxyConfiguration",
        sizeof(py::wrapper::Windows::Networking::Connectivity::ProxyConfiguration),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ProxyConfiguration
    };

    // ----- RoutePolicy class --------------------

    static PyObject* _new_RoutePolicy(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Networking::Connectivity::ConnectionProfile>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Networking::HostName>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Networking::DomainNameType>(args, 2);

                winrt::Windows::Networking::Connectivity::RoutePolicy instance{ param0, param1, param2 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_RoutePolicy(py::wrapper::Windows::Networking::Connectivity::RoutePolicy* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* RoutePolicy_get_ConnectionProfile(py::wrapper::Windows::Networking::Connectivity::RoutePolicy* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Connectivity.RoutePolicy", L"ConnectionProfile"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ConnectionProfile());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RoutePolicy_get_HostName(py::wrapper::Windows::Networking::Connectivity::RoutePolicy* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Connectivity.RoutePolicy", L"HostName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.HostName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RoutePolicy_get_HostNameType(py::wrapper::Windows::Networking::Connectivity::RoutePolicy* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Connectivity.RoutePolicy", L"HostNameType"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.HostNameType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_RoutePolicy(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::Connectivity::RoutePolicy>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_RoutePolicy(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Connectivity::RoutePolicy>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RoutePolicy[] = {
        { "_assign_array_", _assign_array_RoutePolicy, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_RoutePolicy), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_RoutePolicy[] = {
        { "connection_profile", reinterpret_cast<getter>(RoutePolicy_get_ConnectionProfile), nullptr, nullptr, nullptr },
        { "host_name", reinterpret_cast<getter>(RoutePolicy_get_HostName), nullptr, nullptr, nullptr },
        { "host_name_type", reinterpret_cast<getter>(RoutePolicy_get_HostNameType), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_RoutePolicy[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_RoutePolicy) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_RoutePolicy) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_RoutePolicy) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_RoutePolicy) },
        { },
    };

    static PyType_Spec type_spec_RoutePolicy =
    {
        "winrt._winrt_windows_networking_connectivity.RoutePolicy",
        sizeof(py::wrapper::Windows::Networking::Connectivity::RoutePolicy),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RoutePolicy
    };

    // ----- WlanConnectionProfileDetails class --------------------

    static PyObject* _new_WlanConnectionProfileDetails(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Networking::Connectivity::WlanConnectionProfileDetails>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Networking::Connectivity::WlanConnectionProfileDetails>::type_name);
        return nullptr;
    }

    static void _dealloc_WlanConnectionProfileDetails(py::wrapper::Windows::Networking::Connectivity::WlanConnectionProfileDetails* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* WlanConnectionProfileDetails_GetConnectedSsid(py::wrapper::Windows::Networking::Connectivity::WlanConnectionProfileDetails* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Connectivity.WlanConnectionProfileDetails", L"GetConnectedSsid", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetConnectedSsid());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_WlanConnectionProfileDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::Connectivity::WlanConnectionProfileDetails>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_WlanConnectionProfileDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Connectivity::WlanConnectionProfileDetails>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WlanConnectionProfileDetails[] = {
        { "get_connected_ssid", reinterpret_cast<PyCFunction>(WlanConnectionProfileDetails_GetConnectedSsid), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_WlanConnectionProfileDetails, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_WlanConnectionProfileDetails), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_WlanConnectionProfileDetails[] = {
        { }
    };

    static PyType_Slot _type_slots_WlanConnectionProfileDetails[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_WlanConnectionProfileDetails) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_WlanConnectionProfileDetails) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_WlanConnectionProfileDetails) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_WlanConnectionProfileDetails) },
        { },
    };

    static PyType_Spec type_spec_WlanConnectionProfileDetails =
    {
        "winrt._winrt_windows_networking_connectivity.WlanConnectionProfileDetails",
        sizeof(py::wrapper::Windows::Networking::Connectivity::WlanConnectionProfileDetails),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WlanConnectionProfileDetails
    };

    // ----- WwanConnectionProfileDetails class --------------------

    static PyObject* _new_WwanConnectionProfileDetails(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Networking::Connectivity::WwanConnectionProfileDetails>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Networking::Connectivity::WwanConnectionProfileDetails>::type_name);
        return nullptr;
    }

    static void _dealloc_WwanConnectionProfileDetails(py::wrapper::Windows::Networking::Connectivity::WwanConnectionProfileDetails* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* WwanConnectionProfileDetails_GetCurrentDataClass(py::wrapper::Windows::Networking::Connectivity::WwanConnectionProfileDetails* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Connectivity.WwanConnectionProfileDetails", L"GetCurrentDataClass", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetCurrentDataClass());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* WwanConnectionProfileDetails_GetNetworkRegistrationState(py::wrapper::Windows::Networking::Connectivity::WwanConnectionProfileDetails* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.Connectivity.WwanConnectionProfileDetails", L"GetNetworkRegistrationState", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetNetworkRegistrationState());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* WwanConnectionProfileDetails_get_AccessPointName(py::wrapper::Windows::Networking::Connectivity::WwanConnectionProfileDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Connectivity.WwanConnectionProfileDetails", L"AccessPointName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AccessPointName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WwanConnectionProfileDetails_get_HomeProviderId(py::wrapper::Windows::Networking::Connectivity::WwanConnectionProfileDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Connectivity.WwanConnectionProfileDetails", L"HomeProviderId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.HomeProviderId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WwanConnectionProfileDetails_get_IPKind(py::wrapper::Windows::Networking::Connectivity::WwanConnectionProfileDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Connectivity.WwanConnectionProfileDetails", L"IPKind"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IPKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WwanConnectionProfileDetails_get_PurposeGuids(py::wrapper::Windows::Networking::Connectivity::WwanConnectionProfileDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.Connectivity.WwanConnectionProfileDetails", L"PurposeGuids"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PurposeGuids());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_WwanConnectionProfileDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::Connectivity::WwanConnectionProfileDetails>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_WwanConnectionProfileDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Connectivity::WwanConnectionProfileDetails>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WwanConnectionProfileDetails[] = {
        { "get_current_data_class", reinterpret_cast<PyCFunction>(WwanConnectionProfileDetails_GetCurrentDataClass), METH_VARARGS, nullptr },
        { "get_network_registration_state", reinterpret_cast<PyCFunction>(WwanConnectionProfileDetails_GetNetworkRegistrationState), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_WwanConnectionProfileDetails, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_WwanConnectionProfileDetails), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_WwanConnectionProfileDetails[] = {
        { "access_point_name", reinterpret_cast<getter>(WwanConnectionProfileDetails_get_AccessPointName), nullptr, nullptr, nullptr },
        { "home_provider_id", reinterpret_cast<getter>(WwanConnectionProfileDetails_get_HomeProviderId), nullptr, nullptr, nullptr },
        { "i_p_kind", reinterpret_cast<getter>(WwanConnectionProfileDetails_get_IPKind), nullptr, nullptr, nullptr },
        { "purpose_guids", reinterpret_cast<getter>(WwanConnectionProfileDetails_get_PurposeGuids), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_WwanConnectionProfileDetails[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_WwanConnectionProfileDetails) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_WwanConnectionProfileDetails) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_WwanConnectionProfileDetails) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_WwanConnectionProfileDetails) },
        { },
    };

    static PyType_Spec type_spec_WwanConnectionProfileDetails =
    {
        "winrt._winrt_windows_networking_connectivity.WwanConnectionProfileDetails",
        sizeof(py::wrapper::Windows::Networking::Connectivity::WwanConnectionProfileDetails),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WwanConnectionProfileDetails
    };

    // ----- NetworkUsageStates struct --------------------

    winrt_struct_wrapper<winrt::Windows::Networking::Connectivity::NetworkUsageStates>* _new_NetworkUsageStates(PyTypeObject* subclass, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        auto self = reinterpret_cast<winrt_struct_wrapper<winrt::Windows::Networking::Connectivity::NetworkUsageStates>*>(subclass->tp_alloc(subclass, 0));

        if (!self)
        {
            return nullptr;
        }

        std::construct_at(&self->obj);

        return self;
    }

    int _init_NetworkUsageStates(winrt_struct_wrapper<winrt::Windows::Networking::Connectivity::NetworkUsageStates>* self, PyObject* args, PyObject* kwds) noexcept
    {
        auto tuple_size = PyTuple_Size(args);

        if ((tuple_size == 0) && (kwds == nullptr))
        {
            self->obj = {};
            return 0;
        }

        int32_t _Roaming{};
        int32_t _Shared{};

        static const char* kwlist[] = {"roaming", "shared", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "ii", const_cast<char**>(kwlist), &_Roaming, &_Shared))
        {
            return -1;
        }

        try
        {
            self->obj = {static_cast<winrt::Windows::Networking::Connectivity::TriStates>(_Roaming), static_cast<winrt::Windows::Networking::Connectivity::TriStates>(_Shared)};
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static void _dealloc_NetworkUsageStates(py::wrapper::Windows::Networking::Connectivity::NetworkUsageStates* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_NetworkUsageStates(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::Connectivity::NetworkUsageStates>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyMethodDef _methods_NetworkUsageStates[] = {
        { "_assign_array_", _assign_array_NetworkUsageStates, METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyObject* NetworkUsageStates_get_Roaming(py::wrapper::Windows::Networking::Connectivity::NetworkUsageStates* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Roaming);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int NetworkUsageStates_set_Roaming(py::wrapper::Windows::Networking::Connectivity::NetworkUsageStates* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.Roaming = py::converter<winrt::Windows::Networking::Connectivity::TriStates>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* NetworkUsageStates_get_Shared(py::wrapper::Windows::Networking::Connectivity::NetworkUsageStates* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Shared);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int NetworkUsageStates_set_Shared(py::wrapper::Windows::Networking::Connectivity::NetworkUsageStates* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.Shared = py::converter<winrt::Windows::Networking::Connectivity::TriStates>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyGetSetDef _getset_NetworkUsageStates[] = {
        { "roaming", reinterpret_cast<getter>(NetworkUsageStates_get_Roaming), reinterpret_cast<setter>(NetworkUsageStates_set_Roaming), nullptr, nullptr },
        { "shared", reinterpret_cast<getter>(NetworkUsageStates_get_Shared), reinterpret_cast<setter>(NetworkUsageStates_set_Shared), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_NetworkUsageStates[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_NetworkUsageStates) },
        { Py_tp_init, reinterpret_cast<void*>(_init_NetworkUsageStates) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_NetworkUsageStates) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_NetworkUsageStates) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_NetworkUsageStates) },
        { },
    };

    static PyType_Spec type_spec_NetworkUsageStates =
    {
        "winrt._winrt_windows_networking_connectivity.NetworkUsageStates",
        sizeof(py::wrapper::Windows::Networking::Connectivity::NetworkUsageStates),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_NetworkUsageStates
    };

    // ----- Windows.Networking.Connectivity Initialization --------------------
    PyDoc_STRVAR(module_doc, "Windows::Networking::Connectivity");


    static PyModuleDef module_def
        = {PyModuleDef_HEAD_INIT,
           "_winrt_windows_networking_connectivity",
           module_doc,
           0,
           nullptr,
           nullptr,
           nullptr,
           nullptr,
           nullptr};

} // py::cpp::Windows::Networking::Connectivity

PyMODINIT_FUNC PyInit__winrt_windows_networking_connectivity(void) noexcept
{
    using namespace py::cpp::Windows::Networking::Connectivity;

    if (py::import_winrt_runtime() == -1)
    {
        return nullptr;
    }

    py::pyobj_handle module{PyModule_Create(&module_def)};

    if (!module)
    {
        return nullptr;
    }

    auto object_type = py::get_object_type();
    if (!object_type)
    {
        return nullptr;
    }

    py::pyobj_handle object_bases{PyTuple_Pack(1, object_type)};

    if (!object_bases)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_AttributedNetworkUsage, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_CellularApnContext, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ConnectionCost, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ConnectionProfile, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ConnectionProfileFilter, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ConnectionSession, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ConnectivityInterval, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_ConnectivityManager_Static{PyType_FromSpec(&type_spec_ConnectivityManager_Static)};
    if (!type_ConnectivityManager_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ConnectivityManager, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_ConnectivityManager_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_DataPlanStatus, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_DataPlanUsage, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_DataUsage, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_IPInformation, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_LanIdentifier, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_LanIdentifierData, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_NetworkAdapter, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_NetworkInformation_Static{PyType_FromSpec(&type_spec_NetworkInformation_Static)};
    if (!type_NetworkInformation_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_NetworkInformation, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_NetworkInformation_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_NetworkItem, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_NetworkSecuritySettings, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_NetworkStateChangeEventDetails, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_NetworkUsage, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ProviderNetworkUsage, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ProxyConfiguration, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_RoutePolicy, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_WlanConnectionProfileDetails, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_WwanConnectionProfileDetails, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_NetworkUsageStates, nullptr, nullptr) == -1)
    {
        return nullptr;
    }


    return module.detach();
}
