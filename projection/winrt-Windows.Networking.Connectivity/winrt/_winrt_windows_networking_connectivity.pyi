# WARNING: Please don't edit this file. It was generated by Python/WinRT v2.0.0-beta.2

import datetime
import sys
import types
import typing
import uuid as _uuid
from builtins import property as _property

import winrt._winrt
import winrt.system
import winrt.windows.foundation
import winrt.windows.foundation.collections
import winrt.windows.networking
import winrt.windows.storage.streams

from winrt.windows.networking.connectivity import CellularApnAuthenticationType, ConnectionProfileDeleteStatus, DataUsageGranularity, DomainAuthenticationKind, DomainConnectivityLevel, NetworkAuthenticationType, NetworkConnectivityLevel, NetworkCostType, NetworkEncryptionType, NetworkTypes, RoamingStates, TriStates, WwanDataClass, WwanNetworkIPKind, WwanNetworkRegistrationState
from winrt.windows.networking.connectivity import NetworkStatusChangedEventHandler

Self = typing.TypeVar('Self')

@typing.final
class NetworkUsageStates:
    roaming: TriStates
    shared: TriStates
    def __init__(self, roaming: TriStates, shared: TriStates) -> None: ...

@typing.final
class AttributedNetworkUsage(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> AttributedNetworkUsage: ...
    @_property
    def attribution_id(self) -> str: ...
    @_property
    def attribution_name(self) -> str: ...
    @_property
    def attribution_thumbnail(self) -> typing.Optional[winrt.windows.storage.streams.IRandomAccessStreamReference]: ...
    @_property
    def bytes_received(self) -> winrt.system.UInt64: ...
    @_property
    def bytes_sent(self) -> winrt.system.UInt64: ...

@typing.final
class CellularApnContext(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> CellularApnContext: ...
    def __new__(cls: typing.Type[CellularApnContext]) -> CellularApnContext:...
    @_property
    def user_name(self) -> str: ...
    @user_name.setter
    def user_name(self, value: str) -> None: ...
    @_property
    def provider_id(self) -> str: ...
    @provider_id.setter
    def provider_id(self, value: str) -> None: ...
    @_property
    def password(self) -> str: ...
    @password.setter
    def password(self, value: str) -> None: ...
    @_property
    def is_compression_enabled(self) -> bool: ...
    @is_compression_enabled.setter
    def is_compression_enabled(self, value: bool) -> None: ...
    @_property
    def authentication_type(self) -> CellularApnAuthenticationType: ...
    @authentication_type.setter
    def authentication_type(self, value: CellularApnAuthenticationType) -> None: ...
    @_property
    def access_point_name(self) -> str: ...
    @access_point_name.setter
    def access_point_name(self, value: str) -> None: ...
    @_property
    def profile_name(self) -> str: ...
    @profile_name.setter
    def profile_name(self, value: str) -> None: ...

@typing.final
class ConnectionCost(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ConnectionCost: ...
    @_property
    def approaching_data_limit(self) -> bool: ...
    @_property
    def network_cost_type(self) -> NetworkCostType: ...
    @_property
    def over_data_limit(self) -> bool: ...
    @_property
    def roaming(self) -> bool: ...
    @_property
    def background_data_usage_restricted(self) -> bool: ...

@typing.final
class ConnectionProfile(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ConnectionProfile: ...
    def get_attributed_network_usage_async(self, start_time: datetime.datetime, end_time: datetime.datetime, states: NetworkUsageStates, /) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.foundation.collections.IVectorView[AttributedNetworkUsage]]: ...
    def get_connection_cost(self) -> typing.Optional[ConnectionCost]: ...
    def get_connectivity_intervals_async(self, start_time: datetime.datetime, end_time: datetime.datetime, states: NetworkUsageStates, /) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.foundation.collections.IVectorView[ConnectivityInterval]]: ...
    def get_data_plan_status(self) -> typing.Optional[DataPlanStatus]: ...
    def get_domain_connectivity_level(self) -> DomainConnectivityLevel: ...
    @typing.overload
    def get_local_usage(self, start_time: datetime.datetime, end_time: datetime.datetime, /) -> typing.Optional[DataUsage]: ...
    @typing.overload
    def get_local_usage(self, start_time: datetime.datetime, end_time: datetime.datetime, states: RoamingStates, /) -> typing.Optional[DataUsage]: ...
    def get_network_connectivity_level(self) -> NetworkConnectivityLevel: ...
    def get_network_names(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[str]]: ...
    def get_network_usage_async(self, start_time: datetime.datetime, end_time: datetime.datetime, granularity: DataUsageGranularity, states: NetworkUsageStates, /) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.foundation.collections.IVectorView[NetworkUsage]]: ...
    def get_provider_network_usage_async(self, start_time: datetime.datetime, end_time: datetime.datetime, states: NetworkUsageStates, /) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.foundation.collections.IVectorView[ProviderNetworkUsage]]: ...
    def get_signal_bars(self) -> typing.Optional[typing.Optional[winrt.system.UInt8]]: ...
    def is_domain_authenticated_by(self, kind: DomainAuthenticationKind, /) -> bool: ...
    def try_delete_async(self) -> winrt.windows.foundation.IAsyncOperation[ConnectionProfileDeleteStatus]: ...
    @_property
    def network_adapter(self) -> typing.Optional[NetworkAdapter]: ...
    @_property
    def network_security_settings(self) -> typing.Optional[NetworkSecuritySettings]: ...
    @_property
    def profile_name(self) -> str: ...
    @_property
    def is_wlan_connection_profile(self) -> bool: ...
    @_property
    def is_wwan_connection_profile(self) -> bool: ...
    @_property
    def service_provider_guid(self) -> typing.Optional[typing.Optional[_uuid.UUID]]: ...
    @_property
    def wlan_connection_profile_details(self) -> typing.Optional[WlanConnectionProfileDetails]: ...
    @_property
    def wwan_connection_profile_details(self) -> typing.Optional[WwanConnectionProfileDetails]: ...
    @_property
    def can_delete(self) -> bool: ...

@typing.final
class ConnectionProfileFilter(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ConnectionProfileFilter: ...
    def __new__(cls: typing.Type[ConnectionProfileFilter]) -> ConnectionProfileFilter:...
    @_property
    def service_provider_guid(self) -> typing.Optional[typing.Optional[_uuid.UUID]]: ...
    @service_provider_guid.setter
    def service_provider_guid(self, value: typing.Optional[typing.Optional[_uuid.UUID]]) -> None: ...
    @_property
    def network_cost_type(self) -> NetworkCostType: ...
    @network_cost_type.setter
    def network_cost_type(self, value: NetworkCostType) -> None: ...
    @_property
    def is_wwan_connection_profile(self) -> bool: ...
    @is_wwan_connection_profile.setter
    def is_wwan_connection_profile(self, value: bool) -> None: ...
    @_property
    def is_wlan_connection_profile(self) -> bool: ...
    @is_wlan_connection_profile.setter
    def is_wlan_connection_profile(self, value: bool) -> None: ...
    @_property
    def is_connected(self) -> bool: ...
    @is_connected.setter
    def is_connected(self, value: bool) -> None: ...
    @_property
    def is_roaming(self) -> typing.Optional[typing.Optional[bool]]: ...
    @is_roaming.setter
    def is_roaming(self, value: typing.Optional[typing.Optional[bool]]) -> None: ...
    @_property
    def is_over_data_limit(self) -> typing.Optional[typing.Optional[bool]]: ...
    @is_over_data_limit.setter
    def is_over_data_limit(self, value: typing.Optional[typing.Optional[bool]]) -> None: ...
    @_property
    def is_background_data_usage_restricted(self) -> typing.Optional[typing.Optional[bool]]: ...
    @is_background_data_usage_restricted.setter
    def is_background_data_usage_restricted(self, value: typing.Optional[typing.Optional[bool]]) -> None: ...
    @_property
    def raw_data(self) -> typing.Optional[winrt.windows.storage.streams.IBuffer]: ...
    @_property
    def purpose_guid(self) -> typing.Optional[typing.Optional[_uuid.UUID]]: ...
    @purpose_guid.setter
    def purpose_guid(self, value: typing.Optional[typing.Optional[_uuid.UUID]]) -> None: ...

@typing.final
class ConnectionSession(winrt.system.Object):
    def __enter__(self: Self) -> Self: ...
    def __exit__(self, *args) -> None: ...
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ConnectionSession: ...
    def close(self) -> None: ...
    @_property
    def connection_profile(self) -> typing.Optional[ConnectionProfile]: ...

@typing.final
class ConnectivityInterval(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ConnectivityInterval: ...
    @_property
    def connection_duration(self) -> datetime.timedelta: ...
    @_property
    def start_time(self) -> datetime.datetime: ...

@typing.final
class ConnectivityManager_Static(type):
    def acquire_connection_async(cls, cellular_apn_context: typing.Optional[CellularApnContext], /) -> winrt.windows.foundation.IAsyncOperation[ConnectionSession]: ...
    def add_http_route_policy(cls, route_policy: typing.Optional[RoutePolicy], /) -> None: ...
    def remove_http_route_policy(cls, route_policy: typing.Optional[RoutePolicy], /) -> None: ...

@typing.final
class ConnectivityManager(winrt.system.Object, metaclass=ConnectivityManager_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ConnectivityManager: ...

@typing.final
class DataPlanStatus(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> DataPlanStatus: ...
    @_property
    def data_limit_in_megabytes(self) -> typing.Optional[typing.Optional[winrt.system.UInt32]]: ...
    @_property
    def data_plan_usage(self) -> typing.Optional[DataPlanUsage]: ...
    @_property
    def inbound_bits_per_second(self) -> typing.Optional[typing.Optional[winrt.system.UInt64]]: ...
    @_property
    def max_transfer_size_in_megabytes(self) -> typing.Optional[typing.Optional[winrt.system.UInt32]]: ...
    @_property
    def next_billing_cycle(self) -> typing.Optional[typing.Optional[datetime.datetime]]: ...
    @_property
    def outbound_bits_per_second(self) -> typing.Optional[typing.Optional[winrt.system.UInt64]]: ...

@typing.final
class DataPlanUsage(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> DataPlanUsage: ...
    @_property
    def last_sync_time(self) -> datetime.datetime: ...
    @_property
    def megabytes_used(self) -> winrt.system.UInt32: ...

@typing.final
class DataUsage(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> DataUsage: ...
    @_property
    def bytes_received(self) -> winrt.system.UInt64: ...
    @_property
    def bytes_sent(self) -> winrt.system.UInt64: ...

@typing.final
class IPInformation(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> IPInformation: ...
    @_property
    def network_adapter(self) -> typing.Optional[NetworkAdapter]: ...
    @_property
    def prefix_length(self) -> typing.Optional[typing.Optional[winrt.system.UInt8]]: ...

@typing.final
class LanIdentifier(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> LanIdentifier: ...
    @_property
    def infrastructure_id(self) -> typing.Optional[LanIdentifierData]: ...
    @_property
    def network_adapter_id(self) -> _uuid.UUID: ...
    @_property
    def port_id(self) -> typing.Optional[LanIdentifierData]: ...

@typing.final
class LanIdentifierData(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> LanIdentifierData: ...
    @_property
    def type(self) -> winrt.system.UInt32: ...
    @_property
    def value(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[winrt.system.UInt8]]: ...

@typing.final
class NetworkAdapter(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> NetworkAdapter: ...
    def get_connected_profile_async(self) -> winrt.windows.foundation.IAsyncOperation[ConnectionProfile]: ...
    @_property
    def iana_interface_type(self) -> winrt.system.UInt32: ...
    @_property
    def inbound_max_bits_per_second(self) -> winrt.system.UInt64: ...
    @_property
    def network_adapter_id(self) -> _uuid.UUID: ...
    @_property
    def network_item(self) -> typing.Optional[NetworkItem]: ...
    @_property
    def outbound_max_bits_per_second(self) -> winrt.system.UInt64: ...

@typing.final
class NetworkInformation_Static(type):
    def find_connection_profiles_async(cls, p_profile_filter: typing.Optional[ConnectionProfileFilter], /) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.foundation.collections.IVectorView[ConnectionProfile]]: ...
    def get_connection_profiles(cls) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[ConnectionProfile]]: ...
    def get_host_names(cls) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[winrt.windows.networking.HostName]]: ...
    def get_internet_connection_profile(cls) -> typing.Optional[ConnectionProfile]: ...
    def get_lan_identifiers(cls) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[LanIdentifier]]: ...
    def get_proxy_configuration_async(cls, uri: typing.Optional[winrt.windows.foundation.Uri], /) -> winrt.windows.foundation.IAsyncOperation[ProxyConfiguration]: ...
    def get_sorted_endpoint_pairs(cls, destination_list: typing.Iterable[winrt.windows.networking.EndpointPair], sort_options: winrt.windows.networking.HostNameSortOptions, /) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[winrt.windows.networking.EndpointPair]]: ...
    def add_network_status_changed(cls, network_status_handler: typing.Optional[NetworkStatusChangedEventHandler], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_network_status_changed(cls, event_cookie: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...

@typing.final
class NetworkInformation(winrt.system.Object, metaclass=NetworkInformation_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> NetworkInformation: ...

@typing.final
class NetworkItem(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> NetworkItem: ...
    def get_network_types(self) -> NetworkTypes: ...
    @_property
    def network_id(self) -> _uuid.UUID: ...

@typing.final
class NetworkSecuritySettings(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> NetworkSecuritySettings: ...
    @_property
    def network_authentication_type(self) -> NetworkAuthenticationType: ...
    @_property
    def network_encryption_type(self) -> NetworkEncryptionType: ...

@typing.final
class NetworkStateChangeEventDetails(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> NetworkStateChangeEventDetails: ...
    @_property
    def has_new_connection_cost(self) -> bool: ...
    @_property
    def has_new_domain_connectivity_level(self) -> bool: ...
    @_property
    def has_new_host_name_list(self) -> bool: ...
    @_property
    def has_new_internet_connection_profile(self) -> bool: ...
    @_property
    def has_new_network_connectivity_level(self) -> bool: ...
    @_property
    def has_new_wwan_registration_state(self) -> bool: ...
    @_property
    def has_new_tethering_client_count(self) -> bool: ...
    @_property
    def has_new_tethering_operational_state(self) -> bool: ...

@typing.final
class NetworkUsage(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> NetworkUsage: ...
    @_property
    def bytes_received(self) -> winrt.system.UInt64: ...
    @_property
    def bytes_sent(self) -> winrt.system.UInt64: ...
    @_property
    def connection_duration(self) -> datetime.timedelta: ...

@typing.final
class ProviderNetworkUsage(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ProviderNetworkUsage: ...
    @_property
    def bytes_received(self) -> winrt.system.UInt64: ...
    @_property
    def bytes_sent(self) -> winrt.system.UInt64: ...
    @_property
    def provider_id(self) -> str: ...

@typing.final
class ProxyConfiguration(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ProxyConfiguration: ...
    @_property
    def can_connect_directly(self) -> bool: ...
    @_property
    def proxy_uris(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[winrt.windows.foundation.Uri]]: ...

@typing.final
class RoutePolicy(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> RoutePolicy: ...
    def __new__(cls: typing.Type[RoutePolicy], connection_profile: typing.Optional[ConnectionProfile], host_name: typing.Optional[winrt.windows.networking.HostName], type: winrt.windows.networking.DomainNameType) -> RoutePolicy:...
    @_property
    def connection_profile(self) -> typing.Optional[ConnectionProfile]: ...
    @_property
    def host_name(self) -> typing.Optional[winrt.windows.networking.HostName]: ...
    @_property
    def host_name_type(self) -> winrt.windows.networking.DomainNameType: ...

@typing.final
class WlanConnectionProfileDetails(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> WlanConnectionProfileDetails: ...
    def get_connected_ssid(self) -> str: ...

@typing.final
class WwanConnectionProfileDetails(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> WwanConnectionProfileDetails: ...
    def get_current_data_class(self) -> WwanDataClass: ...
    def get_network_registration_state(self) -> WwanNetworkRegistrationState: ...
    @_property
    def access_point_name(self) -> str: ...
    @_property
    def home_provider_id(self) -> str: ...
    @_property
    def i_p_kind(self) -> WwanNetworkIPKind: ...
    @_property
    def purpose_guids(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[_uuid.UUID]]: ...

