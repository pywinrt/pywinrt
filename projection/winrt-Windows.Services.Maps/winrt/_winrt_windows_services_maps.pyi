# WARNING: Please don't edit this file. It was generated by Python/WinRT v2.0.0-beta.2

import datetime
import sys
import types
import typing
import uuid as _uuid
from builtins import property as _property

import winrt._winrt
import winrt.system
import winrt.windows.devices.geolocation
import winrt.windows.foundation
import winrt.windows.foundation.collections
import winrt.windows.ui.popups

from winrt.windows.services.maps import ManeuverWarningKind, ManeuverWarningSeverity, MapLocationDesiredAccuracy, MapLocationFinderStatus, MapManeuverNotices, MapRouteFinderStatus, MapRouteManeuverKind, MapRouteOptimization, MapRouteRestrictions, MapServiceDataUsagePreference, TrafficCongestion, WaypointKind

Self = typing.TypeVar('Self')

@typing.final
class EnhancedWaypoint(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> EnhancedWaypoint: ...
    def __new__(cls: typing.Type[EnhancedWaypoint], point: typing.Optional[winrt.windows.devices.geolocation.Geopoint], kind: WaypointKind) -> EnhancedWaypoint:...
    @_property
    def kind(self) -> WaypointKind: ...
    @_property
    def point(self) -> typing.Optional[winrt.windows.devices.geolocation.Geopoint]: ...

@typing.final
class ManeuverWarning(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ManeuverWarning: ...
    @_property
    def kind(self) -> ManeuverWarningKind: ...
    @_property
    def severity(self) -> ManeuverWarningSeverity: ...

@typing.final
class MapAddress(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MapAddress: ...
    @_property
    def building_floor(self) -> str: ...
    @_property
    def building_name(self) -> str: ...
    @_property
    def building_room(self) -> str: ...
    @_property
    def building_wing(self) -> str: ...
    @_property
    def continent(self) -> str: ...
    @_property
    def country(self) -> str: ...
    @_property
    def country_code(self) -> str: ...
    @_property
    def district(self) -> str: ...
    @_property
    def neighborhood(self) -> str: ...
    @_property
    def post_code(self) -> str: ...
    @_property
    def region(self) -> str: ...
    @_property
    def region_code(self) -> str: ...
    @_property
    def street(self) -> str: ...
    @_property
    def street_number(self) -> str: ...
    @_property
    def town(self) -> str: ...
    @_property
    def formatted_address(self) -> str: ...

@typing.final
class MapLocation(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MapLocation: ...
    @_property
    def address(self) -> typing.Optional[MapAddress]: ...
    @_property
    def description(self) -> str: ...
    @_property
    def display_name(self) -> str: ...
    @_property
    def point(self) -> typing.Optional[winrt.windows.devices.geolocation.Geopoint]: ...

@typing.final
class MapLocationFinder_Static(type):
    @typing.overload
    def find_locations_async(cls, search_text: str, reference_point: typing.Optional[winrt.windows.devices.geolocation.Geopoint], /) -> winrt.windows.foundation.IAsyncOperation[MapLocationFinderResult]: ...
    @typing.overload
    def find_locations_async(cls, search_text: str, reference_point: typing.Optional[winrt.windows.devices.geolocation.Geopoint], max_count: winrt.system.UInt32, /) -> winrt.windows.foundation.IAsyncOperation[MapLocationFinderResult]: ...
    @typing.overload
    def find_locations_at_async(cls, query_point: typing.Optional[winrt.windows.devices.geolocation.Geopoint], /) -> winrt.windows.foundation.IAsyncOperation[MapLocationFinderResult]: ...
    @typing.overload
    def find_locations_at_async(cls, query_point: typing.Optional[winrt.windows.devices.geolocation.Geopoint], accuracy: MapLocationDesiredAccuracy, /) -> winrt.windows.foundation.IAsyncOperation[MapLocationFinderResult]: ...

@typing.final
class MapLocationFinder(winrt.system.Object, metaclass=MapLocationFinder_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MapLocationFinder: ...

@typing.final
class MapLocationFinderResult(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MapLocationFinderResult: ...
    @_property
    def locations(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[MapLocation]]: ...
    @_property
    def status(self) -> MapLocationFinderStatus: ...

@typing.final
class MapManager_Static(type):
    def show_downloaded_maps_u_i(cls) -> None: ...
    def show_maps_update_u_i(cls) -> None: ...

@typing.final
class MapManager(winrt.system.Object, metaclass=MapManager_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MapManager: ...

@typing.final
class MapRoute(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MapRoute: ...
    @_property
    def bounding_box(self) -> typing.Optional[winrt.windows.devices.geolocation.GeoboundingBox]: ...
    @_property
    def estimated_duration(self) -> datetime.timedelta: ...
    @_property
    def is_traffic_based(self) -> bool: ...
    @_property
    def legs(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[MapRouteLeg]]: ...
    @_property
    def length_in_meters(self) -> winrt.system.Double: ...
    @_property
    def path(self) -> typing.Optional[winrt.windows.devices.geolocation.Geopath]: ...
    @_property
    def has_blocked_roads(self) -> bool: ...
    @_property
    def violated_restrictions(self) -> MapRouteRestrictions: ...
    @_property
    def duration_without_traffic(self) -> datetime.timedelta: ...
    @_property
    def traffic_congestion(self) -> TrafficCongestion: ...
    @_property
    def is_scenic(self) -> bool: ...

@typing.final
class MapRouteDrivingOptions(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MapRouteDrivingOptions: ...
    def __new__(cls: typing.Type[MapRouteDrivingOptions]) -> MapRouteDrivingOptions:...
    @_property
    def route_restrictions(self) -> MapRouteRestrictions: ...
    @route_restrictions.setter
    def route_restrictions(self, value: MapRouteRestrictions) -> None: ...
    @_property
    def route_optimization(self) -> MapRouteOptimization: ...
    @route_optimization.setter
    def route_optimization(self, value: MapRouteOptimization) -> None: ...
    @_property
    def max_alternate_route_count(self) -> winrt.system.UInt32: ...
    @max_alternate_route_count.setter
    def max_alternate_route_count(self, value: winrt.system.UInt32) -> None: ...
    @_property
    def initial_heading(self) -> typing.Optional[typing.Optional[winrt.system.Double]]: ...
    @initial_heading.setter
    def initial_heading(self, value: typing.Optional[typing.Optional[winrt.system.Double]]) -> None: ...
    @_property
    def departure_time(self) -> typing.Optional[typing.Optional[datetime.datetime]]: ...
    @departure_time.setter
    def departure_time(self, value: typing.Optional[typing.Optional[datetime.datetime]]) -> None: ...

@typing.final
class MapRouteFinder_Static(type):
    @typing.overload
    def get_driving_route_async(cls, start_point: typing.Optional[winrt.windows.devices.geolocation.Geopoint], end_point: typing.Optional[winrt.windows.devices.geolocation.Geopoint], /) -> winrt.windows.foundation.IAsyncOperation[MapRouteFinderResult]: ...
    @typing.overload
    def get_driving_route_async(cls, start_point: typing.Optional[winrt.windows.devices.geolocation.Geopoint], end_point: typing.Optional[winrt.windows.devices.geolocation.Geopoint], options: typing.Optional[MapRouteDrivingOptions], /) -> winrt.windows.foundation.IAsyncOperation[MapRouteFinderResult]: ...
    @typing.overload
    def get_driving_route_async(cls, start_point: typing.Optional[winrt.windows.devices.geolocation.Geopoint], end_point: typing.Optional[winrt.windows.devices.geolocation.Geopoint], optimization: MapRouteOptimization, restrictions: MapRouteRestrictions, /) -> winrt.windows.foundation.IAsyncOperation[MapRouteFinderResult]: ...
    @typing.overload
    def get_driving_route_async(cls, start_point: typing.Optional[winrt.windows.devices.geolocation.Geopoint], end_point: typing.Optional[winrt.windows.devices.geolocation.Geopoint], optimization: MapRouteOptimization, restrictions: MapRouteRestrictions, heading_in_degrees: winrt.system.Double, /) -> winrt.windows.foundation.IAsyncOperation[MapRouteFinderResult]: ...
    @typing.overload
    def get_driving_route_from_enhanced_waypoints_async(cls, waypoints: typing.Iterable[EnhancedWaypoint], /) -> winrt.windows.foundation.IAsyncOperation[MapRouteFinderResult]: ...
    @typing.overload
    def get_driving_route_from_enhanced_waypoints_async(cls, waypoints: typing.Iterable[EnhancedWaypoint], options: typing.Optional[MapRouteDrivingOptions], /) -> winrt.windows.foundation.IAsyncOperation[MapRouteFinderResult]: ...
    @typing.overload
    def get_driving_route_from_waypoints_async(cls, way_points: typing.Iterable[winrt.windows.devices.geolocation.Geopoint], /) -> winrt.windows.foundation.IAsyncOperation[MapRouteFinderResult]: ...
    @typing.overload
    def get_driving_route_from_waypoints_async(cls, way_points: typing.Iterable[winrt.windows.devices.geolocation.Geopoint], optimization: MapRouteOptimization, /) -> winrt.windows.foundation.IAsyncOperation[MapRouteFinderResult]: ...
    @typing.overload
    def get_driving_route_from_waypoints_async(cls, way_points: typing.Iterable[winrt.windows.devices.geolocation.Geopoint], optimization: MapRouteOptimization, restrictions: MapRouteRestrictions, /) -> winrt.windows.foundation.IAsyncOperation[MapRouteFinderResult]: ...
    @typing.overload
    def get_driving_route_from_waypoints_async(cls, way_points: typing.Iterable[winrt.windows.devices.geolocation.Geopoint], optimization: MapRouteOptimization, restrictions: MapRouteRestrictions, heading_in_degrees: winrt.system.Double, /) -> winrt.windows.foundation.IAsyncOperation[MapRouteFinderResult]: ...
    def get_walking_route_async(cls, start_point: typing.Optional[winrt.windows.devices.geolocation.Geopoint], end_point: typing.Optional[winrt.windows.devices.geolocation.Geopoint], /) -> winrt.windows.foundation.IAsyncOperation[MapRouteFinderResult]: ...
    def get_walking_route_from_waypoints_async(cls, way_points: typing.Iterable[winrt.windows.devices.geolocation.Geopoint], /) -> winrt.windows.foundation.IAsyncOperation[MapRouteFinderResult]: ...

@typing.final
class MapRouteFinder(winrt.system.Object, metaclass=MapRouteFinder_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MapRouteFinder: ...

@typing.final
class MapRouteFinderResult(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MapRouteFinderResult: ...
    @_property
    def route(self) -> typing.Optional[MapRoute]: ...
    @_property
    def status(self) -> MapRouteFinderStatus: ...
    @_property
    def alternate_routes(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[MapRoute]]: ...

@typing.final
class MapRouteLeg(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MapRouteLeg: ...
    @_property
    def bounding_box(self) -> typing.Optional[winrt.windows.devices.geolocation.GeoboundingBox]: ...
    @_property
    def estimated_duration(self) -> datetime.timedelta: ...
    @_property
    def length_in_meters(self) -> winrt.system.Double: ...
    @_property
    def maneuvers(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[MapRouteManeuver]]: ...
    @_property
    def path(self) -> typing.Optional[winrt.windows.devices.geolocation.Geopath]: ...
    @_property
    def duration_without_traffic(self) -> datetime.timedelta: ...
    @_property
    def traffic_congestion(self) -> TrafficCongestion: ...

@typing.final
class MapRouteManeuver(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MapRouteManeuver: ...
    @_property
    def exit_number(self) -> str: ...
    @_property
    def instruction_text(self) -> str: ...
    @_property
    def kind(self) -> MapRouteManeuverKind: ...
    @_property
    def length_in_meters(self) -> winrt.system.Double: ...
    @_property
    def maneuver_notices(self) -> MapManeuverNotices: ...
    @_property
    def starting_point(self) -> typing.Optional[winrt.windows.devices.geolocation.Geopoint]: ...
    @_property
    def end_heading(self) -> winrt.system.Double: ...
    @_property
    def start_heading(self) -> winrt.system.Double: ...
    @_property
    def street_name(self) -> str: ...
    @_property
    def warnings(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[ManeuverWarning]]: ...

@typing.final
class MapService_Static(type):
    @_property
    def service_token(cls) -> str: ...
    @service_token.setter
    def service_token(cls, value: str) -> None: ...
    @_property
    def world_view_region_code(cls) -> str: ...
    @_property
    def data_attributions(cls) -> str: ...
    @_property
    def data_usage_preference(cls) -> MapServiceDataUsagePreference: ...
    @data_usage_preference.setter
    def data_usage_preference(cls, value: MapServiceDataUsagePreference) -> None: ...

@typing.final
class MapService(winrt.system.Object, metaclass=MapService_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MapService: ...

@typing.final
class PlaceInfo_Static(type):
    @typing.overload
    def create(cls, reference_point: typing.Optional[winrt.windows.devices.geolocation.Geopoint], /) -> typing.Optional[PlaceInfo]: ...
    @typing.overload
    def create(cls, reference_point: typing.Optional[winrt.windows.devices.geolocation.Geopoint], options: typing.Optional[PlaceInfoCreateOptions], /) -> typing.Optional[PlaceInfo]: ...
    @typing.overload
    def create_from_address(cls, display_address: str, /) -> typing.Optional[PlaceInfo]: ...
    @typing.overload
    def create_from_address(cls, display_address: str, display_name: str, /) -> typing.Optional[PlaceInfo]: ...
    @typing.overload
    def create_from_identifier(cls, identifier: str, /) -> typing.Optional[PlaceInfo]: ...
    @typing.overload
    def create_from_identifier(cls, identifier: str, default_point: typing.Optional[winrt.windows.devices.geolocation.Geopoint], options: typing.Optional[PlaceInfoCreateOptions], /) -> typing.Optional[PlaceInfo]: ...
    def create_from_map_location(cls, location: typing.Optional[MapLocation], /) -> typing.Optional[PlaceInfo]: ...
    @_property
    def is_show_supported(cls) -> bool: ...

@typing.final
class PlaceInfo(winrt.system.Object, metaclass=PlaceInfo_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> PlaceInfo: ...
    @typing.overload
    def show(self, selection: winrt.windows.foundation.Rect, /) -> None: ...
    @typing.overload
    def show(self, selection: winrt.windows.foundation.Rect, preferred_placement: winrt.windows.ui.popups.Placement, /) -> None: ...
    @_property
    def display_address(self) -> str: ...
    @_property
    def display_name(self) -> str: ...
    @_property
    def geoshape(self) -> typing.Optional[winrt.windows.devices.geolocation.IGeoshape]: ...
    @_property
    def identifier(self) -> str: ...

@typing.final
class PlaceInfoCreateOptions(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> PlaceInfoCreateOptions: ...
    def __new__(cls: typing.Type[PlaceInfoCreateOptions]) -> PlaceInfoCreateOptions:...
    @_property
    def display_name(self) -> str: ...
    @display_name.setter
    def display_name(self, value: str) -> None: ...
    @_property
    def display_address(self) -> str: ...
    @display_address.setter
    def display_address(self, value: str) -> None: ...

