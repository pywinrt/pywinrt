# WARNING: Please don't edit this file. It was generated by Python/WinRT v2.0.0-beta.2

import datetime
import sys
import types
import typing
import uuid as _uuid
from builtins import property as _property

import winrt._winrt
import winrt.system
import winrt.windows.devices.display
import winrt.windows.foundation
import winrt.windows.foundation.collections
import winrt.windows.foundation.numerics
import winrt.windows.graphics
import winrt.windows.graphics.directx
import winrt.windows.graphics.directx.direct3d11
import winrt.windows.storage.streams

from winrt.windows.devices.display.core import DisplayBitsPerChannel, DisplayDeviceCapability, DisplayManagerOptions, DisplayManagerResult, DisplayModeQueryOptions, DisplayPathScaling, DisplayPathStatus, DisplayPresentStatus, DisplayRotation, DisplayScanoutOptions, DisplaySourceStatus, DisplayStateApplyOptions, DisplayStateFunctionalizeOptions, DisplayStateOperationStatus, DisplayTargetPersistence, DisplayTaskSignalKind, DisplayWireFormatColorSpace, DisplayWireFormatEotf, DisplayWireFormatHdrMetadata, DisplayWireFormatPixelEncoding

Self = typing.TypeVar('Self')

@typing.final
class DisplayPresentationRate:
    vertical_sync_rate: winrt.windows.foundation.numerics.Rational
    vertical_syncs_per_presentation: winrt.system.Int32
    def __init__(self, vertical_sync_rate: winrt.windows.foundation.numerics.Rational, vertical_syncs_per_presentation: winrt.system.Int32) -> None: ...

@typing.final
class DisplayAdapter_Static(type):
    def from_id(cls, id: winrt.windows.graphics.DisplayAdapterId, /) -> typing.Optional[DisplayAdapter]: ...

@typing.final
class DisplayAdapter(winrt.system.Object, metaclass=DisplayAdapter_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> DisplayAdapter: ...
    @_property
    def device_interface_path(self) -> str: ...
    @_property
    def id(self) -> winrt.windows.graphics.DisplayAdapterId: ...
    @_property
    def pci_device_id(self) -> winrt.system.UInt32: ...
    @_property
    def pci_revision(self) -> winrt.system.UInt32: ...
    @_property
    def pci_sub_system_id(self) -> winrt.system.UInt32: ...
    @_property
    def pci_vendor_id(self) -> winrt.system.UInt32: ...
    @_property
    def properties(self) -> typing.Optional[winrt.windows.foundation.collections.IMapView[_uuid.UUID, winrt.system.Object]]: ...
    @_property
    def source_count(self) -> winrt.system.UInt32: ...

@typing.final
class DisplayDevice(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> DisplayDevice: ...
    def create_periodic_fence(self, target: typing.Optional[DisplayTarget], offset_from_v_blank: datetime.timedelta, /) -> typing.Optional[DisplayFence]: ...
    def create_primary(self, target: typing.Optional[DisplayTarget], desc: typing.Optional[DisplayPrimaryDescription], /) -> typing.Optional[DisplaySurface]: ...
    def create_scanout_source(self, target: typing.Optional[DisplayTarget], /) -> typing.Optional[DisplaySource]: ...
    def create_simple_scanout(self, p_source: typing.Optional[DisplaySource], p_surface: typing.Optional[DisplaySurface], sub_resource_index: winrt.system.UInt32, sync_interval: winrt.system.UInt32, /) -> typing.Optional[DisplayScanout]: ...
    def create_simple_scanout_with_dirty_rects_and_options(self, source: typing.Optional[DisplaySource], surface: typing.Optional[DisplaySurface], subresource_index: winrt.system.UInt32, sync_interval: winrt.system.UInt32, dirty_rects: typing.Iterable[winrt.windows.graphics.RectInt32], options: DisplayScanoutOptions, /) -> typing.Optional[DisplayScanout]: ...
    def create_task_pool(self) -> typing.Optional[DisplayTaskPool]: ...
    def is_capability_supported(self, capability: DisplayDeviceCapability, /) -> bool: ...
    def wait_for_v_blank(self, source: typing.Optional[DisplaySource], /) -> None: ...

@typing.final
class DisplayFence(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> DisplayFence: ...

@typing.final
class DisplayManager_Static(type):
    def create(cls, options: DisplayManagerOptions, /) -> typing.Optional[DisplayManager]: ...

@typing.final
class DisplayManager(winrt.system.Object, metaclass=DisplayManager_Static):
    def __enter__(self: Self) -> Self: ...
    def __exit__(self, *args) -> None: ...
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> DisplayManager: ...
    def close(self) -> None: ...
    def create_display_device(self, adapter: typing.Optional[DisplayAdapter], /) -> typing.Optional[DisplayDevice]: ...
    def get_current_adapters(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[DisplayAdapter]]: ...
    def get_current_targets(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[DisplayTarget]]: ...
    def release_target(self, target: typing.Optional[DisplayTarget], /) -> None: ...
    def start(self) -> None: ...
    def stop(self) -> None: ...
    def try_acquire_target(self, target: typing.Optional[DisplayTarget], /) -> DisplayManagerResult: ...
    def try_acquire_targets_and_create_empty_state(self, targets: typing.Iterable[DisplayTarget], /) -> typing.Optional[DisplayManagerResultWithState]: ...
    def try_acquire_targets_and_create_substate(self, existing_state: typing.Optional[DisplayState], targets: typing.Iterable[DisplayTarget], /) -> typing.Optional[DisplayManagerResultWithState]: ...
    def try_acquire_targets_and_read_current_state(self, targets: typing.Iterable[DisplayTarget], /) -> typing.Optional[DisplayManagerResultWithState]: ...
    def try_read_current_state_for_all_targets(self) -> typing.Optional[DisplayManagerResultWithState]: ...
    def add_changed(self, handler: winrt.windows.foundation.TypedEventHandler[DisplayManager, DisplayManagerChangedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_disabled(self, handler: winrt.windows.foundation.TypedEventHandler[DisplayManager, DisplayManagerDisabledEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_disabled(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_enabled(self, handler: winrt.windows.foundation.TypedEventHandler[DisplayManager, DisplayManagerEnabledEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_enabled(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_paths_failed_or_invalidated(self, handler: winrt.windows.foundation.TypedEventHandler[DisplayManager, DisplayManagerPathsFailedOrInvalidatedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_paths_failed_or_invalidated(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...

@typing.final
class DisplayManagerChangedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> DisplayManagerChangedEventArgs: ...
    def get_deferral(self) -> typing.Optional[winrt.windows.foundation.Deferral]: ...
    @_property
    def handled(self) -> bool: ...
    @handled.setter
    def handled(self, value: bool) -> None: ...

@typing.final
class DisplayManagerDisabledEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> DisplayManagerDisabledEventArgs: ...
    def get_deferral(self) -> typing.Optional[winrt.windows.foundation.Deferral]: ...
    @_property
    def handled(self) -> bool: ...
    @handled.setter
    def handled(self, value: bool) -> None: ...

@typing.final
class DisplayManagerEnabledEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> DisplayManagerEnabledEventArgs: ...
    def get_deferral(self) -> typing.Optional[winrt.windows.foundation.Deferral]: ...
    @_property
    def handled(self) -> bool: ...
    @handled.setter
    def handled(self, value: bool) -> None: ...

@typing.final
class DisplayManagerPathsFailedOrInvalidatedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> DisplayManagerPathsFailedOrInvalidatedEventArgs: ...
    def get_deferral(self) -> typing.Optional[winrt.windows.foundation.Deferral]: ...
    @_property
    def handled(self) -> bool: ...
    @handled.setter
    def handled(self, value: bool) -> None: ...

@typing.final
class DisplayManagerResultWithState(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> DisplayManagerResultWithState: ...
    @_property
    def error_code(self) -> DisplayManagerResult: ...
    @_property
    def extended_error_code(self) -> winrt.windows.foundation.HResult: ...
    @_property
    def state(self) -> typing.Optional[DisplayState]: ...

@typing.final
class DisplayModeInfo(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> DisplayModeInfo: ...
    def get_wire_format_supported_bits_per_channel(self, encoding: DisplayWireFormatPixelEncoding, /) -> DisplayBitsPerChannel: ...
    def is_wire_format_supported(self, wire_format: typing.Optional[DisplayWireFormat], /) -> bool: ...
    @_property
    def is_interlaced(self) -> bool: ...
    @_property
    def is_stereo(self) -> bool: ...
    @_property
    def presentation_rate(self) -> DisplayPresentationRate: ...
    @_property
    def properties(self) -> typing.Optional[winrt.windows.foundation.collections.IMapView[_uuid.UUID, winrt.system.Object]]: ...
    @_property
    def source_pixel_format(self) -> winrt.windows.graphics.directx.DirectXPixelFormat: ...
    @_property
    def source_resolution(self) -> winrt.windows.graphics.SizeInt32: ...
    @_property
    def target_resolution(self) -> winrt.windows.graphics.SizeInt32: ...
    @_property
    def physical_presentation_rate(self) -> DisplayPresentationRate: ...

@typing.final
class DisplayPath(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> DisplayPath: ...
    def apply_properties_from_mode(self, mode_result: typing.Optional[DisplayModeInfo], /) -> None: ...
    def find_modes(self, flags: DisplayModeQueryOptions, /) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[DisplayModeInfo]]: ...
    @_property
    def wire_format(self) -> typing.Optional[DisplayWireFormat]: ...
    @wire_format.setter
    def wire_format(self, value: typing.Optional[DisplayWireFormat]) -> None: ...
    @_property
    def target_resolution(self) -> typing.Optional[typing.Optional[winrt.windows.graphics.SizeInt32]]: ...
    @target_resolution.setter
    def target_resolution(self, value: typing.Optional[typing.Optional[winrt.windows.graphics.SizeInt32]]) -> None: ...
    @_property
    def source_resolution(self) -> typing.Optional[typing.Optional[winrt.windows.graphics.SizeInt32]]: ...
    @source_resolution.setter
    def source_resolution(self, value: typing.Optional[typing.Optional[winrt.windows.graphics.SizeInt32]]) -> None: ...
    @_property
    def source_pixel_format(self) -> winrt.windows.graphics.directx.DirectXPixelFormat: ...
    @source_pixel_format.setter
    def source_pixel_format(self, value: winrt.windows.graphics.directx.DirectXPixelFormat) -> None: ...
    @_property
    def scaling(self) -> DisplayPathScaling: ...
    @scaling.setter
    def scaling(self, value: DisplayPathScaling) -> None: ...
    @_property
    def rotation(self) -> DisplayRotation: ...
    @rotation.setter
    def rotation(self, value: DisplayRotation) -> None: ...
    @_property
    def presentation_rate(self) -> typing.Optional[typing.Optional[DisplayPresentationRate]]: ...
    @presentation_rate.setter
    def presentation_rate(self, value: typing.Optional[typing.Optional[DisplayPresentationRate]]) -> None: ...
    @_property
    def is_stereo(self) -> bool: ...
    @is_stereo.setter
    def is_stereo(self, value: bool) -> None: ...
    @_property
    def is_interlaced(self) -> typing.Optional[typing.Optional[bool]]: ...
    @is_interlaced.setter
    def is_interlaced(self, value: typing.Optional[typing.Optional[bool]]) -> None: ...
    @_property
    def properties(self) -> typing.Optional[winrt.windows.foundation.collections.IMap[_uuid.UUID, winrt.system.Object]]: ...
    @_property
    def status(self) -> DisplayPathStatus: ...
    @_property
    def target(self) -> typing.Optional[DisplayTarget]: ...
    @_property
    def view(self) -> typing.Optional[DisplayView]: ...
    @_property
    def physical_presentation_rate(self) -> typing.Optional[typing.Optional[DisplayPresentationRate]]: ...
    @physical_presentation_rate.setter
    def physical_presentation_rate(self, value: typing.Optional[typing.Optional[DisplayPresentationRate]]) -> None: ...

@typing.final
class DisplayPrimaryDescription_Static(type):
    def create_with_properties(cls, extra_properties: typing.Iterable[winrt.windows.foundation.collections.IKeyValuePair[_uuid.UUID, winrt.system.Object]], width: winrt.system.UInt32, height: winrt.system.UInt32, pixel_format: winrt.windows.graphics.directx.DirectXPixelFormat, color_space: winrt.windows.graphics.directx.DirectXColorSpace, is_stereo: bool, multisample_description: winrt.windows.graphics.directx.direct3d11.Direct3DMultisampleDescription, /) -> typing.Optional[DisplayPrimaryDescription]: ...

@typing.final
class DisplayPrimaryDescription(winrt.system.Object, metaclass=DisplayPrimaryDescription_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> DisplayPrimaryDescription: ...
    def __new__(cls: typing.Type[DisplayPrimaryDescription], width: winrt.system.UInt32, height: winrt.system.UInt32, pixel_format: winrt.windows.graphics.directx.DirectXPixelFormat, color_space: winrt.windows.graphics.directx.DirectXColorSpace, is_stereo: bool, multisample_description: winrt.windows.graphics.directx.direct3d11.Direct3DMultisampleDescription) -> DisplayPrimaryDescription:...
    @_property
    def color_space(self) -> winrt.windows.graphics.directx.DirectXColorSpace: ...
    @_property
    def format(self) -> winrt.windows.graphics.directx.DirectXPixelFormat: ...
    @_property
    def height(self) -> winrt.system.UInt32: ...
    @_property
    def is_stereo(self) -> bool: ...
    @_property
    def multisample_description(self) -> winrt.windows.graphics.directx.direct3d11.Direct3DMultisampleDescription: ...
    @_property
    def properties(self) -> typing.Optional[winrt.windows.foundation.collections.IMapView[_uuid.UUID, winrt.system.Object]]: ...
    @_property
    def width(self) -> winrt.system.UInt32: ...

@typing.final
class DisplayScanout(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> DisplayScanout: ...

@typing.final
class DisplaySource(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> DisplaySource: ...
    def get_metadata(self, key: _uuid.UUID, /) -> typing.Optional[winrt.windows.storage.streams.IBuffer]: ...
    def add_status_changed(self, handler: winrt.windows.foundation.TypedEventHandler[DisplaySource, winrt.system.Object], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_status_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    @_property
    def adapter_id(self) -> winrt.windows.graphics.DisplayAdapterId: ...
    @_property
    def source_id(self) -> winrt.system.UInt32: ...
    @_property
    def status(self) -> DisplaySourceStatus: ...

@typing.final
class DisplayState(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> DisplayState: ...
    def can_connect_target_to_view(self, target: typing.Optional[DisplayTarget], view: typing.Optional[DisplayView], /) -> bool: ...
    def clone(self) -> typing.Optional[DisplayState]: ...
    @typing.overload
    def connect_target(self, target: typing.Optional[DisplayTarget], /) -> typing.Optional[DisplayPath]: ...
    @typing.overload
    def connect_target(self, target: typing.Optional[DisplayTarget], view: typing.Optional[DisplayView], /) -> typing.Optional[DisplayPath]: ...
    def disconnect_target(self, target: typing.Optional[DisplayTarget], /) -> None: ...
    def get_path_for_target(self, target: typing.Optional[DisplayTarget], /) -> typing.Optional[DisplayPath]: ...
    def get_view_for_target(self, target: typing.Optional[DisplayTarget], /) -> typing.Optional[DisplayView]: ...
    def try_apply(self, options: DisplayStateApplyOptions, /) -> typing.Optional[DisplayStateOperationResult]: ...
    def try_functionalize(self, options: DisplayStateFunctionalizeOptions, /) -> typing.Optional[DisplayStateOperationResult]: ...
    @_property
    def is_read_only(self) -> bool: ...
    @_property
    def is_stale(self) -> bool: ...
    @_property
    def properties(self) -> typing.Optional[winrt.windows.foundation.collections.IMap[_uuid.UUID, winrt.system.Object]]: ...
    @_property
    def targets(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[DisplayTarget]]: ...
    @_property
    def views(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[DisplayView]]: ...

@typing.final
class DisplayStateOperationResult(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> DisplayStateOperationResult: ...
    @_property
    def extended_error_code(self) -> winrt.windows.foundation.HResult: ...
    @_property
    def status(self) -> DisplayStateOperationStatus: ...

@typing.final
class DisplaySurface(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> DisplaySurface: ...

@typing.final
class DisplayTarget(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> DisplayTarget: ...
    def is_equal(self, other_target: typing.Optional[DisplayTarget], /) -> bool: ...
    def is_same(self, other_target: typing.Optional[DisplayTarget], /) -> bool: ...
    def try_get_monitor(self) -> typing.Optional[winrt.windows.devices.display.DisplayMonitor]: ...
    @_property
    def adapter(self) -> typing.Optional[DisplayAdapter]: ...
    @_property
    def adapter_relative_id(self) -> winrt.system.UInt32: ...
    @_property
    def device_interface_path(self) -> str: ...
    @_property
    def is_connected(self) -> bool: ...
    @_property
    def is_stale(self) -> bool: ...
    @_property
    def is_virtual_mode_enabled(self) -> bool: ...
    @_property
    def is_virtual_topology_enabled(self) -> bool: ...
    @_property
    def monitor_persistence(self) -> DisplayTargetPersistence: ...
    @_property
    def properties(self) -> typing.Optional[winrt.windows.foundation.collections.IMapView[_uuid.UUID, winrt.system.Object]]: ...
    @_property
    def stable_monitor_id(self) -> str: ...
    @_property
    def usage_kind(self) -> winrt.windows.devices.display.DisplayMonitorUsageKind: ...

@typing.final
class DisplayTask(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> DisplayTask: ...
    def set_scanout(self, scanout: typing.Optional[DisplayScanout], /) -> None: ...
    def set_signal(self, signal_kind: DisplayTaskSignalKind, fence: typing.Optional[DisplayFence], /) -> None: ...
    def set_wait(self, ready_fence: typing.Optional[DisplayFence], ready_fence_value: winrt.system.UInt64, /) -> None: ...

@typing.final
class DisplayTaskPool(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> DisplayTaskPool: ...
    def create_task(self) -> typing.Optional[DisplayTask]: ...
    def execute_task(self, task: typing.Optional[DisplayTask], /) -> None: ...
    def try_execute_task(self, task: typing.Optional[DisplayTask], /) -> typing.Optional[DisplayTaskResult]: ...

@typing.final
class DisplayTaskResult(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> DisplayTaskResult: ...
    @_property
    def present_id(self) -> winrt.system.UInt64: ...
    @_property
    def present_status(self) -> DisplayPresentStatus: ...
    @_property
    def source_status(self) -> DisplaySourceStatus: ...

@typing.final
class DisplayView(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> DisplayView: ...
    def set_primary_path(self, path: typing.Optional[DisplayPath], /) -> None: ...
    @_property
    def content_resolution(self) -> typing.Optional[typing.Optional[winrt.windows.graphics.SizeInt32]]: ...
    @content_resolution.setter
    def content_resolution(self, value: typing.Optional[typing.Optional[winrt.windows.graphics.SizeInt32]]) -> None: ...
    @_property
    def paths(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[DisplayPath]]: ...
    @_property
    def properties(self) -> typing.Optional[winrt.windows.foundation.collections.IMap[_uuid.UUID, winrt.system.Object]]: ...

@typing.final
class DisplayWireFormat_Static(type):
    def create_with_properties(cls, extra_properties: typing.Iterable[winrt.windows.foundation.collections.IKeyValuePair[_uuid.UUID, winrt.system.Object]], pixel_encoding: DisplayWireFormatPixelEncoding, bits_per_channel: winrt.system.Int32, color_space: DisplayWireFormatColorSpace, eotf: DisplayWireFormatEotf, hdr_metadata: DisplayWireFormatHdrMetadata, /) -> typing.Optional[DisplayWireFormat]: ...

@typing.final
class DisplayWireFormat(winrt.system.Object, metaclass=DisplayWireFormat_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> DisplayWireFormat: ...
    def __new__(cls: typing.Type[DisplayWireFormat], pixel_encoding: DisplayWireFormatPixelEncoding, bits_per_channel: winrt.system.Int32, color_space: DisplayWireFormatColorSpace, eotf: DisplayWireFormatEotf, hdr_metadata: DisplayWireFormatHdrMetadata) -> DisplayWireFormat:...
    @_property
    def bits_per_channel(self) -> winrt.system.Int32: ...
    @_property
    def color_space(self) -> DisplayWireFormatColorSpace: ...
    @_property
    def eotf(self) -> DisplayWireFormatEotf: ...
    @_property
    def hdr_metadata(self) -> DisplayWireFormatHdrMetadata: ...
    @_property
    def pixel_encoding(self) -> DisplayWireFormatPixelEncoding: ...
    @_property
    def properties(self) -> typing.Optional[winrt.windows.foundation.collections.IMapView[_uuid.UUID, winrt.system.Object]]: ...

