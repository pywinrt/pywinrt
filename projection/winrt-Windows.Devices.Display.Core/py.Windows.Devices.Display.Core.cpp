// WARNING: Please don't edit this file. It was generated by Python/WinRT v0.0.0

#include "pybase.h"
#include "py.Windows.Devices.Display.Core.h"


namespace py::cpp::Windows::Devices::Display::Core
{
    // ----- DisplayAdapter class --------------------

    static PyObject* _new_DisplayAdapter(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Display::Core::DisplayAdapter>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Display::Core::DisplayAdapter>::type_name);
        return nullptr;
    }

    static void _dealloc_DisplayAdapter(py::wrapper::Windows::Devices::Display::Core::DisplayAdapter* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* DisplayAdapter_FromId(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Display.Core.DisplayAdapter", L"FromId", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Graphics::DisplayAdapterId>(args, 0);

                return py::convert(winrt::Windows::Devices::Display::Core::DisplayAdapter::FromId(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DisplayAdapter_get_DeviceInterfacePath(py::wrapper::Windows::Devices::Display::Core::DisplayAdapter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Display.Core.DisplayAdapter", L"DeviceInterfacePath"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DeviceInterfacePath());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DisplayAdapter_get_Id(py::wrapper::Windows::Devices::Display::Core::DisplayAdapter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Display.Core.DisplayAdapter", L"Id"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DisplayAdapter_get_PciDeviceId(py::wrapper::Windows::Devices::Display::Core::DisplayAdapter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Display.Core.DisplayAdapter", L"PciDeviceId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PciDeviceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DisplayAdapter_get_PciRevision(py::wrapper::Windows::Devices::Display::Core::DisplayAdapter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Display.Core.DisplayAdapter", L"PciRevision"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PciRevision());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DisplayAdapter_get_PciSubSystemId(py::wrapper::Windows::Devices::Display::Core::DisplayAdapter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Display.Core.DisplayAdapter", L"PciSubSystemId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PciSubSystemId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DisplayAdapter_get_PciVendorId(py::wrapper::Windows::Devices::Display::Core::DisplayAdapter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Display.Core.DisplayAdapter", L"PciVendorId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PciVendorId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DisplayAdapter_get_Properties(py::wrapper::Windows::Devices::Display::Core::DisplayAdapter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Display.Core.DisplayAdapter", L"Properties"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Properties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DisplayAdapter_get_SourceCount(py::wrapper::Windows::Devices::Display::Core::DisplayAdapter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Display.Core.DisplayAdapter", L"SourceCount"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SourceCount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_DisplayAdapter(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Display::Core::DisplayAdapter>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_DisplayAdapter(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Display::Core::DisplayAdapter>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DisplayAdapter[] = {
        { "from_id", reinterpret_cast<PyCFunction>(DisplayAdapter_FromId), METH_VARARGS | METH_STATIC, nullptr },
        { "_assign_array_", _assign_array_DisplayAdapter, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DisplayAdapter), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DisplayAdapter[] = {
        { "device_interface_path", reinterpret_cast<getter>(DisplayAdapter_get_DeviceInterfacePath), nullptr, nullptr, nullptr },
        { "id", reinterpret_cast<getter>(DisplayAdapter_get_Id), nullptr, nullptr, nullptr },
        { "pci_device_id", reinterpret_cast<getter>(DisplayAdapter_get_PciDeviceId), nullptr, nullptr, nullptr },
        { "pci_revision", reinterpret_cast<getter>(DisplayAdapter_get_PciRevision), nullptr, nullptr, nullptr },
        { "pci_sub_system_id", reinterpret_cast<getter>(DisplayAdapter_get_PciSubSystemId), nullptr, nullptr, nullptr },
        { "pci_vendor_id", reinterpret_cast<getter>(DisplayAdapter_get_PciVendorId), nullptr, nullptr, nullptr },
        { "properties", reinterpret_cast<getter>(DisplayAdapter_get_Properties), nullptr, nullptr, nullptr },
        { "source_count", reinterpret_cast<getter>(DisplayAdapter_get_SourceCount), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_DisplayAdapter[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_DisplayAdapter) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_DisplayAdapter) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_DisplayAdapter) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_DisplayAdapter) },
        { },
    };

    static PyType_Spec type_spec_DisplayAdapter =
    {
        "_winrt_windows_devices_display_core.DisplayAdapter",
        sizeof(py::wrapper::Windows::Devices::Display::Core::DisplayAdapter),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DisplayAdapter
    };

    // ----- DisplayDevice class --------------------

    static PyObject* _new_DisplayDevice(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Display::Core::DisplayDevice>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Display::Core::DisplayDevice>::type_name);
        return nullptr;
    }

    static void _dealloc_DisplayDevice(py::wrapper::Windows::Devices::Display::Core::DisplayDevice* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* DisplayDevice_CreatePeriodicFence(py::wrapper::Windows::Devices::Display::Core::DisplayDevice* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Display.Core.DisplayDevice", L"CreatePeriodicFence", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Display::Core::DisplayTarget>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(args, 1);

                return py::convert(self->obj.CreatePeriodicFence(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DisplayDevice_CreatePrimary(py::wrapper::Windows::Devices::Display::Core::DisplayDevice* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Display.Core.DisplayDevice", L"CreatePrimary", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Display::Core::DisplayTarget>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Devices::Display::Core::DisplayPrimaryDescription>(args, 1);

                return py::convert(self->obj.CreatePrimary(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DisplayDevice_CreateScanoutSource(py::wrapper::Windows::Devices::Display::Core::DisplayDevice* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Display.Core.DisplayDevice", L"CreateScanoutSource", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Display::Core::DisplayTarget>(args, 0);

                return py::convert(self->obj.CreateScanoutSource(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DisplayDevice_CreateSimpleScanout(py::wrapper::Windows::Devices::Display::Core::DisplayDevice* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 4)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Display.Core.DisplayDevice", L"CreateSimpleScanout", 4))
            {
                py::set_arg_count_version_error(4);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Display::Core::DisplaySource>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Devices::Display::Core::DisplaySurface>(args, 1);
                auto param2 = py::convert_to<uint32_t>(args, 2);
                auto param3 = py::convert_to<uint32_t>(args, 3);

                return py::convert(self->obj.CreateSimpleScanout(param0, param1, param2, param3));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DisplayDevice_CreateSimpleScanoutWithDirtyRectsAndOptions(py::wrapper::Windows::Devices::Display::Core::DisplayDevice* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 6)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Display.Core.DisplayDevice", L"CreateSimpleScanoutWithDirtyRectsAndOptions", 6))
            {
                py::set_arg_count_version_error(6);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Display::Core::DisplaySource>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Devices::Display::Core::DisplaySurface>(args, 1);
                auto param2 = py::convert_to<uint32_t>(args, 2);
                auto param3 = py::convert_to<uint32_t>(args, 3);
                auto param4 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Graphics::RectInt32>>(args, 4);
                auto param5 = py::convert_to<winrt::Windows::Devices::Display::Core::DisplayScanoutOptions>(args, 5);

                return py::convert(self->obj.CreateSimpleScanoutWithDirtyRectsAndOptions(param0, param1, param2, param3, param4, param5));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DisplayDevice_CreateTaskPool(py::wrapper::Windows::Devices::Display::Core::DisplayDevice* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Display.Core.DisplayDevice", L"CreateTaskPool", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.CreateTaskPool());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DisplayDevice_IsCapabilitySupported(py::wrapper::Windows::Devices::Display::Core::DisplayDevice* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Display.Core.DisplayDevice", L"IsCapabilitySupported", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Display::Core::DisplayDeviceCapability>(args, 0);

                return py::convert(self->obj.IsCapabilitySupported(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DisplayDevice_WaitForVBlank(py::wrapper::Windows::Devices::Display::Core::DisplayDevice* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Display.Core.DisplayDevice", L"WaitForVBlank", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Display::Core::DisplaySource>(args, 0);

                self->obj.WaitForVBlank(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_DisplayDevice(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Display::Core::DisplayDevice>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_DisplayDevice(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Display::Core::DisplayDevice>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DisplayDevice[] = {
        { "create_periodic_fence", reinterpret_cast<PyCFunction>(DisplayDevice_CreatePeriodicFence), METH_VARARGS, nullptr },
        { "create_primary", reinterpret_cast<PyCFunction>(DisplayDevice_CreatePrimary), METH_VARARGS, nullptr },
        { "create_scanout_source", reinterpret_cast<PyCFunction>(DisplayDevice_CreateScanoutSource), METH_VARARGS, nullptr },
        { "create_simple_scanout", reinterpret_cast<PyCFunction>(DisplayDevice_CreateSimpleScanout), METH_VARARGS, nullptr },
        { "create_simple_scanout_with_dirty_rects_and_options", reinterpret_cast<PyCFunction>(DisplayDevice_CreateSimpleScanoutWithDirtyRectsAndOptions), METH_VARARGS, nullptr },
        { "create_task_pool", reinterpret_cast<PyCFunction>(DisplayDevice_CreateTaskPool), METH_VARARGS, nullptr },
        { "is_capability_supported", reinterpret_cast<PyCFunction>(DisplayDevice_IsCapabilitySupported), METH_VARARGS, nullptr },
        { "wait_for_v_blank", reinterpret_cast<PyCFunction>(DisplayDevice_WaitForVBlank), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_DisplayDevice, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DisplayDevice), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DisplayDevice[] = {
        { }
    };

    static PyType_Slot _type_slots_DisplayDevice[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_DisplayDevice) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_DisplayDevice) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_DisplayDevice) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_DisplayDevice) },
        { },
    };

    static PyType_Spec type_spec_DisplayDevice =
    {
        "_winrt_windows_devices_display_core.DisplayDevice",
        sizeof(py::wrapper::Windows::Devices::Display::Core::DisplayDevice),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DisplayDevice
    };

    // ----- DisplayFence class --------------------

    static PyObject* _new_DisplayFence(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Display::Core::DisplayFence>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Display::Core::DisplayFence>::type_name);
        return nullptr;
    }

    static void _dealloc_DisplayFence(py::wrapper::Windows::Devices::Display::Core::DisplayFence* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_DisplayFence(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Display::Core::DisplayFence>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_DisplayFence(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Display::Core::DisplayFence>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DisplayFence[] = {
        { "_assign_array_", _assign_array_DisplayFence, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DisplayFence), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DisplayFence[] = {
        { }
    };

    static PyType_Slot _type_slots_DisplayFence[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_DisplayFence) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_DisplayFence) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_DisplayFence) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_DisplayFence) },
        { },
    };

    static PyType_Spec type_spec_DisplayFence =
    {
        "_winrt_windows_devices_display_core.DisplayFence",
        sizeof(py::wrapper::Windows::Devices::Display::Core::DisplayFence),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DisplayFence
    };

    // ----- DisplayManager class --------------------

    static PyObject* _new_DisplayManager(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Display::Core::DisplayManager>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Display::Core::DisplayManager>::type_name);
        return nullptr;
    }

    static void _dealloc_DisplayManager(py::wrapper::Windows::Devices::Display::Core::DisplayManager* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* DisplayManager_Close(py::wrapper::Windows::Devices::Display::Core::DisplayManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Display.Core.DisplayManager", L"Close", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DisplayManager_Create(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Display.Core.DisplayManager", L"Create", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Display::Core::DisplayManagerOptions>(args, 0);

                return py::convert(winrt::Windows::Devices::Display::Core::DisplayManager::Create(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DisplayManager_CreateDisplayDevice(py::wrapper::Windows::Devices::Display::Core::DisplayManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Display.Core.DisplayManager", L"CreateDisplayDevice", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Display::Core::DisplayAdapter>(args, 0);

                return py::convert(self->obj.CreateDisplayDevice(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DisplayManager_GetCurrentAdapters(py::wrapper::Windows::Devices::Display::Core::DisplayManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Display.Core.DisplayManager", L"GetCurrentAdapters", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetCurrentAdapters());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DisplayManager_GetCurrentTargets(py::wrapper::Windows::Devices::Display::Core::DisplayManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Display.Core.DisplayManager", L"GetCurrentTargets", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetCurrentTargets());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DisplayManager_ReleaseTarget(py::wrapper::Windows::Devices::Display::Core::DisplayManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Display.Core.DisplayManager", L"ReleaseTarget", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Display::Core::DisplayTarget>(args, 0);

                self->obj.ReleaseTarget(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DisplayManager_Start(py::wrapper::Windows::Devices::Display::Core::DisplayManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Display.Core.DisplayManager", L"Start", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Start();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DisplayManager_Stop(py::wrapper::Windows::Devices::Display::Core::DisplayManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Display.Core.DisplayManager", L"Stop", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Stop();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DisplayManager_TryAcquireTarget(py::wrapper::Windows::Devices::Display::Core::DisplayManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Display.Core.DisplayManager", L"TryAcquireTarget", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Display::Core::DisplayTarget>(args, 0);

                return py::convert(self->obj.TryAcquireTarget(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DisplayManager_TryAcquireTargetsAndCreateEmptyState(py::wrapper::Windows::Devices::Display::Core::DisplayManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Display.Core.DisplayManager", L"TryAcquireTargetsAndCreateEmptyState", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Devices::Display::Core::DisplayTarget>>(args, 0);

                return py::convert(self->obj.TryAcquireTargetsAndCreateEmptyState(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DisplayManager_TryAcquireTargetsAndCreateSubstate(py::wrapper::Windows::Devices::Display::Core::DisplayManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Display.Core.DisplayManager", L"TryAcquireTargetsAndCreateSubstate", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Display::Core::DisplayState>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Devices::Display::Core::DisplayTarget>>(args, 1);

                return py::convert(self->obj.TryAcquireTargetsAndCreateSubstate(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DisplayManager_TryAcquireTargetsAndReadCurrentState(py::wrapper::Windows::Devices::Display::Core::DisplayManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Display.Core.DisplayManager", L"TryAcquireTargetsAndReadCurrentState", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Devices::Display::Core::DisplayTarget>>(args, 0);

                return py::convert(self->obj.TryAcquireTargetsAndReadCurrentState(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DisplayManager_TryReadCurrentStateForAllTargets(py::wrapper::Windows::Devices::Display::Core::DisplayManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Display.Core.DisplayManager", L"TryReadCurrentStateForAllTargets", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.TryReadCurrentStateForAllTargets());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DisplayManager_add_Changed(py::wrapper::Windows::Devices::Display::Core::DisplayManager* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Display.Core.DisplayManager", L"Changed"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Display::Core::DisplayManager, winrt::Windows::Devices::Display::Core::DisplayManagerChangedEventArgs>>(arg);

            return py::convert(self->obj.Changed(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DisplayManager_remove_Changed(py::wrapper::Windows::Devices::Display::Core::DisplayManager* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Display.Core.DisplayManager", L"Changed"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Changed(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DisplayManager_add_Disabled(py::wrapper::Windows::Devices::Display::Core::DisplayManager* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Display.Core.DisplayManager", L"Disabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Display::Core::DisplayManager, winrt::Windows::Devices::Display::Core::DisplayManagerDisabledEventArgs>>(arg);

            return py::convert(self->obj.Disabled(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DisplayManager_remove_Disabled(py::wrapper::Windows::Devices::Display::Core::DisplayManager* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Display.Core.DisplayManager", L"Disabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Disabled(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DisplayManager_add_Enabled(py::wrapper::Windows::Devices::Display::Core::DisplayManager* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Display.Core.DisplayManager", L"Enabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Display::Core::DisplayManager, winrt::Windows::Devices::Display::Core::DisplayManagerEnabledEventArgs>>(arg);

            return py::convert(self->obj.Enabled(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DisplayManager_remove_Enabled(py::wrapper::Windows::Devices::Display::Core::DisplayManager* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Display.Core.DisplayManager", L"Enabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Enabled(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DisplayManager_add_PathsFailedOrInvalidated(py::wrapper::Windows::Devices::Display::Core::DisplayManager* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Display.Core.DisplayManager", L"PathsFailedOrInvalidated"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Display::Core::DisplayManager, winrt::Windows::Devices::Display::Core::DisplayManagerPathsFailedOrInvalidatedEventArgs>>(arg);

            return py::convert(self->obj.PathsFailedOrInvalidated(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DisplayManager_remove_PathsFailedOrInvalidated(py::wrapper::Windows::Devices::Display::Core::DisplayManager* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Display.Core.DisplayManager", L"PathsFailedOrInvalidated"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.PathsFailedOrInvalidated(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_DisplayManager(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Display::Core::DisplayManager>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_DisplayManager(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Display::Core::DisplayManager>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_DisplayManager(py::wrapper::Windows::Devices::Display::Core::DisplayManager* self) noexcept
    {
        Py_INCREF(self);
        return reinterpret_cast<PyObject*>(self);
    }

    static PyObject* _exit_DisplayManager(py::wrapper::Windows::Devices::Display::Core::DisplayManager* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DisplayManager[] = {
        { "close", reinterpret_cast<PyCFunction>(DisplayManager_Close), METH_VARARGS, nullptr },
        { "create", reinterpret_cast<PyCFunction>(DisplayManager_Create), METH_VARARGS | METH_STATIC, nullptr },
        { "create_display_device", reinterpret_cast<PyCFunction>(DisplayManager_CreateDisplayDevice), METH_VARARGS, nullptr },
        { "get_current_adapters", reinterpret_cast<PyCFunction>(DisplayManager_GetCurrentAdapters), METH_VARARGS, nullptr },
        { "get_current_targets", reinterpret_cast<PyCFunction>(DisplayManager_GetCurrentTargets), METH_VARARGS, nullptr },
        { "release_target", reinterpret_cast<PyCFunction>(DisplayManager_ReleaseTarget), METH_VARARGS, nullptr },
        { "start", reinterpret_cast<PyCFunction>(DisplayManager_Start), METH_VARARGS, nullptr },
        { "stop", reinterpret_cast<PyCFunction>(DisplayManager_Stop), METH_VARARGS, nullptr },
        { "try_acquire_target", reinterpret_cast<PyCFunction>(DisplayManager_TryAcquireTarget), METH_VARARGS, nullptr },
        { "try_acquire_targets_and_create_empty_state", reinterpret_cast<PyCFunction>(DisplayManager_TryAcquireTargetsAndCreateEmptyState), METH_VARARGS, nullptr },
        { "try_acquire_targets_and_create_substate", reinterpret_cast<PyCFunction>(DisplayManager_TryAcquireTargetsAndCreateSubstate), METH_VARARGS, nullptr },
        { "try_acquire_targets_and_read_current_state", reinterpret_cast<PyCFunction>(DisplayManager_TryAcquireTargetsAndReadCurrentState), METH_VARARGS, nullptr },
        { "try_read_current_state_for_all_targets", reinterpret_cast<PyCFunction>(DisplayManager_TryReadCurrentStateForAllTargets), METH_VARARGS, nullptr },
        { "add_changed", reinterpret_cast<PyCFunction>(DisplayManager_add_Changed), METH_O, nullptr },
        { "remove_changed", reinterpret_cast<PyCFunction>(DisplayManager_remove_Changed), METH_O, nullptr },
        { "add_disabled", reinterpret_cast<PyCFunction>(DisplayManager_add_Disabled), METH_O, nullptr },
        { "remove_disabled", reinterpret_cast<PyCFunction>(DisplayManager_remove_Disabled), METH_O, nullptr },
        { "add_enabled", reinterpret_cast<PyCFunction>(DisplayManager_add_Enabled), METH_O, nullptr },
        { "remove_enabled", reinterpret_cast<PyCFunction>(DisplayManager_remove_Enabled), METH_O, nullptr },
        { "add_paths_failed_or_invalidated", reinterpret_cast<PyCFunction>(DisplayManager_add_PathsFailedOrInvalidated), METH_O, nullptr },
        { "remove_paths_failed_or_invalidated", reinterpret_cast<PyCFunction>(DisplayManager_remove_PathsFailedOrInvalidated), METH_O, nullptr },
        { "_assign_array_", _assign_array_DisplayManager, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DisplayManager), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_DisplayManager), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_DisplayManager), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_DisplayManager[] = {
        { }
    };

    static PyType_Slot _type_slots_DisplayManager[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_DisplayManager) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_DisplayManager) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_DisplayManager) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_DisplayManager) },
        { },
    };

    static PyType_Spec type_spec_DisplayManager =
    {
        "_winrt_windows_devices_display_core.DisplayManager",
        sizeof(py::wrapper::Windows::Devices::Display::Core::DisplayManager),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DisplayManager
    };

    // ----- DisplayManagerChangedEventArgs class --------------------

    static PyObject* _new_DisplayManagerChangedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Display::Core::DisplayManagerChangedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Display::Core::DisplayManagerChangedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_DisplayManagerChangedEventArgs(py::wrapper::Windows::Devices::Display::Core::DisplayManagerChangedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* DisplayManagerChangedEventArgs_GetDeferral(py::wrapper::Windows::Devices::Display::Core::DisplayManagerChangedEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Display.Core.DisplayManagerChangedEventArgs", L"GetDeferral", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DisplayManagerChangedEventArgs_get_Handled(py::wrapper::Windows::Devices::Display::Core::DisplayManagerChangedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Display.Core.DisplayManagerChangedEventArgs", L"Handled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Handled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DisplayManagerChangedEventArgs_put_Handled(py::wrapper::Windows::Devices::Display::Core::DisplayManagerChangedEventArgs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Display.Core.DisplayManagerChangedEventArgs", L"Handled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.Handled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_DisplayManagerChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Display::Core::DisplayManagerChangedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_DisplayManagerChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Display::Core::DisplayManagerChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DisplayManagerChangedEventArgs[] = {
        { "get_deferral", reinterpret_cast<PyCFunction>(DisplayManagerChangedEventArgs_GetDeferral), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_DisplayManagerChangedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DisplayManagerChangedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DisplayManagerChangedEventArgs[] = {
        { "handled", reinterpret_cast<getter>(DisplayManagerChangedEventArgs_get_Handled), reinterpret_cast<setter>(DisplayManagerChangedEventArgs_put_Handled), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_DisplayManagerChangedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_DisplayManagerChangedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_DisplayManagerChangedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_DisplayManagerChangedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_DisplayManagerChangedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_DisplayManagerChangedEventArgs =
    {
        "_winrt_windows_devices_display_core.DisplayManagerChangedEventArgs",
        sizeof(py::wrapper::Windows::Devices::Display::Core::DisplayManagerChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DisplayManagerChangedEventArgs
    };

    // ----- DisplayManagerDisabledEventArgs class --------------------

    static PyObject* _new_DisplayManagerDisabledEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Display::Core::DisplayManagerDisabledEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Display::Core::DisplayManagerDisabledEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_DisplayManagerDisabledEventArgs(py::wrapper::Windows::Devices::Display::Core::DisplayManagerDisabledEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* DisplayManagerDisabledEventArgs_GetDeferral(py::wrapper::Windows::Devices::Display::Core::DisplayManagerDisabledEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Display.Core.DisplayManagerDisabledEventArgs", L"GetDeferral", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DisplayManagerDisabledEventArgs_get_Handled(py::wrapper::Windows::Devices::Display::Core::DisplayManagerDisabledEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Display.Core.DisplayManagerDisabledEventArgs", L"Handled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Handled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DisplayManagerDisabledEventArgs_put_Handled(py::wrapper::Windows::Devices::Display::Core::DisplayManagerDisabledEventArgs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Display.Core.DisplayManagerDisabledEventArgs", L"Handled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.Handled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_DisplayManagerDisabledEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Display::Core::DisplayManagerDisabledEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_DisplayManagerDisabledEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Display::Core::DisplayManagerDisabledEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DisplayManagerDisabledEventArgs[] = {
        { "get_deferral", reinterpret_cast<PyCFunction>(DisplayManagerDisabledEventArgs_GetDeferral), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_DisplayManagerDisabledEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DisplayManagerDisabledEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DisplayManagerDisabledEventArgs[] = {
        { "handled", reinterpret_cast<getter>(DisplayManagerDisabledEventArgs_get_Handled), reinterpret_cast<setter>(DisplayManagerDisabledEventArgs_put_Handled), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_DisplayManagerDisabledEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_DisplayManagerDisabledEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_DisplayManagerDisabledEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_DisplayManagerDisabledEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_DisplayManagerDisabledEventArgs) },
        { },
    };

    static PyType_Spec type_spec_DisplayManagerDisabledEventArgs =
    {
        "_winrt_windows_devices_display_core.DisplayManagerDisabledEventArgs",
        sizeof(py::wrapper::Windows::Devices::Display::Core::DisplayManagerDisabledEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DisplayManagerDisabledEventArgs
    };

    // ----- DisplayManagerEnabledEventArgs class --------------------

    static PyObject* _new_DisplayManagerEnabledEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Display::Core::DisplayManagerEnabledEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Display::Core::DisplayManagerEnabledEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_DisplayManagerEnabledEventArgs(py::wrapper::Windows::Devices::Display::Core::DisplayManagerEnabledEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* DisplayManagerEnabledEventArgs_GetDeferral(py::wrapper::Windows::Devices::Display::Core::DisplayManagerEnabledEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Display.Core.DisplayManagerEnabledEventArgs", L"GetDeferral", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DisplayManagerEnabledEventArgs_get_Handled(py::wrapper::Windows::Devices::Display::Core::DisplayManagerEnabledEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Display.Core.DisplayManagerEnabledEventArgs", L"Handled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Handled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DisplayManagerEnabledEventArgs_put_Handled(py::wrapper::Windows::Devices::Display::Core::DisplayManagerEnabledEventArgs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Display.Core.DisplayManagerEnabledEventArgs", L"Handled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.Handled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_DisplayManagerEnabledEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Display::Core::DisplayManagerEnabledEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_DisplayManagerEnabledEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Display::Core::DisplayManagerEnabledEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DisplayManagerEnabledEventArgs[] = {
        { "get_deferral", reinterpret_cast<PyCFunction>(DisplayManagerEnabledEventArgs_GetDeferral), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_DisplayManagerEnabledEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DisplayManagerEnabledEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DisplayManagerEnabledEventArgs[] = {
        { "handled", reinterpret_cast<getter>(DisplayManagerEnabledEventArgs_get_Handled), reinterpret_cast<setter>(DisplayManagerEnabledEventArgs_put_Handled), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_DisplayManagerEnabledEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_DisplayManagerEnabledEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_DisplayManagerEnabledEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_DisplayManagerEnabledEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_DisplayManagerEnabledEventArgs) },
        { },
    };

    static PyType_Spec type_spec_DisplayManagerEnabledEventArgs =
    {
        "_winrt_windows_devices_display_core.DisplayManagerEnabledEventArgs",
        sizeof(py::wrapper::Windows::Devices::Display::Core::DisplayManagerEnabledEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DisplayManagerEnabledEventArgs
    };

    // ----- DisplayManagerPathsFailedOrInvalidatedEventArgs class --------------------

    static PyObject* _new_DisplayManagerPathsFailedOrInvalidatedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Display::Core::DisplayManagerPathsFailedOrInvalidatedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Display::Core::DisplayManagerPathsFailedOrInvalidatedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_DisplayManagerPathsFailedOrInvalidatedEventArgs(py::wrapper::Windows::Devices::Display::Core::DisplayManagerPathsFailedOrInvalidatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* DisplayManagerPathsFailedOrInvalidatedEventArgs_GetDeferral(py::wrapper::Windows::Devices::Display::Core::DisplayManagerPathsFailedOrInvalidatedEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Display.Core.DisplayManagerPathsFailedOrInvalidatedEventArgs", L"GetDeferral", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DisplayManagerPathsFailedOrInvalidatedEventArgs_get_Handled(py::wrapper::Windows::Devices::Display::Core::DisplayManagerPathsFailedOrInvalidatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Display.Core.DisplayManagerPathsFailedOrInvalidatedEventArgs", L"Handled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Handled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DisplayManagerPathsFailedOrInvalidatedEventArgs_put_Handled(py::wrapper::Windows::Devices::Display::Core::DisplayManagerPathsFailedOrInvalidatedEventArgs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Display.Core.DisplayManagerPathsFailedOrInvalidatedEventArgs", L"Handled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.Handled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_DisplayManagerPathsFailedOrInvalidatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Display::Core::DisplayManagerPathsFailedOrInvalidatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_DisplayManagerPathsFailedOrInvalidatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Display::Core::DisplayManagerPathsFailedOrInvalidatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DisplayManagerPathsFailedOrInvalidatedEventArgs[] = {
        { "get_deferral", reinterpret_cast<PyCFunction>(DisplayManagerPathsFailedOrInvalidatedEventArgs_GetDeferral), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_DisplayManagerPathsFailedOrInvalidatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DisplayManagerPathsFailedOrInvalidatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DisplayManagerPathsFailedOrInvalidatedEventArgs[] = {
        { "handled", reinterpret_cast<getter>(DisplayManagerPathsFailedOrInvalidatedEventArgs_get_Handled), reinterpret_cast<setter>(DisplayManagerPathsFailedOrInvalidatedEventArgs_put_Handled), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_DisplayManagerPathsFailedOrInvalidatedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_DisplayManagerPathsFailedOrInvalidatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_DisplayManagerPathsFailedOrInvalidatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_DisplayManagerPathsFailedOrInvalidatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_DisplayManagerPathsFailedOrInvalidatedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_DisplayManagerPathsFailedOrInvalidatedEventArgs =
    {
        "_winrt_windows_devices_display_core.DisplayManagerPathsFailedOrInvalidatedEventArgs",
        sizeof(py::wrapper::Windows::Devices::Display::Core::DisplayManagerPathsFailedOrInvalidatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DisplayManagerPathsFailedOrInvalidatedEventArgs
    };

    // ----- DisplayManagerResultWithState class --------------------

    static PyObject* _new_DisplayManagerResultWithState(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Display::Core::DisplayManagerResultWithState>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Display::Core::DisplayManagerResultWithState>::type_name);
        return nullptr;
    }

    static void _dealloc_DisplayManagerResultWithState(py::wrapper::Windows::Devices::Display::Core::DisplayManagerResultWithState* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* DisplayManagerResultWithState_get_ErrorCode(py::wrapper::Windows::Devices::Display::Core::DisplayManagerResultWithState* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Display.Core.DisplayManagerResultWithState", L"ErrorCode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ErrorCode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DisplayManagerResultWithState_get_ExtendedErrorCode(py::wrapper::Windows::Devices::Display::Core::DisplayManagerResultWithState* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Display.Core.DisplayManagerResultWithState", L"ExtendedErrorCode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ExtendedErrorCode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DisplayManagerResultWithState_get_State(py::wrapper::Windows::Devices::Display::Core::DisplayManagerResultWithState* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Display.Core.DisplayManagerResultWithState", L"State"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.State());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_DisplayManagerResultWithState(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Display::Core::DisplayManagerResultWithState>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_DisplayManagerResultWithState(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Display::Core::DisplayManagerResultWithState>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DisplayManagerResultWithState[] = {
        { "_assign_array_", _assign_array_DisplayManagerResultWithState, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DisplayManagerResultWithState), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DisplayManagerResultWithState[] = {
        { "error_code", reinterpret_cast<getter>(DisplayManagerResultWithState_get_ErrorCode), nullptr, nullptr, nullptr },
        { "extended_error_code", reinterpret_cast<getter>(DisplayManagerResultWithState_get_ExtendedErrorCode), nullptr, nullptr, nullptr },
        { "state", reinterpret_cast<getter>(DisplayManagerResultWithState_get_State), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_DisplayManagerResultWithState[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_DisplayManagerResultWithState) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_DisplayManagerResultWithState) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_DisplayManagerResultWithState) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_DisplayManagerResultWithState) },
        { },
    };

    static PyType_Spec type_spec_DisplayManagerResultWithState =
    {
        "_winrt_windows_devices_display_core.DisplayManagerResultWithState",
        sizeof(py::wrapper::Windows::Devices::Display::Core::DisplayManagerResultWithState),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DisplayManagerResultWithState
    };

    // ----- DisplayModeInfo class --------------------

    static PyObject* _new_DisplayModeInfo(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Display::Core::DisplayModeInfo>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Display::Core::DisplayModeInfo>::type_name);
        return nullptr;
    }

    static void _dealloc_DisplayModeInfo(py::wrapper::Windows::Devices::Display::Core::DisplayModeInfo* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* DisplayModeInfo_GetWireFormatSupportedBitsPerChannel(py::wrapper::Windows::Devices::Display::Core::DisplayModeInfo* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Display.Core.DisplayModeInfo", L"GetWireFormatSupportedBitsPerChannel", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Display::Core::DisplayWireFormatPixelEncoding>(args, 0);

                return py::convert(self->obj.GetWireFormatSupportedBitsPerChannel(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DisplayModeInfo_IsWireFormatSupported(py::wrapper::Windows::Devices::Display::Core::DisplayModeInfo* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Display.Core.DisplayModeInfo", L"IsWireFormatSupported", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Display::Core::DisplayWireFormat>(args, 0);

                return py::convert(self->obj.IsWireFormatSupported(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DisplayModeInfo_get_IsInterlaced(py::wrapper::Windows::Devices::Display::Core::DisplayModeInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Display.Core.DisplayModeInfo", L"IsInterlaced"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsInterlaced());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DisplayModeInfo_get_IsStereo(py::wrapper::Windows::Devices::Display::Core::DisplayModeInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Display.Core.DisplayModeInfo", L"IsStereo"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsStereo());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DisplayModeInfo_get_PresentationRate(py::wrapper::Windows::Devices::Display::Core::DisplayModeInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Display.Core.DisplayModeInfo", L"PresentationRate"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PresentationRate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DisplayModeInfo_get_Properties(py::wrapper::Windows::Devices::Display::Core::DisplayModeInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Display.Core.DisplayModeInfo", L"Properties"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Properties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DisplayModeInfo_get_SourcePixelFormat(py::wrapper::Windows::Devices::Display::Core::DisplayModeInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Display.Core.DisplayModeInfo", L"SourcePixelFormat"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SourcePixelFormat());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DisplayModeInfo_get_SourceResolution(py::wrapper::Windows::Devices::Display::Core::DisplayModeInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Display.Core.DisplayModeInfo", L"SourceResolution"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SourceResolution());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DisplayModeInfo_get_TargetResolution(py::wrapper::Windows::Devices::Display::Core::DisplayModeInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Display.Core.DisplayModeInfo", L"TargetResolution"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TargetResolution());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DisplayModeInfo_get_PhysicalPresentationRate(py::wrapper::Windows::Devices::Display::Core::DisplayModeInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Display.Core.DisplayModeInfo", L"PhysicalPresentationRate"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PhysicalPresentationRate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_DisplayModeInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Display::Core::DisplayModeInfo>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_DisplayModeInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Display::Core::DisplayModeInfo>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DisplayModeInfo[] = {
        { "get_wire_format_supported_bits_per_channel", reinterpret_cast<PyCFunction>(DisplayModeInfo_GetWireFormatSupportedBitsPerChannel), METH_VARARGS, nullptr },
        { "is_wire_format_supported", reinterpret_cast<PyCFunction>(DisplayModeInfo_IsWireFormatSupported), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_DisplayModeInfo, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DisplayModeInfo), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DisplayModeInfo[] = {
        { "is_interlaced", reinterpret_cast<getter>(DisplayModeInfo_get_IsInterlaced), nullptr, nullptr, nullptr },
        { "is_stereo", reinterpret_cast<getter>(DisplayModeInfo_get_IsStereo), nullptr, nullptr, nullptr },
        { "presentation_rate", reinterpret_cast<getter>(DisplayModeInfo_get_PresentationRate), nullptr, nullptr, nullptr },
        { "properties", reinterpret_cast<getter>(DisplayModeInfo_get_Properties), nullptr, nullptr, nullptr },
        { "source_pixel_format", reinterpret_cast<getter>(DisplayModeInfo_get_SourcePixelFormat), nullptr, nullptr, nullptr },
        { "source_resolution", reinterpret_cast<getter>(DisplayModeInfo_get_SourceResolution), nullptr, nullptr, nullptr },
        { "target_resolution", reinterpret_cast<getter>(DisplayModeInfo_get_TargetResolution), nullptr, nullptr, nullptr },
        { "physical_presentation_rate", reinterpret_cast<getter>(DisplayModeInfo_get_PhysicalPresentationRate), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_DisplayModeInfo[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_DisplayModeInfo) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_DisplayModeInfo) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_DisplayModeInfo) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_DisplayModeInfo) },
        { },
    };

    static PyType_Spec type_spec_DisplayModeInfo =
    {
        "_winrt_windows_devices_display_core.DisplayModeInfo",
        sizeof(py::wrapper::Windows::Devices::Display::Core::DisplayModeInfo),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DisplayModeInfo
    };

    // ----- DisplayPath class --------------------

    static PyObject* _new_DisplayPath(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Display::Core::DisplayPath>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Display::Core::DisplayPath>::type_name);
        return nullptr;
    }

    static void _dealloc_DisplayPath(py::wrapper::Windows::Devices::Display::Core::DisplayPath* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* DisplayPath_ApplyPropertiesFromMode(py::wrapper::Windows::Devices::Display::Core::DisplayPath* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Display.Core.DisplayPath", L"ApplyPropertiesFromMode", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Display::Core::DisplayModeInfo>(args, 0);

                self->obj.ApplyPropertiesFromMode(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DisplayPath_FindModes(py::wrapper::Windows::Devices::Display::Core::DisplayPath* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Display.Core.DisplayPath", L"FindModes", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Display::Core::DisplayModeQueryOptions>(args, 0);

                return py::convert(self->obj.FindModes(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DisplayPath_get_WireFormat(py::wrapper::Windows::Devices::Display::Core::DisplayPath* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Display.Core.DisplayPath", L"WireFormat"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.WireFormat());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DisplayPath_put_WireFormat(py::wrapper::Windows::Devices::Display::Core::DisplayPath* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Display.Core.DisplayPath", L"WireFormat"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Devices::Display::Core::DisplayWireFormat>(arg);

            self->obj.WireFormat(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DisplayPath_get_TargetResolution(py::wrapper::Windows::Devices::Display::Core::DisplayPath* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Display.Core.DisplayPath", L"TargetResolution"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TargetResolution());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DisplayPath_put_TargetResolution(py::wrapper::Windows::Devices::Display::Core::DisplayPath* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Display.Core.DisplayPath", L"TargetResolution"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Graphics::SizeInt32>>(arg);

            self->obj.TargetResolution(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DisplayPath_get_SourceResolution(py::wrapper::Windows::Devices::Display::Core::DisplayPath* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Display.Core.DisplayPath", L"SourceResolution"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SourceResolution());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DisplayPath_put_SourceResolution(py::wrapper::Windows::Devices::Display::Core::DisplayPath* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Display.Core.DisplayPath", L"SourceResolution"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Graphics::SizeInt32>>(arg);

            self->obj.SourceResolution(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DisplayPath_get_SourcePixelFormat(py::wrapper::Windows::Devices::Display::Core::DisplayPath* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Display.Core.DisplayPath", L"SourcePixelFormat"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SourcePixelFormat());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DisplayPath_put_SourcePixelFormat(py::wrapper::Windows::Devices::Display::Core::DisplayPath* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Display.Core.DisplayPath", L"SourcePixelFormat"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Graphics::DirectX::DirectXPixelFormat>(arg);

            self->obj.SourcePixelFormat(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DisplayPath_get_Scaling(py::wrapper::Windows::Devices::Display::Core::DisplayPath* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Display.Core.DisplayPath", L"Scaling"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Scaling());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DisplayPath_put_Scaling(py::wrapper::Windows::Devices::Display::Core::DisplayPath* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Display.Core.DisplayPath", L"Scaling"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Devices::Display::Core::DisplayPathScaling>(arg);

            self->obj.Scaling(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DisplayPath_get_Rotation(py::wrapper::Windows::Devices::Display::Core::DisplayPath* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Display.Core.DisplayPath", L"Rotation"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Rotation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DisplayPath_put_Rotation(py::wrapper::Windows::Devices::Display::Core::DisplayPath* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Display.Core.DisplayPath", L"Rotation"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Devices::Display::Core::DisplayRotation>(arg);

            self->obj.Rotation(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DisplayPath_get_PresentationRate(py::wrapper::Windows::Devices::Display::Core::DisplayPath* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Display.Core.DisplayPath", L"PresentationRate"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PresentationRate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DisplayPath_put_PresentationRate(py::wrapper::Windows::Devices::Display::Core::DisplayPath* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Display.Core.DisplayPath", L"PresentationRate"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Devices::Display::Core::DisplayPresentationRate>>(arg);

            self->obj.PresentationRate(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DisplayPath_get_IsStereo(py::wrapper::Windows::Devices::Display::Core::DisplayPath* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Display.Core.DisplayPath", L"IsStereo"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsStereo());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DisplayPath_put_IsStereo(py::wrapper::Windows::Devices::Display::Core::DisplayPath* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Display.Core.DisplayPath", L"IsStereo"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsStereo(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DisplayPath_get_IsInterlaced(py::wrapper::Windows::Devices::Display::Core::DisplayPath* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Display.Core.DisplayPath", L"IsInterlaced"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsInterlaced());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DisplayPath_put_IsInterlaced(py::wrapper::Windows::Devices::Display::Core::DisplayPath* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Display.Core.DisplayPath", L"IsInterlaced"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<bool>>(arg);

            self->obj.IsInterlaced(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DisplayPath_get_Properties(py::wrapper::Windows::Devices::Display::Core::DisplayPath* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Display.Core.DisplayPath", L"Properties"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Properties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DisplayPath_get_Status(py::wrapper::Windows::Devices::Display::Core::DisplayPath* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Display.Core.DisplayPath", L"Status"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DisplayPath_get_Target(py::wrapper::Windows::Devices::Display::Core::DisplayPath* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Display.Core.DisplayPath", L"Target"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Target());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DisplayPath_get_View(py::wrapper::Windows::Devices::Display::Core::DisplayPath* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Display.Core.DisplayPath", L"View"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.View());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DisplayPath_get_PhysicalPresentationRate(py::wrapper::Windows::Devices::Display::Core::DisplayPath* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Display.Core.DisplayPath", L"PhysicalPresentationRate"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PhysicalPresentationRate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DisplayPath_put_PhysicalPresentationRate(py::wrapper::Windows::Devices::Display::Core::DisplayPath* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Display.Core.DisplayPath", L"PhysicalPresentationRate"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Devices::Display::Core::DisplayPresentationRate>>(arg);

            self->obj.PhysicalPresentationRate(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_DisplayPath(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Display::Core::DisplayPath>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_DisplayPath(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Display::Core::DisplayPath>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DisplayPath[] = {
        { "apply_properties_from_mode", reinterpret_cast<PyCFunction>(DisplayPath_ApplyPropertiesFromMode), METH_VARARGS, nullptr },
        { "find_modes", reinterpret_cast<PyCFunction>(DisplayPath_FindModes), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_DisplayPath, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DisplayPath), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DisplayPath[] = {
        { "wire_format", reinterpret_cast<getter>(DisplayPath_get_WireFormat), reinterpret_cast<setter>(DisplayPath_put_WireFormat), nullptr, nullptr },
        { "target_resolution", reinterpret_cast<getter>(DisplayPath_get_TargetResolution), reinterpret_cast<setter>(DisplayPath_put_TargetResolution), nullptr, nullptr },
        { "source_resolution", reinterpret_cast<getter>(DisplayPath_get_SourceResolution), reinterpret_cast<setter>(DisplayPath_put_SourceResolution), nullptr, nullptr },
        { "source_pixel_format", reinterpret_cast<getter>(DisplayPath_get_SourcePixelFormat), reinterpret_cast<setter>(DisplayPath_put_SourcePixelFormat), nullptr, nullptr },
        { "scaling", reinterpret_cast<getter>(DisplayPath_get_Scaling), reinterpret_cast<setter>(DisplayPath_put_Scaling), nullptr, nullptr },
        { "rotation", reinterpret_cast<getter>(DisplayPath_get_Rotation), reinterpret_cast<setter>(DisplayPath_put_Rotation), nullptr, nullptr },
        { "presentation_rate", reinterpret_cast<getter>(DisplayPath_get_PresentationRate), reinterpret_cast<setter>(DisplayPath_put_PresentationRate), nullptr, nullptr },
        { "is_stereo", reinterpret_cast<getter>(DisplayPath_get_IsStereo), reinterpret_cast<setter>(DisplayPath_put_IsStereo), nullptr, nullptr },
        { "is_interlaced", reinterpret_cast<getter>(DisplayPath_get_IsInterlaced), reinterpret_cast<setter>(DisplayPath_put_IsInterlaced), nullptr, nullptr },
        { "properties", reinterpret_cast<getter>(DisplayPath_get_Properties), nullptr, nullptr, nullptr },
        { "status", reinterpret_cast<getter>(DisplayPath_get_Status), nullptr, nullptr, nullptr },
        { "target", reinterpret_cast<getter>(DisplayPath_get_Target), nullptr, nullptr, nullptr },
        { "view", reinterpret_cast<getter>(DisplayPath_get_View), nullptr, nullptr, nullptr },
        { "physical_presentation_rate", reinterpret_cast<getter>(DisplayPath_get_PhysicalPresentationRate), reinterpret_cast<setter>(DisplayPath_put_PhysicalPresentationRate), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_DisplayPath[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_DisplayPath) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_DisplayPath) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_DisplayPath) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_DisplayPath) },
        { },
    };

    static PyType_Spec type_spec_DisplayPath =
    {
        "_winrt_windows_devices_display_core.DisplayPath",
        sizeof(py::wrapper::Windows::Devices::Display::Core::DisplayPath),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DisplayPath
    };

    // ----- DisplayPrimaryDescription class --------------------

    static PyObject* _new_DisplayPrimaryDescription(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 6)
        {
            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Graphics::DirectX::DirectXPixelFormat>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Graphics::DirectX::DirectXColorSpace>(args, 3);
                auto param4 = py::convert_to<bool>(args, 4);
                auto param5 = py::convert_to<winrt::Windows::Graphics::DirectX::Direct3D11::Direct3DMultisampleDescription>(args, 5);

                winrt::Windows::Devices::Display::Core::DisplayPrimaryDescription instance{ param0, param1, param2, param3, param4, param5 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_DisplayPrimaryDescription(py::wrapper::Windows::Devices::Display::Core::DisplayPrimaryDescription* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* DisplayPrimaryDescription_CreateWithProperties(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 7)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Display.Core.DisplayPrimaryDescription", L"CreateWithProperties", 7))
            {
                py::set_arg_count_version_error(7);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Foundation::Collections::IKeyValuePair<winrt::guid, winrt::Windows::Foundation::IInspectable>>>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);
                auto param2 = py::convert_to<uint32_t>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Graphics::DirectX::DirectXPixelFormat>(args, 3);
                auto param4 = py::convert_to<winrt::Windows::Graphics::DirectX::DirectXColorSpace>(args, 4);
                auto param5 = py::convert_to<bool>(args, 5);
                auto param6 = py::convert_to<winrt::Windows::Graphics::DirectX::Direct3D11::Direct3DMultisampleDescription>(args, 6);

                return py::convert(winrt::Windows::Devices::Display::Core::DisplayPrimaryDescription::CreateWithProperties(param0, param1, param2, param3, param4, param5, param6));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DisplayPrimaryDescription_get_ColorSpace(py::wrapper::Windows::Devices::Display::Core::DisplayPrimaryDescription* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Display.Core.DisplayPrimaryDescription", L"ColorSpace"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ColorSpace());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DisplayPrimaryDescription_get_Format(py::wrapper::Windows::Devices::Display::Core::DisplayPrimaryDescription* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Display.Core.DisplayPrimaryDescription", L"Format"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Format());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DisplayPrimaryDescription_get_Height(py::wrapper::Windows::Devices::Display::Core::DisplayPrimaryDescription* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Display.Core.DisplayPrimaryDescription", L"Height"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Height());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DisplayPrimaryDescription_get_IsStereo(py::wrapper::Windows::Devices::Display::Core::DisplayPrimaryDescription* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Display.Core.DisplayPrimaryDescription", L"IsStereo"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsStereo());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DisplayPrimaryDescription_get_MultisampleDescription(py::wrapper::Windows::Devices::Display::Core::DisplayPrimaryDescription* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Display.Core.DisplayPrimaryDescription", L"MultisampleDescription"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MultisampleDescription());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DisplayPrimaryDescription_get_Properties(py::wrapper::Windows::Devices::Display::Core::DisplayPrimaryDescription* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Display.Core.DisplayPrimaryDescription", L"Properties"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Properties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DisplayPrimaryDescription_get_Width(py::wrapper::Windows::Devices::Display::Core::DisplayPrimaryDescription* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Display.Core.DisplayPrimaryDescription", L"Width"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Width());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_DisplayPrimaryDescription(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Display::Core::DisplayPrimaryDescription>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_DisplayPrimaryDescription(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Display::Core::DisplayPrimaryDescription>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DisplayPrimaryDescription[] = {
        { "create_with_properties", reinterpret_cast<PyCFunction>(DisplayPrimaryDescription_CreateWithProperties), METH_VARARGS | METH_STATIC, nullptr },
        { "_assign_array_", _assign_array_DisplayPrimaryDescription, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DisplayPrimaryDescription), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DisplayPrimaryDescription[] = {
        { "color_space", reinterpret_cast<getter>(DisplayPrimaryDescription_get_ColorSpace), nullptr, nullptr, nullptr },
        { "format", reinterpret_cast<getter>(DisplayPrimaryDescription_get_Format), nullptr, nullptr, nullptr },
        { "height", reinterpret_cast<getter>(DisplayPrimaryDescription_get_Height), nullptr, nullptr, nullptr },
        { "is_stereo", reinterpret_cast<getter>(DisplayPrimaryDescription_get_IsStereo), nullptr, nullptr, nullptr },
        { "multisample_description", reinterpret_cast<getter>(DisplayPrimaryDescription_get_MultisampleDescription), nullptr, nullptr, nullptr },
        { "properties", reinterpret_cast<getter>(DisplayPrimaryDescription_get_Properties), nullptr, nullptr, nullptr },
        { "width", reinterpret_cast<getter>(DisplayPrimaryDescription_get_Width), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_DisplayPrimaryDescription[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_DisplayPrimaryDescription) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_DisplayPrimaryDescription) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_DisplayPrimaryDescription) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_DisplayPrimaryDescription) },
        { },
    };

    static PyType_Spec type_spec_DisplayPrimaryDescription =
    {
        "_winrt_windows_devices_display_core.DisplayPrimaryDescription",
        sizeof(py::wrapper::Windows::Devices::Display::Core::DisplayPrimaryDescription),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DisplayPrimaryDescription
    };

    // ----- DisplayScanout class --------------------

    static PyObject* _new_DisplayScanout(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Display::Core::DisplayScanout>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Display::Core::DisplayScanout>::type_name);
        return nullptr;
    }

    static void _dealloc_DisplayScanout(py::wrapper::Windows::Devices::Display::Core::DisplayScanout* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_DisplayScanout(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Display::Core::DisplayScanout>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_DisplayScanout(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Display::Core::DisplayScanout>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DisplayScanout[] = {
        { "_assign_array_", _assign_array_DisplayScanout, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DisplayScanout), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DisplayScanout[] = {
        { }
    };

    static PyType_Slot _type_slots_DisplayScanout[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_DisplayScanout) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_DisplayScanout) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_DisplayScanout) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_DisplayScanout) },
        { },
    };

    static PyType_Spec type_spec_DisplayScanout =
    {
        "_winrt_windows_devices_display_core.DisplayScanout",
        sizeof(py::wrapper::Windows::Devices::Display::Core::DisplayScanout),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DisplayScanout
    };

    // ----- DisplaySource class --------------------

    static PyObject* _new_DisplaySource(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Display::Core::DisplaySource>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Display::Core::DisplaySource>::type_name);
        return nullptr;
    }

    static void _dealloc_DisplaySource(py::wrapper::Windows::Devices::Display::Core::DisplaySource* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* DisplaySource_GetMetadata(py::wrapper::Windows::Devices::Display::Core::DisplaySource* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Display.Core.DisplaySource", L"GetMetadata", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::guid>(args, 0);

                return py::convert(self->obj.GetMetadata(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DisplaySource_get_AdapterId(py::wrapper::Windows::Devices::Display::Core::DisplaySource* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Display.Core.DisplaySource", L"AdapterId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AdapterId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DisplaySource_get_SourceId(py::wrapper::Windows::Devices::Display::Core::DisplaySource* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Display.Core.DisplaySource", L"SourceId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SourceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DisplaySource_get_Status(py::wrapper::Windows::Devices::Display::Core::DisplaySource* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Display.Core.DisplaySource", L"Status"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DisplaySource_add_StatusChanged(py::wrapper::Windows::Devices::Display::Core::DisplaySource* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Display.Core.DisplaySource", L"StatusChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Display::Core::DisplaySource, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.StatusChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DisplaySource_remove_StatusChanged(py::wrapper::Windows::Devices::Display::Core::DisplaySource* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Display.Core.DisplaySource", L"StatusChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.StatusChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_DisplaySource(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Display::Core::DisplaySource>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_DisplaySource(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Display::Core::DisplaySource>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DisplaySource[] = {
        { "get_metadata", reinterpret_cast<PyCFunction>(DisplaySource_GetMetadata), METH_VARARGS, nullptr },
        { "add_status_changed", reinterpret_cast<PyCFunction>(DisplaySource_add_StatusChanged), METH_O, nullptr },
        { "remove_status_changed", reinterpret_cast<PyCFunction>(DisplaySource_remove_StatusChanged), METH_O, nullptr },
        { "_assign_array_", _assign_array_DisplaySource, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DisplaySource), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DisplaySource[] = {
        { "adapter_id", reinterpret_cast<getter>(DisplaySource_get_AdapterId), nullptr, nullptr, nullptr },
        { "source_id", reinterpret_cast<getter>(DisplaySource_get_SourceId), nullptr, nullptr, nullptr },
        { "status", reinterpret_cast<getter>(DisplaySource_get_Status), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_DisplaySource[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_DisplaySource) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_DisplaySource) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_DisplaySource) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_DisplaySource) },
        { },
    };

    static PyType_Spec type_spec_DisplaySource =
    {
        "_winrt_windows_devices_display_core.DisplaySource",
        sizeof(py::wrapper::Windows::Devices::Display::Core::DisplaySource),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DisplaySource
    };

    // ----- DisplayState class --------------------

    static PyObject* _new_DisplayState(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Display::Core::DisplayState>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Display::Core::DisplayState>::type_name);
        return nullptr;
    }

    static void _dealloc_DisplayState(py::wrapper::Windows::Devices::Display::Core::DisplayState* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* DisplayState_CanConnectTargetToView(py::wrapper::Windows::Devices::Display::Core::DisplayState* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Display.Core.DisplayState", L"CanConnectTargetToView", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Display::Core::DisplayTarget>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Devices::Display::Core::DisplayView>(args, 1);

                return py::convert(self->obj.CanConnectTargetToView(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DisplayState_Clone(py::wrapper::Windows::Devices::Display::Core::DisplayState* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Display.Core.DisplayState", L"Clone", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.Clone());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DisplayState_ConnectTarget(py::wrapper::Windows::Devices::Display::Core::DisplayState* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Display.Core.DisplayState", L"ConnectTarget", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Display::Core::DisplayTarget>(args, 0);

                return py::convert(self->obj.ConnectTarget(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Display.Core.DisplayState", L"ConnectTarget", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Display::Core::DisplayTarget>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Devices::Display::Core::DisplayView>(args, 1);

                return py::convert(self->obj.ConnectTarget(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DisplayState_DisconnectTarget(py::wrapper::Windows::Devices::Display::Core::DisplayState* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Display.Core.DisplayState", L"DisconnectTarget", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Display::Core::DisplayTarget>(args, 0);

                self->obj.DisconnectTarget(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DisplayState_GetPathForTarget(py::wrapper::Windows::Devices::Display::Core::DisplayState* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Display.Core.DisplayState", L"GetPathForTarget", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Display::Core::DisplayTarget>(args, 0);

                return py::convert(self->obj.GetPathForTarget(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DisplayState_GetViewForTarget(py::wrapper::Windows::Devices::Display::Core::DisplayState* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Display.Core.DisplayState", L"GetViewForTarget", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Display::Core::DisplayTarget>(args, 0);

                return py::convert(self->obj.GetViewForTarget(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DisplayState_TryApply(py::wrapper::Windows::Devices::Display::Core::DisplayState* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Display.Core.DisplayState", L"TryApply", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Display::Core::DisplayStateApplyOptions>(args, 0);

                return py::convert(self->obj.TryApply(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DisplayState_TryFunctionalize(py::wrapper::Windows::Devices::Display::Core::DisplayState* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Display.Core.DisplayState", L"TryFunctionalize", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Display::Core::DisplayStateFunctionalizeOptions>(args, 0);

                return py::convert(self->obj.TryFunctionalize(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DisplayState_get_IsReadOnly(py::wrapper::Windows::Devices::Display::Core::DisplayState* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Display.Core.DisplayState", L"IsReadOnly"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsReadOnly());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DisplayState_get_IsStale(py::wrapper::Windows::Devices::Display::Core::DisplayState* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Display.Core.DisplayState", L"IsStale"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsStale());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DisplayState_get_Properties(py::wrapper::Windows::Devices::Display::Core::DisplayState* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Display.Core.DisplayState", L"Properties"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Properties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DisplayState_get_Targets(py::wrapper::Windows::Devices::Display::Core::DisplayState* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Display.Core.DisplayState", L"Targets"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Targets());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DisplayState_get_Views(py::wrapper::Windows::Devices::Display::Core::DisplayState* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Display.Core.DisplayState", L"Views"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Views());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_DisplayState(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Display::Core::DisplayState>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_DisplayState(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Display::Core::DisplayState>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DisplayState[] = {
        { "can_connect_target_to_view", reinterpret_cast<PyCFunction>(DisplayState_CanConnectTargetToView), METH_VARARGS, nullptr },
        { "clone", reinterpret_cast<PyCFunction>(DisplayState_Clone), METH_VARARGS, nullptr },
        { "connect_target", reinterpret_cast<PyCFunction>(DisplayState_ConnectTarget), METH_VARARGS, nullptr },
        { "disconnect_target", reinterpret_cast<PyCFunction>(DisplayState_DisconnectTarget), METH_VARARGS, nullptr },
        { "get_path_for_target", reinterpret_cast<PyCFunction>(DisplayState_GetPathForTarget), METH_VARARGS, nullptr },
        { "get_view_for_target", reinterpret_cast<PyCFunction>(DisplayState_GetViewForTarget), METH_VARARGS, nullptr },
        { "try_apply", reinterpret_cast<PyCFunction>(DisplayState_TryApply), METH_VARARGS, nullptr },
        { "try_functionalize", reinterpret_cast<PyCFunction>(DisplayState_TryFunctionalize), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_DisplayState, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DisplayState), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DisplayState[] = {
        { "is_read_only", reinterpret_cast<getter>(DisplayState_get_IsReadOnly), nullptr, nullptr, nullptr },
        { "is_stale", reinterpret_cast<getter>(DisplayState_get_IsStale), nullptr, nullptr, nullptr },
        { "properties", reinterpret_cast<getter>(DisplayState_get_Properties), nullptr, nullptr, nullptr },
        { "targets", reinterpret_cast<getter>(DisplayState_get_Targets), nullptr, nullptr, nullptr },
        { "views", reinterpret_cast<getter>(DisplayState_get_Views), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_DisplayState[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_DisplayState) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_DisplayState) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_DisplayState) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_DisplayState) },
        { },
    };

    static PyType_Spec type_spec_DisplayState =
    {
        "_winrt_windows_devices_display_core.DisplayState",
        sizeof(py::wrapper::Windows::Devices::Display::Core::DisplayState),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DisplayState
    };

    // ----- DisplayStateOperationResult class --------------------

    static PyObject* _new_DisplayStateOperationResult(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Display::Core::DisplayStateOperationResult>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Display::Core::DisplayStateOperationResult>::type_name);
        return nullptr;
    }

    static void _dealloc_DisplayStateOperationResult(py::wrapper::Windows::Devices::Display::Core::DisplayStateOperationResult* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* DisplayStateOperationResult_get_ExtendedErrorCode(py::wrapper::Windows::Devices::Display::Core::DisplayStateOperationResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Display.Core.DisplayStateOperationResult", L"ExtendedErrorCode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ExtendedErrorCode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DisplayStateOperationResult_get_Status(py::wrapper::Windows::Devices::Display::Core::DisplayStateOperationResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Display.Core.DisplayStateOperationResult", L"Status"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_DisplayStateOperationResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Display::Core::DisplayStateOperationResult>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_DisplayStateOperationResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Display::Core::DisplayStateOperationResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DisplayStateOperationResult[] = {
        { "_assign_array_", _assign_array_DisplayStateOperationResult, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DisplayStateOperationResult), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DisplayStateOperationResult[] = {
        { "extended_error_code", reinterpret_cast<getter>(DisplayStateOperationResult_get_ExtendedErrorCode), nullptr, nullptr, nullptr },
        { "status", reinterpret_cast<getter>(DisplayStateOperationResult_get_Status), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_DisplayStateOperationResult[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_DisplayStateOperationResult) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_DisplayStateOperationResult) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_DisplayStateOperationResult) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_DisplayStateOperationResult) },
        { },
    };

    static PyType_Spec type_spec_DisplayStateOperationResult =
    {
        "_winrt_windows_devices_display_core.DisplayStateOperationResult",
        sizeof(py::wrapper::Windows::Devices::Display::Core::DisplayStateOperationResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DisplayStateOperationResult
    };

    // ----- DisplaySurface class --------------------

    static PyObject* _new_DisplaySurface(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Display::Core::DisplaySurface>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Display::Core::DisplaySurface>::type_name);
        return nullptr;
    }

    static void _dealloc_DisplaySurface(py::wrapper::Windows::Devices::Display::Core::DisplaySurface* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_DisplaySurface(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Display::Core::DisplaySurface>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_DisplaySurface(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Display::Core::DisplaySurface>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DisplaySurface[] = {
        { "_assign_array_", _assign_array_DisplaySurface, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DisplaySurface), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DisplaySurface[] = {
        { }
    };

    static PyType_Slot _type_slots_DisplaySurface[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_DisplaySurface) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_DisplaySurface) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_DisplaySurface) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_DisplaySurface) },
        { },
    };

    static PyType_Spec type_spec_DisplaySurface =
    {
        "_winrt_windows_devices_display_core.DisplaySurface",
        sizeof(py::wrapper::Windows::Devices::Display::Core::DisplaySurface),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DisplaySurface
    };

    // ----- DisplayTarget class --------------------

    static PyObject* _new_DisplayTarget(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Display::Core::DisplayTarget>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Display::Core::DisplayTarget>::type_name);
        return nullptr;
    }

    static void _dealloc_DisplayTarget(py::wrapper::Windows::Devices::Display::Core::DisplayTarget* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* DisplayTarget_IsEqual(py::wrapper::Windows::Devices::Display::Core::DisplayTarget* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Display.Core.DisplayTarget", L"IsEqual", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Display::Core::DisplayTarget>(args, 0);

                return py::convert(self->obj.IsEqual(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DisplayTarget_IsSame(py::wrapper::Windows::Devices::Display::Core::DisplayTarget* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Display.Core.DisplayTarget", L"IsSame", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Display::Core::DisplayTarget>(args, 0);

                return py::convert(self->obj.IsSame(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DisplayTarget_TryGetMonitor(py::wrapper::Windows::Devices::Display::Core::DisplayTarget* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Display.Core.DisplayTarget", L"TryGetMonitor", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.TryGetMonitor());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DisplayTarget_get_Adapter(py::wrapper::Windows::Devices::Display::Core::DisplayTarget* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Display.Core.DisplayTarget", L"Adapter"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Adapter());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DisplayTarget_get_AdapterRelativeId(py::wrapper::Windows::Devices::Display::Core::DisplayTarget* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Display.Core.DisplayTarget", L"AdapterRelativeId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AdapterRelativeId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DisplayTarget_get_DeviceInterfacePath(py::wrapper::Windows::Devices::Display::Core::DisplayTarget* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Display.Core.DisplayTarget", L"DeviceInterfacePath"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DeviceInterfacePath());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DisplayTarget_get_IsConnected(py::wrapper::Windows::Devices::Display::Core::DisplayTarget* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Display.Core.DisplayTarget", L"IsConnected"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsConnected());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DisplayTarget_get_IsStale(py::wrapper::Windows::Devices::Display::Core::DisplayTarget* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Display.Core.DisplayTarget", L"IsStale"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsStale());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DisplayTarget_get_IsVirtualModeEnabled(py::wrapper::Windows::Devices::Display::Core::DisplayTarget* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Display.Core.DisplayTarget", L"IsVirtualModeEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsVirtualModeEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DisplayTarget_get_IsVirtualTopologyEnabled(py::wrapper::Windows::Devices::Display::Core::DisplayTarget* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Display.Core.DisplayTarget", L"IsVirtualTopologyEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsVirtualTopologyEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DisplayTarget_get_MonitorPersistence(py::wrapper::Windows::Devices::Display::Core::DisplayTarget* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Display.Core.DisplayTarget", L"MonitorPersistence"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MonitorPersistence());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DisplayTarget_get_Properties(py::wrapper::Windows::Devices::Display::Core::DisplayTarget* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Display.Core.DisplayTarget", L"Properties"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Properties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DisplayTarget_get_StableMonitorId(py::wrapper::Windows::Devices::Display::Core::DisplayTarget* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Display.Core.DisplayTarget", L"StableMonitorId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.StableMonitorId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DisplayTarget_get_UsageKind(py::wrapper::Windows::Devices::Display::Core::DisplayTarget* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Display.Core.DisplayTarget", L"UsageKind"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.UsageKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_DisplayTarget(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Display::Core::DisplayTarget>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_DisplayTarget(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Display::Core::DisplayTarget>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DisplayTarget[] = {
        { "is_equal", reinterpret_cast<PyCFunction>(DisplayTarget_IsEqual), METH_VARARGS, nullptr },
        { "is_same", reinterpret_cast<PyCFunction>(DisplayTarget_IsSame), METH_VARARGS, nullptr },
        { "try_get_monitor", reinterpret_cast<PyCFunction>(DisplayTarget_TryGetMonitor), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_DisplayTarget, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DisplayTarget), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DisplayTarget[] = {
        { "adapter", reinterpret_cast<getter>(DisplayTarget_get_Adapter), nullptr, nullptr, nullptr },
        { "adapter_relative_id", reinterpret_cast<getter>(DisplayTarget_get_AdapterRelativeId), nullptr, nullptr, nullptr },
        { "device_interface_path", reinterpret_cast<getter>(DisplayTarget_get_DeviceInterfacePath), nullptr, nullptr, nullptr },
        { "is_connected", reinterpret_cast<getter>(DisplayTarget_get_IsConnected), nullptr, nullptr, nullptr },
        { "is_stale", reinterpret_cast<getter>(DisplayTarget_get_IsStale), nullptr, nullptr, nullptr },
        { "is_virtual_mode_enabled", reinterpret_cast<getter>(DisplayTarget_get_IsVirtualModeEnabled), nullptr, nullptr, nullptr },
        { "is_virtual_topology_enabled", reinterpret_cast<getter>(DisplayTarget_get_IsVirtualTopologyEnabled), nullptr, nullptr, nullptr },
        { "monitor_persistence", reinterpret_cast<getter>(DisplayTarget_get_MonitorPersistence), nullptr, nullptr, nullptr },
        { "properties", reinterpret_cast<getter>(DisplayTarget_get_Properties), nullptr, nullptr, nullptr },
        { "stable_monitor_id", reinterpret_cast<getter>(DisplayTarget_get_StableMonitorId), nullptr, nullptr, nullptr },
        { "usage_kind", reinterpret_cast<getter>(DisplayTarget_get_UsageKind), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_DisplayTarget[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_DisplayTarget) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_DisplayTarget) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_DisplayTarget) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_DisplayTarget) },
        { },
    };

    static PyType_Spec type_spec_DisplayTarget =
    {
        "_winrt_windows_devices_display_core.DisplayTarget",
        sizeof(py::wrapper::Windows::Devices::Display::Core::DisplayTarget),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DisplayTarget
    };

    // ----- DisplayTask class --------------------

    static PyObject* _new_DisplayTask(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Display::Core::DisplayTask>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Display::Core::DisplayTask>::type_name);
        return nullptr;
    }

    static void _dealloc_DisplayTask(py::wrapper::Windows::Devices::Display::Core::DisplayTask* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* DisplayTask_SetScanout(py::wrapper::Windows::Devices::Display::Core::DisplayTask* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Display.Core.DisplayTask", L"SetScanout", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Display::Core::DisplayScanout>(args, 0);

                self->obj.SetScanout(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DisplayTask_SetSignal(py::wrapper::Windows::Devices::Display::Core::DisplayTask* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Display.Core.DisplayTask", L"SetSignal", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Display::Core::DisplayTaskSignalKind>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Devices::Display::Core::DisplayFence>(args, 1);

                self->obj.SetSignal(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DisplayTask_SetWait(py::wrapper::Windows::Devices::Display::Core::DisplayTask* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Display.Core.DisplayTask", L"SetWait", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Display::Core::DisplayFence>(args, 0);
                auto param1 = py::convert_to<uint64_t>(args, 1);

                self->obj.SetWait(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_DisplayTask(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Display::Core::DisplayTask>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_DisplayTask(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Display::Core::DisplayTask>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DisplayTask[] = {
        { "set_scanout", reinterpret_cast<PyCFunction>(DisplayTask_SetScanout), METH_VARARGS, nullptr },
        { "set_signal", reinterpret_cast<PyCFunction>(DisplayTask_SetSignal), METH_VARARGS, nullptr },
        { "set_wait", reinterpret_cast<PyCFunction>(DisplayTask_SetWait), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_DisplayTask, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DisplayTask), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DisplayTask[] = {
        { }
    };

    static PyType_Slot _type_slots_DisplayTask[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_DisplayTask) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_DisplayTask) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_DisplayTask) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_DisplayTask) },
        { },
    };

    static PyType_Spec type_spec_DisplayTask =
    {
        "_winrt_windows_devices_display_core.DisplayTask",
        sizeof(py::wrapper::Windows::Devices::Display::Core::DisplayTask),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DisplayTask
    };

    // ----- DisplayTaskPool class --------------------

    static PyObject* _new_DisplayTaskPool(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Display::Core::DisplayTaskPool>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Display::Core::DisplayTaskPool>::type_name);
        return nullptr;
    }

    static void _dealloc_DisplayTaskPool(py::wrapper::Windows::Devices::Display::Core::DisplayTaskPool* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* DisplayTaskPool_CreateTask(py::wrapper::Windows::Devices::Display::Core::DisplayTaskPool* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Display.Core.DisplayTaskPool", L"CreateTask", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.CreateTask());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DisplayTaskPool_ExecuteTask(py::wrapper::Windows::Devices::Display::Core::DisplayTaskPool* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Display.Core.DisplayTaskPool", L"ExecuteTask", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Display::Core::DisplayTask>(args, 0);

                self->obj.ExecuteTask(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DisplayTaskPool_TryExecuteTask(py::wrapper::Windows::Devices::Display::Core::DisplayTaskPool* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Display.Core.DisplayTaskPool", L"TryExecuteTask", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Display::Core::DisplayTask>(args, 0);

                return py::convert(self->obj.TryExecuteTask(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_DisplayTaskPool(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Display::Core::DisplayTaskPool>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_DisplayTaskPool(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Display::Core::DisplayTaskPool>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DisplayTaskPool[] = {
        { "create_task", reinterpret_cast<PyCFunction>(DisplayTaskPool_CreateTask), METH_VARARGS, nullptr },
        { "execute_task", reinterpret_cast<PyCFunction>(DisplayTaskPool_ExecuteTask), METH_VARARGS, nullptr },
        { "try_execute_task", reinterpret_cast<PyCFunction>(DisplayTaskPool_TryExecuteTask), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_DisplayTaskPool, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DisplayTaskPool), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DisplayTaskPool[] = {
        { }
    };

    static PyType_Slot _type_slots_DisplayTaskPool[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_DisplayTaskPool) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_DisplayTaskPool) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_DisplayTaskPool) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_DisplayTaskPool) },
        { },
    };

    static PyType_Spec type_spec_DisplayTaskPool =
    {
        "_winrt_windows_devices_display_core.DisplayTaskPool",
        sizeof(py::wrapper::Windows::Devices::Display::Core::DisplayTaskPool),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DisplayTaskPool
    };

    // ----- DisplayTaskResult class --------------------

    static PyObject* _new_DisplayTaskResult(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Display::Core::DisplayTaskResult>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Display::Core::DisplayTaskResult>::type_name);
        return nullptr;
    }

    static void _dealloc_DisplayTaskResult(py::wrapper::Windows::Devices::Display::Core::DisplayTaskResult* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* DisplayTaskResult_get_PresentId(py::wrapper::Windows::Devices::Display::Core::DisplayTaskResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Display.Core.DisplayTaskResult", L"PresentId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PresentId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DisplayTaskResult_get_PresentStatus(py::wrapper::Windows::Devices::Display::Core::DisplayTaskResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Display.Core.DisplayTaskResult", L"PresentStatus"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PresentStatus());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DisplayTaskResult_get_SourceStatus(py::wrapper::Windows::Devices::Display::Core::DisplayTaskResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Display.Core.DisplayTaskResult", L"SourceStatus"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SourceStatus());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_DisplayTaskResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Display::Core::DisplayTaskResult>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_DisplayTaskResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Display::Core::DisplayTaskResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DisplayTaskResult[] = {
        { "_assign_array_", _assign_array_DisplayTaskResult, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DisplayTaskResult), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DisplayTaskResult[] = {
        { "present_id", reinterpret_cast<getter>(DisplayTaskResult_get_PresentId), nullptr, nullptr, nullptr },
        { "present_status", reinterpret_cast<getter>(DisplayTaskResult_get_PresentStatus), nullptr, nullptr, nullptr },
        { "source_status", reinterpret_cast<getter>(DisplayTaskResult_get_SourceStatus), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_DisplayTaskResult[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_DisplayTaskResult) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_DisplayTaskResult) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_DisplayTaskResult) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_DisplayTaskResult) },
        { },
    };

    static PyType_Spec type_spec_DisplayTaskResult =
    {
        "_winrt_windows_devices_display_core.DisplayTaskResult",
        sizeof(py::wrapper::Windows::Devices::Display::Core::DisplayTaskResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DisplayTaskResult
    };

    // ----- DisplayView class --------------------

    static PyObject* _new_DisplayView(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Display::Core::DisplayView>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Display::Core::DisplayView>::type_name);
        return nullptr;
    }

    static void _dealloc_DisplayView(py::wrapper::Windows::Devices::Display::Core::DisplayView* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* DisplayView_SetPrimaryPath(py::wrapper::Windows::Devices::Display::Core::DisplayView* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Display.Core.DisplayView", L"SetPrimaryPath", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Display::Core::DisplayPath>(args, 0);

                self->obj.SetPrimaryPath(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DisplayView_get_ContentResolution(py::wrapper::Windows::Devices::Display::Core::DisplayView* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Display.Core.DisplayView", L"ContentResolution"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ContentResolution());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DisplayView_put_ContentResolution(py::wrapper::Windows::Devices::Display::Core::DisplayView* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Display.Core.DisplayView", L"ContentResolution"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Graphics::SizeInt32>>(arg);

            self->obj.ContentResolution(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DisplayView_get_Paths(py::wrapper::Windows::Devices::Display::Core::DisplayView* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Display.Core.DisplayView", L"Paths"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Paths());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DisplayView_get_Properties(py::wrapper::Windows::Devices::Display::Core::DisplayView* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Display.Core.DisplayView", L"Properties"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Properties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_DisplayView(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Display::Core::DisplayView>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_DisplayView(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Display::Core::DisplayView>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DisplayView[] = {
        { "set_primary_path", reinterpret_cast<PyCFunction>(DisplayView_SetPrimaryPath), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_DisplayView, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DisplayView), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DisplayView[] = {
        { "content_resolution", reinterpret_cast<getter>(DisplayView_get_ContentResolution), reinterpret_cast<setter>(DisplayView_put_ContentResolution), nullptr, nullptr },
        { "paths", reinterpret_cast<getter>(DisplayView_get_Paths), nullptr, nullptr, nullptr },
        { "properties", reinterpret_cast<getter>(DisplayView_get_Properties), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_DisplayView[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_DisplayView) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_DisplayView) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_DisplayView) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_DisplayView) },
        { },
    };

    static PyType_Spec type_spec_DisplayView =
    {
        "_winrt_windows_devices_display_core.DisplayView",
        sizeof(py::wrapper::Windows::Devices::Display::Core::DisplayView),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DisplayView
    };

    // ----- DisplayWireFormat class --------------------

    static PyObject* _new_DisplayWireFormat(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 5)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Display::Core::DisplayWireFormatPixelEncoding>(args, 0);
                auto param1 = py::convert_to<int32_t>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Devices::Display::Core::DisplayWireFormatColorSpace>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Devices::Display::Core::DisplayWireFormatEotf>(args, 3);
                auto param4 = py::convert_to<winrt::Windows::Devices::Display::Core::DisplayWireFormatHdrMetadata>(args, 4);

                winrt::Windows::Devices::Display::Core::DisplayWireFormat instance{ param0, param1, param2, param3, param4 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_DisplayWireFormat(py::wrapper::Windows::Devices::Display::Core::DisplayWireFormat* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* DisplayWireFormat_CreateWithProperties(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 6)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Display.Core.DisplayWireFormat", L"CreateWithProperties", 6))
            {
                py::set_arg_count_version_error(6);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Foundation::Collections::IKeyValuePair<winrt::guid, winrt::Windows::Foundation::IInspectable>>>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Devices::Display::Core::DisplayWireFormatPixelEncoding>(args, 1);
                auto param2 = py::convert_to<int32_t>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Devices::Display::Core::DisplayWireFormatColorSpace>(args, 3);
                auto param4 = py::convert_to<winrt::Windows::Devices::Display::Core::DisplayWireFormatEotf>(args, 4);
                auto param5 = py::convert_to<winrt::Windows::Devices::Display::Core::DisplayWireFormatHdrMetadata>(args, 5);

                return py::convert(winrt::Windows::Devices::Display::Core::DisplayWireFormat::CreateWithProperties(param0, param1, param2, param3, param4, param5));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DisplayWireFormat_get_BitsPerChannel(py::wrapper::Windows::Devices::Display::Core::DisplayWireFormat* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Display.Core.DisplayWireFormat", L"BitsPerChannel"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.BitsPerChannel());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DisplayWireFormat_get_ColorSpace(py::wrapper::Windows::Devices::Display::Core::DisplayWireFormat* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Display.Core.DisplayWireFormat", L"ColorSpace"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ColorSpace());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DisplayWireFormat_get_Eotf(py::wrapper::Windows::Devices::Display::Core::DisplayWireFormat* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Display.Core.DisplayWireFormat", L"Eotf"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Eotf());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DisplayWireFormat_get_HdrMetadata(py::wrapper::Windows::Devices::Display::Core::DisplayWireFormat* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Display.Core.DisplayWireFormat", L"HdrMetadata"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.HdrMetadata());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DisplayWireFormat_get_PixelEncoding(py::wrapper::Windows::Devices::Display::Core::DisplayWireFormat* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Display.Core.DisplayWireFormat", L"PixelEncoding"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PixelEncoding());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DisplayWireFormat_get_Properties(py::wrapper::Windows::Devices::Display::Core::DisplayWireFormat* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Display.Core.DisplayWireFormat", L"Properties"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Properties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_DisplayWireFormat(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Display::Core::DisplayWireFormat>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_DisplayWireFormat(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Display::Core::DisplayWireFormat>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DisplayWireFormat[] = {
        { "create_with_properties", reinterpret_cast<PyCFunction>(DisplayWireFormat_CreateWithProperties), METH_VARARGS | METH_STATIC, nullptr },
        { "_assign_array_", _assign_array_DisplayWireFormat, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DisplayWireFormat), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DisplayWireFormat[] = {
        { "bits_per_channel", reinterpret_cast<getter>(DisplayWireFormat_get_BitsPerChannel), nullptr, nullptr, nullptr },
        { "color_space", reinterpret_cast<getter>(DisplayWireFormat_get_ColorSpace), nullptr, nullptr, nullptr },
        { "eotf", reinterpret_cast<getter>(DisplayWireFormat_get_Eotf), nullptr, nullptr, nullptr },
        { "hdr_metadata", reinterpret_cast<getter>(DisplayWireFormat_get_HdrMetadata), nullptr, nullptr, nullptr },
        { "pixel_encoding", reinterpret_cast<getter>(DisplayWireFormat_get_PixelEncoding), nullptr, nullptr, nullptr },
        { "properties", reinterpret_cast<getter>(DisplayWireFormat_get_Properties), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_DisplayWireFormat[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_DisplayWireFormat) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_DisplayWireFormat) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_DisplayWireFormat) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_DisplayWireFormat) },
        { },
    };

    static PyType_Spec type_spec_DisplayWireFormat =
    {
        "_winrt_windows_devices_display_core.DisplayWireFormat",
        sizeof(py::wrapper::Windows::Devices::Display::Core::DisplayWireFormat),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DisplayWireFormat
    };

    // ----- DisplayPresentationRate struct --------------------

    winrt_struct_wrapper<winrt::Windows::Devices::Display::Core::DisplayPresentationRate>* _new_DisplayPresentationRate(PyTypeObject* subclass, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        auto self = reinterpret_cast<winrt_struct_wrapper<winrt::Windows::Devices::Display::Core::DisplayPresentationRate>*>(subclass->tp_alloc(subclass, 0));

        if (!self)
        {
            return nullptr;
        }

        std::construct_at(&self->obj);

        return self;
    }

    int _init_DisplayPresentationRate(winrt_struct_wrapper<winrt::Windows::Devices::Display::Core::DisplayPresentationRate>* self, PyObject* args, PyObject* kwds) noexcept
    {
        auto tuple_size = PyTuple_Size(args);

        if ((tuple_size == 0) && (kwds == nullptr))
        {
            self->obj = {};
            return 0;
        }

        PyObject* _VerticalSyncRate{};
        int32_t _VerticalSyncsPerPresentation{};

        static const char* kwlist[] = {"vertical_sync_rate", "vertical_syncs_per_presentation", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "Oi", const_cast<char**>(kwlist), &_VerticalSyncRate, &_VerticalSyncsPerPresentation))
        {
            return -1;
        }

        try
        {
            self->obj = {py::converter<winrt::Windows::Foundation::Numerics::Rational>::convert_to(_VerticalSyncRate), _VerticalSyncsPerPresentation};
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static void _dealloc_DisplayPresentationRate(py::wrapper::Windows::Devices::Display::Core::DisplayPresentationRate* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_DisplayPresentationRate(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Display::Core::DisplayPresentationRate>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyMethodDef _methods_DisplayPresentationRate[] = {
        { "_assign_array_", _assign_array_DisplayPresentationRate, METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyObject* DisplayPresentationRate_get_VerticalSyncRate(py::wrapper::Windows::Devices::Display::Core::DisplayPresentationRate* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.VerticalSyncRate);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DisplayPresentationRate_set_VerticalSyncRate(py::wrapper::Windows::Devices::Display::Core::DisplayPresentationRate* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.VerticalSyncRate = py::converter<winrt::Windows::Foundation::Numerics::Rational>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DisplayPresentationRate_get_VerticalSyncsPerPresentation(py::wrapper::Windows::Devices::Display::Core::DisplayPresentationRate* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.VerticalSyncsPerPresentation);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DisplayPresentationRate_set_VerticalSyncsPerPresentation(py::wrapper::Windows::Devices::Display::Core::DisplayPresentationRate* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.VerticalSyncsPerPresentation = py::converter<int32_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyGetSetDef _getset_DisplayPresentationRate[] = {
        { "vertical_sync_rate", reinterpret_cast<getter>(DisplayPresentationRate_get_VerticalSyncRate), reinterpret_cast<setter>(DisplayPresentationRate_set_VerticalSyncRate), nullptr, nullptr },
        { "vertical_syncs_per_presentation", reinterpret_cast<getter>(DisplayPresentationRate_get_VerticalSyncsPerPresentation), reinterpret_cast<setter>(DisplayPresentationRate_set_VerticalSyncsPerPresentation), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_DisplayPresentationRate[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_DisplayPresentationRate) },
        { Py_tp_init, reinterpret_cast<void*>(_init_DisplayPresentationRate) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_DisplayPresentationRate) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_DisplayPresentationRate) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_DisplayPresentationRate) },
        { },
    };

    static PyType_Spec type_spec_DisplayPresentationRate =
    {
        "_winrt_windows_devices_display_core.DisplayPresentationRate",
        sizeof(py::wrapper::Windows::Devices::Display::Core::DisplayPresentationRate),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DisplayPresentationRate
    };

    // ----- Windows.Devices.Display.Core Initialization --------------------
    PyDoc_STRVAR(module_doc, "Windows::Devices::Display::Core");


    static PyModuleDef module_def
        = {PyModuleDef_HEAD_INIT,
           "_winrt_windows_devices_display_core",
           module_doc,
           0,
           nullptr,
           nullptr,
           nullptr,
           nullptr,
           nullptr};

} // py::cpp::Windows::Devices::Display::Core

PyMODINIT_FUNC PyInit__winrt_windows_devices_display_core(void) noexcept
{
    using namespace py::cpp::Windows::Devices::Display::Core;

    if (py::import_winrt_runtime() == -1)
    {
        return nullptr;
    }

    py::pyobj_handle module{PyModule_Create(&module_def)};

    if (!module)
    {
        return nullptr;
    }

    auto object_type = py::get_object_type();
    if (!object_type)
    {
        return nullptr;
    }

    py::pyobj_handle object_bases{PyTuple_Pack(1, object_type)};

    if (!object_bases)
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), &type_spec_DisplayAdapter, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), &type_spec_DisplayAdapter, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), &type_spec_DisplayDevice, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), &type_spec_DisplayDevice, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), &type_spec_DisplayFence, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), &type_spec_DisplayFence, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), &type_spec_DisplayManager, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), &type_spec_DisplayManager, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), &type_spec_DisplayManagerChangedEventArgs, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), &type_spec_DisplayManagerChangedEventArgs, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), &type_spec_DisplayManagerDisabledEventArgs, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), &type_spec_DisplayManagerDisabledEventArgs, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), &type_spec_DisplayManagerEnabledEventArgs, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), &type_spec_DisplayManagerEnabledEventArgs, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), &type_spec_DisplayManagerPathsFailedOrInvalidatedEventArgs, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), &type_spec_DisplayManagerPathsFailedOrInvalidatedEventArgs, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), &type_spec_DisplayManagerResultWithState, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), &type_spec_DisplayManagerResultWithState, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), &type_spec_DisplayModeInfo, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), &type_spec_DisplayModeInfo, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), &type_spec_DisplayPath, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), &type_spec_DisplayPath, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), &type_spec_DisplayPrimaryDescription, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), &type_spec_DisplayPrimaryDescription, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), &type_spec_DisplayScanout, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), &type_spec_DisplayScanout, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), &type_spec_DisplaySource, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), &type_spec_DisplaySource, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), &type_spec_DisplayState, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), &type_spec_DisplayState, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), &type_spec_DisplayStateOperationResult, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), &type_spec_DisplayStateOperationResult, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), &type_spec_DisplaySurface, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), &type_spec_DisplaySurface, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), &type_spec_DisplayTarget, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), &type_spec_DisplayTarget, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), &type_spec_DisplayTask, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), &type_spec_DisplayTask, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), &type_spec_DisplayTaskPool, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), &type_spec_DisplayTaskPool, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), &type_spec_DisplayTaskResult, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), &type_spec_DisplayTaskResult, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), &type_spec_DisplayView, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), &type_spec_DisplayView, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), &type_spec_DisplayWireFormat, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), &type_spec_DisplayWireFormat, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), &type_spec_DisplayPresentationRate, nullptr, nullptr, nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), &type_spec_DisplayPresentationRate, nullptr, nullptr) == -1)
    #endif
    {
        return nullptr;
    }


    return module.detach();
}
