// WARNING: Please don't edit this file. It was generated by Python/WinRT v0.0.0

#include "py.Windows.AI.MachineLearning.h"


namespace py::cpp::Windows::AI::MachineLearning
{
    // ----- ImageFeatureDescriptor class --------------------

    static PyObject* _new_ImageFeatureDescriptor(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::AI::MachineLearning::ImageFeatureDescriptor>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::AI::MachineLearning::ImageFeatureDescriptor>::type_name);
        return nullptr;
    }

    static void _dealloc_ImageFeatureDescriptor(py::wrapper::Windows::AI::MachineLearning::ImageFeatureDescriptor* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ImageFeatureDescriptor_get_BitmapAlphaMode(py::wrapper::Windows::AI::MachineLearning::ImageFeatureDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.AI.MachineLearning.ImageFeatureDescriptor", L"BitmapAlphaMode"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.BitmapAlphaMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ImageFeatureDescriptor_get_BitmapPixelFormat(py::wrapper::Windows::AI::MachineLearning::ImageFeatureDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.AI.MachineLearning.ImageFeatureDescriptor", L"BitmapPixelFormat"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.BitmapPixelFormat());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ImageFeatureDescriptor_get_Height(py::wrapper::Windows::AI::MachineLearning::ImageFeatureDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.AI.MachineLearning.ImageFeatureDescriptor", L"Height"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Height());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ImageFeatureDescriptor_get_Width(py::wrapper::Windows::AI::MachineLearning::ImageFeatureDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.AI.MachineLearning.ImageFeatureDescriptor", L"Width"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Width());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ImageFeatureDescriptor_get_PixelRange(py::wrapper::Windows::AI::MachineLearning::ImageFeatureDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.AI.MachineLearning.ImageFeatureDescriptor", L"PixelRange"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PixelRange());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ImageFeatureDescriptor_get_Description(py::wrapper::Windows::AI::MachineLearning::ImageFeatureDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.AI.MachineLearning.ImageFeatureDescriptor", L"Description"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Description());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ImageFeatureDescriptor_get_IsRequired(py::wrapper::Windows::AI::MachineLearning::ImageFeatureDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.AI.MachineLearning.ImageFeatureDescriptor", L"IsRequired"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsRequired());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ImageFeatureDescriptor_get_Kind(py::wrapper::Windows::AI::MachineLearning::ImageFeatureDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.AI.MachineLearning.ImageFeatureDescriptor", L"Kind"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ImageFeatureDescriptor_get_Name(py::wrapper::Windows::AI::MachineLearning::ImageFeatureDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.AI.MachineLearning.ImageFeatureDescriptor", L"Name"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Name());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ImageFeatureDescriptor(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::AI::MachineLearning::ImageFeatureDescriptor>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ImageFeatureDescriptor(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::AI::MachineLearning::ImageFeatureDescriptor>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ImageFeatureDescriptor[] = {
        { "_assign_array_", _assign_array_ImageFeatureDescriptor, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ImageFeatureDescriptor), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ImageFeatureDescriptor[] = {
        { "bitmap_alpha_mode", reinterpret_cast<getter>(ImageFeatureDescriptor_get_BitmapAlphaMode), nullptr, nullptr, nullptr },
        { "bitmap_pixel_format", reinterpret_cast<getter>(ImageFeatureDescriptor_get_BitmapPixelFormat), nullptr, nullptr, nullptr },
        { "height", reinterpret_cast<getter>(ImageFeatureDescriptor_get_Height), nullptr, nullptr, nullptr },
        { "width", reinterpret_cast<getter>(ImageFeatureDescriptor_get_Width), nullptr, nullptr, nullptr },
        { "pixel_range", reinterpret_cast<getter>(ImageFeatureDescriptor_get_PixelRange), nullptr, nullptr, nullptr },
        { "description", reinterpret_cast<getter>(ImageFeatureDescriptor_get_Description), nullptr, nullptr, nullptr },
        { "is_required", reinterpret_cast<getter>(ImageFeatureDescriptor_get_IsRequired), nullptr, nullptr, nullptr },
        { "kind", reinterpret_cast<getter>(ImageFeatureDescriptor_get_Kind), nullptr, nullptr, nullptr },
        { "name", reinterpret_cast<getter>(ImageFeatureDescriptor_get_Name), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ImageFeatureDescriptor[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ImageFeatureDescriptor) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ImageFeatureDescriptor) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ImageFeatureDescriptor) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ImageFeatureDescriptor) },
        { },
    };

    static PyType_Spec type_spec_ImageFeatureDescriptor = {
        "winrt._winrt_windows_ai_machinelearning.ImageFeatureDescriptor",
        sizeof(py::wrapper::Windows::AI::MachineLearning::ImageFeatureDescriptor),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ImageFeatureDescriptor};

    // ----- ImageFeatureValue class --------------------

    static PyObject* _new_ImageFeatureValue(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::AI::MachineLearning::ImageFeatureValue>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::AI::MachineLearning::ImageFeatureValue>::type_name);
        return nullptr;
    }

    static void _dealloc_ImageFeatureValue(py::wrapper::Windows::AI::MachineLearning::ImageFeatureValue* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ImageFeatureValue_CreateFromVideoFrame(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.ImageFeatureValue", L"CreateFromVideoFrame", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Media::VideoFrame>(args, 0);

                return py::convert(winrt::Windows::AI::MachineLearning::ImageFeatureValue::CreateFromVideoFrame(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ImageFeatureValue_get_VideoFrame(py::wrapper::Windows::AI::MachineLearning::ImageFeatureValue* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.AI.MachineLearning.ImageFeatureValue", L"VideoFrame"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.VideoFrame());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ImageFeatureValue_get_Kind(py::wrapper::Windows::AI::MachineLearning::ImageFeatureValue* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.AI.MachineLearning.ImageFeatureValue", L"Kind"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ImageFeatureValue(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::AI::MachineLearning::ImageFeatureValue>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ImageFeatureValue(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::AI::MachineLearning::ImageFeatureValue>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ImageFeatureValue[] = {
        { "_assign_array_", _assign_array_ImageFeatureValue, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ImageFeatureValue), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ImageFeatureValue[] = {
        { "video_frame", reinterpret_cast<getter>(ImageFeatureValue_get_VideoFrame), nullptr, nullptr, nullptr },
        { "kind", reinterpret_cast<getter>(ImageFeatureValue_get_Kind), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ImageFeatureValue[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ImageFeatureValue) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ImageFeatureValue) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ImageFeatureValue) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ImageFeatureValue) },
        { },
    };

    static PyType_Spec type_spec_ImageFeatureValue = {
        "winrt._winrt_windows_ai_machinelearning.ImageFeatureValue",
        sizeof(py::wrapper::Windows::AI::MachineLearning::ImageFeatureValue),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ImageFeatureValue};

    static PyGetSetDef getset_ImageFeatureValue_Static[] = {
        { }
    };

    static PyMethodDef methods_ImageFeatureValue_Static[] = {
        { "create_from_video_frame", reinterpret_cast<PyCFunction>(ImageFeatureValue_CreateFromVideoFrame), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_ImageFeatureValue_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_ImageFeatureValue_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_ImageFeatureValue_Static) },
        { }
    };

    static PyType_Spec type_spec_ImageFeatureValue_Static =
    {
        "winrt._winrt_windows_ai_machinelearning.ImageFeatureValue_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_ImageFeatureValue_Static
    };

    // ----- LearningModel class --------------------

    static PyObject* _new_LearningModel(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::AI::MachineLearning::LearningModel>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::AI::MachineLearning::LearningModel>::type_name);
        return nullptr;
    }

    static void _dealloc_LearningModel(py::wrapper::Windows::AI::MachineLearning::LearningModel* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* LearningModel_Close(py::wrapper::Windows::AI::MachineLearning::LearningModel* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.LearningModel", L"Close", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LearningModel_LoadFromFilePath(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.LearningModel", L"LoadFromFilePath", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::AI::MachineLearning::LearningModel::LoadFromFilePath(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.LearningModel", L"LoadFromFilePath", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::AI::MachineLearning::ILearningModelOperatorProvider>(args, 1);

                return py::convert(winrt::Windows::AI::MachineLearning::LearningModel::LoadFromFilePath(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LearningModel_LoadFromStorageFileAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.LearningModel", L"LoadFromStorageFileAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFile>(args, 0);

                return py::convert(winrt::Windows::AI::MachineLearning::LearningModel::LoadFromStorageFileAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.LearningModel", L"LoadFromStorageFileAsync", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFile>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::AI::MachineLearning::ILearningModelOperatorProvider>(args, 1);

                return py::convert(winrt::Windows::AI::MachineLearning::LearningModel::LoadFromStorageFileAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LearningModel_LoadFromStream(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.LearningModel", L"LoadFromStream", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStreamReference>(args, 0);

                return py::convert(winrt::Windows::AI::MachineLearning::LearningModel::LoadFromStream(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.LearningModel", L"LoadFromStream", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStreamReference>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::AI::MachineLearning::ILearningModelOperatorProvider>(args, 1);

                return py::convert(winrt::Windows::AI::MachineLearning::LearningModel::LoadFromStream(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LearningModel_LoadFromStreamAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.LearningModel", L"LoadFromStreamAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStreamReference>(args, 0);

                return py::convert(winrt::Windows::AI::MachineLearning::LearningModel::LoadFromStreamAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.LearningModel", L"LoadFromStreamAsync", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStreamReference>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::AI::MachineLearning::ILearningModelOperatorProvider>(args, 1);

                return py::convert(winrt::Windows::AI::MachineLearning::LearningModel::LoadFromStreamAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LearningModel_get_Author(py::wrapper::Windows::AI::MachineLearning::LearningModel* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.AI.MachineLearning.LearningModel", L"Author"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Author());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LearningModel_get_Description(py::wrapper::Windows::AI::MachineLearning::LearningModel* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.AI.MachineLearning.LearningModel", L"Description"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Description());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LearningModel_get_Domain(py::wrapper::Windows::AI::MachineLearning::LearningModel* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.AI.MachineLearning.LearningModel", L"Domain"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Domain());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LearningModel_get_InputFeatures(py::wrapper::Windows::AI::MachineLearning::LearningModel* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.AI.MachineLearning.LearningModel", L"InputFeatures"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.InputFeatures());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LearningModel_get_Metadata(py::wrapper::Windows::AI::MachineLearning::LearningModel* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.AI.MachineLearning.LearningModel", L"Metadata"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Metadata());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LearningModel_get_Name(py::wrapper::Windows::AI::MachineLearning::LearningModel* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.AI.MachineLearning.LearningModel", L"Name"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Name());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LearningModel_get_OutputFeatures(py::wrapper::Windows::AI::MachineLearning::LearningModel* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.AI.MachineLearning.LearningModel", L"OutputFeatures"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.OutputFeatures());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LearningModel_get_Version(py::wrapper::Windows::AI::MachineLearning::LearningModel* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.AI.MachineLearning.LearningModel", L"Version"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Version());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_LearningModel(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::AI::MachineLearning::LearningModel>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_LearningModel(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::AI::MachineLearning::LearningModel>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_LearningModel(py::wrapper::Windows::AI::MachineLearning::LearningModel* self, PyObject* /*unused*/) noexcept
    {
        return Py_NewRef(self);
    }

    static PyObject* _exit_LearningModel(py::wrapper::Windows::AI::MachineLearning::LearningModel* self, PyObject* /*unused*/) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_LearningModel[] = {
        { "close", reinterpret_cast<PyCFunction>(LearningModel_Close), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_LearningModel, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_LearningModel), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_LearningModel), METH_NOARGS, nullptr },
        { "__exit__", reinterpret_cast<PyCFunction>(_exit_LearningModel), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_LearningModel[] = {
        { "author", reinterpret_cast<getter>(LearningModel_get_Author), nullptr, nullptr, nullptr },
        { "description", reinterpret_cast<getter>(LearningModel_get_Description), nullptr, nullptr, nullptr },
        { "domain", reinterpret_cast<getter>(LearningModel_get_Domain), nullptr, nullptr, nullptr },
        { "input_features", reinterpret_cast<getter>(LearningModel_get_InputFeatures), nullptr, nullptr, nullptr },
        { "metadata", reinterpret_cast<getter>(LearningModel_get_Metadata), nullptr, nullptr, nullptr },
        { "name", reinterpret_cast<getter>(LearningModel_get_Name), nullptr, nullptr, nullptr },
        { "output_features", reinterpret_cast<getter>(LearningModel_get_OutputFeatures), nullptr, nullptr, nullptr },
        { "version", reinterpret_cast<getter>(LearningModel_get_Version), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_LearningModel[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_LearningModel) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_LearningModel) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_LearningModel) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_LearningModel) },
        { },
    };

    static PyType_Spec type_spec_LearningModel = {
        "winrt._winrt_windows_ai_machinelearning.LearningModel",
        sizeof(py::wrapper::Windows::AI::MachineLearning::LearningModel),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_LearningModel};

    static PyGetSetDef getset_LearningModel_Static[] = {
        { }
    };

    static PyMethodDef methods_LearningModel_Static[] = {
        { "load_from_file_path", reinterpret_cast<PyCFunction>(LearningModel_LoadFromFilePath), METH_VARARGS, nullptr },
        { "load_from_storage_file_async", reinterpret_cast<PyCFunction>(LearningModel_LoadFromStorageFileAsync), METH_VARARGS, nullptr },
        { "load_from_stream", reinterpret_cast<PyCFunction>(LearningModel_LoadFromStream), METH_VARARGS, nullptr },
        { "load_from_stream_async", reinterpret_cast<PyCFunction>(LearningModel_LoadFromStreamAsync), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_LearningModel_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_LearningModel_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_LearningModel_Static) },
        { }
    };

    static PyType_Spec type_spec_LearningModel_Static =
    {
        "winrt._winrt_windows_ai_machinelearning.LearningModel_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_LearningModel_Static
    };

    // ----- LearningModelBinding class --------------------

    static PyObject* _new_LearningModelBinding(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::AI::MachineLearning::LearningModelSession>(args, 0);

                winrt::Windows::AI::MachineLearning::LearningModelBinding instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_LearningModelBinding(py::wrapper::Windows::AI::MachineLearning::LearningModelBinding* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* LearningModelBinding_Bind(py::wrapper::Windows::AI::MachineLearning::LearningModelBinding* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.LearningModelBinding", L"Bind", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 1);

                self->obj.Bind(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.LearningModelBinding", L"Bind", 3))
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Collections::IPropertySet>(args, 2);

                self->obj.Bind(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LearningModelBinding_Clear(py::wrapper::Windows::AI::MachineLearning::LearningModelBinding* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.LearningModelBinding", L"Clear", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Clear();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LearningModelBinding_First(py::wrapper::Windows::AI::MachineLearning::LearningModelBinding* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.LearningModelBinding", L"First", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.First());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LearningModelBinding_HasKey(py::wrapper::Windows::AI::MachineLearning::LearningModelBinding* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.LearningModelBinding", L"HasKey", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.HasKey(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LearningModelBinding_Lookup(py::wrapper::Windows::AI::MachineLearning::LearningModelBinding* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.LearningModelBinding", L"Lookup", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.Lookup(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LearningModelBinding_Split(py::wrapper::Windows::AI::MachineLearning::LearningModelBinding* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.LearningModelBinding", L"Split", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                winrt::Windows::Foundation::Collections::IMapView<winrt::hstring, winrt::Windows::Foundation::IInspectable> param0{nullptr};
                winrt::Windows::Foundation::Collections::IMapView<winrt::hstring, winrt::Windows::Foundation::IInspectable> param1{nullptr};

                self->obj.Split(param0, param1);

                py::pyobj_handle out0{ py::convert(param0) };
                if (!out0)
                {
                    return nullptr;
                }
                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out0.get(), out1.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LearningModelBinding_get_Size(py::wrapper::Windows::AI::MachineLearning::LearningModelBinding* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.AI.MachineLearning.LearningModelBinding", L"Size"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_LearningModelBinding(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::AI::MachineLearning::LearningModelBinding>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_LearningModelBinding(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::AI::MachineLearning::LearningModelBinding>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _iterator_LearningModelBinding(py::wrapper::Windows::AI::MachineLearning::LearningModelBinding* self) noexcept
    {
        try
        {
            py::pyobj_handle iter{py::convert(self->obj.First())};

            if (!iter)
            {
                return nullptr;
            }

            return py::wrap_mapping_iter(iter.get());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int _map_contains_LearningModelBinding(py::wrapper::Windows::AI::MachineLearning::LearningModelBinding* self, PyObject* key) noexcept
    {
        try
        {
            return static_cast<int>(self->obj.HasKey(py::convert_to<winrt::hstring>(key)));
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static Py_ssize_t _map_length_LearningModelBinding(py::wrapper::Windows::AI::MachineLearning::LearningModelBinding* self) noexcept
    {
        try
        {
            return static_cast<Py_ssize_t>(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _map_subscript_LearningModelBinding(py::wrapper::Windows::AI::MachineLearning::LearningModelBinding* self, PyObject* key) noexcept
    {
        try
        {
            auto _key = py::convert_to<winrt::hstring>(key);
            auto value = self->obj.TryLookup(_key);

            if (!value) {
                if constexpr (std::is_base_of_v<winrt::Windows::Foundation::IUnknown, decltype(value)>)
                {
                    if (self->obj.HasKey(_key))
                    {
                        Py_RETURN_NONE;
                    }
                }

                PyErr_SetObject(PyExc_KeyError, key);
                return nullptr;
            }

            return py::convert(value);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_LearningModelBinding[] = {
        { "bind", reinterpret_cast<PyCFunction>(LearningModelBinding_Bind), METH_VARARGS, nullptr },
        { "clear", reinterpret_cast<PyCFunction>(LearningModelBinding_Clear), METH_VARARGS, nullptr },
        { "first", reinterpret_cast<PyCFunction>(LearningModelBinding_First), METH_VARARGS, nullptr },
        { "has_key", reinterpret_cast<PyCFunction>(LearningModelBinding_HasKey), METH_VARARGS, nullptr },
        { "lookup", reinterpret_cast<PyCFunction>(LearningModelBinding_Lookup), METH_VARARGS, nullptr },
        { "split", reinterpret_cast<PyCFunction>(LearningModelBinding_Split), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_LearningModelBinding, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_LearningModelBinding), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_LearningModelBinding[] = {
        { "size", reinterpret_cast<getter>(LearningModelBinding_get_Size), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_LearningModelBinding[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_LearningModelBinding) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_LearningModelBinding) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_LearningModelBinding) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_LearningModelBinding) },
        { Py_tp_iter, reinterpret_cast<void*>(_iterator_LearningModelBinding) },
        { Py_sq_contains, reinterpret_cast<void*>(_map_contains_LearningModelBinding) },
        { Py_mp_length, reinterpret_cast<void*>(_map_length_LearningModelBinding) },
        { Py_mp_subscript, reinterpret_cast<void*>(_map_subscript_LearningModelBinding) },
        { },
    };

    static PyType_Spec type_spec_LearningModelBinding = {
        "winrt._winrt_windows_ai_machinelearning.LearningModelBinding",
        sizeof(py::wrapper::Windows::AI::MachineLearning::LearningModelBinding),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_LearningModelBinding};

    // ----- LearningModelDevice class --------------------

    static PyObject* _new_LearningModelDevice(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::AI::MachineLearning::LearningModelDeviceKind>(args, 0);

                winrt::Windows::AI::MachineLearning::LearningModelDevice instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_LearningModelDevice(py::wrapper::Windows::AI::MachineLearning::LearningModelDevice* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* LearningModelDevice_CreateFromDirect3D11Device(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.LearningModelDevice", L"CreateFromDirect3D11Device", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Graphics::DirectX::Direct3D11::IDirect3DDevice>(args, 0);

                return py::convert(winrt::Windows::AI::MachineLearning::LearningModelDevice::CreateFromDirect3D11Device(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LearningModelDevice_get_AdapterId(py::wrapper::Windows::AI::MachineLearning::LearningModelDevice* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.AI.MachineLearning.LearningModelDevice", L"AdapterId"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.AdapterId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LearningModelDevice_get_Direct3D11Device(py::wrapper::Windows::AI::MachineLearning::LearningModelDevice* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.AI.MachineLearning.LearningModelDevice", L"Direct3D11Device"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Direct3D11Device());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_LearningModelDevice(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::AI::MachineLearning::LearningModelDevice>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_LearningModelDevice(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::AI::MachineLearning::LearningModelDevice>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_LearningModelDevice[] = {
        { "_assign_array_", _assign_array_LearningModelDevice, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_LearningModelDevice), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_LearningModelDevice[] = {
        { "adapter_id", reinterpret_cast<getter>(LearningModelDevice_get_AdapterId), nullptr, nullptr, nullptr },
        { "direct3_d11_device", reinterpret_cast<getter>(LearningModelDevice_get_Direct3D11Device), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_LearningModelDevice[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_LearningModelDevice) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_LearningModelDevice) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_LearningModelDevice) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_LearningModelDevice) },
        { },
    };

    static PyType_Spec type_spec_LearningModelDevice = {
        "winrt._winrt_windows_ai_machinelearning.LearningModelDevice",
        sizeof(py::wrapper::Windows::AI::MachineLearning::LearningModelDevice),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_LearningModelDevice};

    static PyGetSetDef getset_LearningModelDevice_Static[] = {
        { }
    };

    static PyMethodDef methods_LearningModelDevice_Static[] = {
        { "create_from_direct3_d11_device", reinterpret_cast<PyCFunction>(LearningModelDevice_CreateFromDirect3D11Device), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_LearningModelDevice_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_LearningModelDevice_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_LearningModelDevice_Static) },
        { }
    };

    static PyType_Spec type_spec_LearningModelDevice_Static =
    {
        "winrt._winrt_windows_ai_machinelearning.LearningModelDevice_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_LearningModelDevice_Static
    };

    // ----- LearningModelEvaluationResult class --------------------

    static PyObject* _new_LearningModelEvaluationResult(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::AI::MachineLearning::LearningModelEvaluationResult>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::AI::MachineLearning::LearningModelEvaluationResult>::type_name);
        return nullptr;
    }

    static void _dealloc_LearningModelEvaluationResult(py::wrapper::Windows::AI::MachineLearning::LearningModelEvaluationResult* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* LearningModelEvaluationResult_get_CorrelationId(py::wrapper::Windows::AI::MachineLearning::LearningModelEvaluationResult* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.AI.MachineLearning.LearningModelEvaluationResult", L"CorrelationId"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CorrelationId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LearningModelEvaluationResult_get_ErrorStatus(py::wrapper::Windows::AI::MachineLearning::LearningModelEvaluationResult* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.AI.MachineLearning.LearningModelEvaluationResult", L"ErrorStatus"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ErrorStatus());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LearningModelEvaluationResult_get_Outputs(py::wrapper::Windows::AI::MachineLearning::LearningModelEvaluationResult* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.AI.MachineLearning.LearningModelEvaluationResult", L"Outputs"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Outputs());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LearningModelEvaluationResult_get_Succeeded(py::wrapper::Windows::AI::MachineLearning::LearningModelEvaluationResult* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.AI.MachineLearning.LearningModelEvaluationResult", L"Succeeded"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Succeeded());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_LearningModelEvaluationResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::AI::MachineLearning::LearningModelEvaluationResult>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_LearningModelEvaluationResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::AI::MachineLearning::LearningModelEvaluationResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_LearningModelEvaluationResult[] = {
        { "_assign_array_", _assign_array_LearningModelEvaluationResult, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_LearningModelEvaluationResult), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_LearningModelEvaluationResult[] = {
        { "correlation_id", reinterpret_cast<getter>(LearningModelEvaluationResult_get_CorrelationId), nullptr, nullptr, nullptr },
        { "error_status", reinterpret_cast<getter>(LearningModelEvaluationResult_get_ErrorStatus), nullptr, nullptr, nullptr },
        { "outputs", reinterpret_cast<getter>(LearningModelEvaluationResult_get_Outputs), nullptr, nullptr, nullptr },
        { "succeeded", reinterpret_cast<getter>(LearningModelEvaluationResult_get_Succeeded), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_LearningModelEvaluationResult[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_LearningModelEvaluationResult) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_LearningModelEvaluationResult) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_LearningModelEvaluationResult) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_LearningModelEvaluationResult) },
        { },
    };

    static PyType_Spec type_spec_LearningModelEvaluationResult = {
        "winrt._winrt_windows_ai_machinelearning.LearningModelEvaluationResult",
        sizeof(py::wrapper::Windows::AI::MachineLearning::LearningModelEvaluationResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_LearningModelEvaluationResult};

    // ----- LearningModelSession class --------------------

    static PyObject* _new_LearningModelSession(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::AI::MachineLearning::LearningModel>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::AI::MachineLearning::LearningModelDevice>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::AI::MachineLearning::LearningModelSessionOptions>(args, 2);

                winrt::Windows::AI::MachineLearning::LearningModelSession instance{ param0, param1, param2 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::AI::MachineLearning::LearningModel>(args, 0);

                winrt::Windows::AI::MachineLearning::LearningModelSession instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::AI::MachineLearning::LearningModel>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::AI::MachineLearning::LearningModelDevice>(args, 1);

                winrt::Windows::AI::MachineLearning::LearningModelSession instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_LearningModelSession(py::wrapper::Windows::AI::MachineLearning::LearningModelSession* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* LearningModelSession_Close(py::wrapper::Windows::AI::MachineLearning::LearningModelSession* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.LearningModelSession", L"Close", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LearningModelSession_Evaluate(py::wrapper::Windows::AI::MachineLearning::LearningModelSession* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.LearningModelSession", L"Evaluate", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::AI::MachineLearning::LearningModelBinding>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(self->obj.Evaluate(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LearningModelSession_EvaluateAsync(py::wrapper::Windows::AI::MachineLearning::LearningModelSession* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.LearningModelSession", L"EvaluateAsync", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::AI::MachineLearning::LearningModelBinding>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(self->obj.EvaluateAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LearningModelSession_EvaluateFeatures(py::wrapper::Windows::AI::MachineLearning::LearningModelSession* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.LearningModelSession", L"EvaluateFeatures", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IMap<winrt::hstring, winrt::Windows::Foundation::IInspectable>>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(self->obj.EvaluateFeatures(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LearningModelSession_EvaluateFeaturesAsync(py::wrapper::Windows::AI::MachineLearning::LearningModelSession* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.LearningModelSession", L"EvaluateFeaturesAsync", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IMap<winrt::hstring, winrt::Windows::Foundation::IInspectable>>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(self->obj.EvaluateFeaturesAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LearningModelSession_get_Device(py::wrapper::Windows::AI::MachineLearning::LearningModelSession* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.AI.MachineLearning.LearningModelSession", L"Device"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Device());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LearningModelSession_get_EvaluationProperties(py::wrapper::Windows::AI::MachineLearning::LearningModelSession* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.AI.MachineLearning.LearningModelSession", L"EvaluationProperties"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.EvaluationProperties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LearningModelSession_get_Model(py::wrapper::Windows::AI::MachineLearning::LearningModelSession* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.AI.MachineLearning.LearningModelSession", L"Model"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Model());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_LearningModelSession(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::AI::MachineLearning::LearningModelSession>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_LearningModelSession(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::AI::MachineLearning::LearningModelSession>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_LearningModelSession(py::wrapper::Windows::AI::MachineLearning::LearningModelSession* self, PyObject* /*unused*/) noexcept
    {
        return Py_NewRef(self);
    }

    static PyObject* _exit_LearningModelSession(py::wrapper::Windows::AI::MachineLearning::LearningModelSession* self, PyObject* /*unused*/) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_LearningModelSession[] = {
        { "close", reinterpret_cast<PyCFunction>(LearningModelSession_Close), METH_VARARGS, nullptr },
        { "evaluate", reinterpret_cast<PyCFunction>(LearningModelSession_Evaluate), METH_VARARGS, nullptr },
        { "evaluate_async", reinterpret_cast<PyCFunction>(LearningModelSession_EvaluateAsync), METH_VARARGS, nullptr },
        { "evaluate_features", reinterpret_cast<PyCFunction>(LearningModelSession_EvaluateFeatures), METH_VARARGS, nullptr },
        { "evaluate_features_async", reinterpret_cast<PyCFunction>(LearningModelSession_EvaluateFeaturesAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_LearningModelSession, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_LearningModelSession), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_LearningModelSession), METH_NOARGS, nullptr },
        { "__exit__", reinterpret_cast<PyCFunction>(_exit_LearningModelSession), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_LearningModelSession[] = {
        { "device", reinterpret_cast<getter>(LearningModelSession_get_Device), nullptr, nullptr, nullptr },
        { "evaluation_properties", reinterpret_cast<getter>(LearningModelSession_get_EvaluationProperties), nullptr, nullptr, nullptr },
        { "model", reinterpret_cast<getter>(LearningModelSession_get_Model), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_LearningModelSession[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_LearningModelSession) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_LearningModelSession) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_LearningModelSession) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_LearningModelSession) },
        { },
    };

    static PyType_Spec type_spec_LearningModelSession = {
        "winrt._winrt_windows_ai_machinelearning.LearningModelSession",
        sizeof(py::wrapper::Windows::AI::MachineLearning::LearningModelSession),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_LearningModelSession};

    // ----- LearningModelSessionOptions class --------------------

    static PyObject* _new_LearningModelSessionOptions(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::AI::MachineLearning::LearningModelSessionOptions instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_LearningModelSessionOptions(py::wrapper::Windows::AI::MachineLearning::LearningModelSessionOptions* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* LearningModelSessionOptions_OverrideNamedDimension(py::wrapper::Windows::AI::MachineLearning::LearningModelSessionOptions* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.LearningModelSessionOptions", L"OverrideNamedDimension", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);

                self->obj.OverrideNamedDimension(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LearningModelSessionOptions_get_BatchSizeOverride(py::wrapper::Windows::AI::MachineLearning::LearningModelSessionOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.AI.MachineLearning.LearningModelSessionOptions", L"BatchSizeOverride"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.BatchSizeOverride());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LearningModelSessionOptions_put_BatchSizeOverride(py::wrapper::Windows::AI::MachineLearning::LearningModelSessionOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.AI.MachineLearning.LearningModelSessionOptions", L"BatchSizeOverride"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.BatchSizeOverride(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LearningModelSessionOptions_get_CloseModelOnSessionCreation(py::wrapper::Windows::AI::MachineLearning::LearningModelSessionOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.AI.MachineLearning.LearningModelSessionOptions", L"CloseModelOnSessionCreation"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CloseModelOnSessionCreation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LearningModelSessionOptions_put_CloseModelOnSessionCreation(py::wrapper::Windows::AI::MachineLearning::LearningModelSessionOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.AI.MachineLearning.LearningModelSessionOptions", L"CloseModelOnSessionCreation"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.CloseModelOnSessionCreation(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_LearningModelSessionOptions(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::AI::MachineLearning::LearningModelSessionOptions>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_LearningModelSessionOptions(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::AI::MachineLearning::LearningModelSessionOptions>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_LearningModelSessionOptions[] = {
        { "override_named_dimension", reinterpret_cast<PyCFunction>(LearningModelSessionOptions_OverrideNamedDimension), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_LearningModelSessionOptions, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_LearningModelSessionOptions), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_LearningModelSessionOptions[] = {
        { "batch_size_override", reinterpret_cast<getter>(LearningModelSessionOptions_get_BatchSizeOverride), reinterpret_cast<setter>(LearningModelSessionOptions_put_BatchSizeOverride), nullptr, nullptr },
        { "close_model_on_session_creation", reinterpret_cast<getter>(LearningModelSessionOptions_get_CloseModelOnSessionCreation), reinterpret_cast<setter>(LearningModelSessionOptions_put_CloseModelOnSessionCreation), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_LearningModelSessionOptions[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_LearningModelSessionOptions) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_LearningModelSessionOptions) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_LearningModelSessionOptions) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_LearningModelSessionOptions) },
        { },
    };

    static PyType_Spec type_spec_LearningModelSessionOptions = {
        "winrt._winrt_windows_ai_machinelearning.LearningModelSessionOptions",
        sizeof(py::wrapper::Windows::AI::MachineLearning::LearningModelSessionOptions),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_LearningModelSessionOptions};

    // ----- MapFeatureDescriptor class --------------------

    static PyObject* _new_MapFeatureDescriptor(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::AI::MachineLearning::MapFeatureDescriptor>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::AI::MachineLearning::MapFeatureDescriptor>::type_name);
        return nullptr;
    }

    static void _dealloc_MapFeatureDescriptor(py::wrapper::Windows::AI::MachineLearning::MapFeatureDescriptor* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MapFeatureDescriptor_get_Description(py::wrapper::Windows::AI::MachineLearning::MapFeatureDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.AI.MachineLearning.MapFeatureDescriptor", L"Description"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Description());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapFeatureDescriptor_get_IsRequired(py::wrapper::Windows::AI::MachineLearning::MapFeatureDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.AI.MachineLearning.MapFeatureDescriptor", L"IsRequired"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsRequired());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapFeatureDescriptor_get_Kind(py::wrapper::Windows::AI::MachineLearning::MapFeatureDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.AI.MachineLearning.MapFeatureDescriptor", L"Kind"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapFeatureDescriptor_get_Name(py::wrapper::Windows::AI::MachineLearning::MapFeatureDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.AI.MachineLearning.MapFeatureDescriptor", L"Name"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Name());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapFeatureDescriptor_get_KeyKind(py::wrapper::Windows::AI::MachineLearning::MapFeatureDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.AI.MachineLearning.MapFeatureDescriptor", L"KeyKind"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.KeyKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapFeatureDescriptor_get_ValueDescriptor(py::wrapper::Windows::AI::MachineLearning::MapFeatureDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.AI.MachineLearning.MapFeatureDescriptor", L"ValueDescriptor"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ValueDescriptor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MapFeatureDescriptor(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::AI::MachineLearning::MapFeatureDescriptor>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MapFeatureDescriptor(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::AI::MachineLearning::MapFeatureDescriptor>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MapFeatureDescriptor[] = {
        { "_assign_array_", _assign_array_MapFeatureDescriptor, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MapFeatureDescriptor), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MapFeatureDescriptor[] = {
        { "description", reinterpret_cast<getter>(MapFeatureDescriptor_get_Description), nullptr, nullptr, nullptr },
        { "is_required", reinterpret_cast<getter>(MapFeatureDescriptor_get_IsRequired), nullptr, nullptr, nullptr },
        { "kind", reinterpret_cast<getter>(MapFeatureDescriptor_get_Kind), nullptr, nullptr, nullptr },
        { "name", reinterpret_cast<getter>(MapFeatureDescriptor_get_Name), nullptr, nullptr, nullptr },
        { "key_kind", reinterpret_cast<getter>(MapFeatureDescriptor_get_KeyKind), nullptr, nullptr, nullptr },
        { "value_descriptor", reinterpret_cast<getter>(MapFeatureDescriptor_get_ValueDescriptor), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MapFeatureDescriptor[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MapFeatureDescriptor) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MapFeatureDescriptor) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MapFeatureDescriptor) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MapFeatureDescriptor) },
        { },
    };

    static PyType_Spec type_spec_MapFeatureDescriptor = {
        "winrt._winrt_windows_ai_machinelearning.MapFeatureDescriptor",
        sizeof(py::wrapper::Windows::AI::MachineLearning::MapFeatureDescriptor),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MapFeatureDescriptor};

    // ----- SequenceFeatureDescriptor class --------------------

    static PyObject* _new_SequenceFeatureDescriptor(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::AI::MachineLearning::SequenceFeatureDescriptor>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::AI::MachineLearning::SequenceFeatureDescriptor>::type_name);
        return nullptr;
    }

    static void _dealloc_SequenceFeatureDescriptor(py::wrapper::Windows::AI::MachineLearning::SequenceFeatureDescriptor* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SequenceFeatureDescriptor_get_Description(py::wrapper::Windows::AI::MachineLearning::SequenceFeatureDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.AI.MachineLearning.SequenceFeatureDescriptor", L"Description"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Description());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SequenceFeatureDescriptor_get_IsRequired(py::wrapper::Windows::AI::MachineLearning::SequenceFeatureDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.AI.MachineLearning.SequenceFeatureDescriptor", L"IsRequired"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsRequired());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SequenceFeatureDescriptor_get_Kind(py::wrapper::Windows::AI::MachineLearning::SequenceFeatureDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.AI.MachineLearning.SequenceFeatureDescriptor", L"Kind"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SequenceFeatureDescriptor_get_Name(py::wrapper::Windows::AI::MachineLearning::SequenceFeatureDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.AI.MachineLearning.SequenceFeatureDescriptor", L"Name"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Name());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SequenceFeatureDescriptor_get_ElementDescriptor(py::wrapper::Windows::AI::MachineLearning::SequenceFeatureDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.AI.MachineLearning.SequenceFeatureDescriptor", L"ElementDescriptor"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ElementDescriptor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SequenceFeatureDescriptor(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::AI::MachineLearning::SequenceFeatureDescriptor>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SequenceFeatureDescriptor(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::AI::MachineLearning::SequenceFeatureDescriptor>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SequenceFeatureDescriptor[] = {
        { "_assign_array_", _assign_array_SequenceFeatureDescriptor, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SequenceFeatureDescriptor), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SequenceFeatureDescriptor[] = {
        { "description", reinterpret_cast<getter>(SequenceFeatureDescriptor_get_Description), nullptr, nullptr, nullptr },
        { "is_required", reinterpret_cast<getter>(SequenceFeatureDescriptor_get_IsRequired), nullptr, nullptr, nullptr },
        { "kind", reinterpret_cast<getter>(SequenceFeatureDescriptor_get_Kind), nullptr, nullptr, nullptr },
        { "name", reinterpret_cast<getter>(SequenceFeatureDescriptor_get_Name), nullptr, nullptr, nullptr },
        { "element_descriptor", reinterpret_cast<getter>(SequenceFeatureDescriptor_get_ElementDescriptor), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SequenceFeatureDescriptor[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SequenceFeatureDescriptor) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SequenceFeatureDescriptor) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SequenceFeatureDescriptor) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SequenceFeatureDescriptor) },
        { },
    };

    static PyType_Spec type_spec_SequenceFeatureDescriptor = {
        "winrt._winrt_windows_ai_machinelearning.SequenceFeatureDescriptor",
        sizeof(py::wrapper::Windows::AI::MachineLearning::SequenceFeatureDescriptor),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SequenceFeatureDescriptor};

    // ----- TensorBoolean class --------------------

    static PyObject* _new_TensorBoolean(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::AI::MachineLearning::TensorBoolean>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::AI::MachineLearning::TensorBoolean>::type_name);
        return nullptr;
    }

    static void _dealloc_TensorBoolean(py::wrapper::Windows::AI::MachineLearning::TensorBoolean* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* TensorBoolean_Close(py::wrapper::Windows::AI::MachineLearning::TensorBoolean* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.TensorBoolean", L"Close", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorBoolean_Create(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.TensorBoolean", L"Create", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(winrt::Windows::AI::MachineLearning::TensorBoolean::Create());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.TensorBoolean", L"Create", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<int64_t>>(args, 0);

                return py::convert(winrt::Windows::AI::MachineLearning::TensorBoolean::Create(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorBoolean_CreateFromArray(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.TensorBoolean", L"CreateFromArray", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<int64_t>>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<bool, false>>(args, 1);

                return py::convert(winrt::Windows::AI::MachineLearning::TensorBoolean::CreateFromArray(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorBoolean_CreateFromBuffer(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.TensorBoolean", L"CreateFromBuffer", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<py::pybuf_view<int64_t, false>>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 1);

                return py::convert(winrt::Windows::AI::MachineLearning::TensorBoolean::CreateFromBuffer(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorBoolean_CreateFromIterable(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.TensorBoolean", L"CreateFromIterable", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<int64_t>>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<bool>>(args, 1);

                return py::convert(winrt::Windows::AI::MachineLearning::TensorBoolean::CreateFromIterable(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorBoolean_CreateFromShapeArrayAndDataArray(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.TensorBoolean", L"CreateFromShapeArrayAndDataArray", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<py::pybuf_view<int64_t, false>>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<bool, false>>(args, 1);

                return py::convert(winrt::Windows::AI::MachineLearning::TensorBoolean::CreateFromShapeArrayAndDataArray(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorBoolean_CreateReference(py::wrapper::Windows::AI::MachineLearning::TensorBoolean* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.TensorBoolean", L"CreateReference", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.CreateReference());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorBoolean_GetAsVectorView(py::wrapper::Windows::AI::MachineLearning::TensorBoolean* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.TensorBoolean", L"GetAsVectorView", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetAsVectorView());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorBoolean_get_Kind(py::wrapper::Windows::AI::MachineLearning::TensorBoolean* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.AI.MachineLearning.TensorBoolean", L"Kind"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TensorBoolean_get_Shape(py::wrapper::Windows::AI::MachineLearning::TensorBoolean* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.AI.MachineLearning.TensorBoolean", L"Shape"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Shape());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TensorBoolean_get_TensorKind(py::wrapper::Windows::AI::MachineLearning::TensorBoolean* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.AI.MachineLearning.TensorBoolean", L"TensorKind"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.TensorKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_TensorBoolean(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::AI::MachineLearning::TensorBoolean>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_TensorBoolean(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::AI::MachineLearning::TensorBoolean>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_TensorBoolean(py::wrapper::Windows::AI::MachineLearning::TensorBoolean* self, PyObject* /*unused*/) noexcept
    {
        return Py_NewRef(self);
    }

    static PyObject* _exit_TensorBoolean(py::wrapper::Windows::AI::MachineLearning::TensorBoolean* self, PyObject* /*unused*/) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TensorBoolean[] = {
        { "close", reinterpret_cast<PyCFunction>(TensorBoolean_Close), METH_VARARGS, nullptr },
        { "create_reference", reinterpret_cast<PyCFunction>(TensorBoolean_CreateReference), METH_VARARGS, nullptr },
        { "get_as_vector_view", reinterpret_cast<PyCFunction>(TensorBoolean_GetAsVectorView), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_TensorBoolean, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_TensorBoolean), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_TensorBoolean), METH_NOARGS, nullptr },
        { "__exit__", reinterpret_cast<PyCFunction>(_exit_TensorBoolean), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_TensorBoolean[] = {
        { "kind", reinterpret_cast<getter>(TensorBoolean_get_Kind), nullptr, nullptr, nullptr },
        { "shape", reinterpret_cast<getter>(TensorBoolean_get_Shape), nullptr, nullptr, nullptr },
        { "tensor_kind", reinterpret_cast<getter>(TensorBoolean_get_TensorKind), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_TensorBoolean[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_TensorBoolean) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_TensorBoolean) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_TensorBoolean) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_TensorBoolean) },
        { },
    };

    static PyType_Spec type_spec_TensorBoolean = {
        "winrt._winrt_windows_ai_machinelearning.TensorBoolean",
        sizeof(py::wrapper::Windows::AI::MachineLearning::TensorBoolean),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TensorBoolean};

    static PyGetSetDef getset_TensorBoolean_Static[] = {
        { }
    };

    static PyMethodDef methods_TensorBoolean_Static[] = {
        { "create", reinterpret_cast<PyCFunction>(TensorBoolean_Create), METH_VARARGS, nullptr },
        { "create_from_array", reinterpret_cast<PyCFunction>(TensorBoolean_CreateFromArray), METH_VARARGS, nullptr },
        { "create_from_buffer", reinterpret_cast<PyCFunction>(TensorBoolean_CreateFromBuffer), METH_VARARGS, nullptr },
        { "create_from_iterable", reinterpret_cast<PyCFunction>(TensorBoolean_CreateFromIterable), METH_VARARGS, nullptr },
        { "create_from_shape_array_and_data_array", reinterpret_cast<PyCFunction>(TensorBoolean_CreateFromShapeArrayAndDataArray), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_TensorBoolean_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_TensorBoolean_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_TensorBoolean_Static) },
        { }
    };

    static PyType_Spec type_spec_TensorBoolean_Static =
    {
        "winrt._winrt_windows_ai_machinelearning.TensorBoolean_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_TensorBoolean_Static
    };

    // ----- TensorDouble class --------------------

    static PyObject* _new_TensorDouble(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::AI::MachineLearning::TensorDouble>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::AI::MachineLearning::TensorDouble>::type_name);
        return nullptr;
    }

    static void _dealloc_TensorDouble(py::wrapper::Windows::AI::MachineLearning::TensorDouble* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* TensorDouble_Close(py::wrapper::Windows::AI::MachineLearning::TensorDouble* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.TensorDouble", L"Close", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorDouble_Create(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.TensorDouble", L"Create", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(winrt::Windows::AI::MachineLearning::TensorDouble::Create());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.TensorDouble", L"Create", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<int64_t>>(args, 0);

                return py::convert(winrt::Windows::AI::MachineLearning::TensorDouble::Create(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorDouble_CreateFromArray(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.TensorDouble", L"CreateFromArray", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<int64_t>>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<double, false>>(args, 1);

                return py::convert(winrt::Windows::AI::MachineLearning::TensorDouble::CreateFromArray(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorDouble_CreateFromBuffer(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.TensorDouble", L"CreateFromBuffer", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<py::pybuf_view<int64_t, false>>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 1);

                return py::convert(winrt::Windows::AI::MachineLearning::TensorDouble::CreateFromBuffer(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorDouble_CreateFromIterable(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.TensorDouble", L"CreateFromIterable", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<int64_t>>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<double>>(args, 1);

                return py::convert(winrt::Windows::AI::MachineLearning::TensorDouble::CreateFromIterable(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorDouble_CreateFromShapeArrayAndDataArray(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.TensorDouble", L"CreateFromShapeArrayAndDataArray", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<py::pybuf_view<int64_t, false>>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<double, false>>(args, 1);

                return py::convert(winrt::Windows::AI::MachineLearning::TensorDouble::CreateFromShapeArrayAndDataArray(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorDouble_CreateReference(py::wrapper::Windows::AI::MachineLearning::TensorDouble* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.TensorDouble", L"CreateReference", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.CreateReference());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorDouble_GetAsVectorView(py::wrapper::Windows::AI::MachineLearning::TensorDouble* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.TensorDouble", L"GetAsVectorView", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetAsVectorView());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorDouble_get_Kind(py::wrapper::Windows::AI::MachineLearning::TensorDouble* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.AI.MachineLearning.TensorDouble", L"Kind"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TensorDouble_get_Shape(py::wrapper::Windows::AI::MachineLearning::TensorDouble* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.AI.MachineLearning.TensorDouble", L"Shape"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Shape());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TensorDouble_get_TensorKind(py::wrapper::Windows::AI::MachineLearning::TensorDouble* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.AI.MachineLearning.TensorDouble", L"TensorKind"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.TensorKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_TensorDouble(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::AI::MachineLearning::TensorDouble>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_TensorDouble(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::AI::MachineLearning::TensorDouble>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_TensorDouble(py::wrapper::Windows::AI::MachineLearning::TensorDouble* self, PyObject* /*unused*/) noexcept
    {
        return Py_NewRef(self);
    }

    static PyObject* _exit_TensorDouble(py::wrapper::Windows::AI::MachineLearning::TensorDouble* self, PyObject* /*unused*/) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TensorDouble[] = {
        { "close", reinterpret_cast<PyCFunction>(TensorDouble_Close), METH_VARARGS, nullptr },
        { "create_reference", reinterpret_cast<PyCFunction>(TensorDouble_CreateReference), METH_VARARGS, nullptr },
        { "get_as_vector_view", reinterpret_cast<PyCFunction>(TensorDouble_GetAsVectorView), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_TensorDouble, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_TensorDouble), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_TensorDouble), METH_NOARGS, nullptr },
        { "__exit__", reinterpret_cast<PyCFunction>(_exit_TensorDouble), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_TensorDouble[] = {
        { "kind", reinterpret_cast<getter>(TensorDouble_get_Kind), nullptr, nullptr, nullptr },
        { "shape", reinterpret_cast<getter>(TensorDouble_get_Shape), nullptr, nullptr, nullptr },
        { "tensor_kind", reinterpret_cast<getter>(TensorDouble_get_TensorKind), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_TensorDouble[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_TensorDouble) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_TensorDouble) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_TensorDouble) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_TensorDouble) },
        { },
    };

    static PyType_Spec type_spec_TensorDouble = {
        "winrt._winrt_windows_ai_machinelearning.TensorDouble",
        sizeof(py::wrapper::Windows::AI::MachineLearning::TensorDouble),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TensorDouble};

    static PyGetSetDef getset_TensorDouble_Static[] = {
        { }
    };

    static PyMethodDef methods_TensorDouble_Static[] = {
        { "create", reinterpret_cast<PyCFunction>(TensorDouble_Create), METH_VARARGS, nullptr },
        { "create_from_array", reinterpret_cast<PyCFunction>(TensorDouble_CreateFromArray), METH_VARARGS, nullptr },
        { "create_from_buffer", reinterpret_cast<PyCFunction>(TensorDouble_CreateFromBuffer), METH_VARARGS, nullptr },
        { "create_from_iterable", reinterpret_cast<PyCFunction>(TensorDouble_CreateFromIterable), METH_VARARGS, nullptr },
        { "create_from_shape_array_and_data_array", reinterpret_cast<PyCFunction>(TensorDouble_CreateFromShapeArrayAndDataArray), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_TensorDouble_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_TensorDouble_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_TensorDouble_Static) },
        { }
    };

    static PyType_Spec type_spec_TensorDouble_Static =
    {
        "winrt._winrt_windows_ai_machinelearning.TensorDouble_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_TensorDouble_Static
    };

    // ----- TensorFeatureDescriptor class --------------------

    static PyObject* _new_TensorFeatureDescriptor(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::AI::MachineLearning::TensorFeatureDescriptor>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::AI::MachineLearning::TensorFeatureDescriptor>::type_name);
        return nullptr;
    }

    static void _dealloc_TensorFeatureDescriptor(py::wrapper::Windows::AI::MachineLearning::TensorFeatureDescriptor* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* TensorFeatureDescriptor_get_Description(py::wrapper::Windows::AI::MachineLearning::TensorFeatureDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.AI.MachineLearning.TensorFeatureDescriptor", L"Description"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Description());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TensorFeatureDescriptor_get_IsRequired(py::wrapper::Windows::AI::MachineLearning::TensorFeatureDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.AI.MachineLearning.TensorFeatureDescriptor", L"IsRequired"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsRequired());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TensorFeatureDescriptor_get_Kind(py::wrapper::Windows::AI::MachineLearning::TensorFeatureDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.AI.MachineLearning.TensorFeatureDescriptor", L"Kind"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TensorFeatureDescriptor_get_Name(py::wrapper::Windows::AI::MachineLearning::TensorFeatureDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.AI.MachineLearning.TensorFeatureDescriptor", L"Name"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Name());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TensorFeatureDescriptor_get_Shape(py::wrapper::Windows::AI::MachineLearning::TensorFeatureDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.AI.MachineLearning.TensorFeatureDescriptor", L"Shape"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Shape());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TensorFeatureDescriptor_get_TensorKind(py::wrapper::Windows::AI::MachineLearning::TensorFeatureDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.AI.MachineLearning.TensorFeatureDescriptor", L"TensorKind"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.TensorKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_TensorFeatureDescriptor(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::AI::MachineLearning::TensorFeatureDescriptor>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_TensorFeatureDescriptor(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::AI::MachineLearning::TensorFeatureDescriptor>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TensorFeatureDescriptor[] = {
        { "_assign_array_", _assign_array_TensorFeatureDescriptor, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_TensorFeatureDescriptor), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_TensorFeatureDescriptor[] = {
        { "description", reinterpret_cast<getter>(TensorFeatureDescriptor_get_Description), nullptr, nullptr, nullptr },
        { "is_required", reinterpret_cast<getter>(TensorFeatureDescriptor_get_IsRequired), nullptr, nullptr, nullptr },
        { "kind", reinterpret_cast<getter>(TensorFeatureDescriptor_get_Kind), nullptr, nullptr, nullptr },
        { "name", reinterpret_cast<getter>(TensorFeatureDescriptor_get_Name), nullptr, nullptr, nullptr },
        { "shape", reinterpret_cast<getter>(TensorFeatureDescriptor_get_Shape), nullptr, nullptr, nullptr },
        { "tensor_kind", reinterpret_cast<getter>(TensorFeatureDescriptor_get_TensorKind), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_TensorFeatureDescriptor[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_TensorFeatureDescriptor) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_TensorFeatureDescriptor) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_TensorFeatureDescriptor) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_TensorFeatureDescriptor) },
        { },
    };

    static PyType_Spec type_spec_TensorFeatureDescriptor = {
        "winrt._winrt_windows_ai_machinelearning.TensorFeatureDescriptor",
        sizeof(py::wrapper::Windows::AI::MachineLearning::TensorFeatureDescriptor),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TensorFeatureDescriptor};

    // ----- TensorFloat class --------------------

    static PyObject* _new_TensorFloat(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::AI::MachineLearning::TensorFloat>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::AI::MachineLearning::TensorFloat>::type_name);
        return nullptr;
    }

    static void _dealloc_TensorFloat(py::wrapper::Windows::AI::MachineLearning::TensorFloat* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* TensorFloat_Close(py::wrapper::Windows::AI::MachineLearning::TensorFloat* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.TensorFloat", L"Close", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorFloat_Create(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.TensorFloat", L"Create", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(winrt::Windows::AI::MachineLearning::TensorFloat::Create());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.TensorFloat", L"Create", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<int64_t>>(args, 0);

                return py::convert(winrt::Windows::AI::MachineLearning::TensorFloat::Create(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorFloat_CreateFromArray(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.TensorFloat", L"CreateFromArray", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<int64_t>>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<float, false>>(args, 1);

                return py::convert(winrt::Windows::AI::MachineLearning::TensorFloat::CreateFromArray(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorFloat_CreateFromBuffer(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.TensorFloat", L"CreateFromBuffer", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<py::pybuf_view<int64_t, false>>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 1);

                return py::convert(winrt::Windows::AI::MachineLearning::TensorFloat::CreateFromBuffer(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorFloat_CreateFromIterable(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.TensorFloat", L"CreateFromIterable", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<int64_t>>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<float>>(args, 1);

                return py::convert(winrt::Windows::AI::MachineLearning::TensorFloat::CreateFromIterable(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorFloat_CreateFromShapeArrayAndDataArray(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.TensorFloat", L"CreateFromShapeArrayAndDataArray", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<py::pybuf_view<int64_t, false>>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<float, false>>(args, 1);

                return py::convert(winrt::Windows::AI::MachineLearning::TensorFloat::CreateFromShapeArrayAndDataArray(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorFloat_CreateReference(py::wrapper::Windows::AI::MachineLearning::TensorFloat* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.TensorFloat", L"CreateReference", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.CreateReference());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorFloat_GetAsVectorView(py::wrapper::Windows::AI::MachineLearning::TensorFloat* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.TensorFloat", L"GetAsVectorView", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetAsVectorView());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorFloat_get_Kind(py::wrapper::Windows::AI::MachineLearning::TensorFloat* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.AI.MachineLearning.TensorFloat", L"Kind"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TensorFloat_get_Shape(py::wrapper::Windows::AI::MachineLearning::TensorFloat* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.AI.MachineLearning.TensorFloat", L"Shape"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Shape());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TensorFloat_get_TensorKind(py::wrapper::Windows::AI::MachineLearning::TensorFloat* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.AI.MachineLearning.TensorFloat", L"TensorKind"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.TensorKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_TensorFloat(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::AI::MachineLearning::TensorFloat>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_TensorFloat(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::AI::MachineLearning::TensorFloat>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_TensorFloat(py::wrapper::Windows::AI::MachineLearning::TensorFloat* self, PyObject* /*unused*/) noexcept
    {
        return Py_NewRef(self);
    }

    static PyObject* _exit_TensorFloat(py::wrapper::Windows::AI::MachineLearning::TensorFloat* self, PyObject* /*unused*/) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TensorFloat[] = {
        { "close", reinterpret_cast<PyCFunction>(TensorFloat_Close), METH_VARARGS, nullptr },
        { "create_reference", reinterpret_cast<PyCFunction>(TensorFloat_CreateReference), METH_VARARGS, nullptr },
        { "get_as_vector_view", reinterpret_cast<PyCFunction>(TensorFloat_GetAsVectorView), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_TensorFloat, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_TensorFloat), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_TensorFloat), METH_NOARGS, nullptr },
        { "__exit__", reinterpret_cast<PyCFunction>(_exit_TensorFloat), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_TensorFloat[] = {
        { "kind", reinterpret_cast<getter>(TensorFloat_get_Kind), nullptr, nullptr, nullptr },
        { "shape", reinterpret_cast<getter>(TensorFloat_get_Shape), nullptr, nullptr, nullptr },
        { "tensor_kind", reinterpret_cast<getter>(TensorFloat_get_TensorKind), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_TensorFloat[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_TensorFloat) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_TensorFloat) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_TensorFloat) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_TensorFloat) },
        { },
    };

    static PyType_Spec type_spec_TensorFloat = {
        "winrt._winrt_windows_ai_machinelearning.TensorFloat",
        sizeof(py::wrapper::Windows::AI::MachineLearning::TensorFloat),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TensorFloat};

    static PyGetSetDef getset_TensorFloat_Static[] = {
        { }
    };

    static PyMethodDef methods_TensorFloat_Static[] = {
        { "create", reinterpret_cast<PyCFunction>(TensorFloat_Create), METH_VARARGS, nullptr },
        { "create_from_array", reinterpret_cast<PyCFunction>(TensorFloat_CreateFromArray), METH_VARARGS, nullptr },
        { "create_from_buffer", reinterpret_cast<PyCFunction>(TensorFloat_CreateFromBuffer), METH_VARARGS, nullptr },
        { "create_from_iterable", reinterpret_cast<PyCFunction>(TensorFloat_CreateFromIterable), METH_VARARGS, nullptr },
        { "create_from_shape_array_and_data_array", reinterpret_cast<PyCFunction>(TensorFloat_CreateFromShapeArrayAndDataArray), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_TensorFloat_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_TensorFloat_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_TensorFloat_Static) },
        { }
    };

    static PyType_Spec type_spec_TensorFloat_Static =
    {
        "winrt._winrt_windows_ai_machinelearning.TensorFloat_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_TensorFloat_Static
    };

    // ----- TensorFloat16Bit class --------------------

    static PyObject* _new_TensorFloat16Bit(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::AI::MachineLearning::TensorFloat16Bit>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::AI::MachineLearning::TensorFloat16Bit>::type_name);
        return nullptr;
    }

    static void _dealloc_TensorFloat16Bit(py::wrapper::Windows::AI::MachineLearning::TensorFloat16Bit* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* TensorFloat16Bit_Close(py::wrapper::Windows::AI::MachineLearning::TensorFloat16Bit* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.TensorFloat16Bit", L"Close", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorFloat16Bit_Create(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.TensorFloat16Bit", L"Create", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(winrt::Windows::AI::MachineLearning::TensorFloat16Bit::Create());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.TensorFloat16Bit", L"Create", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<int64_t>>(args, 0);

                return py::convert(winrt::Windows::AI::MachineLearning::TensorFloat16Bit::Create(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorFloat16Bit_CreateFromArray(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.TensorFloat16Bit", L"CreateFromArray", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<int64_t>>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<float, false>>(args, 1);

                return py::convert(winrt::Windows::AI::MachineLearning::TensorFloat16Bit::CreateFromArray(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorFloat16Bit_CreateFromBuffer(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.TensorFloat16Bit", L"CreateFromBuffer", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<py::pybuf_view<int64_t, false>>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 1);

                return py::convert(winrt::Windows::AI::MachineLearning::TensorFloat16Bit::CreateFromBuffer(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorFloat16Bit_CreateFromIterable(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.TensorFloat16Bit", L"CreateFromIterable", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<int64_t>>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<float>>(args, 1);

                return py::convert(winrt::Windows::AI::MachineLearning::TensorFloat16Bit::CreateFromIterable(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorFloat16Bit_CreateFromShapeArrayAndDataArray(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.TensorFloat16Bit", L"CreateFromShapeArrayAndDataArray", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<py::pybuf_view<int64_t, false>>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<float, false>>(args, 1);

                return py::convert(winrt::Windows::AI::MachineLearning::TensorFloat16Bit::CreateFromShapeArrayAndDataArray(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorFloat16Bit_CreateReference(py::wrapper::Windows::AI::MachineLearning::TensorFloat16Bit* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.TensorFloat16Bit", L"CreateReference", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.CreateReference());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorFloat16Bit_GetAsVectorView(py::wrapper::Windows::AI::MachineLearning::TensorFloat16Bit* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.TensorFloat16Bit", L"GetAsVectorView", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetAsVectorView());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorFloat16Bit_get_Kind(py::wrapper::Windows::AI::MachineLearning::TensorFloat16Bit* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.AI.MachineLearning.TensorFloat16Bit", L"Kind"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TensorFloat16Bit_get_Shape(py::wrapper::Windows::AI::MachineLearning::TensorFloat16Bit* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.AI.MachineLearning.TensorFloat16Bit", L"Shape"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Shape());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TensorFloat16Bit_get_TensorKind(py::wrapper::Windows::AI::MachineLearning::TensorFloat16Bit* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.AI.MachineLearning.TensorFloat16Bit", L"TensorKind"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.TensorKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_TensorFloat16Bit(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::AI::MachineLearning::TensorFloat16Bit>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_TensorFloat16Bit(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::AI::MachineLearning::TensorFloat16Bit>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_TensorFloat16Bit(py::wrapper::Windows::AI::MachineLearning::TensorFloat16Bit* self, PyObject* /*unused*/) noexcept
    {
        return Py_NewRef(self);
    }

    static PyObject* _exit_TensorFloat16Bit(py::wrapper::Windows::AI::MachineLearning::TensorFloat16Bit* self, PyObject* /*unused*/) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TensorFloat16Bit[] = {
        { "close", reinterpret_cast<PyCFunction>(TensorFloat16Bit_Close), METH_VARARGS, nullptr },
        { "create_reference", reinterpret_cast<PyCFunction>(TensorFloat16Bit_CreateReference), METH_VARARGS, nullptr },
        { "get_as_vector_view", reinterpret_cast<PyCFunction>(TensorFloat16Bit_GetAsVectorView), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_TensorFloat16Bit, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_TensorFloat16Bit), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_TensorFloat16Bit), METH_NOARGS, nullptr },
        { "__exit__", reinterpret_cast<PyCFunction>(_exit_TensorFloat16Bit), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_TensorFloat16Bit[] = {
        { "kind", reinterpret_cast<getter>(TensorFloat16Bit_get_Kind), nullptr, nullptr, nullptr },
        { "shape", reinterpret_cast<getter>(TensorFloat16Bit_get_Shape), nullptr, nullptr, nullptr },
        { "tensor_kind", reinterpret_cast<getter>(TensorFloat16Bit_get_TensorKind), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_TensorFloat16Bit[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_TensorFloat16Bit) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_TensorFloat16Bit) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_TensorFloat16Bit) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_TensorFloat16Bit) },
        { },
    };

    static PyType_Spec type_spec_TensorFloat16Bit = {
        "winrt._winrt_windows_ai_machinelearning.TensorFloat16Bit",
        sizeof(py::wrapper::Windows::AI::MachineLearning::TensorFloat16Bit),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TensorFloat16Bit};

    static PyGetSetDef getset_TensorFloat16Bit_Static[] = {
        { }
    };

    static PyMethodDef methods_TensorFloat16Bit_Static[] = {
        { "create", reinterpret_cast<PyCFunction>(TensorFloat16Bit_Create), METH_VARARGS, nullptr },
        { "create_from_array", reinterpret_cast<PyCFunction>(TensorFloat16Bit_CreateFromArray), METH_VARARGS, nullptr },
        { "create_from_buffer", reinterpret_cast<PyCFunction>(TensorFloat16Bit_CreateFromBuffer), METH_VARARGS, nullptr },
        { "create_from_iterable", reinterpret_cast<PyCFunction>(TensorFloat16Bit_CreateFromIterable), METH_VARARGS, nullptr },
        { "create_from_shape_array_and_data_array", reinterpret_cast<PyCFunction>(TensorFloat16Bit_CreateFromShapeArrayAndDataArray), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_TensorFloat16Bit_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_TensorFloat16Bit_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_TensorFloat16Bit_Static) },
        { }
    };

    static PyType_Spec type_spec_TensorFloat16Bit_Static =
    {
        "winrt._winrt_windows_ai_machinelearning.TensorFloat16Bit_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_TensorFloat16Bit_Static
    };

    // ----- TensorInt16Bit class --------------------

    static PyObject* _new_TensorInt16Bit(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::AI::MachineLearning::TensorInt16Bit>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::AI::MachineLearning::TensorInt16Bit>::type_name);
        return nullptr;
    }

    static void _dealloc_TensorInt16Bit(py::wrapper::Windows::AI::MachineLearning::TensorInt16Bit* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* TensorInt16Bit_Close(py::wrapper::Windows::AI::MachineLearning::TensorInt16Bit* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.TensorInt16Bit", L"Close", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorInt16Bit_Create(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.TensorInt16Bit", L"Create", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(winrt::Windows::AI::MachineLearning::TensorInt16Bit::Create());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.TensorInt16Bit", L"Create", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<int64_t>>(args, 0);

                return py::convert(winrt::Windows::AI::MachineLearning::TensorInt16Bit::Create(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorInt16Bit_CreateFromArray(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.TensorInt16Bit", L"CreateFromArray", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<int64_t>>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<int16_t, false>>(args, 1);

                return py::convert(winrt::Windows::AI::MachineLearning::TensorInt16Bit::CreateFromArray(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorInt16Bit_CreateFromBuffer(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.TensorInt16Bit", L"CreateFromBuffer", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<py::pybuf_view<int64_t, false>>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 1);

                return py::convert(winrt::Windows::AI::MachineLearning::TensorInt16Bit::CreateFromBuffer(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorInt16Bit_CreateFromIterable(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.TensorInt16Bit", L"CreateFromIterable", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<int64_t>>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<int16_t>>(args, 1);

                return py::convert(winrt::Windows::AI::MachineLearning::TensorInt16Bit::CreateFromIterable(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorInt16Bit_CreateFromShapeArrayAndDataArray(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.TensorInt16Bit", L"CreateFromShapeArrayAndDataArray", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<py::pybuf_view<int64_t, false>>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<int16_t, false>>(args, 1);

                return py::convert(winrt::Windows::AI::MachineLearning::TensorInt16Bit::CreateFromShapeArrayAndDataArray(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorInt16Bit_CreateReference(py::wrapper::Windows::AI::MachineLearning::TensorInt16Bit* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.TensorInt16Bit", L"CreateReference", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.CreateReference());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorInt16Bit_GetAsVectorView(py::wrapper::Windows::AI::MachineLearning::TensorInt16Bit* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.TensorInt16Bit", L"GetAsVectorView", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetAsVectorView());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorInt16Bit_get_Kind(py::wrapper::Windows::AI::MachineLearning::TensorInt16Bit* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.AI.MachineLearning.TensorInt16Bit", L"Kind"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TensorInt16Bit_get_Shape(py::wrapper::Windows::AI::MachineLearning::TensorInt16Bit* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.AI.MachineLearning.TensorInt16Bit", L"Shape"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Shape());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TensorInt16Bit_get_TensorKind(py::wrapper::Windows::AI::MachineLearning::TensorInt16Bit* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.AI.MachineLearning.TensorInt16Bit", L"TensorKind"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.TensorKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_TensorInt16Bit(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::AI::MachineLearning::TensorInt16Bit>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_TensorInt16Bit(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::AI::MachineLearning::TensorInt16Bit>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_TensorInt16Bit(py::wrapper::Windows::AI::MachineLearning::TensorInt16Bit* self, PyObject* /*unused*/) noexcept
    {
        return Py_NewRef(self);
    }

    static PyObject* _exit_TensorInt16Bit(py::wrapper::Windows::AI::MachineLearning::TensorInt16Bit* self, PyObject* /*unused*/) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TensorInt16Bit[] = {
        { "close", reinterpret_cast<PyCFunction>(TensorInt16Bit_Close), METH_VARARGS, nullptr },
        { "create_reference", reinterpret_cast<PyCFunction>(TensorInt16Bit_CreateReference), METH_VARARGS, nullptr },
        { "get_as_vector_view", reinterpret_cast<PyCFunction>(TensorInt16Bit_GetAsVectorView), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_TensorInt16Bit, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_TensorInt16Bit), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_TensorInt16Bit), METH_NOARGS, nullptr },
        { "__exit__", reinterpret_cast<PyCFunction>(_exit_TensorInt16Bit), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_TensorInt16Bit[] = {
        { "kind", reinterpret_cast<getter>(TensorInt16Bit_get_Kind), nullptr, nullptr, nullptr },
        { "shape", reinterpret_cast<getter>(TensorInt16Bit_get_Shape), nullptr, nullptr, nullptr },
        { "tensor_kind", reinterpret_cast<getter>(TensorInt16Bit_get_TensorKind), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_TensorInt16Bit[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_TensorInt16Bit) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_TensorInt16Bit) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_TensorInt16Bit) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_TensorInt16Bit) },
        { },
    };

    static PyType_Spec type_spec_TensorInt16Bit = {
        "winrt._winrt_windows_ai_machinelearning.TensorInt16Bit",
        sizeof(py::wrapper::Windows::AI::MachineLearning::TensorInt16Bit),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TensorInt16Bit};

    static PyGetSetDef getset_TensorInt16Bit_Static[] = {
        { }
    };

    static PyMethodDef methods_TensorInt16Bit_Static[] = {
        { "create", reinterpret_cast<PyCFunction>(TensorInt16Bit_Create), METH_VARARGS, nullptr },
        { "create_from_array", reinterpret_cast<PyCFunction>(TensorInt16Bit_CreateFromArray), METH_VARARGS, nullptr },
        { "create_from_buffer", reinterpret_cast<PyCFunction>(TensorInt16Bit_CreateFromBuffer), METH_VARARGS, nullptr },
        { "create_from_iterable", reinterpret_cast<PyCFunction>(TensorInt16Bit_CreateFromIterable), METH_VARARGS, nullptr },
        { "create_from_shape_array_and_data_array", reinterpret_cast<PyCFunction>(TensorInt16Bit_CreateFromShapeArrayAndDataArray), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_TensorInt16Bit_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_TensorInt16Bit_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_TensorInt16Bit_Static) },
        { }
    };

    static PyType_Spec type_spec_TensorInt16Bit_Static =
    {
        "winrt._winrt_windows_ai_machinelearning.TensorInt16Bit_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_TensorInt16Bit_Static
    };

    // ----- TensorInt32Bit class --------------------

    static PyObject* _new_TensorInt32Bit(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::AI::MachineLearning::TensorInt32Bit>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::AI::MachineLearning::TensorInt32Bit>::type_name);
        return nullptr;
    }

    static void _dealloc_TensorInt32Bit(py::wrapper::Windows::AI::MachineLearning::TensorInt32Bit* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* TensorInt32Bit_Close(py::wrapper::Windows::AI::MachineLearning::TensorInt32Bit* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.TensorInt32Bit", L"Close", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorInt32Bit_Create(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.TensorInt32Bit", L"Create", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(winrt::Windows::AI::MachineLearning::TensorInt32Bit::Create());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.TensorInt32Bit", L"Create", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<int64_t>>(args, 0);

                return py::convert(winrt::Windows::AI::MachineLearning::TensorInt32Bit::Create(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorInt32Bit_CreateFromArray(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.TensorInt32Bit", L"CreateFromArray", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<int64_t>>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<int32_t, false>>(args, 1);

                return py::convert(winrt::Windows::AI::MachineLearning::TensorInt32Bit::CreateFromArray(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorInt32Bit_CreateFromBuffer(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.TensorInt32Bit", L"CreateFromBuffer", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<py::pybuf_view<int64_t, false>>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 1);

                return py::convert(winrt::Windows::AI::MachineLearning::TensorInt32Bit::CreateFromBuffer(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorInt32Bit_CreateFromIterable(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.TensorInt32Bit", L"CreateFromIterable", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<int64_t>>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<int32_t>>(args, 1);

                return py::convert(winrt::Windows::AI::MachineLearning::TensorInt32Bit::CreateFromIterable(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorInt32Bit_CreateFromShapeArrayAndDataArray(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.TensorInt32Bit", L"CreateFromShapeArrayAndDataArray", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<py::pybuf_view<int64_t, false>>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<int32_t, false>>(args, 1);

                return py::convert(winrt::Windows::AI::MachineLearning::TensorInt32Bit::CreateFromShapeArrayAndDataArray(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorInt32Bit_CreateReference(py::wrapper::Windows::AI::MachineLearning::TensorInt32Bit* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.TensorInt32Bit", L"CreateReference", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.CreateReference());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorInt32Bit_GetAsVectorView(py::wrapper::Windows::AI::MachineLearning::TensorInt32Bit* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.TensorInt32Bit", L"GetAsVectorView", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetAsVectorView());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorInt32Bit_get_Kind(py::wrapper::Windows::AI::MachineLearning::TensorInt32Bit* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.AI.MachineLearning.TensorInt32Bit", L"Kind"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TensorInt32Bit_get_Shape(py::wrapper::Windows::AI::MachineLearning::TensorInt32Bit* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.AI.MachineLearning.TensorInt32Bit", L"Shape"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Shape());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TensorInt32Bit_get_TensorKind(py::wrapper::Windows::AI::MachineLearning::TensorInt32Bit* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.AI.MachineLearning.TensorInt32Bit", L"TensorKind"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.TensorKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_TensorInt32Bit(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::AI::MachineLearning::TensorInt32Bit>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_TensorInt32Bit(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::AI::MachineLearning::TensorInt32Bit>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_TensorInt32Bit(py::wrapper::Windows::AI::MachineLearning::TensorInt32Bit* self, PyObject* /*unused*/) noexcept
    {
        return Py_NewRef(self);
    }

    static PyObject* _exit_TensorInt32Bit(py::wrapper::Windows::AI::MachineLearning::TensorInt32Bit* self, PyObject* /*unused*/) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TensorInt32Bit[] = {
        { "close", reinterpret_cast<PyCFunction>(TensorInt32Bit_Close), METH_VARARGS, nullptr },
        { "create_reference", reinterpret_cast<PyCFunction>(TensorInt32Bit_CreateReference), METH_VARARGS, nullptr },
        { "get_as_vector_view", reinterpret_cast<PyCFunction>(TensorInt32Bit_GetAsVectorView), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_TensorInt32Bit, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_TensorInt32Bit), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_TensorInt32Bit), METH_NOARGS, nullptr },
        { "__exit__", reinterpret_cast<PyCFunction>(_exit_TensorInt32Bit), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_TensorInt32Bit[] = {
        { "kind", reinterpret_cast<getter>(TensorInt32Bit_get_Kind), nullptr, nullptr, nullptr },
        { "shape", reinterpret_cast<getter>(TensorInt32Bit_get_Shape), nullptr, nullptr, nullptr },
        { "tensor_kind", reinterpret_cast<getter>(TensorInt32Bit_get_TensorKind), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_TensorInt32Bit[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_TensorInt32Bit) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_TensorInt32Bit) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_TensorInt32Bit) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_TensorInt32Bit) },
        { },
    };

    static PyType_Spec type_spec_TensorInt32Bit = {
        "winrt._winrt_windows_ai_machinelearning.TensorInt32Bit",
        sizeof(py::wrapper::Windows::AI::MachineLearning::TensorInt32Bit),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TensorInt32Bit};

    static PyGetSetDef getset_TensorInt32Bit_Static[] = {
        { }
    };

    static PyMethodDef methods_TensorInt32Bit_Static[] = {
        { "create", reinterpret_cast<PyCFunction>(TensorInt32Bit_Create), METH_VARARGS, nullptr },
        { "create_from_array", reinterpret_cast<PyCFunction>(TensorInt32Bit_CreateFromArray), METH_VARARGS, nullptr },
        { "create_from_buffer", reinterpret_cast<PyCFunction>(TensorInt32Bit_CreateFromBuffer), METH_VARARGS, nullptr },
        { "create_from_iterable", reinterpret_cast<PyCFunction>(TensorInt32Bit_CreateFromIterable), METH_VARARGS, nullptr },
        { "create_from_shape_array_and_data_array", reinterpret_cast<PyCFunction>(TensorInt32Bit_CreateFromShapeArrayAndDataArray), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_TensorInt32Bit_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_TensorInt32Bit_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_TensorInt32Bit_Static) },
        { }
    };

    static PyType_Spec type_spec_TensorInt32Bit_Static =
    {
        "winrt._winrt_windows_ai_machinelearning.TensorInt32Bit_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_TensorInt32Bit_Static
    };

    // ----- TensorInt64Bit class --------------------

    static PyObject* _new_TensorInt64Bit(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::AI::MachineLearning::TensorInt64Bit>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::AI::MachineLearning::TensorInt64Bit>::type_name);
        return nullptr;
    }

    static void _dealloc_TensorInt64Bit(py::wrapper::Windows::AI::MachineLearning::TensorInt64Bit* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* TensorInt64Bit_Close(py::wrapper::Windows::AI::MachineLearning::TensorInt64Bit* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.TensorInt64Bit", L"Close", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorInt64Bit_Create(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.TensorInt64Bit", L"Create", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(winrt::Windows::AI::MachineLearning::TensorInt64Bit::Create());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.TensorInt64Bit", L"Create", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<int64_t>>(args, 0);

                return py::convert(winrt::Windows::AI::MachineLearning::TensorInt64Bit::Create(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorInt64Bit_CreateFromArray(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.TensorInt64Bit", L"CreateFromArray", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<int64_t>>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<int64_t, false>>(args, 1);

                return py::convert(winrt::Windows::AI::MachineLearning::TensorInt64Bit::CreateFromArray(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorInt64Bit_CreateFromBuffer(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.TensorInt64Bit", L"CreateFromBuffer", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<py::pybuf_view<int64_t, false>>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 1);

                return py::convert(winrt::Windows::AI::MachineLearning::TensorInt64Bit::CreateFromBuffer(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorInt64Bit_CreateFromIterable(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.TensorInt64Bit", L"CreateFromIterable", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<int64_t>>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<int64_t>>(args, 1);

                return py::convert(winrt::Windows::AI::MachineLearning::TensorInt64Bit::CreateFromIterable(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorInt64Bit_CreateFromShapeArrayAndDataArray(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.TensorInt64Bit", L"CreateFromShapeArrayAndDataArray", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<py::pybuf_view<int64_t, false>>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<int64_t, false>>(args, 1);

                return py::convert(winrt::Windows::AI::MachineLearning::TensorInt64Bit::CreateFromShapeArrayAndDataArray(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorInt64Bit_CreateReference(py::wrapper::Windows::AI::MachineLearning::TensorInt64Bit* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.TensorInt64Bit", L"CreateReference", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.CreateReference());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorInt64Bit_GetAsVectorView(py::wrapper::Windows::AI::MachineLearning::TensorInt64Bit* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.TensorInt64Bit", L"GetAsVectorView", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetAsVectorView());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorInt64Bit_get_Kind(py::wrapper::Windows::AI::MachineLearning::TensorInt64Bit* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.AI.MachineLearning.TensorInt64Bit", L"Kind"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TensorInt64Bit_get_Shape(py::wrapper::Windows::AI::MachineLearning::TensorInt64Bit* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.AI.MachineLearning.TensorInt64Bit", L"Shape"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Shape());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TensorInt64Bit_get_TensorKind(py::wrapper::Windows::AI::MachineLearning::TensorInt64Bit* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.AI.MachineLearning.TensorInt64Bit", L"TensorKind"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.TensorKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_TensorInt64Bit(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::AI::MachineLearning::TensorInt64Bit>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_TensorInt64Bit(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::AI::MachineLearning::TensorInt64Bit>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_TensorInt64Bit(py::wrapper::Windows::AI::MachineLearning::TensorInt64Bit* self, PyObject* /*unused*/) noexcept
    {
        return Py_NewRef(self);
    }

    static PyObject* _exit_TensorInt64Bit(py::wrapper::Windows::AI::MachineLearning::TensorInt64Bit* self, PyObject* /*unused*/) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TensorInt64Bit[] = {
        { "close", reinterpret_cast<PyCFunction>(TensorInt64Bit_Close), METH_VARARGS, nullptr },
        { "create_reference", reinterpret_cast<PyCFunction>(TensorInt64Bit_CreateReference), METH_VARARGS, nullptr },
        { "get_as_vector_view", reinterpret_cast<PyCFunction>(TensorInt64Bit_GetAsVectorView), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_TensorInt64Bit, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_TensorInt64Bit), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_TensorInt64Bit), METH_NOARGS, nullptr },
        { "__exit__", reinterpret_cast<PyCFunction>(_exit_TensorInt64Bit), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_TensorInt64Bit[] = {
        { "kind", reinterpret_cast<getter>(TensorInt64Bit_get_Kind), nullptr, nullptr, nullptr },
        { "shape", reinterpret_cast<getter>(TensorInt64Bit_get_Shape), nullptr, nullptr, nullptr },
        { "tensor_kind", reinterpret_cast<getter>(TensorInt64Bit_get_TensorKind), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_TensorInt64Bit[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_TensorInt64Bit) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_TensorInt64Bit) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_TensorInt64Bit) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_TensorInt64Bit) },
        { },
    };

    static PyType_Spec type_spec_TensorInt64Bit = {
        "winrt._winrt_windows_ai_machinelearning.TensorInt64Bit",
        sizeof(py::wrapper::Windows::AI::MachineLearning::TensorInt64Bit),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TensorInt64Bit};

    static PyGetSetDef getset_TensorInt64Bit_Static[] = {
        { }
    };

    static PyMethodDef methods_TensorInt64Bit_Static[] = {
        { "create", reinterpret_cast<PyCFunction>(TensorInt64Bit_Create), METH_VARARGS, nullptr },
        { "create_from_array", reinterpret_cast<PyCFunction>(TensorInt64Bit_CreateFromArray), METH_VARARGS, nullptr },
        { "create_from_buffer", reinterpret_cast<PyCFunction>(TensorInt64Bit_CreateFromBuffer), METH_VARARGS, nullptr },
        { "create_from_iterable", reinterpret_cast<PyCFunction>(TensorInt64Bit_CreateFromIterable), METH_VARARGS, nullptr },
        { "create_from_shape_array_and_data_array", reinterpret_cast<PyCFunction>(TensorInt64Bit_CreateFromShapeArrayAndDataArray), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_TensorInt64Bit_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_TensorInt64Bit_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_TensorInt64Bit_Static) },
        { }
    };

    static PyType_Spec type_spec_TensorInt64Bit_Static =
    {
        "winrt._winrt_windows_ai_machinelearning.TensorInt64Bit_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_TensorInt64Bit_Static
    };

    // ----- TensorInt8Bit class --------------------

    static PyObject* _new_TensorInt8Bit(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::AI::MachineLearning::TensorInt8Bit>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::AI::MachineLearning::TensorInt8Bit>::type_name);
        return nullptr;
    }

    static void _dealloc_TensorInt8Bit(py::wrapper::Windows::AI::MachineLearning::TensorInt8Bit* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* TensorInt8Bit_Close(py::wrapper::Windows::AI::MachineLearning::TensorInt8Bit* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.TensorInt8Bit", L"Close", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorInt8Bit_Create(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.TensorInt8Bit", L"Create", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(winrt::Windows::AI::MachineLearning::TensorInt8Bit::Create());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.TensorInt8Bit", L"Create", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<int64_t>>(args, 0);

                return py::convert(winrt::Windows::AI::MachineLearning::TensorInt8Bit::Create(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorInt8Bit_CreateFromArray(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.TensorInt8Bit", L"CreateFromArray", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<int64_t>>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<uint8_t, false>>(args, 1);

                return py::convert(winrt::Windows::AI::MachineLearning::TensorInt8Bit::CreateFromArray(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorInt8Bit_CreateFromBuffer(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.TensorInt8Bit", L"CreateFromBuffer", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<py::pybuf_view<int64_t, false>>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 1);

                return py::convert(winrt::Windows::AI::MachineLearning::TensorInt8Bit::CreateFromBuffer(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorInt8Bit_CreateFromIterable(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.TensorInt8Bit", L"CreateFromIterable", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<int64_t>>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<uint8_t>>(args, 1);

                return py::convert(winrt::Windows::AI::MachineLearning::TensorInt8Bit::CreateFromIterable(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorInt8Bit_CreateFromShapeArrayAndDataArray(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.TensorInt8Bit", L"CreateFromShapeArrayAndDataArray", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<py::pybuf_view<int64_t, false>>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<uint8_t, false>>(args, 1);

                return py::convert(winrt::Windows::AI::MachineLearning::TensorInt8Bit::CreateFromShapeArrayAndDataArray(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorInt8Bit_CreateReference(py::wrapper::Windows::AI::MachineLearning::TensorInt8Bit* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.TensorInt8Bit", L"CreateReference", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.CreateReference());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorInt8Bit_GetAsVectorView(py::wrapper::Windows::AI::MachineLearning::TensorInt8Bit* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.TensorInt8Bit", L"GetAsVectorView", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetAsVectorView());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorInt8Bit_get_Kind(py::wrapper::Windows::AI::MachineLearning::TensorInt8Bit* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.AI.MachineLearning.TensorInt8Bit", L"Kind"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TensorInt8Bit_get_Shape(py::wrapper::Windows::AI::MachineLearning::TensorInt8Bit* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.AI.MachineLearning.TensorInt8Bit", L"Shape"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Shape());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TensorInt8Bit_get_TensorKind(py::wrapper::Windows::AI::MachineLearning::TensorInt8Bit* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.AI.MachineLearning.TensorInt8Bit", L"TensorKind"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.TensorKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_TensorInt8Bit(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::AI::MachineLearning::TensorInt8Bit>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_TensorInt8Bit(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::AI::MachineLearning::TensorInt8Bit>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_TensorInt8Bit(py::wrapper::Windows::AI::MachineLearning::TensorInt8Bit* self, PyObject* /*unused*/) noexcept
    {
        return Py_NewRef(self);
    }

    static PyObject* _exit_TensorInt8Bit(py::wrapper::Windows::AI::MachineLearning::TensorInt8Bit* self, PyObject* /*unused*/) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TensorInt8Bit[] = {
        { "close", reinterpret_cast<PyCFunction>(TensorInt8Bit_Close), METH_VARARGS, nullptr },
        { "create_reference", reinterpret_cast<PyCFunction>(TensorInt8Bit_CreateReference), METH_VARARGS, nullptr },
        { "get_as_vector_view", reinterpret_cast<PyCFunction>(TensorInt8Bit_GetAsVectorView), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_TensorInt8Bit, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_TensorInt8Bit), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_TensorInt8Bit), METH_NOARGS, nullptr },
        { "__exit__", reinterpret_cast<PyCFunction>(_exit_TensorInt8Bit), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_TensorInt8Bit[] = {
        { "kind", reinterpret_cast<getter>(TensorInt8Bit_get_Kind), nullptr, nullptr, nullptr },
        { "shape", reinterpret_cast<getter>(TensorInt8Bit_get_Shape), nullptr, nullptr, nullptr },
        { "tensor_kind", reinterpret_cast<getter>(TensorInt8Bit_get_TensorKind), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_TensorInt8Bit[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_TensorInt8Bit) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_TensorInt8Bit) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_TensorInt8Bit) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_TensorInt8Bit) },
        { },
    };

    static PyType_Spec type_spec_TensorInt8Bit = {
        "winrt._winrt_windows_ai_machinelearning.TensorInt8Bit",
        sizeof(py::wrapper::Windows::AI::MachineLearning::TensorInt8Bit),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TensorInt8Bit};

    static PyGetSetDef getset_TensorInt8Bit_Static[] = {
        { }
    };

    static PyMethodDef methods_TensorInt8Bit_Static[] = {
        { "create", reinterpret_cast<PyCFunction>(TensorInt8Bit_Create), METH_VARARGS, nullptr },
        { "create_from_array", reinterpret_cast<PyCFunction>(TensorInt8Bit_CreateFromArray), METH_VARARGS, nullptr },
        { "create_from_buffer", reinterpret_cast<PyCFunction>(TensorInt8Bit_CreateFromBuffer), METH_VARARGS, nullptr },
        { "create_from_iterable", reinterpret_cast<PyCFunction>(TensorInt8Bit_CreateFromIterable), METH_VARARGS, nullptr },
        { "create_from_shape_array_and_data_array", reinterpret_cast<PyCFunction>(TensorInt8Bit_CreateFromShapeArrayAndDataArray), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_TensorInt8Bit_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_TensorInt8Bit_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_TensorInt8Bit_Static) },
        { }
    };

    static PyType_Spec type_spec_TensorInt8Bit_Static =
    {
        "winrt._winrt_windows_ai_machinelearning.TensorInt8Bit_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_TensorInt8Bit_Static
    };

    // ----- TensorString class --------------------

    static PyObject* _new_TensorString(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::AI::MachineLearning::TensorString>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::AI::MachineLearning::TensorString>::type_name);
        return nullptr;
    }

    static void _dealloc_TensorString(py::wrapper::Windows::AI::MachineLearning::TensorString* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* TensorString_Close(py::wrapper::Windows::AI::MachineLearning::TensorString* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.TensorString", L"Close", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorString_Create(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.TensorString", L"Create", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(winrt::Windows::AI::MachineLearning::TensorString::Create());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.TensorString", L"Create", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<int64_t>>(args, 0);

                return py::convert(winrt::Windows::AI::MachineLearning::TensorString::Create(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorString_CreateFromArray(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.TensorString", L"CreateFromArray", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<int64_t>>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<winrt::hstring, false>>(args, 1);

                return py::convert(winrt::Windows::AI::MachineLearning::TensorString::CreateFromArray(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorString_CreateFromIterable(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.TensorString", L"CreateFromIterable", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<int64_t>>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 1);

                return py::convert(winrt::Windows::AI::MachineLearning::TensorString::CreateFromIterable(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorString_CreateFromShapeArrayAndDataArray(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.TensorString", L"CreateFromShapeArrayAndDataArray", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<py::pybuf_view<int64_t, false>>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<winrt::hstring, false>>(args, 1);

                return py::convert(winrt::Windows::AI::MachineLearning::TensorString::CreateFromShapeArrayAndDataArray(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorString_CreateReference(py::wrapper::Windows::AI::MachineLearning::TensorString* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.TensorString", L"CreateReference", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.CreateReference());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorString_GetAsVectorView(py::wrapper::Windows::AI::MachineLearning::TensorString* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.TensorString", L"GetAsVectorView", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetAsVectorView());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorString_get_Kind(py::wrapper::Windows::AI::MachineLearning::TensorString* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.AI.MachineLearning.TensorString", L"Kind"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TensorString_get_Shape(py::wrapper::Windows::AI::MachineLearning::TensorString* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.AI.MachineLearning.TensorString", L"Shape"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Shape());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TensorString_get_TensorKind(py::wrapper::Windows::AI::MachineLearning::TensorString* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.AI.MachineLearning.TensorString", L"TensorKind"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.TensorKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_TensorString(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::AI::MachineLearning::TensorString>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_TensorString(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::AI::MachineLearning::TensorString>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_TensorString(py::wrapper::Windows::AI::MachineLearning::TensorString* self, PyObject* /*unused*/) noexcept
    {
        return Py_NewRef(self);
    }

    static PyObject* _exit_TensorString(py::wrapper::Windows::AI::MachineLearning::TensorString* self, PyObject* /*unused*/) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TensorString[] = {
        { "close", reinterpret_cast<PyCFunction>(TensorString_Close), METH_VARARGS, nullptr },
        { "create_reference", reinterpret_cast<PyCFunction>(TensorString_CreateReference), METH_VARARGS, nullptr },
        { "get_as_vector_view", reinterpret_cast<PyCFunction>(TensorString_GetAsVectorView), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_TensorString, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_TensorString), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_TensorString), METH_NOARGS, nullptr },
        { "__exit__", reinterpret_cast<PyCFunction>(_exit_TensorString), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_TensorString[] = {
        { "kind", reinterpret_cast<getter>(TensorString_get_Kind), nullptr, nullptr, nullptr },
        { "shape", reinterpret_cast<getter>(TensorString_get_Shape), nullptr, nullptr, nullptr },
        { "tensor_kind", reinterpret_cast<getter>(TensorString_get_TensorKind), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_TensorString[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_TensorString) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_TensorString) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_TensorString) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_TensorString) },
        { },
    };

    static PyType_Spec type_spec_TensorString = {
        "winrt._winrt_windows_ai_machinelearning.TensorString",
        sizeof(py::wrapper::Windows::AI::MachineLearning::TensorString),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TensorString};

    static PyGetSetDef getset_TensorString_Static[] = {
        { }
    };

    static PyMethodDef methods_TensorString_Static[] = {
        { "create", reinterpret_cast<PyCFunction>(TensorString_Create), METH_VARARGS, nullptr },
        { "create_from_array", reinterpret_cast<PyCFunction>(TensorString_CreateFromArray), METH_VARARGS, nullptr },
        { "create_from_iterable", reinterpret_cast<PyCFunction>(TensorString_CreateFromIterable), METH_VARARGS, nullptr },
        { "create_from_shape_array_and_data_array", reinterpret_cast<PyCFunction>(TensorString_CreateFromShapeArrayAndDataArray), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_TensorString_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_TensorString_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_TensorString_Static) },
        { }
    };

    static PyType_Spec type_spec_TensorString_Static =
    {
        "winrt._winrt_windows_ai_machinelearning.TensorString_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_TensorString_Static
    };

    // ----- TensorUInt16Bit class --------------------

    static PyObject* _new_TensorUInt16Bit(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::AI::MachineLearning::TensorUInt16Bit>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::AI::MachineLearning::TensorUInt16Bit>::type_name);
        return nullptr;
    }

    static void _dealloc_TensorUInt16Bit(py::wrapper::Windows::AI::MachineLearning::TensorUInt16Bit* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* TensorUInt16Bit_Close(py::wrapper::Windows::AI::MachineLearning::TensorUInt16Bit* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.TensorUInt16Bit", L"Close", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorUInt16Bit_Create(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.TensorUInt16Bit", L"Create", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(winrt::Windows::AI::MachineLearning::TensorUInt16Bit::Create());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.TensorUInt16Bit", L"Create", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<int64_t>>(args, 0);

                return py::convert(winrt::Windows::AI::MachineLearning::TensorUInt16Bit::Create(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorUInt16Bit_CreateFromArray(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.TensorUInt16Bit", L"CreateFromArray", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<int64_t>>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<uint16_t, false>>(args, 1);

                return py::convert(winrt::Windows::AI::MachineLearning::TensorUInt16Bit::CreateFromArray(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorUInt16Bit_CreateFromBuffer(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.TensorUInt16Bit", L"CreateFromBuffer", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<py::pybuf_view<int64_t, false>>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 1);

                return py::convert(winrt::Windows::AI::MachineLearning::TensorUInt16Bit::CreateFromBuffer(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorUInt16Bit_CreateFromIterable(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.TensorUInt16Bit", L"CreateFromIterable", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<int64_t>>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<uint16_t>>(args, 1);

                return py::convert(winrt::Windows::AI::MachineLearning::TensorUInt16Bit::CreateFromIterable(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorUInt16Bit_CreateFromShapeArrayAndDataArray(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.TensorUInt16Bit", L"CreateFromShapeArrayAndDataArray", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<py::pybuf_view<int64_t, false>>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<uint16_t, false>>(args, 1);

                return py::convert(winrt::Windows::AI::MachineLearning::TensorUInt16Bit::CreateFromShapeArrayAndDataArray(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorUInt16Bit_CreateReference(py::wrapper::Windows::AI::MachineLearning::TensorUInt16Bit* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.TensorUInt16Bit", L"CreateReference", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.CreateReference());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorUInt16Bit_GetAsVectorView(py::wrapper::Windows::AI::MachineLearning::TensorUInt16Bit* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.TensorUInt16Bit", L"GetAsVectorView", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetAsVectorView());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorUInt16Bit_get_Kind(py::wrapper::Windows::AI::MachineLearning::TensorUInt16Bit* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.AI.MachineLearning.TensorUInt16Bit", L"Kind"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TensorUInt16Bit_get_Shape(py::wrapper::Windows::AI::MachineLearning::TensorUInt16Bit* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.AI.MachineLearning.TensorUInt16Bit", L"Shape"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Shape());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TensorUInt16Bit_get_TensorKind(py::wrapper::Windows::AI::MachineLearning::TensorUInt16Bit* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.AI.MachineLearning.TensorUInt16Bit", L"TensorKind"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.TensorKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_TensorUInt16Bit(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::AI::MachineLearning::TensorUInt16Bit>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_TensorUInt16Bit(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::AI::MachineLearning::TensorUInt16Bit>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_TensorUInt16Bit(py::wrapper::Windows::AI::MachineLearning::TensorUInt16Bit* self, PyObject* /*unused*/) noexcept
    {
        return Py_NewRef(self);
    }

    static PyObject* _exit_TensorUInt16Bit(py::wrapper::Windows::AI::MachineLearning::TensorUInt16Bit* self, PyObject* /*unused*/) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TensorUInt16Bit[] = {
        { "close", reinterpret_cast<PyCFunction>(TensorUInt16Bit_Close), METH_VARARGS, nullptr },
        { "create_reference", reinterpret_cast<PyCFunction>(TensorUInt16Bit_CreateReference), METH_VARARGS, nullptr },
        { "get_as_vector_view", reinterpret_cast<PyCFunction>(TensorUInt16Bit_GetAsVectorView), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_TensorUInt16Bit, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_TensorUInt16Bit), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_TensorUInt16Bit), METH_NOARGS, nullptr },
        { "__exit__", reinterpret_cast<PyCFunction>(_exit_TensorUInt16Bit), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_TensorUInt16Bit[] = {
        { "kind", reinterpret_cast<getter>(TensorUInt16Bit_get_Kind), nullptr, nullptr, nullptr },
        { "shape", reinterpret_cast<getter>(TensorUInt16Bit_get_Shape), nullptr, nullptr, nullptr },
        { "tensor_kind", reinterpret_cast<getter>(TensorUInt16Bit_get_TensorKind), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_TensorUInt16Bit[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_TensorUInt16Bit) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_TensorUInt16Bit) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_TensorUInt16Bit) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_TensorUInt16Bit) },
        { },
    };

    static PyType_Spec type_spec_TensorUInt16Bit = {
        "winrt._winrt_windows_ai_machinelearning.TensorUInt16Bit",
        sizeof(py::wrapper::Windows::AI::MachineLearning::TensorUInt16Bit),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TensorUInt16Bit};

    static PyGetSetDef getset_TensorUInt16Bit_Static[] = {
        { }
    };

    static PyMethodDef methods_TensorUInt16Bit_Static[] = {
        { "create", reinterpret_cast<PyCFunction>(TensorUInt16Bit_Create), METH_VARARGS, nullptr },
        { "create_from_array", reinterpret_cast<PyCFunction>(TensorUInt16Bit_CreateFromArray), METH_VARARGS, nullptr },
        { "create_from_buffer", reinterpret_cast<PyCFunction>(TensorUInt16Bit_CreateFromBuffer), METH_VARARGS, nullptr },
        { "create_from_iterable", reinterpret_cast<PyCFunction>(TensorUInt16Bit_CreateFromIterable), METH_VARARGS, nullptr },
        { "create_from_shape_array_and_data_array", reinterpret_cast<PyCFunction>(TensorUInt16Bit_CreateFromShapeArrayAndDataArray), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_TensorUInt16Bit_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_TensorUInt16Bit_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_TensorUInt16Bit_Static) },
        { }
    };

    static PyType_Spec type_spec_TensorUInt16Bit_Static =
    {
        "winrt._winrt_windows_ai_machinelearning.TensorUInt16Bit_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_TensorUInt16Bit_Static
    };

    // ----- TensorUInt32Bit class --------------------

    static PyObject* _new_TensorUInt32Bit(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::AI::MachineLearning::TensorUInt32Bit>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::AI::MachineLearning::TensorUInt32Bit>::type_name);
        return nullptr;
    }

    static void _dealloc_TensorUInt32Bit(py::wrapper::Windows::AI::MachineLearning::TensorUInt32Bit* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* TensorUInt32Bit_Close(py::wrapper::Windows::AI::MachineLearning::TensorUInt32Bit* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.TensorUInt32Bit", L"Close", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorUInt32Bit_Create(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.TensorUInt32Bit", L"Create", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(winrt::Windows::AI::MachineLearning::TensorUInt32Bit::Create());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.TensorUInt32Bit", L"Create", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<int64_t>>(args, 0);

                return py::convert(winrt::Windows::AI::MachineLearning::TensorUInt32Bit::Create(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorUInt32Bit_CreateFromArray(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.TensorUInt32Bit", L"CreateFromArray", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<int64_t>>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<uint32_t, false>>(args, 1);

                return py::convert(winrt::Windows::AI::MachineLearning::TensorUInt32Bit::CreateFromArray(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorUInt32Bit_CreateFromBuffer(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.TensorUInt32Bit", L"CreateFromBuffer", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<py::pybuf_view<int64_t, false>>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 1);

                return py::convert(winrt::Windows::AI::MachineLearning::TensorUInt32Bit::CreateFromBuffer(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorUInt32Bit_CreateFromIterable(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.TensorUInt32Bit", L"CreateFromIterable", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<int64_t>>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<uint32_t>>(args, 1);

                return py::convert(winrt::Windows::AI::MachineLearning::TensorUInt32Bit::CreateFromIterable(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorUInt32Bit_CreateFromShapeArrayAndDataArray(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.TensorUInt32Bit", L"CreateFromShapeArrayAndDataArray", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<py::pybuf_view<int64_t, false>>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<uint32_t, false>>(args, 1);

                return py::convert(winrt::Windows::AI::MachineLearning::TensorUInt32Bit::CreateFromShapeArrayAndDataArray(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorUInt32Bit_CreateReference(py::wrapper::Windows::AI::MachineLearning::TensorUInt32Bit* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.TensorUInt32Bit", L"CreateReference", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.CreateReference());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorUInt32Bit_GetAsVectorView(py::wrapper::Windows::AI::MachineLearning::TensorUInt32Bit* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.TensorUInt32Bit", L"GetAsVectorView", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetAsVectorView());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorUInt32Bit_get_Kind(py::wrapper::Windows::AI::MachineLearning::TensorUInt32Bit* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.AI.MachineLearning.TensorUInt32Bit", L"Kind"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TensorUInt32Bit_get_Shape(py::wrapper::Windows::AI::MachineLearning::TensorUInt32Bit* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.AI.MachineLearning.TensorUInt32Bit", L"Shape"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Shape());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TensorUInt32Bit_get_TensorKind(py::wrapper::Windows::AI::MachineLearning::TensorUInt32Bit* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.AI.MachineLearning.TensorUInt32Bit", L"TensorKind"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.TensorKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_TensorUInt32Bit(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::AI::MachineLearning::TensorUInt32Bit>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_TensorUInt32Bit(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::AI::MachineLearning::TensorUInt32Bit>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_TensorUInt32Bit(py::wrapper::Windows::AI::MachineLearning::TensorUInt32Bit* self, PyObject* /*unused*/) noexcept
    {
        return Py_NewRef(self);
    }

    static PyObject* _exit_TensorUInt32Bit(py::wrapper::Windows::AI::MachineLearning::TensorUInt32Bit* self, PyObject* /*unused*/) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TensorUInt32Bit[] = {
        { "close", reinterpret_cast<PyCFunction>(TensorUInt32Bit_Close), METH_VARARGS, nullptr },
        { "create_reference", reinterpret_cast<PyCFunction>(TensorUInt32Bit_CreateReference), METH_VARARGS, nullptr },
        { "get_as_vector_view", reinterpret_cast<PyCFunction>(TensorUInt32Bit_GetAsVectorView), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_TensorUInt32Bit, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_TensorUInt32Bit), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_TensorUInt32Bit), METH_NOARGS, nullptr },
        { "__exit__", reinterpret_cast<PyCFunction>(_exit_TensorUInt32Bit), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_TensorUInt32Bit[] = {
        { "kind", reinterpret_cast<getter>(TensorUInt32Bit_get_Kind), nullptr, nullptr, nullptr },
        { "shape", reinterpret_cast<getter>(TensorUInt32Bit_get_Shape), nullptr, nullptr, nullptr },
        { "tensor_kind", reinterpret_cast<getter>(TensorUInt32Bit_get_TensorKind), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_TensorUInt32Bit[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_TensorUInt32Bit) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_TensorUInt32Bit) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_TensorUInt32Bit) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_TensorUInt32Bit) },
        { },
    };

    static PyType_Spec type_spec_TensorUInt32Bit = {
        "winrt._winrt_windows_ai_machinelearning.TensorUInt32Bit",
        sizeof(py::wrapper::Windows::AI::MachineLearning::TensorUInt32Bit),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TensorUInt32Bit};

    static PyGetSetDef getset_TensorUInt32Bit_Static[] = {
        { }
    };

    static PyMethodDef methods_TensorUInt32Bit_Static[] = {
        { "create", reinterpret_cast<PyCFunction>(TensorUInt32Bit_Create), METH_VARARGS, nullptr },
        { "create_from_array", reinterpret_cast<PyCFunction>(TensorUInt32Bit_CreateFromArray), METH_VARARGS, nullptr },
        { "create_from_buffer", reinterpret_cast<PyCFunction>(TensorUInt32Bit_CreateFromBuffer), METH_VARARGS, nullptr },
        { "create_from_iterable", reinterpret_cast<PyCFunction>(TensorUInt32Bit_CreateFromIterable), METH_VARARGS, nullptr },
        { "create_from_shape_array_and_data_array", reinterpret_cast<PyCFunction>(TensorUInt32Bit_CreateFromShapeArrayAndDataArray), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_TensorUInt32Bit_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_TensorUInt32Bit_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_TensorUInt32Bit_Static) },
        { }
    };

    static PyType_Spec type_spec_TensorUInt32Bit_Static =
    {
        "winrt._winrt_windows_ai_machinelearning.TensorUInt32Bit_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_TensorUInt32Bit_Static
    };

    // ----- TensorUInt64Bit class --------------------

    static PyObject* _new_TensorUInt64Bit(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::AI::MachineLearning::TensorUInt64Bit>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::AI::MachineLearning::TensorUInt64Bit>::type_name);
        return nullptr;
    }

    static void _dealloc_TensorUInt64Bit(py::wrapper::Windows::AI::MachineLearning::TensorUInt64Bit* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* TensorUInt64Bit_Close(py::wrapper::Windows::AI::MachineLearning::TensorUInt64Bit* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.TensorUInt64Bit", L"Close", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorUInt64Bit_Create(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.TensorUInt64Bit", L"Create", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(winrt::Windows::AI::MachineLearning::TensorUInt64Bit::Create());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.TensorUInt64Bit", L"Create", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<int64_t>>(args, 0);

                return py::convert(winrt::Windows::AI::MachineLearning::TensorUInt64Bit::Create(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorUInt64Bit_CreateFromArray(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.TensorUInt64Bit", L"CreateFromArray", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<int64_t>>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<uint64_t, false>>(args, 1);

                return py::convert(winrt::Windows::AI::MachineLearning::TensorUInt64Bit::CreateFromArray(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorUInt64Bit_CreateFromBuffer(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.TensorUInt64Bit", L"CreateFromBuffer", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<py::pybuf_view<int64_t, false>>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 1);

                return py::convert(winrt::Windows::AI::MachineLearning::TensorUInt64Bit::CreateFromBuffer(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorUInt64Bit_CreateFromIterable(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.TensorUInt64Bit", L"CreateFromIterable", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<int64_t>>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<uint64_t>>(args, 1);

                return py::convert(winrt::Windows::AI::MachineLearning::TensorUInt64Bit::CreateFromIterable(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorUInt64Bit_CreateFromShapeArrayAndDataArray(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.TensorUInt64Bit", L"CreateFromShapeArrayAndDataArray", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<py::pybuf_view<int64_t, false>>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<uint64_t, false>>(args, 1);

                return py::convert(winrt::Windows::AI::MachineLearning::TensorUInt64Bit::CreateFromShapeArrayAndDataArray(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorUInt64Bit_CreateReference(py::wrapper::Windows::AI::MachineLearning::TensorUInt64Bit* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.TensorUInt64Bit", L"CreateReference", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.CreateReference());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorUInt64Bit_GetAsVectorView(py::wrapper::Windows::AI::MachineLearning::TensorUInt64Bit* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.TensorUInt64Bit", L"GetAsVectorView", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetAsVectorView());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorUInt64Bit_get_Kind(py::wrapper::Windows::AI::MachineLearning::TensorUInt64Bit* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.AI.MachineLearning.TensorUInt64Bit", L"Kind"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TensorUInt64Bit_get_Shape(py::wrapper::Windows::AI::MachineLearning::TensorUInt64Bit* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.AI.MachineLearning.TensorUInt64Bit", L"Shape"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Shape());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TensorUInt64Bit_get_TensorKind(py::wrapper::Windows::AI::MachineLearning::TensorUInt64Bit* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.AI.MachineLearning.TensorUInt64Bit", L"TensorKind"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.TensorKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_TensorUInt64Bit(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::AI::MachineLearning::TensorUInt64Bit>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_TensorUInt64Bit(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::AI::MachineLearning::TensorUInt64Bit>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_TensorUInt64Bit(py::wrapper::Windows::AI::MachineLearning::TensorUInt64Bit* self, PyObject* /*unused*/) noexcept
    {
        return Py_NewRef(self);
    }

    static PyObject* _exit_TensorUInt64Bit(py::wrapper::Windows::AI::MachineLearning::TensorUInt64Bit* self, PyObject* /*unused*/) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TensorUInt64Bit[] = {
        { "close", reinterpret_cast<PyCFunction>(TensorUInt64Bit_Close), METH_VARARGS, nullptr },
        { "create_reference", reinterpret_cast<PyCFunction>(TensorUInt64Bit_CreateReference), METH_VARARGS, nullptr },
        { "get_as_vector_view", reinterpret_cast<PyCFunction>(TensorUInt64Bit_GetAsVectorView), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_TensorUInt64Bit, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_TensorUInt64Bit), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_TensorUInt64Bit), METH_NOARGS, nullptr },
        { "__exit__", reinterpret_cast<PyCFunction>(_exit_TensorUInt64Bit), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_TensorUInt64Bit[] = {
        { "kind", reinterpret_cast<getter>(TensorUInt64Bit_get_Kind), nullptr, nullptr, nullptr },
        { "shape", reinterpret_cast<getter>(TensorUInt64Bit_get_Shape), nullptr, nullptr, nullptr },
        { "tensor_kind", reinterpret_cast<getter>(TensorUInt64Bit_get_TensorKind), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_TensorUInt64Bit[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_TensorUInt64Bit) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_TensorUInt64Bit) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_TensorUInt64Bit) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_TensorUInt64Bit) },
        { },
    };

    static PyType_Spec type_spec_TensorUInt64Bit = {
        "winrt._winrt_windows_ai_machinelearning.TensorUInt64Bit",
        sizeof(py::wrapper::Windows::AI::MachineLearning::TensorUInt64Bit),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TensorUInt64Bit};

    static PyGetSetDef getset_TensorUInt64Bit_Static[] = {
        { }
    };

    static PyMethodDef methods_TensorUInt64Bit_Static[] = {
        { "create", reinterpret_cast<PyCFunction>(TensorUInt64Bit_Create), METH_VARARGS, nullptr },
        { "create_from_array", reinterpret_cast<PyCFunction>(TensorUInt64Bit_CreateFromArray), METH_VARARGS, nullptr },
        { "create_from_buffer", reinterpret_cast<PyCFunction>(TensorUInt64Bit_CreateFromBuffer), METH_VARARGS, nullptr },
        { "create_from_iterable", reinterpret_cast<PyCFunction>(TensorUInt64Bit_CreateFromIterable), METH_VARARGS, nullptr },
        { "create_from_shape_array_and_data_array", reinterpret_cast<PyCFunction>(TensorUInt64Bit_CreateFromShapeArrayAndDataArray), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_TensorUInt64Bit_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_TensorUInt64Bit_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_TensorUInt64Bit_Static) },
        { }
    };

    static PyType_Spec type_spec_TensorUInt64Bit_Static =
    {
        "winrt._winrt_windows_ai_machinelearning.TensorUInt64Bit_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_TensorUInt64Bit_Static
    };

    // ----- TensorUInt8Bit class --------------------

    static PyObject* _new_TensorUInt8Bit(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::AI::MachineLearning::TensorUInt8Bit>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::AI::MachineLearning::TensorUInt8Bit>::type_name);
        return nullptr;
    }

    static void _dealloc_TensorUInt8Bit(py::wrapper::Windows::AI::MachineLearning::TensorUInt8Bit* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* TensorUInt8Bit_Close(py::wrapper::Windows::AI::MachineLearning::TensorUInt8Bit* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.TensorUInt8Bit", L"Close", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorUInt8Bit_Create(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.TensorUInt8Bit", L"Create", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(winrt::Windows::AI::MachineLearning::TensorUInt8Bit::Create());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.TensorUInt8Bit", L"Create", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<int64_t>>(args, 0);

                return py::convert(winrt::Windows::AI::MachineLearning::TensorUInt8Bit::Create(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorUInt8Bit_CreateFromArray(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.TensorUInt8Bit", L"CreateFromArray", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<int64_t>>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<uint8_t, false>>(args, 1);

                return py::convert(winrt::Windows::AI::MachineLearning::TensorUInt8Bit::CreateFromArray(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorUInt8Bit_CreateFromBuffer(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.TensorUInt8Bit", L"CreateFromBuffer", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<py::pybuf_view<int64_t, false>>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 1);

                return py::convert(winrt::Windows::AI::MachineLearning::TensorUInt8Bit::CreateFromBuffer(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorUInt8Bit_CreateFromIterable(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.TensorUInt8Bit", L"CreateFromIterable", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<int64_t>>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<uint8_t>>(args, 1);

                return py::convert(winrt::Windows::AI::MachineLearning::TensorUInt8Bit::CreateFromIterable(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorUInt8Bit_CreateFromShapeArrayAndDataArray(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.TensorUInt8Bit", L"CreateFromShapeArrayAndDataArray", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<py::pybuf_view<int64_t, false>>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<uint8_t, false>>(args, 1);

                return py::convert(winrt::Windows::AI::MachineLearning::TensorUInt8Bit::CreateFromShapeArrayAndDataArray(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorUInt8Bit_CreateReference(py::wrapper::Windows::AI::MachineLearning::TensorUInt8Bit* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.TensorUInt8Bit", L"CreateReference", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.CreateReference());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorUInt8Bit_GetAsVectorView(py::wrapper::Windows::AI::MachineLearning::TensorUInt8Bit* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.AI.MachineLearning.TensorUInt8Bit", L"GetAsVectorView", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetAsVectorView());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorUInt8Bit_get_Kind(py::wrapper::Windows::AI::MachineLearning::TensorUInt8Bit* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.AI.MachineLearning.TensorUInt8Bit", L"Kind"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TensorUInt8Bit_get_Shape(py::wrapper::Windows::AI::MachineLearning::TensorUInt8Bit* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.AI.MachineLearning.TensorUInt8Bit", L"Shape"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Shape());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TensorUInt8Bit_get_TensorKind(py::wrapper::Windows::AI::MachineLearning::TensorUInt8Bit* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.AI.MachineLearning.TensorUInt8Bit", L"TensorKind"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.TensorKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_TensorUInt8Bit(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::AI::MachineLearning::TensorUInt8Bit>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_TensorUInt8Bit(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::AI::MachineLearning::TensorUInt8Bit>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_TensorUInt8Bit(py::wrapper::Windows::AI::MachineLearning::TensorUInt8Bit* self, PyObject* /*unused*/) noexcept
    {
        return Py_NewRef(self);
    }

    static PyObject* _exit_TensorUInt8Bit(py::wrapper::Windows::AI::MachineLearning::TensorUInt8Bit* self, PyObject* /*unused*/) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TensorUInt8Bit[] = {
        { "close", reinterpret_cast<PyCFunction>(TensorUInt8Bit_Close), METH_VARARGS, nullptr },
        { "create_reference", reinterpret_cast<PyCFunction>(TensorUInt8Bit_CreateReference), METH_VARARGS, nullptr },
        { "get_as_vector_view", reinterpret_cast<PyCFunction>(TensorUInt8Bit_GetAsVectorView), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_TensorUInt8Bit, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_TensorUInt8Bit), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_TensorUInt8Bit), METH_NOARGS, nullptr },
        { "__exit__", reinterpret_cast<PyCFunction>(_exit_TensorUInt8Bit), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_TensorUInt8Bit[] = {
        { "kind", reinterpret_cast<getter>(TensorUInt8Bit_get_Kind), nullptr, nullptr, nullptr },
        { "shape", reinterpret_cast<getter>(TensorUInt8Bit_get_Shape), nullptr, nullptr, nullptr },
        { "tensor_kind", reinterpret_cast<getter>(TensorUInt8Bit_get_TensorKind), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_TensorUInt8Bit[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_TensorUInt8Bit) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_TensorUInt8Bit) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_TensorUInt8Bit) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_TensorUInt8Bit) },
        { },
    };

    static PyType_Spec type_spec_TensorUInt8Bit = {
        "winrt._winrt_windows_ai_machinelearning.TensorUInt8Bit",
        sizeof(py::wrapper::Windows::AI::MachineLearning::TensorUInt8Bit),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TensorUInt8Bit};

    static PyGetSetDef getset_TensorUInt8Bit_Static[] = {
        { }
    };

    static PyMethodDef methods_TensorUInt8Bit_Static[] = {
        { "create", reinterpret_cast<PyCFunction>(TensorUInt8Bit_Create), METH_VARARGS, nullptr },
        { "create_from_array", reinterpret_cast<PyCFunction>(TensorUInt8Bit_CreateFromArray), METH_VARARGS, nullptr },
        { "create_from_buffer", reinterpret_cast<PyCFunction>(TensorUInt8Bit_CreateFromBuffer), METH_VARARGS, nullptr },
        { "create_from_iterable", reinterpret_cast<PyCFunction>(TensorUInt8Bit_CreateFromIterable), METH_VARARGS, nullptr },
        { "create_from_shape_array_and_data_array", reinterpret_cast<PyCFunction>(TensorUInt8Bit_CreateFromShapeArrayAndDataArray), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_TensorUInt8Bit_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_TensorUInt8Bit_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_TensorUInt8Bit_Static) },
        { }
    };

    static PyType_Spec type_spec_TensorUInt8Bit_Static =
    {
        "winrt._winrt_windows_ai_machinelearning.TensorUInt8Bit_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_TensorUInt8Bit_Static
    };

    // ----- ILearningModelFeatureDescriptor interface --------------------

    static PyObject* _new_ILearningModelFeatureDescriptor(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::AI::MachineLearning::ILearningModelFeatureDescriptor>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::AI::MachineLearning::ILearningModelFeatureDescriptor>::type_name);
        return nullptr;
    }

    static void _dealloc_ILearningModelFeatureDescriptor(py::wrapper::Windows::AI::MachineLearning::ILearningModelFeatureDescriptor* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ILearningModelFeatureDescriptor_get_Description(py::wrapper::Windows::AI::MachineLearning::ILearningModelFeatureDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.AI.MachineLearning.ILearningModelFeatureDescriptor", L"Description"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Description());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ILearningModelFeatureDescriptor_get_IsRequired(py::wrapper::Windows::AI::MachineLearning::ILearningModelFeatureDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.AI.MachineLearning.ILearningModelFeatureDescriptor", L"IsRequired"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsRequired());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ILearningModelFeatureDescriptor_get_Kind(py::wrapper::Windows::AI::MachineLearning::ILearningModelFeatureDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.AI.MachineLearning.ILearningModelFeatureDescriptor", L"Kind"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ILearningModelFeatureDescriptor_get_Name(py::wrapper::Windows::AI::MachineLearning::ILearningModelFeatureDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.AI.MachineLearning.ILearningModelFeatureDescriptor", L"Name"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Name());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ILearningModelFeatureDescriptor(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::AI::MachineLearning::ILearningModelFeatureDescriptor>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ILearningModelFeatureDescriptor(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::AI::MachineLearning::ILearningModelFeatureDescriptor>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ILearningModelFeatureDescriptor[] = {
        { "_assign_array_", _assign_array_ILearningModelFeatureDescriptor, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ILearningModelFeatureDescriptor), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ILearningModelFeatureDescriptor[] = {
        { "description", reinterpret_cast<getter>(ILearningModelFeatureDescriptor_get_Description), nullptr, nullptr, nullptr },
        { "is_required", reinterpret_cast<getter>(ILearningModelFeatureDescriptor_get_IsRequired), nullptr, nullptr, nullptr },
        { "kind", reinterpret_cast<getter>(ILearningModelFeatureDescriptor_get_Kind), nullptr, nullptr, nullptr },
        { "name", reinterpret_cast<getter>(ILearningModelFeatureDescriptor_get_Name), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ILearningModelFeatureDescriptor[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ILearningModelFeatureDescriptor) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ILearningModelFeatureDescriptor) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ILearningModelFeatureDescriptor) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ILearningModelFeatureDescriptor) },
        { },
    };

    static PyType_Spec type_spec_ILearningModelFeatureDescriptor = {
        "winrt._winrt_windows_ai_machinelearning.ILearningModelFeatureDescriptor",
        sizeof(py::wrapper::Windows::AI::MachineLearning::ILearningModelFeatureDescriptor),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ILearningModelFeatureDescriptor};

    // ----- ILearningModelFeatureValue interface --------------------

    static PyObject* _new_ILearningModelFeatureValue(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::AI::MachineLearning::ILearningModelFeatureValue>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::AI::MachineLearning::ILearningModelFeatureValue>::type_name);
        return nullptr;
    }

    static void _dealloc_ILearningModelFeatureValue(py::wrapper::Windows::AI::MachineLearning::ILearningModelFeatureValue* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ILearningModelFeatureValue_get_Kind(py::wrapper::Windows::AI::MachineLearning::ILearningModelFeatureValue* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.AI.MachineLearning.ILearningModelFeatureValue", L"Kind"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ILearningModelFeatureValue(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::AI::MachineLearning::ILearningModelFeatureValue>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ILearningModelFeatureValue(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::AI::MachineLearning::ILearningModelFeatureValue>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ILearningModelFeatureValue[] = {
        { "_assign_array_", _assign_array_ILearningModelFeatureValue, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ILearningModelFeatureValue), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ILearningModelFeatureValue[] = {
        { "kind", reinterpret_cast<getter>(ILearningModelFeatureValue_get_Kind), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ILearningModelFeatureValue[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ILearningModelFeatureValue) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ILearningModelFeatureValue) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ILearningModelFeatureValue) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ILearningModelFeatureValue) },
        { },
    };

    static PyType_Spec type_spec_ILearningModelFeatureValue = {
        "winrt._winrt_windows_ai_machinelearning.ILearningModelFeatureValue",
        sizeof(py::wrapper::Windows::AI::MachineLearning::ILearningModelFeatureValue),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ILearningModelFeatureValue};

    // ----- ILearningModelOperatorProvider interface --------------------

    static PyObject* _new_ILearningModelOperatorProvider(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::AI::MachineLearning::ILearningModelOperatorProvider>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::AI::MachineLearning::ILearningModelOperatorProvider>::type_name);
        return nullptr;
    }

    static void _dealloc_ILearningModelOperatorProvider(py::wrapper::Windows::AI::MachineLearning::ILearningModelOperatorProvider* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_ILearningModelOperatorProvider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::AI::MachineLearning::ILearningModelOperatorProvider>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ILearningModelOperatorProvider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::AI::MachineLearning::ILearningModelOperatorProvider>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ILearningModelOperatorProvider[] = {
        { "_assign_array_", _assign_array_ILearningModelOperatorProvider, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ILearningModelOperatorProvider), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ILearningModelOperatorProvider[] = {
        { }
    };

    static PyType_Slot _type_slots_ILearningModelOperatorProvider[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ILearningModelOperatorProvider) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ILearningModelOperatorProvider) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ILearningModelOperatorProvider) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ILearningModelOperatorProvider) },
        { },
    };

    static PyType_Spec type_spec_ILearningModelOperatorProvider = {
        "winrt._winrt_windows_ai_machinelearning.ILearningModelOperatorProvider",
        sizeof(py::wrapper::Windows::AI::MachineLearning::ILearningModelOperatorProvider),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ILearningModelOperatorProvider};

    // ----- ITensor interface --------------------

    static PyObject* _new_ITensor(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::AI::MachineLearning::ITensor>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::AI::MachineLearning::ITensor>::type_name);
        return nullptr;
    }

    static void _dealloc_ITensor(py::wrapper::Windows::AI::MachineLearning::ITensor* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ITensor_get_Shape(py::wrapper::Windows::AI::MachineLearning::ITensor* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.AI.MachineLearning.ITensor", L"Shape"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Shape());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ITensor_get_TensorKind(py::wrapper::Windows::AI::MachineLearning::ITensor* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.AI.MachineLearning.ITensor", L"TensorKind"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.TensorKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ITensor_get_Kind(py::wrapper::Windows::AI::MachineLearning::ITensor* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.AI.MachineLearning.ILearningModelFeatureValue", L"Kind"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ITensor(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::AI::MachineLearning::ITensor>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ITensor(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::AI::MachineLearning::ITensor>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ITensor[] = {
        { "_assign_array_", _assign_array_ITensor, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ITensor), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ITensor[] = {
        { "shape", reinterpret_cast<getter>(ITensor_get_Shape), nullptr, nullptr, nullptr },
        { "tensor_kind", reinterpret_cast<getter>(ITensor_get_TensorKind), nullptr, nullptr, nullptr },
        { "kind", reinterpret_cast<getter>(ITensor_get_Kind), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ITensor[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ITensor) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ITensor) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ITensor) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ITensor) },
        { },
    };

    static PyType_Spec type_spec_ITensor = {
        "winrt._winrt_windows_ai_machinelearning.ITensor",
        sizeof(py::wrapper::Windows::AI::MachineLearning::ITensor),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ITensor};

    // ----- Windows.AI.MachineLearning Initialization --------------------

    PyDoc_STRVAR(module_doc, "Windows.AI.MachineLearning");

    static PyModuleDef module_def = {
        PyModuleDef_HEAD_INIT,
        "_winrt_windows_ai_machinelearning",
        module_doc,
        0,
        nullptr,
        nullptr,
        nullptr,
        nullptr,
        nullptr};
} // py::cpp::Windows::AI::MachineLearning

PyMODINIT_FUNC PyInit__winrt_windows_ai_machinelearning(void) noexcept
{
    using namespace py::cpp::Windows::AI::MachineLearning;

    if (py::import_winrt_runtime() == -1)
    {
        return nullptr;
    }

    py::pyobj_handle module{PyModule_Create(&module_def)};

    if (!module)
    {
        return nullptr;
    }

    auto object_type = py::get_object_type();
    if (!object_type)
    {
        return nullptr;
    }

    py::pyobj_handle object_bases{PyTuple_Pack(1, object_type)};

    if (!object_bases)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ImageFeatureDescriptor, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_ImageFeatureValue_Static{PyType_FromSpec(&type_spec_ImageFeatureValue_Static)};
    if (!type_ImageFeatureValue_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ImageFeatureValue, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_ImageFeatureValue_Static.get())) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_LearningModel_Static{PyType_FromSpec(&type_spec_LearningModel_Static)};
    if (!type_LearningModel_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_LearningModel, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_LearningModel_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_LearningModelBinding, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_LearningModelDevice_Static{PyType_FromSpec(&type_spec_LearningModelDevice_Static)};
    if (!type_LearningModelDevice_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_LearningModelDevice, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_LearningModelDevice_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_LearningModelEvaluationResult, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_LearningModelSession, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_LearningModelSessionOptions, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_MapFeatureDescriptor, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_SequenceFeatureDescriptor, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_TensorBoolean_Static{PyType_FromSpec(&type_spec_TensorBoolean_Static)};
    if (!type_TensorBoolean_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_TensorBoolean, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_TensorBoolean_Static.get())) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_TensorDouble_Static{PyType_FromSpec(&type_spec_TensorDouble_Static)};
    if (!type_TensorDouble_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_TensorDouble, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_TensorDouble_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_TensorFeatureDescriptor, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_TensorFloat_Static{PyType_FromSpec(&type_spec_TensorFloat_Static)};
    if (!type_TensorFloat_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_TensorFloat, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_TensorFloat_Static.get())) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_TensorFloat16Bit_Static{PyType_FromSpec(&type_spec_TensorFloat16Bit_Static)};
    if (!type_TensorFloat16Bit_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_TensorFloat16Bit, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_TensorFloat16Bit_Static.get())) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_TensorInt16Bit_Static{PyType_FromSpec(&type_spec_TensorInt16Bit_Static)};
    if (!type_TensorInt16Bit_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_TensorInt16Bit, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_TensorInt16Bit_Static.get())) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_TensorInt32Bit_Static{PyType_FromSpec(&type_spec_TensorInt32Bit_Static)};
    if (!type_TensorInt32Bit_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_TensorInt32Bit, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_TensorInt32Bit_Static.get())) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_TensorInt64Bit_Static{PyType_FromSpec(&type_spec_TensorInt64Bit_Static)};
    if (!type_TensorInt64Bit_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_TensorInt64Bit, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_TensorInt64Bit_Static.get())) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_TensorInt8Bit_Static{PyType_FromSpec(&type_spec_TensorInt8Bit_Static)};
    if (!type_TensorInt8Bit_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_TensorInt8Bit, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_TensorInt8Bit_Static.get())) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_TensorString_Static{PyType_FromSpec(&type_spec_TensorString_Static)};
    if (!type_TensorString_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_TensorString, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_TensorString_Static.get())) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_TensorUInt16Bit_Static{PyType_FromSpec(&type_spec_TensorUInt16Bit_Static)};
    if (!type_TensorUInt16Bit_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_TensorUInt16Bit, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_TensorUInt16Bit_Static.get())) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_TensorUInt32Bit_Static{PyType_FromSpec(&type_spec_TensorUInt32Bit_Static)};
    if (!type_TensorUInt32Bit_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_TensorUInt32Bit, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_TensorUInt32Bit_Static.get())) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_TensorUInt64Bit_Static{PyType_FromSpec(&type_spec_TensorUInt64Bit_Static)};
    if (!type_TensorUInt64Bit_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_TensorUInt64Bit, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_TensorUInt64Bit_Static.get())) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_TensorUInt8Bit_Static{PyType_FromSpec(&type_spec_TensorUInt8Bit_Static)};
    if (!type_TensorUInt8Bit_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_TensorUInt8Bit, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_TensorUInt8Bit_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ILearningModelFeatureDescriptor, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ILearningModelFeatureValue, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ILearningModelOperatorProvider, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ITensor, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }


    return module.detach();
}
