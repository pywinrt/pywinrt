# WARNING: Please don't edit this file. It was generated by Python/WinRT v2.0.0-beta.2

import datetime
import sys
import types
import typing
import uuid as _uuid
from builtins import property as _property

import winrt._winrt
import winrt.system
import winrt.windows.foundation
import winrt.windows.foundation.collections
import winrt.windows.graphics
import winrt.windows.graphics.directx.direct3d11
import winrt.windows.graphics.imaging
import winrt.windows.media
import winrt.windows.storage
import winrt.windows.storage.streams

from winrt.windows.ai.machinelearning import LearningModelDeviceKind, LearningModelFeatureKind, LearningModelPixelRange, TensorKind

Self = typing.TypeVar('Self')

@typing.final
class ImageFeatureDescriptor(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ImageFeatureDescriptor: ...
    @_property
    def bitmap_alpha_mode(self) -> winrt.windows.graphics.imaging.BitmapAlphaMode: ...
    @_property
    def bitmap_pixel_format(self) -> winrt.windows.graphics.imaging.BitmapPixelFormat: ...
    @_property
    def height(self) -> winrt.system.UInt32: ...
    @_property
    def width(self) -> winrt.system.UInt32: ...
    @_property
    def pixel_range(self) -> LearningModelPixelRange: ...
    @_property
    def description(self) -> str: ...
    @_property
    def is_required(self) -> bool: ...
    @_property
    def kind(self) -> LearningModelFeatureKind: ...
    @_property
    def name(self) -> str: ...

@typing.final
class ImageFeatureValue_Static(type):
    def create_from_video_frame(cls, image: typing.Optional[winrt.windows.media.VideoFrame], /) -> typing.Optional[ImageFeatureValue]: ...

@typing.final
class ImageFeatureValue(winrt.system.Object, metaclass=ImageFeatureValue_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ImageFeatureValue: ...
    @_property
    def video_frame(self) -> typing.Optional[winrt.windows.media.VideoFrame]: ...
    @_property
    def kind(self) -> LearningModelFeatureKind: ...

@typing.final
class LearningModel_Static(type):
    @typing.overload
    def load_from_file_path(cls, file_path: str, /) -> typing.Optional[LearningModel]: ...
    @typing.overload
    def load_from_file_path(cls, file_path: str, operator_provider: typing.Optional[ILearningModelOperatorProvider], /) -> typing.Optional[LearningModel]: ...
    @typing.overload
    def load_from_storage_file_async(cls, model_file: typing.Optional[winrt.windows.storage.IStorageFile], /) -> winrt.windows.foundation.IAsyncOperation[LearningModel]: ...
    @typing.overload
    def load_from_storage_file_async(cls, model_file: typing.Optional[winrt.windows.storage.IStorageFile], operator_provider: typing.Optional[ILearningModelOperatorProvider], /) -> winrt.windows.foundation.IAsyncOperation[LearningModel]: ...
    @typing.overload
    def load_from_stream(cls, model_stream: typing.Optional[winrt.windows.storage.streams.IRandomAccessStreamReference], /) -> typing.Optional[LearningModel]: ...
    @typing.overload
    def load_from_stream(cls, model_stream: typing.Optional[winrt.windows.storage.streams.IRandomAccessStreamReference], operator_provider: typing.Optional[ILearningModelOperatorProvider], /) -> typing.Optional[LearningModel]: ...
    @typing.overload
    def load_from_stream_async(cls, model_stream: typing.Optional[winrt.windows.storage.streams.IRandomAccessStreamReference], /) -> winrt.windows.foundation.IAsyncOperation[LearningModel]: ...
    @typing.overload
    def load_from_stream_async(cls, model_stream: typing.Optional[winrt.windows.storage.streams.IRandomAccessStreamReference], operator_provider: typing.Optional[ILearningModelOperatorProvider], /) -> winrt.windows.foundation.IAsyncOperation[LearningModel]: ...

@typing.final
class LearningModel(winrt.system.Object, metaclass=LearningModel_Static):
    def __enter__(self: Self) -> Self: ...
    def __exit__(self, *args) -> None: ...
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> LearningModel: ...
    def close(self) -> None: ...
    @_property
    def author(self) -> str: ...
    @_property
    def description(self) -> str: ...
    @_property
    def domain(self) -> str: ...
    @_property
    def input_features(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[ILearningModelFeatureDescriptor]]: ...
    @_property
    def metadata(self) -> typing.Optional[winrt.windows.foundation.collections.IMapView[str, str]]: ...
    @_property
    def name(self) -> str: ...
    @_property
    def output_features(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[ILearningModelFeatureDescriptor]]: ...
    @_property
    def version(self) -> winrt.system.Int64: ...

@typing.final
class LearningModelBinding(winrt.system.Object, winrt._winrt.Mapping[str, winrt.system.Object]):
    def __len__(self) -> int: ...
    def __iter__(self) -> typing.Iterator[str]: ...
    def __contains__(self, key: object) -> bool:...
    def __getitem__(self, key: str) -> winrt.system.Object: ...
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> LearningModelBinding: ...
    def __new__(cls: typing.Type[LearningModelBinding], session: typing.Optional[LearningModelSession]) -> LearningModelBinding:...
    @typing.overload
    def bind(self, name: str, value: typing.Optional[winrt.system.Object], /) -> None: ...
    @typing.overload
    def bind(self, name: str, value: typing.Optional[winrt.system.Object], props: typing.Optional[winrt.windows.foundation.collections.IPropertySet], /) -> None: ...
    def clear(self) -> None: ...
    def first(self) -> typing.Optional[winrt.windows.foundation.collections.IIterator[winrt.windows.foundation.collections.IKeyValuePair[str, winrt.system.Object]]]: ...
    def has_key(self, key: str, /) -> bool: ...
    def lookup(self, key: str, /) -> typing.Optional[winrt.system.Object]: ...
    def split(self) -> typing.Tuple[typing.Optional[winrt.windows.foundation.collections.IMapView[str, winrt.system.Object]], typing.Optional[winrt.windows.foundation.collections.IMapView[str, winrt.system.Object]]]: ...
    @_property
    def size(self) -> winrt.system.UInt32: ...

@typing.final
class LearningModelDevice_Static(type):
    def create_from_direct3_d11_device(cls, device: typing.Optional[winrt.windows.graphics.directx.direct3d11.IDirect3DDevice], /) -> typing.Optional[LearningModelDevice]: ...

@typing.final
class LearningModelDevice(winrt.system.Object, metaclass=LearningModelDevice_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> LearningModelDevice: ...
    def __new__(cls: typing.Type[LearningModelDevice], device_kind: LearningModelDeviceKind) -> LearningModelDevice:...
    @_property
    def adapter_id(self) -> winrt.windows.graphics.DisplayAdapterId: ...
    @_property
    def direct3_d11_device(self) -> typing.Optional[winrt.windows.graphics.directx.direct3d11.IDirect3DDevice]: ...

@typing.final
class LearningModelEvaluationResult(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> LearningModelEvaluationResult: ...
    @_property
    def correlation_id(self) -> str: ...
    @_property
    def error_status(self) -> winrt.system.Int32: ...
    @_property
    def outputs(self) -> typing.Optional[winrt.windows.foundation.collections.IMapView[str, winrt.system.Object]]: ...
    @_property
    def succeeded(self) -> bool: ...

@typing.final
class LearningModelSession(winrt.system.Object):
    def __enter__(self: Self) -> Self: ...
    def __exit__(self, *args) -> None: ...
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> LearningModelSession: ...
    @typing.overload
    def __new__(cls: typing.Type[LearningModelSession], model: typing.Optional[LearningModel], device_to_run_on: typing.Optional[LearningModelDevice], learning_model_session_options: typing.Optional[LearningModelSessionOptions]) -> LearningModelSession:...
    @typing.overload
    def __new__(cls: typing.Type[LearningModelSession], model: typing.Optional[LearningModel]) -> LearningModelSession:...
    @typing.overload
    def __new__(cls: typing.Type[LearningModelSession], model: typing.Optional[LearningModel], device_to_run_on: typing.Optional[LearningModelDevice]) -> LearningModelSession:...
    def close(self) -> None: ...
    def evaluate(self, bindings: typing.Optional[LearningModelBinding], correlation_id: str, /) -> typing.Optional[LearningModelEvaluationResult]: ...
    def evaluate_async(self, bindings: typing.Optional[LearningModelBinding], correlation_id: str, /) -> winrt.windows.foundation.IAsyncOperation[LearningModelEvaluationResult]: ...
    def evaluate_features(self, features: winrt.windows.foundation.collections.IMap[str, winrt.system.Object], correlation_id: str, /) -> typing.Optional[LearningModelEvaluationResult]: ...
    def evaluate_features_async(self, features: winrt.windows.foundation.collections.IMap[str, winrt.system.Object], correlation_id: str, /) -> winrt.windows.foundation.IAsyncOperation[LearningModelEvaluationResult]: ...
    @_property
    def device(self) -> typing.Optional[LearningModelDevice]: ...
    @_property
    def evaluation_properties(self) -> typing.Optional[winrt.windows.foundation.collections.IPropertySet]: ...
    @_property
    def model(self) -> typing.Optional[LearningModel]: ...

@typing.final
class LearningModelSessionOptions(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> LearningModelSessionOptions: ...
    def __new__(cls: typing.Type[LearningModelSessionOptions]) -> LearningModelSessionOptions:...
    def override_named_dimension(self, name: str, dimension: winrt.system.UInt32, /) -> None: ...
    @_property
    def batch_size_override(self) -> winrt.system.UInt32: ...
    @batch_size_override.setter
    def batch_size_override(self, value: winrt.system.UInt32) -> None: ...
    @_property
    def close_model_on_session_creation(self) -> bool: ...
    @close_model_on_session_creation.setter
    def close_model_on_session_creation(self, value: bool) -> None: ...

@typing.final
class MapFeatureDescriptor(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MapFeatureDescriptor: ...
    @_property
    def description(self) -> str: ...
    @_property
    def is_required(self) -> bool: ...
    @_property
    def kind(self) -> LearningModelFeatureKind: ...
    @_property
    def name(self) -> str: ...
    @_property
    def key_kind(self) -> TensorKind: ...
    @_property
    def value_descriptor(self) -> typing.Optional[ILearningModelFeatureDescriptor]: ...

@typing.final
class SequenceFeatureDescriptor(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> SequenceFeatureDescriptor: ...
    @_property
    def description(self) -> str: ...
    @_property
    def is_required(self) -> bool: ...
    @_property
    def kind(self) -> LearningModelFeatureKind: ...
    @_property
    def name(self) -> str: ...
    @_property
    def element_descriptor(self) -> typing.Optional[ILearningModelFeatureDescriptor]: ...

@typing.final
class TensorBoolean_Static(type):
    @typing.overload
    def create(cls) -> typing.Optional[TensorBoolean]: ...
    @typing.overload
    def create(cls, shape: typing.Iterable[winrt.system.Int64], /) -> typing.Optional[TensorBoolean]: ...
    def create_from_array(cls, shape: typing.Iterable[winrt.system.Int64], data: winrt.system.Array[bool], /) -> typing.Optional[TensorBoolean]: ...
    def create_from_buffer(cls, shape: winrt.system.Array[winrt.system.Int64], buffer: typing.Optional[winrt.windows.storage.streams.IBuffer], /) -> typing.Optional[TensorBoolean]: ...
    def create_from_iterable(cls, shape: typing.Iterable[winrt.system.Int64], data: typing.Iterable[bool], /) -> typing.Optional[TensorBoolean]: ...
    def create_from_shape_array_and_data_array(cls, shape: winrt.system.Array[winrt.system.Int64], data: winrt.system.Array[bool], /) -> typing.Optional[TensorBoolean]: ...

@typing.final
class TensorBoolean(winrt.system.Object, metaclass=TensorBoolean_Static):
    def __enter__(self: Self) -> Self: ...
    def __exit__(self, *args) -> None: ...
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> TensorBoolean: ...
    def close(self) -> None: ...
    def create_reference(self) -> typing.Optional[winrt.windows.foundation.IMemoryBufferReference]: ...
    def get_as_vector_view(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[bool]]: ...
    @_property
    def kind(self) -> LearningModelFeatureKind: ...
    @_property
    def shape(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[winrt.system.Int64]]: ...
    @_property
    def tensor_kind(self) -> TensorKind: ...

@typing.final
class TensorDouble_Static(type):
    @typing.overload
    def create(cls) -> typing.Optional[TensorDouble]: ...
    @typing.overload
    def create(cls, shape: typing.Iterable[winrt.system.Int64], /) -> typing.Optional[TensorDouble]: ...
    def create_from_array(cls, shape: typing.Iterable[winrt.system.Int64], data: winrt.system.Array[winrt.system.Double], /) -> typing.Optional[TensorDouble]: ...
    def create_from_buffer(cls, shape: winrt.system.Array[winrt.system.Int64], buffer: typing.Optional[winrt.windows.storage.streams.IBuffer], /) -> typing.Optional[TensorDouble]: ...
    def create_from_iterable(cls, shape: typing.Iterable[winrt.system.Int64], data: typing.Iterable[winrt.system.Double], /) -> typing.Optional[TensorDouble]: ...
    def create_from_shape_array_and_data_array(cls, shape: winrt.system.Array[winrt.system.Int64], data: winrt.system.Array[winrt.system.Double], /) -> typing.Optional[TensorDouble]: ...

@typing.final
class TensorDouble(winrt.system.Object, metaclass=TensorDouble_Static):
    def __enter__(self: Self) -> Self: ...
    def __exit__(self, *args) -> None: ...
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> TensorDouble: ...
    def close(self) -> None: ...
    def create_reference(self) -> typing.Optional[winrt.windows.foundation.IMemoryBufferReference]: ...
    def get_as_vector_view(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[winrt.system.Double]]: ...
    @_property
    def kind(self) -> LearningModelFeatureKind: ...
    @_property
    def shape(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[winrt.system.Int64]]: ...
    @_property
    def tensor_kind(self) -> TensorKind: ...

@typing.final
class TensorFeatureDescriptor(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> TensorFeatureDescriptor: ...
    @_property
    def description(self) -> str: ...
    @_property
    def is_required(self) -> bool: ...
    @_property
    def kind(self) -> LearningModelFeatureKind: ...
    @_property
    def name(self) -> str: ...
    @_property
    def shape(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[winrt.system.Int64]]: ...
    @_property
    def tensor_kind(self) -> TensorKind: ...

@typing.final
class TensorFloat_Static(type):
    @typing.overload
    def create(cls) -> typing.Optional[TensorFloat]: ...
    @typing.overload
    def create(cls, shape: typing.Iterable[winrt.system.Int64], /) -> typing.Optional[TensorFloat]: ...
    def create_from_array(cls, shape: typing.Iterable[winrt.system.Int64], data: winrt.system.Array[winrt.system.Single], /) -> typing.Optional[TensorFloat]: ...
    def create_from_buffer(cls, shape: winrt.system.Array[winrt.system.Int64], buffer: typing.Optional[winrt.windows.storage.streams.IBuffer], /) -> typing.Optional[TensorFloat]: ...
    def create_from_iterable(cls, shape: typing.Iterable[winrt.system.Int64], data: typing.Iterable[winrt.system.Single], /) -> typing.Optional[TensorFloat]: ...
    def create_from_shape_array_and_data_array(cls, shape: winrt.system.Array[winrt.system.Int64], data: winrt.system.Array[winrt.system.Single], /) -> typing.Optional[TensorFloat]: ...

@typing.final
class TensorFloat(winrt.system.Object, metaclass=TensorFloat_Static):
    def __enter__(self: Self) -> Self: ...
    def __exit__(self, *args) -> None: ...
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> TensorFloat: ...
    def close(self) -> None: ...
    def create_reference(self) -> typing.Optional[winrt.windows.foundation.IMemoryBufferReference]: ...
    def get_as_vector_view(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[winrt.system.Single]]: ...
    @_property
    def kind(self) -> LearningModelFeatureKind: ...
    @_property
    def shape(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[winrt.system.Int64]]: ...
    @_property
    def tensor_kind(self) -> TensorKind: ...

@typing.final
class TensorFloat16Bit_Static(type):
    @typing.overload
    def create(cls) -> typing.Optional[TensorFloat16Bit]: ...
    @typing.overload
    def create(cls, shape: typing.Iterable[winrt.system.Int64], /) -> typing.Optional[TensorFloat16Bit]: ...
    def create_from_array(cls, shape: typing.Iterable[winrt.system.Int64], data: winrt.system.Array[winrt.system.Single], /) -> typing.Optional[TensorFloat16Bit]: ...
    def create_from_buffer(cls, shape: winrt.system.Array[winrt.system.Int64], buffer: typing.Optional[winrt.windows.storage.streams.IBuffer], /) -> typing.Optional[TensorFloat16Bit]: ...
    def create_from_iterable(cls, shape: typing.Iterable[winrt.system.Int64], data: typing.Iterable[winrt.system.Single], /) -> typing.Optional[TensorFloat16Bit]: ...
    def create_from_shape_array_and_data_array(cls, shape: winrt.system.Array[winrt.system.Int64], data: winrt.system.Array[winrt.system.Single], /) -> typing.Optional[TensorFloat16Bit]: ...

@typing.final
class TensorFloat16Bit(winrt.system.Object, metaclass=TensorFloat16Bit_Static):
    def __enter__(self: Self) -> Self: ...
    def __exit__(self, *args) -> None: ...
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> TensorFloat16Bit: ...
    def close(self) -> None: ...
    def create_reference(self) -> typing.Optional[winrt.windows.foundation.IMemoryBufferReference]: ...
    def get_as_vector_view(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[winrt.system.Single]]: ...
    @_property
    def kind(self) -> LearningModelFeatureKind: ...
    @_property
    def shape(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[winrt.system.Int64]]: ...
    @_property
    def tensor_kind(self) -> TensorKind: ...

@typing.final
class TensorInt16Bit_Static(type):
    @typing.overload
    def create(cls) -> typing.Optional[TensorInt16Bit]: ...
    @typing.overload
    def create(cls, shape: typing.Iterable[winrt.system.Int64], /) -> typing.Optional[TensorInt16Bit]: ...
    def create_from_array(cls, shape: typing.Iterable[winrt.system.Int64], data: winrt.system.Array[winrt.system.Int16], /) -> typing.Optional[TensorInt16Bit]: ...
    def create_from_buffer(cls, shape: winrt.system.Array[winrt.system.Int64], buffer: typing.Optional[winrt.windows.storage.streams.IBuffer], /) -> typing.Optional[TensorInt16Bit]: ...
    def create_from_iterable(cls, shape: typing.Iterable[winrt.system.Int64], data: typing.Iterable[winrt.system.Int16], /) -> typing.Optional[TensorInt16Bit]: ...
    def create_from_shape_array_and_data_array(cls, shape: winrt.system.Array[winrt.system.Int64], data: winrt.system.Array[winrt.system.Int16], /) -> typing.Optional[TensorInt16Bit]: ...

@typing.final
class TensorInt16Bit(winrt.system.Object, metaclass=TensorInt16Bit_Static):
    def __enter__(self: Self) -> Self: ...
    def __exit__(self, *args) -> None: ...
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> TensorInt16Bit: ...
    def close(self) -> None: ...
    def create_reference(self) -> typing.Optional[winrt.windows.foundation.IMemoryBufferReference]: ...
    def get_as_vector_view(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[winrt.system.Int16]]: ...
    @_property
    def kind(self) -> LearningModelFeatureKind: ...
    @_property
    def shape(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[winrt.system.Int64]]: ...
    @_property
    def tensor_kind(self) -> TensorKind: ...

@typing.final
class TensorInt32Bit_Static(type):
    @typing.overload
    def create(cls) -> typing.Optional[TensorInt32Bit]: ...
    @typing.overload
    def create(cls, shape: typing.Iterable[winrt.system.Int64], /) -> typing.Optional[TensorInt32Bit]: ...
    def create_from_array(cls, shape: typing.Iterable[winrt.system.Int64], data: winrt.system.Array[winrt.system.Int32], /) -> typing.Optional[TensorInt32Bit]: ...
    def create_from_buffer(cls, shape: winrt.system.Array[winrt.system.Int64], buffer: typing.Optional[winrt.windows.storage.streams.IBuffer], /) -> typing.Optional[TensorInt32Bit]: ...
    def create_from_iterable(cls, shape: typing.Iterable[winrt.system.Int64], data: typing.Iterable[winrt.system.Int32], /) -> typing.Optional[TensorInt32Bit]: ...
    def create_from_shape_array_and_data_array(cls, shape: winrt.system.Array[winrt.system.Int64], data: winrt.system.Array[winrt.system.Int32], /) -> typing.Optional[TensorInt32Bit]: ...

@typing.final
class TensorInt32Bit(winrt.system.Object, metaclass=TensorInt32Bit_Static):
    def __enter__(self: Self) -> Self: ...
    def __exit__(self, *args) -> None: ...
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> TensorInt32Bit: ...
    def close(self) -> None: ...
    def create_reference(self) -> typing.Optional[winrt.windows.foundation.IMemoryBufferReference]: ...
    def get_as_vector_view(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[winrt.system.Int32]]: ...
    @_property
    def kind(self) -> LearningModelFeatureKind: ...
    @_property
    def shape(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[winrt.system.Int64]]: ...
    @_property
    def tensor_kind(self) -> TensorKind: ...

@typing.final
class TensorInt64Bit_Static(type):
    @typing.overload
    def create(cls) -> typing.Optional[TensorInt64Bit]: ...
    @typing.overload
    def create(cls, shape: typing.Iterable[winrt.system.Int64], /) -> typing.Optional[TensorInt64Bit]: ...
    def create_from_array(cls, shape: typing.Iterable[winrt.system.Int64], data: winrt.system.Array[winrt.system.Int64], /) -> typing.Optional[TensorInt64Bit]: ...
    def create_from_buffer(cls, shape: winrt.system.Array[winrt.system.Int64], buffer: typing.Optional[winrt.windows.storage.streams.IBuffer], /) -> typing.Optional[TensorInt64Bit]: ...
    def create_from_iterable(cls, shape: typing.Iterable[winrt.system.Int64], data: typing.Iterable[winrt.system.Int64], /) -> typing.Optional[TensorInt64Bit]: ...
    def create_from_shape_array_and_data_array(cls, shape: winrt.system.Array[winrt.system.Int64], data: winrt.system.Array[winrt.system.Int64], /) -> typing.Optional[TensorInt64Bit]: ...

@typing.final
class TensorInt64Bit(winrt.system.Object, metaclass=TensorInt64Bit_Static):
    def __enter__(self: Self) -> Self: ...
    def __exit__(self, *args) -> None: ...
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> TensorInt64Bit: ...
    def close(self) -> None: ...
    def create_reference(self) -> typing.Optional[winrt.windows.foundation.IMemoryBufferReference]: ...
    def get_as_vector_view(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[winrt.system.Int64]]: ...
    @_property
    def kind(self) -> LearningModelFeatureKind: ...
    @_property
    def shape(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[winrt.system.Int64]]: ...
    @_property
    def tensor_kind(self) -> TensorKind: ...

@typing.final
class TensorInt8Bit_Static(type):
    @typing.overload
    def create(cls) -> typing.Optional[TensorInt8Bit]: ...
    @typing.overload
    def create(cls, shape: typing.Iterable[winrt.system.Int64], /) -> typing.Optional[TensorInt8Bit]: ...
    def create_from_array(cls, shape: typing.Iterable[winrt.system.Int64], data: winrt.system.Array[winrt.system.UInt8], /) -> typing.Optional[TensorInt8Bit]: ...
    def create_from_buffer(cls, shape: winrt.system.Array[winrt.system.Int64], buffer: typing.Optional[winrt.windows.storage.streams.IBuffer], /) -> typing.Optional[TensorInt8Bit]: ...
    def create_from_iterable(cls, shape: typing.Iterable[winrt.system.Int64], data: typing.Iterable[winrt.system.UInt8], /) -> typing.Optional[TensorInt8Bit]: ...
    def create_from_shape_array_and_data_array(cls, shape: winrt.system.Array[winrt.system.Int64], data: winrt.system.Array[winrt.system.UInt8], /) -> typing.Optional[TensorInt8Bit]: ...

@typing.final
class TensorInt8Bit(winrt.system.Object, metaclass=TensorInt8Bit_Static):
    def __enter__(self: Self) -> Self: ...
    def __exit__(self, *args) -> None: ...
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> TensorInt8Bit: ...
    def close(self) -> None: ...
    def create_reference(self) -> typing.Optional[winrt.windows.foundation.IMemoryBufferReference]: ...
    def get_as_vector_view(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[winrt.system.UInt8]]: ...
    @_property
    def kind(self) -> LearningModelFeatureKind: ...
    @_property
    def shape(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[winrt.system.Int64]]: ...
    @_property
    def tensor_kind(self) -> TensorKind: ...

@typing.final
class TensorString_Static(type):
    @typing.overload
    def create(cls) -> typing.Optional[TensorString]: ...
    @typing.overload
    def create(cls, shape: typing.Iterable[winrt.system.Int64], /) -> typing.Optional[TensorString]: ...
    def create_from_array(cls, shape: typing.Iterable[winrt.system.Int64], data: winrt.system.Array[str], /) -> typing.Optional[TensorString]: ...
    def create_from_iterable(cls, shape: typing.Iterable[winrt.system.Int64], data: typing.Iterable[str], /) -> typing.Optional[TensorString]: ...
    def create_from_shape_array_and_data_array(cls, shape: winrt.system.Array[winrt.system.Int64], data: winrt.system.Array[str], /) -> typing.Optional[TensorString]: ...

@typing.final
class TensorString(winrt.system.Object, metaclass=TensorString_Static):
    def __enter__(self: Self) -> Self: ...
    def __exit__(self, *args) -> None: ...
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> TensorString: ...
    def close(self) -> None: ...
    def create_reference(self) -> typing.Optional[winrt.windows.foundation.IMemoryBufferReference]: ...
    def get_as_vector_view(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[str]]: ...
    @_property
    def kind(self) -> LearningModelFeatureKind: ...
    @_property
    def shape(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[winrt.system.Int64]]: ...
    @_property
    def tensor_kind(self) -> TensorKind: ...

@typing.final
class TensorUInt16Bit_Static(type):
    @typing.overload
    def create(cls) -> typing.Optional[TensorUInt16Bit]: ...
    @typing.overload
    def create(cls, shape: typing.Iterable[winrt.system.Int64], /) -> typing.Optional[TensorUInt16Bit]: ...
    def create_from_array(cls, shape: typing.Iterable[winrt.system.Int64], data: winrt.system.Array[winrt.system.UInt16], /) -> typing.Optional[TensorUInt16Bit]: ...
    def create_from_buffer(cls, shape: winrt.system.Array[winrt.system.Int64], buffer: typing.Optional[winrt.windows.storage.streams.IBuffer], /) -> typing.Optional[TensorUInt16Bit]: ...
    def create_from_iterable(cls, shape: typing.Iterable[winrt.system.Int64], data: typing.Iterable[winrt.system.UInt16], /) -> typing.Optional[TensorUInt16Bit]: ...
    def create_from_shape_array_and_data_array(cls, shape: winrt.system.Array[winrt.system.Int64], data: winrt.system.Array[winrt.system.UInt16], /) -> typing.Optional[TensorUInt16Bit]: ...

@typing.final
class TensorUInt16Bit(winrt.system.Object, metaclass=TensorUInt16Bit_Static):
    def __enter__(self: Self) -> Self: ...
    def __exit__(self, *args) -> None: ...
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> TensorUInt16Bit: ...
    def close(self) -> None: ...
    def create_reference(self) -> typing.Optional[winrt.windows.foundation.IMemoryBufferReference]: ...
    def get_as_vector_view(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[winrt.system.UInt16]]: ...
    @_property
    def kind(self) -> LearningModelFeatureKind: ...
    @_property
    def shape(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[winrt.system.Int64]]: ...
    @_property
    def tensor_kind(self) -> TensorKind: ...

@typing.final
class TensorUInt32Bit_Static(type):
    @typing.overload
    def create(cls) -> typing.Optional[TensorUInt32Bit]: ...
    @typing.overload
    def create(cls, shape: typing.Iterable[winrt.system.Int64], /) -> typing.Optional[TensorUInt32Bit]: ...
    def create_from_array(cls, shape: typing.Iterable[winrt.system.Int64], data: winrt.system.Array[winrt.system.UInt32], /) -> typing.Optional[TensorUInt32Bit]: ...
    def create_from_buffer(cls, shape: winrt.system.Array[winrt.system.Int64], buffer: typing.Optional[winrt.windows.storage.streams.IBuffer], /) -> typing.Optional[TensorUInt32Bit]: ...
    def create_from_iterable(cls, shape: typing.Iterable[winrt.system.Int64], data: typing.Iterable[winrt.system.UInt32], /) -> typing.Optional[TensorUInt32Bit]: ...
    def create_from_shape_array_and_data_array(cls, shape: winrt.system.Array[winrt.system.Int64], data: winrt.system.Array[winrt.system.UInt32], /) -> typing.Optional[TensorUInt32Bit]: ...

@typing.final
class TensorUInt32Bit(winrt.system.Object, metaclass=TensorUInt32Bit_Static):
    def __enter__(self: Self) -> Self: ...
    def __exit__(self, *args) -> None: ...
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> TensorUInt32Bit: ...
    def close(self) -> None: ...
    def create_reference(self) -> typing.Optional[winrt.windows.foundation.IMemoryBufferReference]: ...
    def get_as_vector_view(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[winrt.system.UInt32]]: ...
    @_property
    def kind(self) -> LearningModelFeatureKind: ...
    @_property
    def shape(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[winrt.system.Int64]]: ...
    @_property
    def tensor_kind(self) -> TensorKind: ...

@typing.final
class TensorUInt64Bit_Static(type):
    @typing.overload
    def create(cls) -> typing.Optional[TensorUInt64Bit]: ...
    @typing.overload
    def create(cls, shape: typing.Iterable[winrt.system.Int64], /) -> typing.Optional[TensorUInt64Bit]: ...
    def create_from_array(cls, shape: typing.Iterable[winrt.system.Int64], data: winrt.system.Array[winrt.system.UInt64], /) -> typing.Optional[TensorUInt64Bit]: ...
    def create_from_buffer(cls, shape: winrt.system.Array[winrt.system.Int64], buffer: typing.Optional[winrt.windows.storage.streams.IBuffer], /) -> typing.Optional[TensorUInt64Bit]: ...
    def create_from_iterable(cls, shape: typing.Iterable[winrt.system.Int64], data: typing.Iterable[winrt.system.UInt64], /) -> typing.Optional[TensorUInt64Bit]: ...
    def create_from_shape_array_and_data_array(cls, shape: winrt.system.Array[winrt.system.Int64], data: winrt.system.Array[winrt.system.UInt64], /) -> typing.Optional[TensorUInt64Bit]: ...

@typing.final
class TensorUInt64Bit(winrt.system.Object, metaclass=TensorUInt64Bit_Static):
    def __enter__(self: Self) -> Self: ...
    def __exit__(self, *args) -> None: ...
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> TensorUInt64Bit: ...
    def close(self) -> None: ...
    def create_reference(self) -> typing.Optional[winrt.windows.foundation.IMemoryBufferReference]: ...
    def get_as_vector_view(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[winrt.system.UInt64]]: ...
    @_property
    def kind(self) -> LearningModelFeatureKind: ...
    @_property
    def shape(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[winrt.system.Int64]]: ...
    @_property
    def tensor_kind(self) -> TensorKind: ...

@typing.final
class TensorUInt8Bit_Static(type):
    @typing.overload
    def create(cls) -> typing.Optional[TensorUInt8Bit]: ...
    @typing.overload
    def create(cls, shape: typing.Iterable[winrt.system.Int64], /) -> typing.Optional[TensorUInt8Bit]: ...
    def create_from_array(cls, shape: typing.Iterable[winrt.system.Int64], data: winrt.system.Array[winrt.system.UInt8], /) -> typing.Optional[TensorUInt8Bit]: ...
    def create_from_buffer(cls, shape: winrt.system.Array[winrt.system.Int64], buffer: typing.Optional[winrt.windows.storage.streams.IBuffer], /) -> typing.Optional[TensorUInt8Bit]: ...
    def create_from_iterable(cls, shape: typing.Iterable[winrt.system.Int64], data: typing.Iterable[winrt.system.UInt8], /) -> typing.Optional[TensorUInt8Bit]: ...
    def create_from_shape_array_and_data_array(cls, shape: winrt.system.Array[winrt.system.Int64], data: winrt.system.Array[winrt.system.UInt8], /) -> typing.Optional[TensorUInt8Bit]: ...

@typing.final
class TensorUInt8Bit(winrt.system.Object, metaclass=TensorUInt8Bit_Static):
    def __enter__(self: Self) -> Self: ...
    def __exit__(self, *args) -> None: ...
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> TensorUInt8Bit: ...
    def close(self) -> None: ...
    def create_reference(self) -> typing.Optional[winrt.windows.foundation.IMemoryBufferReference]: ...
    def get_as_vector_view(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[winrt.system.UInt8]]: ...
    @_property
    def kind(self) -> LearningModelFeatureKind: ...
    @_property
    def shape(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[winrt.system.Int64]]: ...
    @_property
    def tensor_kind(self) -> TensorKind: ...

@typing.final
class ILearningModelFeatureDescriptor(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ILearningModelFeatureDescriptor: ...
    @_property
    def description(self) -> str: ...
    @_property
    def is_required(self) -> bool: ...
    @_property
    def kind(self) -> LearningModelFeatureKind: ...
    @_property
    def name(self) -> str: ...

@typing.final
class ILearningModelFeatureValue(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ILearningModelFeatureValue: ...
    @_property
    def kind(self) -> LearningModelFeatureKind: ...

@typing.final
class ILearningModelOperatorProvider(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ILearningModelOperatorProvider: ...

@typing.final
class ITensor(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ITensor: ...
    @_property
    def shape(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[winrt.system.Int64]]: ...
    @_property
    def tensor_kind(self) -> TensorKind: ...
    @_property
    def kind(self) -> LearningModelFeatureKind: ...

