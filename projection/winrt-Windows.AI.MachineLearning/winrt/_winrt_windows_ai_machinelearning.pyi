# WARNING: Please don't edit this file. It was generated by Python/WinRT v0.0.0

import datetime
import sys
import types
import typing
import uuid as _uuid
from builtins import property as _property

import winrt._winrt
import winrt.system
import winrt.windows.foundation as windows_foundation
import winrt.windows.foundation.collections as windows_foundation_collections
import winrt.windows.graphics as windows_graphics
import winrt.windows.graphics.directx.direct3d11 as windows_graphics_directx_direct3d11
import winrt.windows.graphics.imaging as windows_graphics_imaging
import winrt.windows.media as windows_media
import winrt.windows.storage as windows_storage
import winrt.windows.storage.streams as windows_storage_streams

from winrt.windows.ai.machinelearning import LearningModelDeviceKind, LearningModelFeatureKind, LearningModelPixelRange, TensorKind

Self = typing.TypeVar('Self')

@typing.final
class ImageFeatureDescriptor(winrt.system.Object, ImplementsILearningModelFeatureDescriptor):
    @_property
    def bitmap_alpha_mode(self) -> windows_graphics_imaging.BitmapAlphaMode: ...
    @_property
    def bitmap_pixel_format(self) -> windows_graphics_imaging.BitmapPixelFormat: ...
    @_property
    def height(self) -> winrt.system.UInt32: ...
    @_property
    def width(self) -> winrt.system.UInt32: ...
    @_property
    def pixel_range(self) -> LearningModelPixelRange: ...
    @_property
    def description(self) -> str: ...
    @_property
    def is_required(self) -> bool: ...
    @_property
    def kind(self) -> LearningModelFeatureKind: ...
    @_property
    def name(self) -> str: ...

@typing.final
class ImageFeatureValue_Static(type):
    def create_from_video_frame(cls, image: windows_media.VideoFrame, /) -> ImageFeatureValue: ...

@typing.final
class ImageFeatureValue(winrt.system.Object, ImplementsILearningModelFeatureValue, metaclass=ImageFeatureValue_Static):
    @_property
    def video_frame(self) -> windows_media.VideoFrame: ...
    @_property
    def kind(self) -> LearningModelFeatureKind: ...

@typing.final
class LearningModel_Static(type):
    def load_from_file_path(cls, file_path: str, /) -> LearningModel: ...
    def load_from_file_path_with_operator_provider(cls, file_path: str, operator_provider: ImplementsILearningModelOperatorProvider, /) -> LearningModel: ...
    def load_from_storage_file_async(cls, model_file: windows_storage.ImplementsIStorageFile, /) -> windows_foundation.IAsyncOperation[LearningModel]: ...
    def load_from_storage_file_with_operator_provider_async(cls, model_file: windows_storage.ImplementsIStorageFile, operator_provider: ImplementsILearningModelOperatorProvider, /) -> windows_foundation.IAsyncOperation[LearningModel]: ...
    def load_from_stream(cls, model_stream: windows_storage_streams.ImplementsIRandomAccessStreamReference, /) -> LearningModel: ...
    def load_from_stream_async(cls, model_stream: windows_storage_streams.ImplementsIRandomAccessStreamReference, /) -> windows_foundation.IAsyncOperation[LearningModel]: ...
    def load_from_stream_with_operator_provider(cls, model_stream: windows_storage_streams.ImplementsIRandomAccessStreamReference, operator_provider: ImplementsILearningModelOperatorProvider, /) -> LearningModel: ...
    def load_from_stream_with_operator_provider_async(cls, model_stream: windows_storage_streams.ImplementsIRandomAccessStreamReference, operator_provider: ImplementsILearningModelOperatorProvider, /) -> windows_foundation.IAsyncOperation[LearningModel]: ...

@typing.final
class LearningModel(winrt.system.Object, windows_foundation.ImplementsIClosable, metaclass=LearningModel_Static):
    def __enter__(self: Self) -> Self: ...
    def __exit__(self, *args) -> None: ...
    def close(self) -> None: ...
    @_property
    def author(self) -> str: ...
    @_property
    def description(self) -> str: ...
    @_property
    def domain(self) -> str: ...
    @_property
    def input_features(self) -> typing.Sequence[ILearningModelFeatureDescriptor]: ...
    @_property
    def metadata(self) -> typing.Mapping[str, str]: ...
    @_property
    def name(self) -> str: ...
    @_property
    def output_features(self) -> typing.Sequence[ILearningModelFeatureDescriptor]: ...
    @_property
    def version(self) -> winrt.system.Int64: ...

@typing.final
class LearningModelBinding(winrt.system.Object, winrt._winrt.Mapping[str, winrt.system.Object]):
    def __len__(self) -> int: ...
    def __iter__(self) -> typing.Iterator[str]: ...
    def __contains__(self, key: object) -> bool: ...
    def __getitem__(self, key: str) -> winrt.system.Object: ...
    def __new__(cls: typing.Type[Self], session: LearningModelSession) -> Self: ...
    def bind(self, name: str, value: winrt.system.Object, /) -> None: ...
    def bind_with_properties(self, name: str, value: winrt.system.Object, props: windows_foundation_collections.ImplementsIPropertySet, /) -> None: ...
    def clear(self) -> None: ...
    def first(self) -> windows_foundation_collections.IIterator[windows_foundation_collections.IKeyValuePair[str, winrt.system.Object]]: ...
    def has_key(self, key: str, /) -> bool: ...
    def lookup(self, key: str, /) -> winrt.system.Object: ...
    def split(self) -> typing.Tuple[typing.Mapping[str, winrt.system.Object], typing.Mapping[str, winrt.system.Object]]: ...
    @_property
    def size(self) -> winrt.system.UInt32: ...

@typing.final
class LearningModelDevice_Static(type):
    def create_from_direct3d11_device(cls, device: windows_graphics_directx_direct3d11.ImplementsIDirect3DDevice, /) -> LearningModelDevice: ...

@typing.final
class LearningModelDevice(winrt.system.Object, metaclass=LearningModelDevice_Static):
    def __new__(cls: typing.Type[Self], device_kind: LearningModelDeviceKind) -> Self: ...
    @_property
    def adapter_id(self) -> windows_graphics.DisplayAdapterId: ...
    @_property
    def direct3d11_device(self) -> windows_graphics_directx_direct3d11.IDirect3DDevice: ...

@typing.final
class LearningModelEvaluationResult(winrt.system.Object):
    @_property
    def correlation_id(self) -> str: ...
    @_property
    def error_status(self) -> winrt.system.Int32: ...
    @_property
    def outputs(self) -> typing.Mapping[str, winrt.system.Object]: ...
    @_property
    def succeeded(self) -> bool: ...

@typing.final
class LearningModelSession(winrt.system.Object, windows_foundation.ImplementsIClosable):
    def __enter__(self: Self) -> Self: ...
    def __exit__(self, *args) -> None: ...
    @typing.overload
    def __new__(cls: typing.Type[Self], model: LearningModel, device_to_run_on: LearningModelDevice, learning_model_session_options: LearningModelSessionOptions) -> Self: ...
    @typing.overload
    def __new__(cls: typing.Type[Self], model: LearningModel) -> Self: ...
    @typing.overload
    def __new__(cls: typing.Type[Self], model: LearningModel, device_to_run_on: LearningModelDevice) -> Self: ...
    def close(self) -> None: ...
    def evaluate(self, bindings: LearningModelBinding, correlation_id: str, /) -> LearningModelEvaluationResult: ...
    def evaluate_async(self, bindings: LearningModelBinding, correlation_id: str, /) -> windows_foundation.IAsyncOperation[LearningModelEvaluationResult]: ...
    def evaluate_features(self, features: typing.MutableMapping[str, winrt.system.Object], correlation_id: str, /) -> LearningModelEvaluationResult: ...
    def evaluate_features_async(self, features: typing.MutableMapping[str, winrt.system.Object], correlation_id: str, /) -> windows_foundation.IAsyncOperation[LearningModelEvaluationResult]: ...
    @_property
    def device(self) -> LearningModelDevice: ...
    @_property
    def evaluation_properties(self) -> windows_foundation_collections.IPropertySet: ...
    @_property
    def model(self) -> LearningModel: ...

@typing.final
class LearningModelSessionOptions(winrt.system.Object):
    def __new__(cls: typing.Type[Self]) -> Self: ...
    def override_named_dimension(self, name: str, dimension: winrt.system.UInt32, /) -> None: ...
    @_property
    def batch_size_override(self) -> winrt.system.UInt32: ...
    @batch_size_override.setter
    def batch_size_override(self, value: winrt.system.UInt32) -> None: ...
    @_property
    def close_model_on_session_creation(self) -> bool: ...
    @close_model_on_session_creation.setter
    def close_model_on_session_creation(self, value: bool) -> None: ...

@typing.final
class MapFeatureDescriptor(winrt.system.Object, ImplementsILearningModelFeatureDescriptor):
    @_property
    def description(self) -> str: ...
    @_property
    def is_required(self) -> bool: ...
    @_property
    def kind(self) -> LearningModelFeatureKind: ...
    @_property
    def name(self) -> str: ...
    @_property
    def key_kind(self) -> TensorKind: ...
    @_property
    def value_descriptor(self) -> ILearningModelFeatureDescriptor: ...

@typing.final
class SequenceFeatureDescriptor(winrt.system.Object, ImplementsILearningModelFeatureDescriptor):
    @_property
    def description(self) -> str: ...
    @_property
    def is_required(self) -> bool: ...
    @_property
    def kind(self) -> LearningModelFeatureKind: ...
    @_property
    def name(self) -> str: ...
    @_property
    def element_descriptor(self) -> ILearningModelFeatureDescriptor: ...

@typing.final
class TensorBoolean_Static(type):
    def create(cls) -> TensorBoolean: ...
    def create2(cls, shape: typing.Iterable[winrt.system.Int64], /) -> TensorBoolean: ...
    def create_from_array(cls, shape: typing.Iterable[winrt.system.Int64], data: typing.Union[winrt.system.Array[bool], winrt.system.ReadableBuffer], /) -> TensorBoolean: ...
    def create_from_buffer(cls, shape: typing.Union[winrt.system.Array[winrt.system.Int64], winrt.system.ReadableBuffer], buffer: windows_storage_streams.ImplementsIBuffer, /) -> TensorBoolean: ...
    def create_from_iterable(cls, shape: typing.Iterable[winrt.system.Int64], data: typing.Iterable[bool], /) -> TensorBoolean: ...
    def create_from_shape_array_and_data_array(cls, shape: typing.Union[winrt.system.Array[winrt.system.Int64], winrt.system.ReadableBuffer], data: typing.Union[winrt.system.Array[bool], winrt.system.ReadableBuffer], /) -> TensorBoolean: ...

@typing.final
class TensorBoolean(winrt.system.Object, windows_foundation.ImplementsIMemoryBuffer, windows_foundation.ImplementsIClosable, ImplementsITensor, ImplementsILearningModelFeatureValue, metaclass=TensorBoolean_Static):
    def __enter__(self: Self) -> Self: ...
    def __exit__(self, *args) -> None: ...
    def close(self) -> None: ...
    def create_reference(self) -> windows_foundation.IMemoryBufferReference: ...
    def get_as_vector_view(self) -> typing.Sequence[bool]: ...
    @_property
    def kind(self) -> LearningModelFeatureKind: ...
    @_property
    def shape(self) -> typing.Sequence[winrt.system.Int64]: ...
    @_property
    def tensor_kind(self) -> TensorKind: ...

@typing.final
class TensorDouble_Static(type):
    def create(cls) -> TensorDouble: ...
    def create2(cls, shape: typing.Iterable[winrt.system.Int64], /) -> TensorDouble: ...
    def create_from_array(cls, shape: typing.Iterable[winrt.system.Int64], data: typing.Union[winrt.system.Array[winrt.system.Double], winrt.system.ReadableBuffer], /) -> TensorDouble: ...
    def create_from_buffer(cls, shape: typing.Union[winrt.system.Array[winrt.system.Int64], winrt.system.ReadableBuffer], buffer: windows_storage_streams.ImplementsIBuffer, /) -> TensorDouble: ...
    def create_from_iterable(cls, shape: typing.Iterable[winrt.system.Int64], data: typing.Iterable[winrt.system.Double], /) -> TensorDouble: ...
    def create_from_shape_array_and_data_array(cls, shape: typing.Union[winrt.system.Array[winrt.system.Int64], winrt.system.ReadableBuffer], data: typing.Union[winrt.system.Array[winrt.system.Double], winrt.system.ReadableBuffer], /) -> TensorDouble: ...

@typing.final
class TensorDouble(winrt.system.Object, windows_foundation.ImplementsIMemoryBuffer, windows_foundation.ImplementsIClosable, ImplementsITensor, ImplementsILearningModelFeatureValue, metaclass=TensorDouble_Static):
    def __enter__(self: Self) -> Self: ...
    def __exit__(self, *args) -> None: ...
    def close(self) -> None: ...
    def create_reference(self) -> windows_foundation.IMemoryBufferReference: ...
    def get_as_vector_view(self) -> typing.Sequence[winrt.system.Double]: ...
    @_property
    def kind(self) -> LearningModelFeatureKind: ...
    @_property
    def shape(self) -> typing.Sequence[winrt.system.Int64]: ...
    @_property
    def tensor_kind(self) -> TensorKind: ...

@typing.final
class TensorFeatureDescriptor(winrt.system.Object, ImplementsILearningModelFeatureDescriptor):
    @_property
    def description(self) -> str: ...
    @_property
    def is_required(self) -> bool: ...
    @_property
    def kind(self) -> LearningModelFeatureKind: ...
    @_property
    def name(self) -> str: ...
    @_property
    def shape(self) -> typing.Sequence[winrt.system.Int64]: ...
    @_property
    def tensor_kind(self) -> TensorKind: ...

@typing.final
class TensorFloat_Static(type):
    def create(cls) -> TensorFloat: ...
    def create2(cls, shape: typing.Iterable[winrt.system.Int64], /) -> TensorFloat: ...
    def create_from_array(cls, shape: typing.Iterable[winrt.system.Int64], data: typing.Union[winrt.system.Array[winrt.system.Single], winrt.system.ReadableBuffer], /) -> TensorFloat: ...
    def create_from_buffer(cls, shape: typing.Union[winrt.system.Array[winrt.system.Int64], winrt.system.ReadableBuffer], buffer: windows_storage_streams.ImplementsIBuffer, /) -> TensorFloat: ...
    def create_from_iterable(cls, shape: typing.Iterable[winrt.system.Int64], data: typing.Iterable[winrt.system.Single], /) -> TensorFloat: ...
    def create_from_shape_array_and_data_array(cls, shape: typing.Union[winrt.system.Array[winrt.system.Int64], winrt.system.ReadableBuffer], data: typing.Union[winrt.system.Array[winrt.system.Single], winrt.system.ReadableBuffer], /) -> TensorFloat: ...

@typing.final
class TensorFloat(winrt.system.Object, windows_foundation.ImplementsIMemoryBuffer, windows_foundation.ImplementsIClosable, ImplementsITensor, ImplementsILearningModelFeatureValue, metaclass=TensorFloat_Static):
    def __enter__(self: Self) -> Self: ...
    def __exit__(self, *args) -> None: ...
    def close(self) -> None: ...
    def create_reference(self) -> windows_foundation.IMemoryBufferReference: ...
    def get_as_vector_view(self) -> typing.Sequence[winrt.system.Single]: ...
    @_property
    def kind(self) -> LearningModelFeatureKind: ...
    @_property
    def shape(self) -> typing.Sequence[winrt.system.Int64]: ...
    @_property
    def tensor_kind(self) -> TensorKind: ...

@typing.final
class TensorFloat16Bit_Static(type):
    def create(cls) -> TensorFloat16Bit: ...
    def create2(cls, shape: typing.Iterable[winrt.system.Int64], /) -> TensorFloat16Bit: ...
    def create_from_array(cls, shape: typing.Iterable[winrt.system.Int64], data: typing.Union[winrt.system.Array[winrt.system.Single], winrt.system.ReadableBuffer], /) -> TensorFloat16Bit: ...
    def create_from_buffer(cls, shape: typing.Union[winrt.system.Array[winrt.system.Int64], winrt.system.ReadableBuffer], buffer: windows_storage_streams.ImplementsIBuffer, /) -> TensorFloat16Bit: ...
    def create_from_iterable(cls, shape: typing.Iterable[winrt.system.Int64], data: typing.Iterable[winrt.system.Single], /) -> TensorFloat16Bit: ...
    def create_from_shape_array_and_data_array(cls, shape: typing.Union[winrt.system.Array[winrt.system.Int64], winrt.system.ReadableBuffer], data: typing.Union[winrt.system.Array[winrt.system.Single], winrt.system.ReadableBuffer], /) -> TensorFloat16Bit: ...

@typing.final
class TensorFloat16Bit(winrt.system.Object, windows_foundation.ImplementsIMemoryBuffer, windows_foundation.ImplementsIClosable, ImplementsITensor, ImplementsILearningModelFeatureValue, metaclass=TensorFloat16Bit_Static):
    def __enter__(self: Self) -> Self: ...
    def __exit__(self, *args) -> None: ...
    def close(self) -> None: ...
    def create_reference(self) -> windows_foundation.IMemoryBufferReference: ...
    def get_as_vector_view(self) -> typing.Sequence[winrt.system.Single]: ...
    @_property
    def kind(self) -> LearningModelFeatureKind: ...
    @_property
    def shape(self) -> typing.Sequence[winrt.system.Int64]: ...
    @_property
    def tensor_kind(self) -> TensorKind: ...

@typing.final
class TensorInt16Bit_Static(type):
    def create(cls) -> TensorInt16Bit: ...
    def create2(cls, shape: typing.Iterable[winrt.system.Int64], /) -> TensorInt16Bit: ...
    def create_from_array(cls, shape: typing.Iterable[winrt.system.Int64], data: typing.Union[winrt.system.Array[winrt.system.Int16], winrt.system.ReadableBuffer], /) -> TensorInt16Bit: ...
    def create_from_buffer(cls, shape: typing.Union[winrt.system.Array[winrt.system.Int64], winrt.system.ReadableBuffer], buffer: windows_storage_streams.ImplementsIBuffer, /) -> TensorInt16Bit: ...
    def create_from_iterable(cls, shape: typing.Iterable[winrt.system.Int64], data: typing.Iterable[winrt.system.Int16], /) -> TensorInt16Bit: ...
    def create_from_shape_array_and_data_array(cls, shape: typing.Union[winrt.system.Array[winrt.system.Int64], winrt.system.ReadableBuffer], data: typing.Union[winrt.system.Array[winrt.system.Int16], winrt.system.ReadableBuffer], /) -> TensorInt16Bit: ...

@typing.final
class TensorInt16Bit(winrt.system.Object, windows_foundation.ImplementsIMemoryBuffer, windows_foundation.ImplementsIClosable, ImplementsITensor, ImplementsILearningModelFeatureValue, metaclass=TensorInt16Bit_Static):
    def __enter__(self: Self) -> Self: ...
    def __exit__(self, *args) -> None: ...
    def close(self) -> None: ...
    def create_reference(self) -> windows_foundation.IMemoryBufferReference: ...
    def get_as_vector_view(self) -> typing.Sequence[winrt.system.Int16]: ...
    @_property
    def kind(self) -> LearningModelFeatureKind: ...
    @_property
    def shape(self) -> typing.Sequence[winrt.system.Int64]: ...
    @_property
    def tensor_kind(self) -> TensorKind: ...

@typing.final
class TensorInt32Bit_Static(type):
    def create(cls) -> TensorInt32Bit: ...
    def create2(cls, shape: typing.Iterable[winrt.system.Int64], /) -> TensorInt32Bit: ...
    def create_from_array(cls, shape: typing.Iterable[winrt.system.Int64], data: typing.Union[winrt.system.Array[winrt.system.Int32], winrt.system.ReadableBuffer], /) -> TensorInt32Bit: ...
    def create_from_buffer(cls, shape: typing.Union[winrt.system.Array[winrt.system.Int64], winrt.system.ReadableBuffer], buffer: windows_storage_streams.ImplementsIBuffer, /) -> TensorInt32Bit: ...
    def create_from_iterable(cls, shape: typing.Iterable[winrt.system.Int64], data: typing.Iterable[winrt.system.Int32], /) -> TensorInt32Bit: ...
    def create_from_shape_array_and_data_array(cls, shape: typing.Union[winrt.system.Array[winrt.system.Int64], winrt.system.ReadableBuffer], data: typing.Union[winrt.system.Array[winrt.system.Int32], winrt.system.ReadableBuffer], /) -> TensorInt32Bit: ...

@typing.final
class TensorInt32Bit(winrt.system.Object, windows_foundation.ImplementsIMemoryBuffer, windows_foundation.ImplementsIClosable, ImplementsITensor, ImplementsILearningModelFeatureValue, metaclass=TensorInt32Bit_Static):
    def __enter__(self: Self) -> Self: ...
    def __exit__(self, *args) -> None: ...
    def close(self) -> None: ...
    def create_reference(self) -> windows_foundation.IMemoryBufferReference: ...
    def get_as_vector_view(self) -> typing.Sequence[winrt.system.Int32]: ...
    @_property
    def kind(self) -> LearningModelFeatureKind: ...
    @_property
    def shape(self) -> typing.Sequence[winrt.system.Int64]: ...
    @_property
    def tensor_kind(self) -> TensorKind: ...

@typing.final
class TensorInt64Bit_Static(type):
    def create(cls) -> TensorInt64Bit: ...
    def create2(cls, shape: typing.Iterable[winrt.system.Int64], /) -> TensorInt64Bit: ...
    def create_from_array(cls, shape: typing.Iterable[winrt.system.Int64], data: typing.Union[winrt.system.Array[winrt.system.Int64], winrt.system.ReadableBuffer], /) -> TensorInt64Bit: ...
    def create_from_buffer(cls, shape: typing.Union[winrt.system.Array[winrt.system.Int64], winrt.system.ReadableBuffer], buffer: windows_storage_streams.ImplementsIBuffer, /) -> TensorInt64Bit: ...
    def create_from_iterable(cls, shape: typing.Iterable[winrt.system.Int64], data: typing.Iterable[winrt.system.Int64], /) -> TensorInt64Bit: ...
    def create_from_shape_array_and_data_array(cls, shape: typing.Union[winrt.system.Array[winrt.system.Int64], winrt.system.ReadableBuffer], data: typing.Union[winrt.system.Array[winrt.system.Int64], winrt.system.ReadableBuffer], /) -> TensorInt64Bit: ...

@typing.final
class TensorInt64Bit(winrt.system.Object, windows_foundation.ImplementsIMemoryBuffer, windows_foundation.ImplementsIClosable, ImplementsITensor, ImplementsILearningModelFeatureValue, metaclass=TensorInt64Bit_Static):
    def __enter__(self: Self) -> Self: ...
    def __exit__(self, *args) -> None: ...
    def close(self) -> None: ...
    def create_reference(self) -> windows_foundation.IMemoryBufferReference: ...
    def get_as_vector_view(self) -> typing.Sequence[winrt.system.Int64]: ...
    @_property
    def kind(self) -> LearningModelFeatureKind: ...
    @_property
    def shape(self) -> typing.Sequence[winrt.system.Int64]: ...
    @_property
    def tensor_kind(self) -> TensorKind: ...

@typing.final
class TensorInt8Bit_Static(type):
    def create(cls) -> TensorInt8Bit: ...
    def create2(cls, shape: typing.Iterable[winrt.system.Int64], /) -> TensorInt8Bit: ...
    def create_from_array(cls, shape: typing.Iterable[winrt.system.Int64], data: typing.Union[winrt.system.Array[winrt.system.UInt8], winrt.system.ReadableBuffer], /) -> TensorInt8Bit: ...
    def create_from_buffer(cls, shape: typing.Union[winrt.system.Array[winrt.system.Int64], winrt.system.ReadableBuffer], buffer: windows_storage_streams.ImplementsIBuffer, /) -> TensorInt8Bit: ...
    def create_from_iterable(cls, shape: typing.Iterable[winrt.system.Int64], data: typing.Iterable[winrt.system.UInt8], /) -> TensorInt8Bit: ...
    def create_from_shape_array_and_data_array(cls, shape: typing.Union[winrt.system.Array[winrt.system.Int64], winrt.system.ReadableBuffer], data: typing.Union[winrt.system.Array[winrt.system.UInt8], winrt.system.ReadableBuffer], /) -> TensorInt8Bit: ...

@typing.final
class TensorInt8Bit(winrt.system.Object, windows_foundation.ImplementsIMemoryBuffer, windows_foundation.ImplementsIClosable, ImplementsITensor, ImplementsILearningModelFeatureValue, metaclass=TensorInt8Bit_Static):
    def __enter__(self: Self) -> Self: ...
    def __exit__(self, *args) -> None: ...
    def close(self) -> None: ...
    def create_reference(self) -> windows_foundation.IMemoryBufferReference: ...
    def get_as_vector_view(self) -> typing.Sequence[winrt.system.UInt8]: ...
    @_property
    def kind(self) -> LearningModelFeatureKind: ...
    @_property
    def shape(self) -> typing.Sequence[winrt.system.Int64]: ...
    @_property
    def tensor_kind(self) -> TensorKind: ...

@typing.final
class TensorString_Static(type):
    def create(cls) -> TensorString: ...
    def create2(cls, shape: typing.Iterable[winrt.system.Int64], /) -> TensorString: ...
    def create_from_array(cls, shape: typing.Iterable[winrt.system.Int64], data: typing.Union[winrt.system.Array[str], winrt.system.ReadableBuffer], /) -> TensorString: ...
    def create_from_iterable(cls, shape: typing.Iterable[winrt.system.Int64], data: typing.Iterable[str], /) -> TensorString: ...
    def create_from_shape_array_and_data_array(cls, shape: typing.Union[winrt.system.Array[winrt.system.Int64], winrt.system.ReadableBuffer], data: typing.Union[winrt.system.Array[str], winrt.system.ReadableBuffer], /) -> TensorString: ...

@typing.final
class TensorString(winrt.system.Object, windows_foundation.ImplementsIMemoryBuffer, windows_foundation.ImplementsIClosable, ImplementsITensor, ImplementsILearningModelFeatureValue, metaclass=TensorString_Static):
    def __enter__(self: Self) -> Self: ...
    def __exit__(self, *args) -> None: ...
    def close(self) -> None: ...
    def create_reference(self) -> windows_foundation.IMemoryBufferReference: ...
    def get_as_vector_view(self) -> typing.Sequence[str]: ...
    @_property
    def kind(self) -> LearningModelFeatureKind: ...
    @_property
    def shape(self) -> typing.Sequence[winrt.system.Int64]: ...
    @_property
    def tensor_kind(self) -> TensorKind: ...

@typing.final
class TensorUInt16Bit_Static(type):
    def create(cls) -> TensorUInt16Bit: ...
    def create2(cls, shape: typing.Iterable[winrt.system.Int64], /) -> TensorUInt16Bit: ...
    def create_from_array(cls, shape: typing.Iterable[winrt.system.Int64], data: typing.Union[winrt.system.Array[winrt.system.UInt16], winrt.system.ReadableBuffer], /) -> TensorUInt16Bit: ...
    def create_from_buffer(cls, shape: typing.Union[winrt.system.Array[winrt.system.Int64], winrt.system.ReadableBuffer], buffer: windows_storage_streams.ImplementsIBuffer, /) -> TensorUInt16Bit: ...
    def create_from_iterable(cls, shape: typing.Iterable[winrt.system.Int64], data: typing.Iterable[winrt.system.UInt16], /) -> TensorUInt16Bit: ...
    def create_from_shape_array_and_data_array(cls, shape: typing.Union[winrt.system.Array[winrt.system.Int64], winrt.system.ReadableBuffer], data: typing.Union[winrt.system.Array[winrt.system.UInt16], winrt.system.ReadableBuffer], /) -> TensorUInt16Bit: ...

@typing.final
class TensorUInt16Bit(winrt.system.Object, windows_foundation.ImplementsIMemoryBuffer, windows_foundation.ImplementsIClosable, ImplementsITensor, ImplementsILearningModelFeatureValue, metaclass=TensorUInt16Bit_Static):
    def __enter__(self: Self) -> Self: ...
    def __exit__(self, *args) -> None: ...
    def close(self) -> None: ...
    def create_reference(self) -> windows_foundation.IMemoryBufferReference: ...
    def get_as_vector_view(self) -> typing.Sequence[winrt.system.UInt16]: ...
    @_property
    def kind(self) -> LearningModelFeatureKind: ...
    @_property
    def shape(self) -> typing.Sequence[winrt.system.Int64]: ...
    @_property
    def tensor_kind(self) -> TensorKind: ...

@typing.final
class TensorUInt32Bit_Static(type):
    def create(cls) -> TensorUInt32Bit: ...
    def create2(cls, shape: typing.Iterable[winrt.system.Int64], /) -> TensorUInt32Bit: ...
    def create_from_array(cls, shape: typing.Iterable[winrt.system.Int64], data: typing.Union[winrt.system.Array[winrt.system.UInt32], winrt.system.ReadableBuffer], /) -> TensorUInt32Bit: ...
    def create_from_buffer(cls, shape: typing.Union[winrt.system.Array[winrt.system.Int64], winrt.system.ReadableBuffer], buffer: windows_storage_streams.ImplementsIBuffer, /) -> TensorUInt32Bit: ...
    def create_from_iterable(cls, shape: typing.Iterable[winrt.system.Int64], data: typing.Iterable[winrt.system.UInt32], /) -> TensorUInt32Bit: ...
    def create_from_shape_array_and_data_array(cls, shape: typing.Union[winrt.system.Array[winrt.system.Int64], winrt.system.ReadableBuffer], data: typing.Union[winrt.system.Array[winrt.system.UInt32], winrt.system.ReadableBuffer], /) -> TensorUInt32Bit: ...

@typing.final
class TensorUInt32Bit(winrt.system.Object, windows_foundation.ImplementsIMemoryBuffer, windows_foundation.ImplementsIClosable, ImplementsITensor, ImplementsILearningModelFeatureValue, metaclass=TensorUInt32Bit_Static):
    def __enter__(self: Self) -> Self: ...
    def __exit__(self, *args) -> None: ...
    def close(self) -> None: ...
    def create_reference(self) -> windows_foundation.IMemoryBufferReference: ...
    def get_as_vector_view(self) -> typing.Sequence[winrt.system.UInt32]: ...
    @_property
    def kind(self) -> LearningModelFeatureKind: ...
    @_property
    def shape(self) -> typing.Sequence[winrt.system.Int64]: ...
    @_property
    def tensor_kind(self) -> TensorKind: ...

@typing.final
class TensorUInt64Bit_Static(type):
    def create(cls) -> TensorUInt64Bit: ...
    def create2(cls, shape: typing.Iterable[winrt.system.Int64], /) -> TensorUInt64Bit: ...
    def create_from_array(cls, shape: typing.Iterable[winrt.system.Int64], data: typing.Union[winrt.system.Array[winrt.system.UInt64], winrt.system.ReadableBuffer], /) -> TensorUInt64Bit: ...
    def create_from_buffer(cls, shape: typing.Union[winrt.system.Array[winrt.system.Int64], winrt.system.ReadableBuffer], buffer: windows_storage_streams.ImplementsIBuffer, /) -> TensorUInt64Bit: ...
    def create_from_iterable(cls, shape: typing.Iterable[winrt.system.Int64], data: typing.Iterable[winrt.system.UInt64], /) -> TensorUInt64Bit: ...
    def create_from_shape_array_and_data_array(cls, shape: typing.Union[winrt.system.Array[winrt.system.Int64], winrt.system.ReadableBuffer], data: typing.Union[winrt.system.Array[winrt.system.UInt64], winrt.system.ReadableBuffer], /) -> TensorUInt64Bit: ...

@typing.final
class TensorUInt64Bit(winrt.system.Object, windows_foundation.ImplementsIMemoryBuffer, windows_foundation.ImplementsIClosable, ImplementsITensor, ImplementsILearningModelFeatureValue, metaclass=TensorUInt64Bit_Static):
    def __enter__(self: Self) -> Self: ...
    def __exit__(self, *args) -> None: ...
    def close(self) -> None: ...
    def create_reference(self) -> windows_foundation.IMemoryBufferReference: ...
    def get_as_vector_view(self) -> typing.Sequence[winrt.system.UInt64]: ...
    @_property
    def kind(self) -> LearningModelFeatureKind: ...
    @_property
    def shape(self) -> typing.Sequence[winrt.system.Int64]: ...
    @_property
    def tensor_kind(self) -> TensorKind: ...

@typing.final
class TensorUInt8Bit_Static(type):
    def create(cls) -> TensorUInt8Bit: ...
    def create2(cls, shape: typing.Iterable[winrt.system.Int64], /) -> TensorUInt8Bit: ...
    def create_from_array(cls, shape: typing.Iterable[winrt.system.Int64], data: typing.Union[winrt.system.Array[winrt.system.UInt8], winrt.system.ReadableBuffer], /) -> TensorUInt8Bit: ...
    def create_from_buffer(cls, shape: typing.Union[winrt.system.Array[winrt.system.Int64], winrt.system.ReadableBuffer], buffer: windows_storage_streams.ImplementsIBuffer, /) -> TensorUInt8Bit: ...
    def create_from_iterable(cls, shape: typing.Iterable[winrt.system.Int64], data: typing.Iterable[winrt.system.UInt8], /) -> TensorUInt8Bit: ...
    def create_from_shape_array_and_data_array(cls, shape: typing.Union[winrt.system.Array[winrt.system.Int64], winrt.system.ReadableBuffer], data: typing.Union[winrt.system.Array[winrt.system.UInt8], winrt.system.ReadableBuffer], /) -> TensorUInt8Bit: ...

@typing.final
class TensorUInt8Bit(winrt.system.Object, windows_foundation.ImplementsIMemoryBuffer, windows_foundation.ImplementsIClosable, ImplementsITensor, ImplementsILearningModelFeatureValue, metaclass=TensorUInt8Bit_Static):
    def __enter__(self: Self) -> Self: ...
    def __exit__(self, *args) -> None: ...
    def close(self) -> None: ...
    def create_reference(self) -> windows_foundation.IMemoryBufferReference: ...
    def get_as_vector_view(self) -> typing.Sequence[winrt.system.UInt8]: ...
    @_property
    def kind(self) -> LearningModelFeatureKind: ...
    @_property
    def shape(self) -> typing.Sequence[winrt.system.Int64]: ...
    @_property
    def tensor_kind(self) -> TensorKind: ...

class ImplementsILearningModelFeatureDescriptor():
    pass

@typing.final
class ILearningModelFeatureDescriptor(winrt.system.Object, ImplementsILearningModelFeatureDescriptor):
    @_property
    def description(self) -> str: ...
    @_property
    def is_required(self) -> bool: ...
    @_property
    def kind(self) -> LearningModelFeatureKind: ...
    @_property
    def name(self) -> str: ...

class ImplementsILearningModelFeatureValue():
    pass

@typing.final
class ILearningModelFeatureValue(winrt.system.Object, ImplementsILearningModelFeatureValue):
    @_property
    def kind(self) -> LearningModelFeatureKind: ...

class ImplementsILearningModelOperatorProvider():
    pass

@typing.final
class ILearningModelOperatorProvider(winrt.system.Object, ImplementsILearningModelOperatorProvider):
    pass

class ImplementsITensor():
    pass

@typing.final
class ITensor(winrt.system.Object, ImplementsITensor, ImplementsILearningModelFeatureValue):
    @_property
    def shape(self) -> typing.Sequence[winrt.system.Int64]: ...
    @_property
    def tensor_kind(self) -> TensorKind: ...
    @_property
    def kind(self) -> LearningModelFeatureKind: ...

