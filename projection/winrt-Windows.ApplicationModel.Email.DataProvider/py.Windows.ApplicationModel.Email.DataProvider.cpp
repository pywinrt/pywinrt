// WARNING: Please don't edit this file. It was generated by Python/WinRT v0.0.0

#include "py.Windows.ApplicationModel.Email.DataProvider.h"

namespace py::cpp::Windows::ApplicationModel::Email::DataProvider
{
    // ----- EmailDataProviderConnection class --------------------

    static PyObject* _new_EmailDataProviderConnection(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Email::DataProvider::EmailDataProviderConnection>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Email::DataProvider::EmailDataProviderConnection>::type_name);
        return nullptr;
    }

    static void _dealloc_EmailDataProviderConnection(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailDataProviderConnection* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* EmailDataProviderConnection_Start(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailDataProviderConnection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailDataProviderConnection", L"Start", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Start();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailDataProviderConnection_add_CreateFolderRequested(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailDataProviderConnection* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailDataProviderConnection", L"CreateFolderRequested");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::ApplicationModel::Email::DataProvider::EmailDataProviderConnection, winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxCreateFolderRequestEventArgs>>(arg);

            return py::convert(self->obj.CreateFolderRequested(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailDataProviderConnection_remove_CreateFolderRequested(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailDataProviderConnection* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailDataProviderConnection", L"CreateFolderRequested");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.CreateFolderRequested(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailDataProviderConnection_add_DeleteFolderRequested(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailDataProviderConnection* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailDataProviderConnection", L"DeleteFolderRequested");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::ApplicationModel::Email::DataProvider::EmailDataProviderConnection, winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxDeleteFolderRequestEventArgs>>(arg);

            return py::convert(self->obj.DeleteFolderRequested(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailDataProviderConnection_remove_DeleteFolderRequested(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailDataProviderConnection* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailDataProviderConnection", L"DeleteFolderRequested");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.DeleteFolderRequested(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailDataProviderConnection_add_DownloadAttachmentRequested(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailDataProviderConnection* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailDataProviderConnection", L"DownloadAttachmentRequested");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::ApplicationModel::Email::DataProvider::EmailDataProviderConnection, winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxDownloadAttachmentRequestEventArgs>>(arg);

            return py::convert(self->obj.DownloadAttachmentRequested(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailDataProviderConnection_remove_DownloadAttachmentRequested(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailDataProviderConnection* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailDataProviderConnection", L"DownloadAttachmentRequested");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.DownloadAttachmentRequested(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailDataProviderConnection_add_DownloadMessageRequested(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailDataProviderConnection* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailDataProviderConnection", L"DownloadMessageRequested");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::ApplicationModel::Email::DataProvider::EmailDataProviderConnection, winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxDownloadMessageRequestEventArgs>>(arg);

            return py::convert(self->obj.DownloadMessageRequested(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailDataProviderConnection_remove_DownloadMessageRequested(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailDataProviderConnection* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailDataProviderConnection", L"DownloadMessageRequested");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.DownloadMessageRequested(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailDataProviderConnection_add_EmptyFolderRequested(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailDataProviderConnection* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailDataProviderConnection", L"EmptyFolderRequested");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::ApplicationModel::Email::DataProvider::EmailDataProviderConnection, winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxEmptyFolderRequestEventArgs>>(arg);

            return py::convert(self->obj.EmptyFolderRequested(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailDataProviderConnection_remove_EmptyFolderRequested(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailDataProviderConnection* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailDataProviderConnection", L"EmptyFolderRequested");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.EmptyFolderRequested(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailDataProviderConnection_add_ForwardMeetingRequested(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailDataProviderConnection* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailDataProviderConnection", L"ForwardMeetingRequested");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::ApplicationModel::Email::DataProvider::EmailDataProviderConnection, winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxForwardMeetingRequestEventArgs>>(arg);

            return py::convert(self->obj.ForwardMeetingRequested(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailDataProviderConnection_remove_ForwardMeetingRequested(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailDataProviderConnection* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailDataProviderConnection", L"ForwardMeetingRequested");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ForwardMeetingRequested(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailDataProviderConnection_add_GetAutoReplySettingsRequested(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailDataProviderConnection* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailDataProviderConnection", L"GetAutoReplySettingsRequested");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::ApplicationModel::Email::DataProvider::EmailDataProviderConnection, winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxGetAutoReplySettingsRequestEventArgs>>(arg);

            return py::convert(self->obj.GetAutoReplySettingsRequested(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailDataProviderConnection_remove_GetAutoReplySettingsRequested(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailDataProviderConnection* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailDataProviderConnection", L"GetAutoReplySettingsRequested");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.GetAutoReplySettingsRequested(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailDataProviderConnection_add_MailboxSyncRequested(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailDataProviderConnection* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailDataProviderConnection", L"MailboxSyncRequested");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::ApplicationModel::Email::DataProvider::EmailDataProviderConnection, winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxSyncManagerSyncRequestEventArgs>>(arg);

            return py::convert(self->obj.MailboxSyncRequested(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailDataProviderConnection_remove_MailboxSyncRequested(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailDataProviderConnection* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailDataProviderConnection", L"MailboxSyncRequested");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.MailboxSyncRequested(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailDataProviderConnection_add_MoveFolderRequested(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailDataProviderConnection* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailDataProviderConnection", L"MoveFolderRequested");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::ApplicationModel::Email::DataProvider::EmailDataProviderConnection, winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxMoveFolderRequestEventArgs>>(arg);

            return py::convert(self->obj.MoveFolderRequested(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailDataProviderConnection_remove_MoveFolderRequested(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailDataProviderConnection* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailDataProviderConnection", L"MoveFolderRequested");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.MoveFolderRequested(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailDataProviderConnection_add_ProposeNewTimeForMeetingRequested(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailDataProviderConnection* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailDataProviderConnection", L"ProposeNewTimeForMeetingRequested");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::ApplicationModel::Email::DataProvider::EmailDataProviderConnection, winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxProposeNewTimeForMeetingRequestEventArgs>>(arg);

            return py::convert(self->obj.ProposeNewTimeForMeetingRequested(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailDataProviderConnection_remove_ProposeNewTimeForMeetingRequested(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailDataProviderConnection* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailDataProviderConnection", L"ProposeNewTimeForMeetingRequested");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ProposeNewTimeForMeetingRequested(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailDataProviderConnection_add_ResolveRecipientsRequested(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailDataProviderConnection* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailDataProviderConnection", L"ResolveRecipientsRequested");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::ApplicationModel::Email::DataProvider::EmailDataProviderConnection, winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxResolveRecipientsRequestEventArgs>>(arg);

            return py::convert(self->obj.ResolveRecipientsRequested(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailDataProviderConnection_remove_ResolveRecipientsRequested(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailDataProviderConnection* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailDataProviderConnection", L"ResolveRecipientsRequested");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ResolveRecipientsRequested(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailDataProviderConnection_add_ServerSearchReadBatchRequested(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailDataProviderConnection* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailDataProviderConnection", L"ServerSearchReadBatchRequested");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::ApplicationModel::Email::DataProvider::EmailDataProviderConnection, winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxServerSearchReadBatchRequestEventArgs>>(arg);

            return py::convert(self->obj.ServerSearchReadBatchRequested(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailDataProviderConnection_remove_ServerSearchReadBatchRequested(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailDataProviderConnection* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailDataProviderConnection", L"ServerSearchReadBatchRequested");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ServerSearchReadBatchRequested(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailDataProviderConnection_add_SetAutoReplySettingsRequested(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailDataProviderConnection* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailDataProviderConnection", L"SetAutoReplySettingsRequested");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::ApplicationModel::Email::DataProvider::EmailDataProviderConnection, winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxSetAutoReplySettingsRequestEventArgs>>(arg);

            return py::convert(self->obj.SetAutoReplySettingsRequested(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailDataProviderConnection_remove_SetAutoReplySettingsRequested(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailDataProviderConnection* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailDataProviderConnection", L"SetAutoReplySettingsRequested");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.SetAutoReplySettingsRequested(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailDataProviderConnection_add_UpdateMeetingResponseRequested(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailDataProviderConnection* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailDataProviderConnection", L"UpdateMeetingResponseRequested");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::ApplicationModel::Email::DataProvider::EmailDataProviderConnection, winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxUpdateMeetingResponseRequestEventArgs>>(arg);

            return py::convert(self->obj.UpdateMeetingResponseRequested(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailDataProviderConnection_remove_UpdateMeetingResponseRequested(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailDataProviderConnection* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailDataProviderConnection", L"UpdateMeetingResponseRequested");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.UpdateMeetingResponseRequested(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailDataProviderConnection_add_ValidateCertificatesRequested(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailDataProviderConnection* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailDataProviderConnection", L"ValidateCertificatesRequested");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::ApplicationModel::Email::DataProvider::EmailDataProviderConnection, winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxValidateCertificatesRequestEventArgs>>(arg);

            return py::convert(self->obj.ValidateCertificatesRequested(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailDataProviderConnection_remove_ValidateCertificatesRequested(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailDataProviderConnection* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailDataProviderConnection", L"ValidateCertificatesRequested");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ValidateCertificatesRequested(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_EmailDataProviderConnection(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Email::DataProvider::EmailDataProviderConnection>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_EmailDataProviderConnection(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Email::DataProvider::EmailDataProviderConnection>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_EmailDataProviderConnection[] = {
        { "start", reinterpret_cast<PyCFunction>(EmailDataProviderConnection_Start), METH_VARARGS, nullptr },
        { "add_create_folder_requested", reinterpret_cast<PyCFunction>(EmailDataProviderConnection_add_CreateFolderRequested), METH_O, nullptr },
        { "remove_create_folder_requested", reinterpret_cast<PyCFunction>(EmailDataProviderConnection_remove_CreateFolderRequested), METH_O, nullptr },
        { "add_delete_folder_requested", reinterpret_cast<PyCFunction>(EmailDataProviderConnection_add_DeleteFolderRequested), METH_O, nullptr },
        { "remove_delete_folder_requested", reinterpret_cast<PyCFunction>(EmailDataProviderConnection_remove_DeleteFolderRequested), METH_O, nullptr },
        { "add_download_attachment_requested", reinterpret_cast<PyCFunction>(EmailDataProviderConnection_add_DownloadAttachmentRequested), METH_O, nullptr },
        { "remove_download_attachment_requested", reinterpret_cast<PyCFunction>(EmailDataProviderConnection_remove_DownloadAttachmentRequested), METH_O, nullptr },
        { "add_download_message_requested", reinterpret_cast<PyCFunction>(EmailDataProviderConnection_add_DownloadMessageRequested), METH_O, nullptr },
        { "remove_download_message_requested", reinterpret_cast<PyCFunction>(EmailDataProviderConnection_remove_DownloadMessageRequested), METH_O, nullptr },
        { "add_empty_folder_requested", reinterpret_cast<PyCFunction>(EmailDataProviderConnection_add_EmptyFolderRequested), METH_O, nullptr },
        { "remove_empty_folder_requested", reinterpret_cast<PyCFunction>(EmailDataProviderConnection_remove_EmptyFolderRequested), METH_O, nullptr },
        { "add_forward_meeting_requested", reinterpret_cast<PyCFunction>(EmailDataProviderConnection_add_ForwardMeetingRequested), METH_O, nullptr },
        { "remove_forward_meeting_requested", reinterpret_cast<PyCFunction>(EmailDataProviderConnection_remove_ForwardMeetingRequested), METH_O, nullptr },
        { "add_get_auto_reply_settings_requested", reinterpret_cast<PyCFunction>(EmailDataProviderConnection_add_GetAutoReplySettingsRequested), METH_O, nullptr },
        { "remove_get_auto_reply_settings_requested", reinterpret_cast<PyCFunction>(EmailDataProviderConnection_remove_GetAutoReplySettingsRequested), METH_O, nullptr },
        { "add_mailbox_sync_requested", reinterpret_cast<PyCFunction>(EmailDataProviderConnection_add_MailboxSyncRequested), METH_O, nullptr },
        { "remove_mailbox_sync_requested", reinterpret_cast<PyCFunction>(EmailDataProviderConnection_remove_MailboxSyncRequested), METH_O, nullptr },
        { "add_move_folder_requested", reinterpret_cast<PyCFunction>(EmailDataProviderConnection_add_MoveFolderRequested), METH_O, nullptr },
        { "remove_move_folder_requested", reinterpret_cast<PyCFunction>(EmailDataProviderConnection_remove_MoveFolderRequested), METH_O, nullptr },
        { "add_propose_new_time_for_meeting_requested", reinterpret_cast<PyCFunction>(EmailDataProviderConnection_add_ProposeNewTimeForMeetingRequested), METH_O, nullptr },
        { "remove_propose_new_time_for_meeting_requested", reinterpret_cast<PyCFunction>(EmailDataProviderConnection_remove_ProposeNewTimeForMeetingRequested), METH_O, nullptr },
        { "add_resolve_recipients_requested", reinterpret_cast<PyCFunction>(EmailDataProviderConnection_add_ResolveRecipientsRequested), METH_O, nullptr },
        { "remove_resolve_recipients_requested", reinterpret_cast<PyCFunction>(EmailDataProviderConnection_remove_ResolveRecipientsRequested), METH_O, nullptr },
        { "add_server_search_read_batch_requested", reinterpret_cast<PyCFunction>(EmailDataProviderConnection_add_ServerSearchReadBatchRequested), METH_O, nullptr },
        { "remove_server_search_read_batch_requested", reinterpret_cast<PyCFunction>(EmailDataProviderConnection_remove_ServerSearchReadBatchRequested), METH_O, nullptr },
        { "add_set_auto_reply_settings_requested", reinterpret_cast<PyCFunction>(EmailDataProviderConnection_add_SetAutoReplySettingsRequested), METH_O, nullptr },
        { "remove_set_auto_reply_settings_requested", reinterpret_cast<PyCFunction>(EmailDataProviderConnection_remove_SetAutoReplySettingsRequested), METH_O, nullptr },
        { "add_update_meeting_response_requested", reinterpret_cast<PyCFunction>(EmailDataProviderConnection_add_UpdateMeetingResponseRequested), METH_O, nullptr },
        { "remove_update_meeting_response_requested", reinterpret_cast<PyCFunction>(EmailDataProviderConnection_remove_UpdateMeetingResponseRequested), METH_O, nullptr },
        { "add_validate_certificates_requested", reinterpret_cast<PyCFunction>(EmailDataProviderConnection_add_ValidateCertificatesRequested), METH_O, nullptr },
        { "remove_validate_certificates_requested", reinterpret_cast<PyCFunction>(EmailDataProviderConnection_remove_ValidateCertificatesRequested), METH_O, nullptr },
        { "_assign_array_", _assign_array_EmailDataProviderConnection, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_EmailDataProviderConnection), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_EmailDataProviderConnection[] = {
        { }
    };

    static PyType_Slot _type_slots_EmailDataProviderConnection[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_EmailDataProviderConnection) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_EmailDataProviderConnection) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_EmailDataProviderConnection) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_EmailDataProviderConnection) },
        { }
    };

    static PyType_Spec type_spec_EmailDataProviderConnection = {
        "winrt._winrt_windows_applicationmodel_email_dataprovider.EmailDataProviderConnection",
        sizeof(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailDataProviderConnection),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_EmailDataProviderConnection};

    // ----- EmailDataProviderTriggerDetails class --------------------

    static PyObject* _new_EmailDataProviderTriggerDetails(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Email::DataProvider::EmailDataProviderTriggerDetails>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Email::DataProvider::EmailDataProviderTriggerDetails>::type_name);
        return nullptr;
    }

    static void _dealloc_EmailDataProviderTriggerDetails(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailDataProviderTriggerDetails* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* EmailDataProviderTriggerDetails_get_Connection(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailDataProviderTriggerDetails* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailDataProviderTriggerDetails", L"Connection");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Connection());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_EmailDataProviderTriggerDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Email::DataProvider::EmailDataProviderTriggerDetails>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_EmailDataProviderTriggerDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Email::DataProvider::EmailDataProviderTriggerDetails>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_EmailDataProviderTriggerDetails[] = {
        { "_assign_array_", _assign_array_EmailDataProviderTriggerDetails, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_EmailDataProviderTriggerDetails), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_EmailDataProviderTriggerDetails[] = {
        { "connection", reinterpret_cast<getter>(EmailDataProviderTriggerDetails_get_Connection), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_EmailDataProviderTriggerDetails[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_EmailDataProviderTriggerDetails) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_EmailDataProviderTriggerDetails) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_EmailDataProviderTriggerDetails) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_EmailDataProviderTriggerDetails) },
        { }
    };

    static PyType_Spec type_spec_EmailDataProviderTriggerDetails = {
        "winrt._winrt_windows_applicationmodel_email_dataprovider.EmailDataProviderTriggerDetails",
        sizeof(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailDataProviderTriggerDetails),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_EmailDataProviderTriggerDetails};

    // ----- EmailMailboxCreateFolderRequest class --------------------

    static PyObject* _new_EmailMailboxCreateFolderRequest(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxCreateFolderRequest>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxCreateFolderRequest>::type_name);
        return nullptr;
    }

    static void _dealloc_EmailMailboxCreateFolderRequest(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxCreateFolderRequest* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* EmailMailboxCreateFolderRequest_ReportCompletedAsync(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxCreateFolderRequest* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailMailboxCreateFolderRequest", L"ReportCompletedAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Email::EmailFolder>(args, 0);

                return py::convert(self->obj.ReportCompletedAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailMailboxCreateFolderRequest_ReportFailedAsync(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxCreateFolderRequest* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailMailboxCreateFolderRequest", L"ReportFailedAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Email::EmailMailboxCreateFolderStatus>(args, 0);

                return py::convert(self->obj.ReportFailedAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailMailboxCreateFolderRequest_get_EmailMailboxId(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxCreateFolderRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailMailboxCreateFolderRequest", L"EmailMailboxId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.EmailMailboxId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailMailboxCreateFolderRequest_get_Name(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxCreateFolderRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailMailboxCreateFolderRequest", L"Name");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Name());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailMailboxCreateFolderRequest_get_ParentFolderId(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxCreateFolderRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailMailboxCreateFolderRequest", L"ParentFolderId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ParentFolderId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_EmailMailboxCreateFolderRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxCreateFolderRequest>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_EmailMailboxCreateFolderRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxCreateFolderRequest>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_EmailMailboxCreateFolderRequest[] = {
        { "report_completed_async", reinterpret_cast<PyCFunction>(EmailMailboxCreateFolderRequest_ReportCompletedAsync), METH_VARARGS, nullptr },
        { "report_failed_async", reinterpret_cast<PyCFunction>(EmailMailboxCreateFolderRequest_ReportFailedAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_EmailMailboxCreateFolderRequest, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_EmailMailboxCreateFolderRequest), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_EmailMailboxCreateFolderRequest[] = {
        { "email_mailbox_id", reinterpret_cast<getter>(EmailMailboxCreateFolderRequest_get_EmailMailboxId), nullptr, nullptr, nullptr },
        { "name", reinterpret_cast<getter>(EmailMailboxCreateFolderRequest_get_Name), nullptr, nullptr, nullptr },
        { "parent_folder_id", reinterpret_cast<getter>(EmailMailboxCreateFolderRequest_get_ParentFolderId), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_EmailMailboxCreateFolderRequest[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_EmailMailboxCreateFolderRequest) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_EmailMailboxCreateFolderRequest) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_EmailMailboxCreateFolderRequest) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_EmailMailboxCreateFolderRequest) },
        { }
    };

    static PyType_Spec type_spec_EmailMailboxCreateFolderRequest = {
        "winrt._winrt_windows_applicationmodel_email_dataprovider.EmailMailboxCreateFolderRequest",
        sizeof(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxCreateFolderRequest),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_EmailMailboxCreateFolderRequest};

    // ----- EmailMailboxCreateFolderRequestEventArgs class --------------------

    static PyObject* _new_EmailMailboxCreateFolderRequestEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxCreateFolderRequestEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxCreateFolderRequestEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_EmailMailboxCreateFolderRequestEventArgs(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxCreateFolderRequestEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* EmailMailboxCreateFolderRequestEventArgs_GetDeferral(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxCreateFolderRequestEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailMailboxCreateFolderRequestEventArgs", L"GetDeferral", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailMailboxCreateFolderRequestEventArgs_get_Request(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxCreateFolderRequestEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailMailboxCreateFolderRequestEventArgs", L"Request");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Request());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_EmailMailboxCreateFolderRequestEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxCreateFolderRequestEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_EmailMailboxCreateFolderRequestEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxCreateFolderRequestEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_EmailMailboxCreateFolderRequestEventArgs[] = {
        { "get_deferral", reinterpret_cast<PyCFunction>(EmailMailboxCreateFolderRequestEventArgs_GetDeferral), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_EmailMailboxCreateFolderRequestEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_EmailMailboxCreateFolderRequestEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_EmailMailboxCreateFolderRequestEventArgs[] = {
        { "request", reinterpret_cast<getter>(EmailMailboxCreateFolderRequestEventArgs_get_Request), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_EmailMailboxCreateFolderRequestEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_EmailMailboxCreateFolderRequestEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_EmailMailboxCreateFolderRequestEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_EmailMailboxCreateFolderRequestEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_EmailMailboxCreateFolderRequestEventArgs) },
        { }
    };

    static PyType_Spec type_spec_EmailMailboxCreateFolderRequestEventArgs = {
        "winrt._winrt_windows_applicationmodel_email_dataprovider.EmailMailboxCreateFolderRequestEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxCreateFolderRequestEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_EmailMailboxCreateFolderRequestEventArgs};

    // ----- EmailMailboxDeleteFolderRequest class --------------------

    static PyObject* _new_EmailMailboxDeleteFolderRequest(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxDeleteFolderRequest>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxDeleteFolderRequest>::type_name);
        return nullptr;
    }

    static void _dealloc_EmailMailboxDeleteFolderRequest(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxDeleteFolderRequest* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* EmailMailboxDeleteFolderRequest_ReportCompletedAsync(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxDeleteFolderRequest* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailMailboxDeleteFolderRequest", L"ReportCompletedAsync", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.ReportCompletedAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailMailboxDeleteFolderRequest_ReportFailedAsync(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxDeleteFolderRequest* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailMailboxDeleteFolderRequest", L"ReportFailedAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Email::EmailMailboxDeleteFolderStatus>(args, 0);

                return py::convert(self->obj.ReportFailedAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailMailboxDeleteFolderRequest_get_EmailFolderId(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxDeleteFolderRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailMailboxDeleteFolderRequest", L"EmailFolderId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.EmailFolderId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailMailboxDeleteFolderRequest_get_EmailMailboxId(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxDeleteFolderRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailMailboxDeleteFolderRequest", L"EmailMailboxId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.EmailMailboxId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_EmailMailboxDeleteFolderRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxDeleteFolderRequest>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_EmailMailboxDeleteFolderRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxDeleteFolderRequest>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_EmailMailboxDeleteFolderRequest[] = {
        { "report_completed_async", reinterpret_cast<PyCFunction>(EmailMailboxDeleteFolderRequest_ReportCompletedAsync), METH_VARARGS, nullptr },
        { "report_failed_async", reinterpret_cast<PyCFunction>(EmailMailboxDeleteFolderRequest_ReportFailedAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_EmailMailboxDeleteFolderRequest, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_EmailMailboxDeleteFolderRequest), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_EmailMailboxDeleteFolderRequest[] = {
        { "email_folder_id", reinterpret_cast<getter>(EmailMailboxDeleteFolderRequest_get_EmailFolderId), nullptr, nullptr, nullptr },
        { "email_mailbox_id", reinterpret_cast<getter>(EmailMailboxDeleteFolderRequest_get_EmailMailboxId), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_EmailMailboxDeleteFolderRequest[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_EmailMailboxDeleteFolderRequest) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_EmailMailboxDeleteFolderRequest) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_EmailMailboxDeleteFolderRequest) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_EmailMailboxDeleteFolderRequest) },
        { }
    };

    static PyType_Spec type_spec_EmailMailboxDeleteFolderRequest = {
        "winrt._winrt_windows_applicationmodel_email_dataprovider.EmailMailboxDeleteFolderRequest",
        sizeof(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxDeleteFolderRequest),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_EmailMailboxDeleteFolderRequest};

    // ----- EmailMailboxDeleteFolderRequestEventArgs class --------------------

    static PyObject* _new_EmailMailboxDeleteFolderRequestEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxDeleteFolderRequestEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxDeleteFolderRequestEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_EmailMailboxDeleteFolderRequestEventArgs(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxDeleteFolderRequestEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* EmailMailboxDeleteFolderRequestEventArgs_GetDeferral(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxDeleteFolderRequestEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailMailboxDeleteFolderRequestEventArgs", L"GetDeferral", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailMailboxDeleteFolderRequestEventArgs_get_Request(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxDeleteFolderRequestEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailMailboxDeleteFolderRequestEventArgs", L"Request");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Request());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_EmailMailboxDeleteFolderRequestEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxDeleteFolderRequestEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_EmailMailboxDeleteFolderRequestEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxDeleteFolderRequestEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_EmailMailboxDeleteFolderRequestEventArgs[] = {
        { "get_deferral", reinterpret_cast<PyCFunction>(EmailMailboxDeleteFolderRequestEventArgs_GetDeferral), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_EmailMailboxDeleteFolderRequestEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_EmailMailboxDeleteFolderRequestEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_EmailMailboxDeleteFolderRequestEventArgs[] = {
        { "request", reinterpret_cast<getter>(EmailMailboxDeleteFolderRequestEventArgs_get_Request), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_EmailMailboxDeleteFolderRequestEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_EmailMailboxDeleteFolderRequestEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_EmailMailboxDeleteFolderRequestEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_EmailMailboxDeleteFolderRequestEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_EmailMailboxDeleteFolderRequestEventArgs) },
        { }
    };

    static PyType_Spec type_spec_EmailMailboxDeleteFolderRequestEventArgs = {
        "winrt._winrt_windows_applicationmodel_email_dataprovider.EmailMailboxDeleteFolderRequestEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxDeleteFolderRequestEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_EmailMailboxDeleteFolderRequestEventArgs};

    // ----- EmailMailboxDownloadAttachmentRequest class --------------------

    static PyObject* _new_EmailMailboxDownloadAttachmentRequest(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxDownloadAttachmentRequest>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxDownloadAttachmentRequest>::type_name);
        return nullptr;
    }

    static void _dealloc_EmailMailboxDownloadAttachmentRequest(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxDownloadAttachmentRequest* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* EmailMailboxDownloadAttachmentRequest_ReportCompletedAsync(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxDownloadAttachmentRequest* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailMailboxDownloadAttachmentRequest", L"ReportCompletedAsync", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.ReportCompletedAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailMailboxDownloadAttachmentRequest_ReportFailedAsync(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxDownloadAttachmentRequest* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailMailboxDownloadAttachmentRequest", L"ReportFailedAsync", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.ReportFailedAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailMailboxDownloadAttachmentRequest_get_EmailAttachmentId(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxDownloadAttachmentRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailMailboxDownloadAttachmentRequest", L"EmailAttachmentId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.EmailAttachmentId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailMailboxDownloadAttachmentRequest_get_EmailMailboxId(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxDownloadAttachmentRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailMailboxDownloadAttachmentRequest", L"EmailMailboxId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.EmailMailboxId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailMailboxDownloadAttachmentRequest_get_EmailMessageId(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxDownloadAttachmentRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailMailboxDownloadAttachmentRequest", L"EmailMessageId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.EmailMessageId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_EmailMailboxDownloadAttachmentRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxDownloadAttachmentRequest>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_EmailMailboxDownloadAttachmentRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxDownloadAttachmentRequest>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_EmailMailboxDownloadAttachmentRequest[] = {
        { "report_completed_async", reinterpret_cast<PyCFunction>(EmailMailboxDownloadAttachmentRequest_ReportCompletedAsync), METH_VARARGS, nullptr },
        { "report_failed_async", reinterpret_cast<PyCFunction>(EmailMailboxDownloadAttachmentRequest_ReportFailedAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_EmailMailboxDownloadAttachmentRequest, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_EmailMailboxDownloadAttachmentRequest), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_EmailMailboxDownloadAttachmentRequest[] = {
        { "email_attachment_id", reinterpret_cast<getter>(EmailMailboxDownloadAttachmentRequest_get_EmailAttachmentId), nullptr, nullptr, nullptr },
        { "email_mailbox_id", reinterpret_cast<getter>(EmailMailboxDownloadAttachmentRequest_get_EmailMailboxId), nullptr, nullptr, nullptr },
        { "email_message_id", reinterpret_cast<getter>(EmailMailboxDownloadAttachmentRequest_get_EmailMessageId), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_EmailMailboxDownloadAttachmentRequest[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_EmailMailboxDownloadAttachmentRequest) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_EmailMailboxDownloadAttachmentRequest) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_EmailMailboxDownloadAttachmentRequest) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_EmailMailboxDownloadAttachmentRequest) },
        { }
    };

    static PyType_Spec type_spec_EmailMailboxDownloadAttachmentRequest = {
        "winrt._winrt_windows_applicationmodel_email_dataprovider.EmailMailboxDownloadAttachmentRequest",
        sizeof(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxDownloadAttachmentRequest),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_EmailMailboxDownloadAttachmentRequest};

    // ----- EmailMailboxDownloadAttachmentRequestEventArgs class --------------------

    static PyObject* _new_EmailMailboxDownloadAttachmentRequestEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxDownloadAttachmentRequestEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxDownloadAttachmentRequestEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_EmailMailboxDownloadAttachmentRequestEventArgs(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxDownloadAttachmentRequestEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* EmailMailboxDownloadAttachmentRequestEventArgs_GetDeferral(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxDownloadAttachmentRequestEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailMailboxDownloadAttachmentRequestEventArgs", L"GetDeferral", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailMailboxDownloadAttachmentRequestEventArgs_get_Request(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxDownloadAttachmentRequestEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailMailboxDownloadAttachmentRequestEventArgs", L"Request");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Request());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_EmailMailboxDownloadAttachmentRequestEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxDownloadAttachmentRequestEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_EmailMailboxDownloadAttachmentRequestEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxDownloadAttachmentRequestEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_EmailMailboxDownloadAttachmentRequestEventArgs[] = {
        { "get_deferral", reinterpret_cast<PyCFunction>(EmailMailboxDownloadAttachmentRequestEventArgs_GetDeferral), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_EmailMailboxDownloadAttachmentRequestEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_EmailMailboxDownloadAttachmentRequestEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_EmailMailboxDownloadAttachmentRequestEventArgs[] = {
        { "request", reinterpret_cast<getter>(EmailMailboxDownloadAttachmentRequestEventArgs_get_Request), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_EmailMailboxDownloadAttachmentRequestEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_EmailMailboxDownloadAttachmentRequestEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_EmailMailboxDownloadAttachmentRequestEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_EmailMailboxDownloadAttachmentRequestEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_EmailMailboxDownloadAttachmentRequestEventArgs) },
        { }
    };

    static PyType_Spec type_spec_EmailMailboxDownloadAttachmentRequestEventArgs = {
        "winrt._winrt_windows_applicationmodel_email_dataprovider.EmailMailboxDownloadAttachmentRequestEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxDownloadAttachmentRequestEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_EmailMailboxDownloadAttachmentRequestEventArgs};

    // ----- EmailMailboxDownloadMessageRequest class --------------------

    static PyObject* _new_EmailMailboxDownloadMessageRequest(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxDownloadMessageRequest>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxDownloadMessageRequest>::type_name);
        return nullptr;
    }

    static void _dealloc_EmailMailboxDownloadMessageRequest(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxDownloadMessageRequest* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* EmailMailboxDownloadMessageRequest_ReportCompletedAsync(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxDownloadMessageRequest* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailMailboxDownloadMessageRequest", L"ReportCompletedAsync", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.ReportCompletedAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailMailboxDownloadMessageRequest_ReportFailedAsync(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxDownloadMessageRequest* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailMailboxDownloadMessageRequest", L"ReportFailedAsync", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.ReportFailedAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailMailboxDownloadMessageRequest_get_EmailMailboxId(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxDownloadMessageRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailMailboxDownloadMessageRequest", L"EmailMailboxId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.EmailMailboxId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailMailboxDownloadMessageRequest_get_EmailMessageId(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxDownloadMessageRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailMailboxDownloadMessageRequest", L"EmailMessageId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.EmailMessageId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_EmailMailboxDownloadMessageRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxDownloadMessageRequest>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_EmailMailboxDownloadMessageRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxDownloadMessageRequest>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_EmailMailboxDownloadMessageRequest[] = {
        { "report_completed_async", reinterpret_cast<PyCFunction>(EmailMailboxDownloadMessageRequest_ReportCompletedAsync), METH_VARARGS, nullptr },
        { "report_failed_async", reinterpret_cast<PyCFunction>(EmailMailboxDownloadMessageRequest_ReportFailedAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_EmailMailboxDownloadMessageRequest, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_EmailMailboxDownloadMessageRequest), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_EmailMailboxDownloadMessageRequest[] = {
        { "email_mailbox_id", reinterpret_cast<getter>(EmailMailboxDownloadMessageRequest_get_EmailMailboxId), nullptr, nullptr, nullptr },
        { "email_message_id", reinterpret_cast<getter>(EmailMailboxDownloadMessageRequest_get_EmailMessageId), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_EmailMailboxDownloadMessageRequest[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_EmailMailboxDownloadMessageRequest) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_EmailMailboxDownloadMessageRequest) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_EmailMailboxDownloadMessageRequest) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_EmailMailboxDownloadMessageRequest) },
        { }
    };

    static PyType_Spec type_spec_EmailMailboxDownloadMessageRequest = {
        "winrt._winrt_windows_applicationmodel_email_dataprovider.EmailMailboxDownloadMessageRequest",
        sizeof(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxDownloadMessageRequest),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_EmailMailboxDownloadMessageRequest};

    // ----- EmailMailboxDownloadMessageRequestEventArgs class --------------------

    static PyObject* _new_EmailMailboxDownloadMessageRequestEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxDownloadMessageRequestEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxDownloadMessageRequestEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_EmailMailboxDownloadMessageRequestEventArgs(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxDownloadMessageRequestEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* EmailMailboxDownloadMessageRequestEventArgs_GetDeferral(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxDownloadMessageRequestEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailMailboxDownloadMessageRequestEventArgs", L"GetDeferral", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailMailboxDownloadMessageRequestEventArgs_get_Request(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxDownloadMessageRequestEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailMailboxDownloadMessageRequestEventArgs", L"Request");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Request());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_EmailMailboxDownloadMessageRequestEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxDownloadMessageRequestEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_EmailMailboxDownloadMessageRequestEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxDownloadMessageRequestEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_EmailMailboxDownloadMessageRequestEventArgs[] = {
        { "get_deferral", reinterpret_cast<PyCFunction>(EmailMailboxDownloadMessageRequestEventArgs_GetDeferral), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_EmailMailboxDownloadMessageRequestEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_EmailMailboxDownloadMessageRequestEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_EmailMailboxDownloadMessageRequestEventArgs[] = {
        { "request", reinterpret_cast<getter>(EmailMailboxDownloadMessageRequestEventArgs_get_Request), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_EmailMailboxDownloadMessageRequestEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_EmailMailboxDownloadMessageRequestEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_EmailMailboxDownloadMessageRequestEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_EmailMailboxDownloadMessageRequestEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_EmailMailboxDownloadMessageRequestEventArgs) },
        { }
    };

    static PyType_Spec type_spec_EmailMailboxDownloadMessageRequestEventArgs = {
        "winrt._winrt_windows_applicationmodel_email_dataprovider.EmailMailboxDownloadMessageRequestEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxDownloadMessageRequestEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_EmailMailboxDownloadMessageRequestEventArgs};

    // ----- EmailMailboxEmptyFolderRequest class --------------------

    static PyObject* _new_EmailMailboxEmptyFolderRequest(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxEmptyFolderRequest>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxEmptyFolderRequest>::type_name);
        return nullptr;
    }

    static void _dealloc_EmailMailboxEmptyFolderRequest(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxEmptyFolderRequest* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* EmailMailboxEmptyFolderRequest_ReportCompletedAsync(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxEmptyFolderRequest* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailMailboxEmptyFolderRequest", L"ReportCompletedAsync", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.ReportCompletedAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailMailboxEmptyFolderRequest_ReportFailedAsync(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxEmptyFolderRequest* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailMailboxEmptyFolderRequest", L"ReportFailedAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Email::EmailMailboxEmptyFolderStatus>(args, 0);

                return py::convert(self->obj.ReportFailedAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailMailboxEmptyFolderRequest_get_EmailFolderId(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxEmptyFolderRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailMailboxEmptyFolderRequest", L"EmailFolderId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.EmailFolderId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailMailboxEmptyFolderRequest_get_EmailMailboxId(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxEmptyFolderRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailMailboxEmptyFolderRequest", L"EmailMailboxId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.EmailMailboxId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_EmailMailboxEmptyFolderRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxEmptyFolderRequest>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_EmailMailboxEmptyFolderRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxEmptyFolderRequest>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_EmailMailboxEmptyFolderRequest[] = {
        { "report_completed_async", reinterpret_cast<PyCFunction>(EmailMailboxEmptyFolderRequest_ReportCompletedAsync), METH_VARARGS, nullptr },
        { "report_failed_async", reinterpret_cast<PyCFunction>(EmailMailboxEmptyFolderRequest_ReportFailedAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_EmailMailboxEmptyFolderRequest, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_EmailMailboxEmptyFolderRequest), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_EmailMailboxEmptyFolderRequest[] = {
        { "email_folder_id", reinterpret_cast<getter>(EmailMailboxEmptyFolderRequest_get_EmailFolderId), nullptr, nullptr, nullptr },
        { "email_mailbox_id", reinterpret_cast<getter>(EmailMailboxEmptyFolderRequest_get_EmailMailboxId), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_EmailMailboxEmptyFolderRequest[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_EmailMailboxEmptyFolderRequest) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_EmailMailboxEmptyFolderRequest) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_EmailMailboxEmptyFolderRequest) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_EmailMailboxEmptyFolderRequest) },
        { }
    };

    static PyType_Spec type_spec_EmailMailboxEmptyFolderRequest = {
        "winrt._winrt_windows_applicationmodel_email_dataprovider.EmailMailboxEmptyFolderRequest",
        sizeof(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxEmptyFolderRequest),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_EmailMailboxEmptyFolderRequest};

    // ----- EmailMailboxEmptyFolderRequestEventArgs class --------------------

    static PyObject* _new_EmailMailboxEmptyFolderRequestEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxEmptyFolderRequestEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxEmptyFolderRequestEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_EmailMailboxEmptyFolderRequestEventArgs(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxEmptyFolderRequestEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* EmailMailboxEmptyFolderRequestEventArgs_GetDeferral(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxEmptyFolderRequestEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailMailboxEmptyFolderRequestEventArgs", L"GetDeferral", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailMailboxEmptyFolderRequestEventArgs_get_Request(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxEmptyFolderRequestEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailMailboxEmptyFolderRequestEventArgs", L"Request");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Request());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_EmailMailboxEmptyFolderRequestEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxEmptyFolderRequestEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_EmailMailboxEmptyFolderRequestEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxEmptyFolderRequestEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_EmailMailboxEmptyFolderRequestEventArgs[] = {
        { "get_deferral", reinterpret_cast<PyCFunction>(EmailMailboxEmptyFolderRequestEventArgs_GetDeferral), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_EmailMailboxEmptyFolderRequestEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_EmailMailboxEmptyFolderRequestEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_EmailMailboxEmptyFolderRequestEventArgs[] = {
        { "request", reinterpret_cast<getter>(EmailMailboxEmptyFolderRequestEventArgs_get_Request), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_EmailMailboxEmptyFolderRequestEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_EmailMailboxEmptyFolderRequestEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_EmailMailboxEmptyFolderRequestEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_EmailMailboxEmptyFolderRequestEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_EmailMailboxEmptyFolderRequestEventArgs) },
        { }
    };

    static PyType_Spec type_spec_EmailMailboxEmptyFolderRequestEventArgs = {
        "winrt._winrt_windows_applicationmodel_email_dataprovider.EmailMailboxEmptyFolderRequestEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxEmptyFolderRequestEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_EmailMailboxEmptyFolderRequestEventArgs};

    // ----- EmailMailboxForwardMeetingRequest class --------------------

    static PyObject* _new_EmailMailboxForwardMeetingRequest(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxForwardMeetingRequest>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxForwardMeetingRequest>::type_name);
        return nullptr;
    }

    static void _dealloc_EmailMailboxForwardMeetingRequest(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxForwardMeetingRequest* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* EmailMailboxForwardMeetingRequest_ReportCompletedAsync(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxForwardMeetingRequest* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailMailboxForwardMeetingRequest", L"ReportCompletedAsync", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.ReportCompletedAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailMailboxForwardMeetingRequest_ReportFailedAsync(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxForwardMeetingRequest* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailMailboxForwardMeetingRequest", L"ReportFailedAsync", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.ReportFailedAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailMailboxForwardMeetingRequest_get_Comment(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxForwardMeetingRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailMailboxForwardMeetingRequest", L"Comment");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Comment());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailMailboxForwardMeetingRequest_get_EmailMailboxId(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxForwardMeetingRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailMailboxForwardMeetingRequest", L"EmailMailboxId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.EmailMailboxId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailMailboxForwardMeetingRequest_get_EmailMessageId(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxForwardMeetingRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailMailboxForwardMeetingRequest", L"EmailMessageId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.EmailMessageId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailMailboxForwardMeetingRequest_get_ForwardHeader(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxForwardMeetingRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailMailboxForwardMeetingRequest", L"ForwardHeader");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ForwardHeader());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailMailboxForwardMeetingRequest_get_ForwardHeaderType(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxForwardMeetingRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailMailboxForwardMeetingRequest", L"ForwardHeaderType");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ForwardHeaderType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailMailboxForwardMeetingRequest_get_Recipients(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxForwardMeetingRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailMailboxForwardMeetingRequest", L"Recipients");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Recipients());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailMailboxForwardMeetingRequest_get_Subject(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxForwardMeetingRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailMailboxForwardMeetingRequest", L"Subject");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Subject());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_EmailMailboxForwardMeetingRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxForwardMeetingRequest>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_EmailMailboxForwardMeetingRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxForwardMeetingRequest>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_EmailMailboxForwardMeetingRequest[] = {
        { "report_completed_async", reinterpret_cast<PyCFunction>(EmailMailboxForwardMeetingRequest_ReportCompletedAsync), METH_VARARGS, nullptr },
        { "report_failed_async", reinterpret_cast<PyCFunction>(EmailMailboxForwardMeetingRequest_ReportFailedAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_EmailMailboxForwardMeetingRequest, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_EmailMailboxForwardMeetingRequest), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_EmailMailboxForwardMeetingRequest[] = {
        { "comment", reinterpret_cast<getter>(EmailMailboxForwardMeetingRequest_get_Comment), nullptr, nullptr, nullptr },
        { "email_mailbox_id", reinterpret_cast<getter>(EmailMailboxForwardMeetingRequest_get_EmailMailboxId), nullptr, nullptr, nullptr },
        { "email_message_id", reinterpret_cast<getter>(EmailMailboxForwardMeetingRequest_get_EmailMessageId), nullptr, nullptr, nullptr },
        { "forward_header", reinterpret_cast<getter>(EmailMailboxForwardMeetingRequest_get_ForwardHeader), nullptr, nullptr, nullptr },
        { "forward_header_type", reinterpret_cast<getter>(EmailMailboxForwardMeetingRequest_get_ForwardHeaderType), nullptr, nullptr, nullptr },
        { "recipients", reinterpret_cast<getter>(EmailMailboxForwardMeetingRequest_get_Recipients), nullptr, nullptr, nullptr },
        { "subject", reinterpret_cast<getter>(EmailMailboxForwardMeetingRequest_get_Subject), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_EmailMailboxForwardMeetingRequest[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_EmailMailboxForwardMeetingRequest) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_EmailMailboxForwardMeetingRequest) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_EmailMailboxForwardMeetingRequest) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_EmailMailboxForwardMeetingRequest) },
        { }
    };

    static PyType_Spec type_spec_EmailMailboxForwardMeetingRequest = {
        "winrt._winrt_windows_applicationmodel_email_dataprovider.EmailMailboxForwardMeetingRequest",
        sizeof(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxForwardMeetingRequest),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_EmailMailboxForwardMeetingRequest};

    // ----- EmailMailboxForwardMeetingRequestEventArgs class --------------------

    static PyObject* _new_EmailMailboxForwardMeetingRequestEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxForwardMeetingRequestEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxForwardMeetingRequestEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_EmailMailboxForwardMeetingRequestEventArgs(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxForwardMeetingRequestEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* EmailMailboxForwardMeetingRequestEventArgs_GetDeferral(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxForwardMeetingRequestEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailMailboxForwardMeetingRequestEventArgs", L"GetDeferral", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailMailboxForwardMeetingRequestEventArgs_get_Request(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxForwardMeetingRequestEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailMailboxForwardMeetingRequestEventArgs", L"Request");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Request());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_EmailMailboxForwardMeetingRequestEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxForwardMeetingRequestEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_EmailMailboxForwardMeetingRequestEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxForwardMeetingRequestEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_EmailMailboxForwardMeetingRequestEventArgs[] = {
        { "get_deferral", reinterpret_cast<PyCFunction>(EmailMailboxForwardMeetingRequestEventArgs_GetDeferral), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_EmailMailboxForwardMeetingRequestEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_EmailMailboxForwardMeetingRequestEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_EmailMailboxForwardMeetingRequestEventArgs[] = {
        { "request", reinterpret_cast<getter>(EmailMailboxForwardMeetingRequestEventArgs_get_Request), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_EmailMailboxForwardMeetingRequestEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_EmailMailboxForwardMeetingRequestEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_EmailMailboxForwardMeetingRequestEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_EmailMailboxForwardMeetingRequestEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_EmailMailboxForwardMeetingRequestEventArgs) },
        { }
    };

    static PyType_Spec type_spec_EmailMailboxForwardMeetingRequestEventArgs = {
        "winrt._winrt_windows_applicationmodel_email_dataprovider.EmailMailboxForwardMeetingRequestEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxForwardMeetingRequestEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_EmailMailboxForwardMeetingRequestEventArgs};

    // ----- EmailMailboxGetAutoReplySettingsRequest class --------------------

    static PyObject* _new_EmailMailboxGetAutoReplySettingsRequest(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxGetAutoReplySettingsRequest>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxGetAutoReplySettingsRequest>::type_name);
        return nullptr;
    }

    static void _dealloc_EmailMailboxGetAutoReplySettingsRequest(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxGetAutoReplySettingsRequest* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* EmailMailboxGetAutoReplySettingsRequest_ReportCompletedAsync(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxGetAutoReplySettingsRequest* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailMailboxGetAutoReplySettingsRequest", L"ReportCompletedAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Email::EmailMailboxAutoReplySettings>(args, 0);

                return py::convert(self->obj.ReportCompletedAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailMailboxGetAutoReplySettingsRequest_ReportFailedAsync(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxGetAutoReplySettingsRequest* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailMailboxGetAutoReplySettingsRequest", L"ReportFailedAsync", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.ReportFailedAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailMailboxGetAutoReplySettingsRequest_get_EmailMailboxId(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxGetAutoReplySettingsRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailMailboxGetAutoReplySettingsRequest", L"EmailMailboxId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.EmailMailboxId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailMailboxGetAutoReplySettingsRequest_get_RequestedFormat(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxGetAutoReplySettingsRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailMailboxGetAutoReplySettingsRequest", L"RequestedFormat");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.RequestedFormat());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_EmailMailboxGetAutoReplySettingsRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxGetAutoReplySettingsRequest>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_EmailMailboxGetAutoReplySettingsRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxGetAutoReplySettingsRequest>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_EmailMailboxGetAutoReplySettingsRequest[] = {
        { "report_completed_async", reinterpret_cast<PyCFunction>(EmailMailboxGetAutoReplySettingsRequest_ReportCompletedAsync), METH_VARARGS, nullptr },
        { "report_failed_async", reinterpret_cast<PyCFunction>(EmailMailboxGetAutoReplySettingsRequest_ReportFailedAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_EmailMailboxGetAutoReplySettingsRequest, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_EmailMailboxGetAutoReplySettingsRequest), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_EmailMailboxGetAutoReplySettingsRequest[] = {
        { "email_mailbox_id", reinterpret_cast<getter>(EmailMailboxGetAutoReplySettingsRequest_get_EmailMailboxId), nullptr, nullptr, nullptr },
        { "requested_format", reinterpret_cast<getter>(EmailMailboxGetAutoReplySettingsRequest_get_RequestedFormat), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_EmailMailboxGetAutoReplySettingsRequest[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_EmailMailboxGetAutoReplySettingsRequest) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_EmailMailboxGetAutoReplySettingsRequest) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_EmailMailboxGetAutoReplySettingsRequest) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_EmailMailboxGetAutoReplySettingsRequest) },
        { }
    };

    static PyType_Spec type_spec_EmailMailboxGetAutoReplySettingsRequest = {
        "winrt._winrt_windows_applicationmodel_email_dataprovider.EmailMailboxGetAutoReplySettingsRequest",
        sizeof(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxGetAutoReplySettingsRequest),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_EmailMailboxGetAutoReplySettingsRequest};

    // ----- EmailMailboxGetAutoReplySettingsRequestEventArgs class --------------------

    static PyObject* _new_EmailMailboxGetAutoReplySettingsRequestEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxGetAutoReplySettingsRequestEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxGetAutoReplySettingsRequestEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_EmailMailboxGetAutoReplySettingsRequestEventArgs(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxGetAutoReplySettingsRequestEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* EmailMailboxGetAutoReplySettingsRequestEventArgs_GetDeferral(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxGetAutoReplySettingsRequestEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailMailboxGetAutoReplySettingsRequestEventArgs", L"GetDeferral", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailMailboxGetAutoReplySettingsRequestEventArgs_get_Request(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxGetAutoReplySettingsRequestEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailMailboxGetAutoReplySettingsRequestEventArgs", L"Request");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Request());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_EmailMailboxGetAutoReplySettingsRequestEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxGetAutoReplySettingsRequestEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_EmailMailboxGetAutoReplySettingsRequestEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxGetAutoReplySettingsRequestEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_EmailMailboxGetAutoReplySettingsRequestEventArgs[] = {
        { "get_deferral", reinterpret_cast<PyCFunction>(EmailMailboxGetAutoReplySettingsRequestEventArgs_GetDeferral), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_EmailMailboxGetAutoReplySettingsRequestEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_EmailMailboxGetAutoReplySettingsRequestEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_EmailMailboxGetAutoReplySettingsRequestEventArgs[] = {
        { "request", reinterpret_cast<getter>(EmailMailboxGetAutoReplySettingsRequestEventArgs_get_Request), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_EmailMailboxGetAutoReplySettingsRequestEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_EmailMailboxGetAutoReplySettingsRequestEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_EmailMailboxGetAutoReplySettingsRequestEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_EmailMailboxGetAutoReplySettingsRequestEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_EmailMailboxGetAutoReplySettingsRequestEventArgs) },
        { }
    };

    static PyType_Spec type_spec_EmailMailboxGetAutoReplySettingsRequestEventArgs = {
        "winrt._winrt_windows_applicationmodel_email_dataprovider.EmailMailboxGetAutoReplySettingsRequestEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxGetAutoReplySettingsRequestEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_EmailMailboxGetAutoReplySettingsRequestEventArgs};

    // ----- EmailMailboxMoveFolderRequest class --------------------

    static PyObject* _new_EmailMailboxMoveFolderRequest(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxMoveFolderRequest>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxMoveFolderRequest>::type_name);
        return nullptr;
    }

    static void _dealloc_EmailMailboxMoveFolderRequest(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxMoveFolderRequest* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* EmailMailboxMoveFolderRequest_ReportCompletedAsync(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxMoveFolderRequest* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailMailboxMoveFolderRequest", L"ReportCompletedAsync", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.ReportCompletedAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailMailboxMoveFolderRequest_ReportFailedAsync(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxMoveFolderRequest* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailMailboxMoveFolderRequest", L"ReportFailedAsync", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.ReportFailedAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailMailboxMoveFolderRequest_get_EmailFolderId(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxMoveFolderRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailMailboxMoveFolderRequest", L"EmailFolderId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.EmailFolderId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailMailboxMoveFolderRequest_get_EmailMailboxId(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxMoveFolderRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailMailboxMoveFolderRequest", L"EmailMailboxId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.EmailMailboxId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailMailboxMoveFolderRequest_get_NewFolderName(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxMoveFolderRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailMailboxMoveFolderRequest", L"NewFolderName");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.NewFolderName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailMailboxMoveFolderRequest_get_NewParentFolderId(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxMoveFolderRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailMailboxMoveFolderRequest", L"NewParentFolderId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.NewParentFolderId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_EmailMailboxMoveFolderRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxMoveFolderRequest>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_EmailMailboxMoveFolderRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxMoveFolderRequest>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_EmailMailboxMoveFolderRequest[] = {
        { "report_completed_async", reinterpret_cast<PyCFunction>(EmailMailboxMoveFolderRequest_ReportCompletedAsync), METH_VARARGS, nullptr },
        { "report_failed_async", reinterpret_cast<PyCFunction>(EmailMailboxMoveFolderRequest_ReportFailedAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_EmailMailboxMoveFolderRequest, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_EmailMailboxMoveFolderRequest), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_EmailMailboxMoveFolderRequest[] = {
        { "email_folder_id", reinterpret_cast<getter>(EmailMailboxMoveFolderRequest_get_EmailFolderId), nullptr, nullptr, nullptr },
        { "email_mailbox_id", reinterpret_cast<getter>(EmailMailboxMoveFolderRequest_get_EmailMailboxId), nullptr, nullptr, nullptr },
        { "new_folder_name", reinterpret_cast<getter>(EmailMailboxMoveFolderRequest_get_NewFolderName), nullptr, nullptr, nullptr },
        { "new_parent_folder_id", reinterpret_cast<getter>(EmailMailboxMoveFolderRequest_get_NewParentFolderId), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_EmailMailboxMoveFolderRequest[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_EmailMailboxMoveFolderRequest) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_EmailMailboxMoveFolderRequest) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_EmailMailboxMoveFolderRequest) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_EmailMailboxMoveFolderRequest) },
        { }
    };

    static PyType_Spec type_spec_EmailMailboxMoveFolderRequest = {
        "winrt._winrt_windows_applicationmodel_email_dataprovider.EmailMailboxMoveFolderRequest",
        sizeof(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxMoveFolderRequest),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_EmailMailboxMoveFolderRequest};

    // ----- EmailMailboxMoveFolderRequestEventArgs class --------------------

    static PyObject* _new_EmailMailboxMoveFolderRequestEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxMoveFolderRequestEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxMoveFolderRequestEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_EmailMailboxMoveFolderRequestEventArgs(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxMoveFolderRequestEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* EmailMailboxMoveFolderRequestEventArgs_GetDeferral(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxMoveFolderRequestEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailMailboxMoveFolderRequestEventArgs", L"GetDeferral", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailMailboxMoveFolderRequestEventArgs_get_Request(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxMoveFolderRequestEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailMailboxMoveFolderRequestEventArgs", L"Request");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Request());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_EmailMailboxMoveFolderRequestEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxMoveFolderRequestEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_EmailMailboxMoveFolderRequestEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxMoveFolderRequestEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_EmailMailboxMoveFolderRequestEventArgs[] = {
        { "get_deferral", reinterpret_cast<PyCFunction>(EmailMailboxMoveFolderRequestEventArgs_GetDeferral), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_EmailMailboxMoveFolderRequestEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_EmailMailboxMoveFolderRequestEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_EmailMailboxMoveFolderRequestEventArgs[] = {
        { "request", reinterpret_cast<getter>(EmailMailboxMoveFolderRequestEventArgs_get_Request), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_EmailMailboxMoveFolderRequestEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_EmailMailboxMoveFolderRequestEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_EmailMailboxMoveFolderRequestEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_EmailMailboxMoveFolderRequestEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_EmailMailboxMoveFolderRequestEventArgs) },
        { }
    };

    static PyType_Spec type_spec_EmailMailboxMoveFolderRequestEventArgs = {
        "winrt._winrt_windows_applicationmodel_email_dataprovider.EmailMailboxMoveFolderRequestEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxMoveFolderRequestEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_EmailMailboxMoveFolderRequestEventArgs};

    // ----- EmailMailboxProposeNewTimeForMeetingRequest class --------------------

    static PyObject* _new_EmailMailboxProposeNewTimeForMeetingRequest(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxProposeNewTimeForMeetingRequest>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxProposeNewTimeForMeetingRequest>::type_name);
        return nullptr;
    }

    static void _dealloc_EmailMailboxProposeNewTimeForMeetingRequest(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxProposeNewTimeForMeetingRequest* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* EmailMailboxProposeNewTimeForMeetingRequest_ReportCompletedAsync(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxProposeNewTimeForMeetingRequest* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailMailboxProposeNewTimeForMeetingRequest", L"ReportCompletedAsync", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.ReportCompletedAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailMailboxProposeNewTimeForMeetingRequest_ReportFailedAsync(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxProposeNewTimeForMeetingRequest* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailMailboxProposeNewTimeForMeetingRequest", L"ReportFailedAsync", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.ReportFailedAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailMailboxProposeNewTimeForMeetingRequest_get_Comment(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxProposeNewTimeForMeetingRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailMailboxProposeNewTimeForMeetingRequest", L"Comment");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Comment());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailMailboxProposeNewTimeForMeetingRequest_get_EmailMailboxId(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxProposeNewTimeForMeetingRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailMailboxProposeNewTimeForMeetingRequest", L"EmailMailboxId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.EmailMailboxId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailMailboxProposeNewTimeForMeetingRequest_get_EmailMessageId(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxProposeNewTimeForMeetingRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailMailboxProposeNewTimeForMeetingRequest", L"EmailMessageId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.EmailMessageId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailMailboxProposeNewTimeForMeetingRequest_get_NewDuration(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxProposeNewTimeForMeetingRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailMailboxProposeNewTimeForMeetingRequest", L"NewDuration");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.NewDuration());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailMailboxProposeNewTimeForMeetingRequest_get_NewStartTime(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxProposeNewTimeForMeetingRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailMailboxProposeNewTimeForMeetingRequest", L"NewStartTime");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.NewStartTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailMailboxProposeNewTimeForMeetingRequest_get_Subject(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxProposeNewTimeForMeetingRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailMailboxProposeNewTimeForMeetingRequest", L"Subject");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Subject());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_EmailMailboxProposeNewTimeForMeetingRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxProposeNewTimeForMeetingRequest>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_EmailMailboxProposeNewTimeForMeetingRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxProposeNewTimeForMeetingRequest>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_EmailMailboxProposeNewTimeForMeetingRequest[] = {
        { "report_completed_async", reinterpret_cast<PyCFunction>(EmailMailboxProposeNewTimeForMeetingRequest_ReportCompletedAsync), METH_VARARGS, nullptr },
        { "report_failed_async", reinterpret_cast<PyCFunction>(EmailMailboxProposeNewTimeForMeetingRequest_ReportFailedAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_EmailMailboxProposeNewTimeForMeetingRequest, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_EmailMailboxProposeNewTimeForMeetingRequest), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_EmailMailboxProposeNewTimeForMeetingRequest[] = {
        { "comment", reinterpret_cast<getter>(EmailMailboxProposeNewTimeForMeetingRequest_get_Comment), nullptr, nullptr, nullptr },
        { "email_mailbox_id", reinterpret_cast<getter>(EmailMailboxProposeNewTimeForMeetingRequest_get_EmailMailboxId), nullptr, nullptr, nullptr },
        { "email_message_id", reinterpret_cast<getter>(EmailMailboxProposeNewTimeForMeetingRequest_get_EmailMessageId), nullptr, nullptr, nullptr },
        { "new_duration", reinterpret_cast<getter>(EmailMailboxProposeNewTimeForMeetingRequest_get_NewDuration), nullptr, nullptr, nullptr },
        { "new_start_time", reinterpret_cast<getter>(EmailMailboxProposeNewTimeForMeetingRequest_get_NewStartTime), nullptr, nullptr, nullptr },
        { "subject", reinterpret_cast<getter>(EmailMailboxProposeNewTimeForMeetingRequest_get_Subject), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_EmailMailboxProposeNewTimeForMeetingRequest[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_EmailMailboxProposeNewTimeForMeetingRequest) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_EmailMailboxProposeNewTimeForMeetingRequest) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_EmailMailboxProposeNewTimeForMeetingRequest) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_EmailMailboxProposeNewTimeForMeetingRequest) },
        { }
    };

    static PyType_Spec type_spec_EmailMailboxProposeNewTimeForMeetingRequest = {
        "winrt._winrt_windows_applicationmodel_email_dataprovider.EmailMailboxProposeNewTimeForMeetingRequest",
        sizeof(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxProposeNewTimeForMeetingRequest),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_EmailMailboxProposeNewTimeForMeetingRequest};

    // ----- EmailMailboxProposeNewTimeForMeetingRequestEventArgs class --------------------

    static PyObject* _new_EmailMailboxProposeNewTimeForMeetingRequestEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxProposeNewTimeForMeetingRequestEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxProposeNewTimeForMeetingRequestEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_EmailMailboxProposeNewTimeForMeetingRequestEventArgs(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxProposeNewTimeForMeetingRequestEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* EmailMailboxProposeNewTimeForMeetingRequestEventArgs_GetDeferral(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxProposeNewTimeForMeetingRequestEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailMailboxProposeNewTimeForMeetingRequestEventArgs", L"GetDeferral", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailMailboxProposeNewTimeForMeetingRequestEventArgs_get_Request(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxProposeNewTimeForMeetingRequestEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailMailboxProposeNewTimeForMeetingRequestEventArgs", L"Request");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Request());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_EmailMailboxProposeNewTimeForMeetingRequestEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxProposeNewTimeForMeetingRequestEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_EmailMailboxProposeNewTimeForMeetingRequestEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxProposeNewTimeForMeetingRequestEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_EmailMailboxProposeNewTimeForMeetingRequestEventArgs[] = {
        { "get_deferral", reinterpret_cast<PyCFunction>(EmailMailboxProposeNewTimeForMeetingRequestEventArgs_GetDeferral), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_EmailMailboxProposeNewTimeForMeetingRequestEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_EmailMailboxProposeNewTimeForMeetingRequestEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_EmailMailboxProposeNewTimeForMeetingRequestEventArgs[] = {
        { "request", reinterpret_cast<getter>(EmailMailboxProposeNewTimeForMeetingRequestEventArgs_get_Request), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_EmailMailboxProposeNewTimeForMeetingRequestEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_EmailMailboxProposeNewTimeForMeetingRequestEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_EmailMailboxProposeNewTimeForMeetingRequestEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_EmailMailboxProposeNewTimeForMeetingRequestEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_EmailMailboxProposeNewTimeForMeetingRequestEventArgs) },
        { }
    };

    static PyType_Spec type_spec_EmailMailboxProposeNewTimeForMeetingRequestEventArgs = {
        "winrt._winrt_windows_applicationmodel_email_dataprovider.EmailMailboxProposeNewTimeForMeetingRequestEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxProposeNewTimeForMeetingRequestEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_EmailMailboxProposeNewTimeForMeetingRequestEventArgs};

    // ----- EmailMailboxResolveRecipientsRequest class --------------------

    static PyObject* _new_EmailMailboxResolveRecipientsRequest(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxResolveRecipientsRequest>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxResolveRecipientsRequest>::type_name);
        return nullptr;
    }

    static void _dealloc_EmailMailboxResolveRecipientsRequest(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxResolveRecipientsRequest* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* EmailMailboxResolveRecipientsRequest_ReportCompletedAsync(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxResolveRecipientsRequest* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailMailboxResolveRecipientsRequest", L"ReportCompletedAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::ApplicationModel::Email::EmailRecipientResolutionResult>>(args, 0);

                return py::convert(self->obj.ReportCompletedAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailMailboxResolveRecipientsRequest_ReportFailedAsync(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxResolveRecipientsRequest* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailMailboxResolveRecipientsRequest", L"ReportFailedAsync", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.ReportFailedAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailMailboxResolveRecipientsRequest_get_EmailMailboxId(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxResolveRecipientsRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailMailboxResolveRecipientsRequest", L"EmailMailboxId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.EmailMailboxId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailMailboxResolveRecipientsRequest_get_Recipients(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxResolveRecipientsRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailMailboxResolveRecipientsRequest", L"Recipients");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Recipients());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_EmailMailboxResolveRecipientsRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxResolveRecipientsRequest>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_EmailMailboxResolveRecipientsRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxResolveRecipientsRequest>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_EmailMailboxResolveRecipientsRequest[] = {
        { "report_completed_async", reinterpret_cast<PyCFunction>(EmailMailboxResolveRecipientsRequest_ReportCompletedAsync), METH_VARARGS, nullptr },
        { "report_failed_async", reinterpret_cast<PyCFunction>(EmailMailboxResolveRecipientsRequest_ReportFailedAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_EmailMailboxResolveRecipientsRequest, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_EmailMailboxResolveRecipientsRequest), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_EmailMailboxResolveRecipientsRequest[] = {
        { "email_mailbox_id", reinterpret_cast<getter>(EmailMailboxResolveRecipientsRequest_get_EmailMailboxId), nullptr, nullptr, nullptr },
        { "recipients", reinterpret_cast<getter>(EmailMailboxResolveRecipientsRequest_get_Recipients), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_EmailMailboxResolveRecipientsRequest[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_EmailMailboxResolveRecipientsRequest) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_EmailMailboxResolveRecipientsRequest) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_EmailMailboxResolveRecipientsRequest) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_EmailMailboxResolveRecipientsRequest) },
        { }
    };

    static PyType_Spec type_spec_EmailMailboxResolveRecipientsRequest = {
        "winrt._winrt_windows_applicationmodel_email_dataprovider.EmailMailboxResolveRecipientsRequest",
        sizeof(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxResolveRecipientsRequest),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_EmailMailboxResolveRecipientsRequest};

    // ----- EmailMailboxResolveRecipientsRequestEventArgs class --------------------

    static PyObject* _new_EmailMailboxResolveRecipientsRequestEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxResolveRecipientsRequestEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxResolveRecipientsRequestEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_EmailMailboxResolveRecipientsRequestEventArgs(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxResolveRecipientsRequestEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* EmailMailboxResolveRecipientsRequestEventArgs_GetDeferral(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxResolveRecipientsRequestEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailMailboxResolveRecipientsRequestEventArgs", L"GetDeferral", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailMailboxResolveRecipientsRequestEventArgs_get_Request(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxResolveRecipientsRequestEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailMailboxResolveRecipientsRequestEventArgs", L"Request");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Request());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_EmailMailboxResolveRecipientsRequestEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxResolveRecipientsRequestEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_EmailMailboxResolveRecipientsRequestEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxResolveRecipientsRequestEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_EmailMailboxResolveRecipientsRequestEventArgs[] = {
        { "get_deferral", reinterpret_cast<PyCFunction>(EmailMailboxResolveRecipientsRequestEventArgs_GetDeferral), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_EmailMailboxResolveRecipientsRequestEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_EmailMailboxResolveRecipientsRequestEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_EmailMailboxResolveRecipientsRequestEventArgs[] = {
        { "request", reinterpret_cast<getter>(EmailMailboxResolveRecipientsRequestEventArgs_get_Request), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_EmailMailboxResolveRecipientsRequestEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_EmailMailboxResolveRecipientsRequestEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_EmailMailboxResolveRecipientsRequestEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_EmailMailboxResolveRecipientsRequestEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_EmailMailboxResolveRecipientsRequestEventArgs) },
        { }
    };

    static PyType_Spec type_spec_EmailMailboxResolveRecipientsRequestEventArgs = {
        "winrt._winrt_windows_applicationmodel_email_dataprovider.EmailMailboxResolveRecipientsRequestEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxResolveRecipientsRequestEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_EmailMailboxResolveRecipientsRequestEventArgs};

    // ----- EmailMailboxServerSearchReadBatchRequest class --------------------

    static PyObject* _new_EmailMailboxServerSearchReadBatchRequest(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxServerSearchReadBatchRequest>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxServerSearchReadBatchRequest>::type_name);
        return nullptr;
    }

    static void _dealloc_EmailMailboxServerSearchReadBatchRequest(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxServerSearchReadBatchRequest* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* EmailMailboxServerSearchReadBatchRequest_ReportCompletedAsync(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxServerSearchReadBatchRequest* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailMailboxServerSearchReadBatchRequest", L"ReportCompletedAsync", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.ReportCompletedAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailMailboxServerSearchReadBatchRequest_ReportFailedAsync(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxServerSearchReadBatchRequest* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailMailboxServerSearchReadBatchRequest", L"ReportFailedAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Email::EmailBatchStatus>(args, 0);

                return py::convert(self->obj.ReportFailedAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailMailboxServerSearchReadBatchRequest_SaveMessageAsync(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxServerSearchReadBatchRequest* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailMailboxServerSearchReadBatchRequest", L"SaveMessageAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Email::EmailMessage>(args, 0);

                return py::convert(self->obj.SaveMessageAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailMailboxServerSearchReadBatchRequest_get_EmailFolderId(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxServerSearchReadBatchRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailMailboxServerSearchReadBatchRequest", L"EmailFolderId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.EmailFolderId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailMailboxServerSearchReadBatchRequest_get_EmailMailboxId(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxServerSearchReadBatchRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailMailboxServerSearchReadBatchRequest", L"EmailMailboxId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.EmailMailboxId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailMailboxServerSearchReadBatchRequest_get_Options(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxServerSearchReadBatchRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailMailboxServerSearchReadBatchRequest", L"Options");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Options());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailMailboxServerSearchReadBatchRequest_get_SessionId(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxServerSearchReadBatchRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailMailboxServerSearchReadBatchRequest", L"SessionId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SessionId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailMailboxServerSearchReadBatchRequest_get_SuggestedBatchSize(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxServerSearchReadBatchRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailMailboxServerSearchReadBatchRequest", L"SuggestedBatchSize");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SuggestedBatchSize());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_EmailMailboxServerSearchReadBatchRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxServerSearchReadBatchRequest>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_EmailMailboxServerSearchReadBatchRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxServerSearchReadBatchRequest>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_EmailMailboxServerSearchReadBatchRequest[] = {
        { "report_completed_async", reinterpret_cast<PyCFunction>(EmailMailboxServerSearchReadBatchRequest_ReportCompletedAsync), METH_VARARGS, nullptr },
        { "report_failed_async", reinterpret_cast<PyCFunction>(EmailMailboxServerSearchReadBatchRequest_ReportFailedAsync), METH_VARARGS, nullptr },
        { "save_message_async", reinterpret_cast<PyCFunction>(EmailMailboxServerSearchReadBatchRequest_SaveMessageAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_EmailMailboxServerSearchReadBatchRequest, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_EmailMailboxServerSearchReadBatchRequest), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_EmailMailboxServerSearchReadBatchRequest[] = {
        { "email_folder_id", reinterpret_cast<getter>(EmailMailboxServerSearchReadBatchRequest_get_EmailFolderId), nullptr, nullptr, nullptr },
        { "email_mailbox_id", reinterpret_cast<getter>(EmailMailboxServerSearchReadBatchRequest_get_EmailMailboxId), nullptr, nullptr, nullptr },
        { "options", reinterpret_cast<getter>(EmailMailboxServerSearchReadBatchRequest_get_Options), nullptr, nullptr, nullptr },
        { "session_id", reinterpret_cast<getter>(EmailMailboxServerSearchReadBatchRequest_get_SessionId), nullptr, nullptr, nullptr },
        { "suggested_batch_size", reinterpret_cast<getter>(EmailMailboxServerSearchReadBatchRequest_get_SuggestedBatchSize), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_EmailMailboxServerSearchReadBatchRequest[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_EmailMailboxServerSearchReadBatchRequest) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_EmailMailboxServerSearchReadBatchRequest) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_EmailMailboxServerSearchReadBatchRequest) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_EmailMailboxServerSearchReadBatchRequest) },
        { }
    };

    static PyType_Spec type_spec_EmailMailboxServerSearchReadBatchRequest = {
        "winrt._winrt_windows_applicationmodel_email_dataprovider.EmailMailboxServerSearchReadBatchRequest",
        sizeof(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxServerSearchReadBatchRequest),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_EmailMailboxServerSearchReadBatchRequest};

    // ----- EmailMailboxServerSearchReadBatchRequestEventArgs class --------------------

    static PyObject* _new_EmailMailboxServerSearchReadBatchRequestEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxServerSearchReadBatchRequestEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxServerSearchReadBatchRequestEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_EmailMailboxServerSearchReadBatchRequestEventArgs(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxServerSearchReadBatchRequestEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* EmailMailboxServerSearchReadBatchRequestEventArgs_GetDeferral(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxServerSearchReadBatchRequestEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailMailboxServerSearchReadBatchRequestEventArgs", L"GetDeferral", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailMailboxServerSearchReadBatchRequestEventArgs_get_Request(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxServerSearchReadBatchRequestEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailMailboxServerSearchReadBatchRequestEventArgs", L"Request");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Request());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_EmailMailboxServerSearchReadBatchRequestEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxServerSearchReadBatchRequestEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_EmailMailboxServerSearchReadBatchRequestEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxServerSearchReadBatchRequestEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_EmailMailboxServerSearchReadBatchRequestEventArgs[] = {
        { "get_deferral", reinterpret_cast<PyCFunction>(EmailMailboxServerSearchReadBatchRequestEventArgs_GetDeferral), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_EmailMailboxServerSearchReadBatchRequestEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_EmailMailboxServerSearchReadBatchRequestEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_EmailMailboxServerSearchReadBatchRequestEventArgs[] = {
        { "request", reinterpret_cast<getter>(EmailMailboxServerSearchReadBatchRequestEventArgs_get_Request), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_EmailMailboxServerSearchReadBatchRequestEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_EmailMailboxServerSearchReadBatchRequestEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_EmailMailboxServerSearchReadBatchRequestEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_EmailMailboxServerSearchReadBatchRequestEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_EmailMailboxServerSearchReadBatchRequestEventArgs) },
        { }
    };

    static PyType_Spec type_spec_EmailMailboxServerSearchReadBatchRequestEventArgs = {
        "winrt._winrt_windows_applicationmodel_email_dataprovider.EmailMailboxServerSearchReadBatchRequestEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxServerSearchReadBatchRequestEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_EmailMailboxServerSearchReadBatchRequestEventArgs};

    // ----- EmailMailboxSetAutoReplySettingsRequest class --------------------

    static PyObject* _new_EmailMailboxSetAutoReplySettingsRequest(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxSetAutoReplySettingsRequest>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxSetAutoReplySettingsRequest>::type_name);
        return nullptr;
    }

    static void _dealloc_EmailMailboxSetAutoReplySettingsRequest(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxSetAutoReplySettingsRequest* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* EmailMailboxSetAutoReplySettingsRequest_ReportCompletedAsync(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxSetAutoReplySettingsRequest* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailMailboxSetAutoReplySettingsRequest", L"ReportCompletedAsync", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.ReportCompletedAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailMailboxSetAutoReplySettingsRequest_ReportFailedAsync(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxSetAutoReplySettingsRequest* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailMailboxSetAutoReplySettingsRequest", L"ReportFailedAsync", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.ReportFailedAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailMailboxSetAutoReplySettingsRequest_get_AutoReplySettings(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxSetAutoReplySettingsRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailMailboxSetAutoReplySettingsRequest", L"AutoReplySettings");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.AutoReplySettings());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailMailboxSetAutoReplySettingsRequest_get_EmailMailboxId(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxSetAutoReplySettingsRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailMailboxSetAutoReplySettingsRequest", L"EmailMailboxId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.EmailMailboxId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_EmailMailboxSetAutoReplySettingsRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxSetAutoReplySettingsRequest>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_EmailMailboxSetAutoReplySettingsRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxSetAutoReplySettingsRequest>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_EmailMailboxSetAutoReplySettingsRequest[] = {
        { "report_completed_async", reinterpret_cast<PyCFunction>(EmailMailboxSetAutoReplySettingsRequest_ReportCompletedAsync), METH_VARARGS, nullptr },
        { "report_failed_async", reinterpret_cast<PyCFunction>(EmailMailboxSetAutoReplySettingsRequest_ReportFailedAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_EmailMailboxSetAutoReplySettingsRequest, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_EmailMailboxSetAutoReplySettingsRequest), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_EmailMailboxSetAutoReplySettingsRequest[] = {
        { "auto_reply_settings", reinterpret_cast<getter>(EmailMailboxSetAutoReplySettingsRequest_get_AutoReplySettings), nullptr, nullptr, nullptr },
        { "email_mailbox_id", reinterpret_cast<getter>(EmailMailboxSetAutoReplySettingsRequest_get_EmailMailboxId), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_EmailMailboxSetAutoReplySettingsRequest[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_EmailMailboxSetAutoReplySettingsRequest) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_EmailMailboxSetAutoReplySettingsRequest) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_EmailMailboxSetAutoReplySettingsRequest) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_EmailMailboxSetAutoReplySettingsRequest) },
        { }
    };

    static PyType_Spec type_spec_EmailMailboxSetAutoReplySettingsRequest = {
        "winrt._winrt_windows_applicationmodel_email_dataprovider.EmailMailboxSetAutoReplySettingsRequest",
        sizeof(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxSetAutoReplySettingsRequest),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_EmailMailboxSetAutoReplySettingsRequest};

    // ----- EmailMailboxSetAutoReplySettingsRequestEventArgs class --------------------

    static PyObject* _new_EmailMailboxSetAutoReplySettingsRequestEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxSetAutoReplySettingsRequestEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxSetAutoReplySettingsRequestEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_EmailMailboxSetAutoReplySettingsRequestEventArgs(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxSetAutoReplySettingsRequestEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* EmailMailboxSetAutoReplySettingsRequestEventArgs_GetDeferral(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxSetAutoReplySettingsRequestEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailMailboxSetAutoReplySettingsRequestEventArgs", L"GetDeferral", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailMailboxSetAutoReplySettingsRequestEventArgs_get_Request(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxSetAutoReplySettingsRequestEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailMailboxSetAutoReplySettingsRequestEventArgs", L"Request");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Request());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_EmailMailboxSetAutoReplySettingsRequestEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxSetAutoReplySettingsRequestEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_EmailMailboxSetAutoReplySettingsRequestEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxSetAutoReplySettingsRequestEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_EmailMailboxSetAutoReplySettingsRequestEventArgs[] = {
        { "get_deferral", reinterpret_cast<PyCFunction>(EmailMailboxSetAutoReplySettingsRequestEventArgs_GetDeferral), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_EmailMailboxSetAutoReplySettingsRequestEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_EmailMailboxSetAutoReplySettingsRequestEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_EmailMailboxSetAutoReplySettingsRequestEventArgs[] = {
        { "request", reinterpret_cast<getter>(EmailMailboxSetAutoReplySettingsRequestEventArgs_get_Request), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_EmailMailboxSetAutoReplySettingsRequestEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_EmailMailboxSetAutoReplySettingsRequestEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_EmailMailboxSetAutoReplySettingsRequestEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_EmailMailboxSetAutoReplySettingsRequestEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_EmailMailboxSetAutoReplySettingsRequestEventArgs) },
        { }
    };

    static PyType_Spec type_spec_EmailMailboxSetAutoReplySettingsRequestEventArgs = {
        "winrt._winrt_windows_applicationmodel_email_dataprovider.EmailMailboxSetAutoReplySettingsRequestEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxSetAutoReplySettingsRequestEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_EmailMailboxSetAutoReplySettingsRequestEventArgs};

    // ----- EmailMailboxSyncManagerSyncRequest class --------------------

    static PyObject* _new_EmailMailboxSyncManagerSyncRequest(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxSyncManagerSyncRequest>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxSyncManagerSyncRequest>::type_name);
        return nullptr;
    }

    static void _dealloc_EmailMailboxSyncManagerSyncRequest(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxSyncManagerSyncRequest* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* EmailMailboxSyncManagerSyncRequest_ReportCompletedAsync(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxSyncManagerSyncRequest* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailMailboxSyncManagerSyncRequest", L"ReportCompletedAsync", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.ReportCompletedAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailMailboxSyncManagerSyncRequest_ReportFailedAsync(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxSyncManagerSyncRequest* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailMailboxSyncManagerSyncRequest", L"ReportFailedAsync", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.ReportFailedAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailMailboxSyncManagerSyncRequest_get_EmailMailboxId(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxSyncManagerSyncRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailMailboxSyncManagerSyncRequest", L"EmailMailboxId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.EmailMailboxId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_EmailMailboxSyncManagerSyncRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxSyncManagerSyncRequest>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_EmailMailboxSyncManagerSyncRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxSyncManagerSyncRequest>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_EmailMailboxSyncManagerSyncRequest[] = {
        { "report_completed_async", reinterpret_cast<PyCFunction>(EmailMailboxSyncManagerSyncRequest_ReportCompletedAsync), METH_VARARGS, nullptr },
        { "report_failed_async", reinterpret_cast<PyCFunction>(EmailMailboxSyncManagerSyncRequest_ReportFailedAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_EmailMailboxSyncManagerSyncRequest, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_EmailMailboxSyncManagerSyncRequest), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_EmailMailboxSyncManagerSyncRequest[] = {
        { "email_mailbox_id", reinterpret_cast<getter>(EmailMailboxSyncManagerSyncRequest_get_EmailMailboxId), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_EmailMailboxSyncManagerSyncRequest[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_EmailMailboxSyncManagerSyncRequest) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_EmailMailboxSyncManagerSyncRequest) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_EmailMailboxSyncManagerSyncRequest) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_EmailMailboxSyncManagerSyncRequest) },
        { }
    };

    static PyType_Spec type_spec_EmailMailboxSyncManagerSyncRequest = {
        "winrt._winrt_windows_applicationmodel_email_dataprovider.EmailMailboxSyncManagerSyncRequest",
        sizeof(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxSyncManagerSyncRequest),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_EmailMailboxSyncManagerSyncRequest};

    // ----- EmailMailboxSyncManagerSyncRequestEventArgs class --------------------

    static PyObject* _new_EmailMailboxSyncManagerSyncRequestEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxSyncManagerSyncRequestEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxSyncManagerSyncRequestEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_EmailMailboxSyncManagerSyncRequestEventArgs(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxSyncManagerSyncRequestEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* EmailMailboxSyncManagerSyncRequestEventArgs_GetDeferral(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxSyncManagerSyncRequestEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailMailboxSyncManagerSyncRequestEventArgs", L"GetDeferral", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailMailboxSyncManagerSyncRequestEventArgs_get_Request(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxSyncManagerSyncRequestEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailMailboxSyncManagerSyncRequestEventArgs", L"Request");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Request());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_EmailMailboxSyncManagerSyncRequestEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxSyncManagerSyncRequestEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_EmailMailboxSyncManagerSyncRequestEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxSyncManagerSyncRequestEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_EmailMailboxSyncManagerSyncRequestEventArgs[] = {
        { "get_deferral", reinterpret_cast<PyCFunction>(EmailMailboxSyncManagerSyncRequestEventArgs_GetDeferral), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_EmailMailboxSyncManagerSyncRequestEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_EmailMailboxSyncManagerSyncRequestEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_EmailMailboxSyncManagerSyncRequestEventArgs[] = {
        { "request", reinterpret_cast<getter>(EmailMailboxSyncManagerSyncRequestEventArgs_get_Request), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_EmailMailboxSyncManagerSyncRequestEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_EmailMailboxSyncManagerSyncRequestEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_EmailMailboxSyncManagerSyncRequestEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_EmailMailboxSyncManagerSyncRequestEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_EmailMailboxSyncManagerSyncRequestEventArgs) },
        { }
    };

    static PyType_Spec type_spec_EmailMailboxSyncManagerSyncRequestEventArgs = {
        "winrt._winrt_windows_applicationmodel_email_dataprovider.EmailMailboxSyncManagerSyncRequestEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxSyncManagerSyncRequestEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_EmailMailboxSyncManagerSyncRequestEventArgs};

    // ----- EmailMailboxUpdateMeetingResponseRequest class --------------------

    static PyObject* _new_EmailMailboxUpdateMeetingResponseRequest(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxUpdateMeetingResponseRequest>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxUpdateMeetingResponseRequest>::type_name);
        return nullptr;
    }

    static void _dealloc_EmailMailboxUpdateMeetingResponseRequest(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxUpdateMeetingResponseRequest* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* EmailMailboxUpdateMeetingResponseRequest_ReportCompletedAsync(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxUpdateMeetingResponseRequest* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailMailboxUpdateMeetingResponseRequest", L"ReportCompletedAsync", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.ReportCompletedAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailMailboxUpdateMeetingResponseRequest_ReportFailedAsync(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxUpdateMeetingResponseRequest* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailMailboxUpdateMeetingResponseRequest", L"ReportFailedAsync", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.ReportFailedAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailMailboxUpdateMeetingResponseRequest_get_Comment(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxUpdateMeetingResponseRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailMailboxUpdateMeetingResponseRequest", L"Comment");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Comment());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailMailboxUpdateMeetingResponseRequest_get_EmailMailboxId(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxUpdateMeetingResponseRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailMailboxUpdateMeetingResponseRequest", L"EmailMailboxId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.EmailMailboxId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailMailboxUpdateMeetingResponseRequest_get_EmailMessageId(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxUpdateMeetingResponseRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailMailboxUpdateMeetingResponseRequest", L"EmailMessageId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.EmailMessageId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailMailboxUpdateMeetingResponseRequest_get_Response(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxUpdateMeetingResponseRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailMailboxUpdateMeetingResponseRequest", L"Response");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Response());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailMailboxUpdateMeetingResponseRequest_get_SendUpdate(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxUpdateMeetingResponseRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailMailboxUpdateMeetingResponseRequest", L"SendUpdate");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SendUpdate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailMailboxUpdateMeetingResponseRequest_get_Subject(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxUpdateMeetingResponseRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailMailboxUpdateMeetingResponseRequest", L"Subject");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Subject());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_EmailMailboxUpdateMeetingResponseRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxUpdateMeetingResponseRequest>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_EmailMailboxUpdateMeetingResponseRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxUpdateMeetingResponseRequest>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_EmailMailboxUpdateMeetingResponseRequest[] = {
        { "report_completed_async", reinterpret_cast<PyCFunction>(EmailMailboxUpdateMeetingResponseRequest_ReportCompletedAsync), METH_VARARGS, nullptr },
        { "report_failed_async", reinterpret_cast<PyCFunction>(EmailMailboxUpdateMeetingResponseRequest_ReportFailedAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_EmailMailboxUpdateMeetingResponseRequest, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_EmailMailboxUpdateMeetingResponseRequest), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_EmailMailboxUpdateMeetingResponseRequest[] = {
        { "comment", reinterpret_cast<getter>(EmailMailboxUpdateMeetingResponseRequest_get_Comment), nullptr, nullptr, nullptr },
        { "email_mailbox_id", reinterpret_cast<getter>(EmailMailboxUpdateMeetingResponseRequest_get_EmailMailboxId), nullptr, nullptr, nullptr },
        { "email_message_id", reinterpret_cast<getter>(EmailMailboxUpdateMeetingResponseRequest_get_EmailMessageId), nullptr, nullptr, nullptr },
        { "response", reinterpret_cast<getter>(EmailMailboxUpdateMeetingResponseRequest_get_Response), nullptr, nullptr, nullptr },
        { "send_update", reinterpret_cast<getter>(EmailMailboxUpdateMeetingResponseRequest_get_SendUpdate), nullptr, nullptr, nullptr },
        { "subject", reinterpret_cast<getter>(EmailMailboxUpdateMeetingResponseRequest_get_Subject), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_EmailMailboxUpdateMeetingResponseRequest[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_EmailMailboxUpdateMeetingResponseRequest) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_EmailMailboxUpdateMeetingResponseRequest) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_EmailMailboxUpdateMeetingResponseRequest) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_EmailMailboxUpdateMeetingResponseRequest) },
        { }
    };

    static PyType_Spec type_spec_EmailMailboxUpdateMeetingResponseRequest = {
        "winrt._winrt_windows_applicationmodel_email_dataprovider.EmailMailboxUpdateMeetingResponseRequest",
        sizeof(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxUpdateMeetingResponseRequest),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_EmailMailboxUpdateMeetingResponseRequest};

    // ----- EmailMailboxUpdateMeetingResponseRequestEventArgs class --------------------

    static PyObject* _new_EmailMailboxUpdateMeetingResponseRequestEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxUpdateMeetingResponseRequestEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxUpdateMeetingResponseRequestEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_EmailMailboxUpdateMeetingResponseRequestEventArgs(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxUpdateMeetingResponseRequestEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* EmailMailboxUpdateMeetingResponseRequestEventArgs_GetDeferral(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxUpdateMeetingResponseRequestEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailMailboxUpdateMeetingResponseRequestEventArgs", L"GetDeferral", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailMailboxUpdateMeetingResponseRequestEventArgs_get_Request(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxUpdateMeetingResponseRequestEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailMailboxUpdateMeetingResponseRequestEventArgs", L"Request");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Request());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_EmailMailboxUpdateMeetingResponseRequestEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxUpdateMeetingResponseRequestEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_EmailMailboxUpdateMeetingResponseRequestEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxUpdateMeetingResponseRequestEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_EmailMailboxUpdateMeetingResponseRequestEventArgs[] = {
        { "get_deferral", reinterpret_cast<PyCFunction>(EmailMailboxUpdateMeetingResponseRequestEventArgs_GetDeferral), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_EmailMailboxUpdateMeetingResponseRequestEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_EmailMailboxUpdateMeetingResponseRequestEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_EmailMailboxUpdateMeetingResponseRequestEventArgs[] = {
        { "request", reinterpret_cast<getter>(EmailMailboxUpdateMeetingResponseRequestEventArgs_get_Request), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_EmailMailboxUpdateMeetingResponseRequestEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_EmailMailboxUpdateMeetingResponseRequestEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_EmailMailboxUpdateMeetingResponseRequestEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_EmailMailboxUpdateMeetingResponseRequestEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_EmailMailboxUpdateMeetingResponseRequestEventArgs) },
        { }
    };

    static PyType_Spec type_spec_EmailMailboxUpdateMeetingResponseRequestEventArgs = {
        "winrt._winrt_windows_applicationmodel_email_dataprovider.EmailMailboxUpdateMeetingResponseRequestEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxUpdateMeetingResponseRequestEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_EmailMailboxUpdateMeetingResponseRequestEventArgs};

    // ----- EmailMailboxValidateCertificatesRequest class --------------------

    static PyObject* _new_EmailMailboxValidateCertificatesRequest(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxValidateCertificatesRequest>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxValidateCertificatesRequest>::type_name);
        return nullptr;
    }

    static void _dealloc_EmailMailboxValidateCertificatesRequest(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxValidateCertificatesRequest* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* EmailMailboxValidateCertificatesRequest_ReportCompletedAsync(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxValidateCertificatesRequest* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailMailboxValidateCertificatesRequest", L"ReportCompletedAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::ApplicationModel::Email::EmailCertificateValidationStatus>>(args, 0);

                return py::convert(self->obj.ReportCompletedAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailMailboxValidateCertificatesRequest_ReportFailedAsync(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxValidateCertificatesRequest* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailMailboxValidateCertificatesRequest", L"ReportFailedAsync", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.ReportFailedAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailMailboxValidateCertificatesRequest_get_Certificates(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxValidateCertificatesRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailMailboxValidateCertificatesRequest", L"Certificates");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Certificates());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailMailboxValidateCertificatesRequest_get_EmailMailboxId(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxValidateCertificatesRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailMailboxValidateCertificatesRequest", L"EmailMailboxId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.EmailMailboxId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_EmailMailboxValidateCertificatesRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxValidateCertificatesRequest>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_EmailMailboxValidateCertificatesRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxValidateCertificatesRequest>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_EmailMailboxValidateCertificatesRequest[] = {
        { "report_completed_async", reinterpret_cast<PyCFunction>(EmailMailboxValidateCertificatesRequest_ReportCompletedAsync), METH_VARARGS, nullptr },
        { "report_failed_async", reinterpret_cast<PyCFunction>(EmailMailboxValidateCertificatesRequest_ReportFailedAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_EmailMailboxValidateCertificatesRequest, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_EmailMailboxValidateCertificatesRequest), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_EmailMailboxValidateCertificatesRequest[] = {
        { "certificates", reinterpret_cast<getter>(EmailMailboxValidateCertificatesRequest_get_Certificates), nullptr, nullptr, nullptr },
        { "email_mailbox_id", reinterpret_cast<getter>(EmailMailboxValidateCertificatesRequest_get_EmailMailboxId), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_EmailMailboxValidateCertificatesRequest[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_EmailMailboxValidateCertificatesRequest) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_EmailMailboxValidateCertificatesRequest) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_EmailMailboxValidateCertificatesRequest) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_EmailMailboxValidateCertificatesRequest) },
        { }
    };

    static PyType_Spec type_spec_EmailMailboxValidateCertificatesRequest = {
        "winrt._winrt_windows_applicationmodel_email_dataprovider.EmailMailboxValidateCertificatesRequest",
        sizeof(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxValidateCertificatesRequest),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_EmailMailboxValidateCertificatesRequest};

    // ----- EmailMailboxValidateCertificatesRequestEventArgs class --------------------

    static PyObject* _new_EmailMailboxValidateCertificatesRequestEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxValidateCertificatesRequestEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxValidateCertificatesRequestEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_EmailMailboxValidateCertificatesRequestEventArgs(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxValidateCertificatesRequestEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* EmailMailboxValidateCertificatesRequestEventArgs_GetDeferral(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxValidateCertificatesRequestEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailMailboxValidateCertificatesRequestEventArgs", L"GetDeferral", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailMailboxValidateCertificatesRequestEventArgs_get_Request(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxValidateCertificatesRequestEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.DataProvider.EmailMailboxValidateCertificatesRequestEventArgs", L"Request");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Request());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_EmailMailboxValidateCertificatesRequestEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxValidateCertificatesRequestEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_EmailMailboxValidateCertificatesRequestEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Email::DataProvider::EmailMailboxValidateCertificatesRequestEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_EmailMailboxValidateCertificatesRequestEventArgs[] = {
        { "get_deferral", reinterpret_cast<PyCFunction>(EmailMailboxValidateCertificatesRequestEventArgs_GetDeferral), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_EmailMailboxValidateCertificatesRequestEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_EmailMailboxValidateCertificatesRequestEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_EmailMailboxValidateCertificatesRequestEventArgs[] = {
        { "request", reinterpret_cast<getter>(EmailMailboxValidateCertificatesRequestEventArgs_get_Request), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_EmailMailboxValidateCertificatesRequestEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_EmailMailboxValidateCertificatesRequestEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_EmailMailboxValidateCertificatesRequestEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_EmailMailboxValidateCertificatesRequestEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_EmailMailboxValidateCertificatesRequestEventArgs) },
        { }
    };

    static PyType_Spec type_spec_EmailMailboxValidateCertificatesRequestEventArgs = {
        "winrt._winrt_windows_applicationmodel_email_dataprovider.EmailMailboxValidateCertificatesRequestEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Email::DataProvider::EmailMailboxValidateCertificatesRequestEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_EmailMailboxValidateCertificatesRequestEventArgs};

    // ----- Windows.ApplicationModel.Email.DataProvider Initialization --------------------

    PyDoc_STRVAR(module_doc, "Windows.ApplicationModel.Email.DataProvider");

    static PyModuleDef module_def = {
        PyModuleDef_HEAD_INIT,
        "_winrt_windows_applicationmodel_email_dataprovider",
        module_doc,
        0,
        nullptr,
        nullptr,
        nullptr,
        nullptr,
        nullptr};
} // py::cpp::Windows::ApplicationModel::Email::DataProvider

PyMODINIT_FUNC PyInit__winrt_windows_applicationmodel_email_dataprovider(void) noexcept
{
    using namespace py::cpp::Windows::ApplicationModel::Email::DataProvider;

    if (py::import_winrt_runtime() == -1)
    {
        return nullptr;
    }

    py::pyobj_handle module{PyModule_Create(&module_def)};

    if (!module)
    {
        return nullptr;
    }

    auto object_type = py::get_object_type();
    if (!object_type)
    {
        return nullptr;
    }

    py::pyobj_handle object_bases{PyTuple_Pack(1, object_type)};

    if (!object_bases)
    {
        return nullptr;
    }

    py::pytype_handle EmailDataProviderConnection_type{py::register_python_type(module.get(), &type_spec_EmailDataProviderConnection, object_bases.get(), nullptr)};
    if (!EmailDataProviderConnection_type)
    {
        return nullptr;
    }

    py::pytype_handle EmailDataProviderTriggerDetails_type{py::register_python_type(module.get(), &type_spec_EmailDataProviderTriggerDetails, object_bases.get(), nullptr)};
    if (!EmailDataProviderTriggerDetails_type)
    {
        return nullptr;
    }

    py::pytype_handle EmailMailboxCreateFolderRequest_type{py::register_python_type(module.get(), &type_spec_EmailMailboxCreateFolderRequest, object_bases.get(), nullptr)};
    if (!EmailMailboxCreateFolderRequest_type)
    {
        return nullptr;
    }

    py::pytype_handle EmailMailboxCreateFolderRequestEventArgs_type{py::register_python_type(module.get(), &type_spec_EmailMailboxCreateFolderRequestEventArgs, object_bases.get(), nullptr)};
    if (!EmailMailboxCreateFolderRequestEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle EmailMailboxDeleteFolderRequest_type{py::register_python_type(module.get(), &type_spec_EmailMailboxDeleteFolderRequest, object_bases.get(), nullptr)};
    if (!EmailMailboxDeleteFolderRequest_type)
    {
        return nullptr;
    }

    py::pytype_handle EmailMailboxDeleteFolderRequestEventArgs_type{py::register_python_type(module.get(), &type_spec_EmailMailboxDeleteFolderRequestEventArgs, object_bases.get(), nullptr)};
    if (!EmailMailboxDeleteFolderRequestEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle EmailMailboxDownloadAttachmentRequest_type{py::register_python_type(module.get(), &type_spec_EmailMailboxDownloadAttachmentRequest, object_bases.get(), nullptr)};
    if (!EmailMailboxDownloadAttachmentRequest_type)
    {
        return nullptr;
    }

    py::pytype_handle EmailMailboxDownloadAttachmentRequestEventArgs_type{py::register_python_type(module.get(), &type_spec_EmailMailboxDownloadAttachmentRequestEventArgs, object_bases.get(), nullptr)};
    if (!EmailMailboxDownloadAttachmentRequestEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle EmailMailboxDownloadMessageRequest_type{py::register_python_type(module.get(), &type_spec_EmailMailboxDownloadMessageRequest, object_bases.get(), nullptr)};
    if (!EmailMailboxDownloadMessageRequest_type)
    {
        return nullptr;
    }

    py::pytype_handle EmailMailboxDownloadMessageRequestEventArgs_type{py::register_python_type(module.get(), &type_spec_EmailMailboxDownloadMessageRequestEventArgs, object_bases.get(), nullptr)};
    if (!EmailMailboxDownloadMessageRequestEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle EmailMailboxEmptyFolderRequest_type{py::register_python_type(module.get(), &type_spec_EmailMailboxEmptyFolderRequest, object_bases.get(), nullptr)};
    if (!EmailMailboxEmptyFolderRequest_type)
    {
        return nullptr;
    }

    py::pytype_handle EmailMailboxEmptyFolderRequestEventArgs_type{py::register_python_type(module.get(), &type_spec_EmailMailboxEmptyFolderRequestEventArgs, object_bases.get(), nullptr)};
    if (!EmailMailboxEmptyFolderRequestEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle EmailMailboxForwardMeetingRequest_type{py::register_python_type(module.get(), &type_spec_EmailMailboxForwardMeetingRequest, object_bases.get(), nullptr)};
    if (!EmailMailboxForwardMeetingRequest_type)
    {
        return nullptr;
    }

    py::pytype_handle EmailMailboxForwardMeetingRequestEventArgs_type{py::register_python_type(module.get(), &type_spec_EmailMailboxForwardMeetingRequestEventArgs, object_bases.get(), nullptr)};
    if (!EmailMailboxForwardMeetingRequestEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle EmailMailboxGetAutoReplySettingsRequest_type{py::register_python_type(module.get(), &type_spec_EmailMailboxGetAutoReplySettingsRequest, object_bases.get(), nullptr)};
    if (!EmailMailboxGetAutoReplySettingsRequest_type)
    {
        return nullptr;
    }

    py::pytype_handle EmailMailboxGetAutoReplySettingsRequestEventArgs_type{py::register_python_type(module.get(), &type_spec_EmailMailboxGetAutoReplySettingsRequestEventArgs, object_bases.get(), nullptr)};
    if (!EmailMailboxGetAutoReplySettingsRequestEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle EmailMailboxMoveFolderRequest_type{py::register_python_type(module.get(), &type_spec_EmailMailboxMoveFolderRequest, object_bases.get(), nullptr)};
    if (!EmailMailboxMoveFolderRequest_type)
    {
        return nullptr;
    }

    py::pytype_handle EmailMailboxMoveFolderRequestEventArgs_type{py::register_python_type(module.get(), &type_spec_EmailMailboxMoveFolderRequestEventArgs, object_bases.get(), nullptr)};
    if (!EmailMailboxMoveFolderRequestEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle EmailMailboxProposeNewTimeForMeetingRequest_type{py::register_python_type(module.get(), &type_spec_EmailMailboxProposeNewTimeForMeetingRequest, object_bases.get(), nullptr)};
    if (!EmailMailboxProposeNewTimeForMeetingRequest_type)
    {
        return nullptr;
    }

    py::pytype_handle EmailMailboxProposeNewTimeForMeetingRequestEventArgs_type{py::register_python_type(module.get(), &type_spec_EmailMailboxProposeNewTimeForMeetingRequestEventArgs, object_bases.get(), nullptr)};
    if (!EmailMailboxProposeNewTimeForMeetingRequestEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle EmailMailboxResolveRecipientsRequest_type{py::register_python_type(module.get(), &type_spec_EmailMailboxResolveRecipientsRequest, object_bases.get(), nullptr)};
    if (!EmailMailboxResolveRecipientsRequest_type)
    {
        return nullptr;
    }

    py::pytype_handle EmailMailboxResolveRecipientsRequestEventArgs_type{py::register_python_type(module.get(), &type_spec_EmailMailboxResolveRecipientsRequestEventArgs, object_bases.get(), nullptr)};
    if (!EmailMailboxResolveRecipientsRequestEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle EmailMailboxServerSearchReadBatchRequest_type{py::register_python_type(module.get(), &type_spec_EmailMailboxServerSearchReadBatchRequest, object_bases.get(), nullptr)};
    if (!EmailMailboxServerSearchReadBatchRequest_type)
    {
        return nullptr;
    }

    py::pytype_handle EmailMailboxServerSearchReadBatchRequestEventArgs_type{py::register_python_type(module.get(), &type_spec_EmailMailboxServerSearchReadBatchRequestEventArgs, object_bases.get(), nullptr)};
    if (!EmailMailboxServerSearchReadBatchRequestEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle EmailMailboxSetAutoReplySettingsRequest_type{py::register_python_type(module.get(), &type_spec_EmailMailboxSetAutoReplySettingsRequest, object_bases.get(), nullptr)};
    if (!EmailMailboxSetAutoReplySettingsRequest_type)
    {
        return nullptr;
    }

    py::pytype_handle EmailMailboxSetAutoReplySettingsRequestEventArgs_type{py::register_python_type(module.get(), &type_spec_EmailMailboxSetAutoReplySettingsRequestEventArgs, object_bases.get(), nullptr)};
    if (!EmailMailboxSetAutoReplySettingsRequestEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle EmailMailboxSyncManagerSyncRequest_type{py::register_python_type(module.get(), &type_spec_EmailMailboxSyncManagerSyncRequest, object_bases.get(), nullptr)};
    if (!EmailMailboxSyncManagerSyncRequest_type)
    {
        return nullptr;
    }

    py::pytype_handle EmailMailboxSyncManagerSyncRequestEventArgs_type{py::register_python_type(module.get(), &type_spec_EmailMailboxSyncManagerSyncRequestEventArgs, object_bases.get(), nullptr)};
    if (!EmailMailboxSyncManagerSyncRequestEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle EmailMailboxUpdateMeetingResponseRequest_type{py::register_python_type(module.get(), &type_spec_EmailMailboxUpdateMeetingResponseRequest, object_bases.get(), nullptr)};
    if (!EmailMailboxUpdateMeetingResponseRequest_type)
    {
        return nullptr;
    }

    py::pytype_handle EmailMailboxUpdateMeetingResponseRequestEventArgs_type{py::register_python_type(module.get(), &type_spec_EmailMailboxUpdateMeetingResponseRequestEventArgs, object_bases.get(), nullptr)};
    if (!EmailMailboxUpdateMeetingResponseRequestEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle EmailMailboxValidateCertificatesRequest_type{py::register_python_type(module.get(), &type_spec_EmailMailboxValidateCertificatesRequest, object_bases.get(), nullptr)};
    if (!EmailMailboxValidateCertificatesRequest_type)
    {
        return nullptr;
    }

    py::pytype_handle EmailMailboxValidateCertificatesRequestEventArgs_type{py::register_python_type(module.get(), &type_spec_EmailMailboxValidateCertificatesRequestEventArgs, object_bases.get(), nullptr)};
    if (!EmailMailboxValidateCertificatesRequestEventArgs_type)
    {
        return nullptr;
    }


    return module.detach();
}
