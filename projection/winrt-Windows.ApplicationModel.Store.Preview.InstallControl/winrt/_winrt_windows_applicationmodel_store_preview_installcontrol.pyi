# WARNING: Please don't edit this file. It was generated by Python/WinRT v2.2.0

import datetime
import sys
import types
import typing
import uuid as _uuid
from builtins import property as _property

import winrt._winrt
import winrt.system
import winrt.windows.foundation as windows_foundation
import winrt.windows.foundation.collections as windows_foundation_collections
import winrt.windows.management.deployment as windows_management_deployment
import winrt.windows.system as windows_system

from winrt.windows.applicationmodel.store.preview.installcontrol import AppInstallState, AppInstallType, AppInstallationToastNotificationMode, AutoUpdateSetting, GetEntitlementStatus

Self = typing.TypeVar('Self')

@typing.final
class AppInstallItem(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> AppInstallItem: ...
    @typing.overload
    def cancel(self) -> None: ...
    @typing.overload
    def cancel(self, correlation_vector: str, /) -> None: ...
    def get_current_status(self) -> typing.Optional[AppInstallStatus]: ...
    @typing.overload
    def pause(self) -> None: ...
    @typing.overload
    def pause(self, correlation_vector: str, /) -> None: ...
    @typing.overload
    def restart(self) -> None: ...
    @typing.overload
    def restart(self, correlation_vector: str, /) -> None: ...
    def add_completed(self, handler: windows_foundation.TypedEventHandler[AppInstallItem, winrt.system.Object], /) -> windows_foundation.EventRegistrationToken: ...
    def remove_completed(self, token: windows_foundation.EventRegistrationToken, /) -> None: ...
    def add_status_changed(self, handler: windows_foundation.TypedEventHandler[AppInstallItem, winrt.system.Object], /) -> windows_foundation.EventRegistrationToken: ...
    def remove_status_changed(self, token: windows_foundation.EventRegistrationToken, /) -> None: ...
    @_property
    def install_type(self) -> AppInstallType: ...
    @_property
    def is_user_initiated(self) -> bool: ...
    @_property
    def package_family_name(self) -> str: ...
    @_property
    def product_id(self) -> str: ...
    @_property
    def children(self) -> typing.Optional[windows_foundation_collections.IVectorView[AppInstallItem]]: ...
    @_property
    def item_operations_might_affect_other_items(self) -> bool: ...
    @_property
    def launch_after_install(self) -> bool: ...
    @launch_after_install.setter
    def launch_after_install(self, value: bool) -> None: ...
    @_property
    def pin_to_taskbar_after_install(self) -> bool: ...
    @pin_to_taskbar_after_install.setter
    def pin_to_taskbar_after_install(self, value: bool) -> None: ...
    @_property
    def pin_to_start_after_install(self) -> bool: ...
    @pin_to_start_after_install.setter
    def pin_to_start_after_install(self, value: bool) -> None: ...
    @_property
    def pin_to_desktop_after_install(self) -> bool: ...
    @pin_to_desktop_after_install.setter
    def pin_to_desktop_after_install(self, value: bool) -> None: ...
    @_property
    def install_in_progress_toast_notification_mode(self) -> AppInstallationToastNotificationMode: ...
    @install_in_progress_toast_notification_mode.setter
    def install_in_progress_toast_notification_mode(self, value: AppInstallationToastNotificationMode) -> None: ...
    @_property
    def completed_install_toast_notification_mode(self) -> AppInstallationToastNotificationMode: ...
    @completed_install_toast_notification_mode.setter
    def completed_install_toast_notification_mode(self, value: AppInstallationToastNotificationMode) -> None: ...

@typing.final
class AppInstallManager(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> AppInstallManager: ...
    def __new__(cls: typing.Type[AppInstallManager]) -> AppInstallManager: ...
    @typing.overload
    def cancel(self, product_id: str, /) -> None: ...
    @typing.overload
    def cancel(self, product_id: str, correlation_vector: str, /) -> None: ...
    def get_free_device_entitlement_async(self, store_id: str, campaign_id: str, correlation_vector: str, /) -> windows_foundation.IAsyncOperation[GetEntitlementResult]: ...
    def get_free_user_entitlement_async(self, store_id: str, campaign_id: str, correlation_vector: str, /) -> windows_foundation.IAsyncOperation[GetEntitlementResult]: ...
    def get_free_user_entitlement_for_user_async(self, user: typing.Optional[windows_system.User], store_id: str, campaign_id: str, correlation_vector: str, /) -> windows_foundation.IAsyncOperation[GetEntitlementResult]: ...
    @typing.overload
    def get_is_app_allowed_to_install_async(self, product_id: str, /) -> windows_foundation.IAsyncOperation[bool]: ...
    @typing.overload
    def get_is_app_allowed_to_install_async(self, product_id: str, sku_id: str, catalog_id: str, correlation_vector: str, /) -> windows_foundation.IAsyncOperation[bool]: ...
    def get_is_app_allowed_to_install_for_user_async(self, user: typing.Optional[windows_system.User], product_id: str, sku_id: str, catalog_id: str, correlation_vector: str, /) -> windows_foundation.IAsyncOperation[bool]: ...
    def get_is_applicable_async(self, product_id: str, sku_id: str, /) -> windows_foundation.IAsyncOperation[bool]: ...
    def get_is_applicable_for_user_async(self, user: typing.Optional[windows_system.User], product_id: str, sku_id: str, /) -> windows_foundation.IAsyncOperation[bool]: ...
    def get_is_package_identity_allowed_to_install_async(self, correlation_vector: str, package_identity_name: str, publisher_certificate_name: str, /) -> windows_foundation.IAsyncOperation[bool]: ...
    def get_is_package_identity_allowed_to_install_for_user_async(self, user: typing.Optional[windows_system.User], correlation_vector: str, package_identity_name: str, publisher_certificate_name: str, /) -> windows_foundation.IAsyncOperation[bool]: ...
    def is_store_blocked_by_policy_async(self, store_client_name: str, store_client_publisher: str, /) -> windows_foundation.IAsyncOperation[bool]: ...
    def move_to_front_of_download_queue(self, product_id: str, correlation_vector: str, /) -> None: ...
    @typing.overload
    def pause(self, product_id: str, /) -> None: ...
    @typing.overload
    def pause(self, product_id: str, correlation_vector: str, /) -> None: ...
    @typing.overload
    def restart(self, product_id: str, /) -> None: ...
    @typing.overload
    def restart(self, product_id: str, correlation_vector: str, /) -> None: ...
    @typing.overload
    def search_for_all_updates_async(self) -> windows_foundation.IAsyncOperation[windows_foundation_collections.IVectorView[AppInstallItem]]: ...
    @typing.overload
    def search_for_all_updates_async(self, correlation_vector: str, /) -> windows_foundation.IAsyncOperation[windows_foundation_collections.IVectorView[AppInstallItem]]: ...
    @typing.overload
    def search_for_all_updates_async(self, correlation_vector: str, client_id: str, update_options: typing.Optional[AppUpdateOptions], /) -> windows_foundation.IAsyncOperation[windows_foundation_collections.IVectorView[AppInstallItem]]: ...
    @typing.overload
    def search_for_all_updates_for_user_async(self, user: typing.Optional[windows_system.User], correlation_vector: str, /) -> windows_foundation.IAsyncOperation[windows_foundation_collections.IVectorView[AppInstallItem]]: ...
    @typing.overload
    def search_for_all_updates_for_user_async(self, user: typing.Optional[windows_system.User], correlation_vector: str, client_id: str, update_options: typing.Optional[AppUpdateOptions], /) -> windows_foundation.IAsyncOperation[windows_foundation_collections.IVectorView[AppInstallItem]]: ...
    @typing.overload
    def search_for_updates_async(self, product_id: str, sku_id: str, /) -> windows_foundation.IAsyncOperation[AppInstallItem]: ...
    @typing.overload
    def search_for_updates_async(self, product_id: str, sku_id: str, catalog_id: str, correlation_vector: str, /) -> windows_foundation.IAsyncOperation[AppInstallItem]: ...
    @typing.overload
    def search_for_updates_async(self, product_id: str, sku_id: str, correlation_vector: str, client_id: str, update_options: typing.Optional[AppUpdateOptions], /) -> windows_foundation.IAsyncOperation[AppInstallItem]: ...
    @typing.overload
    def search_for_updates_for_user_async(self, user: typing.Optional[windows_system.User], product_id: str, sku_id: str, catalog_id: str, correlation_vector: str, /) -> windows_foundation.IAsyncOperation[AppInstallItem]: ...
    @typing.overload
    def search_for_updates_for_user_async(self, user: typing.Optional[windows_system.User], product_id: str, sku_id: str, correlation_vector: str, client_id: str, update_options: typing.Optional[AppUpdateOptions], /) -> windows_foundation.IAsyncOperation[AppInstallItem]: ...
    @typing.overload
    def start_app_install_async(self, product_id: str, sku_id: str, repair: bool, force_use_of_non_removable_storage: bool, /) -> windows_foundation.IAsyncOperation[AppInstallItem]: ...
    @typing.overload
    def start_app_install_async(self, product_id: str, sku_id: str, repair: bool, force_use_of_non_removable_storage: bool, catalog_id: str, bundle_id: str, correlation_vector: str, /) -> windows_foundation.IAsyncOperation[AppInstallItem]: ...
    @typing.overload
    def start_product_install_async(self, product_id: str, flight_id: str, client_id: str, correlation_vector: str, install_options: typing.Optional[AppInstallOptions], /) -> windows_foundation.IAsyncOperation[windows_foundation_collections.IVectorView[AppInstallItem]]: ...
    @typing.overload
    def start_product_install_async(self, product_id: str, catalog_id: str, flight_id: str, client_id: str, repair: bool, force_use_of_non_removable_storage: bool, correlation_vector: str, target_volume: typing.Optional[windows_management_deployment.PackageVolume], /) -> windows_foundation.IAsyncOperation[windows_foundation_collections.IVectorView[AppInstallItem]]: ...
    @typing.overload
    def start_product_install_for_user_async(self, user: typing.Optional[windows_system.User], product_id: str, flight_id: str, client_id: str, correlation_vector: str, install_options: typing.Optional[AppInstallOptions], /) -> windows_foundation.IAsyncOperation[windows_foundation_collections.IVectorView[AppInstallItem]]: ...
    @typing.overload
    def start_product_install_for_user_async(self, user: typing.Optional[windows_system.User], product_id: str, catalog_id: str, flight_id: str, client_id: str, repair: bool, force_use_of_non_removable_storage: bool, correlation_vector: str, target_volume: typing.Optional[windows_management_deployment.PackageVolume], /) -> windows_foundation.IAsyncOperation[windows_foundation_collections.IVectorView[AppInstallItem]]: ...
    @typing.overload
    def update_app_by_package_family_name_async(self, package_family_name: str, /) -> windows_foundation.IAsyncOperation[AppInstallItem]: ...
    @typing.overload
    def update_app_by_package_family_name_async(self, package_family_name: str, correlation_vector: str, /) -> windows_foundation.IAsyncOperation[AppInstallItem]: ...
    def update_app_by_package_family_name_for_user_async(self, user: typing.Optional[windows_system.User], package_family_name: str, correlation_vector: str, /) -> windows_foundation.IAsyncOperation[AppInstallItem]: ...
    def add_item_completed(self, handler: windows_foundation.TypedEventHandler[AppInstallManager, AppInstallManagerItemEventArgs], /) -> windows_foundation.EventRegistrationToken: ...
    def remove_item_completed(self, token: windows_foundation.EventRegistrationToken, /) -> None: ...
    def add_item_status_changed(self, handler: windows_foundation.TypedEventHandler[AppInstallManager, AppInstallManagerItemEventArgs], /) -> windows_foundation.EventRegistrationToken: ...
    def remove_item_status_changed(self, token: windows_foundation.EventRegistrationToken, /) -> None: ...
    @_property
    def auto_update_setting(self) -> AutoUpdateSetting: ...
    @auto_update_setting.setter
    def auto_update_setting(self, value: AutoUpdateSetting) -> None: ...
    @_property
    def acquisition_identity(self) -> str: ...
    @acquisition_identity.setter
    def acquisition_identity(self, value: str) -> None: ...
    @_property
    def app_install_items(self) -> typing.Optional[windows_foundation_collections.IVectorView[AppInstallItem]]: ...
    @_property
    def app_install_items_with_group_support(self) -> typing.Optional[windows_foundation_collections.IVectorView[AppInstallItem]]: ...
    @_property
    def can_install_for_all_users(self) -> bool: ...

@typing.final
class AppInstallManagerItemEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> AppInstallManagerItemEventArgs: ...
    @_property
    def item(self) -> typing.Optional[AppInstallItem]: ...

@typing.final
class AppInstallOptions(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> AppInstallOptions: ...
    def __new__(cls: typing.Type[AppInstallOptions]) -> AppInstallOptions: ...
    @_property
    def target_volume(self) -> typing.Optional[windows_management_deployment.PackageVolume]: ...
    @target_volume.setter
    def target_volume(self, value: typing.Optional[windows_management_deployment.PackageVolume]) -> None: ...
    @_property
    def repair(self) -> bool: ...
    @repair.setter
    def repair(self, value: bool) -> None: ...
    @_property
    def launch_after_install(self) -> bool: ...
    @launch_after_install.setter
    def launch_after_install(self, value: bool) -> None: ...
    @_property
    def force_use_of_non_removable_storage(self) -> bool: ...
    @force_use_of_non_removable_storage.setter
    def force_use_of_non_removable_storage(self, value: bool) -> None: ...
    @_property
    def catalog_id(self) -> str: ...
    @catalog_id.setter
    def catalog_id(self, value: str) -> None: ...
    @_property
    def allow_forced_app_restart(self) -> bool: ...
    @allow_forced_app_restart.setter
    def allow_forced_app_restart(self, value: bool) -> None: ...
    @_property
    def stage_but_do_not_install(self) -> bool: ...
    @stage_but_do_not_install.setter
    def stage_but_do_not_install(self, value: bool) -> None: ...
    @_property
    def pin_to_taskbar_after_install(self) -> bool: ...
    @pin_to_taskbar_after_install.setter
    def pin_to_taskbar_after_install(self, value: bool) -> None: ...
    @_property
    def pin_to_start_after_install(self) -> bool: ...
    @pin_to_start_after_install.setter
    def pin_to_start_after_install(self, value: bool) -> None: ...
    @_property
    def pin_to_desktop_after_install(self) -> bool: ...
    @pin_to_desktop_after_install.setter
    def pin_to_desktop_after_install(self, value: bool) -> None: ...
    @_property
    def install_in_progress_toast_notification_mode(self) -> AppInstallationToastNotificationMode: ...
    @install_in_progress_toast_notification_mode.setter
    def install_in_progress_toast_notification_mode(self, value: AppInstallationToastNotificationMode) -> None: ...
    @_property
    def install_for_all_users(self) -> bool: ...
    @install_for_all_users.setter
    def install_for_all_users(self, value: bool) -> None: ...
    @_property
    def extended_campaign_id(self) -> str: ...
    @extended_campaign_id.setter
    def extended_campaign_id(self, value: str) -> None: ...
    @_property
    def completed_install_toast_notification_mode(self) -> AppInstallationToastNotificationMode: ...
    @completed_install_toast_notification_mode.setter
    def completed_install_toast_notification_mode(self, value: AppInstallationToastNotificationMode) -> None: ...
    @_property
    def campaign_id(self) -> str: ...
    @campaign_id.setter
    def campaign_id(self, value: str) -> None: ...

@typing.final
class AppInstallStatus(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> AppInstallStatus: ...
    @_property
    def bytes_downloaded(self) -> winrt.system.UInt64: ...
    @_property
    def download_size_in_bytes(self) -> winrt.system.UInt64: ...
    @_property
    def error_code(self) -> windows_foundation.HResult: ...
    @_property
    def install_state(self) -> AppInstallState: ...
    @_property
    def percent_complete(self) -> winrt.system.Double: ...
    @_property
    def ready_for_launch(self) -> bool: ...
    @_property
    def user(self) -> typing.Optional[windows_system.User]: ...
    @_property
    def is_staged(self) -> bool: ...

@typing.final
class AppUpdateOptions(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> AppUpdateOptions: ...
    def __new__(cls: typing.Type[AppUpdateOptions]) -> AppUpdateOptions: ...
    @_property
    def catalog_id(self) -> str: ...
    @catalog_id.setter
    def catalog_id(self, value: str) -> None: ...
    @_property
    def allow_forced_app_restart(self) -> bool: ...
    @allow_forced_app_restart.setter
    def allow_forced_app_restart(self, value: bool) -> None: ...
    @_property
    def automatically_download_and_install_update_if_found(self) -> bool: ...
    @automatically_download_and_install_update_if_found.setter
    def automatically_download_and_install_update_if_found(self, value: bool) -> None: ...

@typing.final
class GetEntitlementResult(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> GetEntitlementResult: ...
    @_property
    def status(self) -> GetEntitlementStatus: ...

