// WARNING: Please don't edit this file. It was generated by Python/WinRT v2.0.1

#include "py.Windows.Devices.Input.h"


namespace py::cpp::Windows::Devices::Input
{
    // ----- KeyboardCapabilities class --------------------

    static PyObject* _new_KeyboardCapabilities(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Devices::Input::KeyboardCapabilities instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_KeyboardCapabilities(py::wrapper::Windows::Devices::Input::KeyboardCapabilities* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* KeyboardCapabilities_get_KeyboardPresent(py::wrapper::Windows::Devices::Input::KeyboardCapabilities* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Input.KeyboardCapabilities", L"KeyboardPresent"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.KeyboardPresent());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_KeyboardCapabilities(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Input::KeyboardCapabilities>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_KeyboardCapabilities(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Input::KeyboardCapabilities>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_KeyboardCapabilities[] = {
        { "_assign_array_", _assign_array_KeyboardCapabilities, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_KeyboardCapabilities), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_KeyboardCapabilities[] = {
        { "keyboard_present", reinterpret_cast<getter>(KeyboardCapabilities_get_KeyboardPresent), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_KeyboardCapabilities[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_KeyboardCapabilities) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_KeyboardCapabilities) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_KeyboardCapabilities) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_KeyboardCapabilities) },
        { },
    };

    static PyType_Spec type_spec_KeyboardCapabilities =
    {
        "winrt._winrt_windows_devices_input.KeyboardCapabilities",
        sizeof(py::wrapper::Windows::Devices::Input::KeyboardCapabilities),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_KeyboardCapabilities
    };

    // ----- MouseCapabilities class --------------------

    static PyObject* _new_MouseCapabilities(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Devices::Input::MouseCapabilities instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MouseCapabilities(py::wrapper::Windows::Devices::Input::MouseCapabilities* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MouseCapabilities_get_HorizontalWheelPresent(py::wrapper::Windows::Devices::Input::MouseCapabilities* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Input.MouseCapabilities", L"HorizontalWheelPresent"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.HorizontalWheelPresent());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MouseCapabilities_get_MousePresent(py::wrapper::Windows::Devices::Input::MouseCapabilities* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Input.MouseCapabilities", L"MousePresent"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MousePresent());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MouseCapabilities_get_NumberOfButtons(py::wrapper::Windows::Devices::Input::MouseCapabilities* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Input.MouseCapabilities", L"NumberOfButtons"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.NumberOfButtons());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MouseCapabilities_get_SwapButtons(py::wrapper::Windows::Devices::Input::MouseCapabilities* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Input.MouseCapabilities", L"SwapButtons"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SwapButtons());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MouseCapabilities_get_VerticalWheelPresent(py::wrapper::Windows::Devices::Input::MouseCapabilities* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Input.MouseCapabilities", L"VerticalWheelPresent"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.VerticalWheelPresent());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MouseCapabilities(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Input::MouseCapabilities>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MouseCapabilities(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Input::MouseCapabilities>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MouseCapabilities[] = {
        { "_assign_array_", _assign_array_MouseCapabilities, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MouseCapabilities), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MouseCapabilities[] = {
        { "horizontal_wheel_present", reinterpret_cast<getter>(MouseCapabilities_get_HorizontalWheelPresent), nullptr, nullptr, nullptr },
        { "mouse_present", reinterpret_cast<getter>(MouseCapabilities_get_MousePresent), nullptr, nullptr, nullptr },
        { "number_of_buttons", reinterpret_cast<getter>(MouseCapabilities_get_NumberOfButtons), nullptr, nullptr, nullptr },
        { "swap_buttons", reinterpret_cast<getter>(MouseCapabilities_get_SwapButtons), nullptr, nullptr, nullptr },
        { "vertical_wheel_present", reinterpret_cast<getter>(MouseCapabilities_get_VerticalWheelPresent), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MouseCapabilities[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MouseCapabilities) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MouseCapabilities) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MouseCapabilities) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MouseCapabilities) },
        { },
    };

    static PyType_Spec type_spec_MouseCapabilities =
    {
        "winrt._winrt_windows_devices_input.MouseCapabilities",
        sizeof(py::wrapper::Windows::Devices::Input::MouseCapabilities),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MouseCapabilities
    };

    // ----- MouseDevice class --------------------

    static PyObject* _new_MouseDevice(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Input::MouseDevice>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Input::MouseDevice>::type_name);
        return nullptr;
    }

    static void _dealloc_MouseDevice(py::wrapper::Windows::Devices::Input::MouseDevice* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MouseDevice_GetForCurrentView(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Input.MouseDevice", L"GetForCurrentView", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::Devices::Input::MouseDevice::GetForCurrentView());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MouseDevice_add_MouseMoved(py::wrapper::Windows::Devices::Input::MouseDevice* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Input.MouseDevice", L"MouseMoved"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Input::MouseDevice, winrt::Windows::Devices::Input::MouseEventArgs>>(arg);

            return py::convert(self->obj.MouseMoved(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MouseDevice_remove_MouseMoved(py::wrapper::Windows::Devices::Input::MouseDevice* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Input.MouseDevice", L"MouseMoved"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.MouseMoved(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MouseDevice(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Input::MouseDevice>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MouseDevice(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Input::MouseDevice>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MouseDevice[] = {
        { "add_mouse_moved", reinterpret_cast<PyCFunction>(MouseDevice_add_MouseMoved), METH_O, nullptr },
        { "remove_mouse_moved", reinterpret_cast<PyCFunction>(MouseDevice_remove_MouseMoved), METH_O, nullptr },
        { "_assign_array_", _assign_array_MouseDevice, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MouseDevice), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MouseDevice[] = {
        { }
    };

    static PyType_Slot _type_slots_MouseDevice[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MouseDevice) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MouseDevice) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MouseDevice) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MouseDevice) },
        { },
    };

    static PyType_Spec type_spec_MouseDevice =
    {
        "winrt._winrt_windows_devices_input.MouseDevice",
        sizeof(py::wrapper::Windows::Devices::Input::MouseDevice),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MouseDevice
    };

    static PyGetSetDef getset_MouseDevice_Static[] = {
        { }
    };

    static PyMethodDef methods_MouseDevice_Static[] = {
        { "get_for_current_view", reinterpret_cast<PyCFunction>(MouseDevice_GetForCurrentView), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_MouseDevice_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_MouseDevice_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_MouseDevice_Static) },
        { }
    };

    static PyType_Spec type_spec_MouseDevice_Static =
    {
        "winrt._winrt_windows_devices_input.MouseDevice_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_MouseDevice_Static
    };

    // ----- MouseEventArgs class --------------------

    static PyObject* _new_MouseEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Input::MouseEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Input::MouseEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_MouseEventArgs(py::wrapper::Windows::Devices::Input::MouseEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MouseEventArgs_get_MouseDelta(py::wrapper::Windows::Devices::Input::MouseEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Input.MouseEventArgs", L"MouseDelta"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MouseDelta());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MouseEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Input::MouseEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MouseEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Input::MouseEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MouseEventArgs[] = {
        { "_assign_array_", _assign_array_MouseEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MouseEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MouseEventArgs[] = {
        { "mouse_delta", reinterpret_cast<getter>(MouseEventArgs_get_MouseDelta), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MouseEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MouseEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MouseEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MouseEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MouseEventArgs) },
        { },
    };

    static PyType_Spec type_spec_MouseEventArgs =
    {
        "winrt._winrt_windows_devices_input.MouseEventArgs",
        sizeof(py::wrapper::Windows::Devices::Input::MouseEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MouseEventArgs
    };

    // ----- PenButtonListener class --------------------

    static PyObject* _new_PenButtonListener(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Input::PenButtonListener>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Input::PenButtonListener>::type_name);
        return nullptr;
    }

    static void _dealloc_PenButtonListener(py::wrapper::Windows::Devices::Input::PenButtonListener* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PenButtonListener_GetDefault(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Input.PenButtonListener", L"GetDefault", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::Devices::Input::PenButtonListener::GetDefault());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PenButtonListener_IsSupported(py::wrapper::Windows::Devices::Input::PenButtonListener* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Input.PenButtonListener", L"IsSupported", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.IsSupported());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PenButtonListener_add_IsSupportedChanged(py::wrapper::Windows::Devices::Input::PenButtonListener* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Input.PenButtonListener", L"IsSupportedChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Input::PenButtonListener, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.IsSupportedChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PenButtonListener_remove_IsSupportedChanged(py::wrapper::Windows::Devices::Input::PenButtonListener* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Input.PenButtonListener", L"IsSupportedChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.IsSupportedChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PenButtonListener_add_TailButtonClicked(py::wrapper::Windows::Devices::Input::PenButtonListener* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Input.PenButtonListener", L"TailButtonClicked"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Input::PenButtonListener, winrt::Windows::Devices::Input::PenTailButtonClickedEventArgs>>(arg);

            return py::convert(self->obj.TailButtonClicked(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PenButtonListener_remove_TailButtonClicked(py::wrapper::Windows::Devices::Input::PenButtonListener* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Input.PenButtonListener", L"TailButtonClicked"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.TailButtonClicked(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PenButtonListener_add_TailButtonDoubleClicked(py::wrapper::Windows::Devices::Input::PenButtonListener* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Input.PenButtonListener", L"TailButtonDoubleClicked"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Input::PenButtonListener, winrt::Windows::Devices::Input::PenTailButtonDoubleClickedEventArgs>>(arg);

            return py::convert(self->obj.TailButtonDoubleClicked(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PenButtonListener_remove_TailButtonDoubleClicked(py::wrapper::Windows::Devices::Input::PenButtonListener* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Input.PenButtonListener", L"TailButtonDoubleClicked"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.TailButtonDoubleClicked(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PenButtonListener_add_TailButtonLongPressed(py::wrapper::Windows::Devices::Input::PenButtonListener* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Input.PenButtonListener", L"TailButtonLongPressed"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Input::PenButtonListener, winrt::Windows::Devices::Input::PenTailButtonLongPressedEventArgs>>(arg);

            return py::convert(self->obj.TailButtonLongPressed(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PenButtonListener_remove_TailButtonLongPressed(py::wrapper::Windows::Devices::Input::PenButtonListener* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Input.PenButtonListener", L"TailButtonLongPressed"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.TailButtonLongPressed(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PenButtonListener(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Input::PenButtonListener>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PenButtonListener(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Input::PenButtonListener>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PenButtonListener[] = {
        { "is_supported", reinterpret_cast<PyCFunction>(PenButtonListener_IsSupported), METH_VARARGS, nullptr },
        { "add_is_supported_changed", reinterpret_cast<PyCFunction>(PenButtonListener_add_IsSupportedChanged), METH_O, nullptr },
        { "remove_is_supported_changed", reinterpret_cast<PyCFunction>(PenButtonListener_remove_IsSupportedChanged), METH_O, nullptr },
        { "add_tail_button_clicked", reinterpret_cast<PyCFunction>(PenButtonListener_add_TailButtonClicked), METH_O, nullptr },
        { "remove_tail_button_clicked", reinterpret_cast<PyCFunction>(PenButtonListener_remove_TailButtonClicked), METH_O, nullptr },
        { "add_tail_button_double_clicked", reinterpret_cast<PyCFunction>(PenButtonListener_add_TailButtonDoubleClicked), METH_O, nullptr },
        { "remove_tail_button_double_clicked", reinterpret_cast<PyCFunction>(PenButtonListener_remove_TailButtonDoubleClicked), METH_O, nullptr },
        { "add_tail_button_long_pressed", reinterpret_cast<PyCFunction>(PenButtonListener_add_TailButtonLongPressed), METH_O, nullptr },
        { "remove_tail_button_long_pressed", reinterpret_cast<PyCFunction>(PenButtonListener_remove_TailButtonLongPressed), METH_O, nullptr },
        { "_assign_array_", _assign_array_PenButtonListener, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PenButtonListener), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PenButtonListener[] = {
        { }
    };

    static PyType_Slot _type_slots_PenButtonListener[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PenButtonListener) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PenButtonListener) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PenButtonListener) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PenButtonListener) },
        { },
    };

    static PyType_Spec type_spec_PenButtonListener =
    {
        "winrt._winrt_windows_devices_input.PenButtonListener",
        sizeof(py::wrapper::Windows::Devices::Input::PenButtonListener),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PenButtonListener
    };

    static PyGetSetDef getset_PenButtonListener_Static[] = {
        { }
    };

    static PyMethodDef methods_PenButtonListener_Static[] = {
        { "get_default", reinterpret_cast<PyCFunction>(PenButtonListener_GetDefault), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_PenButtonListener_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_PenButtonListener_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_PenButtonListener_Static) },
        { }
    };

    static PyType_Spec type_spec_PenButtonListener_Static =
    {
        "winrt._winrt_windows_devices_input.PenButtonListener_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_PenButtonListener_Static
    };

    // ----- PenDevice class --------------------

    static PyObject* _new_PenDevice(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Input::PenDevice>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Input::PenDevice>::type_name);
        return nullptr;
    }

    static void _dealloc_PenDevice(py::wrapper::Windows::Devices::Input::PenDevice* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PenDevice_GetFromPointerId(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Input.PenDevice", L"GetFromPointerId", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);

                return py::convert(winrt::Windows::Devices::Input::PenDevice::GetFromPointerId(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PenDevice_get_PenId(py::wrapper::Windows::Devices::Input::PenDevice* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Input.PenDevice", L"PenId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PenId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PenDevice_get_SimpleHapticsController(py::wrapper::Windows::Devices::Input::PenDevice* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Input.PenDevice", L"SimpleHapticsController"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SimpleHapticsController());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PenDevice(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Input::PenDevice>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PenDevice(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Input::PenDevice>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PenDevice[] = {
        { "_assign_array_", _assign_array_PenDevice, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PenDevice), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PenDevice[] = {
        { "pen_id", reinterpret_cast<getter>(PenDevice_get_PenId), nullptr, nullptr, nullptr },
        { "simple_haptics_controller", reinterpret_cast<getter>(PenDevice_get_SimpleHapticsController), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PenDevice[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PenDevice) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PenDevice) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PenDevice) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PenDevice) },
        { },
    };

    static PyType_Spec type_spec_PenDevice =
    {
        "winrt._winrt_windows_devices_input.PenDevice",
        sizeof(py::wrapper::Windows::Devices::Input::PenDevice),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PenDevice
    };

    static PyGetSetDef getset_PenDevice_Static[] = {
        { }
    };

    static PyMethodDef methods_PenDevice_Static[] = {
        { "get_from_pointer_id", reinterpret_cast<PyCFunction>(PenDevice_GetFromPointerId), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_PenDevice_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_PenDevice_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_PenDevice_Static) },
        { }
    };

    static PyType_Spec type_spec_PenDevice_Static =
    {
        "winrt._winrt_windows_devices_input.PenDevice_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_PenDevice_Static
    };

    // ----- PenDockListener class --------------------

    static PyObject* _new_PenDockListener(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Input::PenDockListener>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Input::PenDockListener>::type_name);
        return nullptr;
    }

    static void _dealloc_PenDockListener(py::wrapper::Windows::Devices::Input::PenDockListener* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PenDockListener_GetDefault(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Input.PenDockListener", L"GetDefault", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::Devices::Input::PenDockListener::GetDefault());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PenDockListener_IsSupported(py::wrapper::Windows::Devices::Input::PenDockListener* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Input.PenDockListener", L"IsSupported", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.IsSupported());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PenDockListener_add_Docked(py::wrapper::Windows::Devices::Input::PenDockListener* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Input.PenDockListener", L"Docked"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Input::PenDockListener, winrt::Windows::Devices::Input::PenDockedEventArgs>>(arg);

            return py::convert(self->obj.Docked(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PenDockListener_remove_Docked(py::wrapper::Windows::Devices::Input::PenDockListener* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Input.PenDockListener", L"Docked"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Docked(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PenDockListener_add_IsSupportedChanged(py::wrapper::Windows::Devices::Input::PenDockListener* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Input.PenDockListener", L"IsSupportedChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Input::PenDockListener, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.IsSupportedChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PenDockListener_remove_IsSupportedChanged(py::wrapper::Windows::Devices::Input::PenDockListener* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Input.PenDockListener", L"IsSupportedChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.IsSupportedChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PenDockListener_add_Undocked(py::wrapper::Windows::Devices::Input::PenDockListener* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Input.PenDockListener", L"Undocked"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Input::PenDockListener, winrt::Windows::Devices::Input::PenUndockedEventArgs>>(arg);

            return py::convert(self->obj.Undocked(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PenDockListener_remove_Undocked(py::wrapper::Windows::Devices::Input::PenDockListener* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Input.PenDockListener", L"Undocked"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Undocked(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PenDockListener(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Input::PenDockListener>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PenDockListener(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Input::PenDockListener>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PenDockListener[] = {
        { "is_supported", reinterpret_cast<PyCFunction>(PenDockListener_IsSupported), METH_VARARGS, nullptr },
        { "add_docked", reinterpret_cast<PyCFunction>(PenDockListener_add_Docked), METH_O, nullptr },
        { "remove_docked", reinterpret_cast<PyCFunction>(PenDockListener_remove_Docked), METH_O, nullptr },
        { "add_is_supported_changed", reinterpret_cast<PyCFunction>(PenDockListener_add_IsSupportedChanged), METH_O, nullptr },
        { "remove_is_supported_changed", reinterpret_cast<PyCFunction>(PenDockListener_remove_IsSupportedChanged), METH_O, nullptr },
        { "add_undocked", reinterpret_cast<PyCFunction>(PenDockListener_add_Undocked), METH_O, nullptr },
        { "remove_undocked", reinterpret_cast<PyCFunction>(PenDockListener_remove_Undocked), METH_O, nullptr },
        { "_assign_array_", _assign_array_PenDockListener, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PenDockListener), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PenDockListener[] = {
        { }
    };

    static PyType_Slot _type_slots_PenDockListener[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PenDockListener) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PenDockListener) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PenDockListener) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PenDockListener) },
        { },
    };

    static PyType_Spec type_spec_PenDockListener =
    {
        "winrt._winrt_windows_devices_input.PenDockListener",
        sizeof(py::wrapper::Windows::Devices::Input::PenDockListener),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PenDockListener
    };

    static PyGetSetDef getset_PenDockListener_Static[] = {
        { }
    };

    static PyMethodDef methods_PenDockListener_Static[] = {
        { "get_default", reinterpret_cast<PyCFunction>(PenDockListener_GetDefault), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_PenDockListener_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_PenDockListener_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_PenDockListener_Static) },
        { }
    };

    static PyType_Spec type_spec_PenDockListener_Static =
    {
        "winrt._winrt_windows_devices_input.PenDockListener_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_PenDockListener_Static
    };

    // ----- PenDockedEventArgs class --------------------

    static PyObject* _new_PenDockedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Input::PenDockedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Input::PenDockedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_PenDockedEventArgs(py::wrapper::Windows::Devices::Input::PenDockedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_PenDockedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Input::PenDockedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PenDockedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Input::PenDockedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PenDockedEventArgs[] = {
        { "_assign_array_", _assign_array_PenDockedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PenDockedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PenDockedEventArgs[] = {
        { }
    };

    static PyType_Slot _type_slots_PenDockedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PenDockedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PenDockedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PenDockedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PenDockedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_PenDockedEventArgs =
    {
        "winrt._winrt_windows_devices_input.PenDockedEventArgs",
        sizeof(py::wrapper::Windows::Devices::Input::PenDockedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PenDockedEventArgs
    };

    // ----- PenTailButtonClickedEventArgs class --------------------

    static PyObject* _new_PenTailButtonClickedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Input::PenTailButtonClickedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Input::PenTailButtonClickedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_PenTailButtonClickedEventArgs(py::wrapper::Windows::Devices::Input::PenTailButtonClickedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_PenTailButtonClickedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Input::PenTailButtonClickedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PenTailButtonClickedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Input::PenTailButtonClickedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PenTailButtonClickedEventArgs[] = {
        { "_assign_array_", _assign_array_PenTailButtonClickedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PenTailButtonClickedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PenTailButtonClickedEventArgs[] = {
        { }
    };

    static PyType_Slot _type_slots_PenTailButtonClickedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PenTailButtonClickedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PenTailButtonClickedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PenTailButtonClickedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PenTailButtonClickedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_PenTailButtonClickedEventArgs =
    {
        "winrt._winrt_windows_devices_input.PenTailButtonClickedEventArgs",
        sizeof(py::wrapper::Windows::Devices::Input::PenTailButtonClickedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PenTailButtonClickedEventArgs
    };

    // ----- PenTailButtonDoubleClickedEventArgs class --------------------

    static PyObject* _new_PenTailButtonDoubleClickedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Input::PenTailButtonDoubleClickedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Input::PenTailButtonDoubleClickedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_PenTailButtonDoubleClickedEventArgs(py::wrapper::Windows::Devices::Input::PenTailButtonDoubleClickedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_PenTailButtonDoubleClickedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Input::PenTailButtonDoubleClickedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PenTailButtonDoubleClickedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Input::PenTailButtonDoubleClickedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PenTailButtonDoubleClickedEventArgs[] = {
        { "_assign_array_", _assign_array_PenTailButtonDoubleClickedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PenTailButtonDoubleClickedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PenTailButtonDoubleClickedEventArgs[] = {
        { }
    };

    static PyType_Slot _type_slots_PenTailButtonDoubleClickedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PenTailButtonDoubleClickedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PenTailButtonDoubleClickedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PenTailButtonDoubleClickedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PenTailButtonDoubleClickedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_PenTailButtonDoubleClickedEventArgs =
    {
        "winrt._winrt_windows_devices_input.PenTailButtonDoubleClickedEventArgs",
        sizeof(py::wrapper::Windows::Devices::Input::PenTailButtonDoubleClickedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PenTailButtonDoubleClickedEventArgs
    };

    // ----- PenTailButtonLongPressedEventArgs class --------------------

    static PyObject* _new_PenTailButtonLongPressedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Input::PenTailButtonLongPressedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Input::PenTailButtonLongPressedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_PenTailButtonLongPressedEventArgs(py::wrapper::Windows::Devices::Input::PenTailButtonLongPressedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_PenTailButtonLongPressedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Input::PenTailButtonLongPressedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PenTailButtonLongPressedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Input::PenTailButtonLongPressedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PenTailButtonLongPressedEventArgs[] = {
        { "_assign_array_", _assign_array_PenTailButtonLongPressedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PenTailButtonLongPressedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PenTailButtonLongPressedEventArgs[] = {
        { }
    };

    static PyType_Slot _type_slots_PenTailButtonLongPressedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PenTailButtonLongPressedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PenTailButtonLongPressedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PenTailButtonLongPressedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PenTailButtonLongPressedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_PenTailButtonLongPressedEventArgs =
    {
        "winrt._winrt_windows_devices_input.PenTailButtonLongPressedEventArgs",
        sizeof(py::wrapper::Windows::Devices::Input::PenTailButtonLongPressedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PenTailButtonLongPressedEventArgs
    };

    // ----- PenUndockedEventArgs class --------------------

    static PyObject* _new_PenUndockedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Input::PenUndockedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Input::PenUndockedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_PenUndockedEventArgs(py::wrapper::Windows::Devices::Input::PenUndockedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_PenUndockedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Input::PenUndockedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PenUndockedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Input::PenUndockedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PenUndockedEventArgs[] = {
        { "_assign_array_", _assign_array_PenUndockedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PenUndockedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PenUndockedEventArgs[] = {
        { }
    };

    static PyType_Slot _type_slots_PenUndockedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PenUndockedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PenUndockedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PenUndockedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PenUndockedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_PenUndockedEventArgs =
    {
        "winrt._winrt_windows_devices_input.PenUndockedEventArgs",
        sizeof(py::wrapper::Windows::Devices::Input::PenUndockedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PenUndockedEventArgs
    };

    // ----- PointerDevice class --------------------

    static PyObject* _new_PointerDevice(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Input::PointerDevice>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Input::PointerDevice>::type_name);
        return nullptr;
    }

    static void _dealloc_PointerDevice(py::wrapper::Windows::Devices::Input::PointerDevice* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PointerDevice_GetPointerDevice(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Input.PointerDevice", L"GetPointerDevice", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);

                return py::convert(winrt::Windows::Devices::Input::PointerDevice::GetPointerDevice(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PointerDevice_GetPointerDevices(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Input.PointerDevice", L"GetPointerDevices", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::Devices::Input::PointerDevice::GetPointerDevices());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PointerDevice_get_IsIntegrated(py::wrapper::Windows::Devices::Input::PointerDevice* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Input.PointerDevice", L"IsIntegrated"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsIntegrated());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PointerDevice_get_MaxContacts(py::wrapper::Windows::Devices::Input::PointerDevice* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Input.PointerDevice", L"MaxContacts"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MaxContacts());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PointerDevice_get_PhysicalDeviceRect(py::wrapper::Windows::Devices::Input::PointerDevice* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Input.PointerDevice", L"PhysicalDeviceRect"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PhysicalDeviceRect());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PointerDevice_get_PointerDeviceType(py::wrapper::Windows::Devices::Input::PointerDevice* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Input.PointerDevice", L"PointerDeviceType"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PointerDeviceType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PointerDevice_get_ScreenRect(py::wrapper::Windows::Devices::Input::PointerDevice* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Input.PointerDevice", L"ScreenRect"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ScreenRect());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PointerDevice_get_SupportedUsages(py::wrapper::Windows::Devices::Input::PointerDevice* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Input.PointerDevice", L"SupportedUsages"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SupportedUsages());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PointerDevice_get_MaxPointersWithZDistance(py::wrapper::Windows::Devices::Input::PointerDevice* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Input.PointerDevice", L"MaxPointersWithZDistance"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MaxPointersWithZDistance());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PointerDevice(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Input::PointerDevice>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PointerDevice(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Input::PointerDevice>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PointerDevice[] = {
        { "_assign_array_", _assign_array_PointerDevice, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PointerDevice), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PointerDevice[] = {
        { "is_integrated", reinterpret_cast<getter>(PointerDevice_get_IsIntegrated), nullptr, nullptr, nullptr },
        { "max_contacts", reinterpret_cast<getter>(PointerDevice_get_MaxContacts), nullptr, nullptr, nullptr },
        { "physical_device_rect", reinterpret_cast<getter>(PointerDevice_get_PhysicalDeviceRect), nullptr, nullptr, nullptr },
        { "pointer_device_type", reinterpret_cast<getter>(PointerDevice_get_PointerDeviceType), nullptr, nullptr, nullptr },
        { "screen_rect", reinterpret_cast<getter>(PointerDevice_get_ScreenRect), nullptr, nullptr, nullptr },
        { "supported_usages", reinterpret_cast<getter>(PointerDevice_get_SupportedUsages), nullptr, nullptr, nullptr },
        { "max_pointers_with_z_distance", reinterpret_cast<getter>(PointerDevice_get_MaxPointersWithZDistance), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PointerDevice[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PointerDevice) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PointerDevice) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PointerDevice) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PointerDevice) },
        { },
    };

    static PyType_Spec type_spec_PointerDevice =
    {
        "winrt._winrt_windows_devices_input.PointerDevice",
        sizeof(py::wrapper::Windows::Devices::Input::PointerDevice),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PointerDevice
    };

    static PyGetSetDef getset_PointerDevice_Static[] = {
        { }
    };

    static PyMethodDef methods_PointerDevice_Static[] = {
        { "get_pointer_device", reinterpret_cast<PyCFunction>(PointerDevice_GetPointerDevice), METH_VARARGS, nullptr },
        { "get_pointer_devices", reinterpret_cast<PyCFunction>(PointerDevice_GetPointerDevices), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_PointerDevice_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_PointerDevice_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_PointerDevice_Static) },
        { }
    };

    static PyType_Spec type_spec_PointerDevice_Static =
    {
        "winrt._winrt_windows_devices_input.PointerDevice_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_PointerDevice_Static
    };

    // ----- TouchCapabilities class --------------------

    static PyObject* _new_TouchCapabilities(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Devices::Input::TouchCapabilities instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_TouchCapabilities(py::wrapper::Windows::Devices::Input::TouchCapabilities* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* TouchCapabilities_get_Contacts(py::wrapper::Windows::Devices::Input::TouchCapabilities* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Input.TouchCapabilities", L"Contacts"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Contacts());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TouchCapabilities_get_TouchPresent(py::wrapper::Windows::Devices::Input::TouchCapabilities* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Input.TouchCapabilities", L"TouchPresent"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TouchPresent());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_TouchCapabilities(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Input::TouchCapabilities>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_TouchCapabilities(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Input::TouchCapabilities>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TouchCapabilities[] = {
        { "_assign_array_", _assign_array_TouchCapabilities, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_TouchCapabilities), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_TouchCapabilities[] = {
        { "contacts", reinterpret_cast<getter>(TouchCapabilities_get_Contacts), nullptr, nullptr, nullptr },
        { "touch_present", reinterpret_cast<getter>(TouchCapabilities_get_TouchPresent), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_TouchCapabilities[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_TouchCapabilities) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_TouchCapabilities) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_TouchCapabilities) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_TouchCapabilities) },
        { },
    };

    static PyType_Spec type_spec_TouchCapabilities =
    {
        "winrt._winrt_windows_devices_input.TouchCapabilities",
        sizeof(py::wrapper::Windows::Devices::Input::TouchCapabilities),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TouchCapabilities
    };

    // ----- MouseDelta struct --------------------

    winrt_struct_wrapper<winrt::Windows::Devices::Input::MouseDelta>* _new_MouseDelta(PyTypeObject* subclass, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        auto self = reinterpret_cast<winrt_struct_wrapper<winrt::Windows::Devices::Input::MouseDelta>*>(subclass->tp_alloc(subclass, 0));

        if (!self)
        {
            return nullptr;
        }

        std::construct_at(&self->obj);

        return self;
    }

    int _init_MouseDelta(winrt_struct_wrapper<winrt::Windows::Devices::Input::MouseDelta>* self, PyObject* args, PyObject* kwds) noexcept
    {
        auto tuple_size = PyTuple_Size(args);

        if ((tuple_size == 0) && (kwds == nullptr))
        {
            self->obj = {};
            return 0;
        }

        int32_t _X{};
        int32_t _Y{};

        static const char* kwlist[] = {"x", "y", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "ii", const_cast<char**>(kwlist), &_X, &_Y))
        {
            return -1;
        }

        try
        {
            self->obj = {_X, _Y};
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static void _dealloc_MouseDelta(py::wrapper::Windows::Devices::Input::MouseDelta* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_MouseDelta(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Input::MouseDelta>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyMethodDef _methods_MouseDelta[] = {
        { "_assign_array_", _assign_array_MouseDelta, METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyObject* MouseDelta_get_X(py::wrapper::Windows::Devices::Input::MouseDelta* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.X);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MouseDelta_set_X(py::wrapper::Windows::Devices::Input::MouseDelta* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.X = py::converter<int32_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MouseDelta_get_Y(py::wrapper::Windows::Devices::Input::MouseDelta* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Y);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MouseDelta_set_Y(py::wrapper::Windows::Devices::Input::MouseDelta* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.Y = py::converter<int32_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyGetSetDef _getset_MouseDelta[] = {
        { "x", reinterpret_cast<getter>(MouseDelta_get_X), reinterpret_cast<setter>(MouseDelta_set_X), nullptr, nullptr },
        { "y", reinterpret_cast<getter>(MouseDelta_get_Y), reinterpret_cast<setter>(MouseDelta_set_Y), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MouseDelta[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MouseDelta) },
        { Py_tp_init, reinterpret_cast<void*>(_init_MouseDelta) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MouseDelta) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MouseDelta) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MouseDelta) },
        { },
    };

    static PyType_Spec type_spec_MouseDelta =
    {
        "winrt._winrt_windows_devices_input.MouseDelta",
        sizeof(py::wrapper::Windows::Devices::Input::MouseDelta),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MouseDelta
    };

    // ----- PointerDeviceUsage struct --------------------

    winrt_struct_wrapper<winrt::Windows::Devices::Input::PointerDeviceUsage>* _new_PointerDeviceUsage(PyTypeObject* subclass, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        auto self = reinterpret_cast<winrt_struct_wrapper<winrt::Windows::Devices::Input::PointerDeviceUsage>*>(subclass->tp_alloc(subclass, 0));

        if (!self)
        {
            return nullptr;
        }

        std::construct_at(&self->obj);

        return self;
    }

    int _init_PointerDeviceUsage(winrt_struct_wrapper<winrt::Windows::Devices::Input::PointerDeviceUsage>* self, PyObject* args, PyObject* kwds) noexcept
    {
        auto tuple_size = PyTuple_Size(args);

        if ((tuple_size == 0) && (kwds == nullptr))
        {
            self->obj = {};
            return 0;
        }

        uint32_t _UsagePage{};
        uint32_t _Usage{};
        int32_t _MinLogical{};
        int32_t _MaxLogical{};
        int32_t _MinPhysical{};
        int32_t _MaxPhysical{};
        uint32_t _Unit{};
        float _PhysicalMultiplier{};

        static const char* kwlist[] = {"usage_page", "usage", "min_logical", "max_logical", "min_physical", "max_physical", "unit", "physical_multiplier", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "IIiiiiIf", const_cast<char**>(kwlist), &_UsagePage, &_Usage, &_MinLogical, &_MaxLogical, &_MinPhysical, &_MaxPhysical, &_Unit, &_PhysicalMultiplier))
        {
            return -1;
        }

        try
        {
            self->obj = {_UsagePage, _Usage, _MinLogical, _MaxLogical, _MinPhysical, _MaxPhysical, _Unit, _PhysicalMultiplier};
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static void _dealloc_PointerDeviceUsage(py::wrapper::Windows::Devices::Input::PointerDeviceUsage* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_PointerDeviceUsage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Input::PointerDeviceUsage>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyMethodDef _methods_PointerDeviceUsage[] = {
        { "_assign_array_", _assign_array_PointerDeviceUsage, METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyObject* PointerDeviceUsage_get_UsagePage(py::wrapper::Windows::Devices::Input::PointerDeviceUsage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.UsagePage);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PointerDeviceUsage_set_UsagePage(py::wrapper::Windows::Devices::Input::PointerDeviceUsage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.UsagePage = py::converter<uint32_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PointerDeviceUsage_get_Usage(py::wrapper::Windows::Devices::Input::PointerDeviceUsage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Usage);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PointerDeviceUsage_set_Usage(py::wrapper::Windows::Devices::Input::PointerDeviceUsage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.Usage = py::converter<uint32_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PointerDeviceUsage_get_MinLogical(py::wrapper::Windows::Devices::Input::PointerDeviceUsage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MinLogical);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PointerDeviceUsage_set_MinLogical(py::wrapper::Windows::Devices::Input::PointerDeviceUsage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.MinLogical = py::converter<int32_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PointerDeviceUsage_get_MaxLogical(py::wrapper::Windows::Devices::Input::PointerDeviceUsage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MaxLogical);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PointerDeviceUsage_set_MaxLogical(py::wrapper::Windows::Devices::Input::PointerDeviceUsage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.MaxLogical = py::converter<int32_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PointerDeviceUsage_get_MinPhysical(py::wrapper::Windows::Devices::Input::PointerDeviceUsage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MinPhysical);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PointerDeviceUsage_set_MinPhysical(py::wrapper::Windows::Devices::Input::PointerDeviceUsage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.MinPhysical = py::converter<int32_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PointerDeviceUsage_get_MaxPhysical(py::wrapper::Windows::Devices::Input::PointerDeviceUsage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MaxPhysical);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PointerDeviceUsage_set_MaxPhysical(py::wrapper::Windows::Devices::Input::PointerDeviceUsage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.MaxPhysical = py::converter<int32_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PointerDeviceUsage_get_Unit(py::wrapper::Windows::Devices::Input::PointerDeviceUsage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Unit);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PointerDeviceUsage_set_Unit(py::wrapper::Windows::Devices::Input::PointerDeviceUsage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.Unit = py::converter<uint32_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PointerDeviceUsage_get_PhysicalMultiplier(py::wrapper::Windows::Devices::Input::PointerDeviceUsage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PhysicalMultiplier);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PointerDeviceUsage_set_PhysicalMultiplier(py::wrapper::Windows::Devices::Input::PointerDeviceUsage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.PhysicalMultiplier = py::converter<float>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyGetSetDef _getset_PointerDeviceUsage[] = {
        { "usage_page", reinterpret_cast<getter>(PointerDeviceUsage_get_UsagePage), reinterpret_cast<setter>(PointerDeviceUsage_set_UsagePage), nullptr, nullptr },
        { "usage", reinterpret_cast<getter>(PointerDeviceUsage_get_Usage), reinterpret_cast<setter>(PointerDeviceUsage_set_Usage), nullptr, nullptr },
        { "min_logical", reinterpret_cast<getter>(PointerDeviceUsage_get_MinLogical), reinterpret_cast<setter>(PointerDeviceUsage_set_MinLogical), nullptr, nullptr },
        { "max_logical", reinterpret_cast<getter>(PointerDeviceUsage_get_MaxLogical), reinterpret_cast<setter>(PointerDeviceUsage_set_MaxLogical), nullptr, nullptr },
        { "min_physical", reinterpret_cast<getter>(PointerDeviceUsage_get_MinPhysical), reinterpret_cast<setter>(PointerDeviceUsage_set_MinPhysical), nullptr, nullptr },
        { "max_physical", reinterpret_cast<getter>(PointerDeviceUsage_get_MaxPhysical), reinterpret_cast<setter>(PointerDeviceUsage_set_MaxPhysical), nullptr, nullptr },
        { "unit", reinterpret_cast<getter>(PointerDeviceUsage_get_Unit), reinterpret_cast<setter>(PointerDeviceUsage_set_Unit), nullptr, nullptr },
        { "physical_multiplier", reinterpret_cast<getter>(PointerDeviceUsage_get_PhysicalMultiplier), reinterpret_cast<setter>(PointerDeviceUsage_set_PhysicalMultiplier), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PointerDeviceUsage[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PointerDeviceUsage) },
        { Py_tp_init, reinterpret_cast<void*>(_init_PointerDeviceUsage) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PointerDeviceUsage) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PointerDeviceUsage) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PointerDeviceUsage) },
        { },
    };

    static PyType_Spec type_spec_PointerDeviceUsage =
    {
        "winrt._winrt_windows_devices_input.PointerDeviceUsage",
        sizeof(py::wrapper::Windows::Devices::Input::PointerDeviceUsage),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PointerDeviceUsage
    };

    // ----- Windows.Devices.Input Initialization --------------------
    PyDoc_STRVAR(module_doc, "Windows::Devices::Input");


    static PyModuleDef module_def
        = {PyModuleDef_HEAD_INIT,
           "_winrt_windows_devices_input",
           module_doc,
           0,
           nullptr,
           nullptr,
           nullptr,
           nullptr,
           nullptr};

} // py::cpp::Windows::Devices::Input

PyMODINIT_FUNC PyInit__winrt_windows_devices_input(void) noexcept
{
    using namespace py::cpp::Windows::Devices::Input;

    if (py::import_winrt_runtime() == -1)
    {
        return nullptr;
    }

    py::pyobj_handle module{PyModule_Create(&module_def)};

    if (!module)
    {
        return nullptr;
    }

    auto object_type = py::get_object_type();
    if (!object_type)
    {
        return nullptr;
    }

    py::pyobj_handle object_bases{PyTuple_Pack(1, object_type)};

    if (!object_bases)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_KeyboardCapabilities, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_MouseCapabilities, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_MouseDevice_Static{PyType_FromSpec(&type_spec_MouseDevice_Static)};
    if (!type_MouseDevice_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_MouseDevice, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_MouseDevice_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_MouseEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_PenButtonListener_Static{PyType_FromSpec(&type_spec_PenButtonListener_Static)};
    if (!type_PenButtonListener_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_PenButtonListener, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_PenButtonListener_Static.get())) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_PenDevice_Static{PyType_FromSpec(&type_spec_PenDevice_Static)};
    if (!type_PenDevice_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_PenDevice, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_PenDevice_Static.get())) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_PenDockListener_Static{PyType_FromSpec(&type_spec_PenDockListener_Static)};
    if (!type_PenDockListener_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_PenDockListener, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_PenDockListener_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_PenDockedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_PenTailButtonClickedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_PenTailButtonDoubleClickedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_PenTailButtonLongPressedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_PenUndockedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_PointerDevice_Static{PyType_FromSpec(&type_spec_PointerDevice_Static)};
    if (!type_PointerDevice_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_PointerDevice, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_PointerDevice_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_TouchCapabilities, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_MouseDelta, nullptr, nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_PointerDeviceUsage, nullptr, nullptr) == -1)
    {
        return nullptr;
    }


    return module.detach();
}
