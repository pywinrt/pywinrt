// WARNING: Please don't edit this file. It was generated by Python/WinRT v0.0.0

#include "py.Microsoft.UI.Xaml.Markup.h"

namespace py::cpp::Microsoft::UI::Xaml::Markup
{
    // ----- MarkupExtension class --------------------

    struct PyWinrtMarkupExtension;
    using BasePyWinrtMarkupExtension = winrt::Microsoft::UI::Xaml::Markup::MarkupExtensionT<PyWinrtMarkupExtension, py::IPywinrtObject>;

    struct PyWinrtMarkupExtension : py::py_obj_ref, BasePyWinrtMarkupExtension
    {
        PyWinrtMarkupExtension(PyObject* py_obj) : py::py_obj_ref(py_obj), BasePyWinrtMarkupExtension() {}

        int32_t __stdcall GetPyObject(PyObject*& obj) override
        {
            obj = py::py_obj_ref::get_py_obj();
            return 0;
        }

        int32_t __stdcall GetComposableInner(winrt::Windows::Foundation::IInspectable& inner) override
        {
            inner = m_inner;
            return winrt::impl::error_ok;
        }

        static void toggle_reference(PyWinrtMarkupExtension* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }

        int32_t query_interface_tearoff(winrt::guid const& id, void** result) const noexcept override
        {
            return py::py_obj_ref::query_interface_tearoff(id, result);
        }

        std::vector<winrt::guid> get_iids_tearoff() const noexcept override
        {
            return py::py_obj_ref::get_iids_tearoff();
        }

        winrt::Windows::Foundation::IInspectable ProvideValue()
        {
            auto gil = py::ensure_gil();

            try
            {
                py::pyobj_handle self{get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "_provide_value")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallNoArgs(method.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Foundation::IInspectable>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        winrt::Windows::Foundation::IInspectable ProvideValue(winrt::Microsoft::UI::Xaml::IXamlServiceProvider const& param0)
        {
            auto gil = py::ensure_gil();

            try
            {
                py::pyobj_handle self{get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "_provide_value_with_ixaml_service_provider")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallOneArg(method.get(), py_param0.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Foundation::IInspectable>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }
    };

    static PyObject* _new_MarkupExtension(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);

        auto self_type = get_python_type_for<winrt::Microsoft::UI::Xaml::Markup::MarkupExtension>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 0)
        {
            try
            {
                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj, nullptr);

                    auto obj_impl = winrt::make_self<PyWinrtMarkupExtension>(self.get());

                    auto obj = py::make_py_obj<PyWinrtMarkupExtension>(obj_impl, type, self.get());
                    if (!obj)
                    {
                        return nullptr;
                    }

                    reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj = std::move(obj);

                    return self.detach();
                }

                winrt::Microsoft::UI::Xaml::Markup::MarkupExtension instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MarkupExtension(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MarkupExtension_ProvideValue(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Markup.MarkupExtension", L"ProvideValue", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return py::get_inner_or_self(self->obj).try_as<winrt::Microsoft::UI::Xaml::Markup::IMarkupExtensionOverrides>().ProvideValue();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MarkupExtension_ProvideValueWithIXamlServiceProvider(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Markup.MarkupExtension", L"ProvideValue", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::IXamlServiceProvider>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return py::get_inner_or_self(self->obj).try_as<winrt::Microsoft::UI::Xaml::Markup::IMarkupExtensionOverrides>().ProvideValue(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_MarkupExtension(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Markup::MarkupExtension>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MarkupExtension(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Markup::MarkupExtension>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MarkupExtension[] = {
        { "_provide_value", reinterpret_cast<PyCFunction>(MarkupExtension_ProvideValue), METH_VARARGS, nullptr },
        { "_provide_value_with_ixaml_service_provider", reinterpret_cast<PyCFunction>(MarkupExtension_ProvideValueWithIXamlServiceProvider), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_MarkupExtension, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MarkupExtension), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_MarkupExtension[] = {
        { }};

    static PyType_Slot _type_slots_MarkupExtension[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_MarkupExtension) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MarkupExtension) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MarkupExtension) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MarkupExtension) },
        { }};

    static PyType_Spec type_spec_MarkupExtension = {
        "winrt._winrt_microsoft_ui_xaml_markup.MarkupExtension",
        sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_MarkupExtension};

    static PyGetSetDef getset_MarkupExtension_Static[] = {
        { }};

    static PyMethodDef methods_MarkupExtension_Static[] = {
        { }};

    static PyType_Slot type_slots_MarkupExtension_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_MarkupExtension_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_MarkupExtension_Static) },
        { }
    };

    static PyType_Spec type_spec_MarkupExtension_Static = {
        "winrt._winrt_microsoft_ui_xaml_markup.MarkupExtension_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_MarkupExtension_Static};

    // ----- ProvideValueTargetProperty class --------------------

    static PyObject* _new_ProvideValueTargetProperty(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Microsoft::UI::Xaml::Markup::ProvideValueTargetProperty instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ProvideValueTargetProperty(py::wrapper::Microsoft::UI::Xaml::Markup::ProvideValueTargetProperty* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ProvideValueTargetProperty_get_DeclaringType(py::wrapper::Microsoft::UI::Xaml::Markup::ProvideValueTargetProperty* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Markup.ProvideValueTargetProperty", L"DeclaringType");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.DeclaringType();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProvideValueTargetProperty_get_Name(py::wrapper::Microsoft::UI::Xaml::Markup::ProvideValueTargetProperty* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Markup.ProvideValueTargetProperty", L"Name");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Name();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProvideValueTargetProperty_get_Type(py::wrapper::Microsoft::UI::Xaml::Markup::ProvideValueTargetProperty* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Markup.ProvideValueTargetProperty", L"Type");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Type();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ProvideValueTargetProperty(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Markup::ProvideValueTargetProperty>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ProvideValueTargetProperty(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Markup::ProvideValueTargetProperty>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ProvideValueTargetProperty[] = {
        { "_assign_array_", _assign_array_ProvideValueTargetProperty, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ProvideValueTargetProperty), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_ProvideValueTargetProperty[] = {
        { "declaring_type", reinterpret_cast<getter>(ProvideValueTargetProperty_get_DeclaringType), nullptr, nullptr, nullptr },
        { "name", reinterpret_cast<getter>(ProvideValueTargetProperty_get_Name), nullptr, nullptr, nullptr },
        { "type", reinterpret_cast<getter>(ProvideValueTargetProperty_get_Type), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_ProvideValueTargetProperty[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ProvideValueTargetProperty) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ProvideValueTargetProperty) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ProvideValueTargetProperty) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ProvideValueTargetProperty) },
        { }};

    static PyType_Spec type_spec_ProvideValueTargetProperty = {
        "winrt._winrt_microsoft_ui_xaml_markup.ProvideValueTargetProperty",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Markup::ProvideValueTargetProperty),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ProvideValueTargetProperty};

    // ----- XamlBinaryWriter class --------------------

    static PyObject* _new_XamlBinaryWriter(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Markup::XamlBinaryWriter>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Markup::XamlBinaryWriter>::type_name);
        return nullptr;
    }

    static void _dealloc_XamlBinaryWriter(py::wrapper::Microsoft::UI::Xaml::Markup::XamlBinaryWriter* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* XamlBinaryWriter_Write(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Markup.XamlBinaryWriter", L"Write", 3);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IVector<winrt::Windows::Storage::Streams::IRandomAccessStream>>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IVector<winrt::Windows::Storage::Streams::IRandomAccessStream>>(args, 1);
                auto param2 = py::convert_to<winrt::Microsoft::UI::Xaml::Markup::IXamlMetadataProvider>(args, 2);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Microsoft::UI::Xaml::Markup::XamlBinaryWriter::Write(param0, param1, param2);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_XamlBinaryWriter(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Markup::XamlBinaryWriter>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_XamlBinaryWriter(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Markup::XamlBinaryWriter>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_XamlBinaryWriter[] = {
        { "_assign_array_", _assign_array_XamlBinaryWriter, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_XamlBinaryWriter), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_XamlBinaryWriter[] = {
        { }};

    static PyType_Slot _type_slots_XamlBinaryWriter[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_XamlBinaryWriter) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_XamlBinaryWriter) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_XamlBinaryWriter) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_XamlBinaryWriter) },
        { }};

    static PyType_Spec type_spec_XamlBinaryWriter = {
        "winrt._winrt_microsoft_ui_xaml_markup.XamlBinaryWriter",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Markup::XamlBinaryWriter),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_XamlBinaryWriter};

    static PyGetSetDef getset_XamlBinaryWriter_Static[] = {
        { }};

    static PyMethodDef methods_XamlBinaryWriter_Static[] = {
        { "write", reinterpret_cast<PyCFunction>(XamlBinaryWriter_Write), METH_VARARGS, nullptr },
        { }};

    static PyType_Slot type_slots_XamlBinaryWriter_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_XamlBinaryWriter_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_XamlBinaryWriter_Static) },
        { }
    };

    static PyType_Spec type_spec_XamlBinaryWriter_Static = {
        "winrt._winrt_microsoft_ui_xaml_markup.XamlBinaryWriter_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_XamlBinaryWriter_Static};

    // ----- XamlBindingHelper class --------------------

    static PyObject* _new_XamlBindingHelper(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Markup::XamlBindingHelper>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Markup::XamlBindingHelper>::type_name);
        return nullptr;
    }

    static void _dealloc_XamlBindingHelper(py::wrapper::Microsoft::UI::Xaml::Markup::XamlBindingHelper* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* XamlBindingHelper_ConvertValue(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Markup.XamlBindingHelper", L"ConvertValue", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Interop::TypeName>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 1);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Microsoft::UI::Xaml::Markup::XamlBindingHelper::ConvertValue(param0, param1);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* XamlBindingHelper_GetDataTemplateComponent(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Markup.XamlBindingHelper", L"GetDataTemplateComponent", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Microsoft::UI::Xaml::Markup::XamlBindingHelper::GetDataTemplateComponent(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* XamlBindingHelper_ResumeRendering(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Markup.XamlBindingHelper", L"ResumeRendering", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::UIElement>(args, 0);

                {
                    auto _gil = release_gil();
                    winrt::Microsoft::UI::Xaml::Markup::XamlBindingHelper::ResumeRendering(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* XamlBindingHelper_SetDataTemplateComponent(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Markup.XamlBindingHelper", L"SetDataTemplateComponent", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::UI::Xaml::Markup::IDataTemplateComponent>(args, 1);

                {
                    auto _gil = release_gil();
                    winrt::Microsoft::UI::Xaml::Markup::XamlBindingHelper::SetDataTemplateComponent(param0, param1);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* XamlBindingHelper_SetPropertyFromBoolean(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Markup.XamlBindingHelper", L"SetPropertyFromBoolean", 3);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyProperty>(args, 1);
                auto param2 = py::convert_to<bool>(args, 2);

                {
                    auto _gil = release_gil();
                    winrt::Microsoft::UI::Xaml::Markup::XamlBindingHelper::SetPropertyFromBoolean(param0, param1, param2);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* XamlBindingHelper_SetPropertyFromByte(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Markup.XamlBindingHelper", L"SetPropertyFromByte", 3);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyProperty>(args, 1);
                auto param2 = py::convert_to<uint8_t>(args, 2);

                {
                    auto _gil = release_gil();
                    winrt::Microsoft::UI::Xaml::Markup::XamlBindingHelper::SetPropertyFromByte(param0, param1, param2);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* XamlBindingHelper_SetPropertyFromChar16(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Markup.XamlBindingHelper", L"SetPropertyFromChar16", 3);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyProperty>(args, 1);
                auto param2 = py::convert_to<char16_t>(args, 2);

                {
                    auto _gil = release_gil();
                    winrt::Microsoft::UI::Xaml::Markup::XamlBindingHelper::SetPropertyFromChar16(param0, param1, param2);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* XamlBindingHelper_SetPropertyFromDateTime(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Markup.XamlBindingHelper", L"SetPropertyFromDateTime", 3);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyProperty>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::DateTime>(args, 2);

                {
                    auto _gil = release_gil();
                    winrt::Microsoft::UI::Xaml::Markup::XamlBindingHelper::SetPropertyFromDateTime(param0, param1, param2);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* XamlBindingHelper_SetPropertyFromDouble(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Markup.XamlBindingHelper", L"SetPropertyFromDouble", 3);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyProperty>(args, 1);
                auto param2 = py::convert_to<double>(args, 2);

                {
                    auto _gil = release_gil();
                    winrt::Microsoft::UI::Xaml::Markup::XamlBindingHelper::SetPropertyFromDouble(param0, param1, param2);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* XamlBindingHelper_SetPropertyFromInt32(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Markup.XamlBindingHelper", L"SetPropertyFromInt32", 3);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyProperty>(args, 1);
                auto param2 = py::convert_to<int32_t>(args, 2);

                {
                    auto _gil = release_gil();
                    winrt::Microsoft::UI::Xaml::Markup::XamlBindingHelper::SetPropertyFromInt32(param0, param1, param2);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* XamlBindingHelper_SetPropertyFromInt64(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Markup.XamlBindingHelper", L"SetPropertyFromInt64", 3);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyProperty>(args, 1);
                auto param2 = py::convert_to<int64_t>(args, 2);

                {
                    auto _gil = release_gil();
                    winrt::Microsoft::UI::Xaml::Markup::XamlBindingHelper::SetPropertyFromInt64(param0, param1, param2);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* XamlBindingHelper_SetPropertyFromObject(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Markup.XamlBindingHelper", L"SetPropertyFromObject", 3);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyProperty>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 2);

                {
                    auto _gil = release_gil();
                    winrt::Microsoft::UI::Xaml::Markup::XamlBindingHelper::SetPropertyFromObject(param0, param1, param2);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* XamlBindingHelper_SetPropertyFromPoint(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Markup.XamlBindingHelper", L"SetPropertyFromPoint", 3);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyProperty>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Point>(args, 2);

                {
                    auto _gil = release_gil();
                    winrt::Microsoft::UI::Xaml::Markup::XamlBindingHelper::SetPropertyFromPoint(param0, param1, param2);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* XamlBindingHelper_SetPropertyFromRect(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Markup.XamlBindingHelper", L"SetPropertyFromRect", 3);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyProperty>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Rect>(args, 2);

                {
                    auto _gil = release_gil();
                    winrt::Microsoft::UI::Xaml::Markup::XamlBindingHelper::SetPropertyFromRect(param0, param1, param2);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* XamlBindingHelper_SetPropertyFromSingle(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Markup.XamlBindingHelper", L"SetPropertyFromSingle", 3);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyProperty>(args, 1);
                auto param2 = py::convert_to<float>(args, 2);

                {
                    auto _gil = release_gil();
                    winrt::Microsoft::UI::Xaml::Markup::XamlBindingHelper::SetPropertyFromSingle(param0, param1, param2);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* XamlBindingHelper_SetPropertyFromSize(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Markup.XamlBindingHelper", L"SetPropertyFromSize", 3);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyProperty>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Size>(args, 2);

                {
                    auto _gil = release_gil();
                    winrt::Microsoft::UI::Xaml::Markup::XamlBindingHelper::SetPropertyFromSize(param0, param1, param2);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* XamlBindingHelper_SetPropertyFromString(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Markup.XamlBindingHelper", L"SetPropertyFromString", 3);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyProperty>(args, 1);
                auto param2 = py::convert_to<winrt::hstring>(args, 2);

                {
                    auto _gil = release_gil();
                    winrt::Microsoft::UI::Xaml::Markup::XamlBindingHelper::SetPropertyFromString(param0, param1, param2);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* XamlBindingHelper_SetPropertyFromTimeSpan(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Markup.XamlBindingHelper", L"SetPropertyFromTimeSpan", 3);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyProperty>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(args, 2);

                {
                    auto _gil = release_gil();
                    winrt::Microsoft::UI::Xaml::Markup::XamlBindingHelper::SetPropertyFromTimeSpan(param0, param1, param2);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* XamlBindingHelper_SetPropertyFromUInt32(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Markup.XamlBindingHelper", L"SetPropertyFromUInt32", 3);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyProperty>(args, 1);
                auto param2 = py::convert_to<uint32_t>(args, 2);

                {
                    auto _gil = release_gil();
                    winrt::Microsoft::UI::Xaml::Markup::XamlBindingHelper::SetPropertyFromUInt32(param0, param1, param2);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* XamlBindingHelper_SetPropertyFromUInt64(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Markup.XamlBindingHelper", L"SetPropertyFromUInt64", 3);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyProperty>(args, 1);
                auto param2 = py::convert_to<uint64_t>(args, 2);

                {
                    auto _gil = release_gil();
                    winrt::Microsoft::UI::Xaml::Markup::XamlBindingHelper::SetPropertyFromUInt64(param0, param1, param2);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* XamlBindingHelper_SetPropertyFromUri(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Markup.XamlBindingHelper", L"SetPropertyFromUri", 3);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyProperty>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 2);

                {
                    auto _gil = release_gil();
                    winrt::Microsoft::UI::Xaml::Markup::XamlBindingHelper::SetPropertyFromUri(param0, param1, param2);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* XamlBindingHelper_SuspendRendering(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Markup.XamlBindingHelper", L"SuspendRendering", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::UIElement>(args, 0);

                {
                    auto _gil = release_gil();
                    winrt::Microsoft::UI::Xaml::Markup::XamlBindingHelper::SuspendRendering(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* XamlBindingHelper_get_DataTemplateComponentProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Markup.XamlBindingHelper", L"DataTemplateComponentProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Markup::XamlBindingHelper::DataTemplateComponentProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_XamlBindingHelper(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Markup::XamlBindingHelper>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_XamlBindingHelper(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Markup::XamlBindingHelper>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_XamlBindingHelper[] = {
        { "_assign_array_", _assign_array_XamlBindingHelper, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_XamlBindingHelper), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_XamlBindingHelper[] = {
        { }};

    static PyType_Slot _type_slots_XamlBindingHelper[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_XamlBindingHelper) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_XamlBindingHelper) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_XamlBindingHelper) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_XamlBindingHelper) },
        { }};

    static PyType_Spec type_spec_XamlBindingHelper = {
        "winrt._winrt_microsoft_ui_xaml_markup.XamlBindingHelper",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Markup::XamlBindingHelper),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_XamlBindingHelper};

    static PyGetSetDef getset_XamlBindingHelper_Static[] = {
        { "data_template_component_property", reinterpret_cast<getter>(XamlBindingHelper_get_DataTemplateComponentProperty), nullptr, nullptr, nullptr },
        { }};

    static PyMethodDef methods_XamlBindingHelper_Static[] = {
        { "convert_value", reinterpret_cast<PyCFunction>(XamlBindingHelper_ConvertValue), METH_VARARGS, nullptr },
        { "get_data_template_component", reinterpret_cast<PyCFunction>(XamlBindingHelper_GetDataTemplateComponent), METH_VARARGS, nullptr },
        { "resume_rendering", reinterpret_cast<PyCFunction>(XamlBindingHelper_ResumeRendering), METH_VARARGS, nullptr },
        { "set_data_template_component", reinterpret_cast<PyCFunction>(XamlBindingHelper_SetDataTemplateComponent), METH_VARARGS, nullptr },
        { "set_property_from_boolean", reinterpret_cast<PyCFunction>(XamlBindingHelper_SetPropertyFromBoolean), METH_VARARGS, nullptr },
        { "set_property_from_byte", reinterpret_cast<PyCFunction>(XamlBindingHelper_SetPropertyFromByte), METH_VARARGS, nullptr },
        { "set_property_from_char16", reinterpret_cast<PyCFunction>(XamlBindingHelper_SetPropertyFromChar16), METH_VARARGS, nullptr },
        { "set_property_from_date_time", reinterpret_cast<PyCFunction>(XamlBindingHelper_SetPropertyFromDateTime), METH_VARARGS, nullptr },
        { "set_property_from_double", reinterpret_cast<PyCFunction>(XamlBindingHelper_SetPropertyFromDouble), METH_VARARGS, nullptr },
        { "set_property_from_int32", reinterpret_cast<PyCFunction>(XamlBindingHelper_SetPropertyFromInt32), METH_VARARGS, nullptr },
        { "set_property_from_int64", reinterpret_cast<PyCFunction>(XamlBindingHelper_SetPropertyFromInt64), METH_VARARGS, nullptr },
        { "set_property_from_object", reinterpret_cast<PyCFunction>(XamlBindingHelper_SetPropertyFromObject), METH_VARARGS, nullptr },
        { "set_property_from_point", reinterpret_cast<PyCFunction>(XamlBindingHelper_SetPropertyFromPoint), METH_VARARGS, nullptr },
        { "set_property_from_rect", reinterpret_cast<PyCFunction>(XamlBindingHelper_SetPropertyFromRect), METH_VARARGS, nullptr },
        { "set_property_from_single", reinterpret_cast<PyCFunction>(XamlBindingHelper_SetPropertyFromSingle), METH_VARARGS, nullptr },
        { "set_property_from_size", reinterpret_cast<PyCFunction>(XamlBindingHelper_SetPropertyFromSize), METH_VARARGS, nullptr },
        { "set_property_from_string", reinterpret_cast<PyCFunction>(XamlBindingHelper_SetPropertyFromString), METH_VARARGS, nullptr },
        { "set_property_from_time_span", reinterpret_cast<PyCFunction>(XamlBindingHelper_SetPropertyFromTimeSpan), METH_VARARGS, nullptr },
        { "set_property_from_uint32", reinterpret_cast<PyCFunction>(XamlBindingHelper_SetPropertyFromUInt32), METH_VARARGS, nullptr },
        { "set_property_from_uint64", reinterpret_cast<PyCFunction>(XamlBindingHelper_SetPropertyFromUInt64), METH_VARARGS, nullptr },
        { "set_property_from_uri", reinterpret_cast<PyCFunction>(XamlBindingHelper_SetPropertyFromUri), METH_VARARGS, nullptr },
        { "suspend_rendering", reinterpret_cast<PyCFunction>(XamlBindingHelper_SuspendRendering), METH_VARARGS, nullptr },
        { }};

    static PyType_Slot type_slots_XamlBindingHelper_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_XamlBindingHelper_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_XamlBindingHelper_Static) },
        { }
    };

    static PyType_Spec type_spec_XamlBindingHelper_Static = {
        "winrt._winrt_microsoft_ui_xaml_markup.XamlBindingHelper_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_XamlBindingHelper_Static};

    // ----- XamlMarkupHelper class --------------------

    static PyObject* _new_XamlMarkupHelper(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Markup::XamlMarkupHelper>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Markup::XamlMarkupHelper>::type_name);
        return nullptr;
    }

    static void _dealloc_XamlMarkupHelper(py::wrapper::Microsoft::UI::Xaml::Markup::XamlMarkupHelper* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* XamlMarkupHelper_UnloadObject(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Markup.XamlMarkupHelper", L"UnloadObject", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(args, 0);

                {
                    auto _gil = release_gil();
                    winrt::Microsoft::UI::Xaml::Markup::XamlMarkupHelper::UnloadObject(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_XamlMarkupHelper(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Markup::XamlMarkupHelper>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_XamlMarkupHelper(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Markup::XamlMarkupHelper>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_XamlMarkupHelper[] = {
        { "_assign_array_", _assign_array_XamlMarkupHelper, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_XamlMarkupHelper), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_XamlMarkupHelper[] = {
        { }};

    static PyType_Slot _type_slots_XamlMarkupHelper[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_XamlMarkupHelper) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_XamlMarkupHelper) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_XamlMarkupHelper) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_XamlMarkupHelper) },
        { }};

    static PyType_Spec type_spec_XamlMarkupHelper = {
        "winrt._winrt_microsoft_ui_xaml_markup.XamlMarkupHelper",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Markup::XamlMarkupHelper),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_XamlMarkupHelper};

    static PyGetSetDef getset_XamlMarkupHelper_Static[] = {
        { }};

    static PyMethodDef methods_XamlMarkupHelper_Static[] = {
        { "unload_object", reinterpret_cast<PyCFunction>(XamlMarkupHelper_UnloadObject), METH_VARARGS, nullptr },
        { }};

    static PyType_Slot type_slots_XamlMarkupHelper_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_XamlMarkupHelper_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_XamlMarkupHelper_Static) },
        { }
    };

    static PyType_Spec type_spec_XamlMarkupHelper_Static = {
        "winrt._winrt_microsoft_ui_xaml_markup.XamlMarkupHelper_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_XamlMarkupHelper_Static};

    // ----- XamlReader class --------------------

    static PyObject* _new_XamlReader(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Markup::XamlReader>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Markup::XamlReader>::type_name);
        return nullptr;
    }

    static void _dealloc_XamlReader(py::wrapper::Microsoft::UI::Xaml::Markup::XamlReader* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* XamlReader_Load(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Markup.XamlReader", L"Load", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Microsoft::UI::Xaml::Markup::XamlReader::Load(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* XamlReader_LoadWithInitialTemplateValidation(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Markup.XamlReader", L"LoadWithInitialTemplateValidation", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Microsoft::UI::Xaml::Markup::XamlReader::LoadWithInitialTemplateValidation(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_XamlReader(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Markup::XamlReader>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_XamlReader(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Markup::XamlReader>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_XamlReader[] = {
        { "_assign_array_", _assign_array_XamlReader, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_XamlReader), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_XamlReader[] = {
        { }};

    static PyType_Slot _type_slots_XamlReader[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_XamlReader) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_XamlReader) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_XamlReader) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_XamlReader) },
        { }};

    static PyType_Spec type_spec_XamlReader = {
        "winrt._winrt_microsoft_ui_xaml_markup.XamlReader",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Markup::XamlReader),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_XamlReader};

    static PyGetSetDef getset_XamlReader_Static[] = {
        { }};

    static PyMethodDef methods_XamlReader_Static[] = {
        { "load", reinterpret_cast<PyCFunction>(XamlReader_Load), METH_VARARGS, nullptr },
        { "load_with_initial_template_validation", reinterpret_cast<PyCFunction>(XamlReader_LoadWithInitialTemplateValidation), METH_VARARGS, nullptr },
        { }};

    static PyType_Slot type_slots_XamlReader_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_XamlReader_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_XamlReader_Static) },
        { }
    };

    static PyType_Spec type_spec_XamlReader_Static = {
        "winrt._winrt_microsoft_ui_xaml_markup.XamlReader_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_XamlReader_Static};

    // ----- IComponentConnector interface --------------------

    static PyObject* _new_IComponentConnector(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Markup::IComponentConnector>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Markup::IComponentConnector>::type_name);
        return nullptr;
    }

    static void _dealloc_IComponentConnector(py::wrapper::Microsoft::UI::Xaml::Markup::IComponentConnector* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IComponentConnector_Connect(py::wrapper::Microsoft::UI::Xaml::Markup::IComponentConnector* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Markup.IComponentConnector", L"Connect", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<int32_t>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 1);

                {
                    auto _gil = release_gil();
                    self->obj.Connect(param0, param1);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IComponentConnector_GetBindingConnector(py::wrapper::Microsoft::UI::Xaml::Markup::IComponentConnector* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Markup.IComponentConnector", L"GetBindingConnector", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<int32_t>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 1);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetBindingConnector(param0, param1);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyMethodDef _methods_IComponentConnector[] = {
        { "connect", reinterpret_cast<PyCFunction>(IComponentConnector_Connect), METH_VARARGS, nullptr },
        { "get_binding_connector", reinterpret_cast<PyCFunction>(IComponentConnector_GetBindingConnector), METH_VARARGS, nullptr },
        { }};

    static PyGetSetDef _getset_IComponentConnector[] = {
        { }};

    static PyType_Slot _type_slots_IComponentConnector[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_IComponentConnector) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IComponentConnector) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IComponentConnector) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IComponentConnector) },
        { }};

    static PyType_Spec type_spec_IComponentConnector = {
        "winrt._winrt_microsoft_ui_xaml_markup._IComponentConnector",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Markup::IComponentConnector),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IComponentConnector};

    struct ImplementsIComponentConnector : py::ImplementsInterfaceT<ImplementsIComponentConnector, winrt::Microsoft::UI::Xaml::Markup::IComponentConnector>
    {
        ImplementsIComponentConnector() = delete;
        ImplementsIComponentConnector(PyObject* py_obj, winrt::impl::inspectable_abi* runtime_class) : py::ImplementsInterfaceT<ImplementsIComponentConnector, winrt::Microsoft::UI::Xaml::Markup::IComponentConnector>(py_obj, runtime_class)
        {
        }

        auto Connect(int32_t param0, winrt::Windows::Foundation::IInspectable const& param1)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "connect")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param1{py::convert(param1)};
                if (!py_param1)
                {
                    throw python_exception();
                }

                py::pyobj_handle args{PyTuple_Pack(2, py_param0.get(), py_param1.get())};
                if (!args)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallObject(method.get(), args.get())};
                if (!return_value)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto GetBindingConnector(int32_t param0, winrt::Windows::Foundation::IInspectable const& param1)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "get_binding_connector")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param1{py::convert(param1)};
                if (!py_param1)
                {
                    throw python_exception();
                }

                py::pyobj_handle args{PyTuple_Pack(2, py_param0.get(), py_param1.get())};
                if (!args)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallObject(method.get(), args.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Microsoft::UI::Xaml::Markup::IComponentConnector>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }
    };

    static PyObject* _assign_array_IComponentConnector(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Markup::IComponentConnector>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IComponentConnector(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Markup::IComponentConnector>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _guid_ImplementsIComponentConnector(PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::guid_of<winrt::Microsoft::UI::Xaml::Markup::IComponentConnector>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _make_ImplementsIComponentConnector(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            PyObject* py_obj;
            winrt::impl::inspectable_abi* runtime_class;

            if (!PyArg_ParseTuple(args, "On", &py_obj, &runtime_class))
            {
                return nullptr;
            }

            auto iface{std::make_unique<ImplementsIComponentConnector>(py_obj, runtime_class)};

            return PyLong_FromVoidPtr(iface.release());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef methods_ImplementsIComponentConnector[] = {
        { "_assign_array_", _assign_array_IComponentConnector, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IComponentConnector), METH_O | METH_STATIC, nullptr },
        { "_guid_", reinterpret_cast<PyCFunction>(_guid_ImplementsIComponentConnector), METH_NOARGS | METH_STATIC, nullptr },
        { "_make_", reinterpret_cast<PyCFunction>(_make_ImplementsIComponentConnector), METH_VARARGS | METH_STATIC, nullptr },
        { }};

    static PyType_Slot type_slots_ImplementsIComponentConnector[] = {
        { Py_tp_methods, reinterpret_cast<void*>(methods_ImplementsIComponentConnector) },
        { }};

    static PyType_Spec type_spec_ImplementsIComponentConnector = {
        "winrt._winrt_microsoft_ui_xaml_markup.IComponentConnector",
        0,
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_ImplementsIComponentConnector};

    // ----- IDataTemplateComponent interface --------------------

    static PyObject* _new_IDataTemplateComponent(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Markup::IDataTemplateComponent>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Markup::IDataTemplateComponent>::type_name);
        return nullptr;
    }

    static void _dealloc_IDataTemplateComponent(py::wrapper::Microsoft::UI::Xaml::Markup::IDataTemplateComponent* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IDataTemplateComponent_ProcessBindings(py::wrapper::Microsoft::UI::Xaml::Markup::IDataTemplateComponent* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Markup.IDataTemplateComponent", L"ProcessBindings", 3);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 0);
                auto param1 = py::convert_to<int32_t>(args, 1);
                auto param2 = py::convert_to<int32_t>(args, 2);
                int32_t param3{};

                {
                    auto _gil = release_gil();
                    self->obj.ProcessBindings(param0, param1, param2, param3);
                }

                py::pyobj_handle out3{ py::convert(param3) };
                if (!out3)
                {
                    return nullptr;
                }

                return out3.detach();
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IDataTemplateComponent_Recycle(py::wrapper::Microsoft::UI::Xaml::Markup::IDataTemplateComponent* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Markup.IDataTemplateComponent", L"Recycle", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.Recycle();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyMethodDef _methods_IDataTemplateComponent[] = {
        { "process_bindings", reinterpret_cast<PyCFunction>(IDataTemplateComponent_ProcessBindings), METH_VARARGS, nullptr },
        { "recycle", reinterpret_cast<PyCFunction>(IDataTemplateComponent_Recycle), METH_VARARGS, nullptr },
        { }};

    static PyGetSetDef _getset_IDataTemplateComponent[] = {
        { }};

    static PyType_Slot _type_slots_IDataTemplateComponent[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_IDataTemplateComponent) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IDataTemplateComponent) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IDataTemplateComponent) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IDataTemplateComponent) },
        { }};

    static PyType_Spec type_spec_IDataTemplateComponent = {
        "winrt._winrt_microsoft_ui_xaml_markup._IDataTemplateComponent",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Markup::IDataTemplateComponent),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IDataTemplateComponent};

    struct ImplementsIDataTemplateComponent : py::ImplementsInterfaceT<ImplementsIDataTemplateComponent, winrt::Microsoft::UI::Xaml::Markup::IDataTemplateComponent>
    {
        ImplementsIDataTemplateComponent() = delete;
        ImplementsIDataTemplateComponent(PyObject* py_obj, winrt::impl::inspectable_abi* runtime_class) : py::ImplementsInterfaceT<ImplementsIDataTemplateComponent, winrt::Microsoft::UI::Xaml::Markup::IDataTemplateComponent>(py_obj, runtime_class)
        {
        }

        auto ProcessBindings(winrt::Windows::Foundation::IInspectable const& param0, int32_t param1, int32_t param2, int32_t& param3)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "process_bindings")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param1{py::convert(param1)};
                if (!py_param1)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param2{py::convert(param2)};
                if (!py_param2)
                {
                    throw python_exception();
                }

                py::pyobj_handle args{PyTuple_Pack(3, py_param0.get(), py_param1.get(), py_param2.get())};
                if (!args)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallObject(method.get(), args.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                param3 = py::convert_to<int32_t>(return_value.get(), 0);
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto Recycle()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "recycle")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallNoArgs(method.get())};
                if (!return_value)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }
    };

    static PyObject* _assign_array_IDataTemplateComponent(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Markup::IDataTemplateComponent>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IDataTemplateComponent(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Markup::IDataTemplateComponent>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _guid_ImplementsIDataTemplateComponent(PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::guid_of<winrt::Microsoft::UI::Xaml::Markup::IDataTemplateComponent>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _make_ImplementsIDataTemplateComponent(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            PyObject* py_obj;
            winrt::impl::inspectable_abi* runtime_class;

            if (!PyArg_ParseTuple(args, "On", &py_obj, &runtime_class))
            {
                return nullptr;
            }

            auto iface{std::make_unique<ImplementsIDataTemplateComponent>(py_obj, runtime_class)};

            return PyLong_FromVoidPtr(iface.release());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef methods_ImplementsIDataTemplateComponent[] = {
        { "_assign_array_", _assign_array_IDataTemplateComponent, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IDataTemplateComponent), METH_O | METH_STATIC, nullptr },
        { "_guid_", reinterpret_cast<PyCFunction>(_guid_ImplementsIDataTemplateComponent), METH_NOARGS | METH_STATIC, nullptr },
        { "_make_", reinterpret_cast<PyCFunction>(_make_ImplementsIDataTemplateComponent), METH_VARARGS | METH_STATIC, nullptr },
        { }};

    static PyType_Slot type_slots_ImplementsIDataTemplateComponent[] = {
        { Py_tp_methods, reinterpret_cast<void*>(methods_ImplementsIDataTemplateComponent) },
        { }};

    static PyType_Spec type_spec_ImplementsIDataTemplateComponent = {
        "winrt._winrt_microsoft_ui_xaml_markup.IDataTemplateComponent",
        0,
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_ImplementsIDataTemplateComponent};

    // ----- IProvideValueTarget interface --------------------

    static PyObject* _new_IProvideValueTarget(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Markup::IProvideValueTarget>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Markup::IProvideValueTarget>::type_name);
        return nullptr;
    }

    static void _dealloc_IProvideValueTarget(py::wrapper::Microsoft::UI::Xaml::Markup::IProvideValueTarget* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IProvideValueTarget_get_TargetObject(py::wrapper::Microsoft::UI::Xaml::Markup::IProvideValueTarget* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Markup.IProvideValueTarget", L"TargetObject");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.TargetObject();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IProvideValueTarget_get_TargetProperty(py::wrapper::Microsoft::UI::Xaml::Markup::IProvideValueTarget* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Markup.IProvideValueTarget", L"TargetProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.TargetProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IProvideValueTarget[] = {
        { }};

    static PyGetSetDef _getset_IProvideValueTarget[] = {
        { "target_object", reinterpret_cast<getter>(IProvideValueTarget_get_TargetObject), nullptr, nullptr, nullptr },
        { "target_property", reinterpret_cast<getter>(IProvideValueTarget_get_TargetProperty), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_IProvideValueTarget[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_IProvideValueTarget) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IProvideValueTarget) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IProvideValueTarget) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IProvideValueTarget) },
        { }};

    static PyType_Spec type_spec_IProvideValueTarget = {
        "winrt._winrt_microsoft_ui_xaml_markup._IProvideValueTarget",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Markup::IProvideValueTarget),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IProvideValueTarget};

    struct ImplementsIProvideValueTarget : py::ImplementsInterfaceT<ImplementsIProvideValueTarget, winrt::Microsoft::UI::Xaml::Markup::IProvideValueTarget>
    {
        ImplementsIProvideValueTarget() = delete;
        ImplementsIProvideValueTarget(PyObject* py_obj, winrt::impl::inspectable_abi* runtime_class) : py::ImplementsInterfaceT<ImplementsIProvideValueTarget, winrt::Microsoft::UI::Xaml::Markup::IProvideValueTarget>(py_obj, runtime_class)
        {
        }

        auto TargetObject()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "target_object")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Foundation::IInspectable>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto TargetProperty()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "target_property")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Foundation::IInspectable>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }
    };

    static PyObject* _assign_array_IProvideValueTarget(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Markup::IProvideValueTarget>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IProvideValueTarget(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Markup::IProvideValueTarget>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _guid_ImplementsIProvideValueTarget(PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::guid_of<winrt::Microsoft::UI::Xaml::Markup::IProvideValueTarget>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _make_ImplementsIProvideValueTarget(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            PyObject* py_obj;
            winrt::impl::inspectable_abi* runtime_class;

            if (!PyArg_ParseTuple(args, "On", &py_obj, &runtime_class))
            {
                return nullptr;
            }

            auto iface{std::make_unique<ImplementsIProvideValueTarget>(py_obj, runtime_class)};

            return PyLong_FromVoidPtr(iface.release());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef methods_ImplementsIProvideValueTarget[] = {
        { "_assign_array_", _assign_array_IProvideValueTarget, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IProvideValueTarget), METH_O | METH_STATIC, nullptr },
        { "_guid_", reinterpret_cast<PyCFunction>(_guid_ImplementsIProvideValueTarget), METH_NOARGS | METH_STATIC, nullptr },
        { "_make_", reinterpret_cast<PyCFunction>(_make_ImplementsIProvideValueTarget), METH_VARARGS | METH_STATIC, nullptr },
        { }};

    static PyType_Slot type_slots_ImplementsIProvideValueTarget[] = {
        { Py_tp_methods, reinterpret_cast<void*>(methods_ImplementsIProvideValueTarget) },
        { }};

    static PyType_Spec type_spec_ImplementsIProvideValueTarget = {
        "winrt._winrt_microsoft_ui_xaml_markup.IProvideValueTarget",
        0,
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_ImplementsIProvideValueTarget};

    // ----- IRootObjectProvider interface --------------------

    static PyObject* _new_IRootObjectProvider(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Markup::IRootObjectProvider>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Markup::IRootObjectProvider>::type_name);
        return nullptr;
    }

    static void _dealloc_IRootObjectProvider(py::wrapper::Microsoft::UI::Xaml::Markup::IRootObjectProvider* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IRootObjectProvider_get_RootObject(py::wrapper::Microsoft::UI::Xaml::Markup::IRootObjectProvider* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Markup.IRootObjectProvider", L"RootObject");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.RootObject();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IRootObjectProvider[] = {
        { }};

    static PyGetSetDef _getset_IRootObjectProvider[] = {
        { "root_object", reinterpret_cast<getter>(IRootObjectProvider_get_RootObject), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_IRootObjectProvider[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_IRootObjectProvider) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IRootObjectProvider) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IRootObjectProvider) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IRootObjectProvider) },
        { }};

    static PyType_Spec type_spec_IRootObjectProvider = {
        "winrt._winrt_microsoft_ui_xaml_markup._IRootObjectProvider",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Markup::IRootObjectProvider),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IRootObjectProvider};

    struct ImplementsIRootObjectProvider : py::ImplementsInterfaceT<ImplementsIRootObjectProvider, winrt::Microsoft::UI::Xaml::Markup::IRootObjectProvider>
    {
        ImplementsIRootObjectProvider() = delete;
        ImplementsIRootObjectProvider(PyObject* py_obj, winrt::impl::inspectable_abi* runtime_class) : py::ImplementsInterfaceT<ImplementsIRootObjectProvider, winrt::Microsoft::UI::Xaml::Markup::IRootObjectProvider>(py_obj, runtime_class)
        {
        }

        auto RootObject()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "root_object")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Foundation::IInspectable>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }
    };

    static PyObject* _assign_array_IRootObjectProvider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Markup::IRootObjectProvider>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IRootObjectProvider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Markup::IRootObjectProvider>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _guid_ImplementsIRootObjectProvider(PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::guid_of<winrt::Microsoft::UI::Xaml::Markup::IRootObjectProvider>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _make_ImplementsIRootObjectProvider(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            PyObject* py_obj;
            winrt::impl::inspectable_abi* runtime_class;

            if (!PyArg_ParseTuple(args, "On", &py_obj, &runtime_class))
            {
                return nullptr;
            }

            auto iface{std::make_unique<ImplementsIRootObjectProvider>(py_obj, runtime_class)};

            return PyLong_FromVoidPtr(iface.release());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef methods_ImplementsIRootObjectProvider[] = {
        { "_assign_array_", _assign_array_IRootObjectProvider, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IRootObjectProvider), METH_O | METH_STATIC, nullptr },
        { "_guid_", reinterpret_cast<PyCFunction>(_guid_ImplementsIRootObjectProvider), METH_NOARGS | METH_STATIC, nullptr },
        { "_make_", reinterpret_cast<PyCFunction>(_make_ImplementsIRootObjectProvider), METH_VARARGS | METH_STATIC, nullptr },
        { }};

    static PyType_Slot type_slots_ImplementsIRootObjectProvider[] = {
        { Py_tp_methods, reinterpret_cast<void*>(methods_ImplementsIRootObjectProvider) },
        { }};

    static PyType_Spec type_spec_ImplementsIRootObjectProvider = {
        "winrt._winrt_microsoft_ui_xaml_markup.IRootObjectProvider",
        0,
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_ImplementsIRootObjectProvider};

    // ----- IUriContext interface --------------------

    static PyObject* _new_IUriContext(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Markup::IUriContext>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Markup::IUriContext>::type_name);
        return nullptr;
    }

    static void _dealloc_IUriContext(py::wrapper::Microsoft::UI::Xaml::Markup::IUriContext* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IUriContext_get_BaseUri(py::wrapper::Microsoft::UI::Xaml::Markup::IUriContext* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Markup.IUriContext", L"BaseUri");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.BaseUri();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IUriContext[] = {
        { }};

    static PyGetSetDef _getset_IUriContext[] = {
        { "base_uri", reinterpret_cast<getter>(IUriContext_get_BaseUri), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_IUriContext[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_IUriContext) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IUriContext) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IUriContext) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IUriContext) },
        { }};

    static PyType_Spec type_spec_IUriContext = {
        "winrt._winrt_microsoft_ui_xaml_markup._IUriContext",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Markup::IUriContext),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IUriContext};

    struct ImplementsIUriContext : py::ImplementsInterfaceT<ImplementsIUriContext, winrt::Microsoft::UI::Xaml::Markup::IUriContext>
    {
        ImplementsIUriContext() = delete;
        ImplementsIUriContext(PyObject* py_obj, winrt::impl::inspectable_abi* runtime_class) : py::ImplementsInterfaceT<ImplementsIUriContext, winrt::Microsoft::UI::Xaml::Markup::IUriContext>(py_obj, runtime_class)
        {
        }

        auto BaseUri()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "base_uri")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Foundation::Uri>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }
    };

    static PyObject* _assign_array_IUriContext(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Markup::IUriContext>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IUriContext(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Markup::IUriContext>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _guid_ImplementsIUriContext(PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::guid_of<winrt::Microsoft::UI::Xaml::Markup::IUriContext>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _make_ImplementsIUriContext(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            PyObject* py_obj;
            winrt::impl::inspectable_abi* runtime_class;

            if (!PyArg_ParseTuple(args, "On", &py_obj, &runtime_class))
            {
                return nullptr;
            }

            auto iface{std::make_unique<ImplementsIUriContext>(py_obj, runtime_class)};

            return PyLong_FromVoidPtr(iface.release());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef methods_ImplementsIUriContext[] = {
        { "_assign_array_", _assign_array_IUriContext, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IUriContext), METH_O | METH_STATIC, nullptr },
        { "_guid_", reinterpret_cast<PyCFunction>(_guid_ImplementsIUriContext), METH_NOARGS | METH_STATIC, nullptr },
        { "_make_", reinterpret_cast<PyCFunction>(_make_ImplementsIUriContext), METH_VARARGS | METH_STATIC, nullptr },
        { }};

    static PyType_Slot type_slots_ImplementsIUriContext[] = {
        { Py_tp_methods, reinterpret_cast<void*>(methods_ImplementsIUriContext) },
        { }};

    static PyType_Spec type_spec_ImplementsIUriContext = {
        "winrt._winrt_microsoft_ui_xaml_markup.IUriContext",
        0,
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_ImplementsIUriContext};

    // ----- IXamlBindScopeDiagnostics interface --------------------

    static PyObject* _new_IXamlBindScopeDiagnostics(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Markup::IXamlBindScopeDiagnostics>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Markup::IXamlBindScopeDiagnostics>::type_name);
        return nullptr;
    }

    static void _dealloc_IXamlBindScopeDiagnostics(py::wrapper::Microsoft::UI::Xaml::Markup::IXamlBindScopeDiagnostics* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IXamlBindScopeDiagnostics_Disable(py::wrapper::Microsoft::UI::Xaml::Markup::IXamlBindScopeDiagnostics* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Markup.IXamlBindScopeDiagnostics", L"Disable", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<int32_t>(args, 0);
                auto param1 = py::convert_to<int32_t>(args, 1);

                {
                    auto _gil = release_gil();
                    self->obj.Disable(param0, param1);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyMethodDef _methods_IXamlBindScopeDiagnostics[] = {
        { "disable", reinterpret_cast<PyCFunction>(IXamlBindScopeDiagnostics_Disable), METH_VARARGS, nullptr },
        { }};

    static PyGetSetDef _getset_IXamlBindScopeDiagnostics[] = {
        { }};

    static PyType_Slot _type_slots_IXamlBindScopeDiagnostics[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_IXamlBindScopeDiagnostics) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IXamlBindScopeDiagnostics) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IXamlBindScopeDiagnostics) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IXamlBindScopeDiagnostics) },
        { }};

    static PyType_Spec type_spec_IXamlBindScopeDiagnostics = {
        "winrt._winrt_microsoft_ui_xaml_markup._IXamlBindScopeDiagnostics",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Markup::IXamlBindScopeDiagnostics),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IXamlBindScopeDiagnostics};

    struct ImplementsIXamlBindScopeDiagnostics : py::ImplementsInterfaceT<ImplementsIXamlBindScopeDiagnostics, winrt::Microsoft::UI::Xaml::Markup::IXamlBindScopeDiagnostics>
    {
        ImplementsIXamlBindScopeDiagnostics() = delete;
        ImplementsIXamlBindScopeDiagnostics(PyObject* py_obj, winrt::impl::inspectable_abi* runtime_class) : py::ImplementsInterfaceT<ImplementsIXamlBindScopeDiagnostics, winrt::Microsoft::UI::Xaml::Markup::IXamlBindScopeDiagnostics>(py_obj, runtime_class)
        {
        }

        auto Disable(int32_t param0, int32_t param1)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "disable")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param1{py::convert(param1)};
                if (!py_param1)
                {
                    throw python_exception();
                }

                py::pyobj_handle args{PyTuple_Pack(2, py_param0.get(), py_param1.get())};
                if (!args)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallObject(method.get(), args.get())};
                if (!return_value)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }
    };

    static PyObject* _assign_array_IXamlBindScopeDiagnostics(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Markup::IXamlBindScopeDiagnostics>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IXamlBindScopeDiagnostics(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Markup::IXamlBindScopeDiagnostics>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _guid_ImplementsIXamlBindScopeDiagnostics(PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::guid_of<winrt::Microsoft::UI::Xaml::Markup::IXamlBindScopeDiagnostics>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _make_ImplementsIXamlBindScopeDiagnostics(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            PyObject* py_obj;
            winrt::impl::inspectable_abi* runtime_class;

            if (!PyArg_ParseTuple(args, "On", &py_obj, &runtime_class))
            {
                return nullptr;
            }

            auto iface{std::make_unique<ImplementsIXamlBindScopeDiagnostics>(py_obj, runtime_class)};

            return PyLong_FromVoidPtr(iface.release());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef methods_ImplementsIXamlBindScopeDiagnostics[] = {
        { "_assign_array_", _assign_array_IXamlBindScopeDiagnostics, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IXamlBindScopeDiagnostics), METH_O | METH_STATIC, nullptr },
        { "_guid_", reinterpret_cast<PyCFunction>(_guid_ImplementsIXamlBindScopeDiagnostics), METH_NOARGS | METH_STATIC, nullptr },
        { "_make_", reinterpret_cast<PyCFunction>(_make_ImplementsIXamlBindScopeDiagnostics), METH_VARARGS | METH_STATIC, nullptr },
        { }};

    static PyType_Slot type_slots_ImplementsIXamlBindScopeDiagnostics[] = {
        { Py_tp_methods, reinterpret_cast<void*>(methods_ImplementsIXamlBindScopeDiagnostics) },
        { }};

    static PyType_Spec type_spec_ImplementsIXamlBindScopeDiagnostics = {
        "winrt._winrt_microsoft_ui_xaml_markup.IXamlBindScopeDiagnostics",
        0,
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_ImplementsIXamlBindScopeDiagnostics};

    // ----- IXamlMember interface --------------------

    static PyObject* _new_IXamlMember(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Markup::IXamlMember>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Markup::IXamlMember>::type_name);
        return nullptr;
    }

    static void _dealloc_IXamlMember(py::wrapper::Microsoft::UI::Xaml::Markup::IXamlMember* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IXamlMember_GetValue(py::wrapper::Microsoft::UI::Xaml::Markup::IXamlMember* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Markup.IXamlMember", L"GetValue", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetValue(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IXamlMember_SetValue(py::wrapper::Microsoft::UI::Xaml::Markup::IXamlMember* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Markup.IXamlMember", L"SetValue", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 1);

                {
                    auto _gil = release_gil();
                    self->obj.SetValue(param0, param1);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IXamlMember_get_IsAttachable(py::wrapper::Microsoft::UI::Xaml::Markup::IXamlMember* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Markup.IXamlMember", L"IsAttachable");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsAttachable();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IXamlMember_get_IsDependencyProperty(py::wrapper::Microsoft::UI::Xaml::Markup::IXamlMember* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Markup.IXamlMember", L"IsDependencyProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsDependencyProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IXamlMember_get_IsReadOnly(py::wrapper::Microsoft::UI::Xaml::Markup::IXamlMember* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Markup.IXamlMember", L"IsReadOnly");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsReadOnly();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IXamlMember_get_Name(py::wrapper::Microsoft::UI::Xaml::Markup::IXamlMember* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Markup.IXamlMember", L"Name");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Name();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IXamlMember_get_TargetType(py::wrapper::Microsoft::UI::Xaml::Markup::IXamlMember* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Markup.IXamlMember", L"TargetType");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.TargetType();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IXamlMember_get_Type(py::wrapper::Microsoft::UI::Xaml::Markup::IXamlMember* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Markup.IXamlMember", L"Type");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Type();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IXamlMember[] = {
        { "get_value", reinterpret_cast<PyCFunction>(IXamlMember_GetValue), METH_VARARGS, nullptr },
        { "set_value", reinterpret_cast<PyCFunction>(IXamlMember_SetValue), METH_VARARGS, nullptr },
        { }};

    static PyGetSetDef _getset_IXamlMember[] = {
        { "is_attachable", reinterpret_cast<getter>(IXamlMember_get_IsAttachable), nullptr, nullptr, nullptr },
        { "is_dependency_property", reinterpret_cast<getter>(IXamlMember_get_IsDependencyProperty), nullptr, nullptr, nullptr },
        { "is_read_only", reinterpret_cast<getter>(IXamlMember_get_IsReadOnly), nullptr, nullptr, nullptr },
        { "name", reinterpret_cast<getter>(IXamlMember_get_Name), nullptr, nullptr, nullptr },
        { "target_type", reinterpret_cast<getter>(IXamlMember_get_TargetType), nullptr, nullptr, nullptr },
        { "type", reinterpret_cast<getter>(IXamlMember_get_Type), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_IXamlMember[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_IXamlMember) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IXamlMember) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IXamlMember) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IXamlMember) },
        { }};

    static PyType_Spec type_spec_IXamlMember = {
        "winrt._winrt_microsoft_ui_xaml_markup._IXamlMember",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Markup::IXamlMember),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IXamlMember};

    struct ImplementsIXamlMember : py::ImplementsInterfaceT<ImplementsIXamlMember, winrt::Microsoft::UI::Xaml::Markup::IXamlMember>
    {
        ImplementsIXamlMember() = delete;
        ImplementsIXamlMember(PyObject* py_obj, winrt::impl::inspectable_abi* runtime_class) : py::ImplementsInterfaceT<ImplementsIXamlMember, winrt::Microsoft::UI::Xaml::Markup::IXamlMember>(py_obj, runtime_class)
        {
        }

        auto GetValue(winrt::Windows::Foundation::IInspectable const& param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "get_value")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallOneArg(method.get(), py_param0.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Foundation::IInspectable>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto SetValue(winrt::Windows::Foundation::IInspectable const& param0, winrt::Windows::Foundation::IInspectable const& param1)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "set_value")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param1{py::convert(param1)};
                if (!py_param1)
                {
                    throw python_exception();
                }

                py::pyobj_handle args{PyTuple_Pack(2, py_param0.get(), py_param1.get())};
                if (!args)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallObject(method.get(), args.get())};
                if (!return_value)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto IsAttachable()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "is_attachable")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<bool>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto IsDependencyProperty()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "is_dependency_property")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<bool>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto IsReadOnly()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "is_read_only")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<bool>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto Name()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "name")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::hstring>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto TargetType()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "target_type")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Microsoft::UI::Xaml::Markup::IXamlType>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto Type()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "type")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Microsoft::UI::Xaml::Markup::IXamlType>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }
    };

    static PyObject* _assign_array_IXamlMember(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Markup::IXamlMember>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IXamlMember(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Markup::IXamlMember>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _guid_ImplementsIXamlMember(PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::guid_of<winrt::Microsoft::UI::Xaml::Markup::IXamlMember>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _make_ImplementsIXamlMember(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            PyObject* py_obj;
            winrt::impl::inspectable_abi* runtime_class;

            if (!PyArg_ParseTuple(args, "On", &py_obj, &runtime_class))
            {
                return nullptr;
            }

            auto iface{std::make_unique<ImplementsIXamlMember>(py_obj, runtime_class)};

            return PyLong_FromVoidPtr(iface.release());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef methods_ImplementsIXamlMember[] = {
        { "_assign_array_", _assign_array_IXamlMember, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IXamlMember), METH_O | METH_STATIC, nullptr },
        { "_guid_", reinterpret_cast<PyCFunction>(_guid_ImplementsIXamlMember), METH_NOARGS | METH_STATIC, nullptr },
        { "_make_", reinterpret_cast<PyCFunction>(_make_ImplementsIXamlMember), METH_VARARGS | METH_STATIC, nullptr },
        { }};

    static PyType_Slot type_slots_ImplementsIXamlMember[] = {
        { Py_tp_methods, reinterpret_cast<void*>(methods_ImplementsIXamlMember) },
        { }};

    static PyType_Spec type_spec_ImplementsIXamlMember = {
        "winrt._winrt_microsoft_ui_xaml_markup.IXamlMember",
        0,
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_ImplementsIXamlMember};

    // ----- IXamlMetadataProvider interface --------------------

    static PyObject* _new_IXamlMetadataProvider(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Markup::IXamlMetadataProvider>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Markup::IXamlMetadataProvider>::type_name);
        return nullptr;
    }

    static void _dealloc_IXamlMetadataProvider(py::wrapper::Microsoft::UI::Xaml::Markup::IXamlMetadataProvider* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IXamlMetadataProvider_GetXamlType(py::wrapper::Microsoft::UI::Xaml::Markup::IXamlMetadataProvider* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Markup.IXamlMetadataProvider", L"GetXamlType", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Interop::TypeName>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetXamlType(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IXamlMetadataProvider_GetXamlTypeByFullName(py::wrapper::Microsoft::UI::Xaml::Markup::IXamlMetadataProvider* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Markup.IXamlMetadataProvider", L"GetXamlType", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetXamlType(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IXamlMetadataProvider_GetXmlnsDefinitions(py::wrapper::Microsoft::UI::Xaml::Markup::IXamlMetadataProvider* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Markup.IXamlMetadataProvider", L"GetXmlnsDefinitions", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetXmlnsDefinitions();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyMethodDef _methods_IXamlMetadataProvider[] = {
        { "get_xaml_type", reinterpret_cast<PyCFunction>(IXamlMetadataProvider_GetXamlType), METH_VARARGS, nullptr },
        { "get_xaml_type_by_full_name", reinterpret_cast<PyCFunction>(IXamlMetadataProvider_GetXamlTypeByFullName), METH_VARARGS, nullptr },
        { "get_xmlns_definitions", reinterpret_cast<PyCFunction>(IXamlMetadataProvider_GetXmlnsDefinitions), METH_VARARGS, nullptr },
        { }};

    static PyGetSetDef _getset_IXamlMetadataProvider[] = {
        { }};

    static PyType_Slot _type_slots_IXamlMetadataProvider[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_IXamlMetadataProvider) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IXamlMetadataProvider) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IXamlMetadataProvider) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IXamlMetadataProvider) },
        { }};

    static PyType_Spec type_spec_IXamlMetadataProvider = {
        "winrt._winrt_microsoft_ui_xaml_markup._IXamlMetadataProvider",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Markup::IXamlMetadataProvider),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IXamlMetadataProvider};

    struct ImplementsIXamlMetadataProvider : py::ImplementsInterfaceT<ImplementsIXamlMetadataProvider, winrt::Microsoft::UI::Xaml::Markup::IXamlMetadataProvider>
    {
        ImplementsIXamlMetadataProvider() = delete;
        ImplementsIXamlMetadataProvider(PyObject* py_obj, winrt::impl::inspectable_abi* runtime_class) : py::ImplementsInterfaceT<ImplementsIXamlMetadataProvider, winrt::Microsoft::UI::Xaml::Markup::IXamlMetadataProvider>(py_obj, runtime_class)
        {
        }

        auto GetXamlType(winrt::Windows::UI::Xaml::Interop::TypeName param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "get_xaml_type")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallOneArg(method.get(), py_param0.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Microsoft::UI::Xaml::Markup::IXamlType>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto GetXamlType(winrt::hstring const& param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "get_xaml_type_by_full_name")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallOneArg(method.get(), py_param0.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Microsoft::UI::Xaml::Markup::IXamlType>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto GetXmlnsDefinitions()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "get_xmlns_definitions")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallNoArgs(method.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                auto return_buf = py::convert_to<py::pybuf_view<winrt::Microsoft::UI::Xaml::Markup::XmlnsDefinition, false>>(return_value.get());
                return winrt::com_array<winrt::Microsoft::UI::Xaml::Markup::XmlnsDefinition>{return_buf.begin(), return_buf.end()};
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }
    };

    static PyObject* _assign_array_IXamlMetadataProvider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Markup::IXamlMetadataProvider>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IXamlMetadataProvider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Markup::IXamlMetadataProvider>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _guid_ImplementsIXamlMetadataProvider(PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::guid_of<winrt::Microsoft::UI::Xaml::Markup::IXamlMetadataProvider>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _make_ImplementsIXamlMetadataProvider(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            PyObject* py_obj;
            winrt::impl::inspectable_abi* runtime_class;

            if (!PyArg_ParseTuple(args, "On", &py_obj, &runtime_class))
            {
                return nullptr;
            }

            auto iface{std::make_unique<ImplementsIXamlMetadataProvider>(py_obj, runtime_class)};

            return PyLong_FromVoidPtr(iface.release());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef methods_ImplementsIXamlMetadataProvider[] = {
        { "_assign_array_", _assign_array_IXamlMetadataProvider, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IXamlMetadataProvider), METH_O | METH_STATIC, nullptr },
        { "_guid_", reinterpret_cast<PyCFunction>(_guid_ImplementsIXamlMetadataProvider), METH_NOARGS | METH_STATIC, nullptr },
        { "_make_", reinterpret_cast<PyCFunction>(_make_ImplementsIXamlMetadataProvider), METH_VARARGS | METH_STATIC, nullptr },
        { }};

    static PyType_Slot type_slots_ImplementsIXamlMetadataProvider[] = {
        { Py_tp_methods, reinterpret_cast<void*>(methods_ImplementsIXamlMetadataProvider) },
        { }};

    static PyType_Spec type_spec_ImplementsIXamlMetadataProvider = {
        "winrt._winrt_microsoft_ui_xaml_markup.IXamlMetadataProvider",
        0,
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_ImplementsIXamlMetadataProvider};

    // ----- IXamlType interface --------------------

    static PyObject* _new_IXamlType(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Markup::IXamlType>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Markup::IXamlType>::type_name);
        return nullptr;
    }

    static void _dealloc_IXamlType(py::wrapper::Microsoft::UI::Xaml::Markup::IXamlType* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IXamlType_ActivateInstance(py::wrapper::Microsoft::UI::Xaml::Markup::IXamlType* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Markup.IXamlType", L"ActivateInstance", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.ActivateInstance();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IXamlType_AddToMap(py::wrapper::Microsoft::UI::Xaml::Markup::IXamlType* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Markup.IXamlType", L"AddToMap", 3);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 2);

                {
                    auto _gil = release_gil();
                    self->obj.AddToMap(param0, param1, param2);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IXamlType_AddToVector(py::wrapper::Microsoft::UI::Xaml::Markup::IXamlType* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Markup.IXamlType", L"AddToVector", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 1);

                {
                    auto _gil = release_gil();
                    self->obj.AddToVector(param0, param1);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IXamlType_CreateFromString(py::wrapper::Microsoft::UI::Xaml::Markup::IXamlType* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Markup.IXamlType", L"CreateFromString", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.CreateFromString(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IXamlType_GetMember(py::wrapper::Microsoft::UI::Xaml::Markup::IXamlType* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Markup.IXamlType", L"GetMember", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetMember(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IXamlType_RunInitializer(py::wrapper::Microsoft::UI::Xaml::Markup::IXamlType* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Markup.IXamlType", L"RunInitializer", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.RunInitializer();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IXamlType_get_BaseType(py::wrapper::Microsoft::UI::Xaml::Markup::IXamlType* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Markup.IXamlType", L"BaseType");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.BaseType();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IXamlType_get_BoxedType(py::wrapper::Microsoft::UI::Xaml::Markup::IXamlType* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Markup.IXamlType", L"BoxedType");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.BoxedType();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IXamlType_get_ContentProperty(py::wrapper::Microsoft::UI::Xaml::Markup::IXamlType* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Markup.IXamlType", L"ContentProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ContentProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IXamlType_get_FullName(py::wrapper::Microsoft::UI::Xaml::Markup::IXamlType* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Markup.IXamlType", L"FullName");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.FullName();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IXamlType_get_IsArray(py::wrapper::Microsoft::UI::Xaml::Markup::IXamlType* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Markup.IXamlType", L"IsArray");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsArray();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IXamlType_get_IsBindable(py::wrapper::Microsoft::UI::Xaml::Markup::IXamlType* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Markup.IXamlType", L"IsBindable");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsBindable();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IXamlType_get_IsCollection(py::wrapper::Microsoft::UI::Xaml::Markup::IXamlType* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Markup.IXamlType", L"IsCollection");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsCollection();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IXamlType_get_IsConstructible(py::wrapper::Microsoft::UI::Xaml::Markup::IXamlType* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Markup.IXamlType", L"IsConstructible");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsConstructible();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IXamlType_get_IsDictionary(py::wrapper::Microsoft::UI::Xaml::Markup::IXamlType* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Markup.IXamlType", L"IsDictionary");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsDictionary();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IXamlType_get_IsMarkupExtension(py::wrapper::Microsoft::UI::Xaml::Markup::IXamlType* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Markup.IXamlType", L"IsMarkupExtension");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsMarkupExtension();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IXamlType_get_ItemType(py::wrapper::Microsoft::UI::Xaml::Markup::IXamlType* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Markup.IXamlType", L"ItemType");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ItemType();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IXamlType_get_KeyType(py::wrapper::Microsoft::UI::Xaml::Markup::IXamlType* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Markup.IXamlType", L"KeyType");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.KeyType();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IXamlType_get_UnderlyingType(py::wrapper::Microsoft::UI::Xaml::Markup::IXamlType* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Markup.IXamlType", L"UnderlyingType");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.UnderlyingType();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IXamlType[] = {
        { "activate_instance", reinterpret_cast<PyCFunction>(IXamlType_ActivateInstance), METH_VARARGS, nullptr },
        { "add_to_map", reinterpret_cast<PyCFunction>(IXamlType_AddToMap), METH_VARARGS, nullptr },
        { "add_to_vector", reinterpret_cast<PyCFunction>(IXamlType_AddToVector), METH_VARARGS, nullptr },
        { "create_from_string", reinterpret_cast<PyCFunction>(IXamlType_CreateFromString), METH_VARARGS, nullptr },
        { "get_member", reinterpret_cast<PyCFunction>(IXamlType_GetMember), METH_VARARGS, nullptr },
        { "run_initializer", reinterpret_cast<PyCFunction>(IXamlType_RunInitializer), METH_VARARGS, nullptr },
        { }};

    static PyGetSetDef _getset_IXamlType[] = {
        { "base_type", reinterpret_cast<getter>(IXamlType_get_BaseType), nullptr, nullptr, nullptr },
        { "boxed_type", reinterpret_cast<getter>(IXamlType_get_BoxedType), nullptr, nullptr, nullptr },
        { "content_property", reinterpret_cast<getter>(IXamlType_get_ContentProperty), nullptr, nullptr, nullptr },
        { "full_name", reinterpret_cast<getter>(IXamlType_get_FullName), nullptr, nullptr, nullptr },
        { "is_array", reinterpret_cast<getter>(IXamlType_get_IsArray), nullptr, nullptr, nullptr },
        { "is_bindable", reinterpret_cast<getter>(IXamlType_get_IsBindable), nullptr, nullptr, nullptr },
        { "is_collection", reinterpret_cast<getter>(IXamlType_get_IsCollection), nullptr, nullptr, nullptr },
        { "is_constructible", reinterpret_cast<getter>(IXamlType_get_IsConstructible), nullptr, nullptr, nullptr },
        { "is_dictionary", reinterpret_cast<getter>(IXamlType_get_IsDictionary), nullptr, nullptr, nullptr },
        { "is_markup_extension", reinterpret_cast<getter>(IXamlType_get_IsMarkupExtension), nullptr, nullptr, nullptr },
        { "item_type", reinterpret_cast<getter>(IXamlType_get_ItemType), nullptr, nullptr, nullptr },
        { "key_type", reinterpret_cast<getter>(IXamlType_get_KeyType), nullptr, nullptr, nullptr },
        { "underlying_type", reinterpret_cast<getter>(IXamlType_get_UnderlyingType), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_IXamlType[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_IXamlType) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IXamlType) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IXamlType) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IXamlType) },
        { }};

    static PyType_Spec type_spec_IXamlType = {
        "winrt._winrt_microsoft_ui_xaml_markup._IXamlType",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Markup::IXamlType),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IXamlType};

    struct ImplementsIXamlType : py::ImplementsInterfaceT<ImplementsIXamlType, winrt::Microsoft::UI::Xaml::Markup::IXamlType>
    {
        ImplementsIXamlType() = delete;
        ImplementsIXamlType(PyObject* py_obj, winrt::impl::inspectable_abi* runtime_class) : py::ImplementsInterfaceT<ImplementsIXamlType, winrt::Microsoft::UI::Xaml::Markup::IXamlType>(py_obj, runtime_class)
        {
        }

        auto ActivateInstance()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "activate_instance")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallNoArgs(method.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Foundation::IInspectable>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto AddToMap(winrt::Windows::Foundation::IInspectable const& param0, winrt::Windows::Foundation::IInspectable const& param1, winrt::Windows::Foundation::IInspectable const& param2)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "add_to_map")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param1{py::convert(param1)};
                if (!py_param1)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param2{py::convert(param2)};
                if (!py_param2)
                {
                    throw python_exception();
                }

                py::pyobj_handle args{PyTuple_Pack(3, py_param0.get(), py_param1.get(), py_param2.get())};
                if (!args)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallObject(method.get(), args.get())};
                if (!return_value)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto AddToVector(winrt::Windows::Foundation::IInspectable const& param0, winrt::Windows::Foundation::IInspectable const& param1)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "add_to_vector")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param1{py::convert(param1)};
                if (!py_param1)
                {
                    throw python_exception();
                }

                py::pyobj_handle args{PyTuple_Pack(2, py_param0.get(), py_param1.get())};
                if (!args)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallObject(method.get(), args.get())};
                if (!return_value)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto CreateFromString(winrt::hstring const& param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "create_from_string")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallOneArg(method.get(), py_param0.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Foundation::IInspectable>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto GetMember(winrt::hstring const& param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "get_member")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallOneArg(method.get(), py_param0.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Microsoft::UI::Xaml::Markup::IXamlMember>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto RunInitializer()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "run_initializer")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallNoArgs(method.get())};
                if (!return_value)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto BaseType()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "base_type")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Microsoft::UI::Xaml::Markup::IXamlType>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto BoxedType()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "boxed_type")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Microsoft::UI::Xaml::Markup::IXamlType>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto ContentProperty()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "content_property")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Microsoft::UI::Xaml::Markup::IXamlMember>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto FullName()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "full_name")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::hstring>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto IsArray()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "is_array")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<bool>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto IsBindable()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "is_bindable")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<bool>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto IsCollection()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "is_collection")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<bool>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto IsConstructible()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "is_constructible")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<bool>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto IsDictionary()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "is_dictionary")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<bool>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto IsMarkupExtension()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "is_markup_extension")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<bool>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto ItemType()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "item_type")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Microsoft::UI::Xaml::Markup::IXamlType>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto KeyType()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "key_type")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Microsoft::UI::Xaml::Markup::IXamlType>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto UnderlyingType()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "underlying_type")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::UI::Xaml::Interop::TypeName>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }
    };

    static PyObject* _assign_array_IXamlType(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Markup::IXamlType>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IXamlType(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Markup::IXamlType>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _guid_ImplementsIXamlType(PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::guid_of<winrt::Microsoft::UI::Xaml::Markup::IXamlType>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _make_ImplementsIXamlType(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            PyObject* py_obj;
            winrt::impl::inspectable_abi* runtime_class;

            if (!PyArg_ParseTuple(args, "On", &py_obj, &runtime_class))
            {
                return nullptr;
            }

            auto iface{std::make_unique<ImplementsIXamlType>(py_obj, runtime_class)};

            return PyLong_FromVoidPtr(iface.release());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef methods_ImplementsIXamlType[] = {
        { "_assign_array_", _assign_array_IXamlType, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IXamlType), METH_O | METH_STATIC, nullptr },
        { "_guid_", reinterpret_cast<PyCFunction>(_guid_ImplementsIXamlType), METH_NOARGS | METH_STATIC, nullptr },
        { "_make_", reinterpret_cast<PyCFunction>(_make_ImplementsIXamlType), METH_VARARGS | METH_STATIC, nullptr },
        { }};

    static PyType_Slot type_slots_ImplementsIXamlType[] = {
        { Py_tp_methods, reinterpret_cast<void*>(methods_ImplementsIXamlType) },
        { }};

    static PyType_Spec type_spec_ImplementsIXamlType = {
        "winrt._winrt_microsoft_ui_xaml_markup.IXamlType",
        0,
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_ImplementsIXamlType};

    // ----- IXamlTypeResolver interface --------------------

    static PyObject* _new_IXamlTypeResolver(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Markup::IXamlTypeResolver>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Markup::IXamlTypeResolver>::type_name);
        return nullptr;
    }

    static void _dealloc_IXamlTypeResolver(py::wrapper::Microsoft::UI::Xaml::Markup::IXamlTypeResolver* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IXamlTypeResolver_Resolve(py::wrapper::Microsoft::UI::Xaml::Markup::IXamlTypeResolver* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Markup.IXamlTypeResolver", L"Resolve", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.Resolve(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyMethodDef _methods_IXamlTypeResolver[] = {
        { "resolve", reinterpret_cast<PyCFunction>(IXamlTypeResolver_Resolve), METH_VARARGS, nullptr },
        { }};

    static PyGetSetDef _getset_IXamlTypeResolver[] = {
        { }};

    static PyType_Slot _type_slots_IXamlTypeResolver[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_IXamlTypeResolver) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IXamlTypeResolver) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IXamlTypeResolver) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IXamlTypeResolver) },
        { }};

    static PyType_Spec type_spec_IXamlTypeResolver = {
        "winrt._winrt_microsoft_ui_xaml_markup._IXamlTypeResolver",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Markup::IXamlTypeResolver),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IXamlTypeResolver};

    struct ImplementsIXamlTypeResolver : py::ImplementsInterfaceT<ImplementsIXamlTypeResolver, winrt::Microsoft::UI::Xaml::Markup::IXamlTypeResolver>
    {
        ImplementsIXamlTypeResolver() = delete;
        ImplementsIXamlTypeResolver(PyObject* py_obj, winrt::impl::inspectable_abi* runtime_class) : py::ImplementsInterfaceT<ImplementsIXamlTypeResolver, winrt::Microsoft::UI::Xaml::Markup::IXamlTypeResolver>(py_obj, runtime_class)
        {
        }

        auto Resolve(winrt::hstring const& param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "resolve")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallOneArg(method.get(), py_param0.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::UI::Xaml::Interop::TypeName>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }
    };

    static PyObject* _assign_array_IXamlTypeResolver(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Markup::IXamlTypeResolver>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IXamlTypeResolver(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Markup::IXamlTypeResolver>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _guid_ImplementsIXamlTypeResolver(PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::guid_of<winrt::Microsoft::UI::Xaml::Markup::IXamlTypeResolver>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _make_ImplementsIXamlTypeResolver(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            PyObject* py_obj;
            winrt::impl::inspectable_abi* runtime_class;

            if (!PyArg_ParseTuple(args, "On", &py_obj, &runtime_class))
            {
                return nullptr;
            }

            auto iface{std::make_unique<ImplementsIXamlTypeResolver>(py_obj, runtime_class)};

            return PyLong_FromVoidPtr(iface.release());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef methods_ImplementsIXamlTypeResolver[] = {
        { "_assign_array_", _assign_array_IXamlTypeResolver, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IXamlTypeResolver), METH_O | METH_STATIC, nullptr },
        { "_guid_", reinterpret_cast<PyCFunction>(_guid_ImplementsIXamlTypeResolver), METH_NOARGS | METH_STATIC, nullptr },
        { "_make_", reinterpret_cast<PyCFunction>(_make_ImplementsIXamlTypeResolver), METH_VARARGS | METH_STATIC, nullptr },
        { }};

    static PyType_Slot type_slots_ImplementsIXamlTypeResolver[] = {
        { Py_tp_methods, reinterpret_cast<void*>(methods_ImplementsIXamlTypeResolver) },
        { }};

    static PyType_Spec type_spec_ImplementsIXamlTypeResolver = {
        "winrt._winrt_microsoft_ui_xaml_markup.IXamlTypeResolver",
        0,
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_ImplementsIXamlTypeResolver};

    // ----- XamlBinaryWriterErrorInformation struct --------------------

    winrt_struct_wrapper<winrt::Microsoft::UI::Xaml::Markup::XamlBinaryWriterErrorInformation>* _new_XamlBinaryWriterErrorInformation(PyTypeObject* subclass, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        auto self = reinterpret_cast<winrt_struct_wrapper<winrt::Microsoft::UI::Xaml::Markup::XamlBinaryWriterErrorInformation>*>(subclass->tp_alloc(subclass, 0));

        if (!self)
        {
            return nullptr;
        }

        std::construct_at(&self->obj);

        return self;
    }

    int _init_XamlBinaryWriterErrorInformation(winrt_struct_wrapper<winrt::Microsoft::UI::Xaml::Markup::XamlBinaryWriterErrorInformation>* self, PyObject* args, PyObject* kwds) noexcept
    {
        auto tuple_size = PyTuple_Size(args);

        if ((tuple_size == 0) && (!kwds))
        {
            self->obj = {};
            return 0;
        }

        uint32_t _InputStreamIndex{};
        uint32_t _LineNumber{};
        uint32_t _LinePosition{};

        static const char* kwlist[] = {"input_stream_index", "line_number", "line_position", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "III", const_cast<char**>(kwlist), &_InputStreamIndex, &_LineNumber, &_LinePosition))
        {
            return -1;
        }

        try
        {
            self->obj.InputStreamIndex = _InputStreamIndex;
            self->obj.LineNumber = _LineNumber;
            self->obj.LinePosition = _LinePosition;

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static void _dealloc_XamlBinaryWriterErrorInformation(py::wrapper::Microsoft::UI::Xaml::Markup::XamlBinaryWriterErrorInformation* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_XamlBinaryWriterErrorInformation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Markup::XamlBinaryWriterErrorInformation>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyMethodDef _methods_XamlBinaryWriterErrorInformation[] = {
        { "_assign_array_", _assign_array_XamlBinaryWriterErrorInformation, METH_O | METH_STATIC, nullptr },
        { }};

    static PyObject* XamlBinaryWriterErrorInformation_get_InputStreamIndex(py::wrapper::Microsoft::UI::Xaml::Markup::XamlBinaryWriterErrorInformation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.InputStreamIndex);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int XamlBinaryWriterErrorInformation_set_InputStreamIndex(py::wrapper::Microsoft::UI::Xaml::Markup::XamlBinaryWriterErrorInformation* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.InputStreamIndex = py::convert_to<uint32_t>(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* XamlBinaryWriterErrorInformation_get_LineNumber(py::wrapper::Microsoft::UI::Xaml::Markup::XamlBinaryWriterErrorInformation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.LineNumber);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int XamlBinaryWriterErrorInformation_set_LineNumber(py::wrapper::Microsoft::UI::Xaml::Markup::XamlBinaryWriterErrorInformation* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.LineNumber = py::convert_to<uint32_t>(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* XamlBinaryWriterErrorInformation_get_LinePosition(py::wrapper::Microsoft::UI::Xaml::Markup::XamlBinaryWriterErrorInformation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.LinePosition);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int XamlBinaryWriterErrorInformation_set_LinePosition(py::wrapper::Microsoft::UI::Xaml::Markup::XamlBinaryWriterErrorInformation* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.LinePosition = py::convert_to<uint32_t>(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyGetSetDef _getset_XamlBinaryWriterErrorInformation[] = {
        { "input_stream_index", reinterpret_cast<getter>(XamlBinaryWriterErrorInformation_get_InputStreamIndex), reinterpret_cast<setter>(XamlBinaryWriterErrorInformation_set_InputStreamIndex), nullptr, nullptr },
        { "line_number", reinterpret_cast<getter>(XamlBinaryWriterErrorInformation_get_LineNumber), reinterpret_cast<setter>(XamlBinaryWriterErrorInformation_set_LineNumber), nullptr, nullptr },
        { "line_position", reinterpret_cast<getter>(XamlBinaryWriterErrorInformation_get_LinePosition), reinterpret_cast<setter>(XamlBinaryWriterErrorInformation_set_LinePosition), nullptr, nullptr },
        { }};

    static PyObject* _richcompare_XamlBinaryWriterErrorInformation(py::wrapper::Microsoft::UI::Xaml::Markup::XamlBinaryWriterErrorInformation* self, PyObject* other, int op) noexcept
    {
        try
        {
            auto _other = py::convert_to<winrt::Microsoft::UI::Xaml::Markup::XamlBinaryWriterErrorInformation>(other);

            if (op == Py_EQ)
            {
                if (self->obj == _other)
                {
                    Py_RETURN_TRUE;
                }

                Py_RETURN_FALSE;
            }

            if (op == Py_NE)
            {
                if (self->obj != _other)
                {
                    Py_RETURN_TRUE;
                }

                Py_RETURN_FALSE;
            }

            Py_RETURN_NOTIMPLEMENTED;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _repr_XamlBinaryWriterErrorInformation(PyObject* self) noexcept
    {
        py::pyobj_handle InputStreamIndex{PyObject_GetAttrString(self, "input_stream_index")};
        if (!InputStreamIndex)
        {
            return nullptr;
        }

        py::pyobj_handle LineNumber{PyObject_GetAttrString(self, "line_number")};
        if (!LineNumber)
        {
            return nullptr;
        }

        py::pyobj_handle LinePosition{PyObject_GetAttrString(self, "line_position")};
        if (!LinePosition)
        {
            return nullptr;
        }

        return PyUnicode_FromFormat("XamlBinaryWriterErrorInformation(input_stream_index=%R, line_number=%R, line_position=%R)", InputStreamIndex.get(), LineNumber.get(), LinePosition.get());
    }

    static PyType_Slot _type_slots_XamlBinaryWriterErrorInformation[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_XamlBinaryWriterErrorInformation) },
        { Py_tp_init, reinterpret_cast<void*>(_init_XamlBinaryWriterErrorInformation) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_XamlBinaryWriterErrorInformation) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_XamlBinaryWriterErrorInformation) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_XamlBinaryWriterErrorInformation) },
        { Py_tp_richcompare, reinterpret_cast<void*>(_richcompare_XamlBinaryWriterErrorInformation) },
        { Py_tp_repr, reinterpret_cast<void*>(_repr_XamlBinaryWriterErrorInformation) },
        { }};

    static PyType_Spec type_spec_XamlBinaryWriterErrorInformation = {
        "winrt._winrt_microsoft_ui_xaml_markup.XamlBinaryWriterErrorInformation",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Markup::XamlBinaryWriterErrorInformation),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_XamlBinaryWriterErrorInformation};

    // ----- XmlnsDefinition struct --------------------

    winrt_struct_wrapper<winrt::Microsoft::UI::Xaml::Markup::XmlnsDefinition>* _new_XmlnsDefinition(PyTypeObject* subclass, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        auto self = reinterpret_cast<winrt_struct_wrapper<winrt::Microsoft::UI::Xaml::Markup::XmlnsDefinition>*>(subclass->tp_alloc(subclass, 0));

        if (!self)
        {
            return nullptr;
        }

        std::construct_at(&self->obj);

        return self;
    }

    int _init_XmlnsDefinition(winrt_struct_wrapper<winrt::Microsoft::UI::Xaml::Markup::XmlnsDefinition>* self, PyObject* args, PyObject* kwds) noexcept
    {
        auto tuple_size = PyTuple_Size(args);

        if ((tuple_size == 0) && (!kwds))
        {
            self->obj = {};
            return 0;
        }

        PyObject* _XmlNamespace{};
        PyObject* _Namespace{};

        static const char* kwlist[] = {"xml_namespace", "namespace", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "OO", const_cast<char**>(kwlist), &_XmlNamespace, &_Namespace))
        {
            return -1;
        }

        try
        {
            self->obj.XmlNamespace = py::convert_to<winrt::hstring>(_XmlNamespace);
            self->obj.Namespace = py::convert_to<winrt::hstring>(_Namespace);

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static void _dealloc_XmlnsDefinition(py::wrapper::Microsoft::UI::Xaml::Markup::XmlnsDefinition* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_XmlnsDefinition(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Markup::XmlnsDefinition>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyMethodDef _methods_XmlnsDefinition[] = {
        { "_assign_array_", _assign_array_XmlnsDefinition, METH_O | METH_STATIC, nullptr },
        { }};

    static PyObject* XmlnsDefinition_get_XmlNamespace(py::wrapper::Microsoft::UI::Xaml::Markup::XmlnsDefinition* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.XmlNamespace);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int XmlnsDefinition_set_XmlNamespace(py::wrapper::Microsoft::UI::Xaml::Markup::XmlnsDefinition* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.XmlNamespace = py::convert_to<winrt::hstring>(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* XmlnsDefinition_get_Namespace(py::wrapper::Microsoft::UI::Xaml::Markup::XmlnsDefinition* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Namespace);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int XmlnsDefinition_set_Namespace(py::wrapper::Microsoft::UI::Xaml::Markup::XmlnsDefinition* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.Namespace = py::convert_to<winrt::hstring>(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyGetSetDef _getset_XmlnsDefinition[] = {
        { "xml_namespace", reinterpret_cast<getter>(XmlnsDefinition_get_XmlNamespace), reinterpret_cast<setter>(XmlnsDefinition_set_XmlNamespace), nullptr, nullptr },
        { "namespace", reinterpret_cast<getter>(XmlnsDefinition_get_Namespace), reinterpret_cast<setter>(XmlnsDefinition_set_Namespace), nullptr, nullptr },
        { }};

    static PyObject* _richcompare_XmlnsDefinition(py::wrapper::Microsoft::UI::Xaml::Markup::XmlnsDefinition* self, PyObject* other, int op) noexcept
    {
        try
        {
            auto _other = py::convert_to<winrt::Microsoft::UI::Xaml::Markup::XmlnsDefinition>(other);

            if (op == Py_EQ)
            {
                if (self->obj == _other)
                {
                    Py_RETURN_TRUE;
                }

                Py_RETURN_FALSE;
            }

            if (op == Py_NE)
            {
                if (self->obj != _other)
                {
                    Py_RETURN_TRUE;
                }

                Py_RETURN_FALSE;
            }

            Py_RETURN_NOTIMPLEMENTED;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _repr_XmlnsDefinition(PyObject* self) noexcept
    {
        py::pyobj_handle XmlNamespace{PyObject_GetAttrString(self, "xml_namespace")};
        if (!XmlNamespace)
        {
            return nullptr;
        }

        py::pyobj_handle Namespace{PyObject_GetAttrString(self, "namespace")};
        if (!Namespace)
        {
            return nullptr;
        }

        return PyUnicode_FromFormat("XmlnsDefinition(xml_namespace=%R, namespace=%R)", XmlNamespace.get(), Namespace.get());
    }

    static PyType_Slot _type_slots_XmlnsDefinition[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_XmlnsDefinition) },
        { Py_tp_init, reinterpret_cast<void*>(_init_XmlnsDefinition) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_XmlnsDefinition) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_XmlnsDefinition) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_XmlnsDefinition) },
        { Py_tp_richcompare, reinterpret_cast<void*>(_richcompare_XmlnsDefinition) },
        { Py_tp_repr, reinterpret_cast<void*>(_repr_XmlnsDefinition) },
        { }};

    static PyType_Spec type_spec_XmlnsDefinition = {
        "winrt._winrt_microsoft_ui_xaml_markup.XmlnsDefinition",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Markup::XmlnsDefinition),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_XmlnsDefinition};

    // ----- Microsoft.UI.Xaml.Markup Initialization --------------------

    PyDoc_STRVAR(module_doc, "Microsoft.UI.Xaml.Markup");

    static PyModuleDef module_def = {
        PyModuleDef_HEAD_INIT,
        "_winrt_microsoft_ui_xaml_markup",
        module_doc,
        0,
        nullptr,
        nullptr,
        nullptr,
        nullptr,
        nullptr};
} // py::cpp::Microsoft::UI::Xaml::Markup

PyMODINIT_FUNC PyInit__winrt_microsoft_ui_xaml_markup(void) noexcept
{
    using namespace py::cpp::Microsoft::UI::Xaml::Markup;

    if (py::import_winrt_runtime() == -1)
    {
        return nullptr;
    }

    py::pyobj_handle module{PyModule_Create(&module_def)};

    if (!module)
    {
        return nullptr;
    }

    auto inspectable_meta_type = py::get_inspectable_meta_type();
    if (!inspectable_meta_type)
    {
        return nullptr;
    }

    auto object_type = py::get_object_type();
    if (!object_type)
    {
        return nullptr;
    }

    py::pyobj_handle object_bases{PyTuple_Pack(1, object_type)};

    if (!object_bases)
    {
        return nullptr;
    }

    py::pyobj_handle MarkupExtension_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(inspectable_meta_type))};
    if (!MarkupExtension_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_MarkupExtension_Static{PyType_FromSpecWithBases(&type_spec_MarkupExtension_Static, MarkupExtension_Static_bases.get())};
    if (!type_MarkupExtension_Static)
    {
        return nullptr;
    }

    py::pytype_handle MarkupExtension_type{py::register_python_type(module.get(), &type_spec_MarkupExtension, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_MarkupExtension_Static.get()))};
    if (!MarkupExtension_type)
    {
        return nullptr;
    }

    py::pytype_handle ProvideValueTargetProperty_type{py::register_python_type(module.get(), &type_spec_ProvideValueTargetProperty, object_bases.get(), inspectable_meta_type)};
    if (!ProvideValueTargetProperty_type)
    {
        return nullptr;
    }

    py::pyobj_handle XamlBinaryWriter_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(inspectable_meta_type))};
    if (!XamlBinaryWriter_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_XamlBinaryWriter_Static{PyType_FromSpecWithBases(&type_spec_XamlBinaryWriter_Static, XamlBinaryWriter_Static_bases.get())};
    if (!type_XamlBinaryWriter_Static)
    {
        return nullptr;
    }

    py::pytype_handle XamlBinaryWriter_type{py::register_python_type(module.get(), &type_spec_XamlBinaryWriter, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_XamlBinaryWriter_Static.get()))};
    if (!XamlBinaryWriter_type)
    {
        return nullptr;
    }

    py::pyobj_handle XamlBindingHelper_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(inspectable_meta_type))};
    if (!XamlBindingHelper_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_XamlBindingHelper_Static{PyType_FromSpecWithBases(&type_spec_XamlBindingHelper_Static, XamlBindingHelper_Static_bases.get())};
    if (!type_XamlBindingHelper_Static)
    {
        return nullptr;
    }

    py::pytype_handle XamlBindingHelper_type{py::register_python_type(module.get(), &type_spec_XamlBindingHelper, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_XamlBindingHelper_Static.get()))};
    if (!XamlBindingHelper_type)
    {
        return nullptr;
    }

    py::pyobj_handle XamlMarkupHelper_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(inspectable_meta_type))};
    if (!XamlMarkupHelper_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_XamlMarkupHelper_Static{PyType_FromSpecWithBases(&type_spec_XamlMarkupHelper_Static, XamlMarkupHelper_Static_bases.get())};
    if (!type_XamlMarkupHelper_Static)
    {
        return nullptr;
    }

    py::pytype_handle XamlMarkupHelper_type{py::register_python_type(module.get(), &type_spec_XamlMarkupHelper, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_XamlMarkupHelper_Static.get()))};
    if (!XamlMarkupHelper_type)
    {
        return nullptr;
    }

    py::pyobj_handle XamlReader_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(inspectable_meta_type))};
    if (!XamlReader_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_XamlReader_Static{PyType_FromSpecWithBases(&type_spec_XamlReader_Static, XamlReader_Static_bases.get())};
    if (!type_XamlReader_Static)
    {
        return nullptr;
    }

    py::pytype_handle XamlReader_type{py::register_python_type(module.get(), &type_spec_XamlReader, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_XamlReader_Static.get()))};
    if (!XamlReader_type)
    {
        return nullptr;
    }

    py::pytype_handle IComponentConnector_type{py::register_python_type(module.get(), &type_spec_IComponentConnector, object_bases.get(), nullptr)};
    if (!IComponentConnector_type)
    {
        return nullptr;
    }

    py::pytype_handle ImplementsIComponentConnector_type{py::register_python_type(module.get(), &type_spec_ImplementsIComponentConnector, nullptr, inspectable_meta_type)};
    if (!ImplementsIComponentConnector_type)
    {
        return nullptr;
    }

    if (PyModule_AddType(module.get(), ImplementsIComponentConnector_type.get()) == -1)
    {
        return nullptr;
    }

    py::pytype_handle IDataTemplateComponent_type{py::register_python_type(module.get(), &type_spec_IDataTemplateComponent, object_bases.get(), nullptr)};
    if (!IDataTemplateComponent_type)
    {
        return nullptr;
    }

    py::pytype_handle ImplementsIDataTemplateComponent_type{py::register_python_type(module.get(), &type_spec_ImplementsIDataTemplateComponent, nullptr, inspectable_meta_type)};
    if (!ImplementsIDataTemplateComponent_type)
    {
        return nullptr;
    }

    if (PyModule_AddType(module.get(), ImplementsIDataTemplateComponent_type.get()) == -1)
    {
        return nullptr;
    }

    py::pytype_handle IProvideValueTarget_type{py::register_python_type(module.get(), &type_spec_IProvideValueTarget, object_bases.get(), nullptr)};
    if (!IProvideValueTarget_type)
    {
        return nullptr;
    }

    py::pytype_handle ImplementsIProvideValueTarget_type{py::register_python_type(module.get(), &type_spec_ImplementsIProvideValueTarget, nullptr, inspectable_meta_type)};
    if (!ImplementsIProvideValueTarget_type)
    {
        return nullptr;
    }

    if (PyModule_AddType(module.get(), ImplementsIProvideValueTarget_type.get()) == -1)
    {
        return nullptr;
    }

    py::pytype_handle IRootObjectProvider_type{py::register_python_type(module.get(), &type_spec_IRootObjectProvider, object_bases.get(), nullptr)};
    if (!IRootObjectProvider_type)
    {
        return nullptr;
    }

    py::pytype_handle ImplementsIRootObjectProvider_type{py::register_python_type(module.get(), &type_spec_ImplementsIRootObjectProvider, nullptr, inspectable_meta_type)};
    if (!ImplementsIRootObjectProvider_type)
    {
        return nullptr;
    }

    if (PyModule_AddType(module.get(), ImplementsIRootObjectProvider_type.get()) == -1)
    {
        return nullptr;
    }

    py::pytype_handle IUriContext_type{py::register_python_type(module.get(), &type_spec_IUriContext, object_bases.get(), nullptr)};
    if (!IUriContext_type)
    {
        return nullptr;
    }

    py::pytype_handle ImplementsIUriContext_type{py::register_python_type(module.get(), &type_spec_ImplementsIUriContext, nullptr, inspectable_meta_type)};
    if (!ImplementsIUriContext_type)
    {
        return nullptr;
    }

    if (PyModule_AddType(module.get(), ImplementsIUriContext_type.get()) == -1)
    {
        return nullptr;
    }

    py::pytype_handle IXamlBindScopeDiagnostics_type{py::register_python_type(module.get(), &type_spec_IXamlBindScopeDiagnostics, object_bases.get(), nullptr)};
    if (!IXamlBindScopeDiagnostics_type)
    {
        return nullptr;
    }

    py::pytype_handle ImplementsIXamlBindScopeDiagnostics_type{py::register_python_type(module.get(), &type_spec_ImplementsIXamlBindScopeDiagnostics, nullptr, inspectable_meta_type)};
    if (!ImplementsIXamlBindScopeDiagnostics_type)
    {
        return nullptr;
    }

    if (PyModule_AddType(module.get(), ImplementsIXamlBindScopeDiagnostics_type.get()) == -1)
    {
        return nullptr;
    }

    py::pytype_handle IXamlMember_type{py::register_python_type(module.get(), &type_spec_IXamlMember, object_bases.get(), nullptr)};
    if (!IXamlMember_type)
    {
        return nullptr;
    }

    py::pytype_handle ImplementsIXamlMember_type{py::register_python_type(module.get(), &type_spec_ImplementsIXamlMember, nullptr, inspectable_meta_type)};
    if (!ImplementsIXamlMember_type)
    {
        return nullptr;
    }

    if (PyModule_AddType(module.get(), ImplementsIXamlMember_type.get()) == -1)
    {
        return nullptr;
    }

    py::pytype_handle IXamlMetadataProvider_type{py::register_python_type(module.get(), &type_spec_IXamlMetadataProvider, object_bases.get(), nullptr)};
    if (!IXamlMetadataProvider_type)
    {
        return nullptr;
    }

    py::pytype_handle ImplementsIXamlMetadataProvider_type{py::register_python_type(module.get(), &type_spec_ImplementsIXamlMetadataProvider, nullptr, inspectable_meta_type)};
    if (!ImplementsIXamlMetadataProvider_type)
    {
        return nullptr;
    }

    if (PyModule_AddType(module.get(), ImplementsIXamlMetadataProvider_type.get()) == -1)
    {
        return nullptr;
    }

    py::pytype_handle IXamlType_type{py::register_python_type(module.get(), &type_spec_IXamlType, object_bases.get(), nullptr)};
    if (!IXamlType_type)
    {
        return nullptr;
    }

    py::pytype_handle ImplementsIXamlType_type{py::register_python_type(module.get(), &type_spec_ImplementsIXamlType, nullptr, inspectable_meta_type)};
    if (!ImplementsIXamlType_type)
    {
        return nullptr;
    }

    if (PyModule_AddType(module.get(), ImplementsIXamlType_type.get()) == -1)
    {
        return nullptr;
    }

    py::pytype_handle IXamlTypeResolver_type{py::register_python_type(module.get(), &type_spec_IXamlTypeResolver, object_bases.get(), nullptr)};
    if (!IXamlTypeResolver_type)
    {
        return nullptr;
    }

    py::pytype_handle ImplementsIXamlTypeResolver_type{py::register_python_type(module.get(), &type_spec_ImplementsIXamlTypeResolver, nullptr, inspectable_meta_type)};
    if (!ImplementsIXamlTypeResolver_type)
    {
        return nullptr;
    }

    if (PyModule_AddType(module.get(), ImplementsIXamlTypeResolver_type.get()) == -1)
    {
        return nullptr;
    }

    py::pytype_handle XamlBinaryWriterErrorInformation_type{py::register_python_type(module.get(), &type_spec_XamlBinaryWriterErrorInformation, nullptr, nullptr)};
    if (!XamlBinaryWriterErrorInformation_type)
    {
        return nullptr;
    }

    py::pytype_handle XmlnsDefinition_type{py::register_python_type(module.get(), &type_spec_XmlnsDefinition, nullptr, nullptr)};
    if (!XmlnsDefinition_type)
    {
        return nullptr;
    }


    return module.detach();
}
