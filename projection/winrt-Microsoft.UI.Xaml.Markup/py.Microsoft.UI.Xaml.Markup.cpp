// WARNING: Please don't edit this file. It was generated by Python/WinRT v0.0.0

#include "py.Microsoft.UI.Xaml.Markup.h"


namespace py::cpp::Microsoft::UI::Xaml::Markup
{
    // ----- MarkupExtension class --------------------

    static PyObject* _new_MarkupExtension(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Microsoft::UI::Xaml::Markup::MarkupExtension instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MarkupExtension(py::wrapper::Microsoft::UI::Xaml::Markup::MarkupExtension* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MarkupExtension_ProvideValue(py::wrapper::Microsoft::UI::Xaml::Markup::MarkupExtension* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Markup.MarkupExtension", L"ProvideValue", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.ProvideValue());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Markup.MarkupExtension", L"ProvideValue", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::IXamlServiceProvider>(args, 0);

                return py::convert(self->obj.ProvideValue(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_MarkupExtension(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Markup::MarkupExtension>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MarkupExtension(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Markup::MarkupExtension>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MarkupExtension[] = {
        { "provide_value", reinterpret_cast<PyCFunction>(MarkupExtension_ProvideValue), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_MarkupExtension, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MarkupExtension), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MarkupExtension[] = {
        { }
    };

    static PyType_Slot _type_slots_MarkupExtension[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MarkupExtension) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MarkupExtension) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MarkupExtension) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MarkupExtension) },
        { },
    };

    static PyType_Spec type_spec_MarkupExtension =
    {
        "winrt._winrt_microsoft_ui_xaml_markup.MarkupExtension",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Markup::MarkupExtension),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MarkupExtension
    };

    // ----- ProvideValueTargetProperty class --------------------

    static PyObject* _new_ProvideValueTargetProperty(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Microsoft::UI::Xaml::Markup::ProvideValueTargetProperty instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ProvideValueTargetProperty(py::wrapper::Microsoft::UI::Xaml::Markup::ProvideValueTargetProperty* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ProvideValueTargetProperty_get_DeclaringType(py::wrapper::Microsoft::UI::Xaml::Markup::ProvideValueTargetProperty* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Markup.ProvideValueTargetProperty", L"DeclaringType"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DeclaringType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProvideValueTargetProperty_get_Name(py::wrapper::Microsoft::UI::Xaml::Markup::ProvideValueTargetProperty* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Markup.ProvideValueTargetProperty", L"Name"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Name());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProvideValueTargetProperty_get_Type(py::wrapper::Microsoft::UI::Xaml::Markup::ProvideValueTargetProperty* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Markup.ProvideValueTargetProperty", L"Type"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Type());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ProvideValueTargetProperty(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Markup::ProvideValueTargetProperty>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ProvideValueTargetProperty(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Markup::ProvideValueTargetProperty>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ProvideValueTargetProperty[] = {
        { "_assign_array_", _assign_array_ProvideValueTargetProperty, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ProvideValueTargetProperty), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ProvideValueTargetProperty[] = {
        { "declaring_type", reinterpret_cast<getter>(ProvideValueTargetProperty_get_DeclaringType), nullptr, nullptr, nullptr },
        { "name", reinterpret_cast<getter>(ProvideValueTargetProperty_get_Name), nullptr, nullptr, nullptr },
        { "type", reinterpret_cast<getter>(ProvideValueTargetProperty_get_Type), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ProvideValueTargetProperty[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ProvideValueTargetProperty) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ProvideValueTargetProperty) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ProvideValueTargetProperty) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ProvideValueTargetProperty) },
        { },
    };

    static PyType_Spec type_spec_ProvideValueTargetProperty =
    {
        "winrt._winrt_microsoft_ui_xaml_markup.ProvideValueTargetProperty",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Markup::ProvideValueTargetProperty),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ProvideValueTargetProperty
    };

    // ----- XamlBinaryWriter class --------------------

    static PyObject* _new_XamlBinaryWriter(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Markup::XamlBinaryWriter>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Markup::XamlBinaryWriter>::type_name);
        return nullptr;
    }

    static void _dealloc_XamlBinaryWriter(py::wrapper::Microsoft::UI::Xaml::Markup::XamlBinaryWriter* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* XamlBinaryWriter_Write(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Markup.XamlBinaryWriter", L"Write", 3))
            {
                py::set_arg_count_version_error(3);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IVector<winrt::Windows::Storage::Streams::IRandomAccessStream>>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IVector<winrt::Windows::Storage::Streams::IRandomAccessStream>>(args, 1);
                auto param2 = py::convert_to<winrt::Microsoft::UI::Xaml::Markup::IXamlMetadataProvider>(args, 2);

                return py::convert(winrt::Microsoft::UI::Xaml::Markup::XamlBinaryWriter::Write(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_XamlBinaryWriter(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Markup::XamlBinaryWriter>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_XamlBinaryWriter(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Markup::XamlBinaryWriter>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_XamlBinaryWriter[] = {
        { "_assign_array_", _assign_array_XamlBinaryWriter, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_XamlBinaryWriter), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_XamlBinaryWriter[] = {
        { }
    };

    static PyType_Slot _type_slots_XamlBinaryWriter[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_XamlBinaryWriter) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_XamlBinaryWriter) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_XamlBinaryWriter) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_XamlBinaryWriter) },
        { },
    };

    static PyType_Spec type_spec_XamlBinaryWriter =
    {
        "winrt._winrt_microsoft_ui_xaml_markup.XamlBinaryWriter",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Markup::XamlBinaryWriter),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_XamlBinaryWriter
    };

    static PyGetSetDef getset_XamlBinaryWriter_Static[] = {
        { }
    };

    static PyMethodDef methods_XamlBinaryWriter_Static[] = {
        { "write", reinterpret_cast<PyCFunction>(XamlBinaryWriter_Write), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_XamlBinaryWriter_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_XamlBinaryWriter_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_XamlBinaryWriter_Static) },
        { }
    };

    static PyType_Spec type_spec_XamlBinaryWriter_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_markup.XamlBinaryWriter_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_XamlBinaryWriter_Static
    };

    // ----- XamlBindingHelper class --------------------

    static PyObject* _new_XamlBindingHelper(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Markup::XamlBindingHelper>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Markup::XamlBindingHelper>::type_name);
        return nullptr;
    }

    static void _dealloc_XamlBindingHelper(py::wrapper::Microsoft::UI::Xaml::Markup::XamlBindingHelper* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* XamlBindingHelper_ConvertValue(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Markup.XamlBindingHelper", L"ConvertValue", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Interop::TypeName>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 1);

                return py::convert(winrt::Microsoft::UI::Xaml::Markup::XamlBindingHelper::ConvertValue(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* XamlBindingHelper_GetDataTemplateComponent(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Markup.XamlBindingHelper", L"GetDataTemplateComponent", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(args, 0);

                return py::convert(winrt::Microsoft::UI::Xaml::Markup::XamlBindingHelper::GetDataTemplateComponent(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* XamlBindingHelper_ResumeRendering(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Markup.XamlBindingHelper", L"ResumeRendering", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::UIElement>(args, 0);

                winrt::Microsoft::UI::Xaml::Markup::XamlBindingHelper::ResumeRendering(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* XamlBindingHelper_SetDataTemplateComponent(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Markup.XamlBindingHelper", L"SetDataTemplateComponent", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::UI::Xaml::Markup::IDataTemplateComponent>(args, 1);

                winrt::Microsoft::UI::Xaml::Markup::XamlBindingHelper::SetDataTemplateComponent(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* XamlBindingHelper_SetPropertyFromBoolean(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Markup.XamlBindingHelper", L"SetPropertyFromBoolean", 3))
            {
                py::set_arg_count_version_error(3);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyProperty>(args, 1);
                auto param2 = py::convert_to<bool>(args, 2);

                winrt::Microsoft::UI::Xaml::Markup::XamlBindingHelper::SetPropertyFromBoolean(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* XamlBindingHelper_SetPropertyFromByte(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Markup.XamlBindingHelper", L"SetPropertyFromByte", 3))
            {
                py::set_arg_count_version_error(3);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyProperty>(args, 1);
                auto param2 = py::convert_to<uint8_t>(args, 2);

                winrt::Microsoft::UI::Xaml::Markup::XamlBindingHelper::SetPropertyFromByte(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* XamlBindingHelper_SetPropertyFromChar16(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Markup.XamlBindingHelper", L"SetPropertyFromChar16", 3))
            {
                py::set_arg_count_version_error(3);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyProperty>(args, 1);
                auto param2 = py::convert_to<char16_t>(args, 2);

                winrt::Microsoft::UI::Xaml::Markup::XamlBindingHelper::SetPropertyFromChar16(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* XamlBindingHelper_SetPropertyFromDateTime(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Markup.XamlBindingHelper", L"SetPropertyFromDateTime", 3))
            {
                py::set_arg_count_version_error(3);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyProperty>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::DateTime>(args, 2);

                winrt::Microsoft::UI::Xaml::Markup::XamlBindingHelper::SetPropertyFromDateTime(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* XamlBindingHelper_SetPropertyFromDouble(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Markup.XamlBindingHelper", L"SetPropertyFromDouble", 3))
            {
                py::set_arg_count_version_error(3);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyProperty>(args, 1);
                auto param2 = py::convert_to<double>(args, 2);

                winrt::Microsoft::UI::Xaml::Markup::XamlBindingHelper::SetPropertyFromDouble(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* XamlBindingHelper_SetPropertyFromInt32(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Markup.XamlBindingHelper", L"SetPropertyFromInt32", 3))
            {
                py::set_arg_count_version_error(3);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyProperty>(args, 1);
                auto param2 = py::convert_to<int32_t>(args, 2);

                winrt::Microsoft::UI::Xaml::Markup::XamlBindingHelper::SetPropertyFromInt32(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* XamlBindingHelper_SetPropertyFromInt64(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Markup.XamlBindingHelper", L"SetPropertyFromInt64", 3))
            {
                py::set_arg_count_version_error(3);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyProperty>(args, 1);
                auto param2 = py::convert_to<int64_t>(args, 2);

                winrt::Microsoft::UI::Xaml::Markup::XamlBindingHelper::SetPropertyFromInt64(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* XamlBindingHelper_SetPropertyFromObject(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Markup.XamlBindingHelper", L"SetPropertyFromObject", 3))
            {
                py::set_arg_count_version_error(3);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyProperty>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 2);

                winrt::Microsoft::UI::Xaml::Markup::XamlBindingHelper::SetPropertyFromObject(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* XamlBindingHelper_SetPropertyFromPoint(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Markup.XamlBindingHelper", L"SetPropertyFromPoint", 3))
            {
                py::set_arg_count_version_error(3);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyProperty>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Point>(args, 2);

                winrt::Microsoft::UI::Xaml::Markup::XamlBindingHelper::SetPropertyFromPoint(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* XamlBindingHelper_SetPropertyFromRect(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Markup.XamlBindingHelper", L"SetPropertyFromRect", 3))
            {
                py::set_arg_count_version_error(3);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyProperty>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Rect>(args, 2);

                winrt::Microsoft::UI::Xaml::Markup::XamlBindingHelper::SetPropertyFromRect(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* XamlBindingHelper_SetPropertyFromSingle(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Markup.XamlBindingHelper", L"SetPropertyFromSingle", 3))
            {
                py::set_arg_count_version_error(3);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyProperty>(args, 1);
                auto param2 = py::convert_to<float>(args, 2);

                winrt::Microsoft::UI::Xaml::Markup::XamlBindingHelper::SetPropertyFromSingle(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* XamlBindingHelper_SetPropertyFromSize(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Markup.XamlBindingHelper", L"SetPropertyFromSize", 3))
            {
                py::set_arg_count_version_error(3);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyProperty>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Size>(args, 2);

                winrt::Microsoft::UI::Xaml::Markup::XamlBindingHelper::SetPropertyFromSize(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* XamlBindingHelper_SetPropertyFromString(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Markup.XamlBindingHelper", L"SetPropertyFromString", 3))
            {
                py::set_arg_count_version_error(3);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyProperty>(args, 1);
                auto param2 = py::convert_to<winrt::hstring>(args, 2);

                winrt::Microsoft::UI::Xaml::Markup::XamlBindingHelper::SetPropertyFromString(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* XamlBindingHelper_SetPropertyFromTimeSpan(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Markup.XamlBindingHelper", L"SetPropertyFromTimeSpan", 3))
            {
                py::set_arg_count_version_error(3);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyProperty>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(args, 2);

                winrt::Microsoft::UI::Xaml::Markup::XamlBindingHelper::SetPropertyFromTimeSpan(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* XamlBindingHelper_SetPropertyFromUInt32(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Markup.XamlBindingHelper", L"SetPropertyFromUInt32", 3))
            {
                py::set_arg_count_version_error(3);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyProperty>(args, 1);
                auto param2 = py::convert_to<uint32_t>(args, 2);

                winrt::Microsoft::UI::Xaml::Markup::XamlBindingHelper::SetPropertyFromUInt32(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* XamlBindingHelper_SetPropertyFromUInt64(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Markup.XamlBindingHelper", L"SetPropertyFromUInt64", 3))
            {
                py::set_arg_count_version_error(3);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyProperty>(args, 1);
                auto param2 = py::convert_to<uint64_t>(args, 2);

                winrt::Microsoft::UI::Xaml::Markup::XamlBindingHelper::SetPropertyFromUInt64(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* XamlBindingHelper_SetPropertyFromUri(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Markup.XamlBindingHelper", L"SetPropertyFromUri", 3))
            {
                py::set_arg_count_version_error(3);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyProperty>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 2);

                winrt::Microsoft::UI::Xaml::Markup::XamlBindingHelper::SetPropertyFromUri(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* XamlBindingHelper_SuspendRendering(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Markup.XamlBindingHelper", L"SuspendRendering", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::UIElement>(args, 0);

                winrt::Microsoft::UI::Xaml::Markup::XamlBindingHelper::SuspendRendering(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* XamlBindingHelper_get_DataTemplateComponentProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Markup.XamlBindingHelper", L"DataTemplateComponentProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Markup::XamlBindingHelper::DataTemplateComponentProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_XamlBindingHelper(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Markup::XamlBindingHelper>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_XamlBindingHelper(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Markup::XamlBindingHelper>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_XamlBindingHelper[] = {
        { "_assign_array_", _assign_array_XamlBindingHelper, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_XamlBindingHelper), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_XamlBindingHelper[] = {
        { }
    };

    static PyType_Slot _type_slots_XamlBindingHelper[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_XamlBindingHelper) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_XamlBindingHelper) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_XamlBindingHelper) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_XamlBindingHelper) },
        { },
    };

    static PyType_Spec type_spec_XamlBindingHelper =
    {
        "winrt._winrt_microsoft_ui_xaml_markup.XamlBindingHelper",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Markup::XamlBindingHelper),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_XamlBindingHelper
    };

    static PyGetSetDef getset_XamlBindingHelper_Static[] = {
        { "data_template_component_property", reinterpret_cast<getter>(XamlBindingHelper_get_DataTemplateComponentProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_XamlBindingHelper_Static[] = {
        { "convert_value", reinterpret_cast<PyCFunction>(XamlBindingHelper_ConvertValue), METH_VARARGS, nullptr },
        { "get_data_template_component", reinterpret_cast<PyCFunction>(XamlBindingHelper_GetDataTemplateComponent), METH_VARARGS, nullptr },
        { "resume_rendering", reinterpret_cast<PyCFunction>(XamlBindingHelper_ResumeRendering), METH_VARARGS, nullptr },
        { "set_data_template_component", reinterpret_cast<PyCFunction>(XamlBindingHelper_SetDataTemplateComponent), METH_VARARGS, nullptr },
        { "set_property_from_boolean", reinterpret_cast<PyCFunction>(XamlBindingHelper_SetPropertyFromBoolean), METH_VARARGS, nullptr },
        { "set_property_from_byte", reinterpret_cast<PyCFunction>(XamlBindingHelper_SetPropertyFromByte), METH_VARARGS, nullptr },
        { "set_property_from_char16", reinterpret_cast<PyCFunction>(XamlBindingHelper_SetPropertyFromChar16), METH_VARARGS, nullptr },
        { "set_property_from_date_time", reinterpret_cast<PyCFunction>(XamlBindingHelper_SetPropertyFromDateTime), METH_VARARGS, nullptr },
        { "set_property_from_double", reinterpret_cast<PyCFunction>(XamlBindingHelper_SetPropertyFromDouble), METH_VARARGS, nullptr },
        { "set_property_from_int32", reinterpret_cast<PyCFunction>(XamlBindingHelper_SetPropertyFromInt32), METH_VARARGS, nullptr },
        { "set_property_from_int64", reinterpret_cast<PyCFunction>(XamlBindingHelper_SetPropertyFromInt64), METH_VARARGS, nullptr },
        { "set_property_from_object", reinterpret_cast<PyCFunction>(XamlBindingHelper_SetPropertyFromObject), METH_VARARGS, nullptr },
        { "set_property_from_point", reinterpret_cast<PyCFunction>(XamlBindingHelper_SetPropertyFromPoint), METH_VARARGS, nullptr },
        { "set_property_from_rect", reinterpret_cast<PyCFunction>(XamlBindingHelper_SetPropertyFromRect), METH_VARARGS, nullptr },
        { "set_property_from_single", reinterpret_cast<PyCFunction>(XamlBindingHelper_SetPropertyFromSingle), METH_VARARGS, nullptr },
        { "set_property_from_size", reinterpret_cast<PyCFunction>(XamlBindingHelper_SetPropertyFromSize), METH_VARARGS, nullptr },
        { "set_property_from_string", reinterpret_cast<PyCFunction>(XamlBindingHelper_SetPropertyFromString), METH_VARARGS, nullptr },
        { "set_property_from_time_span", reinterpret_cast<PyCFunction>(XamlBindingHelper_SetPropertyFromTimeSpan), METH_VARARGS, nullptr },
        { "set_property_from_uint32", reinterpret_cast<PyCFunction>(XamlBindingHelper_SetPropertyFromUInt32), METH_VARARGS, nullptr },
        { "set_property_from_uint64", reinterpret_cast<PyCFunction>(XamlBindingHelper_SetPropertyFromUInt64), METH_VARARGS, nullptr },
        { "set_property_from_uri", reinterpret_cast<PyCFunction>(XamlBindingHelper_SetPropertyFromUri), METH_VARARGS, nullptr },
        { "suspend_rendering", reinterpret_cast<PyCFunction>(XamlBindingHelper_SuspendRendering), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_XamlBindingHelper_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_XamlBindingHelper_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_XamlBindingHelper_Static) },
        { }
    };

    static PyType_Spec type_spec_XamlBindingHelper_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_markup.XamlBindingHelper_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_XamlBindingHelper_Static
    };

    // ----- XamlMarkupHelper class --------------------

    static PyObject* _new_XamlMarkupHelper(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Markup::XamlMarkupHelper>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Markup::XamlMarkupHelper>::type_name);
        return nullptr;
    }

    static void _dealloc_XamlMarkupHelper(py::wrapper::Microsoft::UI::Xaml::Markup::XamlMarkupHelper* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* XamlMarkupHelper_UnloadObject(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Markup.XamlMarkupHelper", L"UnloadObject", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(args, 0);

                winrt::Microsoft::UI::Xaml::Markup::XamlMarkupHelper::UnloadObject(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_XamlMarkupHelper(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Markup::XamlMarkupHelper>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_XamlMarkupHelper(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Markup::XamlMarkupHelper>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_XamlMarkupHelper[] = {
        { "_assign_array_", _assign_array_XamlMarkupHelper, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_XamlMarkupHelper), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_XamlMarkupHelper[] = {
        { }
    };

    static PyType_Slot _type_slots_XamlMarkupHelper[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_XamlMarkupHelper) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_XamlMarkupHelper) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_XamlMarkupHelper) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_XamlMarkupHelper) },
        { },
    };

    static PyType_Spec type_spec_XamlMarkupHelper =
    {
        "winrt._winrt_microsoft_ui_xaml_markup.XamlMarkupHelper",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Markup::XamlMarkupHelper),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_XamlMarkupHelper
    };

    static PyGetSetDef getset_XamlMarkupHelper_Static[] = {
        { }
    };

    static PyMethodDef methods_XamlMarkupHelper_Static[] = {
        { "unload_object", reinterpret_cast<PyCFunction>(XamlMarkupHelper_UnloadObject), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_XamlMarkupHelper_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_XamlMarkupHelper_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_XamlMarkupHelper_Static) },
        { }
    };

    static PyType_Spec type_spec_XamlMarkupHelper_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_markup.XamlMarkupHelper_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_XamlMarkupHelper_Static
    };

    // ----- XamlReader class --------------------

    static PyObject* _new_XamlReader(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Markup::XamlReader>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Markup::XamlReader>::type_name);
        return nullptr;
    }

    static void _dealloc_XamlReader(py::wrapper::Microsoft::UI::Xaml::Markup::XamlReader* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* XamlReader_Load(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Markup.XamlReader", L"Load", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Microsoft::UI::Xaml::Markup::XamlReader::Load(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* XamlReader_LoadWithInitialTemplateValidation(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Markup.XamlReader", L"LoadWithInitialTemplateValidation", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Microsoft::UI::Xaml::Markup::XamlReader::LoadWithInitialTemplateValidation(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_XamlReader(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Markup::XamlReader>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_XamlReader(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Markup::XamlReader>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_XamlReader[] = {
        { "_assign_array_", _assign_array_XamlReader, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_XamlReader), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_XamlReader[] = {
        { }
    };

    static PyType_Slot _type_slots_XamlReader[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_XamlReader) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_XamlReader) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_XamlReader) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_XamlReader) },
        { },
    };

    static PyType_Spec type_spec_XamlReader =
    {
        "winrt._winrt_microsoft_ui_xaml_markup.XamlReader",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Markup::XamlReader),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_XamlReader
    };

    static PyGetSetDef getset_XamlReader_Static[] = {
        { }
    };

    static PyMethodDef methods_XamlReader_Static[] = {
        { "load", reinterpret_cast<PyCFunction>(XamlReader_Load), METH_VARARGS, nullptr },
        { "load_with_initial_template_validation", reinterpret_cast<PyCFunction>(XamlReader_LoadWithInitialTemplateValidation), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_XamlReader_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_XamlReader_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_XamlReader_Static) },
        { }
    };

    static PyType_Spec type_spec_XamlReader_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_markup.XamlReader_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_XamlReader_Static
    };

    // ----- IComponentConnector interface --------------------

    static PyObject* _new_IComponentConnector(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Markup::IComponentConnector>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Markup::IComponentConnector>::type_name);
        return nullptr;
    }

    static void _dealloc_IComponentConnector(py::wrapper::Microsoft::UI::Xaml::Markup::IComponentConnector* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IComponentConnector_Connect(py::wrapper::Microsoft::UI::Xaml::Markup::IComponentConnector* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Markup.IComponentConnector", L"Connect", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<int32_t>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 1);

                self->obj.Connect(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IComponentConnector_GetBindingConnector(py::wrapper::Microsoft::UI::Xaml::Markup::IComponentConnector* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Markup.IComponentConnector", L"GetBindingConnector", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<int32_t>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 1);

                return py::convert(self->obj.GetBindingConnector(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_IComponentConnector(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Markup::IComponentConnector>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IComponentConnector(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Markup::IComponentConnector>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IComponentConnector[] = {
        { "connect", reinterpret_cast<PyCFunction>(IComponentConnector_Connect), METH_VARARGS, nullptr },
        { "get_binding_connector", reinterpret_cast<PyCFunction>(IComponentConnector_GetBindingConnector), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_IComponentConnector, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IComponentConnector), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IComponentConnector[] = {
        { }
    };

    static PyType_Slot _type_slots_IComponentConnector[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_IComponentConnector) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IComponentConnector) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IComponentConnector) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IComponentConnector) },
        { },
    };

    static PyType_Spec type_spec_IComponentConnector =
    {
        "winrt._winrt_microsoft_ui_xaml_markup.IComponentConnector",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Markup::IComponentConnector),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IComponentConnector
    };

    // ----- IDataTemplateComponent interface --------------------

    static PyObject* _new_IDataTemplateComponent(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Markup::IDataTemplateComponent>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Markup::IDataTemplateComponent>::type_name);
        return nullptr;
    }

    static void _dealloc_IDataTemplateComponent(py::wrapper::Microsoft::UI::Xaml::Markup::IDataTemplateComponent* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IDataTemplateComponent_ProcessBindings(py::wrapper::Microsoft::UI::Xaml::Markup::IDataTemplateComponent* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Markup.IDataTemplateComponent", L"ProcessBindings", 3))
            {
                py::set_arg_count_version_error(3);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 0);
                auto param1 = py::convert_to<int32_t>(args, 1);
                auto param2 = py::convert_to<int32_t>(args, 2);
                int32_t param3 {  };

                self->obj.ProcessBindings(param0, param1, param2, param3);

                py::pyobj_handle out3{ py::convert(param3) };
                if (!out3)
                {
                    return nullptr;
                }
                return out3.detach();
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IDataTemplateComponent_Recycle(py::wrapper::Microsoft::UI::Xaml::Markup::IDataTemplateComponent* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Markup.IDataTemplateComponent", L"Recycle", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Recycle();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_IDataTemplateComponent(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Markup::IDataTemplateComponent>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IDataTemplateComponent(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Markup::IDataTemplateComponent>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IDataTemplateComponent[] = {
        { "process_bindings", reinterpret_cast<PyCFunction>(IDataTemplateComponent_ProcessBindings), METH_VARARGS, nullptr },
        { "recycle", reinterpret_cast<PyCFunction>(IDataTemplateComponent_Recycle), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_IDataTemplateComponent, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IDataTemplateComponent), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IDataTemplateComponent[] = {
        { }
    };

    static PyType_Slot _type_slots_IDataTemplateComponent[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_IDataTemplateComponent) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IDataTemplateComponent) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IDataTemplateComponent) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IDataTemplateComponent) },
        { },
    };

    static PyType_Spec type_spec_IDataTemplateComponent =
    {
        "winrt._winrt_microsoft_ui_xaml_markup.IDataTemplateComponent",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Markup::IDataTemplateComponent),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IDataTemplateComponent
    };

    // ----- IProvideValueTarget interface --------------------

    static PyObject* _new_IProvideValueTarget(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Markup::IProvideValueTarget>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Markup::IProvideValueTarget>::type_name);
        return nullptr;
    }

    static void _dealloc_IProvideValueTarget(py::wrapper::Microsoft::UI::Xaml::Markup::IProvideValueTarget* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IProvideValueTarget_get_TargetObject(py::wrapper::Microsoft::UI::Xaml::Markup::IProvideValueTarget* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Markup.IProvideValueTarget", L"TargetObject"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TargetObject());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IProvideValueTarget_get_TargetProperty(py::wrapper::Microsoft::UI::Xaml::Markup::IProvideValueTarget* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Markup.IProvideValueTarget", L"TargetProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TargetProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_IProvideValueTarget(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Markup::IProvideValueTarget>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IProvideValueTarget(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Markup::IProvideValueTarget>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IProvideValueTarget[] = {
        { "_assign_array_", _assign_array_IProvideValueTarget, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IProvideValueTarget), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IProvideValueTarget[] = {
        { "target_object", reinterpret_cast<getter>(IProvideValueTarget_get_TargetObject), nullptr, nullptr, nullptr },
        { "target_property", reinterpret_cast<getter>(IProvideValueTarget_get_TargetProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IProvideValueTarget[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_IProvideValueTarget) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IProvideValueTarget) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IProvideValueTarget) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IProvideValueTarget) },
        { },
    };

    static PyType_Spec type_spec_IProvideValueTarget =
    {
        "winrt._winrt_microsoft_ui_xaml_markup.IProvideValueTarget",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Markup::IProvideValueTarget),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IProvideValueTarget
    };

    // ----- IRootObjectProvider interface --------------------

    static PyObject* _new_IRootObjectProvider(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Markup::IRootObjectProvider>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Markup::IRootObjectProvider>::type_name);
        return nullptr;
    }

    static void _dealloc_IRootObjectProvider(py::wrapper::Microsoft::UI::Xaml::Markup::IRootObjectProvider* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IRootObjectProvider_get_RootObject(py::wrapper::Microsoft::UI::Xaml::Markup::IRootObjectProvider* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Markup.IRootObjectProvider", L"RootObject"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RootObject());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_IRootObjectProvider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Markup::IRootObjectProvider>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IRootObjectProvider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Markup::IRootObjectProvider>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IRootObjectProvider[] = {
        { "_assign_array_", _assign_array_IRootObjectProvider, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IRootObjectProvider), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IRootObjectProvider[] = {
        { "root_object", reinterpret_cast<getter>(IRootObjectProvider_get_RootObject), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IRootObjectProvider[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_IRootObjectProvider) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IRootObjectProvider) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IRootObjectProvider) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IRootObjectProvider) },
        { },
    };

    static PyType_Spec type_spec_IRootObjectProvider =
    {
        "winrt._winrt_microsoft_ui_xaml_markup.IRootObjectProvider",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Markup::IRootObjectProvider),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IRootObjectProvider
    };

    // ----- IUriContext interface --------------------

    static PyObject* _new_IUriContext(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Markup::IUriContext>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Markup::IUriContext>::type_name);
        return nullptr;
    }

    static void _dealloc_IUriContext(py::wrapper::Microsoft::UI::Xaml::Markup::IUriContext* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IUriContext_get_BaseUri(py::wrapper::Microsoft::UI::Xaml::Markup::IUriContext* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Markup.IUriContext", L"BaseUri"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.BaseUri());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_IUriContext(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Markup::IUriContext>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IUriContext(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Markup::IUriContext>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IUriContext[] = {
        { "_assign_array_", _assign_array_IUriContext, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IUriContext), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IUriContext[] = {
        { "base_uri", reinterpret_cast<getter>(IUriContext_get_BaseUri), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IUriContext[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_IUriContext) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IUriContext) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IUriContext) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IUriContext) },
        { },
    };

    static PyType_Spec type_spec_IUriContext =
    {
        "winrt._winrt_microsoft_ui_xaml_markup.IUriContext",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Markup::IUriContext),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IUriContext
    };

    // ----- IXamlBindScopeDiagnostics interface --------------------

    static PyObject* _new_IXamlBindScopeDiagnostics(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Markup::IXamlBindScopeDiagnostics>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Markup::IXamlBindScopeDiagnostics>::type_name);
        return nullptr;
    }

    static void _dealloc_IXamlBindScopeDiagnostics(py::wrapper::Microsoft::UI::Xaml::Markup::IXamlBindScopeDiagnostics* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IXamlBindScopeDiagnostics_Disable(py::wrapper::Microsoft::UI::Xaml::Markup::IXamlBindScopeDiagnostics* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Markup.IXamlBindScopeDiagnostics", L"Disable", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<int32_t>(args, 0);
                auto param1 = py::convert_to<int32_t>(args, 1);

                self->obj.Disable(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_IXamlBindScopeDiagnostics(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Markup::IXamlBindScopeDiagnostics>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IXamlBindScopeDiagnostics(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Markup::IXamlBindScopeDiagnostics>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IXamlBindScopeDiagnostics[] = {
        { "disable", reinterpret_cast<PyCFunction>(IXamlBindScopeDiagnostics_Disable), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_IXamlBindScopeDiagnostics, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IXamlBindScopeDiagnostics), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IXamlBindScopeDiagnostics[] = {
        { }
    };

    static PyType_Slot _type_slots_IXamlBindScopeDiagnostics[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_IXamlBindScopeDiagnostics) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IXamlBindScopeDiagnostics) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IXamlBindScopeDiagnostics) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IXamlBindScopeDiagnostics) },
        { },
    };

    static PyType_Spec type_spec_IXamlBindScopeDiagnostics =
    {
        "winrt._winrt_microsoft_ui_xaml_markup.IXamlBindScopeDiagnostics",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Markup::IXamlBindScopeDiagnostics),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IXamlBindScopeDiagnostics
    };

    // ----- IXamlMember interface --------------------

    static PyObject* _new_IXamlMember(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Markup::IXamlMember>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Markup::IXamlMember>::type_name);
        return nullptr;
    }

    static void _dealloc_IXamlMember(py::wrapper::Microsoft::UI::Xaml::Markup::IXamlMember* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IXamlMember_GetValue(py::wrapper::Microsoft::UI::Xaml::Markup::IXamlMember* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Markup.IXamlMember", L"GetValue", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 0);

                return py::convert(self->obj.GetValue(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IXamlMember_SetValue(py::wrapper::Microsoft::UI::Xaml::Markup::IXamlMember* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Markup.IXamlMember", L"SetValue", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 1);

                self->obj.SetValue(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IXamlMember_get_IsAttachable(py::wrapper::Microsoft::UI::Xaml::Markup::IXamlMember* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Markup.IXamlMember", L"IsAttachable"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsAttachable());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IXamlMember_get_IsDependencyProperty(py::wrapper::Microsoft::UI::Xaml::Markup::IXamlMember* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Markup.IXamlMember", L"IsDependencyProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsDependencyProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IXamlMember_get_IsReadOnly(py::wrapper::Microsoft::UI::Xaml::Markup::IXamlMember* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Markup.IXamlMember", L"IsReadOnly"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsReadOnly());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IXamlMember_get_Name(py::wrapper::Microsoft::UI::Xaml::Markup::IXamlMember* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Markup.IXamlMember", L"Name"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Name());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IXamlMember_get_TargetType(py::wrapper::Microsoft::UI::Xaml::Markup::IXamlMember* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Markup.IXamlMember", L"TargetType"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TargetType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IXamlMember_get_Type(py::wrapper::Microsoft::UI::Xaml::Markup::IXamlMember* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Markup.IXamlMember", L"Type"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Type());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_IXamlMember(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Markup::IXamlMember>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IXamlMember(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Markup::IXamlMember>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IXamlMember[] = {
        { "get_value", reinterpret_cast<PyCFunction>(IXamlMember_GetValue), METH_VARARGS, nullptr },
        { "set_value", reinterpret_cast<PyCFunction>(IXamlMember_SetValue), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_IXamlMember, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IXamlMember), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IXamlMember[] = {
        { "is_attachable", reinterpret_cast<getter>(IXamlMember_get_IsAttachable), nullptr, nullptr, nullptr },
        { "is_dependency_property", reinterpret_cast<getter>(IXamlMember_get_IsDependencyProperty), nullptr, nullptr, nullptr },
        { "is_read_only", reinterpret_cast<getter>(IXamlMember_get_IsReadOnly), nullptr, nullptr, nullptr },
        { "name", reinterpret_cast<getter>(IXamlMember_get_Name), nullptr, nullptr, nullptr },
        { "target_type", reinterpret_cast<getter>(IXamlMember_get_TargetType), nullptr, nullptr, nullptr },
        { "type", reinterpret_cast<getter>(IXamlMember_get_Type), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IXamlMember[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_IXamlMember) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IXamlMember) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IXamlMember) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IXamlMember) },
        { },
    };

    static PyType_Spec type_spec_IXamlMember =
    {
        "winrt._winrt_microsoft_ui_xaml_markup.IXamlMember",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Markup::IXamlMember),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IXamlMember
    };

    // ----- IXamlMetadataProvider interface --------------------

    static PyObject* _new_IXamlMetadataProvider(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Markup::IXamlMetadataProvider>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Markup::IXamlMetadataProvider>::type_name);
        return nullptr;
    }

    static void _dealloc_IXamlMetadataProvider(py::wrapper::Microsoft::UI::Xaml::Markup::IXamlMetadataProvider* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IXamlMetadataProvider_GetXamlType(py::wrapper::Microsoft::UI::Xaml::Markup::IXamlMetadataProvider* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Markup.IXamlMetadataProvider", L"GetXamlType", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Interop::TypeName>(args, 0);

                return py::convert(self->obj.GetXamlType(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IXamlMetadataProvider_GetXmlnsDefinitions(py::wrapper::Microsoft::UI::Xaml::Markup::IXamlMetadataProvider* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Markup.IXamlMetadataProvider", L"GetXmlnsDefinitions", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetXmlnsDefinitions());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_IXamlMetadataProvider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Markup::IXamlMetadataProvider>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IXamlMetadataProvider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Markup::IXamlMetadataProvider>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IXamlMetadataProvider[] = {
        { "get_xaml_type", reinterpret_cast<PyCFunction>(IXamlMetadataProvider_GetXamlType), METH_VARARGS, nullptr },
        { "get_xmlns_definitions", reinterpret_cast<PyCFunction>(IXamlMetadataProvider_GetXmlnsDefinitions), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_IXamlMetadataProvider, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IXamlMetadataProvider), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IXamlMetadataProvider[] = {
        { }
    };

    static PyType_Slot _type_slots_IXamlMetadataProvider[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_IXamlMetadataProvider) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IXamlMetadataProvider) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IXamlMetadataProvider) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IXamlMetadataProvider) },
        { },
    };

    static PyType_Spec type_spec_IXamlMetadataProvider =
    {
        "winrt._winrt_microsoft_ui_xaml_markup.IXamlMetadataProvider",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Markup::IXamlMetadataProvider),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IXamlMetadataProvider
    };

    // ----- IXamlType interface --------------------

    static PyObject* _new_IXamlType(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Markup::IXamlType>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Markup::IXamlType>::type_name);
        return nullptr;
    }

    static void _dealloc_IXamlType(py::wrapper::Microsoft::UI::Xaml::Markup::IXamlType* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IXamlType_ActivateInstance(py::wrapper::Microsoft::UI::Xaml::Markup::IXamlType* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Markup.IXamlType", L"ActivateInstance", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.ActivateInstance());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IXamlType_AddToMap(py::wrapper::Microsoft::UI::Xaml::Markup::IXamlType* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Markup.IXamlType", L"AddToMap", 3))
            {
                py::set_arg_count_version_error(3);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 2);

                self->obj.AddToMap(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IXamlType_AddToVector(py::wrapper::Microsoft::UI::Xaml::Markup::IXamlType* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Markup.IXamlType", L"AddToVector", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 1);

                self->obj.AddToVector(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IXamlType_CreateFromString(py::wrapper::Microsoft::UI::Xaml::Markup::IXamlType* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Markup.IXamlType", L"CreateFromString", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.CreateFromString(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IXamlType_GetMember(py::wrapper::Microsoft::UI::Xaml::Markup::IXamlType* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Markup.IXamlType", L"GetMember", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.GetMember(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IXamlType_RunInitializer(py::wrapper::Microsoft::UI::Xaml::Markup::IXamlType* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Markup.IXamlType", L"RunInitializer", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.RunInitializer();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IXamlType_get_BaseType(py::wrapper::Microsoft::UI::Xaml::Markup::IXamlType* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Markup.IXamlType", L"BaseType"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.BaseType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IXamlType_get_BoxedType(py::wrapper::Microsoft::UI::Xaml::Markup::IXamlType* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Markup.IXamlType", L"BoxedType"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.BoxedType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IXamlType_get_ContentProperty(py::wrapper::Microsoft::UI::Xaml::Markup::IXamlType* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Markup.IXamlType", L"ContentProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ContentProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IXamlType_get_FullName(py::wrapper::Microsoft::UI::Xaml::Markup::IXamlType* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Markup.IXamlType", L"FullName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.FullName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IXamlType_get_IsArray(py::wrapper::Microsoft::UI::Xaml::Markup::IXamlType* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Markup.IXamlType", L"IsArray"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsArray());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IXamlType_get_IsBindable(py::wrapper::Microsoft::UI::Xaml::Markup::IXamlType* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Markup.IXamlType", L"IsBindable"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsBindable());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IXamlType_get_IsCollection(py::wrapper::Microsoft::UI::Xaml::Markup::IXamlType* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Markup.IXamlType", L"IsCollection"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsCollection());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IXamlType_get_IsConstructible(py::wrapper::Microsoft::UI::Xaml::Markup::IXamlType* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Markup.IXamlType", L"IsConstructible"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsConstructible());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IXamlType_get_IsDictionary(py::wrapper::Microsoft::UI::Xaml::Markup::IXamlType* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Markup.IXamlType", L"IsDictionary"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsDictionary());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IXamlType_get_IsMarkupExtension(py::wrapper::Microsoft::UI::Xaml::Markup::IXamlType* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Markup.IXamlType", L"IsMarkupExtension"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsMarkupExtension());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IXamlType_get_ItemType(py::wrapper::Microsoft::UI::Xaml::Markup::IXamlType* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Markup.IXamlType", L"ItemType"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ItemType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IXamlType_get_KeyType(py::wrapper::Microsoft::UI::Xaml::Markup::IXamlType* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Markup.IXamlType", L"KeyType"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.KeyType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IXamlType_get_UnderlyingType(py::wrapper::Microsoft::UI::Xaml::Markup::IXamlType* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Markup.IXamlType", L"UnderlyingType"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.UnderlyingType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_IXamlType(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Markup::IXamlType>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IXamlType(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Markup::IXamlType>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IXamlType[] = {
        { "activate_instance", reinterpret_cast<PyCFunction>(IXamlType_ActivateInstance), METH_VARARGS, nullptr },
        { "add_to_map", reinterpret_cast<PyCFunction>(IXamlType_AddToMap), METH_VARARGS, nullptr },
        { "add_to_vector", reinterpret_cast<PyCFunction>(IXamlType_AddToVector), METH_VARARGS, nullptr },
        { "create_from_string", reinterpret_cast<PyCFunction>(IXamlType_CreateFromString), METH_VARARGS, nullptr },
        { "get_member", reinterpret_cast<PyCFunction>(IXamlType_GetMember), METH_VARARGS, nullptr },
        { "run_initializer", reinterpret_cast<PyCFunction>(IXamlType_RunInitializer), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_IXamlType, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IXamlType), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IXamlType[] = {
        { "base_type", reinterpret_cast<getter>(IXamlType_get_BaseType), nullptr, nullptr, nullptr },
        { "boxed_type", reinterpret_cast<getter>(IXamlType_get_BoxedType), nullptr, nullptr, nullptr },
        { "content_property", reinterpret_cast<getter>(IXamlType_get_ContentProperty), nullptr, nullptr, nullptr },
        { "full_name", reinterpret_cast<getter>(IXamlType_get_FullName), nullptr, nullptr, nullptr },
        { "is_array", reinterpret_cast<getter>(IXamlType_get_IsArray), nullptr, nullptr, nullptr },
        { "is_bindable", reinterpret_cast<getter>(IXamlType_get_IsBindable), nullptr, nullptr, nullptr },
        { "is_collection", reinterpret_cast<getter>(IXamlType_get_IsCollection), nullptr, nullptr, nullptr },
        { "is_constructible", reinterpret_cast<getter>(IXamlType_get_IsConstructible), nullptr, nullptr, nullptr },
        { "is_dictionary", reinterpret_cast<getter>(IXamlType_get_IsDictionary), nullptr, nullptr, nullptr },
        { "is_markup_extension", reinterpret_cast<getter>(IXamlType_get_IsMarkupExtension), nullptr, nullptr, nullptr },
        { "item_type", reinterpret_cast<getter>(IXamlType_get_ItemType), nullptr, nullptr, nullptr },
        { "key_type", reinterpret_cast<getter>(IXamlType_get_KeyType), nullptr, nullptr, nullptr },
        { "underlying_type", reinterpret_cast<getter>(IXamlType_get_UnderlyingType), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IXamlType[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_IXamlType) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IXamlType) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IXamlType) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IXamlType) },
        { },
    };

    static PyType_Spec type_spec_IXamlType =
    {
        "winrt._winrt_microsoft_ui_xaml_markup.IXamlType",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Markup::IXamlType),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IXamlType
    };

    // ----- IXamlTypeResolver interface --------------------

    static PyObject* _new_IXamlTypeResolver(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Markup::IXamlTypeResolver>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Markup::IXamlTypeResolver>::type_name);
        return nullptr;
    }

    static void _dealloc_IXamlTypeResolver(py::wrapper::Microsoft::UI::Xaml::Markup::IXamlTypeResolver* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IXamlTypeResolver_Resolve(py::wrapper::Microsoft::UI::Xaml::Markup::IXamlTypeResolver* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Markup.IXamlTypeResolver", L"Resolve", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.Resolve(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_IXamlTypeResolver(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Markup::IXamlTypeResolver>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IXamlTypeResolver(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Markup::IXamlTypeResolver>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IXamlTypeResolver[] = {
        { "resolve", reinterpret_cast<PyCFunction>(IXamlTypeResolver_Resolve), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_IXamlTypeResolver, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IXamlTypeResolver), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IXamlTypeResolver[] = {
        { }
    };

    static PyType_Slot _type_slots_IXamlTypeResolver[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_IXamlTypeResolver) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IXamlTypeResolver) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IXamlTypeResolver) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IXamlTypeResolver) },
        { },
    };

    static PyType_Spec type_spec_IXamlTypeResolver =
    {
        "winrt._winrt_microsoft_ui_xaml_markup.IXamlTypeResolver",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Markup::IXamlTypeResolver),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IXamlTypeResolver
    };

    // ----- XamlBinaryWriterErrorInformation struct --------------------

    winrt_struct_wrapper<winrt::Microsoft::UI::Xaml::Markup::XamlBinaryWriterErrorInformation>* _new_XamlBinaryWriterErrorInformation(PyTypeObject* subclass, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        auto self = reinterpret_cast<winrt_struct_wrapper<winrt::Microsoft::UI::Xaml::Markup::XamlBinaryWriterErrorInformation>*>(subclass->tp_alloc(subclass, 0));

        if (!self)
        {
            return nullptr;
        }

        std::construct_at(&self->obj);

        return self;
    }

    int _init_XamlBinaryWriterErrorInformation(winrt_struct_wrapper<winrt::Microsoft::UI::Xaml::Markup::XamlBinaryWriterErrorInformation>* self, PyObject* args, PyObject* kwds) noexcept
    {
        auto tuple_size = PyTuple_Size(args);

        if ((tuple_size == 0) && (kwds == nullptr))
        {
            self->obj = {};
            return 0;
        }

        uint32_t _InputStreamIndex{};
        uint32_t _LineNumber{};
        uint32_t _LinePosition{};

        static const char* kwlist[] = {"input_stream_index", "line_number", "line_position", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "III", const_cast<char**>(kwlist), &_InputStreamIndex, &_LineNumber, &_LinePosition))
        {
            return -1;
        }

        try
        {
            self->obj = {_InputStreamIndex, _LineNumber, _LinePosition};
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static void _dealloc_XamlBinaryWriterErrorInformation(py::wrapper::Microsoft::UI::Xaml::Markup::XamlBinaryWriterErrorInformation* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_XamlBinaryWriterErrorInformation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Markup::XamlBinaryWriterErrorInformation>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyMethodDef _methods_XamlBinaryWriterErrorInformation[] = {
        { "_assign_array_", _assign_array_XamlBinaryWriterErrorInformation, METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyObject* XamlBinaryWriterErrorInformation_get_InputStreamIndex(py::wrapper::Microsoft::UI::Xaml::Markup::XamlBinaryWriterErrorInformation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.InputStreamIndex);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int XamlBinaryWriterErrorInformation_set_InputStreamIndex(py::wrapper::Microsoft::UI::Xaml::Markup::XamlBinaryWriterErrorInformation* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.InputStreamIndex = py::converter<uint32_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* XamlBinaryWriterErrorInformation_get_LineNumber(py::wrapper::Microsoft::UI::Xaml::Markup::XamlBinaryWriterErrorInformation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.LineNumber);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int XamlBinaryWriterErrorInformation_set_LineNumber(py::wrapper::Microsoft::UI::Xaml::Markup::XamlBinaryWriterErrorInformation* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.LineNumber = py::converter<uint32_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* XamlBinaryWriterErrorInformation_get_LinePosition(py::wrapper::Microsoft::UI::Xaml::Markup::XamlBinaryWriterErrorInformation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.LinePosition);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int XamlBinaryWriterErrorInformation_set_LinePosition(py::wrapper::Microsoft::UI::Xaml::Markup::XamlBinaryWriterErrorInformation* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.LinePosition = py::converter<uint32_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyGetSetDef _getset_XamlBinaryWriterErrorInformation[] = {
        { "input_stream_index", reinterpret_cast<getter>(XamlBinaryWriterErrorInformation_get_InputStreamIndex), reinterpret_cast<setter>(XamlBinaryWriterErrorInformation_set_InputStreamIndex), nullptr, nullptr },
        { "line_number", reinterpret_cast<getter>(XamlBinaryWriterErrorInformation_get_LineNumber), reinterpret_cast<setter>(XamlBinaryWriterErrorInformation_set_LineNumber), nullptr, nullptr },
        { "line_position", reinterpret_cast<getter>(XamlBinaryWriterErrorInformation_get_LinePosition), reinterpret_cast<setter>(XamlBinaryWriterErrorInformation_set_LinePosition), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_XamlBinaryWriterErrorInformation[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_XamlBinaryWriterErrorInformation) },
        { Py_tp_init, reinterpret_cast<void*>(_init_XamlBinaryWriterErrorInformation) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_XamlBinaryWriterErrorInformation) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_XamlBinaryWriterErrorInformation) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_XamlBinaryWriterErrorInformation) },
        { },
    };

    static PyType_Spec type_spec_XamlBinaryWriterErrorInformation =
    {
        "winrt._winrt_microsoft_ui_xaml_markup.XamlBinaryWriterErrorInformation",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Markup::XamlBinaryWriterErrorInformation),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_XamlBinaryWriterErrorInformation
    };

    // ----- XmlnsDefinition struct --------------------

    winrt_struct_wrapper<winrt::Microsoft::UI::Xaml::Markup::XmlnsDefinition>* _new_XmlnsDefinition(PyTypeObject* subclass, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        auto self = reinterpret_cast<winrt_struct_wrapper<winrt::Microsoft::UI::Xaml::Markup::XmlnsDefinition>*>(subclass->tp_alloc(subclass, 0));

        if (!self)
        {
            return nullptr;
        }

        std::construct_at(&self->obj);

        return self;
    }

    int _init_XmlnsDefinition(winrt_struct_wrapper<winrt::Microsoft::UI::Xaml::Markup::XmlnsDefinition>* self, PyObject* args, PyObject* kwds) noexcept
    {
        auto tuple_size = PyTuple_Size(args);

        if ((tuple_size == 0) && (kwds == nullptr))
        {
            self->obj = {};
            return 0;
        }

        winrt::hstring _XmlNamespace{};
        winrt::hstring _Namespace{};

        static const char* kwlist[] = {"xml_namespace", "namespace", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "uu", const_cast<char**>(kwlist), &_XmlNamespace, &_Namespace))
        {
            return -1;
        }

        try
        {
            self->obj = {_XmlNamespace, _Namespace};
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static void _dealloc_XmlnsDefinition(py::wrapper::Microsoft::UI::Xaml::Markup::XmlnsDefinition* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_XmlnsDefinition(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Markup::XmlnsDefinition>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyMethodDef _methods_XmlnsDefinition[] = {
        { "_assign_array_", _assign_array_XmlnsDefinition, METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyObject* XmlnsDefinition_get_XmlNamespace(py::wrapper::Microsoft::UI::Xaml::Markup::XmlnsDefinition* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.XmlNamespace);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int XmlnsDefinition_set_XmlNamespace(py::wrapper::Microsoft::UI::Xaml::Markup::XmlnsDefinition* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.XmlNamespace = py::converter<winrt::hstring>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* XmlnsDefinition_get_Namespace(py::wrapper::Microsoft::UI::Xaml::Markup::XmlnsDefinition* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Namespace);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int XmlnsDefinition_set_Namespace(py::wrapper::Microsoft::UI::Xaml::Markup::XmlnsDefinition* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.Namespace = py::converter<winrt::hstring>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyGetSetDef _getset_XmlnsDefinition[] = {
        { "xml_namespace", reinterpret_cast<getter>(XmlnsDefinition_get_XmlNamespace), reinterpret_cast<setter>(XmlnsDefinition_set_XmlNamespace), nullptr, nullptr },
        { "namespace", reinterpret_cast<getter>(XmlnsDefinition_get_Namespace), reinterpret_cast<setter>(XmlnsDefinition_set_Namespace), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_XmlnsDefinition[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_XmlnsDefinition) },
        { Py_tp_init, reinterpret_cast<void*>(_init_XmlnsDefinition) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_XmlnsDefinition) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_XmlnsDefinition) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_XmlnsDefinition) },
        { },
    };

    static PyType_Spec type_spec_XmlnsDefinition =
    {
        "winrt._winrt_microsoft_ui_xaml_markup.XmlnsDefinition",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Markup::XmlnsDefinition),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_XmlnsDefinition
    };

    // ----- Microsoft.UI.Xaml.Markup Initialization --------------------
    PyDoc_STRVAR(module_doc, "Microsoft::UI::Xaml::Markup");


    static PyModuleDef module_def
        = {PyModuleDef_HEAD_INIT,
           "_winrt_microsoft_ui_xaml_markup",
           module_doc,
           0,
           nullptr,
           nullptr,
           nullptr,
           nullptr,
           nullptr};

} // py::cpp::Microsoft::UI::Xaml::Markup

PyMODINIT_FUNC PyInit__winrt_microsoft_ui_xaml_markup(void) noexcept
{
    using namespace py::cpp::Microsoft::UI::Xaml::Markup;

    if (py::import_winrt_runtime() == -1)
    {
        return nullptr;
    }

    py::pyobj_handle module{PyModule_Create(&module_def)};

    if (!module)
    {
        return nullptr;
    }

    auto object_type = py::get_object_type();
    if (!object_type)
    {
        return nullptr;
    }

    py::pyobj_handle object_bases{PyTuple_Pack(1, object_type)};

    if (!object_bases)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_MarkupExtension, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ProvideValueTargetProperty, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_XamlBinaryWriter_Static{PyType_FromSpec(&type_spec_XamlBinaryWriter_Static)};
    if (!type_XamlBinaryWriter_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_XamlBinaryWriter, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_XamlBinaryWriter_Static.get())) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_XamlBindingHelper_Static{PyType_FromSpec(&type_spec_XamlBindingHelper_Static)};
    if (!type_XamlBindingHelper_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_XamlBindingHelper, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_XamlBindingHelper_Static.get())) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_XamlMarkupHelper_Static{PyType_FromSpec(&type_spec_XamlMarkupHelper_Static)};
    if (!type_XamlMarkupHelper_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_XamlMarkupHelper, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_XamlMarkupHelper_Static.get())) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_XamlReader_Static{PyType_FromSpec(&type_spec_XamlReader_Static)};
    if (!type_XamlReader_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_XamlReader, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_XamlReader_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_IComponentConnector, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_IDataTemplateComponent, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_IProvideValueTarget, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_IRootObjectProvider, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_IUriContext, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_IXamlBindScopeDiagnostics, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_IXamlMember, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_IXamlMetadataProvider, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_IXamlType, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_IXamlTypeResolver, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_XamlBinaryWriterErrorInformation, nullptr, nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_XmlnsDefinition, nullptr, nullptr) == -1)
    {
        return nullptr;
    }


    return module.detach();
}
