// WARNING: Please don't edit this file. It was generated by Python/WinRT v2.0.0-beta.2

#include "py.Windows.ApplicationModel.Payments.h"


namespace py::cpp::Windows::ApplicationModel::Payments
{
    // ----- PaymentAddress class --------------------

    static PyObject* _new_PaymentAddress(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::ApplicationModel::Payments::PaymentAddress instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_PaymentAddress(py::wrapper::Windows::ApplicationModel::Payments::PaymentAddress* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PaymentAddress_get_SortingCode(py::wrapper::Windows::ApplicationModel::Payments::PaymentAddress* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentAddress", L"SortingCode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SortingCode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PaymentAddress_put_SortingCode(py::wrapper::Windows::ApplicationModel::Payments::PaymentAddress* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentAddress", L"SortingCode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.SortingCode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PaymentAddress_get_Region(py::wrapper::Windows::ApplicationModel::Payments::PaymentAddress* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentAddress", L"Region"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Region());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PaymentAddress_put_Region(py::wrapper::Windows::ApplicationModel::Payments::PaymentAddress* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentAddress", L"Region"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Region(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PaymentAddress_get_Recipient(py::wrapper::Windows::ApplicationModel::Payments::PaymentAddress* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentAddress", L"Recipient"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Recipient());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PaymentAddress_put_Recipient(py::wrapper::Windows::ApplicationModel::Payments::PaymentAddress* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentAddress", L"Recipient"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Recipient(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PaymentAddress_get_PostalCode(py::wrapper::Windows::ApplicationModel::Payments::PaymentAddress* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentAddress", L"PostalCode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PostalCode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PaymentAddress_put_PostalCode(py::wrapper::Windows::ApplicationModel::Payments::PaymentAddress* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentAddress", L"PostalCode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.PostalCode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PaymentAddress_get_PhoneNumber(py::wrapper::Windows::ApplicationModel::Payments::PaymentAddress* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentAddress", L"PhoneNumber"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PhoneNumber());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PaymentAddress_put_PhoneNumber(py::wrapper::Windows::ApplicationModel::Payments::PaymentAddress* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentAddress", L"PhoneNumber"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.PhoneNumber(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PaymentAddress_get_Organization(py::wrapper::Windows::ApplicationModel::Payments::PaymentAddress* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentAddress", L"Organization"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Organization());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PaymentAddress_put_Organization(py::wrapper::Windows::ApplicationModel::Payments::PaymentAddress* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentAddress", L"Organization"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Organization(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PaymentAddress_get_LanguageCode(py::wrapper::Windows::ApplicationModel::Payments::PaymentAddress* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentAddress", L"LanguageCode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.LanguageCode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PaymentAddress_put_LanguageCode(py::wrapper::Windows::ApplicationModel::Payments::PaymentAddress* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentAddress", L"LanguageCode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.LanguageCode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PaymentAddress_get_DependentLocality(py::wrapper::Windows::ApplicationModel::Payments::PaymentAddress* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentAddress", L"DependentLocality"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DependentLocality());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PaymentAddress_put_DependentLocality(py::wrapper::Windows::ApplicationModel::Payments::PaymentAddress* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentAddress", L"DependentLocality"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.DependentLocality(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PaymentAddress_get_Country(py::wrapper::Windows::ApplicationModel::Payments::PaymentAddress* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentAddress", L"Country"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Country());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PaymentAddress_put_Country(py::wrapper::Windows::ApplicationModel::Payments::PaymentAddress* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentAddress", L"Country"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Country(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PaymentAddress_get_City(py::wrapper::Windows::ApplicationModel::Payments::PaymentAddress* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentAddress", L"City"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.City());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PaymentAddress_put_City(py::wrapper::Windows::ApplicationModel::Payments::PaymentAddress* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentAddress", L"City"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.City(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PaymentAddress_get_AddressLines(py::wrapper::Windows::ApplicationModel::Payments::PaymentAddress* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentAddress", L"AddressLines"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AddressLines());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PaymentAddress_put_AddressLines(py::wrapper::Windows::ApplicationModel::Payments::PaymentAddress* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentAddress", L"AddressLines"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IVectorView<winrt::hstring>>(arg);

            self->obj.AddressLines(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PaymentAddress_get_Properties(py::wrapper::Windows::ApplicationModel::Payments::PaymentAddress* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentAddress", L"Properties"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Properties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PaymentAddress(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Payments::PaymentAddress>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PaymentAddress(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Payments::PaymentAddress>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PaymentAddress[] = {
        { "_assign_array_", _assign_array_PaymentAddress, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PaymentAddress), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PaymentAddress[] = {
        { "sorting_code", reinterpret_cast<getter>(PaymentAddress_get_SortingCode), reinterpret_cast<setter>(PaymentAddress_put_SortingCode), nullptr, nullptr },
        { "region", reinterpret_cast<getter>(PaymentAddress_get_Region), reinterpret_cast<setter>(PaymentAddress_put_Region), nullptr, nullptr },
        { "recipient", reinterpret_cast<getter>(PaymentAddress_get_Recipient), reinterpret_cast<setter>(PaymentAddress_put_Recipient), nullptr, nullptr },
        { "postal_code", reinterpret_cast<getter>(PaymentAddress_get_PostalCode), reinterpret_cast<setter>(PaymentAddress_put_PostalCode), nullptr, nullptr },
        { "phone_number", reinterpret_cast<getter>(PaymentAddress_get_PhoneNumber), reinterpret_cast<setter>(PaymentAddress_put_PhoneNumber), nullptr, nullptr },
        { "organization", reinterpret_cast<getter>(PaymentAddress_get_Organization), reinterpret_cast<setter>(PaymentAddress_put_Organization), nullptr, nullptr },
        { "language_code", reinterpret_cast<getter>(PaymentAddress_get_LanguageCode), reinterpret_cast<setter>(PaymentAddress_put_LanguageCode), nullptr, nullptr },
        { "dependent_locality", reinterpret_cast<getter>(PaymentAddress_get_DependentLocality), reinterpret_cast<setter>(PaymentAddress_put_DependentLocality), nullptr, nullptr },
        { "country", reinterpret_cast<getter>(PaymentAddress_get_Country), reinterpret_cast<setter>(PaymentAddress_put_Country), nullptr, nullptr },
        { "city", reinterpret_cast<getter>(PaymentAddress_get_City), reinterpret_cast<setter>(PaymentAddress_put_City), nullptr, nullptr },
        { "address_lines", reinterpret_cast<getter>(PaymentAddress_get_AddressLines), reinterpret_cast<setter>(PaymentAddress_put_AddressLines), nullptr, nullptr },
        { "properties", reinterpret_cast<getter>(PaymentAddress_get_Properties), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PaymentAddress[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PaymentAddress) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PaymentAddress) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PaymentAddress) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PaymentAddress) },
        { },
    };

    static PyType_Spec type_spec_PaymentAddress =
    {
        "winrt._winrt_windows_applicationmodel_payments.PaymentAddress",
        sizeof(py::wrapper::Windows::ApplicationModel::Payments::PaymentAddress),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PaymentAddress
    };

    // ----- PaymentCanMakePaymentResult class --------------------

    static PyObject* _new_PaymentCanMakePaymentResult(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Payments::PaymentCanMakePaymentResultStatus>(args, 0);

                winrt::Windows::ApplicationModel::Payments::PaymentCanMakePaymentResult instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_PaymentCanMakePaymentResult(py::wrapper::Windows::ApplicationModel::Payments::PaymentCanMakePaymentResult* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PaymentCanMakePaymentResult_get_Status(py::wrapper::Windows::ApplicationModel::Payments::PaymentCanMakePaymentResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentCanMakePaymentResult", L"Status"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PaymentCanMakePaymentResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Payments::PaymentCanMakePaymentResult>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PaymentCanMakePaymentResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Payments::PaymentCanMakePaymentResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PaymentCanMakePaymentResult[] = {
        { "_assign_array_", _assign_array_PaymentCanMakePaymentResult, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PaymentCanMakePaymentResult), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PaymentCanMakePaymentResult[] = {
        { "status", reinterpret_cast<getter>(PaymentCanMakePaymentResult_get_Status), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PaymentCanMakePaymentResult[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PaymentCanMakePaymentResult) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PaymentCanMakePaymentResult) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PaymentCanMakePaymentResult) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PaymentCanMakePaymentResult) },
        { },
    };

    static PyType_Spec type_spec_PaymentCanMakePaymentResult =
    {
        "winrt._winrt_windows_applicationmodel_payments.PaymentCanMakePaymentResult",
        sizeof(py::wrapper::Windows::ApplicationModel::Payments::PaymentCanMakePaymentResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PaymentCanMakePaymentResult
    };

    // ----- PaymentCurrencyAmount class --------------------

    static PyObject* _new_PaymentCurrencyAmount(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                winrt::Windows::ApplicationModel::Payments::PaymentCurrencyAmount instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::hstring>(args, 2);

                winrt::Windows::ApplicationModel::Payments::PaymentCurrencyAmount instance{ param0, param1, param2 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_PaymentCurrencyAmount(py::wrapper::Windows::ApplicationModel::Payments::PaymentCurrencyAmount* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PaymentCurrencyAmount_get_Value(py::wrapper::Windows::ApplicationModel::Payments::PaymentCurrencyAmount* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentCurrencyAmount", L"Value"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Value());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PaymentCurrencyAmount_put_Value(py::wrapper::Windows::ApplicationModel::Payments::PaymentCurrencyAmount* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentCurrencyAmount", L"Value"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Value(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PaymentCurrencyAmount_get_CurrencySystem(py::wrapper::Windows::ApplicationModel::Payments::PaymentCurrencyAmount* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentCurrencyAmount", L"CurrencySystem"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CurrencySystem());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PaymentCurrencyAmount_put_CurrencySystem(py::wrapper::Windows::ApplicationModel::Payments::PaymentCurrencyAmount* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentCurrencyAmount", L"CurrencySystem"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.CurrencySystem(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PaymentCurrencyAmount_get_Currency(py::wrapper::Windows::ApplicationModel::Payments::PaymentCurrencyAmount* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentCurrencyAmount", L"Currency"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Currency());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PaymentCurrencyAmount_put_Currency(py::wrapper::Windows::ApplicationModel::Payments::PaymentCurrencyAmount* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentCurrencyAmount", L"Currency"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Currency(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_PaymentCurrencyAmount(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Payments::PaymentCurrencyAmount>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PaymentCurrencyAmount(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Payments::PaymentCurrencyAmount>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PaymentCurrencyAmount[] = {
        { "_assign_array_", _assign_array_PaymentCurrencyAmount, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PaymentCurrencyAmount), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PaymentCurrencyAmount[] = {
        { "value", reinterpret_cast<getter>(PaymentCurrencyAmount_get_Value), reinterpret_cast<setter>(PaymentCurrencyAmount_put_Value), nullptr, nullptr },
        { "currency_system", reinterpret_cast<getter>(PaymentCurrencyAmount_get_CurrencySystem), reinterpret_cast<setter>(PaymentCurrencyAmount_put_CurrencySystem), nullptr, nullptr },
        { "currency", reinterpret_cast<getter>(PaymentCurrencyAmount_get_Currency), reinterpret_cast<setter>(PaymentCurrencyAmount_put_Currency), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PaymentCurrencyAmount[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PaymentCurrencyAmount) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PaymentCurrencyAmount) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PaymentCurrencyAmount) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PaymentCurrencyAmount) },
        { },
    };

    static PyType_Spec type_spec_PaymentCurrencyAmount =
    {
        "winrt._winrt_windows_applicationmodel_payments.PaymentCurrencyAmount",
        sizeof(py::wrapper::Windows::ApplicationModel::Payments::PaymentCurrencyAmount),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PaymentCurrencyAmount
    };

    // ----- PaymentDetails class --------------------

    static PyObject* _new_PaymentDetails(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Payments::PaymentItem>(args, 0);

                winrt::Windows::ApplicationModel::Payments::PaymentDetails instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Payments::PaymentItem>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::ApplicationModel::Payments::PaymentItem>>(args, 1);

                winrt::Windows::ApplicationModel::Payments::PaymentDetails instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 0)
        {
            try
            {
                winrt::Windows::ApplicationModel::Payments::PaymentDetails instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_PaymentDetails(py::wrapper::Windows::ApplicationModel::Payments::PaymentDetails* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PaymentDetails_get_Total(py::wrapper::Windows::ApplicationModel::Payments::PaymentDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentDetails", L"Total"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Total());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PaymentDetails_put_Total(py::wrapper::Windows::ApplicationModel::Payments::PaymentDetails* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentDetails", L"Total"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Payments::PaymentItem>(arg);

            self->obj.Total(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PaymentDetails_get_ShippingOptions(py::wrapper::Windows::ApplicationModel::Payments::PaymentDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentDetails", L"ShippingOptions"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ShippingOptions());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PaymentDetails_put_ShippingOptions(py::wrapper::Windows::ApplicationModel::Payments::PaymentDetails* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentDetails", L"ShippingOptions"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::ApplicationModel::Payments::PaymentShippingOption>>(arg);

            self->obj.ShippingOptions(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PaymentDetails_get_Modifiers(py::wrapper::Windows::ApplicationModel::Payments::PaymentDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentDetails", L"Modifiers"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Modifiers());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PaymentDetails_put_Modifiers(py::wrapper::Windows::ApplicationModel::Payments::PaymentDetails* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentDetails", L"Modifiers"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::ApplicationModel::Payments::PaymentDetailsModifier>>(arg);

            self->obj.Modifiers(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PaymentDetails_get_DisplayItems(py::wrapper::Windows::ApplicationModel::Payments::PaymentDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentDetails", L"DisplayItems"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DisplayItems());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PaymentDetails_put_DisplayItems(py::wrapper::Windows::ApplicationModel::Payments::PaymentDetails* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentDetails", L"DisplayItems"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::ApplicationModel::Payments::PaymentItem>>(arg);

            self->obj.DisplayItems(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_PaymentDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Payments::PaymentDetails>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PaymentDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Payments::PaymentDetails>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PaymentDetails[] = {
        { "_assign_array_", _assign_array_PaymentDetails, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PaymentDetails), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PaymentDetails[] = {
        { "total", reinterpret_cast<getter>(PaymentDetails_get_Total), reinterpret_cast<setter>(PaymentDetails_put_Total), nullptr, nullptr },
        { "shipping_options", reinterpret_cast<getter>(PaymentDetails_get_ShippingOptions), reinterpret_cast<setter>(PaymentDetails_put_ShippingOptions), nullptr, nullptr },
        { "modifiers", reinterpret_cast<getter>(PaymentDetails_get_Modifiers), reinterpret_cast<setter>(PaymentDetails_put_Modifiers), nullptr, nullptr },
        { "display_items", reinterpret_cast<getter>(PaymentDetails_get_DisplayItems), reinterpret_cast<setter>(PaymentDetails_put_DisplayItems), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PaymentDetails[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PaymentDetails) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PaymentDetails) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PaymentDetails) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PaymentDetails) },
        { },
    };

    static PyType_Spec type_spec_PaymentDetails =
    {
        "winrt._winrt_windows_applicationmodel_payments.PaymentDetails",
        sizeof(py::wrapper::Windows::ApplicationModel::Payments::PaymentDetails),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PaymentDetails
    };

    // ----- PaymentDetailsModifier class --------------------

    static PyObject* _new_PaymentDetailsModifier(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::ApplicationModel::Payments::PaymentItem>(args, 1);

                winrt::Windows::ApplicationModel::Payments::PaymentDetailsModifier instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::ApplicationModel::Payments::PaymentItem>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::ApplicationModel::Payments::PaymentItem>>(args, 2);

                winrt::Windows::ApplicationModel::Payments::PaymentDetailsModifier instance{ param0, param1, param2 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 4)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::ApplicationModel::Payments::PaymentItem>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::ApplicationModel::Payments::PaymentItem>>(args, 2);
                auto param3 = py::convert_to<winrt::hstring>(args, 3);

                winrt::Windows::ApplicationModel::Payments::PaymentDetailsModifier instance{ param0, param1, param2, param3 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_PaymentDetailsModifier(py::wrapper::Windows::ApplicationModel::Payments::PaymentDetailsModifier* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PaymentDetailsModifier_get_AdditionalDisplayItems(py::wrapper::Windows::ApplicationModel::Payments::PaymentDetailsModifier* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentDetailsModifier", L"AdditionalDisplayItems"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AdditionalDisplayItems());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PaymentDetailsModifier_get_JsonData(py::wrapper::Windows::ApplicationModel::Payments::PaymentDetailsModifier* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentDetailsModifier", L"JsonData"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.JsonData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PaymentDetailsModifier_get_SupportedMethodIds(py::wrapper::Windows::ApplicationModel::Payments::PaymentDetailsModifier* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentDetailsModifier", L"SupportedMethodIds"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SupportedMethodIds());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PaymentDetailsModifier_get_Total(py::wrapper::Windows::ApplicationModel::Payments::PaymentDetailsModifier* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentDetailsModifier", L"Total"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Total());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PaymentDetailsModifier(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Payments::PaymentDetailsModifier>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PaymentDetailsModifier(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Payments::PaymentDetailsModifier>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PaymentDetailsModifier[] = {
        { "_assign_array_", _assign_array_PaymentDetailsModifier, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PaymentDetailsModifier), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PaymentDetailsModifier[] = {
        { "additional_display_items", reinterpret_cast<getter>(PaymentDetailsModifier_get_AdditionalDisplayItems), nullptr, nullptr, nullptr },
        { "json_data", reinterpret_cast<getter>(PaymentDetailsModifier_get_JsonData), nullptr, nullptr, nullptr },
        { "supported_method_ids", reinterpret_cast<getter>(PaymentDetailsModifier_get_SupportedMethodIds), nullptr, nullptr, nullptr },
        { "total", reinterpret_cast<getter>(PaymentDetailsModifier_get_Total), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PaymentDetailsModifier[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PaymentDetailsModifier) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PaymentDetailsModifier) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PaymentDetailsModifier) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PaymentDetailsModifier) },
        { },
    };

    static PyType_Spec type_spec_PaymentDetailsModifier =
    {
        "winrt._winrt_windows_applicationmodel_payments.PaymentDetailsModifier",
        sizeof(py::wrapper::Windows::ApplicationModel::Payments::PaymentDetailsModifier),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PaymentDetailsModifier
    };

    // ----- PaymentItem class --------------------

    static PyObject* _new_PaymentItem(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::ApplicationModel::Payments::PaymentCurrencyAmount>(args, 1);

                winrt::Windows::ApplicationModel::Payments::PaymentItem instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_PaymentItem(py::wrapper::Windows::ApplicationModel::Payments::PaymentItem* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PaymentItem_get_Pending(py::wrapper::Windows::ApplicationModel::Payments::PaymentItem* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentItem", L"Pending"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Pending());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PaymentItem_put_Pending(py::wrapper::Windows::ApplicationModel::Payments::PaymentItem* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentItem", L"Pending"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.Pending(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PaymentItem_get_Label(py::wrapper::Windows::ApplicationModel::Payments::PaymentItem* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentItem", L"Label"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Label());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PaymentItem_put_Label(py::wrapper::Windows::ApplicationModel::Payments::PaymentItem* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentItem", L"Label"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Label(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PaymentItem_get_Amount(py::wrapper::Windows::ApplicationModel::Payments::PaymentItem* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentItem", L"Amount"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Amount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PaymentItem_put_Amount(py::wrapper::Windows::ApplicationModel::Payments::PaymentItem* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentItem", L"Amount"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Payments::PaymentCurrencyAmount>(arg);

            self->obj.Amount(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_PaymentItem(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Payments::PaymentItem>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PaymentItem(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Payments::PaymentItem>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PaymentItem[] = {
        { "_assign_array_", _assign_array_PaymentItem, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PaymentItem), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PaymentItem[] = {
        { "pending", reinterpret_cast<getter>(PaymentItem_get_Pending), reinterpret_cast<setter>(PaymentItem_put_Pending), nullptr, nullptr },
        { "label", reinterpret_cast<getter>(PaymentItem_get_Label), reinterpret_cast<setter>(PaymentItem_put_Label), nullptr, nullptr },
        { "amount", reinterpret_cast<getter>(PaymentItem_get_Amount), reinterpret_cast<setter>(PaymentItem_put_Amount), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PaymentItem[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PaymentItem) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PaymentItem) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PaymentItem) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PaymentItem) },
        { },
    };

    static PyType_Spec type_spec_PaymentItem =
    {
        "winrt._winrt_windows_applicationmodel_payments.PaymentItem",
        sizeof(py::wrapper::Windows::ApplicationModel::Payments::PaymentItem),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PaymentItem
    };

    // ----- PaymentMediator class --------------------

    static PyObject* _new_PaymentMediator(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::ApplicationModel::Payments::PaymentMediator instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_PaymentMediator(py::wrapper::Windows::ApplicationModel::Payments::PaymentMediator* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PaymentMediator_CanMakePaymentAsync(py::wrapper::Windows::ApplicationModel::Payments::PaymentMediator* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Payments.PaymentMediator", L"CanMakePaymentAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Payments::PaymentRequest>(args, 0);

                return py::convert(self->obj.CanMakePaymentAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PaymentMediator_GetSupportedMethodIdsAsync(py::wrapper::Windows::ApplicationModel::Payments::PaymentMediator* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Payments.PaymentMediator", L"GetSupportedMethodIdsAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetSupportedMethodIdsAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PaymentMediator_SubmitPaymentRequestAsync(py::wrapper::Windows::ApplicationModel::Payments::PaymentMediator* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Payments.PaymentMediator", L"SubmitPaymentRequestAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Payments::PaymentRequest>(args, 0);

                return py::convert(self->obj.SubmitPaymentRequestAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Payments.PaymentMediator", L"SubmitPaymentRequestAsync", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Payments::PaymentRequest>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::ApplicationModel::Payments::PaymentRequestChangedHandler>(args, 1);

                return py::convert(self->obj.SubmitPaymentRequestAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_PaymentMediator(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Payments::PaymentMediator>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PaymentMediator(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Payments::PaymentMediator>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PaymentMediator[] = {
        { "can_make_payment_async", reinterpret_cast<PyCFunction>(PaymentMediator_CanMakePaymentAsync), METH_VARARGS, nullptr },
        { "get_supported_method_ids_async", reinterpret_cast<PyCFunction>(PaymentMediator_GetSupportedMethodIdsAsync), METH_VARARGS, nullptr },
        { "submit_payment_request_async", reinterpret_cast<PyCFunction>(PaymentMediator_SubmitPaymentRequestAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_PaymentMediator, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PaymentMediator), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PaymentMediator[] = {
        { }
    };

    static PyType_Slot _type_slots_PaymentMediator[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PaymentMediator) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PaymentMediator) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PaymentMediator) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PaymentMediator) },
        { },
    };

    static PyType_Spec type_spec_PaymentMediator =
    {
        "winrt._winrt_windows_applicationmodel_payments.PaymentMediator",
        sizeof(py::wrapper::Windows::ApplicationModel::Payments::PaymentMediator),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PaymentMediator
    };

    // ----- PaymentMerchantInfo class --------------------

    static PyObject* _new_PaymentMerchantInfo(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);

                winrt::Windows::ApplicationModel::Payments::PaymentMerchantInfo instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 0)
        {
            try
            {
                winrt::Windows::ApplicationModel::Payments::PaymentMerchantInfo instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_PaymentMerchantInfo(py::wrapper::Windows::ApplicationModel::Payments::PaymentMerchantInfo* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PaymentMerchantInfo_get_PackageFullName(py::wrapper::Windows::ApplicationModel::Payments::PaymentMerchantInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentMerchantInfo", L"PackageFullName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PackageFullName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PaymentMerchantInfo_get_Uri(py::wrapper::Windows::ApplicationModel::Payments::PaymentMerchantInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentMerchantInfo", L"Uri"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Uri());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PaymentMerchantInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Payments::PaymentMerchantInfo>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PaymentMerchantInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Payments::PaymentMerchantInfo>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PaymentMerchantInfo[] = {
        { "_assign_array_", _assign_array_PaymentMerchantInfo, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PaymentMerchantInfo), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PaymentMerchantInfo[] = {
        { "package_full_name", reinterpret_cast<getter>(PaymentMerchantInfo_get_PackageFullName), nullptr, nullptr, nullptr },
        { "uri", reinterpret_cast<getter>(PaymentMerchantInfo_get_Uri), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PaymentMerchantInfo[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PaymentMerchantInfo) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PaymentMerchantInfo) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PaymentMerchantInfo) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PaymentMerchantInfo) },
        { },
    };

    static PyType_Spec type_spec_PaymentMerchantInfo =
    {
        "winrt._winrt_windows_applicationmodel_payments.PaymentMerchantInfo",
        sizeof(py::wrapper::Windows::ApplicationModel::Payments::PaymentMerchantInfo),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PaymentMerchantInfo
    };

    // ----- PaymentMethodData class --------------------

    static PyObject* _new_PaymentMethodData(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 0);

                winrt::Windows::ApplicationModel::Payments::PaymentMethodData instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                winrt::Windows::ApplicationModel::Payments::PaymentMethodData instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_PaymentMethodData(py::wrapper::Windows::ApplicationModel::Payments::PaymentMethodData* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PaymentMethodData_get_JsonData(py::wrapper::Windows::ApplicationModel::Payments::PaymentMethodData* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentMethodData", L"JsonData"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.JsonData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PaymentMethodData_get_SupportedMethodIds(py::wrapper::Windows::ApplicationModel::Payments::PaymentMethodData* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentMethodData", L"SupportedMethodIds"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SupportedMethodIds());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PaymentMethodData(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Payments::PaymentMethodData>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PaymentMethodData(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Payments::PaymentMethodData>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PaymentMethodData[] = {
        { "_assign_array_", _assign_array_PaymentMethodData, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PaymentMethodData), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PaymentMethodData[] = {
        { "json_data", reinterpret_cast<getter>(PaymentMethodData_get_JsonData), nullptr, nullptr, nullptr },
        { "supported_method_ids", reinterpret_cast<getter>(PaymentMethodData_get_SupportedMethodIds), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PaymentMethodData[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PaymentMethodData) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PaymentMethodData) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PaymentMethodData) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PaymentMethodData) },
        { },
    };

    static PyType_Spec type_spec_PaymentMethodData =
    {
        "winrt._winrt_windows_applicationmodel_payments.PaymentMethodData",
        sizeof(py::wrapper::Windows::ApplicationModel::Payments::PaymentMethodData),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PaymentMethodData
    };

    // ----- PaymentOptions class --------------------

    static PyObject* _new_PaymentOptions(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::ApplicationModel::Payments::PaymentOptions instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_PaymentOptions(py::wrapper::Windows::ApplicationModel::Payments::PaymentOptions* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PaymentOptions_get_ShippingType(py::wrapper::Windows::ApplicationModel::Payments::PaymentOptions* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentOptions", L"ShippingType"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ShippingType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PaymentOptions_put_ShippingType(py::wrapper::Windows::ApplicationModel::Payments::PaymentOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentOptions", L"ShippingType"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Payments::PaymentShippingType>(arg);

            self->obj.ShippingType(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PaymentOptions_get_RequestShipping(py::wrapper::Windows::ApplicationModel::Payments::PaymentOptions* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentOptions", L"RequestShipping"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RequestShipping());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PaymentOptions_put_RequestShipping(py::wrapper::Windows::ApplicationModel::Payments::PaymentOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentOptions", L"RequestShipping"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.RequestShipping(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PaymentOptions_get_RequestPayerPhoneNumber(py::wrapper::Windows::ApplicationModel::Payments::PaymentOptions* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentOptions", L"RequestPayerPhoneNumber"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RequestPayerPhoneNumber());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PaymentOptions_put_RequestPayerPhoneNumber(py::wrapper::Windows::ApplicationModel::Payments::PaymentOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentOptions", L"RequestPayerPhoneNumber"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Payments::PaymentOptionPresence>(arg);

            self->obj.RequestPayerPhoneNumber(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PaymentOptions_get_RequestPayerName(py::wrapper::Windows::ApplicationModel::Payments::PaymentOptions* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentOptions", L"RequestPayerName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RequestPayerName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PaymentOptions_put_RequestPayerName(py::wrapper::Windows::ApplicationModel::Payments::PaymentOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentOptions", L"RequestPayerName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Payments::PaymentOptionPresence>(arg);

            self->obj.RequestPayerName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PaymentOptions_get_RequestPayerEmail(py::wrapper::Windows::ApplicationModel::Payments::PaymentOptions* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentOptions", L"RequestPayerEmail"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RequestPayerEmail());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PaymentOptions_put_RequestPayerEmail(py::wrapper::Windows::ApplicationModel::Payments::PaymentOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentOptions", L"RequestPayerEmail"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Payments::PaymentOptionPresence>(arg);

            self->obj.RequestPayerEmail(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_PaymentOptions(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Payments::PaymentOptions>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PaymentOptions(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Payments::PaymentOptions>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PaymentOptions[] = {
        { "_assign_array_", _assign_array_PaymentOptions, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PaymentOptions), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PaymentOptions[] = {
        { "shipping_type", reinterpret_cast<getter>(PaymentOptions_get_ShippingType), reinterpret_cast<setter>(PaymentOptions_put_ShippingType), nullptr, nullptr },
        { "request_shipping", reinterpret_cast<getter>(PaymentOptions_get_RequestShipping), reinterpret_cast<setter>(PaymentOptions_put_RequestShipping), nullptr, nullptr },
        { "request_payer_phone_number", reinterpret_cast<getter>(PaymentOptions_get_RequestPayerPhoneNumber), reinterpret_cast<setter>(PaymentOptions_put_RequestPayerPhoneNumber), nullptr, nullptr },
        { "request_payer_name", reinterpret_cast<getter>(PaymentOptions_get_RequestPayerName), reinterpret_cast<setter>(PaymentOptions_put_RequestPayerName), nullptr, nullptr },
        { "request_payer_email", reinterpret_cast<getter>(PaymentOptions_get_RequestPayerEmail), reinterpret_cast<setter>(PaymentOptions_put_RequestPayerEmail), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PaymentOptions[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PaymentOptions) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PaymentOptions) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PaymentOptions) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PaymentOptions) },
        { },
    };

    static PyType_Spec type_spec_PaymentOptions =
    {
        "winrt._winrt_windows_applicationmodel_payments.PaymentOptions",
        sizeof(py::wrapper::Windows::ApplicationModel::Payments::PaymentOptions),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PaymentOptions
    };

    // ----- PaymentRequest class --------------------

    static PyObject* _new_PaymentRequest(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 5)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Payments::PaymentDetails>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::ApplicationModel::Payments::PaymentMethodData>>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::ApplicationModel::Payments::PaymentMerchantInfo>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::ApplicationModel::Payments::PaymentOptions>(args, 3);
                auto param4 = py::convert_to<winrt::hstring>(args, 4);

                winrt::Windows::ApplicationModel::Payments::PaymentRequest instance{ param0, param1, param2, param3, param4 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Payments::PaymentDetails>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::ApplicationModel::Payments::PaymentMethodData>>(args, 1);

                winrt::Windows::ApplicationModel::Payments::PaymentRequest instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Payments::PaymentDetails>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::ApplicationModel::Payments::PaymentMethodData>>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::ApplicationModel::Payments::PaymentMerchantInfo>(args, 2);

                winrt::Windows::ApplicationModel::Payments::PaymentRequest instance{ param0, param1, param2 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 4)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Payments::PaymentDetails>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::ApplicationModel::Payments::PaymentMethodData>>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::ApplicationModel::Payments::PaymentMerchantInfo>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::ApplicationModel::Payments::PaymentOptions>(args, 3);

                winrt::Windows::ApplicationModel::Payments::PaymentRequest instance{ param0, param1, param2, param3 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_PaymentRequest(py::wrapper::Windows::ApplicationModel::Payments::PaymentRequest* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PaymentRequest_get_Details(py::wrapper::Windows::ApplicationModel::Payments::PaymentRequest* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentRequest", L"Details"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Details());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PaymentRequest_get_MerchantInfo(py::wrapper::Windows::ApplicationModel::Payments::PaymentRequest* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentRequest", L"MerchantInfo"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MerchantInfo());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PaymentRequest_get_MethodData(py::wrapper::Windows::ApplicationModel::Payments::PaymentRequest* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentRequest", L"MethodData"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MethodData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PaymentRequest_get_Options(py::wrapper::Windows::ApplicationModel::Payments::PaymentRequest* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentRequest", L"Options"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Options());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PaymentRequest_get_Id(py::wrapper::Windows::ApplicationModel::Payments::PaymentRequest* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentRequest", L"Id"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PaymentRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Payments::PaymentRequest>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PaymentRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Payments::PaymentRequest>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PaymentRequest[] = {
        { "_assign_array_", _assign_array_PaymentRequest, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PaymentRequest), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PaymentRequest[] = {
        { "details", reinterpret_cast<getter>(PaymentRequest_get_Details), nullptr, nullptr, nullptr },
        { "merchant_info", reinterpret_cast<getter>(PaymentRequest_get_MerchantInfo), nullptr, nullptr, nullptr },
        { "method_data", reinterpret_cast<getter>(PaymentRequest_get_MethodData), nullptr, nullptr, nullptr },
        { "options", reinterpret_cast<getter>(PaymentRequest_get_Options), nullptr, nullptr, nullptr },
        { "id", reinterpret_cast<getter>(PaymentRequest_get_Id), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PaymentRequest[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PaymentRequest) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PaymentRequest) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PaymentRequest) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PaymentRequest) },
        { },
    };

    static PyType_Spec type_spec_PaymentRequest =
    {
        "winrt._winrt_windows_applicationmodel_payments.PaymentRequest",
        sizeof(py::wrapper::Windows::ApplicationModel::Payments::PaymentRequest),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PaymentRequest
    };

    // ----- PaymentRequestChangedArgs class --------------------

    static PyObject* _new_PaymentRequestChangedArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Payments::PaymentRequestChangedArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Payments::PaymentRequestChangedArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_PaymentRequestChangedArgs(py::wrapper::Windows::ApplicationModel::Payments::PaymentRequestChangedArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PaymentRequestChangedArgs_Acknowledge(py::wrapper::Windows::ApplicationModel::Payments::PaymentRequestChangedArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Payments.PaymentRequestChangedArgs", L"Acknowledge", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Payments::PaymentRequestChangedResult>(args, 0);

                self->obj.Acknowledge(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PaymentRequestChangedArgs_get_ChangeKind(py::wrapper::Windows::ApplicationModel::Payments::PaymentRequestChangedArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentRequestChangedArgs", L"ChangeKind"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ChangeKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PaymentRequestChangedArgs_get_SelectedShippingOption(py::wrapper::Windows::ApplicationModel::Payments::PaymentRequestChangedArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentRequestChangedArgs", L"SelectedShippingOption"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SelectedShippingOption());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PaymentRequestChangedArgs_get_ShippingAddress(py::wrapper::Windows::ApplicationModel::Payments::PaymentRequestChangedArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentRequestChangedArgs", L"ShippingAddress"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ShippingAddress());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PaymentRequestChangedArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Payments::PaymentRequestChangedArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PaymentRequestChangedArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Payments::PaymentRequestChangedArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PaymentRequestChangedArgs[] = {
        { "acknowledge", reinterpret_cast<PyCFunction>(PaymentRequestChangedArgs_Acknowledge), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_PaymentRequestChangedArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PaymentRequestChangedArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PaymentRequestChangedArgs[] = {
        { "change_kind", reinterpret_cast<getter>(PaymentRequestChangedArgs_get_ChangeKind), nullptr, nullptr, nullptr },
        { "selected_shipping_option", reinterpret_cast<getter>(PaymentRequestChangedArgs_get_SelectedShippingOption), nullptr, nullptr, nullptr },
        { "shipping_address", reinterpret_cast<getter>(PaymentRequestChangedArgs_get_ShippingAddress), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PaymentRequestChangedArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PaymentRequestChangedArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PaymentRequestChangedArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PaymentRequestChangedArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PaymentRequestChangedArgs) },
        { },
    };

    static PyType_Spec type_spec_PaymentRequestChangedArgs =
    {
        "winrt._winrt_windows_applicationmodel_payments.PaymentRequestChangedArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Payments::PaymentRequestChangedArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PaymentRequestChangedArgs
    };

    // ----- PaymentRequestChangedResult class --------------------

    static PyObject* _new_PaymentRequestChangedResult(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<bool>(args, 0);

                winrt::Windows::ApplicationModel::Payments::PaymentRequestChangedResult instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<bool>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::ApplicationModel::Payments::PaymentDetails>(args, 1);

                winrt::Windows::ApplicationModel::Payments::PaymentRequestChangedResult instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_PaymentRequestChangedResult(py::wrapper::Windows::ApplicationModel::Payments::PaymentRequestChangedResult* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PaymentRequestChangedResult_get_UpdatedPaymentDetails(py::wrapper::Windows::ApplicationModel::Payments::PaymentRequestChangedResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentRequestChangedResult", L"UpdatedPaymentDetails"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.UpdatedPaymentDetails());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PaymentRequestChangedResult_put_UpdatedPaymentDetails(py::wrapper::Windows::ApplicationModel::Payments::PaymentRequestChangedResult* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentRequestChangedResult", L"UpdatedPaymentDetails"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Payments::PaymentDetails>(arg);

            self->obj.UpdatedPaymentDetails(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PaymentRequestChangedResult_get_Message(py::wrapper::Windows::ApplicationModel::Payments::PaymentRequestChangedResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentRequestChangedResult", L"Message"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Message());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PaymentRequestChangedResult_put_Message(py::wrapper::Windows::ApplicationModel::Payments::PaymentRequestChangedResult* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentRequestChangedResult", L"Message"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Message(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PaymentRequestChangedResult_get_ChangeAcceptedByMerchant(py::wrapper::Windows::ApplicationModel::Payments::PaymentRequestChangedResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentRequestChangedResult", L"ChangeAcceptedByMerchant"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ChangeAcceptedByMerchant());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PaymentRequestChangedResult_put_ChangeAcceptedByMerchant(py::wrapper::Windows::ApplicationModel::Payments::PaymentRequestChangedResult* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentRequestChangedResult", L"ChangeAcceptedByMerchant"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.ChangeAcceptedByMerchant(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_PaymentRequestChangedResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Payments::PaymentRequestChangedResult>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PaymentRequestChangedResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Payments::PaymentRequestChangedResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PaymentRequestChangedResult[] = {
        { "_assign_array_", _assign_array_PaymentRequestChangedResult, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PaymentRequestChangedResult), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PaymentRequestChangedResult[] = {
        { "updated_payment_details", reinterpret_cast<getter>(PaymentRequestChangedResult_get_UpdatedPaymentDetails), reinterpret_cast<setter>(PaymentRequestChangedResult_put_UpdatedPaymentDetails), nullptr, nullptr },
        { "message", reinterpret_cast<getter>(PaymentRequestChangedResult_get_Message), reinterpret_cast<setter>(PaymentRequestChangedResult_put_Message), nullptr, nullptr },
        { "change_accepted_by_merchant", reinterpret_cast<getter>(PaymentRequestChangedResult_get_ChangeAcceptedByMerchant), reinterpret_cast<setter>(PaymentRequestChangedResult_put_ChangeAcceptedByMerchant), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PaymentRequestChangedResult[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PaymentRequestChangedResult) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PaymentRequestChangedResult) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PaymentRequestChangedResult) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PaymentRequestChangedResult) },
        { },
    };

    static PyType_Spec type_spec_PaymentRequestChangedResult =
    {
        "winrt._winrt_windows_applicationmodel_payments.PaymentRequestChangedResult",
        sizeof(py::wrapper::Windows::ApplicationModel::Payments::PaymentRequestChangedResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PaymentRequestChangedResult
    };

    // ----- PaymentRequestSubmitResult class --------------------

    static PyObject* _new_PaymentRequestSubmitResult(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Payments::PaymentRequestSubmitResult>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Payments::PaymentRequestSubmitResult>::type_name);
        return nullptr;
    }

    static void _dealloc_PaymentRequestSubmitResult(py::wrapper::Windows::ApplicationModel::Payments::PaymentRequestSubmitResult* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PaymentRequestSubmitResult_get_Response(py::wrapper::Windows::ApplicationModel::Payments::PaymentRequestSubmitResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentRequestSubmitResult", L"Response"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Response());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PaymentRequestSubmitResult_get_Status(py::wrapper::Windows::ApplicationModel::Payments::PaymentRequestSubmitResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentRequestSubmitResult", L"Status"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PaymentRequestSubmitResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Payments::PaymentRequestSubmitResult>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PaymentRequestSubmitResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Payments::PaymentRequestSubmitResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PaymentRequestSubmitResult[] = {
        { "_assign_array_", _assign_array_PaymentRequestSubmitResult, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PaymentRequestSubmitResult), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PaymentRequestSubmitResult[] = {
        { "response", reinterpret_cast<getter>(PaymentRequestSubmitResult_get_Response), nullptr, nullptr, nullptr },
        { "status", reinterpret_cast<getter>(PaymentRequestSubmitResult_get_Status), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PaymentRequestSubmitResult[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PaymentRequestSubmitResult) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PaymentRequestSubmitResult) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PaymentRequestSubmitResult) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PaymentRequestSubmitResult) },
        { },
    };

    static PyType_Spec type_spec_PaymentRequestSubmitResult =
    {
        "winrt._winrt_windows_applicationmodel_payments.PaymentRequestSubmitResult",
        sizeof(py::wrapper::Windows::ApplicationModel::Payments::PaymentRequestSubmitResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PaymentRequestSubmitResult
    };

    // ----- PaymentResponse class --------------------

    static PyObject* _new_PaymentResponse(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Payments::PaymentResponse>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Payments::PaymentResponse>::type_name);
        return nullptr;
    }

    static void _dealloc_PaymentResponse(py::wrapper::Windows::ApplicationModel::Payments::PaymentResponse* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PaymentResponse_CompleteAsync(py::wrapper::Windows::ApplicationModel::Payments::PaymentResponse* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Payments.PaymentResponse", L"CompleteAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Payments::PaymentRequestCompletionStatus>(args, 0);

                return py::convert(self->obj.CompleteAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PaymentResponse_get_PayerEmail(py::wrapper::Windows::ApplicationModel::Payments::PaymentResponse* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentResponse", L"PayerEmail"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PayerEmail());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PaymentResponse_get_PayerName(py::wrapper::Windows::ApplicationModel::Payments::PaymentResponse* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentResponse", L"PayerName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PayerName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PaymentResponse_get_PayerPhoneNumber(py::wrapper::Windows::ApplicationModel::Payments::PaymentResponse* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentResponse", L"PayerPhoneNumber"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PayerPhoneNumber());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PaymentResponse_get_PaymentToken(py::wrapper::Windows::ApplicationModel::Payments::PaymentResponse* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentResponse", L"PaymentToken"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PaymentToken());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PaymentResponse_get_ShippingAddress(py::wrapper::Windows::ApplicationModel::Payments::PaymentResponse* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentResponse", L"ShippingAddress"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ShippingAddress());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PaymentResponse_get_ShippingOption(py::wrapper::Windows::ApplicationModel::Payments::PaymentResponse* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentResponse", L"ShippingOption"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ShippingOption());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PaymentResponse(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Payments::PaymentResponse>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PaymentResponse(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Payments::PaymentResponse>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PaymentResponse[] = {
        { "complete_async", reinterpret_cast<PyCFunction>(PaymentResponse_CompleteAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_PaymentResponse, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PaymentResponse), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PaymentResponse[] = {
        { "payer_email", reinterpret_cast<getter>(PaymentResponse_get_PayerEmail), nullptr, nullptr, nullptr },
        { "payer_name", reinterpret_cast<getter>(PaymentResponse_get_PayerName), nullptr, nullptr, nullptr },
        { "payer_phone_number", reinterpret_cast<getter>(PaymentResponse_get_PayerPhoneNumber), nullptr, nullptr, nullptr },
        { "payment_token", reinterpret_cast<getter>(PaymentResponse_get_PaymentToken), nullptr, nullptr, nullptr },
        { "shipping_address", reinterpret_cast<getter>(PaymentResponse_get_ShippingAddress), nullptr, nullptr, nullptr },
        { "shipping_option", reinterpret_cast<getter>(PaymentResponse_get_ShippingOption), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PaymentResponse[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PaymentResponse) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PaymentResponse) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PaymentResponse) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PaymentResponse) },
        { },
    };

    static PyType_Spec type_spec_PaymentResponse =
    {
        "winrt._winrt_windows_applicationmodel_payments.PaymentResponse",
        sizeof(py::wrapper::Windows::ApplicationModel::Payments::PaymentResponse),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PaymentResponse
    };

    // ----- PaymentShippingOption class --------------------

    static PyObject* _new_PaymentShippingOption(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::ApplicationModel::Payments::PaymentCurrencyAmount>(args, 1);

                winrt::Windows::ApplicationModel::Payments::PaymentShippingOption instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::ApplicationModel::Payments::PaymentCurrencyAmount>(args, 1);
                auto param2 = py::convert_to<bool>(args, 2);

                winrt::Windows::ApplicationModel::Payments::PaymentShippingOption instance{ param0, param1, param2 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 4)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::ApplicationModel::Payments::PaymentCurrencyAmount>(args, 1);
                auto param2 = py::convert_to<bool>(args, 2);
                auto param3 = py::convert_to<winrt::hstring>(args, 3);

                winrt::Windows::ApplicationModel::Payments::PaymentShippingOption instance{ param0, param1, param2, param3 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_PaymentShippingOption(py::wrapper::Windows::ApplicationModel::Payments::PaymentShippingOption* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PaymentShippingOption_get_Tag(py::wrapper::Windows::ApplicationModel::Payments::PaymentShippingOption* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentShippingOption", L"Tag"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Tag());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PaymentShippingOption_put_Tag(py::wrapper::Windows::ApplicationModel::Payments::PaymentShippingOption* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentShippingOption", L"Tag"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Tag(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PaymentShippingOption_get_Label(py::wrapper::Windows::ApplicationModel::Payments::PaymentShippingOption* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentShippingOption", L"Label"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Label());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PaymentShippingOption_put_Label(py::wrapper::Windows::ApplicationModel::Payments::PaymentShippingOption* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentShippingOption", L"Label"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Label(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PaymentShippingOption_get_IsSelected(py::wrapper::Windows::ApplicationModel::Payments::PaymentShippingOption* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentShippingOption", L"IsSelected"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsSelected());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PaymentShippingOption_put_IsSelected(py::wrapper::Windows::ApplicationModel::Payments::PaymentShippingOption* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentShippingOption", L"IsSelected"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsSelected(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PaymentShippingOption_get_Amount(py::wrapper::Windows::ApplicationModel::Payments::PaymentShippingOption* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentShippingOption", L"Amount"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Amount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PaymentShippingOption_put_Amount(py::wrapper::Windows::ApplicationModel::Payments::PaymentShippingOption* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentShippingOption", L"Amount"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Payments::PaymentCurrencyAmount>(arg);

            self->obj.Amount(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_PaymentShippingOption(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Payments::PaymentShippingOption>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PaymentShippingOption(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Payments::PaymentShippingOption>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PaymentShippingOption[] = {
        { "_assign_array_", _assign_array_PaymentShippingOption, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PaymentShippingOption), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PaymentShippingOption[] = {
        { "tag", reinterpret_cast<getter>(PaymentShippingOption_get_Tag), reinterpret_cast<setter>(PaymentShippingOption_put_Tag), nullptr, nullptr },
        { "label", reinterpret_cast<getter>(PaymentShippingOption_get_Label), reinterpret_cast<setter>(PaymentShippingOption_put_Label), nullptr, nullptr },
        { "is_selected", reinterpret_cast<getter>(PaymentShippingOption_get_IsSelected), reinterpret_cast<setter>(PaymentShippingOption_put_IsSelected), nullptr, nullptr },
        { "amount", reinterpret_cast<getter>(PaymentShippingOption_get_Amount), reinterpret_cast<setter>(PaymentShippingOption_put_Amount), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PaymentShippingOption[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PaymentShippingOption) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PaymentShippingOption) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PaymentShippingOption) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PaymentShippingOption) },
        { },
    };

    static PyType_Spec type_spec_PaymentShippingOption =
    {
        "winrt._winrt_windows_applicationmodel_payments.PaymentShippingOption",
        sizeof(py::wrapper::Windows::ApplicationModel::Payments::PaymentShippingOption),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PaymentShippingOption
    };

    // ----- PaymentToken class --------------------

    static PyObject* _new_PaymentToken(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                winrt::Windows::ApplicationModel::Payments::PaymentToken instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                winrt::Windows::ApplicationModel::Payments::PaymentToken instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_PaymentToken(py::wrapper::Windows::ApplicationModel::Payments::PaymentToken* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PaymentToken_get_JsonDetails(py::wrapper::Windows::ApplicationModel::Payments::PaymentToken* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentToken", L"JsonDetails"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.JsonDetails());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PaymentToken_get_PaymentMethodId(py::wrapper::Windows::ApplicationModel::Payments::PaymentToken* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentToken", L"PaymentMethodId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PaymentMethodId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PaymentToken(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Payments::PaymentToken>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PaymentToken(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Payments::PaymentToken>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PaymentToken[] = {
        { "_assign_array_", _assign_array_PaymentToken, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PaymentToken), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PaymentToken[] = {
        { "json_details", reinterpret_cast<getter>(PaymentToken_get_JsonDetails), nullptr, nullptr, nullptr },
        { "payment_method_id", reinterpret_cast<getter>(PaymentToken_get_PaymentMethodId), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PaymentToken[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PaymentToken) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PaymentToken) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PaymentToken) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PaymentToken) },
        { },
    };

    static PyType_Spec type_spec_PaymentToken =
    {
        "winrt._winrt_windows_applicationmodel_payments.PaymentToken",
        sizeof(py::wrapper::Windows::ApplicationModel::Payments::PaymentToken),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PaymentToken
    };

    // ----- Windows.ApplicationModel.Payments Initialization --------------------
    PyDoc_STRVAR(module_doc, "Windows::ApplicationModel::Payments");


    static PyModuleDef module_def
        = {PyModuleDef_HEAD_INIT,
           "_winrt_windows_applicationmodel_payments",
           module_doc,
           0,
           nullptr,
           nullptr,
           nullptr,
           nullptr,
           nullptr};

} // py::cpp::Windows::ApplicationModel::Payments

PyMODINIT_FUNC PyInit__winrt_windows_applicationmodel_payments(void) noexcept
{
    using namespace py::cpp::Windows::ApplicationModel::Payments;

    if (py::import_winrt_runtime() == -1)
    {
        return nullptr;
    }

    py::pyobj_handle module{PyModule_Create(&module_def)};

    if (!module)
    {
        return nullptr;
    }

    auto object_type = py::get_object_type();
    if (!object_type)
    {
        return nullptr;
    }

    py::pyobj_handle object_bases{PyTuple_Pack(1, object_type)};

    if (!object_bases)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_PaymentAddress, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_PaymentCanMakePaymentResult, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_PaymentCurrencyAmount, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_PaymentDetails, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_PaymentDetailsModifier, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_PaymentItem, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_PaymentMediator, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_PaymentMerchantInfo, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_PaymentMethodData, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_PaymentOptions, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_PaymentRequest, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_PaymentRequestChangedArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_PaymentRequestChangedResult, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_PaymentRequestSubmitResult, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_PaymentResponse, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_PaymentShippingOption, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_PaymentToken, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }


    return module.detach();
}
