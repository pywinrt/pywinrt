// WARNING: Please don't edit this file. It was generated by Python/WinRT v2.0.0-beta.2

#include "py.Windows.System.Diagnostics.h"


namespace py::cpp::Windows::System::Diagnostics
{
    // ----- DiagnosticActionResult class --------------------

    static PyObject* _new_DiagnosticActionResult(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::System::Diagnostics::DiagnosticActionResult>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::System::Diagnostics::DiagnosticActionResult>::type_name);
        return nullptr;
    }

    static void _dealloc_DiagnosticActionResult(py::wrapper::Windows::System::Diagnostics::DiagnosticActionResult* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* DiagnosticActionResult_get_ExtendedError(py::wrapper::Windows::System::Diagnostics::DiagnosticActionResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.Diagnostics.DiagnosticActionResult", L"ExtendedError"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ExtendedError());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DiagnosticActionResult_get_Results(py::wrapper::Windows::System::Diagnostics::DiagnosticActionResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.Diagnostics.DiagnosticActionResult", L"Results"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Results());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_DiagnosticActionResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::System::Diagnostics::DiagnosticActionResult>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_DiagnosticActionResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::Diagnostics::DiagnosticActionResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DiagnosticActionResult[] = {
        { "_assign_array_", _assign_array_DiagnosticActionResult, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DiagnosticActionResult), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DiagnosticActionResult[] = {
        { "extended_error", reinterpret_cast<getter>(DiagnosticActionResult_get_ExtendedError), nullptr, nullptr, nullptr },
        { "results", reinterpret_cast<getter>(DiagnosticActionResult_get_Results), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_DiagnosticActionResult[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_DiagnosticActionResult) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_DiagnosticActionResult) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_DiagnosticActionResult) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_DiagnosticActionResult) },
        { },
    };

    static PyType_Spec type_spec_DiagnosticActionResult =
    {
        "winrt._winrt_windows_system_diagnostics.DiagnosticActionResult",
        sizeof(py::wrapper::Windows::System::Diagnostics::DiagnosticActionResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DiagnosticActionResult
    };

    // ----- DiagnosticInvoker class --------------------

    static PyObject* _new_DiagnosticInvoker(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::System::Diagnostics::DiagnosticInvoker>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::System::Diagnostics::DiagnosticInvoker>::type_name);
        return nullptr;
    }

    static void _dealloc_DiagnosticInvoker(py::wrapper::Windows::System::Diagnostics::DiagnosticInvoker* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* DiagnosticInvoker_GetDefault(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.Diagnostics.DiagnosticInvoker", L"GetDefault", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::System::Diagnostics::DiagnosticInvoker::GetDefault());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DiagnosticInvoker_GetForUser(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.Diagnostics.DiagnosticInvoker", L"GetForUser", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::System::User>(args, 0);

                return py::convert(winrt::Windows::System::Diagnostics::DiagnosticInvoker::GetForUser(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DiagnosticInvoker_RunDiagnosticActionAsync(py::wrapper::Windows::System::Diagnostics::DiagnosticInvoker* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.Diagnostics.DiagnosticInvoker", L"RunDiagnosticActionAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Data::Json::JsonObject>(args, 0);

                return py::convert(self->obj.RunDiagnosticActionAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DiagnosticInvoker_RunDiagnosticActionFromStringAsync(py::wrapper::Windows::System::Diagnostics::DiagnosticInvoker* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.Diagnostics.DiagnosticInvoker", L"RunDiagnosticActionFromStringAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.RunDiagnosticActionFromStringAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DiagnosticInvoker_get_IsSupported(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.Diagnostics.DiagnosticInvoker", L"IsSupported"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::System::Diagnostics::DiagnosticInvoker::IsSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_DiagnosticInvoker(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::System::Diagnostics::DiagnosticInvoker>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_DiagnosticInvoker(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::Diagnostics::DiagnosticInvoker>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DiagnosticInvoker[] = {
        { "run_diagnostic_action_async", reinterpret_cast<PyCFunction>(DiagnosticInvoker_RunDiagnosticActionAsync), METH_VARARGS, nullptr },
        { "run_diagnostic_action_from_string_async", reinterpret_cast<PyCFunction>(DiagnosticInvoker_RunDiagnosticActionFromStringAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_DiagnosticInvoker, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DiagnosticInvoker), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DiagnosticInvoker[] = {
        { }
    };

    static PyType_Slot _type_slots_DiagnosticInvoker[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_DiagnosticInvoker) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_DiagnosticInvoker) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_DiagnosticInvoker) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_DiagnosticInvoker) },
        { },
    };

    static PyType_Spec type_spec_DiagnosticInvoker =
    {
        "winrt._winrt_windows_system_diagnostics.DiagnosticInvoker",
        sizeof(py::wrapper::Windows::System::Diagnostics::DiagnosticInvoker),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DiagnosticInvoker
    };

    static PyGetSetDef getset_DiagnosticInvoker_Static[] = {
        { "is_supported", reinterpret_cast<getter>(DiagnosticInvoker_get_IsSupported), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_DiagnosticInvoker_Static[] = {
        { "get_default", reinterpret_cast<PyCFunction>(DiagnosticInvoker_GetDefault), METH_VARARGS, nullptr },
        { "get_for_user", reinterpret_cast<PyCFunction>(DiagnosticInvoker_GetForUser), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_DiagnosticInvoker_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_DiagnosticInvoker_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_DiagnosticInvoker_Static) },
        { }
    };

    static PyType_Spec type_spec_DiagnosticInvoker_Static =
    {
        "winrt._winrt_windows_system_diagnostics.DiagnosticInvoker_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_DiagnosticInvoker_Static
    };

    // ----- ProcessCpuUsage class --------------------

    static PyObject* _new_ProcessCpuUsage(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::System::Diagnostics::ProcessCpuUsage>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::System::Diagnostics::ProcessCpuUsage>::type_name);
        return nullptr;
    }

    static void _dealloc_ProcessCpuUsage(py::wrapper::Windows::System::Diagnostics::ProcessCpuUsage* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ProcessCpuUsage_GetReport(py::wrapper::Windows::System::Diagnostics::ProcessCpuUsage* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.Diagnostics.ProcessCpuUsage", L"GetReport", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetReport());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_ProcessCpuUsage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::System::Diagnostics::ProcessCpuUsage>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ProcessCpuUsage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::Diagnostics::ProcessCpuUsage>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ProcessCpuUsage[] = {
        { "get_report", reinterpret_cast<PyCFunction>(ProcessCpuUsage_GetReport), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_ProcessCpuUsage, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ProcessCpuUsage), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ProcessCpuUsage[] = {
        { }
    };

    static PyType_Slot _type_slots_ProcessCpuUsage[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ProcessCpuUsage) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ProcessCpuUsage) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ProcessCpuUsage) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ProcessCpuUsage) },
        { },
    };

    static PyType_Spec type_spec_ProcessCpuUsage =
    {
        "winrt._winrt_windows_system_diagnostics.ProcessCpuUsage",
        sizeof(py::wrapper::Windows::System::Diagnostics::ProcessCpuUsage),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ProcessCpuUsage
    };

    // ----- ProcessCpuUsageReport class --------------------

    static PyObject* _new_ProcessCpuUsageReport(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::System::Diagnostics::ProcessCpuUsageReport>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::System::Diagnostics::ProcessCpuUsageReport>::type_name);
        return nullptr;
    }

    static void _dealloc_ProcessCpuUsageReport(py::wrapper::Windows::System::Diagnostics::ProcessCpuUsageReport* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ProcessCpuUsageReport_get_KernelTime(py::wrapper::Windows::System::Diagnostics::ProcessCpuUsageReport* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.Diagnostics.ProcessCpuUsageReport", L"KernelTime"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.KernelTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProcessCpuUsageReport_get_UserTime(py::wrapper::Windows::System::Diagnostics::ProcessCpuUsageReport* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.Diagnostics.ProcessCpuUsageReport", L"UserTime"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.UserTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ProcessCpuUsageReport(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::System::Diagnostics::ProcessCpuUsageReport>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ProcessCpuUsageReport(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::Diagnostics::ProcessCpuUsageReport>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ProcessCpuUsageReport[] = {
        { "_assign_array_", _assign_array_ProcessCpuUsageReport, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ProcessCpuUsageReport), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ProcessCpuUsageReport[] = {
        { "kernel_time", reinterpret_cast<getter>(ProcessCpuUsageReport_get_KernelTime), nullptr, nullptr, nullptr },
        { "user_time", reinterpret_cast<getter>(ProcessCpuUsageReport_get_UserTime), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ProcessCpuUsageReport[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ProcessCpuUsageReport) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ProcessCpuUsageReport) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ProcessCpuUsageReport) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ProcessCpuUsageReport) },
        { },
    };

    static PyType_Spec type_spec_ProcessCpuUsageReport =
    {
        "winrt._winrt_windows_system_diagnostics.ProcessCpuUsageReport",
        sizeof(py::wrapper::Windows::System::Diagnostics::ProcessCpuUsageReport),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ProcessCpuUsageReport
    };

    // ----- ProcessDiagnosticInfo class --------------------

    static PyObject* _new_ProcessDiagnosticInfo(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::System::Diagnostics::ProcessDiagnosticInfo>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::System::Diagnostics::ProcessDiagnosticInfo>::type_name);
        return nullptr;
    }

    static void _dealloc_ProcessDiagnosticInfo(py::wrapper::Windows::System::Diagnostics::ProcessDiagnosticInfo* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ProcessDiagnosticInfo_GetAppDiagnosticInfos(py::wrapper::Windows::System::Diagnostics::ProcessDiagnosticInfo* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.Diagnostics.ProcessDiagnosticInfo", L"GetAppDiagnosticInfos", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetAppDiagnosticInfos());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ProcessDiagnosticInfo_GetForCurrentProcess(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.Diagnostics.ProcessDiagnosticInfo", L"GetForCurrentProcess", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::System::Diagnostics::ProcessDiagnosticInfo::GetForCurrentProcess());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ProcessDiagnosticInfo_GetForProcesses(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.Diagnostics.ProcessDiagnosticInfo", L"GetForProcesses", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::System::Diagnostics::ProcessDiagnosticInfo::GetForProcesses());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ProcessDiagnosticInfo_TryGetForProcessId(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.Diagnostics.ProcessDiagnosticInfo", L"TryGetForProcessId", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);

                return py::convert(winrt::Windows::System::Diagnostics::ProcessDiagnosticInfo::TryGetForProcessId(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ProcessDiagnosticInfo_get_CpuUsage(py::wrapper::Windows::System::Diagnostics::ProcessDiagnosticInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.Diagnostics.ProcessDiagnosticInfo", L"CpuUsage"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CpuUsage());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProcessDiagnosticInfo_get_DiskUsage(py::wrapper::Windows::System::Diagnostics::ProcessDiagnosticInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.Diagnostics.ProcessDiagnosticInfo", L"DiskUsage"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DiskUsage());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProcessDiagnosticInfo_get_ExecutableFileName(py::wrapper::Windows::System::Diagnostics::ProcessDiagnosticInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.Diagnostics.ProcessDiagnosticInfo", L"ExecutableFileName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ExecutableFileName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProcessDiagnosticInfo_get_MemoryUsage(py::wrapper::Windows::System::Diagnostics::ProcessDiagnosticInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.Diagnostics.ProcessDiagnosticInfo", L"MemoryUsage"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MemoryUsage());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProcessDiagnosticInfo_get_Parent(py::wrapper::Windows::System::Diagnostics::ProcessDiagnosticInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.Diagnostics.ProcessDiagnosticInfo", L"Parent"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Parent());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProcessDiagnosticInfo_get_ProcessId(py::wrapper::Windows::System::Diagnostics::ProcessDiagnosticInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.Diagnostics.ProcessDiagnosticInfo", L"ProcessId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ProcessId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProcessDiagnosticInfo_get_ProcessStartTime(py::wrapper::Windows::System::Diagnostics::ProcessDiagnosticInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.Diagnostics.ProcessDiagnosticInfo", L"ProcessStartTime"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ProcessStartTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProcessDiagnosticInfo_get_IsPackaged(py::wrapper::Windows::System::Diagnostics::ProcessDiagnosticInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.Diagnostics.ProcessDiagnosticInfo", L"IsPackaged"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsPackaged());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ProcessDiagnosticInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::System::Diagnostics::ProcessDiagnosticInfo>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ProcessDiagnosticInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::Diagnostics::ProcessDiagnosticInfo>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ProcessDiagnosticInfo[] = {
        { "get_app_diagnostic_infos", reinterpret_cast<PyCFunction>(ProcessDiagnosticInfo_GetAppDiagnosticInfos), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_ProcessDiagnosticInfo, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ProcessDiagnosticInfo), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ProcessDiagnosticInfo[] = {
        { "cpu_usage", reinterpret_cast<getter>(ProcessDiagnosticInfo_get_CpuUsage), nullptr, nullptr, nullptr },
        { "disk_usage", reinterpret_cast<getter>(ProcessDiagnosticInfo_get_DiskUsage), nullptr, nullptr, nullptr },
        { "executable_file_name", reinterpret_cast<getter>(ProcessDiagnosticInfo_get_ExecutableFileName), nullptr, nullptr, nullptr },
        { "memory_usage", reinterpret_cast<getter>(ProcessDiagnosticInfo_get_MemoryUsage), nullptr, nullptr, nullptr },
        { "parent", reinterpret_cast<getter>(ProcessDiagnosticInfo_get_Parent), nullptr, nullptr, nullptr },
        { "process_id", reinterpret_cast<getter>(ProcessDiagnosticInfo_get_ProcessId), nullptr, nullptr, nullptr },
        { "process_start_time", reinterpret_cast<getter>(ProcessDiagnosticInfo_get_ProcessStartTime), nullptr, nullptr, nullptr },
        { "is_packaged", reinterpret_cast<getter>(ProcessDiagnosticInfo_get_IsPackaged), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ProcessDiagnosticInfo[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ProcessDiagnosticInfo) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ProcessDiagnosticInfo) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ProcessDiagnosticInfo) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ProcessDiagnosticInfo) },
        { },
    };

    static PyType_Spec type_spec_ProcessDiagnosticInfo =
    {
        "winrt._winrt_windows_system_diagnostics.ProcessDiagnosticInfo",
        sizeof(py::wrapper::Windows::System::Diagnostics::ProcessDiagnosticInfo),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ProcessDiagnosticInfo
    };

    static PyGetSetDef getset_ProcessDiagnosticInfo_Static[] = {
        { }
    };

    static PyMethodDef methods_ProcessDiagnosticInfo_Static[] = {
        { "get_for_current_process", reinterpret_cast<PyCFunction>(ProcessDiagnosticInfo_GetForCurrentProcess), METH_VARARGS, nullptr },
        { "get_for_processes", reinterpret_cast<PyCFunction>(ProcessDiagnosticInfo_GetForProcesses), METH_VARARGS, nullptr },
        { "try_get_for_process_id", reinterpret_cast<PyCFunction>(ProcessDiagnosticInfo_TryGetForProcessId), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_ProcessDiagnosticInfo_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_ProcessDiagnosticInfo_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_ProcessDiagnosticInfo_Static) },
        { }
    };

    static PyType_Spec type_spec_ProcessDiagnosticInfo_Static =
    {
        "winrt._winrt_windows_system_diagnostics.ProcessDiagnosticInfo_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_ProcessDiagnosticInfo_Static
    };

    // ----- ProcessDiskUsage class --------------------

    static PyObject* _new_ProcessDiskUsage(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::System::Diagnostics::ProcessDiskUsage>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::System::Diagnostics::ProcessDiskUsage>::type_name);
        return nullptr;
    }

    static void _dealloc_ProcessDiskUsage(py::wrapper::Windows::System::Diagnostics::ProcessDiskUsage* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ProcessDiskUsage_GetReport(py::wrapper::Windows::System::Diagnostics::ProcessDiskUsage* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.Diagnostics.ProcessDiskUsage", L"GetReport", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetReport());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_ProcessDiskUsage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::System::Diagnostics::ProcessDiskUsage>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ProcessDiskUsage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::Diagnostics::ProcessDiskUsage>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ProcessDiskUsage[] = {
        { "get_report", reinterpret_cast<PyCFunction>(ProcessDiskUsage_GetReport), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_ProcessDiskUsage, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ProcessDiskUsage), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ProcessDiskUsage[] = {
        { }
    };

    static PyType_Slot _type_slots_ProcessDiskUsage[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ProcessDiskUsage) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ProcessDiskUsage) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ProcessDiskUsage) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ProcessDiskUsage) },
        { },
    };

    static PyType_Spec type_spec_ProcessDiskUsage =
    {
        "winrt._winrt_windows_system_diagnostics.ProcessDiskUsage",
        sizeof(py::wrapper::Windows::System::Diagnostics::ProcessDiskUsage),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ProcessDiskUsage
    };

    // ----- ProcessDiskUsageReport class --------------------

    static PyObject* _new_ProcessDiskUsageReport(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::System::Diagnostics::ProcessDiskUsageReport>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::System::Diagnostics::ProcessDiskUsageReport>::type_name);
        return nullptr;
    }

    static void _dealloc_ProcessDiskUsageReport(py::wrapper::Windows::System::Diagnostics::ProcessDiskUsageReport* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ProcessDiskUsageReport_get_BytesReadCount(py::wrapper::Windows::System::Diagnostics::ProcessDiskUsageReport* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.Diagnostics.ProcessDiskUsageReport", L"BytesReadCount"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.BytesReadCount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProcessDiskUsageReport_get_BytesWrittenCount(py::wrapper::Windows::System::Diagnostics::ProcessDiskUsageReport* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.Diagnostics.ProcessDiskUsageReport", L"BytesWrittenCount"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.BytesWrittenCount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProcessDiskUsageReport_get_OtherBytesCount(py::wrapper::Windows::System::Diagnostics::ProcessDiskUsageReport* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.Diagnostics.ProcessDiskUsageReport", L"OtherBytesCount"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.OtherBytesCount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProcessDiskUsageReport_get_OtherOperationCount(py::wrapper::Windows::System::Diagnostics::ProcessDiskUsageReport* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.Diagnostics.ProcessDiskUsageReport", L"OtherOperationCount"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.OtherOperationCount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProcessDiskUsageReport_get_ReadOperationCount(py::wrapper::Windows::System::Diagnostics::ProcessDiskUsageReport* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.Diagnostics.ProcessDiskUsageReport", L"ReadOperationCount"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ReadOperationCount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProcessDiskUsageReport_get_WriteOperationCount(py::wrapper::Windows::System::Diagnostics::ProcessDiskUsageReport* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.Diagnostics.ProcessDiskUsageReport", L"WriteOperationCount"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.WriteOperationCount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ProcessDiskUsageReport(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::System::Diagnostics::ProcessDiskUsageReport>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ProcessDiskUsageReport(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::Diagnostics::ProcessDiskUsageReport>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ProcessDiskUsageReport[] = {
        { "_assign_array_", _assign_array_ProcessDiskUsageReport, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ProcessDiskUsageReport), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ProcessDiskUsageReport[] = {
        { "bytes_read_count", reinterpret_cast<getter>(ProcessDiskUsageReport_get_BytesReadCount), nullptr, nullptr, nullptr },
        { "bytes_written_count", reinterpret_cast<getter>(ProcessDiskUsageReport_get_BytesWrittenCount), nullptr, nullptr, nullptr },
        { "other_bytes_count", reinterpret_cast<getter>(ProcessDiskUsageReport_get_OtherBytesCount), nullptr, nullptr, nullptr },
        { "other_operation_count", reinterpret_cast<getter>(ProcessDiskUsageReport_get_OtherOperationCount), nullptr, nullptr, nullptr },
        { "read_operation_count", reinterpret_cast<getter>(ProcessDiskUsageReport_get_ReadOperationCount), nullptr, nullptr, nullptr },
        { "write_operation_count", reinterpret_cast<getter>(ProcessDiskUsageReport_get_WriteOperationCount), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ProcessDiskUsageReport[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ProcessDiskUsageReport) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ProcessDiskUsageReport) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ProcessDiskUsageReport) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ProcessDiskUsageReport) },
        { },
    };

    static PyType_Spec type_spec_ProcessDiskUsageReport =
    {
        "winrt._winrt_windows_system_diagnostics.ProcessDiskUsageReport",
        sizeof(py::wrapper::Windows::System::Diagnostics::ProcessDiskUsageReport),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ProcessDiskUsageReport
    };

    // ----- ProcessMemoryUsage class --------------------

    static PyObject* _new_ProcessMemoryUsage(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::System::Diagnostics::ProcessMemoryUsage>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::System::Diagnostics::ProcessMemoryUsage>::type_name);
        return nullptr;
    }

    static void _dealloc_ProcessMemoryUsage(py::wrapper::Windows::System::Diagnostics::ProcessMemoryUsage* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ProcessMemoryUsage_GetReport(py::wrapper::Windows::System::Diagnostics::ProcessMemoryUsage* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.Diagnostics.ProcessMemoryUsage", L"GetReport", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetReport());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_ProcessMemoryUsage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::System::Diagnostics::ProcessMemoryUsage>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ProcessMemoryUsage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::Diagnostics::ProcessMemoryUsage>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ProcessMemoryUsage[] = {
        { "get_report", reinterpret_cast<PyCFunction>(ProcessMemoryUsage_GetReport), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_ProcessMemoryUsage, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ProcessMemoryUsage), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ProcessMemoryUsage[] = {
        { }
    };

    static PyType_Slot _type_slots_ProcessMemoryUsage[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ProcessMemoryUsage) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ProcessMemoryUsage) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ProcessMemoryUsage) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ProcessMemoryUsage) },
        { },
    };

    static PyType_Spec type_spec_ProcessMemoryUsage =
    {
        "winrt._winrt_windows_system_diagnostics.ProcessMemoryUsage",
        sizeof(py::wrapper::Windows::System::Diagnostics::ProcessMemoryUsage),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ProcessMemoryUsage
    };

    // ----- ProcessMemoryUsageReport class --------------------

    static PyObject* _new_ProcessMemoryUsageReport(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::System::Diagnostics::ProcessMemoryUsageReport>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::System::Diagnostics::ProcessMemoryUsageReport>::type_name);
        return nullptr;
    }

    static void _dealloc_ProcessMemoryUsageReport(py::wrapper::Windows::System::Diagnostics::ProcessMemoryUsageReport* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ProcessMemoryUsageReport_get_NonPagedPoolSizeInBytes(py::wrapper::Windows::System::Diagnostics::ProcessMemoryUsageReport* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.Diagnostics.ProcessMemoryUsageReport", L"NonPagedPoolSizeInBytes"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.NonPagedPoolSizeInBytes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProcessMemoryUsageReport_get_PageFaultCount(py::wrapper::Windows::System::Diagnostics::ProcessMemoryUsageReport* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.Diagnostics.ProcessMemoryUsageReport", L"PageFaultCount"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PageFaultCount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProcessMemoryUsageReport_get_PageFileSizeInBytes(py::wrapper::Windows::System::Diagnostics::ProcessMemoryUsageReport* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.Diagnostics.ProcessMemoryUsageReport", L"PageFileSizeInBytes"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PageFileSizeInBytes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProcessMemoryUsageReport_get_PagedPoolSizeInBytes(py::wrapper::Windows::System::Diagnostics::ProcessMemoryUsageReport* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.Diagnostics.ProcessMemoryUsageReport", L"PagedPoolSizeInBytes"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PagedPoolSizeInBytes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProcessMemoryUsageReport_get_PeakNonPagedPoolSizeInBytes(py::wrapper::Windows::System::Diagnostics::ProcessMemoryUsageReport* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.Diagnostics.ProcessMemoryUsageReport", L"PeakNonPagedPoolSizeInBytes"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PeakNonPagedPoolSizeInBytes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProcessMemoryUsageReport_get_PeakPageFileSizeInBytes(py::wrapper::Windows::System::Diagnostics::ProcessMemoryUsageReport* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.Diagnostics.ProcessMemoryUsageReport", L"PeakPageFileSizeInBytes"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PeakPageFileSizeInBytes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProcessMemoryUsageReport_get_PeakPagedPoolSizeInBytes(py::wrapper::Windows::System::Diagnostics::ProcessMemoryUsageReport* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.Diagnostics.ProcessMemoryUsageReport", L"PeakPagedPoolSizeInBytes"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PeakPagedPoolSizeInBytes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProcessMemoryUsageReport_get_PeakVirtualMemorySizeInBytes(py::wrapper::Windows::System::Diagnostics::ProcessMemoryUsageReport* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.Diagnostics.ProcessMemoryUsageReport", L"PeakVirtualMemorySizeInBytes"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PeakVirtualMemorySizeInBytes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProcessMemoryUsageReport_get_PeakWorkingSetSizeInBytes(py::wrapper::Windows::System::Diagnostics::ProcessMemoryUsageReport* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.Diagnostics.ProcessMemoryUsageReport", L"PeakWorkingSetSizeInBytes"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PeakWorkingSetSizeInBytes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProcessMemoryUsageReport_get_PrivatePageCount(py::wrapper::Windows::System::Diagnostics::ProcessMemoryUsageReport* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.Diagnostics.ProcessMemoryUsageReport", L"PrivatePageCount"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PrivatePageCount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProcessMemoryUsageReport_get_VirtualMemorySizeInBytes(py::wrapper::Windows::System::Diagnostics::ProcessMemoryUsageReport* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.Diagnostics.ProcessMemoryUsageReport", L"VirtualMemorySizeInBytes"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.VirtualMemorySizeInBytes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProcessMemoryUsageReport_get_WorkingSetSizeInBytes(py::wrapper::Windows::System::Diagnostics::ProcessMemoryUsageReport* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.Diagnostics.ProcessMemoryUsageReport", L"WorkingSetSizeInBytes"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.WorkingSetSizeInBytes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ProcessMemoryUsageReport(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::System::Diagnostics::ProcessMemoryUsageReport>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ProcessMemoryUsageReport(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::Diagnostics::ProcessMemoryUsageReport>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ProcessMemoryUsageReport[] = {
        { "_assign_array_", _assign_array_ProcessMemoryUsageReport, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ProcessMemoryUsageReport), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ProcessMemoryUsageReport[] = {
        { "non_paged_pool_size_in_bytes", reinterpret_cast<getter>(ProcessMemoryUsageReport_get_NonPagedPoolSizeInBytes), nullptr, nullptr, nullptr },
        { "page_fault_count", reinterpret_cast<getter>(ProcessMemoryUsageReport_get_PageFaultCount), nullptr, nullptr, nullptr },
        { "page_file_size_in_bytes", reinterpret_cast<getter>(ProcessMemoryUsageReport_get_PageFileSizeInBytes), nullptr, nullptr, nullptr },
        { "paged_pool_size_in_bytes", reinterpret_cast<getter>(ProcessMemoryUsageReport_get_PagedPoolSizeInBytes), nullptr, nullptr, nullptr },
        { "peak_non_paged_pool_size_in_bytes", reinterpret_cast<getter>(ProcessMemoryUsageReport_get_PeakNonPagedPoolSizeInBytes), nullptr, nullptr, nullptr },
        { "peak_page_file_size_in_bytes", reinterpret_cast<getter>(ProcessMemoryUsageReport_get_PeakPageFileSizeInBytes), nullptr, nullptr, nullptr },
        { "peak_paged_pool_size_in_bytes", reinterpret_cast<getter>(ProcessMemoryUsageReport_get_PeakPagedPoolSizeInBytes), nullptr, nullptr, nullptr },
        { "peak_virtual_memory_size_in_bytes", reinterpret_cast<getter>(ProcessMemoryUsageReport_get_PeakVirtualMemorySizeInBytes), nullptr, nullptr, nullptr },
        { "peak_working_set_size_in_bytes", reinterpret_cast<getter>(ProcessMemoryUsageReport_get_PeakWorkingSetSizeInBytes), nullptr, nullptr, nullptr },
        { "private_page_count", reinterpret_cast<getter>(ProcessMemoryUsageReport_get_PrivatePageCount), nullptr, nullptr, nullptr },
        { "virtual_memory_size_in_bytes", reinterpret_cast<getter>(ProcessMemoryUsageReport_get_VirtualMemorySizeInBytes), nullptr, nullptr, nullptr },
        { "working_set_size_in_bytes", reinterpret_cast<getter>(ProcessMemoryUsageReport_get_WorkingSetSizeInBytes), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ProcessMemoryUsageReport[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ProcessMemoryUsageReport) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ProcessMemoryUsageReport) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ProcessMemoryUsageReport) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ProcessMemoryUsageReport) },
        { },
    };

    static PyType_Spec type_spec_ProcessMemoryUsageReport =
    {
        "winrt._winrt_windows_system_diagnostics.ProcessMemoryUsageReport",
        sizeof(py::wrapper::Windows::System::Diagnostics::ProcessMemoryUsageReport),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ProcessMemoryUsageReport
    };

    // ----- SystemCpuUsage class --------------------

    static PyObject* _new_SystemCpuUsage(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::System::Diagnostics::SystemCpuUsage>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::System::Diagnostics::SystemCpuUsage>::type_name);
        return nullptr;
    }

    static void _dealloc_SystemCpuUsage(py::wrapper::Windows::System::Diagnostics::SystemCpuUsage* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SystemCpuUsage_GetReport(py::wrapper::Windows::System::Diagnostics::SystemCpuUsage* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.Diagnostics.SystemCpuUsage", L"GetReport", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetReport());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_SystemCpuUsage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::System::Diagnostics::SystemCpuUsage>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SystemCpuUsage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::Diagnostics::SystemCpuUsage>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SystemCpuUsage[] = {
        { "get_report", reinterpret_cast<PyCFunction>(SystemCpuUsage_GetReport), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_SystemCpuUsage, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SystemCpuUsage), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SystemCpuUsage[] = {
        { }
    };

    static PyType_Slot _type_slots_SystemCpuUsage[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SystemCpuUsage) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SystemCpuUsage) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SystemCpuUsage) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SystemCpuUsage) },
        { },
    };

    static PyType_Spec type_spec_SystemCpuUsage =
    {
        "winrt._winrt_windows_system_diagnostics.SystemCpuUsage",
        sizeof(py::wrapper::Windows::System::Diagnostics::SystemCpuUsage),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SystemCpuUsage
    };

    // ----- SystemCpuUsageReport class --------------------

    static PyObject* _new_SystemCpuUsageReport(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::System::Diagnostics::SystemCpuUsageReport>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::System::Diagnostics::SystemCpuUsageReport>::type_name);
        return nullptr;
    }

    static void _dealloc_SystemCpuUsageReport(py::wrapper::Windows::System::Diagnostics::SystemCpuUsageReport* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SystemCpuUsageReport_get_IdleTime(py::wrapper::Windows::System::Diagnostics::SystemCpuUsageReport* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.Diagnostics.SystemCpuUsageReport", L"IdleTime"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IdleTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemCpuUsageReport_get_KernelTime(py::wrapper::Windows::System::Diagnostics::SystemCpuUsageReport* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.Diagnostics.SystemCpuUsageReport", L"KernelTime"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.KernelTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemCpuUsageReport_get_UserTime(py::wrapper::Windows::System::Diagnostics::SystemCpuUsageReport* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.Diagnostics.SystemCpuUsageReport", L"UserTime"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.UserTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SystemCpuUsageReport(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::System::Diagnostics::SystemCpuUsageReport>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SystemCpuUsageReport(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::Diagnostics::SystemCpuUsageReport>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SystemCpuUsageReport[] = {
        { "_assign_array_", _assign_array_SystemCpuUsageReport, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SystemCpuUsageReport), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SystemCpuUsageReport[] = {
        { "idle_time", reinterpret_cast<getter>(SystemCpuUsageReport_get_IdleTime), nullptr, nullptr, nullptr },
        { "kernel_time", reinterpret_cast<getter>(SystemCpuUsageReport_get_KernelTime), nullptr, nullptr, nullptr },
        { "user_time", reinterpret_cast<getter>(SystemCpuUsageReport_get_UserTime), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SystemCpuUsageReport[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SystemCpuUsageReport) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SystemCpuUsageReport) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SystemCpuUsageReport) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SystemCpuUsageReport) },
        { },
    };

    static PyType_Spec type_spec_SystemCpuUsageReport =
    {
        "winrt._winrt_windows_system_diagnostics.SystemCpuUsageReport",
        sizeof(py::wrapper::Windows::System::Diagnostics::SystemCpuUsageReport),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SystemCpuUsageReport
    };

    // ----- SystemDiagnosticInfo class --------------------

    static PyObject* _new_SystemDiagnosticInfo(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::System::Diagnostics::SystemDiagnosticInfo>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::System::Diagnostics::SystemDiagnosticInfo>::type_name);
        return nullptr;
    }

    static void _dealloc_SystemDiagnosticInfo(py::wrapper::Windows::System::Diagnostics::SystemDiagnosticInfo* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SystemDiagnosticInfo_GetForCurrentSystem(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.Diagnostics.SystemDiagnosticInfo", L"GetForCurrentSystem", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::System::Diagnostics::SystemDiagnosticInfo::GetForCurrentSystem());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SystemDiagnosticInfo_IsArchitectureSupported(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.Diagnostics.SystemDiagnosticInfo", L"IsArchitectureSupported", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::System::ProcessorArchitecture>(args, 0);

                return py::convert(winrt::Windows::System::Diagnostics::SystemDiagnosticInfo::IsArchitectureSupported(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SystemDiagnosticInfo_get_CpuUsage(py::wrapper::Windows::System::Diagnostics::SystemDiagnosticInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.Diagnostics.SystemDiagnosticInfo", L"CpuUsage"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CpuUsage());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemDiagnosticInfo_get_MemoryUsage(py::wrapper::Windows::System::Diagnostics::SystemDiagnosticInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.Diagnostics.SystemDiagnosticInfo", L"MemoryUsage"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MemoryUsage());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemDiagnosticInfo_get_PreferredArchitecture(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.Diagnostics.SystemDiagnosticInfo", L"PreferredArchitecture"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::System::Diagnostics::SystemDiagnosticInfo::PreferredArchitecture());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SystemDiagnosticInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::System::Diagnostics::SystemDiagnosticInfo>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SystemDiagnosticInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::Diagnostics::SystemDiagnosticInfo>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SystemDiagnosticInfo[] = {
        { "_assign_array_", _assign_array_SystemDiagnosticInfo, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SystemDiagnosticInfo), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SystemDiagnosticInfo[] = {
        { "cpu_usage", reinterpret_cast<getter>(SystemDiagnosticInfo_get_CpuUsage), nullptr, nullptr, nullptr },
        { "memory_usage", reinterpret_cast<getter>(SystemDiagnosticInfo_get_MemoryUsage), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SystemDiagnosticInfo[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SystemDiagnosticInfo) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SystemDiagnosticInfo) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SystemDiagnosticInfo) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SystemDiagnosticInfo) },
        { },
    };

    static PyType_Spec type_spec_SystemDiagnosticInfo =
    {
        "winrt._winrt_windows_system_diagnostics.SystemDiagnosticInfo",
        sizeof(py::wrapper::Windows::System::Diagnostics::SystemDiagnosticInfo),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SystemDiagnosticInfo
    };

    static PyGetSetDef getset_SystemDiagnosticInfo_Static[] = {
        { "preferred_architecture", reinterpret_cast<getter>(SystemDiagnosticInfo_get_PreferredArchitecture), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_SystemDiagnosticInfo_Static[] = {
        { "get_for_current_system", reinterpret_cast<PyCFunction>(SystemDiagnosticInfo_GetForCurrentSystem), METH_VARARGS, nullptr },
        { "is_architecture_supported", reinterpret_cast<PyCFunction>(SystemDiagnosticInfo_IsArchitectureSupported), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_SystemDiagnosticInfo_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_SystemDiagnosticInfo_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_SystemDiagnosticInfo_Static) },
        { }
    };

    static PyType_Spec type_spec_SystemDiagnosticInfo_Static =
    {
        "winrt._winrt_windows_system_diagnostics.SystemDiagnosticInfo_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_SystemDiagnosticInfo_Static
    };

    // ----- SystemMemoryUsage class --------------------

    static PyObject* _new_SystemMemoryUsage(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::System::Diagnostics::SystemMemoryUsage>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::System::Diagnostics::SystemMemoryUsage>::type_name);
        return nullptr;
    }

    static void _dealloc_SystemMemoryUsage(py::wrapper::Windows::System::Diagnostics::SystemMemoryUsage* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SystemMemoryUsage_GetReport(py::wrapper::Windows::System::Diagnostics::SystemMemoryUsage* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.Diagnostics.SystemMemoryUsage", L"GetReport", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetReport());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_SystemMemoryUsage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::System::Diagnostics::SystemMemoryUsage>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SystemMemoryUsage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::Diagnostics::SystemMemoryUsage>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SystemMemoryUsage[] = {
        { "get_report", reinterpret_cast<PyCFunction>(SystemMemoryUsage_GetReport), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_SystemMemoryUsage, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SystemMemoryUsage), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SystemMemoryUsage[] = {
        { }
    };

    static PyType_Slot _type_slots_SystemMemoryUsage[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SystemMemoryUsage) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SystemMemoryUsage) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SystemMemoryUsage) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SystemMemoryUsage) },
        { },
    };

    static PyType_Spec type_spec_SystemMemoryUsage =
    {
        "winrt._winrt_windows_system_diagnostics.SystemMemoryUsage",
        sizeof(py::wrapper::Windows::System::Diagnostics::SystemMemoryUsage),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SystemMemoryUsage
    };

    // ----- SystemMemoryUsageReport class --------------------

    static PyObject* _new_SystemMemoryUsageReport(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::System::Diagnostics::SystemMemoryUsageReport>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::System::Diagnostics::SystemMemoryUsageReport>::type_name);
        return nullptr;
    }

    static void _dealloc_SystemMemoryUsageReport(py::wrapper::Windows::System::Diagnostics::SystemMemoryUsageReport* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SystemMemoryUsageReport_get_AvailableSizeInBytes(py::wrapper::Windows::System::Diagnostics::SystemMemoryUsageReport* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.Diagnostics.SystemMemoryUsageReport", L"AvailableSizeInBytes"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AvailableSizeInBytes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemMemoryUsageReport_get_CommittedSizeInBytes(py::wrapper::Windows::System::Diagnostics::SystemMemoryUsageReport* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.Diagnostics.SystemMemoryUsageReport", L"CommittedSizeInBytes"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CommittedSizeInBytes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemMemoryUsageReport_get_TotalPhysicalSizeInBytes(py::wrapper::Windows::System::Diagnostics::SystemMemoryUsageReport* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.Diagnostics.SystemMemoryUsageReport", L"TotalPhysicalSizeInBytes"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TotalPhysicalSizeInBytes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SystemMemoryUsageReport(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::System::Diagnostics::SystemMemoryUsageReport>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SystemMemoryUsageReport(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::Diagnostics::SystemMemoryUsageReport>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SystemMemoryUsageReport[] = {
        { "_assign_array_", _assign_array_SystemMemoryUsageReport, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SystemMemoryUsageReport), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SystemMemoryUsageReport[] = {
        { "available_size_in_bytes", reinterpret_cast<getter>(SystemMemoryUsageReport_get_AvailableSizeInBytes), nullptr, nullptr, nullptr },
        { "committed_size_in_bytes", reinterpret_cast<getter>(SystemMemoryUsageReport_get_CommittedSizeInBytes), nullptr, nullptr, nullptr },
        { "total_physical_size_in_bytes", reinterpret_cast<getter>(SystemMemoryUsageReport_get_TotalPhysicalSizeInBytes), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SystemMemoryUsageReport[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SystemMemoryUsageReport) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SystemMemoryUsageReport) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SystemMemoryUsageReport) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SystemMemoryUsageReport) },
        { },
    };

    static PyType_Spec type_spec_SystemMemoryUsageReport =
    {
        "winrt._winrt_windows_system_diagnostics.SystemMemoryUsageReport",
        sizeof(py::wrapper::Windows::System::Diagnostics::SystemMemoryUsageReport),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SystemMemoryUsageReport
    };

    // ----- Windows.System.Diagnostics Initialization --------------------
    PyDoc_STRVAR(module_doc, "Windows::System::Diagnostics");


    static PyModuleDef module_def
        = {PyModuleDef_HEAD_INIT,
           "_winrt_windows_system_diagnostics",
           module_doc,
           0,
           nullptr,
           nullptr,
           nullptr,
           nullptr,
           nullptr};

} // py::cpp::Windows::System::Diagnostics

PyMODINIT_FUNC PyInit__winrt_windows_system_diagnostics(void) noexcept
{
    using namespace py::cpp::Windows::System::Diagnostics;

    if (py::import_winrt_runtime() == -1)
    {
        return nullptr;
    }

    py::pyobj_handle module{PyModule_Create(&module_def)};

    if (!module)
    {
        return nullptr;
    }

    auto object_type = py::get_object_type();
    if (!object_type)
    {
        return nullptr;
    }

    py::pyobj_handle object_bases{PyTuple_Pack(1, object_type)};

    if (!object_bases)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_DiagnosticActionResult, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_DiagnosticInvoker_Static{PyType_FromSpec(&type_spec_DiagnosticInvoker_Static)};
    if (!type_DiagnosticInvoker_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_DiagnosticInvoker, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_DiagnosticInvoker_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ProcessCpuUsage, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ProcessCpuUsageReport, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_ProcessDiagnosticInfo_Static{PyType_FromSpec(&type_spec_ProcessDiagnosticInfo_Static)};
    if (!type_ProcessDiagnosticInfo_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ProcessDiagnosticInfo, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_ProcessDiagnosticInfo_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ProcessDiskUsage, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ProcessDiskUsageReport, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ProcessMemoryUsage, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ProcessMemoryUsageReport, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_SystemCpuUsage, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_SystemCpuUsageReport, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_SystemDiagnosticInfo_Static{PyType_FromSpec(&type_spec_SystemDiagnosticInfo_Static)};
    if (!type_SystemDiagnosticInfo_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_SystemDiagnosticInfo, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_SystemDiagnosticInfo_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_SystemMemoryUsage, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_SystemMemoryUsageReport, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }


    return module.detach();
}
