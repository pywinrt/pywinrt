# WARNING: Please don't edit this file. It was generated by Python/WinRT v2.0.0-beta.2

import datetime
import sys
import types
import typing
import uuid as _uuid
from builtins import property as _property

import winrt._winrt
import winrt.system
import winrt.microsoft.ui.xaml
import winrt.windows.foundation
import winrt.windows.foundation.collections
import winrt.windows.ui.xaml.interop

from winrt.microsoft.ui.xaml.data import BindingMode, RelativeSourceMode, UpdateSourceTrigger
from winrt.microsoft.ui.xaml.data import CurrentChangingEventHandler, PropertyChangedEventHandler

Self = typing.TypeVar('Self')

@typing.final
class LoadMoreItemsResult:
    count: winrt.system.UInt32
    def __init__(self, count: winrt.system.UInt32) -> None: ...

@typing.final
class Binding(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> Binding: ...
    def __new__(cls: typing.Type[Binding]) -> Binding:...
    @_property
    def update_source_trigger(self) -> UpdateSourceTrigger: ...
    @update_source_trigger.setter
    def update_source_trigger(self, value: UpdateSourceTrigger) -> None: ...
    @_property
    def target_null_value(self) -> typing.Optional[winrt.system.Object]: ...
    @target_null_value.setter
    def target_null_value(self, value: typing.Optional[winrt.system.Object]) -> None: ...
    @_property
    def source(self) -> typing.Optional[winrt.system.Object]: ...
    @source.setter
    def source(self, value: typing.Optional[winrt.system.Object]) -> None: ...
    @_property
    def relative_source(self) -> typing.Optional[RelativeSource]: ...
    @relative_source.setter
    def relative_source(self, value: typing.Optional[RelativeSource]) -> None: ...
    @_property
    def path(self) -> typing.Optional[winrt.microsoft.ui.xaml.PropertyPath]: ...
    @path.setter
    def path(self, value: typing.Optional[winrt.microsoft.ui.xaml.PropertyPath]) -> None: ...
    @_property
    def mode(self) -> BindingMode: ...
    @mode.setter
    def mode(self, value: BindingMode) -> None: ...
    @_property
    def fallback_value(self) -> typing.Optional[winrt.system.Object]: ...
    @fallback_value.setter
    def fallback_value(self, value: typing.Optional[winrt.system.Object]) -> None: ...
    @_property
    def element_name(self) -> str: ...
    @element_name.setter
    def element_name(self, value: str) -> None: ...
    @_property
    def converter_parameter(self) -> typing.Optional[winrt.system.Object]: ...
    @converter_parameter.setter
    def converter_parameter(self, value: typing.Optional[winrt.system.Object]) -> None: ...
    @_property
    def converter_language(self) -> str: ...
    @converter_language.setter
    def converter_language(self, value: str) -> None: ...
    @_property
    def converter(self) -> typing.Optional[IValueConverter]: ...
    @converter.setter
    def converter(self, value: typing.Optional[IValueConverter]) -> None: ...

@typing.final
class BindingBase(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> BindingBase: ...
    def __new__(cls: typing.Type[BindingBase]) -> BindingBase:...

@typing.final
class BindingExpression(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> BindingExpression: ...
    def update_source(self) -> None: ...
    @_property
    def data_item(self) -> typing.Optional[winrt.system.Object]: ...
    @_property
    def parent_binding(self) -> typing.Optional[Binding]: ...

@typing.final
class BindingExpressionBase(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> BindingExpressionBase: ...

@typing.final
class BindingOperations_Static(type):
    def set_binding(cls, target: typing.Optional[winrt.microsoft.ui.xaml.DependencyObject], dp: typing.Optional[winrt.microsoft.ui.xaml.DependencyProperty], binding: typing.Optional[BindingBase], /) -> None: ...

@typing.final
class BindingOperations(winrt.system.Object, metaclass=BindingOperations_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> BindingOperations: ...

@typing.final
class CollectionViewSource_Static(type):
    @_property
    def is_source_grouped_property(cls) -> typing.Optional[winrt.microsoft.ui.xaml.DependencyProperty]: ...
    @_property
    def items_path_property(cls) -> typing.Optional[winrt.microsoft.ui.xaml.DependencyProperty]: ...
    @_property
    def source_property(cls) -> typing.Optional[winrt.microsoft.ui.xaml.DependencyProperty]: ...
    @_property
    def view_property(cls) -> typing.Optional[winrt.microsoft.ui.xaml.DependencyProperty]: ...

@typing.final
class CollectionViewSource(winrt.system.Object, metaclass=CollectionViewSource_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> CollectionViewSource: ...
    def __new__(cls: typing.Type[CollectionViewSource]) -> CollectionViewSource:...
    @_property
    def source(self) -> typing.Optional[winrt.system.Object]: ...
    @source.setter
    def source(self, value: typing.Optional[winrt.system.Object]) -> None: ...
    @_property
    def items_path(self) -> typing.Optional[winrt.microsoft.ui.xaml.PropertyPath]: ...
    @items_path.setter
    def items_path(self, value: typing.Optional[winrt.microsoft.ui.xaml.PropertyPath]) -> None: ...
    @_property
    def is_source_grouped(self) -> bool: ...
    @is_source_grouped.setter
    def is_source_grouped(self, value: bool) -> None: ...
    @_property
    def view(self) -> typing.Optional[ICollectionView]: ...

@typing.final
class CurrentChangingEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> CurrentChangingEventArgs: ...
    @typing.overload
    def __new__(cls: typing.Type[CurrentChangingEventArgs]) -> CurrentChangingEventArgs:...
    @typing.overload
    def __new__(cls: typing.Type[CurrentChangingEventArgs], is_cancelable: bool) -> CurrentChangingEventArgs:...
    @_property
    def cancel(self) -> bool: ...
    @cancel.setter
    def cancel(self, value: bool) -> None: ...
    @_property
    def is_cancelable(self) -> bool: ...

@typing.final
class DataErrorsChangedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> DataErrorsChangedEventArgs: ...
    def __new__(cls: typing.Type[DataErrorsChangedEventArgs], name: str) -> DataErrorsChangedEventArgs:...
    @_property
    def property_name(self) -> str: ...
    @property_name.setter
    def property_name(self, value: str) -> None: ...

@typing.final
class ItemIndexRange(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ItemIndexRange: ...
    def __new__(cls: typing.Type[ItemIndexRange], first_index: winrt.system.Int32, length: winrt.system.UInt32) -> ItemIndexRange:...
    @_property
    def first_index(self) -> winrt.system.Int32: ...
    @_property
    def last_index(self) -> winrt.system.Int32: ...
    @_property
    def length(self) -> winrt.system.UInt32: ...

@typing.final
class PropertyChangedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> PropertyChangedEventArgs: ...
    def __new__(cls: typing.Type[PropertyChangedEventArgs], name: str) -> PropertyChangedEventArgs:...
    @_property
    def property_name(self) -> str: ...

@typing.final
class RelativeSource(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> RelativeSource: ...
    def __new__(cls: typing.Type[RelativeSource]) -> RelativeSource:...
    @_property
    def mode(self) -> RelativeSourceMode: ...
    @mode.setter
    def mode(self, value: RelativeSourceMode) -> None: ...

@typing.final
class ICollectionView(winrt.system.Object, winrt._winrt.MutableSequence[winrt.system.Object]):
    def __len__(self) -> int: ...
    def __iter__(self) -> winrt.windows.foundation.collections.IIterator[winrt.system.Object]: ...
    @typing.overload
    def __getitem__(self, index: typing.SupportsIndex) -> winrt.system.Object: ...
    @typing.overload
    def __getitem__(self, index: slice) -> winrt.system.Array[winrt.system.Object]: ...
    @typing.overload
    def __delitem__(self, index: typing.SupportsIndex) -> None: ...
    @typing.overload
    def __delitem__(self, index: slice) -> None: ...
    @typing.overload
    def __setitem__(self, index: typing.SupportsIndex, value: winrt.system.Object) -> None: ...
    @typing.overload
    def __setitem__(self, index: slice, value: typing.Iterable[winrt.system.Object]) -> None: ...
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ICollectionView: ...
    def append(self, value: typing.Optional[winrt.system.Object], /) -> None: ...
    def clear(self) -> None: ...
    def first(self) -> typing.Optional[winrt.windows.foundation.collections.IIterator[winrt.system.Object]]: ...
    def get_at(self, index: winrt.system.UInt32, /) -> typing.Optional[winrt.system.Object]: ...
    def get_many(self, start_index: winrt.system.UInt32, items: winrt.system.Array[winrt.system.Object], /) -> winrt.system.UInt32: ...
    def get_view(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[winrt.system.Object]]: ...
    def index_of(self, value: typing.Optional[winrt.system.Object], /) -> typing.Tuple[bool, winrt.system.UInt32]: ...
    def insert_at(self, index: winrt.system.UInt32, value: typing.Optional[winrt.system.Object], /) -> None: ...
    def load_more_items_async(self, count: winrt.system.UInt32, /) -> winrt.windows.foundation.IAsyncOperation[LoadMoreItemsResult]: ...
    def move_current_to(self, item: typing.Optional[winrt.system.Object], /) -> bool: ...
    def move_current_to_first(self) -> bool: ...
    def move_current_to_last(self) -> bool: ...
    def move_current_to_next(self) -> bool: ...
    def move_current_to_position(self, index: winrt.system.Int32, /) -> bool: ...
    def move_current_to_previous(self) -> bool: ...
    def remove_at(self, index: winrt.system.UInt32, /) -> None: ...
    def remove_at_end(self) -> None: ...
    def replace_all(self, items: winrt.system.Array[winrt.system.Object], /) -> None: ...
    def set_at(self, index: winrt.system.UInt32, value: typing.Optional[winrt.system.Object], /) -> None: ...
    def add_current_changed(self, handler: winrt.windows.foundation.EventHandler[winrt.system.Object], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_current_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_current_changing(self, handler: typing.Optional[CurrentChangingEventHandler], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_current_changing(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_vector_changed(self, vhnd: winrt.windows.foundation.collections.VectorChangedEventHandler[winrt.system.Object], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_vector_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    @_property
    def collection_groups(self) -> typing.Optional[winrt.windows.foundation.collections.IObservableVector[winrt.system.Object]]: ...
    @_property
    def current_item(self) -> typing.Optional[winrt.system.Object]: ...
    @_property
    def current_position(self) -> winrt.system.Int32: ...
    @_property
    def has_more_items(self) -> bool: ...
    @_property
    def is_current_after_last(self) -> bool: ...
    @_property
    def is_current_before_first(self) -> bool: ...
    @_property
    def size(self) -> winrt.system.UInt32: ...

@typing.final
class ICollectionViewFactory(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ICollectionViewFactory: ...
    def create_view(self) -> typing.Optional[ICollectionView]: ...

@typing.final
class ICollectionViewGroup(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ICollectionViewGroup: ...
    @_property
    def group(self) -> typing.Optional[winrt.system.Object]: ...
    @_property
    def group_items(self) -> typing.Optional[winrt.windows.foundation.collections.IObservableVector[winrt.system.Object]]: ...

@typing.final
class ICustomProperty(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ICustomProperty: ...
    def get_indexed_value(self, target: typing.Optional[winrt.system.Object], index: typing.Optional[winrt.system.Object], /) -> typing.Optional[winrt.system.Object]: ...
    def get_value(self, target: typing.Optional[winrt.system.Object], /) -> typing.Optional[winrt.system.Object]: ...
    def set_indexed_value(self, target: typing.Optional[winrt.system.Object], value: typing.Optional[winrt.system.Object], index: typing.Optional[winrt.system.Object], /) -> None: ...
    def set_value(self, target: typing.Optional[winrt.system.Object], value: typing.Optional[winrt.system.Object], /) -> None: ...
    @_property
    def can_read(self) -> bool: ...
    @_property
    def can_write(self) -> bool: ...
    @_property
    def name(self) -> str: ...
    @_property
    def type(self) -> winrt.windows.ui.xaml.interop.TypeName: ...

@typing.final
class ICustomPropertyProvider(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ICustomPropertyProvider: ...
    def get_custom_property(self, name: str, /) -> typing.Optional[ICustomProperty]: ...
    def get_indexed_property(self, name: str, type: winrt.windows.ui.xaml.interop.TypeName, /) -> typing.Optional[ICustomProperty]: ...
    def get_string_representation(self) -> str: ...
    @_property
    def type(self) -> winrt.windows.ui.xaml.interop.TypeName: ...

@typing.final
class IItemsRangeInfo(winrt.system.Object):
    def __enter__(self: Self) -> Self: ...
    def __exit__(self, *args) -> None: ...
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> IItemsRangeInfo: ...
    def close(self) -> None: ...
    def ranges_changed(self, visible_range: typing.Optional[ItemIndexRange], tracked_items: winrt.windows.foundation.collections.IVectorView[ItemIndexRange], /) -> None: ...

@typing.final
class INotifyDataErrorInfo(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> INotifyDataErrorInfo: ...
    def get_errors(self, property_name: str, /) -> typing.Optional[winrt.windows.foundation.collections.IIterable[winrt.system.Object]]: ...
    def add_errors_changed(self, handler: winrt.windows.foundation.EventHandler[DataErrorsChangedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_errors_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    @_property
    def has_errors(self) -> bool: ...

@typing.final
class INotifyPropertyChanged(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> INotifyPropertyChanged: ...
    def add_property_changed(self, handler: typing.Optional[PropertyChangedEventHandler], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_property_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...

@typing.final
class ISelectionInfo(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ISelectionInfo: ...
    def deselect_range(self, item_index_range: typing.Optional[ItemIndexRange], /) -> None: ...
    def get_selected_ranges(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[ItemIndexRange]]: ...
    def is_selected(self, index: winrt.system.Int32, /) -> bool: ...
    def select_range(self, item_index_range: typing.Optional[ItemIndexRange], /) -> None: ...

@typing.final
class ISupportIncrementalLoading(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ISupportIncrementalLoading: ...
    def load_more_items_async(self, count: winrt.system.UInt32, /) -> winrt.windows.foundation.IAsyncOperation[LoadMoreItemsResult]: ...
    @_property
    def has_more_items(self) -> bool: ...

@typing.final
class IValueConverter(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> IValueConverter: ...
    def convert(self, value: typing.Optional[winrt.system.Object], target_type: winrt.windows.ui.xaml.interop.TypeName, parameter: typing.Optional[winrt.system.Object], language: str, /) -> typing.Optional[winrt.system.Object]: ...
    def convert_back(self, value: typing.Optional[winrt.system.Object], target_type: winrt.windows.ui.xaml.interop.TypeName, parameter: typing.Optional[winrt.system.Object], language: str, /) -> typing.Optional[winrt.system.Object]: ...

