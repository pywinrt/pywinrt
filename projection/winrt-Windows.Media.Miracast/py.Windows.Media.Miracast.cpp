// WARNING: Please don't edit this file. It was generated by Python/WinRT v2.0.0-beta.2

#include "py.Windows.Media.Miracast.h"


namespace py::cpp::Windows::Media::Miracast
{
    // ----- MiracastReceiver class --------------------

    static PyObject* _new_MiracastReceiver(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Media::Miracast::MiracastReceiver instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MiracastReceiver(py::wrapper::Windows::Media::Miracast::MiracastReceiver* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MiracastReceiver_ClearKnownTransmitters(py::wrapper::Windows::Media::Miracast::MiracastReceiver* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Miracast.MiracastReceiver", L"ClearKnownTransmitters", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.ClearKnownTransmitters();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MiracastReceiver_CreateSession(py::wrapper::Windows::Media::Miracast::MiracastReceiver* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Miracast.MiracastReceiver", L"CreateSession", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Core::CoreApplicationView>(args, 0);

                return py::convert(self->obj.CreateSession(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MiracastReceiver_CreateSessionAsync(py::wrapper::Windows::Media::Miracast::MiracastReceiver* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Miracast.MiracastReceiver", L"CreateSessionAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Core::CoreApplicationView>(args, 0);

                return py::convert(self->obj.CreateSessionAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MiracastReceiver_DisconnectAllAndApplySettings(py::wrapper::Windows::Media::Miracast::MiracastReceiver* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Miracast.MiracastReceiver", L"DisconnectAllAndApplySettings", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Miracast::MiracastReceiverSettings>(args, 0);

                return py::convert(self->obj.DisconnectAllAndApplySettings(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MiracastReceiver_DisconnectAllAndApplySettingsAsync(py::wrapper::Windows::Media::Miracast::MiracastReceiver* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Miracast.MiracastReceiver", L"DisconnectAllAndApplySettingsAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Miracast::MiracastReceiverSettings>(args, 0);

                return py::convert(self->obj.DisconnectAllAndApplySettingsAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MiracastReceiver_GetCurrentSettings(py::wrapper::Windows::Media::Miracast::MiracastReceiver* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Miracast.MiracastReceiver", L"GetCurrentSettings", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetCurrentSettings());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MiracastReceiver_GetCurrentSettingsAsync(py::wrapper::Windows::Media::Miracast::MiracastReceiver* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Miracast.MiracastReceiver", L"GetCurrentSettingsAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetCurrentSettingsAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MiracastReceiver_GetDefaultSettings(py::wrapper::Windows::Media::Miracast::MiracastReceiver* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Miracast.MiracastReceiver", L"GetDefaultSettings", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetDefaultSettings());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MiracastReceiver_GetStatus(py::wrapper::Windows::Media::Miracast::MiracastReceiver* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Miracast.MiracastReceiver", L"GetStatus", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetStatus());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MiracastReceiver_GetStatusAsync(py::wrapper::Windows::Media::Miracast::MiracastReceiver* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Miracast.MiracastReceiver", L"GetStatusAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetStatusAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MiracastReceiver_RemoveKnownTransmitter(py::wrapper::Windows::Media::Miracast::MiracastReceiver* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Miracast.MiracastReceiver", L"RemoveKnownTransmitter", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Miracast::MiracastTransmitter>(args, 0);

                self->obj.RemoveKnownTransmitter(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MiracastReceiver_add_StatusChanged(py::wrapper::Windows::Media::Miracast::MiracastReceiver* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Miracast.MiracastReceiver", L"StatusChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Miracast::MiracastReceiver, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.StatusChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MiracastReceiver_remove_StatusChanged(py::wrapper::Windows::Media::Miracast::MiracastReceiver* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Miracast.MiracastReceiver", L"StatusChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.StatusChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MiracastReceiver(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Miracast::MiracastReceiver>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MiracastReceiver(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Miracast::MiracastReceiver>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MiracastReceiver[] = {
        { "clear_known_transmitters", reinterpret_cast<PyCFunction>(MiracastReceiver_ClearKnownTransmitters), METH_VARARGS, nullptr },
        { "create_session", reinterpret_cast<PyCFunction>(MiracastReceiver_CreateSession), METH_VARARGS, nullptr },
        { "create_session_async", reinterpret_cast<PyCFunction>(MiracastReceiver_CreateSessionAsync), METH_VARARGS, nullptr },
        { "disconnect_all_and_apply_settings", reinterpret_cast<PyCFunction>(MiracastReceiver_DisconnectAllAndApplySettings), METH_VARARGS, nullptr },
        { "disconnect_all_and_apply_settings_async", reinterpret_cast<PyCFunction>(MiracastReceiver_DisconnectAllAndApplySettingsAsync), METH_VARARGS, nullptr },
        { "get_current_settings", reinterpret_cast<PyCFunction>(MiracastReceiver_GetCurrentSettings), METH_VARARGS, nullptr },
        { "get_current_settings_async", reinterpret_cast<PyCFunction>(MiracastReceiver_GetCurrentSettingsAsync), METH_VARARGS, nullptr },
        { "get_default_settings", reinterpret_cast<PyCFunction>(MiracastReceiver_GetDefaultSettings), METH_VARARGS, nullptr },
        { "get_status", reinterpret_cast<PyCFunction>(MiracastReceiver_GetStatus), METH_VARARGS, nullptr },
        { "get_status_async", reinterpret_cast<PyCFunction>(MiracastReceiver_GetStatusAsync), METH_VARARGS, nullptr },
        { "remove_known_transmitter", reinterpret_cast<PyCFunction>(MiracastReceiver_RemoveKnownTransmitter), METH_VARARGS, nullptr },
        { "add_status_changed", reinterpret_cast<PyCFunction>(MiracastReceiver_add_StatusChanged), METH_O, nullptr },
        { "remove_status_changed", reinterpret_cast<PyCFunction>(MiracastReceiver_remove_StatusChanged), METH_O, nullptr },
        { "_assign_array_", _assign_array_MiracastReceiver, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MiracastReceiver), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MiracastReceiver[] = {
        { }
    };

    static PyType_Slot _type_slots_MiracastReceiver[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MiracastReceiver) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MiracastReceiver) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MiracastReceiver) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MiracastReceiver) },
        { },
    };

    static PyType_Spec type_spec_MiracastReceiver =
    {
        "winrt._winrt_windows_media_miracast.MiracastReceiver",
        sizeof(py::wrapper::Windows::Media::Miracast::MiracastReceiver),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MiracastReceiver
    };

    // ----- MiracastReceiverApplySettingsResult class --------------------

    static PyObject* _new_MiracastReceiverApplySettingsResult(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Miracast::MiracastReceiverApplySettingsResult>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Miracast::MiracastReceiverApplySettingsResult>::type_name);
        return nullptr;
    }

    static void _dealloc_MiracastReceiverApplySettingsResult(py::wrapper::Windows::Media::Miracast::MiracastReceiverApplySettingsResult* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MiracastReceiverApplySettingsResult_get_ExtendedError(py::wrapper::Windows::Media::Miracast::MiracastReceiverApplySettingsResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Miracast.MiracastReceiverApplySettingsResult", L"ExtendedError"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ExtendedError());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MiracastReceiverApplySettingsResult_get_Status(py::wrapper::Windows::Media::Miracast::MiracastReceiverApplySettingsResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Miracast.MiracastReceiverApplySettingsResult", L"Status"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MiracastReceiverApplySettingsResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Miracast::MiracastReceiverApplySettingsResult>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MiracastReceiverApplySettingsResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Miracast::MiracastReceiverApplySettingsResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MiracastReceiverApplySettingsResult[] = {
        { "_assign_array_", _assign_array_MiracastReceiverApplySettingsResult, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MiracastReceiverApplySettingsResult), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MiracastReceiverApplySettingsResult[] = {
        { "extended_error", reinterpret_cast<getter>(MiracastReceiverApplySettingsResult_get_ExtendedError), nullptr, nullptr, nullptr },
        { "status", reinterpret_cast<getter>(MiracastReceiverApplySettingsResult_get_Status), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MiracastReceiverApplySettingsResult[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MiracastReceiverApplySettingsResult) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MiracastReceiverApplySettingsResult) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MiracastReceiverApplySettingsResult) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MiracastReceiverApplySettingsResult) },
        { },
    };

    static PyType_Spec type_spec_MiracastReceiverApplySettingsResult =
    {
        "winrt._winrt_windows_media_miracast.MiracastReceiverApplySettingsResult",
        sizeof(py::wrapper::Windows::Media::Miracast::MiracastReceiverApplySettingsResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MiracastReceiverApplySettingsResult
    };

    // ----- MiracastReceiverConnection class --------------------

    static PyObject* _new_MiracastReceiverConnection(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Miracast::MiracastReceiverConnection>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Miracast::MiracastReceiverConnection>::type_name);
        return nullptr;
    }

    static void _dealloc_MiracastReceiverConnection(py::wrapper::Windows::Media::Miracast::MiracastReceiverConnection* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MiracastReceiverConnection_Close(py::wrapper::Windows::Media::Miracast::MiracastReceiverConnection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Miracast.MiracastReceiverConnection", L"Close", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MiracastReceiverConnection_Disconnect(py::wrapper::Windows::Media::Miracast::MiracastReceiverConnection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Miracast.MiracastReceiverConnection", L"Disconnect", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Miracast::MiracastReceiverDisconnectReason>(args, 0);

                self->obj.Disconnect(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Miracast.MiracastReceiverConnection", L"Disconnect", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Miracast::MiracastReceiverDisconnectReason>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                self->obj.Disconnect(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MiracastReceiverConnection_Pause(py::wrapper::Windows::Media::Miracast::MiracastReceiverConnection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Miracast.MiracastReceiverConnection", L"Pause", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Pause();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MiracastReceiverConnection_PauseAsync(py::wrapper::Windows::Media::Miracast::MiracastReceiverConnection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Miracast.MiracastReceiverConnection", L"PauseAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.PauseAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MiracastReceiverConnection_Resume(py::wrapper::Windows::Media::Miracast::MiracastReceiverConnection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Miracast.MiracastReceiverConnection", L"Resume", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Resume();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MiracastReceiverConnection_ResumeAsync(py::wrapper::Windows::Media::Miracast::MiracastReceiverConnection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Miracast.MiracastReceiverConnection", L"ResumeAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.ResumeAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MiracastReceiverConnection_get_CursorImageChannel(py::wrapper::Windows::Media::Miracast::MiracastReceiverConnection* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Miracast.MiracastReceiverConnection", L"CursorImageChannel"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CursorImageChannel());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MiracastReceiverConnection_get_InputDevices(py::wrapper::Windows::Media::Miracast::MiracastReceiverConnection* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Miracast.MiracastReceiverConnection", L"InputDevices"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.InputDevices());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MiracastReceiverConnection_get_StreamControl(py::wrapper::Windows::Media::Miracast::MiracastReceiverConnection* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Miracast.MiracastReceiverConnection", L"StreamControl"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.StreamControl());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MiracastReceiverConnection_get_Transmitter(py::wrapper::Windows::Media::Miracast::MiracastReceiverConnection* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Miracast.MiracastReceiverConnection", L"Transmitter"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Transmitter());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MiracastReceiverConnection(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Miracast::MiracastReceiverConnection>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MiracastReceiverConnection(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Miracast::MiracastReceiverConnection>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_MiracastReceiverConnection(py::wrapper::Windows::Media::Miracast::MiracastReceiverConnection* self, PyObject* /*unused*/) noexcept
    {
        return Py_NewRef(self);
    }

    static PyObject* _exit_MiracastReceiverConnection(py::wrapper::Windows::Media::Miracast::MiracastReceiverConnection* self, PyObject* /*unused*/) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MiracastReceiverConnection[] = {
        { "close", reinterpret_cast<PyCFunction>(MiracastReceiverConnection_Close), METH_VARARGS, nullptr },
        { "disconnect", reinterpret_cast<PyCFunction>(MiracastReceiverConnection_Disconnect), METH_VARARGS, nullptr },
        { "pause", reinterpret_cast<PyCFunction>(MiracastReceiverConnection_Pause), METH_VARARGS, nullptr },
        { "pause_async", reinterpret_cast<PyCFunction>(MiracastReceiverConnection_PauseAsync), METH_VARARGS, nullptr },
        { "resume", reinterpret_cast<PyCFunction>(MiracastReceiverConnection_Resume), METH_VARARGS, nullptr },
        { "resume_async", reinterpret_cast<PyCFunction>(MiracastReceiverConnection_ResumeAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_MiracastReceiverConnection, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MiracastReceiverConnection), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_MiracastReceiverConnection), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_MiracastReceiverConnection), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_MiracastReceiverConnection[] = {
        { "cursor_image_channel", reinterpret_cast<getter>(MiracastReceiverConnection_get_CursorImageChannel), nullptr, nullptr, nullptr },
        { "input_devices", reinterpret_cast<getter>(MiracastReceiverConnection_get_InputDevices), nullptr, nullptr, nullptr },
        { "stream_control", reinterpret_cast<getter>(MiracastReceiverConnection_get_StreamControl), nullptr, nullptr, nullptr },
        { "transmitter", reinterpret_cast<getter>(MiracastReceiverConnection_get_Transmitter), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MiracastReceiverConnection[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MiracastReceiverConnection) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MiracastReceiverConnection) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MiracastReceiverConnection) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MiracastReceiverConnection) },
        { },
    };

    static PyType_Spec type_spec_MiracastReceiverConnection =
    {
        "winrt._winrt_windows_media_miracast.MiracastReceiverConnection",
        sizeof(py::wrapper::Windows::Media::Miracast::MiracastReceiverConnection),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MiracastReceiverConnection
    };

    // ----- MiracastReceiverConnectionCreatedEventArgs class --------------------

    static PyObject* _new_MiracastReceiverConnectionCreatedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Miracast::MiracastReceiverConnectionCreatedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Miracast::MiracastReceiverConnectionCreatedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_MiracastReceiverConnectionCreatedEventArgs(py::wrapper::Windows::Media::Miracast::MiracastReceiverConnectionCreatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MiracastReceiverConnectionCreatedEventArgs_GetDeferral(py::wrapper::Windows::Media::Miracast::MiracastReceiverConnectionCreatedEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Miracast.MiracastReceiverConnectionCreatedEventArgs", L"GetDeferral", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MiracastReceiverConnectionCreatedEventArgs_get_Connection(py::wrapper::Windows::Media::Miracast::MiracastReceiverConnectionCreatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Miracast.MiracastReceiverConnectionCreatedEventArgs", L"Connection"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Connection());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MiracastReceiverConnectionCreatedEventArgs_get_Pin(py::wrapper::Windows::Media::Miracast::MiracastReceiverConnectionCreatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Miracast.MiracastReceiverConnectionCreatedEventArgs", L"Pin"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Pin());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MiracastReceiverConnectionCreatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Miracast::MiracastReceiverConnectionCreatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MiracastReceiverConnectionCreatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Miracast::MiracastReceiverConnectionCreatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MiracastReceiverConnectionCreatedEventArgs[] = {
        { "get_deferral", reinterpret_cast<PyCFunction>(MiracastReceiverConnectionCreatedEventArgs_GetDeferral), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_MiracastReceiverConnectionCreatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MiracastReceiverConnectionCreatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MiracastReceiverConnectionCreatedEventArgs[] = {
        { "connection", reinterpret_cast<getter>(MiracastReceiverConnectionCreatedEventArgs_get_Connection), nullptr, nullptr, nullptr },
        { "pin", reinterpret_cast<getter>(MiracastReceiverConnectionCreatedEventArgs_get_Pin), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MiracastReceiverConnectionCreatedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MiracastReceiverConnectionCreatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MiracastReceiverConnectionCreatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MiracastReceiverConnectionCreatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MiracastReceiverConnectionCreatedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_MiracastReceiverConnectionCreatedEventArgs =
    {
        "winrt._winrt_windows_media_miracast.MiracastReceiverConnectionCreatedEventArgs",
        sizeof(py::wrapper::Windows::Media::Miracast::MiracastReceiverConnectionCreatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MiracastReceiverConnectionCreatedEventArgs
    };

    // ----- MiracastReceiverCursorImageChannel class --------------------

    static PyObject* _new_MiracastReceiverCursorImageChannel(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Miracast::MiracastReceiverCursorImageChannel>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Miracast::MiracastReceiverCursorImageChannel>::type_name);
        return nullptr;
    }

    static void _dealloc_MiracastReceiverCursorImageChannel(py::wrapper::Windows::Media::Miracast::MiracastReceiverCursorImageChannel* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MiracastReceiverCursorImageChannel_get_ImageStream(py::wrapper::Windows::Media::Miracast::MiracastReceiverCursorImageChannel* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Miracast.MiracastReceiverCursorImageChannel", L"ImageStream"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ImageStream());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MiracastReceiverCursorImageChannel_get_IsEnabled(py::wrapper::Windows::Media::Miracast::MiracastReceiverCursorImageChannel* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Miracast.MiracastReceiverCursorImageChannel", L"IsEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MiracastReceiverCursorImageChannel_get_MaxImageSize(py::wrapper::Windows::Media::Miracast::MiracastReceiverCursorImageChannel* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Miracast.MiracastReceiverCursorImageChannel", L"MaxImageSize"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MaxImageSize());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MiracastReceiverCursorImageChannel_get_Position(py::wrapper::Windows::Media::Miracast::MiracastReceiverCursorImageChannel* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Miracast.MiracastReceiverCursorImageChannel", L"Position"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Position());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MiracastReceiverCursorImageChannel_add_ImageStreamChanged(py::wrapper::Windows::Media::Miracast::MiracastReceiverCursorImageChannel* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Miracast.MiracastReceiverCursorImageChannel", L"ImageStreamChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Miracast::MiracastReceiverCursorImageChannel, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.ImageStreamChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MiracastReceiverCursorImageChannel_remove_ImageStreamChanged(py::wrapper::Windows::Media::Miracast::MiracastReceiverCursorImageChannel* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Miracast.MiracastReceiverCursorImageChannel", L"ImageStreamChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ImageStreamChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MiracastReceiverCursorImageChannel_add_PositionChanged(py::wrapper::Windows::Media::Miracast::MiracastReceiverCursorImageChannel* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Miracast.MiracastReceiverCursorImageChannel", L"PositionChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Miracast::MiracastReceiverCursorImageChannel, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.PositionChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MiracastReceiverCursorImageChannel_remove_PositionChanged(py::wrapper::Windows::Media::Miracast::MiracastReceiverCursorImageChannel* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Miracast.MiracastReceiverCursorImageChannel", L"PositionChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.PositionChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MiracastReceiverCursorImageChannel(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Miracast::MiracastReceiverCursorImageChannel>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MiracastReceiverCursorImageChannel(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Miracast::MiracastReceiverCursorImageChannel>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MiracastReceiverCursorImageChannel[] = {
        { "add_image_stream_changed", reinterpret_cast<PyCFunction>(MiracastReceiverCursorImageChannel_add_ImageStreamChanged), METH_O, nullptr },
        { "remove_image_stream_changed", reinterpret_cast<PyCFunction>(MiracastReceiverCursorImageChannel_remove_ImageStreamChanged), METH_O, nullptr },
        { "add_position_changed", reinterpret_cast<PyCFunction>(MiracastReceiverCursorImageChannel_add_PositionChanged), METH_O, nullptr },
        { "remove_position_changed", reinterpret_cast<PyCFunction>(MiracastReceiverCursorImageChannel_remove_PositionChanged), METH_O, nullptr },
        { "_assign_array_", _assign_array_MiracastReceiverCursorImageChannel, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MiracastReceiverCursorImageChannel), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MiracastReceiverCursorImageChannel[] = {
        { "image_stream", reinterpret_cast<getter>(MiracastReceiverCursorImageChannel_get_ImageStream), nullptr, nullptr, nullptr },
        { "is_enabled", reinterpret_cast<getter>(MiracastReceiverCursorImageChannel_get_IsEnabled), nullptr, nullptr, nullptr },
        { "max_image_size", reinterpret_cast<getter>(MiracastReceiverCursorImageChannel_get_MaxImageSize), nullptr, nullptr, nullptr },
        { "position", reinterpret_cast<getter>(MiracastReceiverCursorImageChannel_get_Position), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MiracastReceiverCursorImageChannel[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MiracastReceiverCursorImageChannel) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MiracastReceiverCursorImageChannel) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MiracastReceiverCursorImageChannel) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MiracastReceiverCursorImageChannel) },
        { },
    };

    static PyType_Spec type_spec_MiracastReceiverCursorImageChannel =
    {
        "winrt._winrt_windows_media_miracast.MiracastReceiverCursorImageChannel",
        sizeof(py::wrapper::Windows::Media::Miracast::MiracastReceiverCursorImageChannel),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MiracastReceiverCursorImageChannel
    };

    // ----- MiracastReceiverCursorImageChannelSettings class --------------------

    static PyObject* _new_MiracastReceiverCursorImageChannelSettings(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Miracast::MiracastReceiverCursorImageChannelSettings>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Miracast::MiracastReceiverCursorImageChannelSettings>::type_name);
        return nullptr;
    }

    static void _dealloc_MiracastReceiverCursorImageChannelSettings(py::wrapper::Windows::Media::Miracast::MiracastReceiverCursorImageChannelSettings* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MiracastReceiverCursorImageChannelSettings_get_MaxImageSize(py::wrapper::Windows::Media::Miracast::MiracastReceiverCursorImageChannelSettings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Miracast.MiracastReceiverCursorImageChannelSettings", L"MaxImageSize"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MaxImageSize());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MiracastReceiverCursorImageChannelSettings_put_MaxImageSize(py::wrapper::Windows::Media::Miracast::MiracastReceiverCursorImageChannelSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Miracast.MiracastReceiverCursorImageChannelSettings", L"MaxImageSize"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Graphics::SizeInt32>(arg);

            self->obj.MaxImageSize(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MiracastReceiverCursorImageChannelSettings_get_IsEnabled(py::wrapper::Windows::Media::Miracast::MiracastReceiverCursorImageChannelSettings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Miracast.MiracastReceiverCursorImageChannelSettings", L"IsEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MiracastReceiverCursorImageChannelSettings_put_IsEnabled(py::wrapper::Windows::Media::Miracast::MiracastReceiverCursorImageChannelSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Miracast.MiracastReceiverCursorImageChannelSettings", L"IsEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_MiracastReceiverCursorImageChannelSettings(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Miracast::MiracastReceiverCursorImageChannelSettings>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MiracastReceiverCursorImageChannelSettings(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Miracast::MiracastReceiverCursorImageChannelSettings>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MiracastReceiverCursorImageChannelSettings[] = {
        { "_assign_array_", _assign_array_MiracastReceiverCursorImageChannelSettings, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MiracastReceiverCursorImageChannelSettings), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MiracastReceiverCursorImageChannelSettings[] = {
        { "max_image_size", reinterpret_cast<getter>(MiracastReceiverCursorImageChannelSettings_get_MaxImageSize), reinterpret_cast<setter>(MiracastReceiverCursorImageChannelSettings_put_MaxImageSize), nullptr, nullptr },
        { "is_enabled", reinterpret_cast<getter>(MiracastReceiverCursorImageChannelSettings_get_IsEnabled), reinterpret_cast<setter>(MiracastReceiverCursorImageChannelSettings_put_IsEnabled), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MiracastReceiverCursorImageChannelSettings[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MiracastReceiverCursorImageChannelSettings) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MiracastReceiverCursorImageChannelSettings) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MiracastReceiverCursorImageChannelSettings) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MiracastReceiverCursorImageChannelSettings) },
        { },
    };

    static PyType_Spec type_spec_MiracastReceiverCursorImageChannelSettings =
    {
        "winrt._winrt_windows_media_miracast.MiracastReceiverCursorImageChannelSettings",
        sizeof(py::wrapper::Windows::Media::Miracast::MiracastReceiverCursorImageChannelSettings),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MiracastReceiverCursorImageChannelSettings
    };

    // ----- MiracastReceiverDisconnectedEventArgs class --------------------

    static PyObject* _new_MiracastReceiverDisconnectedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Miracast::MiracastReceiverDisconnectedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Miracast::MiracastReceiverDisconnectedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_MiracastReceiverDisconnectedEventArgs(py::wrapper::Windows::Media::Miracast::MiracastReceiverDisconnectedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MiracastReceiverDisconnectedEventArgs_get_Connection(py::wrapper::Windows::Media::Miracast::MiracastReceiverDisconnectedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Miracast.MiracastReceiverDisconnectedEventArgs", L"Connection"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Connection());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MiracastReceiverDisconnectedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Miracast::MiracastReceiverDisconnectedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MiracastReceiverDisconnectedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Miracast::MiracastReceiverDisconnectedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MiracastReceiverDisconnectedEventArgs[] = {
        { "_assign_array_", _assign_array_MiracastReceiverDisconnectedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MiracastReceiverDisconnectedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MiracastReceiverDisconnectedEventArgs[] = {
        { "connection", reinterpret_cast<getter>(MiracastReceiverDisconnectedEventArgs_get_Connection), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MiracastReceiverDisconnectedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MiracastReceiverDisconnectedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MiracastReceiverDisconnectedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MiracastReceiverDisconnectedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MiracastReceiverDisconnectedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_MiracastReceiverDisconnectedEventArgs =
    {
        "winrt._winrt_windows_media_miracast.MiracastReceiverDisconnectedEventArgs",
        sizeof(py::wrapper::Windows::Media::Miracast::MiracastReceiverDisconnectedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MiracastReceiverDisconnectedEventArgs
    };

    // ----- MiracastReceiverGameControllerDevice class --------------------

    static PyObject* _new_MiracastReceiverGameControllerDevice(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Miracast::MiracastReceiverGameControllerDevice>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Miracast::MiracastReceiverGameControllerDevice>::type_name);
        return nullptr;
    }

    static void _dealloc_MiracastReceiverGameControllerDevice(py::wrapper::Windows::Media::Miracast::MiracastReceiverGameControllerDevice* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MiracastReceiverGameControllerDevice_get_TransmitInput(py::wrapper::Windows::Media::Miracast::MiracastReceiverGameControllerDevice* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Miracast.MiracastReceiverGameControllerDevice", L"TransmitInput"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TransmitInput());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MiracastReceiverGameControllerDevice_put_TransmitInput(py::wrapper::Windows::Media::Miracast::MiracastReceiverGameControllerDevice* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Miracast.MiracastReceiverGameControllerDevice", L"TransmitInput"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.TransmitInput(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MiracastReceiverGameControllerDevice_get_Mode(py::wrapper::Windows::Media::Miracast::MiracastReceiverGameControllerDevice* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Miracast.MiracastReceiverGameControllerDevice", L"Mode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Mode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MiracastReceiverGameControllerDevice_put_Mode(py::wrapper::Windows::Media::Miracast::MiracastReceiverGameControllerDevice* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Miracast.MiracastReceiverGameControllerDevice", L"Mode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Miracast::MiracastReceiverGameControllerDeviceUsageMode>(arg);

            self->obj.Mode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MiracastReceiverGameControllerDevice_get_IsRequestedByTransmitter(py::wrapper::Windows::Media::Miracast::MiracastReceiverGameControllerDevice* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Miracast.MiracastReceiverGameControllerDevice", L"IsRequestedByTransmitter"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsRequestedByTransmitter());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MiracastReceiverGameControllerDevice_get_IsTransmittingInput(py::wrapper::Windows::Media::Miracast::MiracastReceiverGameControllerDevice* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Miracast.MiracastReceiverGameControllerDevice", L"IsTransmittingInput"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsTransmittingInput());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MiracastReceiverGameControllerDevice_add_Changed(py::wrapper::Windows::Media::Miracast::MiracastReceiverGameControllerDevice* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Miracast.MiracastReceiverGameControllerDevice", L"Changed"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Miracast::MiracastReceiverGameControllerDevice, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.Changed(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MiracastReceiverGameControllerDevice_remove_Changed(py::wrapper::Windows::Media::Miracast::MiracastReceiverGameControllerDevice* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Miracast.MiracastReceiverGameControllerDevice", L"Changed"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Changed(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MiracastReceiverGameControllerDevice(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Miracast::MiracastReceiverGameControllerDevice>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MiracastReceiverGameControllerDevice(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Miracast::MiracastReceiverGameControllerDevice>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MiracastReceiverGameControllerDevice[] = {
        { "add_changed", reinterpret_cast<PyCFunction>(MiracastReceiverGameControllerDevice_add_Changed), METH_O, nullptr },
        { "remove_changed", reinterpret_cast<PyCFunction>(MiracastReceiverGameControllerDevice_remove_Changed), METH_O, nullptr },
        { "_assign_array_", _assign_array_MiracastReceiverGameControllerDevice, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MiracastReceiverGameControllerDevice), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MiracastReceiverGameControllerDevice[] = {
        { "transmit_input", reinterpret_cast<getter>(MiracastReceiverGameControllerDevice_get_TransmitInput), reinterpret_cast<setter>(MiracastReceiverGameControllerDevice_put_TransmitInput), nullptr, nullptr },
        { "mode", reinterpret_cast<getter>(MiracastReceiverGameControllerDevice_get_Mode), reinterpret_cast<setter>(MiracastReceiverGameControllerDevice_put_Mode), nullptr, nullptr },
        { "is_requested_by_transmitter", reinterpret_cast<getter>(MiracastReceiverGameControllerDevice_get_IsRequestedByTransmitter), nullptr, nullptr, nullptr },
        { "is_transmitting_input", reinterpret_cast<getter>(MiracastReceiverGameControllerDevice_get_IsTransmittingInput), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MiracastReceiverGameControllerDevice[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MiracastReceiverGameControllerDevice) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MiracastReceiverGameControllerDevice) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MiracastReceiverGameControllerDevice) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MiracastReceiverGameControllerDevice) },
        { },
    };

    static PyType_Spec type_spec_MiracastReceiverGameControllerDevice =
    {
        "winrt._winrt_windows_media_miracast.MiracastReceiverGameControllerDevice",
        sizeof(py::wrapper::Windows::Media::Miracast::MiracastReceiverGameControllerDevice),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MiracastReceiverGameControllerDevice
    };

    // ----- MiracastReceiverInputDevices class --------------------

    static PyObject* _new_MiracastReceiverInputDevices(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Miracast::MiracastReceiverInputDevices>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Miracast::MiracastReceiverInputDevices>::type_name);
        return nullptr;
    }

    static void _dealloc_MiracastReceiverInputDevices(py::wrapper::Windows::Media::Miracast::MiracastReceiverInputDevices* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MiracastReceiverInputDevices_get_GameController(py::wrapper::Windows::Media::Miracast::MiracastReceiverInputDevices* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Miracast.MiracastReceiverInputDevices", L"GameController"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.GameController());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MiracastReceiverInputDevices_get_Keyboard(py::wrapper::Windows::Media::Miracast::MiracastReceiverInputDevices* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Miracast.MiracastReceiverInputDevices", L"Keyboard"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Keyboard());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MiracastReceiverInputDevices(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Miracast::MiracastReceiverInputDevices>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MiracastReceiverInputDevices(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Miracast::MiracastReceiverInputDevices>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MiracastReceiverInputDevices[] = {
        { "_assign_array_", _assign_array_MiracastReceiverInputDevices, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MiracastReceiverInputDevices), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MiracastReceiverInputDevices[] = {
        { "game_controller", reinterpret_cast<getter>(MiracastReceiverInputDevices_get_GameController), nullptr, nullptr, nullptr },
        { "keyboard", reinterpret_cast<getter>(MiracastReceiverInputDevices_get_Keyboard), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MiracastReceiverInputDevices[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MiracastReceiverInputDevices) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MiracastReceiverInputDevices) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MiracastReceiverInputDevices) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MiracastReceiverInputDevices) },
        { },
    };

    static PyType_Spec type_spec_MiracastReceiverInputDevices =
    {
        "winrt._winrt_windows_media_miracast.MiracastReceiverInputDevices",
        sizeof(py::wrapper::Windows::Media::Miracast::MiracastReceiverInputDevices),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MiracastReceiverInputDevices
    };

    // ----- MiracastReceiverKeyboardDevice class --------------------

    static PyObject* _new_MiracastReceiverKeyboardDevice(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Miracast::MiracastReceiverKeyboardDevice>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Miracast::MiracastReceiverKeyboardDevice>::type_name);
        return nullptr;
    }

    static void _dealloc_MiracastReceiverKeyboardDevice(py::wrapper::Windows::Media::Miracast::MiracastReceiverKeyboardDevice* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MiracastReceiverKeyboardDevice_get_TransmitInput(py::wrapper::Windows::Media::Miracast::MiracastReceiverKeyboardDevice* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Miracast.MiracastReceiverKeyboardDevice", L"TransmitInput"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TransmitInput());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MiracastReceiverKeyboardDevice_put_TransmitInput(py::wrapper::Windows::Media::Miracast::MiracastReceiverKeyboardDevice* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Miracast.MiracastReceiverKeyboardDevice", L"TransmitInput"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.TransmitInput(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MiracastReceiverKeyboardDevice_get_IsRequestedByTransmitter(py::wrapper::Windows::Media::Miracast::MiracastReceiverKeyboardDevice* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Miracast.MiracastReceiverKeyboardDevice", L"IsRequestedByTransmitter"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsRequestedByTransmitter());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MiracastReceiverKeyboardDevice_get_IsTransmittingInput(py::wrapper::Windows::Media::Miracast::MiracastReceiverKeyboardDevice* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Miracast.MiracastReceiverKeyboardDevice", L"IsTransmittingInput"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsTransmittingInput());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MiracastReceiverKeyboardDevice_add_Changed(py::wrapper::Windows::Media::Miracast::MiracastReceiverKeyboardDevice* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Miracast.MiracastReceiverKeyboardDevice", L"Changed"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Miracast::MiracastReceiverKeyboardDevice, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.Changed(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MiracastReceiverKeyboardDevice_remove_Changed(py::wrapper::Windows::Media::Miracast::MiracastReceiverKeyboardDevice* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Miracast.MiracastReceiverKeyboardDevice", L"Changed"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Changed(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MiracastReceiverKeyboardDevice(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Miracast::MiracastReceiverKeyboardDevice>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MiracastReceiverKeyboardDevice(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Miracast::MiracastReceiverKeyboardDevice>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MiracastReceiverKeyboardDevice[] = {
        { "add_changed", reinterpret_cast<PyCFunction>(MiracastReceiverKeyboardDevice_add_Changed), METH_O, nullptr },
        { "remove_changed", reinterpret_cast<PyCFunction>(MiracastReceiverKeyboardDevice_remove_Changed), METH_O, nullptr },
        { "_assign_array_", _assign_array_MiracastReceiverKeyboardDevice, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MiracastReceiverKeyboardDevice), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MiracastReceiverKeyboardDevice[] = {
        { "transmit_input", reinterpret_cast<getter>(MiracastReceiverKeyboardDevice_get_TransmitInput), reinterpret_cast<setter>(MiracastReceiverKeyboardDevice_put_TransmitInput), nullptr, nullptr },
        { "is_requested_by_transmitter", reinterpret_cast<getter>(MiracastReceiverKeyboardDevice_get_IsRequestedByTransmitter), nullptr, nullptr, nullptr },
        { "is_transmitting_input", reinterpret_cast<getter>(MiracastReceiverKeyboardDevice_get_IsTransmittingInput), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MiracastReceiverKeyboardDevice[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MiracastReceiverKeyboardDevice) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MiracastReceiverKeyboardDevice) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MiracastReceiverKeyboardDevice) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MiracastReceiverKeyboardDevice) },
        { },
    };

    static PyType_Spec type_spec_MiracastReceiverKeyboardDevice =
    {
        "winrt._winrt_windows_media_miracast.MiracastReceiverKeyboardDevice",
        sizeof(py::wrapper::Windows::Media::Miracast::MiracastReceiverKeyboardDevice),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MiracastReceiverKeyboardDevice
    };

    // ----- MiracastReceiverMediaSourceCreatedEventArgs class --------------------

    static PyObject* _new_MiracastReceiverMediaSourceCreatedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Miracast::MiracastReceiverMediaSourceCreatedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Miracast::MiracastReceiverMediaSourceCreatedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_MiracastReceiverMediaSourceCreatedEventArgs(py::wrapper::Windows::Media::Miracast::MiracastReceiverMediaSourceCreatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MiracastReceiverMediaSourceCreatedEventArgs_GetDeferral(py::wrapper::Windows::Media::Miracast::MiracastReceiverMediaSourceCreatedEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Miracast.MiracastReceiverMediaSourceCreatedEventArgs", L"GetDeferral", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MiracastReceiverMediaSourceCreatedEventArgs_get_Connection(py::wrapper::Windows::Media::Miracast::MiracastReceiverMediaSourceCreatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Miracast.MiracastReceiverMediaSourceCreatedEventArgs", L"Connection"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Connection());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MiracastReceiverMediaSourceCreatedEventArgs_get_CursorImageChannelSettings(py::wrapper::Windows::Media::Miracast::MiracastReceiverMediaSourceCreatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Miracast.MiracastReceiverMediaSourceCreatedEventArgs", L"CursorImageChannelSettings"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CursorImageChannelSettings());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MiracastReceiverMediaSourceCreatedEventArgs_get_MediaSource(py::wrapper::Windows::Media::Miracast::MiracastReceiverMediaSourceCreatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Miracast.MiracastReceiverMediaSourceCreatedEventArgs", L"MediaSource"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MediaSource());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MiracastReceiverMediaSourceCreatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Miracast::MiracastReceiverMediaSourceCreatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MiracastReceiverMediaSourceCreatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Miracast::MiracastReceiverMediaSourceCreatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MiracastReceiverMediaSourceCreatedEventArgs[] = {
        { "get_deferral", reinterpret_cast<PyCFunction>(MiracastReceiverMediaSourceCreatedEventArgs_GetDeferral), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_MiracastReceiverMediaSourceCreatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MiracastReceiverMediaSourceCreatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MiracastReceiverMediaSourceCreatedEventArgs[] = {
        { "connection", reinterpret_cast<getter>(MiracastReceiverMediaSourceCreatedEventArgs_get_Connection), nullptr, nullptr, nullptr },
        { "cursor_image_channel_settings", reinterpret_cast<getter>(MiracastReceiverMediaSourceCreatedEventArgs_get_CursorImageChannelSettings), nullptr, nullptr, nullptr },
        { "media_source", reinterpret_cast<getter>(MiracastReceiverMediaSourceCreatedEventArgs_get_MediaSource), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MiracastReceiverMediaSourceCreatedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MiracastReceiverMediaSourceCreatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MiracastReceiverMediaSourceCreatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MiracastReceiverMediaSourceCreatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MiracastReceiverMediaSourceCreatedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_MiracastReceiverMediaSourceCreatedEventArgs =
    {
        "winrt._winrt_windows_media_miracast.MiracastReceiverMediaSourceCreatedEventArgs",
        sizeof(py::wrapper::Windows::Media::Miracast::MiracastReceiverMediaSourceCreatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MiracastReceiverMediaSourceCreatedEventArgs
    };

    // ----- MiracastReceiverSession class --------------------

    static PyObject* _new_MiracastReceiverSession(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Miracast::MiracastReceiverSession>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Miracast::MiracastReceiverSession>::type_name);
        return nullptr;
    }

    static void _dealloc_MiracastReceiverSession(py::wrapper::Windows::Media::Miracast::MiracastReceiverSession* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MiracastReceiverSession_Close(py::wrapper::Windows::Media::Miracast::MiracastReceiverSession* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Miracast.MiracastReceiverSession", L"Close", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MiracastReceiverSession_Start(py::wrapper::Windows::Media::Miracast::MiracastReceiverSession* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Miracast.MiracastReceiverSession", L"Start", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.Start());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MiracastReceiverSession_StartAsync(py::wrapper::Windows::Media::Miracast::MiracastReceiverSession* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Miracast.MiracastReceiverSession", L"StartAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.StartAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MiracastReceiverSession_get_MaxSimultaneousConnections(py::wrapper::Windows::Media::Miracast::MiracastReceiverSession* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Miracast.MiracastReceiverSession", L"MaxSimultaneousConnections"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MaxSimultaneousConnections());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MiracastReceiverSession_put_MaxSimultaneousConnections(py::wrapper::Windows::Media::Miracast::MiracastReceiverSession* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Miracast.MiracastReceiverSession", L"MaxSimultaneousConnections"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.MaxSimultaneousConnections(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MiracastReceiverSession_get_AllowConnectionTakeover(py::wrapper::Windows::Media::Miracast::MiracastReceiverSession* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Miracast.MiracastReceiverSession", L"AllowConnectionTakeover"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AllowConnectionTakeover());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MiracastReceiverSession_put_AllowConnectionTakeover(py::wrapper::Windows::Media::Miracast::MiracastReceiverSession* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Miracast.MiracastReceiverSession", L"AllowConnectionTakeover"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.AllowConnectionTakeover(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MiracastReceiverSession_add_ConnectionCreated(py::wrapper::Windows::Media::Miracast::MiracastReceiverSession* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Miracast.MiracastReceiverSession", L"ConnectionCreated"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Miracast::MiracastReceiverSession, winrt::Windows::Media::Miracast::MiracastReceiverConnectionCreatedEventArgs>>(arg);

            return py::convert(self->obj.ConnectionCreated(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MiracastReceiverSession_remove_ConnectionCreated(py::wrapper::Windows::Media::Miracast::MiracastReceiverSession* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Miracast.MiracastReceiverSession", L"ConnectionCreated"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ConnectionCreated(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MiracastReceiverSession_add_Disconnected(py::wrapper::Windows::Media::Miracast::MiracastReceiverSession* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Miracast.MiracastReceiverSession", L"Disconnected"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Miracast::MiracastReceiverSession, winrt::Windows::Media::Miracast::MiracastReceiverDisconnectedEventArgs>>(arg);

            return py::convert(self->obj.Disconnected(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MiracastReceiverSession_remove_Disconnected(py::wrapper::Windows::Media::Miracast::MiracastReceiverSession* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Miracast.MiracastReceiverSession", L"Disconnected"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Disconnected(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MiracastReceiverSession_add_MediaSourceCreated(py::wrapper::Windows::Media::Miracast::MiracastReceiverSession* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Miracast.MiracastReceiverSession", L"MediaSourceCreated"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Miracast::MiracastReceiverSession, winrt::Windows::Media::Miracast::MiracastReceiverMediaSourceCreatedEventArgs>>(arg);

            return py::convert(self->obj.MediaSourceCreated(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MiracastReceiverSession_remove_MediaSourceCreated(py::wrapper::Windows::Media::Miracast::MiracastReceiverSession* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Miracast.MiracastReceiverSession", L"MediaSourceCreated"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.MediaSourceCreated(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MiracastReceiverSession(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Miracast::MiracastReceiverSession>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MiracastReceiverSession(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Miracast::MiracastReceiverSession>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_MiracastReceiverSession(py::wrapper::Windows::Media::Miracast::MiracastReceiverSession* self, PyObject* /*unused*/) noexcept
    {
        return Py_NewRef(self);
    }

    static PyObject* _exit_MiracastReceiverSession(py::wrapper::Windows::Media::Miracast::MiracastReceiverSession* self, PyObject* /*unused*/) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MiracastReceiverSession[] = {
        { "close", reinterpret_cast<PyCFunction>(MiracastReceiverSession_Close), METH_VARARGS, nullptr },
        { "start", reinterpret_cast<PyCFunction>(MiracastReceiverSession_Start), METH_VARARGS, nullptr },
        { "start_async", reinterpret_cast<PyCFunction>(MiracastReceiverSession_StartAsync), METH_VARARGS, nullptr },
        { "add_connection_created", reinterpret_cast<PyCFunction>(MiracastReceiverSession_add_ConnectionCreated), METH_O, nullptr },
        { "remove_connection_created", reinterpret_cast<PyCFunction>(MiracastReceiverSession_remove_ConnectionCreated), METH_O, nullptr },
        { "add_disconnected", reinterpret_cast<PyCFunction>(MiracastReceiverSession_add_Disconnected), METH_O, nullptr },
        { "remove_disconnected", reinterpret_cast<PyCFunction>(MiracastReceiverSession_remove_Disconnected), METH_O, nullptr },
        { "add_media_source_created", reinterpret_cast<PyCFunction>(MiracastReceiverSession_add_MediaSourceCreated), METH_O, nullptr },
        { "remove_media_source_created", reinterpret_cast<PyCFunction>(MiracastReceiverSession_remove_MediaSourceCreated), METH_O, nullptr },
        { "_assign_array_", _assign_array_MiracastReceiverSession, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MiracastReceiverSession), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_MiracastReceiverSession), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_MiracastReceiverSession), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_MiracastReceiverSession[] = {
        { "max_simultaneous_connections", reinterpret_cast<getter>(MiracastReceiverSession_get_MaxSimultaneousConnections), reinterpret_cast<setter>(MiracastReceiverSession_put_MaxSimultaneousConnections), nullptr, nullptr },
        { "allow_connection_takeover", reinterpret_cast<getter>(MiracastReceiverSession_get_AllowConnectionTakeover), reinterpret_cast<setter>(MiracastReceiverSession_put_AllowConnectionTakeover), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MiracastReceiverSession[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MiracastReceiverSession) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MiracastReceiverSession) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MiracastReceiverSession) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MiracastReceiverSession) },
        { },
    };

    static PyType_Spec type_spec_MiracastReceiverSession =
    {
        "winrt._winrt_windows_media_miracast.MiracastReceiverSession",
        sizeof(py::wrapper::Windows::Media::Miracast::MiracastReceiverSession),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MiracastReceiverSession
    };

    // ----- MiracastReceiverSessionStartResult class --------------------

    static PyObject* _new_MiracastReceiverSessionStartResult(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Miracast::MiracastReceiverSessionStartResult>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Miracast::MiracastReceiverSessionStartResult>::type_name);
        return nullptr;
    }

    static void _dealloc_MiracastReceiverSessionStartResult(py::wrapper::Windows::Media::Miracast::MiracastReceiverSessionStartResult* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MiracastReceiverSessionStartResult_get_ExtendedError(py::wrapper::Windows::Media::Miracast::MiracastReceiverSessionStartResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Miracast.MiracastReceiverSessionStartResult", L"ExtendedError"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ExtendedError());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MiracastReceiverSessionStartResult_get_Status(py::wrapper::Windows::Media::Miracast::MiracastReceiverSessionStartResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Miracast.MiracastReceiverSessionStartResult", L"Status"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MiracastReceiverSessionStartResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Miracast::MiracastReceiverSessionStartResult>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MiracastReceiverSessionStartResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Miracast::MiracastReceiverSessionStartResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MiracastReceiverSessionStartResult[] = {
        { "_assign_array_", _assign_array_MiracastReceiverSessionStartResult, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MiracastReceiverSessionStartResult), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MiracastReceiverSessionStartResult[] = {
        { "extended_error", reinterpret_cast<getter>(MiracastReceiverSessionStartResult_get_ExtendedError), nullptr, nullptr, nullptr },
        { "status", reinterpret_cast<getter>(MiracastReceiverSessionStartResult_get_Status), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MiracastReceiverSessionStartResult[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MiracastReceiverSessionStartResult) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MiracastReceiverSessionStartResult) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MiracastReceiverSessionStartResult) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MiracastReceiverSessionStartResult) },
        { },
    };

    static PyType_Spec type_spec_MiracastReceiverSessionStartResult =
    {
        "winrt._winrt_windows_media_miracast.MiracastReceiverSessionStartResult",
        sizeof(py::wrapper::Windows::Media::Miracast::MiracastReceiverSessionStartResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MiracastReceiverSessionStartResult
    };

    // ----- MiracastReceiverSettings class --------------------

    static PyObject* _new_MiracastReceiverSettings(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Miracast::MiracastReceiverSettings>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Miracast::MiracastReceiverSettings>::type_name);
        return nullptr;
    }

    static void _dealloc_MiracastReceiverSettings(py::wrapper::Windows::Media::Miracast::MiracastReceiverSettings* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MiracastReceiverSettings_get_RequireAuthorizationFromKnownTransmitters(py::wrapper::Windows::Media::Miracast::MiracastReceiverSettings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Miracast.MiracastReceiverSettings", L"RequireAuthorizationFromKnownTransmitters"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RequireAuthorizationFromKnownTransmitters());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MiracastReceiverSettings_put_RequireAuthorizationFromKnownTransmitters(py::wrapper::Windows::Media::Miracast::MiracastReceiverSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Miracast.MiracastReceiverSettings", L"RequireAuthorizationFromKnownTransmitters"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.RequireAuthorizationFromKnownTransmitters(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MiracastReceiverSettings_get_ModelNumber(py::wrapper::Windows::Media::Miracast::MiracastReceiverSettings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Miracast.MiracastReceiverSettings", L"ModelNumber"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ModelNumber());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MiracastReceiverSettings_put_ModelNumber(py::wrapper::Windows::Media::Miracast::MiracastReceiverSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Miracast.MiracastReceiverSettings", L"ModelNumber"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.ModelNumber(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MiracastReceiverSettings_get_ModelName(py::wrapper::Windows::Media::Miracast::MiracastReceiverSettings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Miracast.MiracastReceiverSettings", L"ModelName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ModelName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MiracastReceiverSettings_put_ModelName(py::wrapper::Windows::Media::Miracast::MiracastReceiverSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Miracast.MiracastReceiverSettings", L"ModelName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.ModelName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MiracastReceiverSettings_get_FriendlyName(py::wrapper::Windows::Media::Miracast::MiracastReceiverSettings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Miracast.MiracastReceiverSettings", L"FriendlyName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.FriendlyName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MiracastReceiverSettings_put_FriendlyName(py::wrapper::Windows::Media::Miracast::MiracastReceiverSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Miracast.MiracastReceiverSettings", L"FriendlyName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.FriendlyName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MiracastReceiverSettings_get_AuthorizationMethod(py::wrapper::Windows::Media::Miracast::MiracastReceiverSettings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Miracast.MiracastReceiverSettings", L"AuthorizationMethod"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AuthorizationMethod());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MiracastReceiverSettings_put_AuthorizationMethod(py::wrapper::Windows::Media::Miracast::MiracastReceiverSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Miracast.MiracastReceiverSettings", L"AuthorizationMethod"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Miracast::MiracastReceiverAuthorizationMethod>(arg);

            self->obj.AuthorizationMethod(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_MiracastReceiverSettings(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Miracast::MiracastReceiverSettings>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MiracastReceiverSettings(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Miracast::MiracastReceiverSettings>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MiracastReceiverSettings[] = {
        { "_assign_array_", _assign_array_MiracastReceiverSettings, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MiracastReceiverSettings), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MiracastReceiverSettings[] = {
        { "require_authorization_from_known_transmitters", reinterpret_cast<getter>(MiracastReceiverSettings_get_RequireAuthorizationFromKnownTransmitters), reinterpret_cast<setter>(MiracastReceiverSettings_put_RequireAuthorizationFromKnownTransmitters), nullptr, nullptr },
        { "model_number", reinterpret_cast<getter>(MiracastReceiverSettings_get_ModelNumber), reinterpret_cast<setter>(MiracastReceiverSettings_put_ModelNumber), nullptr, nullptr },
        { "model_name", reinterpret_cast<getter>(MiracastReceiverSettings_get_ModelName), reinterpret_cast<setter>(MiracastReceiverSettings_put_ModelName), nullptr, nullptr },
        { "friendly_name", reinterpret_cast<getter>(MiracastReceiverSettings_get_FriendlyName), reinterpret_cast<setter>(MiracastReceiverSettings_put_FriendlyName), nullptr, nullptr },
        { "authorization_method", reinterpret_cast<getter>(MiracastReceiverSettings_get_AuthorizationMethod), reinterpret_cast<setter>(MiracastReceiverSettings_put_AuthorizationMethod), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MiracastReceiverSettings[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MiracastReceiverSettings) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MiracastReceiverSettings) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MiracastReceiverSettings) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MiracastReceiverSettings) },
        { },
    };

    static PyType_Spec type_spec_MiracastReceiverSettings =
    {
        "winrt._winrt_windows_media_miracast.MiracastReceiverSettings",
        sizeof(py::wrapper::Windows::Media::Miracast::MiracastReceiverSettings),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MiracastReceiverSettings
    };

    // ----- MiracastReceiverStatus class --------------------

    static PyObject* _new_MiracastReceiverStatus(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Miracast::MiracastReceiverStatus>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Miracast::MiracastReceiverStatus>::type_name);
        return nullptr;
    }

    static void _dealloc_MiracastReceiverStatus(py::wrapper::Windows::Media::Miracast::MiracastReceiverStatus* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MiracastReceiverStatus_get_IsConnectionTakeoverSupported(py::wrapper::Windows::Media::Miracast::MiracastReceiverStatus* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Miracast.MiracastReceiverStatus", L"IsConnectionTakeoverSupported"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsConnectionTakeoverSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MiracastReceiverStatus_get_KnownTransmitters(py::wrapper::Windows::Media::Miracast::MiracastReceiverStatus* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Miracast.MiracastReceiverStatus", L"KnownTransmitters"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.KnownTransmitters());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MiracastReceiverStatus_get_ListeningStatus(py::wrapper::Windows::Media::Miracast::MiracastReceiverStatus* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Miracast.MiracastReceiverStatus", L"ListeningStatus"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ListeningStatus());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MiracastReceiverStatus_get_MaxSimultaneousConnections(py::wrapper::Windows::Media::Miracast::MiracastReceiverStatus* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Miracast.MiracastReceiverStatus", L"MaxSimultaneousConnections"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MaxSimultaneousConnections());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MiracastReceiverStatus_get_WiFiStatus(py::wrapper::Windows::Media::Miracast::MiracastReceiverStatus* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Miracast.MiracastReceiverStatus", L"WiFiStatus"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.WiFiStatus());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MiracastReceiverStatus(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Miracast::MiracastReceiverStatus>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MiracastReceiverStatus(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Miracast::MiracastReceiverStatus>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MiracastReceiverStatus[] = {
        { "_assign_array_", _assign_array_MiracastReceiverStatus, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MiracastReceiverStatus), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MiracastReceiverStatus[] = {
        { "is_connection_takeover_supported", reinterpret_cast<getter>(MiracastReceiverStatus_get_IsConnectionTakeoverSupported), nullptr, nullptr, nullptr },
        { "known_transmitters", reinterpret_cast<getter>(MiracastReceiverStatus_get_KnownTransmitters), nullptr, nullptr, nullptr },
        { "listening_status", reinterpret_cast<getter>(MiracastReceiverStatus_get_ListeningStatus), nullptr, nullptr, nullptr },
        { "max_simultaneous_connections", reinterpret_cast<getter>(MiracastReceiverStatus_get_MaxSimultaneousConnections), nullptr, nullptr, nullptr },
        { "wi_fi_status", reinterpret_cast<getter>(MiracastReceiverStatus_get_WiFiStatus), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MiracastReceiverStatus[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MiracastReceiverStatus) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MiracastReceiverStatus) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MiracastReceiverStatus) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MiracastReceiverStatus) },
        { },
    };

    static PyType_Spec type_spec_MiracastReceiverStatus =
    {
        "winrt._winrt_windows_media_miracast.MiracastReceiverStatus",
        sizeof(py::wrapper::Windows::Media::Miracast::MiracastReceiverStatus),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MiracastReceiverStatus
    };

    // ----- MiracastReceiverStreamControl class --------------------

    static PyObject* _new_MiracastReceiverStreamControl(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Miracast::MiracastReceiverStreamControl>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Miracast::MiracastReceiverStreamControl>::type_name);
        return nullptr;
    }

    static void _dealloc_MiracastReceiverStreamControl(py::wrapper::Windows::Media::Miracast::MiracastReceiverStreamControl* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MiracastReceiverStreamControl_GetVideoStreamSettings(py::wrapper::Windows::Media::Miracast::MiracastReceiverStreamControl* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Miracast.MiracastReceiverStreamControl", L"GetVideoStreamSettings", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetVideoStreamSettings());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MiracastReceiverStreamControl_GetVideoStreamSettingsAsync(py::wrapper::Windows::Media::Miracast::MiracastReceiverStreamControl* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Miracast.MiracastReceiverStreamControl", L"GetVideoStreamSettingsAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetVideoStreamSettingsAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MiracastReceiverStreamControl_SuggestVideoStreamSettings(py::wrapper::Windows::Media::Miracast::MiracastReceiverStreamControl* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Miracast.MiracastReceiverStreamControl", L"SuggestVideoStreamSettings", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Miracast::MiracastReceiverVideoStreamSettings>(args, 0);

                self->obj.SuggestVideoStreamSettings(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MiracastReceiverStreamControl_SuggestVideoStreamSettingsAsync(py::wrapper::Windows::Media::Miracast::MiracastReceiverStreamControl* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Miracast.MiracastReceiverStreamControl", L"SuggestVideoStreamSettingsAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Miracast::MiracastReceiverVideoStreamSettings>(args, 0);

                return py::convert(self->obj.SuggestVideoStreamSettingsAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MiracastReceiverStreamControl_get_MuteAudio(py::wrapper::Windows::Media::Miracast::MiracastReceiverStreamControl* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Miracast.MiracastReceiverStreamControl", L"MuteAudio"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MuteAudio());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MiracastReceiverStreamControl_put_MuteAudio(py::wrapper::Windows::Media::Miracast::MiracastReceiverStreamControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Miracast.MiracastReceiverStreamControl", L"MuteAudio"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.MuteAudio(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_MiracastReceiverStreamControl(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Miracast::MiracastReceiverStreamControl>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MiracastReceiverStreamControl(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Miracast::MiracastReceiverStreamControl>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MiracastReceiverStreamControl[] = {
        { "get_video_stream_settings", reinterpret_cast<PyCFunction>(MiracastReceiverStreamControl_GetVideoStreamSettings), METH_VARARGS, nullptr },
        { "get_video_stream_settings_async", reinterpret_cast<PyCFunction>(MiracastReceiverStreamControl_GetVideoStreamSettingsAsync), METH_VARARGS, nullptr },
        { "suggest_video_stream_settings", reinterpret_cast<PyCFunction>(MiracastReceiverStreamControl_SuggestVideoStreamSettings), METH_VARARGS, nullptr },
        { "suggest_video_stream_settings_async", reinterpret_cast<PyCFunction>(MiracastReceiverStreamControl_SuggestVideoStreamSettingsAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_MiracastReceiverStreamControl, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MiracastReceiverStreamControl), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MiracastReceiverStreamControl[] = {
        { "mute_audio", reinterpret_cast<getter>(MiracastReceiverStreamControl_get_MuteAudio), reinterpret_cast<setter>(MiracastReceiverStreamControl_put_MuteAudio), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MiracastReceiverStreamControl[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MiracastReceiverStreamControl) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MiracastReceiverStreamControl) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MiracastReceiverStreamControl) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MiracastReceiverStreamControl) },
        { },
    };

    static PyType_Spec type_spec_MiracastReceiverStreamControl =
    {
        "winrt._winrt_windows_media_miracast.MiracastReceiverStreamControl",
        sizeof(py::wrapper::Windows::Media::Miracast::MiracastReceiverStreamControl),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MiracastReceiverStreamControl
    };

    // ----- MiracastReceiverVideoStreamSettings class --------------------

    static PyObject* _new_MiracastReceiverVideoStreamSettings(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Miracast::MiracastReceiverVideoStreamSettings>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Miracast::MiracastReceiverVideoStreamSettings>::type_name);
        return nullptr;
    }

    static void _dealloc_MiracastReceiverVideoStreamSettings(py::wrapper::Windows::Media::Miracast::MiracastReceiverVideoStreamSettings* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MiracastReceiverVideoStreamSettings_get_Size(py::wrapper::Windows::Media::Miracast::MiracastReceiverVideoStreamSettings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Miracast.MiracastReceiverVideoStreamSettings", L"Size"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MiracastReceiverVideoStreamSettings_put_Size(py::wrapper::Windows::Media::Miracast::MiracastReceiverVideoStreamSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Miracast.MiracastReceiverVideoStreamSettings", L"Size"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Graphics::SizeInt32>(arg);

            self->obj.Size(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MiracastReceiverVideoStreamSettings_get_Bitrate(py::wrapper::Windows::Media::Miracast::MiracastReceiverVideoStreamSettings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Miracast.MiracastReceiverVideoStreamSettings", L"Bitrate"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Bitrate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MiracastReceiverVideoStreamSettings_put_Bitrate(py::wrapper::Windows::Media::Miracast::MiracastReceiverVideoStreamSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Miracast.MiracastReceiverVideoStreamSettings", L"Bitrate"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.Bitrate(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_MiracastReceiverVideoStreamSettings(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Miracast::MiracastReceiverVideoStreamSettings>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MiracastReceiverVideoStreamSettings(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Miracast::MiracastReceiverVideoStreamSettings>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MiracastReceiverVideoStreamSettings[] = {
        { "_assign_array_", _assign_array_MiracastReceiverVideoStreamSettings, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MiracastReceiverVideoStreamSettings), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MiracastReceiverVideoStreamSettings[] = {
        { "size", reinterpret_cast<getter>(MiracastReceiverVideoStreamSettings_get_Size), reinterpret_cast<setter>(MiracastReceiverVideoStreamSettings_put_Size), nullptr, nullptr },
        { "bitrate", reinterpret_cast<getter>(MiracastReceiverVideoStreamSettings_get_Bitrate), reinterpret_cast<setter>(MiracastReceiverVideoStreamSettings_put_Bitrate), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MiracastReceiverVideoStreamSettings[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MiracastReceiverVideoStreamSettings) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MiracastReceiverVideoStreamSettings) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MiracastReceiverVideoStreamSettings) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MiracastReceiverVideoStreamSettings) },
        { },
    };

    static PyType_Spec type_spec_MiracastReceiverVideoStreamSettings =
    {
        "winrt._winrt_windows_media_miracast.MiracastReceiverVideoStreamSettings",
        sizeof(py::wrapper::Windows::Media::Miracast::MiracastReceiverVideoStreamSettings),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MiracastReceiverVideoStreamSettings
    };

    // ----- MiracastTransmitter class --------------------

    static PyObject* _new_MiracastTransmitter(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Miracast::MiracastTransmitter>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Miracast::MiracastTransmitter>::type_name);
        return nullptr;
    }

    static void _dealloc_MiracastTransmitter(py::wrapper::Windows::Media::Miracast::MiracastTransmitter* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MiracastTransmitter_GetConnections(py::wrapper::Windows::Media::Miracast::MiracastTransmitter* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Miracast.MiracastTransmitter", L"GetConnections", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetConnections());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MiracastTransmitter_get_Name(py::wrapper::Windows::Media::Miracast::MiracastTransmitter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Miracast.MiracastTransmitter", L"Name"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Name());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MiracastTransmitter_put_Name(py::wrapper::Windows::Media::Miracast::MiracastTransmitter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Miracast.MiracastTransmitter", L"Name"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Name(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MiracastTransmitter_get_AuthorizationStatus(py::wrapper::Windows::Media::Miracast::MiracastTransmitter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Miracast.MiracastTransmitter", L"AuthorizationStatus"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AuthorizationStatus());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MiracastTransmitter_put_AuthorizationStatus(py::wrapper::Windows::Media::Miracast::MiracastTransmitter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Miracast.MiracastTransmitter", L"AuthorizationStatus"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Miracast::MiracastTransmitterAuthorizationStatus>(arg);

            self->obj.AuthorizationStatus(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MiracastTransmitter_get_LastConnectionTime(py::wrapper::Windows::Media::Miracast::MiracastTransmitter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Miracast.MiracastTransmitter", L"LastConnectionTime"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.LastConnectionTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MiracastTransmitter_get_MacAddress(py::wrapper::Windows::Media::Miracast::MiracastTransmitter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Miracast.MiracastTransmitter", L"MacAddress"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MacAddress());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MiracastTransmitter(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Miracast::MiracastTransmitter>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MiracastTransmitter(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Miracast::MiracastTransmitter>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MiracastTransmitter[] = {
        { "get_connections", reinterpret_cast<PyCFunction>(MiracastTransmitter_GetConnections), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_MiracastTransmitter, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MiracastTransmitter), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MiracastTransmitter[] = {
        { "name", reinterpret_cast<getter>(MiracastTransmitter_get_Name), reinterpret_cast<setter>(MiracastTransmitter_put_Name), nullptr, nullptr },
        { "authorization_status", reinterpret_cast<getter>(MiracastTransmitter_get_AuthorizationStatus), reinterpret_cast<setter>(MiracastTransmitter_put_AuthorizationStatus), nullptr, nullptr },
        { "last_connection_time", reinterpret_cast<getter>(MiracastTransmitter_get_LastConnectionTime), nullptr, nullptr, nullptr },
        { "mac_address", reinterpret_cast<getter>(MiracastTransmitter_get_MacAddress), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MiracastTransmitter[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MiracastTransmitter) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MiracastTransmitter) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MiracastTransmitter) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MiracastTransmitter) },
        { },
    };

    static PyType_Spec type_spec_MiracastTransmitter =
    {
        "winrt._winrt_windows_media_miracast.MiracastTransmitter",
        sizeof(py::wrapper::Windows::Media::Miracast::MiracastTransmitter),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MiracastTransmitter
    };

    // ----- Windows.Media.Miracast Initialization --------------------
    PyDoc_STRVAR(module_doc, "Windows::Media::Miracast");


    static PyModuleDef module_def
        = {PyModuleDef_HEAD_INIT,
           "_winrt_windows_media_miracast",
           module_doc,
           0,
           nullptr,
           nullptr,
           nullptr,
           nullptr,
           nullptr};

} // py::cpp::Windows::Media::Miracast

PyMODINIT_FUNC PyInit__winrt_windows_media_miracast(void) noexcept
{
    using namespace py::cpp::Windows::Media::Miracast;

    if (py::import_winrt_runtime() == -1)
    {
        return nullptr;
    }

    py::pyobj_handle module{PyModule_Create(&module_def)};

    if (!module)
    {
        return nullptr;
    }

    auto object_type = py::get_object_type();
    if (!object_type)
    {
        return nullptr;
    }

    py::pyobj_handle object_bases{PyTuple_Pack(1, object_type)};

    if (!object_bases)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_MiracastReceiver, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_MiracastReceiverApplySettingsResult, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_MiracastReceiverConnection, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_MiracastReceiverConnectionCreatedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_MiracastReceiverCursorImageChannel, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_MiracastReceiverCursorImageChannelSettings, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_MiracastReceiverDisconnectedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_MiracastReceiverGameControllerDevice, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_MiracastReceiverInputDevices, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_MiracastReceiverKeyboardDevice, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_MiracastReceiverMediaSourceCreatedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_MiracastReceiverSession, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_MiracastReceiverSessionStartResult, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_MiracastReceiverSettings, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_MiracastReceiverStatus, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_MiracastReceiverStreamControl, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_MiracastReceiverVideoStreamSettings, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_MiracastTransmitter, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }


    return module.detach();
}
