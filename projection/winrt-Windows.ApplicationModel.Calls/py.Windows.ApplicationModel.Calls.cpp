// WARNING: Please don't edit this file. It was generated by Python/WinRT v0.0.0

#include "pybase.h"
#include "py.Windows.ApplicationModel.Calls.h"


namespace py::cpp::Windows::ApplicationModel::Calls
{
    // ----- CallAnswerEventArgs class --------------------

    static PyObject* _new_CallAnswerEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Calls::CallAnswerEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Calls::CallAnswerEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_CallAnswerEventArgs(py::wrapper::Windows::ApplicationModel::Calls::CallAnswerEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CallAnswerEventArgs_get_AcceptedMedia(py::wrapper::Windows::ApplicationModel::Calls::CallAnswerEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Calls.CallAnswerEventArgs", L"AcceptedMedia"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AcceptedMedia());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CallAnswerEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Calls::CallAnswerEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CallAnswerEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Calls::CallAnswerEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CallAnswerEventArgs[] = {
        { "_assign_array_", _assign_array_CallAnswerEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CallAnswerEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CallAnswerEventArgs[] = {
        { "accepted_media", reinterpret_cast<getter>(CallAnswerEventArgs_get_AcceptedMedia), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CallAnswerEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_CallAnswerEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CallAnswerEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CallAnswerEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CallAnswerEventArgs) },
        { },
    };

    static PyType_Spec type_spec_CallAnswerEventArgs =
    {
        "_winrt_windows_applicationmodel_calls.CallAnswerEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Calls::CallAnswerEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CallAnswerEventArgs
    };

    // ----- CallRejectEventArgs class --------------------

    static PyObject* _new_CallRejectEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Calls::CallRejectEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Calls::CallRejectEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_CallRejectEventArgs(py::wrapper::Windows::ApplicationModel::Calls::CallRejectEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CallRejectEventArgs_get_RejectReason(py::wrapper::Windows::ApplicationModel::Calls::CallRejectEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Calls.CallRejectEventArgs", L"RejectReason"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RejectReason());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CallRejectEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Calls::CallRejectEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CallRejectEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Calls::CallRejectEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CallRejectEventArgs[] = {
        { "_assign_array_", _assign_array_CallRejectEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CallRejectEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CallRejectEventArgs[] = {
        { "reject_reason", reinterpret_cast<getter>(CallRejectEventArgs_get_RejectReason), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CallRejectEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_CallRejectEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CallRejectEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CallRejectEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CallRejectEventArgs) },
        { },
    };

    static PyType_Spec type_spec_CallRejectEventArgs =
    {
        "_winrt_windows_applicationmodel_calls.CallRejectEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Calls::CallRejectEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CallRejectEventArgs
    };

    // ----- CallStateChangeEventArgs class --------------------

    static PyObject* _new_CallStateChangeEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Calls::CallStateChangeEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Calls::CallStateChangeEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_CallStateChangeEventArgs(py::wrapper::Windows::ApplicationModel::Calls::CallStateChangeEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CallStateChangeEventArgs_get_State(py::wrapper::Windows::ApplicationModel::Calls::CallStateChangeEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Calls.CallStateChangeEventArgs", L"State"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.State());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CallStateChangeEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Calls::CallStateChangeEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CallStateChangeEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Calls::CallStateChangeEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CallStateChangeEventArgs[] = {
        { "_assign_array_", _assign_array_CallStateChangeEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CallStateChangeEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CallStateChangeEventArgs[] = {
        { "state", reinterpret_cast<getter>(CallStateChangeEventArgs_get_State), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CallStateChangeEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_CallStateChangeEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CallStateChangeEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CallStateChangeEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CallStateChangeEventArgs) },
        { },
    };

    static PyType_Spec type_spec_CallStateChangeEventArgs =
    {
        "_winrt_windows_applicationmodel_calls.CallStateChangeEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Calls::CallStateChangeEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CallStateChangeEventArgs
    };

    // ----- LockScreenCallEndCallDeferral class --------------------

    static PyObject* _new_LockScreenCallEndCallDeferral(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Calls::LockScreenCallEndCallDeferral>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Calls::LockScreenCallEndCallDeferral>::type_name);
        return nullptr;
    }

    static void _dealloc_LockScreenCallEndCallDeferral(py::wrapper::Windows::ApplicationModel::Calls::LockScreenCallEndCallDeferral* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* LockScreenCallEndCallDeferral_Complete(py::wrapper::Windows::ApplicationModel::Calls::LockScreenCallEndCallDeferral* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Calls.LockScreenCallEndCallDeferral", L"Complete", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Complete();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_LockScreenCallEndCallDeferral(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Calls::LockScreenCallEndCallDeferral>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_LockScreenCallEndCallDeferral(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Calls::LockScreenCallEndCallDeferral>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_LockScreenCallEndCallDeferral[] = {
        { "complete", reinterpret_cast<PyCFunction>(LockScreenCallEndCallDeferral_Complete), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_LockScreenCallEndCallDeferral, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_LockScreenCallEndCallDeferral), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_LockScreenCallEndCallDeferral[] = {
        { }
    };

    static PyType_Slot _type_slots_LockScreenCallEndCallDeferral[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_LockScreenCallEndCallDeferral) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_LockScreenCallEndCallDeferral) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_LockScreenCallEndCallDeferral) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_LockScreenCallEndCallDeferral) },
        { },
    };

    static PyType_Spec type_spec_LockScreenCallEndCallDeferral =
    {
        "_winrt_windows_applicationmodel_calls.LockScreenCallEndCallDeferral",
        sizeof(py::wrapper::Windows::ApplicationModel::Calls::LockScreenCallEndCallDeferral),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_LockScreenCallEndCallDeferral
    };

    // ----- LockScreenCallEndRequestedEventArgs class --------------------

    static PyObject* _new_LockScreenCallEndRequestedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Calls::LockScreenCallEndRequestedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Calls::LockScreenCallEndRequestedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_LockScreenCallEndRequestedEventArgs(py::wrapper::Windows::ApplicationModel::Calls::LockScreenCallEndRequestedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* LockScreenCallEndRequestedEventArgs_GetDeferral(py::wrapper::Windows::ApplicationModel::Calls::LockScreenCallEndRequestedEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Calls.LockScreenCallEndRequestedEventArgs", L"GetDeferral", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LockScreenCallEndRequestedEventArgs_get_Deadline(py::wrapper::Windows::ApplicationModel::Calls::LockScreenCallEndRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Calls.LockScreenCallEndRequestedEventArgs", L"Deadline"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Deadline());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_LockScreenCallEndRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Calls::LockScreenCallEndRequestedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_LockScreenCallEndRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Calls::LockScreenCallEndRequestedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_LockScreenCallEndRequestedEventArgs[] = {
        { "get_deferral", reinterpret_cast<PyCFunction>(LockScreenCallEndRequestedEventArgs_GetDeferral), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_LockScreenCallEndRequestedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_LockScreenCallEndRequestedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_LockScreenCallEndRequestedEventArgs[] = {
        { "deadline", reinterpret_cast<getter>(LockScreenCallEndRequestedEventArgs_get_Deadline), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_LockScreenCallEndRequestedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_LockScreenCallEndRequestedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_LockScreenCallEndRequestedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_LockScreenCallEndRequestedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_LockScreenCallEndRequestedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_LockScreenCallEndRequestedEventArgs =
    {
        "_winrt_windows_applicationmodel_calls.LockScreenCallEndRequestedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Calls::LockScreenCallEndRequestedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_LockScreenCallEndRequestedEventArgs
    };

    // ----- LockScreenCallUI class --------------------

    static PyObject* _new_LockScreenCallUI(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Calls::LockScreenCallUI>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Calls::LockScreenCallUI>::type_name);
        return nullptr;
    }

    static void _dealloc_LockScreenCallUI(py::wrapper::Windows::ApplicationModel::Calls::LockScreenCallUI* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* LockScreenCallUI_Dismiss(py::wrapper::Windows::ApplicationModel::Calls::LockScreenCallUI* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Calls.LockScreenCallUI", L"Dismiss", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Dismiss();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LockScreenCallUI_get_CallTitle(py::wrapper::Windows::ApplicationModel::Calls::LockScreenCallUI* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Calls.LockScreenCallUI", L"CallTitle"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CallTitle());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LockScreenCallUI_put_CallTitle(py::wrapper::Windows::ApplicationModel::Calls::LockScreenCallUI* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Calls.LockScreenCallUI", L"CallTitle"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.CallTitle(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LockScreenCallUI_add_Closed(py::wrapper::Windows::ApplicationModel::Calls::LockScreenCallUI* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Calls.LockScreenCallUI", L"Closed"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::ApplicationModel::Calls::LockScreenCallUI, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.Closed(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LockScreenCallUI_remove_Closed(py::wrapper::Windows::ApplicationModel::Calls::LockScreenCallUI* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Calls.LockScreenCallUI", L"Closed"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Closed(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LockScreenCallUI_add_EndRequested(py::wrapper::Windows::ApplicationModel::Calls::LockScreenCallUI* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Calls.LockScreenCallUI", L"EndRequested"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::ApplicationModel::Calls::LockScreenCallUI, winrt::Windows::ApplicationModel::Calls::LockScreenCallEndRequestedEventArgs>>(arg);

            return py::convert(self->obj.EndRequested(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LockScreenCallUI_remove_EndRequested(py::wrapper::Windows::ApplicationModel::Calls::LockScreenCallUI* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Calls.LockScreenCallUI", L"EndRequested"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.EndRequested(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_LockScreenCallUI(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Calls::LockScreenCallUI>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_LockScreenCallUI(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Calls::LockScreenCallUI>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_LockScreenCallUI[] = {
        { "dismiss", reinterpret_cast<PyCFunction>(LockScreenCallUI_Dismiss), METH_VARARGS, nullptr },
        { "add_closed", reinterpret_cast<PyCFunction>(LockScreenCallUI_add_Closed), METH_O, nullptr },
        { "remove_closed", reinterpret_cast<PyCFunction>(LockScreenCallUI_remove_Closed), METH_O, nullptr },
        { "add_end_requested", reinterpret_cast<PyCFunction>(LockScreenCallUI_add_EndRequested), METH_O, nullptr },
        { "remove_end_requested", reinterpret_cast<PyCFunction>(LockScreenCallUI_remove_EndRequested), METH_O, nullptr },
        { "_assign_array_", _assign_array_LockScreenCallUI, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_LockScreenCallUI), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_LockScreenCallUI[] = {
        { "call_title", reinterpret_cast<getter>(LockScreenCallUI_get_CallTitle), reinterpret_cast<setter>(LockScreenCallUI_put_CallTitle), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_LockScreenCallUI[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_LockScreenCallUI) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_LockScreenCallUI) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_LockScreenCallUI) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_LockScreenCallUI) },
        { },
    };

    static PyType_Spec type_spec_LockScreenCallUI =
    {
        "_winrt_windows_applicationmodel_calls.LockScreenCallUI",
        sizeof(py::wrapper::Windows::ApplicationModel::Calls::LockScreenCallUI),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_LockScreenCallUI
    };

    // ----- MuteChangeEventArgs class --------------------

    static PyObject* _new_MuteChangeEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Calls::MuteChangeEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Calls::MuteChangeEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_MuteChangeEventArgs(py::wrapper::Windows::ApplicationModel::Calls::MuteChangeEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MuteChangeEventArgs_get_Muted(py::wrapper::Windows::ApplicationModel::Calls::MuteChangeEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Calls.MuteChangeEventArgs", L"Muted"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Muted());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MuteChangeEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Calls::MuteChangeEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MuteChangeEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Calls::MuteChangeEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MuteChangeEventArgs[] = {
        { "_assign_array_", _assign_array_MuteChangeEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MuteChangeEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MuteChangeEventArgs[] = {
        { "muted", reinterpret_cast<getter>(MuteChangeEventArgs_get_Muted), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MuteChangeEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MuteChangeEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MuteChangeEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MuteChangeEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MuteChangeEventArgs) },
        { },
    };

    static PyType_Spec type_spec_MuteChangeEventArgs =
    {
        "_winrt_windows_applicationmodel_calls.MuteChangeEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Calls::MuteChangeEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MuteChangeEventArgs
    };

    // ----- PhoneCall class --------------------

    static PyObject* _new_PhoneCall(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Calls::PhoneCall>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Calls::PhoneCall>::type_name);
        return nullptr;
    }

    static void _dealloc_PhoneCall(py::wrapper::Windows::ApplicationModel::Calls::PhoneCall* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PhoneCall_AcceptIncoming(py::wrapper::Windows::ApplicationModel::Calls::PhoneCall* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Calls.PhoneCall", L"AcceptIncoming", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.AcceptIncoming());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhoneCall_AcceptIncomingAsync(py::wrapper::Windows::ApplicationModel::Calls::PhoneCall* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Calls.PhoneCall", L"AcceptIncomingAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.AcceptIncomingAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhoneCall_ChangeAudioDevice(py::wrapper::Windows::ApplicationModel::Calls::PhoneCall* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Calls.PhoneCall", L"ChangeAudioDevice", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Calls::PhoneCallAudioDevice>(args, 0);

                return py::convert(self->obj.ChangeAudioDevice(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhoneCall_ChangeAudioDeviceAsync(py::wrapper::Windows::ApplicationModel::Calls::PhoneCall* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Calls.PhoneCall", L"ChangeAudioDeviceAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Calls::PhoneCallAudioDevice>(args, 0);

                return py::convert(self->obj.ChangeAudioDeviceAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhoneCall_End(py::wrapper::Windows::ApplicationModel::Calls::PhoneCall* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Calls.PhoneCall", L"End", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.End());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhoneCall_EndAsync(py::wrapper::Windows::ApplicationModel::Calls::PhoneCall* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Calls.PhoneCall", L"EndAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.EndAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhoneCall_GetFromId(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Calls.PhoneCall", L"GetFromId", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::ApplicationModel::Calls::PhoneCall::GetFromId(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhoneCall_GetPhoneCallInfo(py::wrapper::Windows::ApplicationModel::Calls::PhoneCall* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Calls.PhoneCall", L"GetPhoneCallInfo", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetPhoneCallInfo());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhoneCall_GetPhoneCallInfoAsync(py::wrapper::Windows::ApplicationModel::Calls::PhoneCall* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Calls.PhoneCall", L"GetPhoneCallInfoAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetPhoneCallInfoAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhoneCall_Hold(py::wrapper::Windows::ApplicationModel::Calls::PhoneCall* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Calls.PhoneCall", L"Hold", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.Hold());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhoneCall_HoldAsync(py::wrapper::Windows::ApplicationModel::Calls::PhoneCall* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Calls.PhoneCall", L"HoldAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.HoldAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhoneCall_Mute(py::wrapper::Windows::ApplicationModel::Calls::PhoneCall* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Calls.PhoneCall", L"Mute", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.Mute());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhoneCall_MuteAsync(py::wrapper::Windows::ApplicationModel::Calls::PhoneCall* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Calls.PhoneCall", L"MuteAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.MuteAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhoneCall_RejectIncoming(py::wrapper::Windows::ApplicationModel::Calls::PhoneCall* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Calls.PhoneCall", L"RejectIncoming", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.RejectIncoming());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhoneCall_RejectIncomingAsync(py::wrapper::Windows::ApplicationModel::Calls::PhoneCall* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Calls.PhoneCall", L"RejectIncomingAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.RejectIncomingAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhoneCall_ResumeFromHold(py::wrapper::Windows::ApplicationModel::Calls::PhoneCall* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Calls.PhoneCall", L"ResumeFromHold", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.ResumeFromHold());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhoneCall_ResumeFromHoldAsync(py::wrapper::Windows::ApplicationModel::Calls::PhoneCall* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Calls.PhoneCall", L"ResumeFromHoldAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.ResumeFromHoldAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhoneCall_SendDtmfKey(py::wrapper::Windows::ApplicationModel::Calls::PhoneCall* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Calls.PhoneCall", L"SendDtmfKey", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Calls::DtmfKey>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::ApplicationModel::Calls::DtmfToneAudioPlayback>(args, 1);

                return py::convert(self->obj.SendDtmfKey(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhoneCall_SendDtmfKeyAsync(py::wrapper::Windows::ApplicationModel::Calls::PhoneCall* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Calls.PhoneCall", L"SendDtmfKeyAsync", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Calls::DtmfKey>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::ApplicationModel::Calls::DtmfToneAudioPlayback>(args, 1);

                return py::convert(self->obj.SendDtmfKeyAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhoneCall_Unmute(py::wrapper::Windows::ApplicationModel::Calls::PhoneCall* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Calls.PhoneCall", L"Unmute", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.Unmute());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhoneCall_UnmuteAsync(py::wrapper::Windows::ApplicationModel::Calls::PhoneCall* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Calls.PhoneCall", L"UnmuteAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.UnmuteAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhoneCall_get_AudioDevice(py::wrapper::Windows::ApplicationModel::Calls::PhoneCall* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Calls.PhoneCall", L"AudioDevice"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AudioDevice());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneCall_get_CallId(py::wrapper::Windows::ApplicationModel::Calls::PhoneCall* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Calls.PhoneCall", L"CallId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CallId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneCall_get_IsMuted(py::wrapper::Windows::ApplicationModel::Calls::PhoneCall* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Calls.PhoneCall", L"IsMuted"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsMuted());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneCall_get_Status(py::wrapper::Windows::ApplicationModel::Calls::PhoneCall* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Calls.PhoneCall", L"Status"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneCall_add_AudioDeviceChanged(py::wrapper::Windows::ApplicationModel::Calls::PhoneCall* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Calls.PhoneCall", L"AudioDeviceChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::ApplicationModel::Calls::PhoneCall, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.AudioDeviceChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneCall_remove_AudioDeviceChanged(py::wrapper::Windows::ApplicationModel::Calls::PhoneCall* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Calls.PhoneCall", L"AudioDeviceChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.AudioDeviceChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneCall_add_IsMutedChanged(py::wrapper::Windows::ApplicationModel::Calls::PhoneCall* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Calls.PhoneCall", L"IsMutedChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::ApplicationModel::Calls::PhoneCall, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.IsMutedChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneCall_remove_IsMutedChanged(py::wrapper::Windows::ApplicationModel::Calls::PhoneCall* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Calls.PhoneCall", L"IsMutedChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.IsMutedChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneCall_add_StatusChanged(py::wrapper::Windows::ApplicationModel::Calls::PhoneCall* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Calls.PhoneCall", L"StatusChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::ApplicationModel::Calls::PhoneCall, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.StatusChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneCall_remove_StatusChanged(py::wrapper::Windows::ApplicationModel::Calls::PhoneCall* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Calls.PhoneCall", L"StatusChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.StatusChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PhoneCall(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Calls::PhoneCall>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PhoneCall(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Calls::PhoneCall>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PhoneCall[] = {
        { "accept_incoming", reinterpret_cast<PyCFunction>(PhoneCall_AcceptIncoming), METH_VARARGS, nullptr },
        { "accept_incoming_async", reinterpret_cast<PyCFunction>(PhoneCall_AcceptIncomingAsync), METH_VARARGS, nullptr },
        { "change_audio_device", reinterpret_cast<PyCFunction>(PhoneCall_ChangeAudioDevice), METH_VARARGS, nullptr },
        { "change_audio_device_async", reinterpret_cast<PyCFunction>(PhoneCall_ChangeAudioDeviceAsync), METH_VARARGS, nullptr },
        { "end", reinterpret_cast<PyCFunction>(PhoneCall_End), METH_VARARGS, nullptr },
        { "end_async", reinterpret_cast<PyCFunction>(PhoneCall_EndAsync), METH_VARARGS, nullptr },
        { "get_from_id", reinterpret_cast<PyCFunction>(PhoneCall_GetFromId), METH_VARARGS | METH_STATIC, nullptr },
        { "get_phone_call_info", reinterpret_cast<PyCFunction>(PhoneCall_GetPhoneCallInfo), METH_VARARGS, nullptr },
        { "get_phone_call_info_async", reinterpret_cast<PyCFunction>(PhoneCall_GetPhoneCallInfoAsync), METH_VARARGS, nullptr },
        { "hold", reinterpret_cast<PyCFunction>(PhoneCall_Hold), METH_VARARGS, nullptr },
        { "hold_async", reinterpret_cast<PyCFunction>(PhoneCall_HoldAsync), METH_VARARGS, nullptr },
        { "mute", reinterpret_cast<PyCFunction>(PhoneCall_Mute), METH_VARARGS, nullptr },
        { "mute_async", reinterpret_cast<PyCFunction>(PhoneCall_MuteAsync), METH_VARARGS, nullptr },
        { "reject_incoming", reinterpret_cast<PyCFunction>(PhoneCall_RejectIncoming), METH_VARARGS, nullptr },
        { "reject_incoming_async", reinterpret_cast<PyCFunction>(PhoneCall_RejectIncomingAsync), METH_VARARGS, nullptr },
        { "resume_from_hold", reinterpret_cast<PyCFunction>(PhoneCall_ResumeFromHold), METH_VARARGS, nullptr },
        { "resume_from_hold_async", reinterpret_cast<PyCFunction>(PhoneCall_ResumeFromHoldAsync), METH_VARARGS, nullptr },
        { "send_dtmf_key", reinterpret_cast<PyCFunction>(PhoneCall_SendDtmfKey), METH_VARARGS, nullptr },
        { "send_dtmf_key_async", reinterpret_cast<PyCFunction>(PhoneCall_SendDtmfKeyAsync), METH_VARARGS, nullptr },
        { "unmute", reinterpret_cast<PyCFunction>(PhoneCall_Unmute), METH_VARARGS, nullptr },
        { "unmute_async", reinterpret_cast<PyCFunction>(PhoneCall_UnmuteAsync), METH_VARARGS, nullptr },
        { "add_audio_device_changed", reinterpret_cast<PyCFunction>(PhoneCall_add_AudioDeviceChanged), METH_O, nullptr },
        { "remove_audio_device_changed", reinterpret_cast<PyCFunction>(PhoneCall_remove_AudioDeviceChanged), METH_O, nullptr },
        { "add_is_muted_changed", reinterpret_cast<PyCFunction>(PhoneCall_add_IsMutedChanged), METH_O, nullptr },
        { "remove_is_muted_changed", reinterpret_cast<PyCFunction>(PhoneCall_remove_IsMutedChanged), METH_O, nullptr },
        { "add_status_changed", reinterpret_cast<PyCFunction>(PhoneCall_add_StatusChanged), METH_O, nullptr },
        { "remove_status_changed", reinterpret_cast<PyCFunction>(PhoneCall_remove_StatusChanged), METH_O, nullptr },
        { "_assign_array_", _assign_array_PhoneCall, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PhoneCall), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PhoneCall[] = {
        { "audio_device", reinterpret_cast<getter>(PhoneCall_get_AudioDevice), nullptr, nullptr, nullptr },
        { "call_id", reinterpret_cast<getter>(PhoneCall_get_CallId), nullptr, nullptr, nullptr },
        { "is_muted", reinterpret_cast<getter>(PhoneCall_get_IsMuted), nullptr, nullptr, nullptr },
        { "status", reinterpret_cast<getter>(PhoneCall_get_Status), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PhoneCall[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PhoneCall) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PhoneCall) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PhoneCall) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PhoneCall) },
        { },
    };

    static PyType_Spec type_spec_PhoneCall =
    {
        "_winrt_windows_applicationmodel_calls.PhoneCall",
        sizeof(py::wrapper::Windows::ApplicationModel::Calls::PhoneCall),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PhoneCall
    };

    // ----- PhoneCallBlocking class --------------------

    static PyObject* _new_PhoneCallBlocking(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Calls::PhoneCallBlocking>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Calls::PhoneCallBlocking>::type_name);
        return nullptr;
    }

    static PyObject* PhoneCallBlocking_SetCallBlockingListAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Calls.PhoneCallBlocking", L"SetCallBlockingListAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 0);

                return py::convert(winrt::Windows::ApplicationModel::Calls::PhoneCallBlocking::SetCallBlockingListAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhoneCallBlocking_get_BlockUnknownNumbers(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Calls.PhoneCallBlocking", L"BlockUnknownNumbers"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::ApplicationModel::Calls::PhoneCallBlocking::BlockUnknownNumbers());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneCallBlocking_put_BlockUnknownNumbers(PyObject* /*unused*/, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Calls.PhoneCallBlocking", L"BlockUnknownNumbers"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            winrt::Windows::ApplicationModel::Calls::PhoneCallBlocking::BlockUnknownNumbers(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneCallBlocking_get_BlockPrivateNumbers(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Calls.PhoneCallBlocking", L"BlockPrivateNumbers"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::ApplicationModel::Calls::PhoneCallBlocking::BlockPrivateNumbers());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneCallBlocking_put_BlockPrivateNumbers(PyObject* /*unused*/, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Calls.PhoneCallBlocking", L"BlockPrivateNumbers"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            winrt::Windows::ApplicationModel::Calls::PhoneCallBlocking::BlockPrivateNumbers(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PhoneCallBlocking[] = {
        { "set_call_blocking_list_async", reinterpret_cast<PyCFunction>(PhoneCallBlocking_SetCallBlockingListAsync), METH_VARARGS | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PhoneCallBlocking[] = {
        { }
    };

    static PyType_Slot _type_slots_PhoneCallBlocking[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PhoneCallBlocking) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PhoneCallBlocking) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PhoneCallBlocking) },
        { },
    };

    static PyType_Spec type_spec_PhoneCallBlocking =
    {
        "_winrt_windows_applicationmodel_calls.PhoneCallBlocking",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PhoneCallBlocking
    };

    static PyGetSetDef getset_PhoneCallBlocking_Meta[] = {
        { "block_unknown_numbers", reinterpret_cast<getter>(PhoneCallBlocking_get_BlockUnknownNumbers), reinterpret_cast<setter>(PhoneCallBlocking_put_BlockUnknownNumbers), nullptr, nullptr },
        { "block_private_numbers", reinterpret_cast<getter>(PhoneCallBlocking_get_BlockPrivateNumbers), reinterpret_cast<setter>(PhoneCallBlocking_put_BlockPrivateNumbers), nullptr, nullptr },
        { }
    };

    static PyType_Slot type_slots_PhoneCallBlocking_Meta[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_PhoneCallBlocking_Meta) },
        { }
    };

    static PyType_Spec type_spec_PhoneCallBlocking_Meta =
    {
        "_winrt_windows_applicationmodel_calls.PhoneCallBlocking_Meta",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_PhoneCallBlocking_Meta
    };

    // ----- PhoneCallHistoryEntry class --------------------

    static PyObject* _new_PhoneCallHistoryEntry(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::ApplicationModel::Calls::PhoneCallHistoryEntry instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_PhoneCallHistoryEntry(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryEntry* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PhoneCallHistoryEntry_get_Media(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryEntry* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Calls.PhoneCallHistoryEntry", L"Media"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Media());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PhoneCallHistoryEntry_put_Media(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryEntry* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Calls.PhoneCallHistoryEntry", L"Media"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Calls::PhoneCallHistoryEntryMedia>(arg);

            self->obj.Media(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PhoneCallHistoryEntry_get_IsMissed(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryEntry* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Calls.PhoneCallHistoryEntry", L"IsMissed"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsMissed());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PhoneCallHistoryEntry_put_IsMissed(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryEntry* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Calls.PhoneCallHistoryEntry", L"IsMissed"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsMissed(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PhoneCallHistoryEntry_get_IsIncoming(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryEntry* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Calls.PhoneCallHistoryEntry", L"IsIncoming"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsIncoming());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PhoneCallHistoryEntry_put_IsIncoming(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryEntry* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Calls.PhoneCallHistoryEntry", L"IsIncoming"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsIncoming(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PhoneCallHistoryEntry_get_IsCallerIdBlocked(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryEntry* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Calls.PhoneCallHistoryEntry", L"IsCallerIdBlocked"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsCallerIdBlocked());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PhoneCallHistoryEntry_put_IsCallerIdBlocked(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryEntry* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Calls.PhoneCallHistoryEntry", L"IsCallerIdBlocked"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsCallerIdBlocked(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PhoneCallHistoryEntry_get_IsSeen(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryEntry* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Calls.PhoneCallHistoryEntry", L"IsSeen"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsSeen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PhoneCallHistoryEntry_put_IsSeen(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryEntry* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Calls.PhoneCallHistoryEntry", L"IsSeen"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsSeen(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PhoneCallHistoryEntry_get_Duration(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryEntry* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Calls.PhoneCallHistoryEntry", L"Duration"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Duration());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PhoneCallHistoryEntry_put_Duration(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryEntry* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Calls.PhoneCallHistoryEntry", L"Duration"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::TimeSpan>>(arg);

            self->obj.Duration(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PhoneCallHistoryEntry_get_IsEmergency(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryEntry* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Calls.PhoneCallHistoryEntry", L"IsEmergency"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsEmergency());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PhoneCallHistoryEntry_put_IsEmergency(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryEntry* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Calls.PhoneCallHistoryEntry", L"IsEmergency"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsEmergency(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PhoneCallHistoryEntry_get_IsSuppressed(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryEntry* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Calls.PhoneCallHistoryEntry", L"IsSuppressed"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsSuppressed());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PhoneCallHistoryEntry_put_IsSuppressed(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryEntry* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Calls.PhoneCallHistoryEntry", L"IsSuppressed"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsSuppressed(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PhoneCallHistoryEntry_get_StartTime(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryEntry* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Calls.PhoneCallHistoryEntry", L"StartTime"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.StartTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PhoneCallHistoryEntry_put_StartTime(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryEntry* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Calls.PhoneCallHistoryEntry", L"StartTime"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::DateTime>(arg);

            self->obj.StartTime(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PhoneCallHistoryEntry_get_SourceIdKind(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryEntry* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Calls.PhoneCallHistoryEntry", L"SourceIdKind"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SourceIdKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PhoneCallHistoryEntry_put_SourceIdKind(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryEntry* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Calls.PhoneCallHistoryEntry", L"SourceIdKind"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Calls::PhoneCallHistorySourceIdKind>(arg);

            self->obj.SourceIdKind(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PhoneCallHistoryEntry_get_Address(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryEntry* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Calls.PhoneCallHistoryEntry", L"Address"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Address());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PhoneCallHistoryEntry_put_Address(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryEntry* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Calls.PhoneCallHistoryEntry", L"Address"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Calls::PhoneCallHistoryEntryAddress>(arg);

            self->obj.Address(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PhoneCallHistoryEntry_get_SourceId(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryEntry* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Calls.PhoneCallHistoryEntry", L"SourceId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SourceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PhoneCallHistoryEntry_put_SourceId(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryEntry* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Calls.PhoneCallHistoryEntry", L"SourceId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.SourceId(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PhoneCallHistoryEntry_get_RemoteId(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryEntry* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Calls.PhoneCallHistoryEntry", L"RemoteId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RemoteId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PhoneCallHistoryEntry_put_RemoteId(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryEntry* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Calls.PhoneCallHistoryEntry", L"RemoteId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.RemoteId(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PhoneCallHistoryEntry_get_OtherAppReadAccess(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryEntry* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Calls.PhoneCallHistoryEntry", L"OtherAppReadAccess"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.OtherAppReadAccess());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PhoneCallHistoryEntry_put_OtherAppReadAccess(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryEntry* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Calls.PhoneCallHistoryEntry", L"OtherAppReadAccess"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Calls::PhoneCallHistoryEntryOtherAppReadAccess>(arg);

            self->obj.OtherAppReadAccess(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PhoneCallHistoryEntry_get_IsRinging(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryEntry* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Calls.PhoneCallHistoryEntry", L"IsRinging"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsRinging());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PhoneCallHistoryEntry_put_IsRinging(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryEntry* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Calls.PhoneCallHistoryEntry", L"IsRinging"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsRinging(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PhoneCallHistoryEntry_get_IsVoicemail(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryEntry* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Calls.PhoneCallHistoryEntry", L"IsVoicemail"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsVoicemail());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PhoneCallHistoryEntry_put_IsVoicemail(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryEntry* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Calls.PhoneCallHistoryEntry", L"IsVoicemail"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsVoicemail(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PhoneCallHistoryEntry_get_Id(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryEntry* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Calls.PhoneCallHistoryEntry", L"Id"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneCallHistoryEntry_get_SourceDisplayName(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryEntry* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Calls.PhoneCallHistoryEntry", L"SourceDisplayName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SourceDisplayName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PhoneCallHistoryEntry(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Calls::PhoneCallHistoryEntry>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PhoneCallHistoryEntry(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Calls::PhoneCallHistoryEntry>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PhoneCallHistoryEntry[] = {
        { "_assign_array_", _assign_array_PhoneCallHistoryEntry, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PhoneCallHistoryEntry), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PhoneCallHistoryEntry[] = {
        { "media", reinterpret_cast<getter>(PhoneCallHistoryEntry_get_Media), reinterpret_cast<setter>(PhoneCallHistoryEntry_put_Media), nullptr, nullptr },
        { "is_missed", reinterpret_cast<getter>(PhoneCallHistoryEntry_get_IsMissed), reinterpret_cast<setter>(PhoneCallHistoryEntry_put_IsMissed), nullptr, nullptr },
        { "is_incoming", reinterpret_cast<getter>(PhoneCallHistoryEntry_get_IsIncoming), reinterpret_cast<setter>(PhoneCallHistoryEntry_put_IsIncoming), nullptr, nullptr },
        { "is_caller_id_blocked", reinterpret_cast<getter>(PhoneCallHistoryEntry_get_IsCallerIdBlocked), reinterpret_cast<setter>(PhoneCallHistoryEntry_put_IsCallerIdBlocked), nullptr, nullptr },
        { "is_seen", reinterpret_cast<getter>(PhoneCallHistoryEntry_get_IsSeen), reinterpret_cast<setter>(PhoneCallHistoryEntry_put_IsSeen), nullptr, nullptr },
        { "duration", reinterpret_cast<getter>(PhoneCallHistoryEntry_get_Duration), reinterpret_cast<setter>(PhoneCallHistoryEntry_put_Duration), nullptr, nullptr },
        { "is_emergency", reinterpret_cast<getter>(PhoneCallHistoryEntry_get_IsEmergency), reinterpret_cast<setter>(PhoneCallHistoryEntry_put_IsEmergency), nullptr, nullptr },
        { "is_suppressed", reinterpret_cast<getter>(PhoneCallHistoryEntry_get_IsSuppressed), reinterpret_cast<setter>(PhoneCallHistoryEntry_put_IsSuppressed), nullptr, nullptr },
        { "start_time", reinterpret_cast<getter>(PhoneCallHistoryEntry_get_StartTime), reinterpret_cast<setter>(PhoneCallHistoryEntry_put_StartTime), nullptr, nullptr },
        { "source_id_kind", reinterpret_cast<getter>(PhoneCallHistoryEntry_get_SourceIdKind), reinterpret_cast<setter>(PhoneCallHistoryEntry_put_SourceIdKind), nullptr, nullptr },
        { "address", reinterpret_cast<getter>(PhoneCallHistoryEntry_get_Address), reinterpret_cast<setter>(PhoneCallHistoryEntry_put_Address), nullptr, nullptr },
        { "source_id", reinterpret_cast<getter>(PhoneCallHistoryEntry_get_SourceId), reinterpret_cast<setter>(PhoneCallHistoryEntry_put_SourceId), nullptr, nullptr },
        { "remote_id", reinterpret_cast<getter>(PhoneCallHistoryEntry_get_RemoteId), reinterpret_cast<setter>(PhoneCallHistoryEntry_put_RemoteId), nullptr, nullptr },
        { "other_app_read_access", reinterpret_cast<getter>(PhoneCallHistoryEntry_get_OtherAppReadAccess), reinterpret_cast<setter>(PhoneCallHistoryEntry_put_OtherAppReadAccess), nullptr, nullptr },
        { "is_ringing", reinterpret_cast<getter>(PhoneCallHistoryEntry_get_IsRinging), reinterpret_cast<setter>(PhoneCallHistoryEntry_put_IsRinging), nullptr, nullptr },
        { "is_voicemail", reinterpret_cast<getter>(PhoneCallHistoryEntry_get_IsVoicemail), reinterpret_cast<setter>(PhoneCallHistoryEntry_put_IsVoicemail), nullptr, nullptr },
        { "id", reinterpret_cast<getter>(PhoneCallHistoryEntry_get_Id), nullptr, nullptr, nullptr },
        { "source_display_name", reinterpret_cast<getter>(PhoneCallHistoryEntry_get_SourceDisplayName), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PhoneCallHistoryEntry[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PhoneCallHistoryEntry) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PhoneCallHistoryEntry) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PhoneCallHistoryEntry) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PhoneCallHistoryEntry) },
        { },
    };

    static PyType_Spec type_spec_PhoneCallHistoryEntry =
    {
        "_winrt_windows_applicationmodel_calls.PhoneCallHistoryEntry",
        sizeof(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryEntry),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PhoneCallHistoryEntry
    };

    // ----- PhoneCallHistoryEntryAddress class --------------------

    static PyObject* _new_PhoneCallHistoryEntryAddress(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::ApplicationModel::Calls::PhoneCallHistoryEntryRawAddressKind>(args, 1);

                winrt::Windows::ApplicationModel::Calls::PhoneCallHistoryEntryAddress instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 0)
        {
            try
            {
                winrt::Windows::ApplicationModel::Calls::PhoneCallHistoryEntryAddress instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_PhoneCallHistoryEntryAddress(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryEntryAddress* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PhoneCallHistoryEntryAddress_get_RawAddressKind(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryEntryAddress* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Calls.PhoneCallHistoryEntryAddress", L"RawAddressKind"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RawAddressKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PhoneCallHistoryEntryAddress_put_RawAddressKind(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryEntryAddress* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Calls.PhoneCallHistoryEntryAddress", L"RawAddressKind"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Calls::PhoneCallHistoryEntryRawAddressKind>(arg);

            self->obj.RawAddressKind(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PhoneCallHistoryEntryAddress_get_RawAddress(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryEntryAddress* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Calls.PhoneCallHistoryEntryAddress", L"RawAddress"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RawAddress());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PhoneCallHistoryEntryAddress_put_RawAddress(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryEntryAddress* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Calls.PhoneCallHistoryEntryAddress", L"RawAddress"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.RawAddress(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PhoneCallHistoryEntryAddress_get_DisplayName(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryEntryAddress* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Calls.PhoneCallHistoryEntryAddress", L"DisplayName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DisplayName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PhoneCallHistoryEntryAddress_put_DisplayName(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryEntryAddress* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Calls.PhoneCallHistoryEntryAddress", L"DisplayName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.DisplayName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PhoneCallHistoryEntryAddress_get_ContactId(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryEntryAddress* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Calls.PhoneCallHistoryEntryAddress", L"ContactId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ContactId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PhoneCallHistoryEntryAddress_put_ContactId(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryEntryAddress* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Calls.PhoneCallHistoryEntryAddress", L"ContactId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.ContactId(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_PhoneCallHistoryEntryAddress(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Calls::PhoneCallHistoryEntryAddress>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PhoneCallHistoryEntryAddress(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Calls::PhoneCallHistoryEntryAddress>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PhoneCallHistoryEntryAddress[] = {
        { "_assign_array_", _assign_array_PhoneCallHistoryEntryAddress, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PhoneCallHistoryEntryAddress), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PhoneCallHistoryEntryAddress[] = {
        { "raw_address_kind", reinterpret_cast<getter>(PhoneCallHistoryEntryAddress_get_RawAddressKind), reinterpret_cast<setter>(PhoneCallHistoryEntryAddress_put_RawAddressKind), nullptr, nullptr },
        { "raw_address", reinterpret_cast<getter>(PhoneCallHistoryEntryAddress_get_RawAddress), reinterpret_cast<setter>(PhoneCallHistoryEntryAddress_put_RawAddress), nullptr, nullptr },
        { "display_name", reinterpret_cast<getter>(PhoneCallHistoryEntryAddress_get_DisplayName), reinterpret_cast<setter>(PhoneCallHistoryEntryAddress_put_DisplayName), nullptr, nullptr },
        { "contact_id", reinterpret_cast<getter>(PhoneCallHistoryEntryAddress_get_ContactId), reinterpret_cast<setter>(PhoneCallHistoryEntryAddress_put_ContactId), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PhoneCallHistoryEntryAddress[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PhoneCallHistoryEntryAddress) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PhoneCallHistoryEntryAddress) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PhoneCallHistoryEntryAddress) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PhoneCallHistoryEntryAddress) },
        { },
    };

    static PyType_Spec type_spec_PhoneCallHistoryEntryAddress =
    {
        "_winrt_windows_applicationmodel_calls.PhoneCallHistoryEntryAddress",
        sizeof(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryEntryAddress),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PhoneCallHistoryEntryAddress
    };

    // ----- PhoneCallHistoryEntryQueryOptions class --------------------

    static PyObject* _new_PhoneCallHistoryEntryQueryOptions(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::ApplicationModel::Calls::PhoneCallHistoryEntryQueryOptions instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_PhoneCallHistoryEntryQueryOptions(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryEntryQueryOptions* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PhoneCallHistoryEntryQueryOptions_get_DesiredMedia(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryEntryQueryOptions* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Calls.PhoneCallHistoryEntryQueryOptions", L"DesiredMedia"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DesiredMedia());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PhoneCallHistoryEntryQueryOptions_put_DesiredMedia(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryEntryQueryOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Calls.PhoneCallHistoryEntryQueryOptions", L"DesiredMedia"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Calls::PhoneCallHistoryEntryQueryDesiredMedia>(arg);

            self->obj.DesiredMedia(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PhoneCallHistoryEntryQueryOptions_get_SourceIds(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryEntryQueryOptions* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Calls.PhoneCallHistoryEntryQueryOptions", L"SourceIds"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SourceIds());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PhoneCallHistoryEntryQueryOptions(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Calls::PhoneCallHistoryEntryQueryOptions>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PhoneCallHistoryEntryQueryOptions(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Calls::PhoneCallHistoryEntryQueryOptions>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PhoneCallHistoryEntryQueryOptions[] = {
        { "_assign_array_", _assign_array_PhoneCallHistoryEntryQueryOptions, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PhoneCallHistoryEntryQueryOptions), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PhoneCallHistoryEntryQueryOptions[] = {
        { "desired_media", reinterpret_cast<getter>(PhoneCallHistoryEntryQueryOptions_get_DesiredMedia), reinterpret_cast<setter>(PhoneCallHistoryEntryQueryOptions_put_DesiredMedia), nullptr, nullptr },
        { "source_ids", reinterpret_cast<getter>(PhoneCallHistoryEntryQueryOptions_get_SourceIds), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PhoneCallHistoryEntryQueryOptions[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PhoneCallHistoryEntryQueryOptions) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PhoneCallHistoryEntryQueryOptions) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PhoneCallHistoryEntryQueryOptions) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PhoneCallHistoryEntryQueryOptions) },
        { },
    };

    static PyType_Spec type_spec_PhoneCallHistoryEntryQueryOptions =
    {
        "_winrt_windows_applicationmodel_calls.PhoneCallHistoryEntryQueryOptions",
        sizeof(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryEntryQueryOptions),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PhoneCallHistoryEntryQueryOptions
    };

    // ----- PhoneCallHistoryEntryReader class --------------------

    static PyObject* _new_PhoneCallHistoryEntryReader(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Calls::PhoneCallHistoryEntryReader>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Calls::PhoneCallHistoryEntryReader>::type_name);
        return nullptr;
    }

    static void _dealloc_PhoneCallHistoryEntryReader(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryEntryReader* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PhoneCallHistoryEntryReader_ReadBatchAsync(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryEntryReader* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Calls.PhoneCallHistoryEntryReader", L"ReadBatchAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.ReadBatchAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_PhoneCallHistoryEntryReader(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Calls::PhoneCallHistoryEntryReader>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PhoneCallHistoryEntryReader(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Calls::PhoneCallHistoryEntryReader>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PhoneCallHistoryEntryReader[] = {
        { "read_batch_async", reinterpret_cast<PyCFunction>(PhoneCallHistoryEntryReader_ReadBatchAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_PhoneCallHistoryEntryReader, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PhoneCallHistoryEntryReader), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PhoneCallHistoryEntryReader[] = {
        { }
    };

    static PyType_Slot _type_slots_PhoneCallHistoryEntryReader[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PhoneCallHistoryEntryReader) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PhoneCallHistoryEntryReader) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PhoneCallHistoryEntryReader) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PhoneCallHistoryEntryReader) },
        { },
    };

    static PyType_Spec type_spec_PhoneCallHistoryEntryReader =
    {
        "_winrt_windows_applicationmodel_calls.PhoneCallHistoryEntryReader",
        sizeof(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryEntryReader),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PhoneCallHistoryEntryReader
    };

    // ----- PhoneCallHistoryManager class --------------------

    static PyObject* _new_PhoneCallHistoryManager(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Calls::PhoneCallHistoryManager>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Calls::PhoneCallHistoryManager>::type_name);
        return nullptr;
    }

    static PyObject* PhoneCallHistoryManager_GetForUser(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Calls.PhoneCallHistoryManager", L"GetForUser", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::System::User>(args, 0);

                return py::convert(winrt::Windows::ApplicationModel::Calls::PhoneCallHistoryManager::GetForUser(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhoneCallHistoryManager_RequestStoreAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Calls.PhoneCallHistoryManager", L"RequestStoreAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Calls::PhoneCallHistoryStoreAccessType>(args, 0);

                return py::convert(winrt::Windows::ApplicationModel::Calls::PhoneCallHistoryManager::RequestStoreAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyMethodDef _methods_PhoneCallHistoryManager[] = {
        { "get_for_user", reinterpret_cast<PyCFunction>(PhoneCallHistoryManager_GetForUser), METH_VARARGS | METH_STATIC, nullptr },
        { "request_store_async", reinterpret_cast<PyCFunction>(PhoneCallHistoryManager_RequestStoreAsync), METH_VARARGS | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PhoneCallHistoryManager[] = {
        { }
    };

    static PyType_Slot _type_slots_PhoneCallHistoryManager[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PhoneCallHistoryManager) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PhoneCallHistoryManager) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PhoneCallHistoryManager) },
        { },
    };

    static PyType_Spec type_spec_PhoneCallHistoryManager =
    {
        "_winrt_windows_applicationmodel_calls.PhoneCallHistoryManager",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PhoneCallHistoryManager
    };

    // ----- PhoneCallHistoryManagerForUser class --------------------

    static PyObject* _new_PhoneCallHistoryManagerForUser(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Calls::PhoneCallHistoryManagerForUser>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Calls::PhoneCallHistoryManagerForUser>::type_name);
        return nullptr;
    }

    static void _dealloc_PhoneCallHistoryManagerForUser(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryManagerForUser* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PhoneCallHistoryManagerForUser_RequestStoreAsync(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryManagerForUser* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Calls.PhoneCallHistoryManagerForUser", L"RequestStoreAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Calls::PhoneCallHistoryStoreAccessType>(args, 0);

                return py::convert(self->obj.RequestStoreAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhoneCallHistoryManagerForUser_get_User(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryManagerForUser* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Calls.PhoneCallHistoryManagerForUser", L"User"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.User());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PhoneCallHistoryManagerForUser(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Calls::PhoneCallHistoryManagerForUser>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PhoneCallHistoryManagerForUser(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Calls::PhoneCallHistoryManagerForUser>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PhoneCallHistoryManagerForUser[] = {
        { "request_store_async", reinterpret_cast<PyCFunction>(PhoneCallHistoryManagerForUser_RequestStoreAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_PhoneCallHistoryManagerForUser, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PhoneCallHistoryManagerForUser), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PhoneCallHistoryManagerForUser[] = {
        { "user", reinterpret_cast<getter>(PhoneCallHistoryManagerForUser_get_User), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PhoneCallHistoryManagerForUser[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PhoneCallHistoryManagerForUser) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PhoneCallHistoryManagerForUser) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PhoneCallHistoryManagerForUser) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PhoneCallHistoryManagerForUser) },
        { },
    };

    static PyType_Spec type_spec_PhoneCallHistoryManagerForUser =
    {
        "_winrt_windows_applicationmodel_calls.PhoneCallHistoryManagerForUser",
        sizeof(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryManagerForUser),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PhoneCallHistoryManagerForUser
    };

    // ----- PhoneCallHistoryStore class --------------------

    static PyObject* _new_PhoneCallHistoryStore(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Calls::PhoneCallHistoryStore>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Calls::PhoneCallHistoryStore>::type_name);
        return nullptr;
    }

    static void _dealloc_PhoneCallHistoryStore(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryStore* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PhoneCallHistoryStore_DeleteEntriesAsync(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryStore* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Calls.PhoneCallHistoryStore", L"DeleteEntriesAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::ApplicationModel::Calls::PhoneCallHistoryEntry>>(args, 0);

                return py::convert(self->obj.DeleteEntriesAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhoneCallHistoryStore_DeleteEntryAsync(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryStore* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Calls.PhoneCallHistoryStore", L"DeleteEntryAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Calls::PhoneCallHistoryEntry>(args, 0);

                return py::convert(self->obj.DeleteEntryAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhoneCallHistoryStore_GetEntryAsync(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryStore* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Calls.PhoneCallHistoryStore", L"GetEntryAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.GetEntryAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhoneCallHistoryStore_GetEntryReader(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryStore* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Calls.PhoneCallHistoryStore", L"GetEntryReader", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetEntryReader());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Calls.PhoneCallHistoryStore", L"GetEntryReader", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Calls::PhoneCallHistoryEntryQueryOptions>(args, 0);

                return py::convert(self->obj.GetEntryReader(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhoneCallHistoryStore_GetSourcesUnseenCountAsync(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryStore* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Calls.PhoneCallHistoryStore", L"GetSourcesUnseenCountAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 0);

                return py::convert(self->obj.GetSourcesUnseenCountAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhoneCallHistoryStore_GetUnseenCountAsync(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryStore* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Calls.PhoneCallHistoryStore", L"GetUnseenCountAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetUnseenCountAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhoneCallHistoryStore_MarkAllAsSeenAsync(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryStore* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Calls.PhoneCallHistoryStore", L"MarkAllAsSeenAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.MarkAllAsSeenAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhoneCallHistoryStore_MarkEntriesAsSeenAsync(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryStore* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Calls.PhoneCallHistoryStore", L"MarkEntriesAsSeenAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::ApplicationModel::Calls::PhoneCallHistoryEntry>>(args, 0);

                return py::convert(self->obj.MarkEntriesAsSeenAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhoneCallHistoryStore_MarkEntryAsSeenAsync(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryStore* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Calls.PhoneCallHistoryStore", L"MarkEntryAsSeenAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Calls::PhoneCallHistoryEntry>(args, 0);

                return py::convert(self->obj.MarkEntryAsSeenAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhoneCallHistoryStore_MarkSourcesAsSeenAsync(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryStore* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Calls.PhoneCallHistoryStore", L"MarkSourcesAsSeenAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 0);

                return py::convert(self->obj.MarkSourcesAsSeenAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhoneCallHistoryStore_SaveEntryAsync(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryStore* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Calls.PhoneCallHistoryStore", L"SaveEntryAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Calls::PhoneCallHistoryEntry>(args, 0);

                return py::convert(self->obj.SaveEntryAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_PhoneCallHistoryStore(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Calls::PhoneCallHistoryStore>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PhoneCallHistoryStore(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Calls::PhoneCallHistoryStore>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PhoneCallHistoryStore[] = {
        { "delete_entries_async", reinterpret_cast<PyCFunction>(PhoneCallHistoryStore_DeleteEntriesAsync), METH_VARARGS, nullptr },
        { "delete_entry_async", reinterpret_cast<PyCFunction>(PhoneCallHistoryStore_DeleteEntryAsync), METH_VARARGS, nullptr },
        { "get_entry_async", reinterpret_cast<PyCFunction>(PhoneCallHistoryStore_GetEntryAsync), METH_VARARGS, nullptr },
        { "get_entry_reader", reinterpret_cast<PyCFunction>(PhoneCallHistoryStore_GetEntryReader), METH_VARARGS, nullptr },
        { "get_sources_unseen_count_async", reinterpret_cast<PyCFunction>(PhoneCallHistoryStore_GetSourcesUnseenCountAsync), METH_VARARGS, nullptr },
        { "get_unseen_count_async", reinterpret_cast<PyCFunction>(PhoneCallHistoryStore_GetUnseenCountAsync), METH_VARARGS, nullptr },
        { "mark_all_as_seen_async", reinterpret_cast<PyCFunction>(PhoneCallHistoryStore_MarkAllAsSeenAsync), METH_VARARGS, nullptr },
        { "mark_entries_as_seen_async", reinterpret_cast<PyCFunction>(PhoneCallHistoryStore_MarkEntriesAsSeenAsync), METH_VARARGS, nullptr },
        { "mark_entry_as_seen_async", reinterpret_cast<PyCFunction>(PhoneCallHistoryStore_MarkEntryAsSeenAsync), METH_VARARGS, nullptr },
        { "mark_sources_as_seen_async", reinterpret_cast<PyCFunction>(PhoneCallHistoryStore_MarkSourcesAsSeenAsync), METH_VARARGS, nullptr },
        { "save_entry_async", reinterpret_cast<PyCFunction>(PhoneCallHistoryStore_SaveEntryAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_PhoneCallHistoryStore, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PhoneCallHistoryStore), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PhoneCallHistoryStore[] = {
        { }
    };

    static PyType_Slot _type_slots_PhoneCallHistoryStore[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PhoneCallHistoryStore) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PhoneCallHistoryStore) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PhoneCallHistoryStore) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PhoneCallHistoryStore) },
        { },
    };

    static PyType_Spec type_spec_PhoneCallHistoryStore =
    {
        "_winrt_windows_applicationmodel_calls.PhoneCallHistoryStore",
        sizeof(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryStore),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PhoneCallHistoryStore
    };

    // ----- PhoneCallInfo class --------------------

    static PyObject* _new_PhoneCallInfo(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Calls::PhoneCallInfo>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Calls::PhoneCallInfo>::type_name);
        return nullptr;
    }

    static void _dealloc_PhoneCallInfo(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallInfo* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PhoneCallInfo_get_CallDirection(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Calls.PhoneCallInfo", L"CallDirection"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CallDirection());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneCallInfo_get_DisplayName(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Calls.PhoneCallInfo", L"DisplayName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DisplayName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneCallInfo_get_IsHoldSupported(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Calls.PhoneCallInfo", L"IsHoldSupported"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsHoldSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneCallInfo_get_LineId(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Calls.PhoneCallInfo", L"LineId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.LineId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneCallInfo_get_PhoneNumber(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Calls.PhoneCallInfo", L"PhoneNumber"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PhoneNumber());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneCallInfo_get_StartTime(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Calls.PhoneCallInfo", L"StartTime"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.StartTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PhoneCallInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Calls::PhoneCallInfo>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PhoneCallInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Calls::PhoneCallInfo>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PhoneCallInfo[] = {
        { "_assign_array_", _assign_array_PhoneCallInfo, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PhoneCallInfo), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PhoneCallInfo[] = {
        { "call_direction", reinterpret_cast<getter>(PhoneCallInfo_get_CallDirection), nullptr, nullptr, nullptr },
        { "display_name", reinterpret_cast<getter>(PhoneCallInfo_get_DisplayName), nullptr, nullptr, nullptr },
        { "is_hold_supported", reinterpret_cast<getter>(PhoneCallInfo_get_IsHoldSupported), nullptr, nullptr, nullptr },
        { "line_id", reinterpret_cast<getter>(PhoneCallInfo_get_LineId), nullptr, nullptr, nullptr },
        { "phone_number", reinterpret_cast<getter>(PhoneCallInfo_get_PhoneNumber), nullptr, nullptr, nullptr },
        { "start_time", reinterpret_cast<getter>(PhoneCallInfo_get_StartTime), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PhoneCallInfo[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PhoneCallInfo) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PhoneCallInfo) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PhoneCallInfo) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PhoneCallInfo) },
        { },
    };

    static PyType_Spec type_spec_PhoneCallInfo =
    {
        "_winrt_windows_applicationmodel_calls.PhoneCallInfo",
        sizeof(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallInfo),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PhoneCallInfo
    };

    // ----- PhoneCallManager class --------------------

    static PyObject* _new_PhoneCallManager(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Calls::PhoneCallManager>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Calls::PhoneCallManager>::type_name);
        return nullptr;
    }

    static PyObject* PhoneCallManager_RequestStoreAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Calls.PhoneCallManager", L"RequestStoreAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::ApplicationModel::Calls::PhoneCallManager::RequestStoreAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhoneCallManager_ShowPhoneCallSettingsUI(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Calls.PhoneCallManager", L"ShowPhoneCallSettingsUI", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                winrt::Windows::ApplicationModel::Calls::PhoneCallManager::ShowPhoneCallSettingsUI();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhoneCallManager_ShowPhoneCallUI(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Calls.PhoneCallManager", L"ShowPhoneCallUI", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                winrt::Windows::ApplicationModel::Calls::PhoneCallManager::ShowPhoneCallUI(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhoneCallManager_get_IsCallActive(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Calls.PhoneCallManager", L"IsCallActive"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::ApplicationModel::Calls::PhoneCallManager::IsCallActive());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneCallManager_get_IsCallIncoming(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Calls.PhoneCallManager", L"IsCallIncoming"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::ApplicationModel::Calls::PhoneCallManager::IsCallIncoming());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneCallManager_add_CallStateChanged(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Calls.PhoneCallManager", L"CallStateChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::EventHandler<winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(winrt::Windows::ApplicationModel::Calls::PhoneCallManager::CallStateChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneCallManager_remove_CallStateChanged(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Calls.PhoneCallManager", L"CallStateChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            winrt::Windows::ApplicationModel::Calls::PhoneCallManager::CallStateChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PhoneCallManager[] = {
        { "request_store_async", reinterpret_cast<PyCFunction>(PhoneCallManager_RequestStoreAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "show_phone_call_settings_u_i", reinterpret_cast<PyCFunction>(PhoneCallManager_ShowPhoneCallSettingsUI), METH_VARARGS | METH_STATIC, nullptr },
        { "show_phone_call_u_i", reinterpret_cast<PyCFunction>(PhoneCallManager_ShowPhoneCallUI), METH_VARARGS | METH_STATIC, nullptr },
        { "add_call_state_changed", reinterpret_cast<PyCFunction>(PhoneCallManager_add_CallStateChanged), METH_O | METH_STATIC, nullptr },
        { "remove_call_state_changed", reinterpret_cast<PyCFunction>(PhoneCallManager_remove_CallStateChanged), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PhoneCallManager[] = {
        { }
    };

    static PyType_Slot _type_slots_PhoneCallManager[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PhoneCallManager) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PhoneCallManager) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PhoneCallManager) },
        { },
    };

    static PyType_Spec type_spec_PhoneCallManager =
    {
        "_winrt_windows_applicationmodel_calls.PhoneCallManager",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PhoneCallManager
    };

    static PyGetSetDef getset_PhoneCallManager_Meta[] = {
        { "is_call_active", reinterpret_cast<getter>(PhoneCallManager_get_IsCallActive), nullptr, nullptr, nullptr },
        { "is_call_incoming", reinterpret_cast<getter>(PhoneCallManager_get_IsCallIncoming), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot type_slots_PhoneCallManager_Meta[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_PhoneCallManager_Meta) },
        { }
    };

    static PyType_Spec type_spec_PhoneCallManager_Meta =
    {
        "_winrt_windows_applicationmodel_calls.PhoneCallManager_Meta",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_PhoneCallManager_Meta
    };

    // ----- PhoneCallStore class --------------------

    static PyObject* _new_PhoneCallStore(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Calls::PhoneCallStore>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Calls::PhoneCallStore>::type_name);
        return nullptr;
    }

    static void _dealloc_PhoneCallStore(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallStore* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PhoneCallStore_GetDefaultLineAsync(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallStore* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Calls.PhoneCallStore", L"GetDefaultLineAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetDefaultLineAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhoneCallStore_IsEmergencyPhoneNumberAsync(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallStore* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Calls.PhoneCallStore", L"IsEmergencyPhoneNumberAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.IsEmergencyPhoneNumberAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhoneCallStore_RequestLineWatcher(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallStore* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Calls.PhoneCallStore", L"RequestLineWatcher", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.RequestLineWatcher());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_PhoneCallStore(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Calls::PhoneCallStore>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PhoneCallStore(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Calls::PhoneCallStore>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PhoneCallStore[] = {
        { "get_default_line_async", reinterpret_cast<PyCFunction>(PhoneCallStore_GetDefaultLineAsync), METH_VARARGS, nullptr },
        { "is_emergency_phone_number_async", reinterpret_cast<PyCFunction>(PhoneCallStore_IsEmergencyPhoneNumberAsync), METH_VARARGS, nullptr },
        { "request_line_watcher", reinterpret_cast<PyCFunction>(PhoneCallStore_RequestLineWatcher), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_PhoneCallStore, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PhoneCallStore), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PhoneCallStore[] = {
        { }
    };

    static PyType_Slot _type_slots_PhoneCallStore[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PhoneCallStore) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PhoneCallStore) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PhoneCallStore) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PhoneCallStore) },
        { },
    };

    static PyType_Spec type_spec_PhoneCallStore =
    {
        "_winrt_windows_applicationmodel_calls.PhoneCallStore",
        sizeof(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallStore),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PhoneCallStore
    };

    // ----- PhoneCallVideoCapabilities class --------------------

    static PyObject* _new_PhoneCallVideoCapabilities(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Calls::PhoneCallVideoCapabilities>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Calls::PhoneCallVideoCapabilities>::type_name);
        return nullptr;
    }

    static void _dealloc_PhoneCallVideoCapabilities(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallVideoCapabilities* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PhoneCallVideoCapabilities_get_IsVideoCallingCapable(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallVideoCapabilities* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Calls.PhoneCallVideoCapabilities", L"IsVideoCallingCapable"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsVideoCallingCapable());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PhoneCallVideoCapabilities(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Calls::PhoneCallVideoCapabilities>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PhoneCallVideoCapabilities(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Calls::PhoneCallVideoCapabilities>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PhoneCallVideoCapabilities[] = {
        { "_assign_array_", _assign_array_PhoneCallVideoCapabilities, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PhoneCallVideoCapabilities), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PhoneCallVideoCapabilities[] = {
        { "is_video_calling_capable", reinterpret_cast<getter>(PhoneCallVideoCapabilities_get_IsVideoCallingCapable), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PhoneCallVideoCapabilities[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PhoneCallVideoCapabilities) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PhoneCallVideoCapabilities) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PhoneCallVideoCapabilities) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PhoneCallVideoCapabilities) },
        { },
    };

    static PyType_Spec type_spec_PhoneCallVideoCapabilities =
    {
        "_winrt_windows_applicationmodel_calls.PhoneCallVideoCapabilities",
        sizeof(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallVideoCapabilities),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PhoneCallVideoCapabilities
    };

    // ----- PhoneCallVideoCapabilitiesManager class --------------------

    static PyObject* _new_PhoneCallVideoCapabilitiesManager(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Calls::PhoneCallVideoCapabilitiesManager>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Calls::PhoneCallVideoCapabilitiesManager>::type_name);
        return nullptr;
    }

    static PyObject* PhoneCallVideoCapabilitiesManager_GetCapabilitiesAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Calls.PhoneCallVideoCapabilitiesManager", L"GetCapabilitiesAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::ApplicationModel::Calls::PhoneCallVideoCapabilitiesManager::GetCapabilitiesAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyMethodDef _methods_PhoneCallVideoCapabilitiesManager[] = {
        { "get_capabilities_async", reinterpret_cast<PyCFunction>(PhoneCallVideoCapabilitiesManager_GetCapabilitiesAsync), METH_VARARGS | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PhoneCallVideoCapabilitiesManager[] = {
        { }
    };

    static PyType_Slot _type_slots_PhoneCallVideoCapabilitiesManager[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PhoneCallVideoCapabilitiesManager) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PhoneCallVideoCapabilitiesManager) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PhoneCallVideoCapabilitiesManager) },
        { },
    };

    static PyType_Spec type_spec_PhoneCallVideoCapabilitiesManager =
    {
        "_winrt_windows_applicationmodel_calls.PhoneCallVideoCapabilitiesManager",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PhoneCallVideoCapabilitiesManager
    };

    // ----- PhoneCallsResult class --------------------

    static PyObject* _new_PhoneCallsResult(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Calls::PhoneCallsResult>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Calls::PhoneCallsResult>::type_name);
        return nullptr;
    }

    static void _dealloc_PhoneCallsResult(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallsResult* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PhoneCallsResult_get_AllActivePhoneCalls(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallsResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Calls.PhoneCallsResult", L"AllActivePhoneCalls"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AllActivePhoneCalls());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneCallsResult_get_OperationStatus(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallsResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Calls.PhoneCallsResult", L"OperationStatus"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.OperationStatus());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PhoneCallsResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Calls::PhoneCallsResult>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PhoneCallsResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Calls::PhoneCallsResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PhoneCallsResult[] = {
        { "_assign_array_", _assign_array_PhoneCallsResult, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PhoneCallsResult), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PhoneCallsResult[] = {
        { "all_active_phone_calls", reinterpret_cast<getter>(PhoneCallsResult_get_AllActivePhoneCalls), nullptr, nullptr, nullptr },
        { "operation_status", reinterpret_cast<getter>(PhoneCallsResult_get_OperationStatus), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PhoneCallsResult[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PhoneCallsResult) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PhoneCallsResult) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PhoneCallsResult) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PhoneCallsResult) },
        { },
    };

    static PyType_Spec type_spec_PhoneCallsResult =
    {
        "_winrt_windows_applicationmodel_calls.PhoneCallsResult",
        sizeof(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallsResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PhoneCallsResult
    };

    // ----- PhoneDialOptions class --------------------

    static PyObject* _new_PhoneDialOptions(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::ApplicationModel::Calls::PhoneDialOptions instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_PhoneDialOptions(py::wrapper::Windows::ApplicationModel::Calls::PhoneDialOptions* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PhoneDialOptions_get_Number(py::wrapper::Windows::ApplicationModel::Calls::PhoneDialOptions* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Calls.PhoneDialOptions", L"Number"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Number());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PhoneDialOptions_put_Number(py::wrapper::Windows::ApplicationModel::Calls::PhoneDialOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Calls.PhoneDialOptions", L"Number"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Number(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PhoneDialOptions_get_Media(py::wrapper::Windows::ApplicationModel::Calls::PhoneDialOptions* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Calls.PhoneDialOptions", L"Media"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Media());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PhoneDialOptions_put_Media(py::wrapper::Windows::ApplicationModel::Calls::PhoneDialOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Calls.PhoneDialOptions", L"Media"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Calls::PhoneCallMedia>(arg);

            self->obj.Media(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PhoneDialOptions_get_DisplayName(py::wrapper::Windows::ApplicationModel::Calls::PhoneDialOptions* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Calls.PhoneDialOptions", L"DisplayName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DisplayName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PhoneDialOptions_put_DisplayName(py::wrapper::Windows::ApplicationModel::Calls::PhoneDialOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Calls.PhoneDialOptions", L"DisplayName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.DisplayName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PhoneDialOptions_get_ContactPhone(py::wrapper::Windows::ApplicationModel::Calls::PhoneDialOptions* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Calls.PhoneDialOptions", L"ContactPhone"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ContactPhone());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PhoneDialOptions_put_ContactPhone(py::wrapper::Windows::ApplicationModel::Calls::PhoneDialOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Calls.PhoneDialOptions", L"ContactPhone"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::ContactPhone>(arg);

            self->obj.ContactPhone(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PhoneDialOptions_get_Contact(py::wrapper::Windows::ApplicationModel::Calls::PhoneDialOptions* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Calls.PhoneDialOptions", L"Contact"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Contact());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PhoneDialOptions_put_Contact(py::wrapper::Windows::ApplicationModel::Calls::PhoneDialOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Calls.PhoneDialOptions", L"Contact"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::Contact>(arg);

            self->obj.Contact(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PhoneDialOptions_get_AudioEndpoint(py::wrapper::Windows::ApplicationModel::Calls::PhoneDialOptions* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Calls.PhoneDialOptions", L"AudioEndpoint"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AudioEndpoint());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PhoneDialOptions_put_AudioEndpoint(py::wrapper::Windows::ApplicationModel::Calls::PhoneDialOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Calls.PhoneDialOptions", L"AudioEndpoint"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Calls::PhoneAudioRoutingEndpoint>(arg);

            self->obj.AudioEndpoint(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_PhoneDialOptions(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Calls::PhoneDialOptions>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PhoneDialOptions(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Calls::PhoneDialOptions>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PhoneDialOptions[] = {
        { "_assign_array_", _assign_array_PhoneDialOptions, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PhoneDialOptions), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PhoneDialOptions[] = {
        { "number", reinterpret_cast<getter>(PhoneDialOptions_get_Number), reinterpret_cast<setter>(PhoneDialOptions_put_Number), nullptr, nullptr },
        { "media", reinterpret_cast<getter>(PhoneDialOptions_get_Media), reinterpret_cast<setter>(PhoneDialOptions_put_Media), nullptr, nullptr },
        { "display_name", reinterpret_cast<getter>(PhoneDialOptions_get_DisplayName), reinterpret_cast<setter>(PhoneDialOptions_put_DisplayName), nullptr, nullptr },
        { "contact_phone", reinterpret_cast<getter>(PhoneDialOptions_get_ContactPhone), reinterpret_cast<setter>(PhoneDialOptions_put_ContactPhone), nullptr, nullptr },
        { "contact", reinterpret_cast<getter>(PhoneDialOptions_get_Contact), reinterpret_cast<setter>(PhoneDialOptions_put_Contact), nullptr, nullptr },
        { "audio_endpoint", reinterpret_cast<getter>(PhoneDialOptions_get_AudioEndpoint), reinterpret_cast<setter>(PhoneDialOptions_put_AudioEndpoint), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PhoneDialOptions[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PhoneDialOptions) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PhoneDialOptions) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PhoneDialOptions) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PhoneDialOptions) },
        { },
    };

    static PyType_Spec type_spec_PhoneDialOptions =
    {
        "_winrt_windows_applicationmodel_calls.PhoneDialOptions",
        sizeof(py::wrapper::Windows::ApplicationModel::Calls::PhoneDialOptions),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PhoneDialOptions
    };

    // ----- PhoneLine class --------------------

    static PyObject* _new_PhoneLine(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Calls::PhoneLine>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Calls::PhoneLine>::type_name);
        return nullptr;
    }

    static void _dealloc_PhoneLine(py::wrapper::Windows::ApplicationModel::Calls::PhoneLine* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PhoneLine_Dial(py::wrapper::Windows::ApplicationModel::Calls::PhoneLine* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Calls.PhoneLine", L"Dial", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                self->obj.Dial(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhoneLine_DialWithOptions(py::wrapper::Windows::ApplicationModel::Calls::PhoneLine* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Calls.PhoneLine", L"DialWithOptions", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Calls::PhoneDialOptions>(args, 0);

                self->obj.DialWithOptions(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhoneLine_DialWithResult(py::wrapper::Windows::ApplicationModel::Calls::PhoneLine* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Calls.PhoneLine", L"DialWithResult", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(self->obj.DialWithResult(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhoneLine_DialWithResultAsync(py::wrapper::Windows::ApplicationModel::Calls::PhoneLine* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Calls.PhoneLine", L"DialWithResultAsync", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(self->obj.DialWithResultAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhoneLine_EnableTextReply(py::wrapper::Windows::ApplicationModel::Calls::PhoneLine* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Calls.PhoneLine", L"EnableTextReply", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<bool>(args, 0);

                self->obj.EnableTextReply(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhoneLine_FromIdAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Calls.PhoneLine", L"FromIdAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::guid>(args, 0);

                return py::convert(winrt::Windows::ApplicationModel::Calls::PhoneLine::FromIdAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhoneLine_GetAllActivePhoneCalls(py::wrapper::Windows::ApplicationModel::Calls::PhoneLine* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Calls.PhoneLine", L"GetAllActivePhoneCalls", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetAllActivePhoneCalls());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhoneLine_GetAllActivePhoneCallsAsync(py::wrapper::Windows::ApplicationModel::Calls::PhoneLine* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Calls.PhoneLine", L"GetAllActivePhoneCallsAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetAllActivePhoneCallsAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhoneLine_IsImmediateDialNumberAsync(py::wrapper::Windows::ApplicationModel::Calls::PhoneLine* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Calls.PhoneLine", L"IsImmediateDialNumberAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.IsImmediateDialNumberAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhoneLine_get_CanDial(py::wrapper::Windows::ApplicationModel::Calls::PhoneLine* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Calls.PhoneLine", L"CanDial"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CanDial());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneLine_get_CellularDetails(py::wrapper::Windows::ApplicationModel::Calls::PhoneLine* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Calls.PhoneLine", L"CellularDetails"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CellularDetails());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneLine_get_DisplayColor(py::wrapper::Windows::ApplicationModel::Calls::PhoneLine* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Calls.PhoneLine", L"DisplayColor"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DisplayColor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneLine_get_DisplayName(py::wrapper::Windows::ApplicationModel::Calls::PhoneLine* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Calls.PhoneLine", L"DisplayName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DisplayName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneLine_get_Id(py::wrapper::Windows::ApplicationModel::Calls::PhoneLine* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Calls.PhoneLine", L"Id"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneLine_get_LineConfiguration(py::wrapper::Windows::ApplicationModel::Calls::PhoneLine* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Calls.PhoneLine", L"LineConfiguration"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.LineConfiguration());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneLine_get_NetworkName(py::wrapper::Windows::ApplicationModel::Calls::PhoneLine* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Calls.PhoneLine", L"NetworkName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.NetworkName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneLine_get_NetworkState(py::wrapper::Windows::ApplicationModel::Calls::PhoneLine* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Calls.PhoneLine", L"NetworkState"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.NetworkState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneLine_get_SupportsTile(py::wrapper::Windows::ApplicationModel::Calls::PhoneLine* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Calls.PhoneLine", L"SupportsTile"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SupportsTile());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneLine_get_Transport(py::wrapper::Windows::ApplicationModel::Calls::PhoneLine* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Calls.PhoneLine", L"Transport"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Transport());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneLine_get_VideoCallingCapabilities(py::wrapper::Windows::ApplicationModel::Calls::PhoneLine* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Calls.PhoneLine", L"VideoCallingCapabilities"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.VideoCallingCapabilities());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneLine_get_Voicemail(py::wrapper::Windows::ApplicationModel::Calls::PhoneLine* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Calls.PhoneLine", L"Voicemail"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Voicemail());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneLine_get_TransportDeviceId(py::wrapper::Windows::ApplicationModel::Calls::PhoneLine* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Calls.PhoneLine", L"TransportDeviceId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TransportDeviceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneLine_add_LineChanged(py::wrapper::Windows::ApplicationModel::Calls::PhoneLine* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Calls.PhoneLine", L"LineChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::ApplicationModel::Calls::PhoneLine, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.LineChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneLine_remove_LineChanged(py::wrapper::Windows::ApplicationModel::Calls::PhoneLine* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Calls.PhoneLine", L"LineChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.LineChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PhoneLine(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Calls::PhoneLine>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PhoneLine(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Calls::PhoneLine>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PhoneLine[] = {
        { "dial", reinterpret_cast<PyCFunction>(PhoneLine_Dial), METH_VARARGS, nullptr },
        { "dial_with_options", reinterpret_cast<PyCFunction>(PhoneLine_DialWithOptions), METH_VARARGS, nullptr },
        { "dial_with_result", reinterpret_cast<PyCFunction>(PhoneLine_DialWithResult), METH_VARARGS, nullptr },
        { "dial_with_result_async", reinterpret_cast<PyCFunction>(PhoneLine_DialWithResultAsync), METH_VARARGS, nullptr },
        { "enable_text_reply", reinterpret_cast<PyCFunction>(PhoneLine_EnableTextReply), METH_VARARGS, nullptr },
        { "from_id_async", reinterpret_cast<PyCFunction>(PhoneLine_FromIdAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "get_all_active_phone_calls", reinterpret_cast<PyCFunction>(PhoneLine_GetAllActivePhoneCalls), METH_VARARGS, nullptr },
        { "get_all_active_phone_calls_async", reinterpret_cast<PyCFunction>(PhoneLine_GetAllActivePhoneCallsAsync), METH_VARARGS, nullptr },
        { "is_immediate_dial_number_async", reinterpret_cast<PyCFunction>(PhoneLine_IsImmediateDialNumberAsync), METH_VARARGS, nullptr },
        { "add_line_changed", reinterpret_cast<PyCFunction>(PhoneLine_add_LineChanged), METH_O, nullptr },
        { "remove_line_changed", reinterpret_cast<PyCFunction>(PhoneLine_remove_LineChanged), METH_O, nullptr },
        { "_assign_array_", _assign_array_PhoneLine, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PhoneLine), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PhoneLine[] = {
        { "can_dial", reinterpret_cast<getter>(PhoneLine_get_CanDial), nullptr, nullptr, nullptr },
        { "cellular_details", reinterpret_cast<getter>(PhoneLine_get_CellularDetails), nullptr, nullptr, nullptr },
        { "display_color", reinterpret_cast<getter>(PhoneLine_get_DisplayColor), nullptr, nullptr, nullptr },
        { "display_name", reinterpret_cast<getter>(PhoneLine_get_DisplayName), nullptr, nullptr, nullptr },
        { "id", reinterpret_cast<getter>(PhoneLine_get_Id), nullptr, nullptr, nullptr },
        { "line_configuration", reinterpret_cast<getter>(PhoneLine_get_LineConfiguration), nullptr, nullptr, nullptr },
        { "network_name", reinterpret_cast<getter>(PhoneLine_get_NetworkName), nullptr, nullptr, nullptr },
        { "network_state", reinterpret_cast<getter>(PhoneLine_get_NetworkState), nullptr, nullptr, nullptr },
        { "supports_tile", reinterpret_cast<getter>(PhoneLine_get_SupportsTile), nullptr, nullptr, nullptr },
        { "transport", reinterpret_cast<getter>(PhoneLine_get_Transport), nullptr, nullptr, nullptr },
        { "video_calling_capabilities", reinterpret_cast<getter>(PhoneLine_get_VideoCallingCapabilities), nullptr, nullptr, nullptr },
        { "voicemail", reinterpret_cast<getter>(PhoneLine_get_Voicemail), nullptr, nullptr, nullptr },
        { "transport_device_id", reinterpret_cast<getter>(PhoneLine_get_TransportDeviceId), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PhoneLine[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PhoneLine) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PhoneLine) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PhoneLine) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PhoneLine) },
        { },
    };

    static PyType_Spec type_spec_PhoneLine =
    {
        "_winrt_windows_applicationmodel_calls.PhoneLine",
        sizeof(py::wrapper::Windows::ApplicationModel::Calls::PhoneLine),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PhoneLine
    };

    // ----- PhoneLineCellularDetails class --------------------

    static PyObject* _new_PhoneLineCellularDetails(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Calls::PhoneLineCellularDetails>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Calls::PhoneLineCellularDetails>::type_name);
        return nullptr;
    }

    static void _dealloc_PhoneLineCellularDetails(py::wrapper::Windows::ApplicationModel::Calls::PhoneLineCellularDetails* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PhoneLineCellularDetails_GetNetworkOperatorDisplayText(py::wrapper::Windows::ApplicationModel::Calls::PhoneLineCellularDetails* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Calls.PhoneLineCellularDetails", L"GetNetworkOperatorDisplayText", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Calls::PhoneLineNetworkOperatorDisplayTextLocation>(args, 0);

                return py::convert(self->obj.GetNetworkOperatorDisplayText(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhoneLineCellularDetails_get_IsModemOn(py::wrapper::Windows::ApplicationModel::Calls::PhoneLineCellularDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Calls.PhoneLineCellularDetails", L"IsModemOn"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsModemOn());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneLineCellularDetails_get_RegistrationRejectCode(py::wrapper::Windows::ApplicationModel::Calls::PhoneLineCellularDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Calls.PhoneLineCellularDetails", L"RegistrationRejectCode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RegistrationRejectCode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneLineCellularDetails_get_SimSlotIndex(py::wrapper::Windows::ApplicationModel::Calls::PhoneLineCellularDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Calls.PhoneLineCellularDetails", L"SimSlotIndex"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SimSlotIndex());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneLineCellularDetails_get_SimState(py::wrapper::Windows::ApplicationModel::Calls::PhoneLineCellularDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Calls.PhoneLineCellularDetails", L"SimState"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SimState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PhoneLineCellularDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Calls::PhoneLineCellularDetails>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PhoneLineCellularDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Calls::PhoneLineCellularDetails>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PhoneLineCellularDetails[] = {
        { "get_network_operator_display_text", reinterpret_cast<PyCFunction>(PhoneLineCellularDetails_GetNetworkOperatorDisplayText), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_PhoneLineCellularDetails, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PhoneLineCellularDetails), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PhoneLineCellularDetails[] = {
        { "is_modem_on", reinterpret_cast<getter>(PhoneLineCellularDetails_get_IsModemOn), nullptr, nullptr, nullptr },
        { "registration_reject_code", reinterpret_cast<getter>(PhoneLineCellularDetails_get_RegistrationRejectCode), nullptr, nullptr, nullptr },
        { "sim_slot_index", reinterpret_cast<getter>(PhoneLineCellularDetails_get_SimSlotIndex), nullptr, nullptr, nullptr },
        { "sim_state", reinterpret_cast<getter>(PhoneLineCellularDetails_get_SimState), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PhoneLineCellularDetails[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PhoneLineCellularDetails) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PhoneLineCellularDetails) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PhoneLineCellularDetails) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PhoneLineCellularDetails) },
        { },
    };

    static PyType_Spec type_spec_PhoneLineCellularDetails =
    {
        "_winrt_windows_applicationmodel_calls.PhoneLineCellularDetails",
        sizeof(py::wrapper::Windows::ApplicationModel::Calls::PhoneLineCellularDetails),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PhoneLineCellularDetails
    };

    // ----- PhoneLineConfiguration class --------------------

    static PyObject* _new_PhoneLineConfiguration(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Calls::PhoneLineConfiguration>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Calls::PhoneLineConfiguration>::type_name);
        return nullptr;
    }

    static void _dealloc_PhoneLineConfiguration(py::wrapper::Windows::ApplicationModel::Calls::PhoneLineConfiguration* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PhoneLineConfiguration_get_ExtendedProperties(py::wrapper::Windows::ApplicationModel::Calls::PhoneLineConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Calls.PhoneLineConfiguration", L"ExtendedProperties"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ExtendedProperties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneLineConfiguration_get_IsVideoCallingEnabled(py::wrapper::Windows::ApplicationModel::Calls::PhoneLineConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Calls.PhoneLineConfiguration", L"IsVideoCallingEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsVideoCallingEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PhoneLineConfiguration(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Calls::PhoneLineConfiguration>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PhoneLineConfiguration(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Calls::PhoneLineConfiguration>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PhoneLineConfiguration[] = {
        { "_assign_array_", _assign_array_PhoneLineConfiguration, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PhoneLineConfiguration), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PhoneLineConfiguration[] = {
        { "extended_properties", reinterpret_cast<getter>(PhoneLineConfiguration_get_ExtendedProperties), nullptr, nullptr, nullptr },
        { "is_video_calling_enabled", reinterpret_cast<getter>(PhoneLineConfiguration_get_IsVideoCallingEnabled), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PhoneLineConfiguration[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PhoneLineConfiguration) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PhoneLineConfiguration) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PhoneLineConfiguration) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PhoneLineConfiguration) },
        { },
    };

    static PyType_Spec type_spec_PhoneLineConfiguration =
    {
        "_winrt_windows_applicationmodel_calls.PhoneLineConfiguration",
        sizeof(py::wrapper::Windows::ApplicationModel::Calls::PhoneLineConfiguration),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PhoneLineConfiguration
    };

    // ----- PhoneLineDialResult class --------------------

    static PyObject* _new_PhoneLineDialResult(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Calls::PhoneLineDialResult>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Calls::PhoneLineDialResult>::type_name);
        return nullptr;
    }

    static void _dealloc_PhoneLineDialResult(py::wrapper::Windows::ApplicationModel::Calls::PhoneLineDialResult* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PhoneLineDialResult_get_DialCallStatus(py::wrapper::Windows::ApplicationModel::Calls::PhoneLineDialResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Calls.PhoneLineDialResult", L"DialCallStatus"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DialCallStatus());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneLineDialResult_get_DialedCall(py::wrapper::Windows::ApplicationModel::Calls::PhoneLineDialResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Calls.PhoneLineDialResult", L"DialedCall"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DialedCall());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PhoneLineDialResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Calls::PhoneLineDialResult>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PhoneLineDialResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Calls::PhoneLineDialResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PhoneLineDialResult[] = {
        { "_assign_array_", _assign_array_PhoneLineDialResult, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PhoneLineDialResult), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PhoneLineDialResult[] = {
        { "dial_call_status", reinterpret_cast<getter>(PhoneLineDialResult_get_DialCallStatus), nullptr, nullptr, nullptr },
        { "dialed_call", reinterpret_cast<getter>(PhoneLineDialResult_get_DialedCall), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PhoneLineDialResult[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PhoneLineDialResult) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PhoneLineDialResult) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PhoneLineDialResult) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PhoneLineDialResult) },
        { },
    };

    static PyType_Spec type_spec_PhoneLineDialResult =
    {
        "_winrt_windows_applicationmodel_calls.PhoneLineDialResult",
        sizeof(py::wrapper::Windows::ApplicationModel::Calls::PhoneLineDialResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PhoneLineDialResult
    };

    // ----- PhoneLineTransportDevice class --------------------

    static PyObject* _new_PhoneLineTransportDevice(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Calls::PhoneLineTransportDevice>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Calls::PhoneLineTransportDevice>::type_name);
        return nullptr;
    }

    static void _dealloc_PhoneLineTransportDevice(py::wrapper::Windows::ApplicationModel::Calls::PhoneLineTransportDevice* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PhoneLineTransportDevice_Connect(py::wrapper::Windows::ApplicationModel::Calls::PhoneLineTransportDevice* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Calls.PhoneLineTransportDevice", L"Connect", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.Connect());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhoneLineTransportDevice_ConnectAsync(py::wrapper::Windows::ApplicationModel::Calls::PhoneLineTransportDevice* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Calls.PhoneLineTransportDevice", L"ConnectAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.ConnectAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhoneLineTransportDevice_FromId(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Calls.PhoneLineTransportDevice", L"FromId", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::ApplicationModel::Calls::PhoneLineTransportDevice::FromId(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhoneLineTransportDevice_GetDeviceSelector(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Calls.PhoneLineTransportDevice", L"GetDeviceSelector", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::ApplicationModel::Calls::PhoneLineTransportDevice::GetDeviceSelector());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Calls.PhoneLineTransportDevice", L"GetDeviceSelector", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Calls::PhoneLineTransport>(args, 0);

                return py::convert(winrt::Windows::ApplicationModel::Calls::PhoneLineTransportDevice::GetDeviceSelector(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhoneLineTransportDevice_IsRegistered(py::wrapper::Windows::ApplicationModel::Calls::PhoneLineTransportDevice* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Calls.PhoneLineTransportDevice", L"IsRegistered", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.IsRegistered());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhoneLineTransportDevice_RegisterApp(py::wrapper::Windows::ApplicationModel::Calls::PhoneLineTransportDevice* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Calls.PhoneLineTransportDevice", L"RegisterApp", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.RegisterApp();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhoneLineTransportDevice_RegisterAppForUser(py::wrapper::Windows::ApplicationModel::Calls::PhoneLineTransportDevice* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Calls.PhoneLineTransportDevice", L"RegisterAppForUser", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::System::User>(args, 0);

                self->obj.RegisterAppForUser(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhoneLineTransportDevice_RequestAccessAsync(py::wrapper::Windows::ApplicationModel::Calls::PhoneLineTransportDevice* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Calls.PhoneLineTransportDevice", L"RequestAccessAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.RequestAccessAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhoneLineTransportDevice_UnregisterApp(py::wrapper::Windows::ApplicationModel::Calls::PhoneLineTransportDevice* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Calls.PhoneLineTransportDevice", L"UnregisterApp", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.UnregisterApp();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhoneLineTransportDevice_UnregisterAppForUser(py::wrapper::Windows::ApplicationModel::Calls::PhoneLineTransportDevice* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Calls.PhoneLineTransportDevice", L"UnregisterAppForUser", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::System::User>(args, 0);

                self->obj.UnregisterAppForUser(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhoneLineTransportDevice_get_DeviceId(py::wrapper::Windows::ApplicationModel::Calls::PhoneLineTransportDevice* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Calls.PhoneLineTransportDevice", L"DeviceId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DeviceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneLineTransportDevice_get_Transport(py::wrapper::Windows::ApplicationModel::Calls::PhoneLineTransportDevice* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Calls.PhoneLineTransportDevice", L"Transport"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Transport());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneLineTransportDevice_get_AudioRoutingStatus(py::wrapper::Windows::ApplicationModel::Calls::PhoneLineTransportDevice* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Calls.PhoneLineTransportDevice", L"AudioRoutingStatus"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AudioRoutingStatus());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneLineTransportDevice_get_InBandRingingEnabled(py::wrapper::Windows::ApplicationModel::Calls::PhoneLineTransportDevice* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Calls.PhoneLineTransportDevice", L"InBandRingingEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.InBandRingingEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneLineTransportDevice_add_AudioRoutingStatusChanged(py::wrapper::Windows::ApplicationModel::Calls::PhoneLineTransportDevice* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Calls.PhoneLineTransportDevice", L"AudioRoutingStatusChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::ApplicationModel::Calls::PhoneLineTransportDevice, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.AudioRoutingStatusChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneLineTransportDevice_remove_AudioRoutingStatusChanged(py::wrapper::Windows::ApplicationModel::Calls::PhoneLineTransportDevice* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Calls.PhoneLineTransportDevice", L"AudioRoutingStatusChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.AudioRoutingStatusChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneLineTransportDevice_add_InBandRingingEnabledChanged(py::wrapper::Windows::ApplicationModel::Calls::PhoneLineTransportDevice* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Calls.PhoneLineTransportDevice", L"InBandRingingEnabledChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::ApplicationModel::Calls::PhoneLineTransportDevice, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.InBandRingingEnabledChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneLineTransportDevice_remove_InBandRingingEnabledChanged(py::wrapper::Windows::ApplicationModel::Calls::PhoneLineTransportDevice* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Calls.PhoneLineTransportDevice", L"InBandRingingEnabledChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.InBandRingingEnabledChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PhoneLineTransportDevice(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Calls::PhoneLineTransportDevice>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PhoneLineTransportDevice(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Calls::PhoneLineTransportDevice>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PhoneLineTransportDevice[] = {
        { "connect", reinterpret_cast<PyCFunction>(PhoneLineTransportDevice_Connect), METH_VARARGS, nullptr },
        { "connect_async", reinterpret_cast<PyCFunction>(PhoneLineTransportDevice_ConnectAsync), METH_VARARGS, nullptr },
        { "from_id", reinterpret_cast<PyCFunction>(PhoneLineTransportDevice_FromId), METH_VARARGS | METH_STATIC, nullptr },
        { "get_device_selector", reinterpret_cast<PyCFunction>(PhoneLineTransportDevice_GetDeviceSelector), METH_VARARGS | METH_STATIC, nullptr },
        { "is_registered", reinterpret_cast<PyCFunction>(PhoneLineTransportDevice_IsRegistered), METH_VARARGS, nullptr },
        { "register_app", reinterpret_cast<PyCFunction>(PhoneLineTransportDevice_RegisterApp), METH_VARARGS, nullptr },
        { "register_app_for_user", reinterpret_cast<PyCFunction>(PhoneLineTransportDevice_RegisterAppForUser), METH_VARARGS, nullptr },
        { "request_access_async", reinterpret_cast<PyCFunction>(PhoneLineTransportDevice_RequestAccessAsync), METH_VARARGS, nullptr },
        { "unregister_app", reinterpret_cast<PyCFunction>(PhoneLineTransportDevice_UnregisterApp), METH_VARARGS, nullptr },
        { "unregister_app_for_user", reinterpret_cast<PyCFunction>(PhoneLineTransportDevice_UnregisterAppForUser), METH_VARARGS, nullptr },
        { "add_audio_routing_status_changed", reinterpret_cast<PyCFunction>(PhoneLineTransportDevice_add_AudioRoutingStatusChanged), METH_O, nullptr },
        { "remove_audio_routing_status_changed", reinterpret_cast<PyCFunction>(PhoneLineTransportDevice_remove_AudioRoutingStatusChanged), METH_O, nullptr },
        { "add_in_band_ringing_enabled_changed", reinterpret_cast<PyCFunction>(PhoneLineTransportDevice_add_InBandRingingEnabledChanged), METH_O, nullptr },
        { "remove_in_band_ringing_enabled_changed", reinterpret_cast<PyCFunction>(PhoneLineTransportDevice_remove_InBandRingingEnabledChanged), METH_O, nullptr },
        { "_assign_array_", _assign_array_PhoneLineTransportDevice, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PhoneLineTransportDevice), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PhoneLineTransportDevice[] = {
        { "device_id", reinterpret_cast<getter>(PhoneLineTransportDevice_get_DeviceId), nullptr, nullptr, nullptr },
        { "transport", reinterpret_cast<getter>(PhoneLineTransportDevice_get_Transport), nullptr, nullptr, nullptr },
        { "audio_routing_status", reinterpret_cast<getter>(PhoneLineTransportDevice_get_AudioRoutingStatus), nullptr, nullptr, nullptr },
        { "in_band_ringing_enabled", reinterpret_cast<getter>(PhoneLineTransportDevice_get_InBandRingingEnabled), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PhoneLineTransportDevice[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PhoneLineTransportDevice) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PhoneLineTransportDevice) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PhoneLineTransportDevice) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PhoneLineTransportDevice) },
        { },
    };

    static PyType_Spec type_spec_PhoneLineTransportDevice =
    {
        "_winrt_windows_applicationmodel_calls.PhoneLineTransportDevice",
        sizeof(py::wrapper::Windows::ApplicationModel::Calls::PhoneLineTransportDevice),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PhoneLineTransportDevice
    };

    // ----- PhoneLineWatcher class --------------------

    static PyObject* _new_PhoneLineWatcher(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Calls::PhoneLineWatcher>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Calls::PhoneLineWatcher>::type_name);
        return nullptr;
    }

    static void _dealloc_PhoneLineWatcher(py::wrapper::Windows::ApplicationModel::Calls::PhoneLineWatcher* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PhoneLineWatcher_Start(py::wrapper::Windows::ApplicationModel::Calls::PhoneLineWatcher* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Calls.PhoneLineWatcher", L"Start", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Start();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhoneLineWatcher_Stop(py::wrapper::Windows::ApplicationModel::Calls::PhoneLineWatcher* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Calls.PhoneLineWatcher", L"Stop", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Stop();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhoneLineWatcher_get_Status(py::wrapper::Windows::ApplicationModel::Calls::PhoneLineWatcher* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Calls.PhoneLineWatcher", L"Status"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneLineWatcher_add_EnumerationCompleted(py::wrapper::Windows::ApplicationModel::Calls::PhoneLineWatcher* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Calls.PhoneLineWatcher", L"EnumerationCompleted"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::ApplicationModel::Calls::PhoneLineWatcher, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.EnumerationCompleted(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneLineWatcher_remove_EnumerationCompleted(py::wrapper::Windows::ApplicationModel::Calls::PhoneLineWatcher* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Calls.PhoneLineWatcher", L"EnumerationCompleted"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.EnumerationCompleted(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneLineWatcher_add_LineAdded(py::wrapper::Windows::ApplicationModel::Calls::PhoneLineWatcher* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Calls.PhoneLineWatcher", L"LineAdded"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::ApplicationModel::Calls::PhoneLineWatcher, winrt::Windows::ApplicationModel::Calls::PhoneLineWatcherEventArgs>>(arg);

            return py::convert(self->obj.LineAdded(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneLineWatcher_remove_LineAdded(py::wrapper::Windows::ApplicationModel::Calls::PhoneLineWatcher* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Calls.PhoneLineWatcher", L"LineAdded"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.LineAdded(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneLineWatcher_add_LineRemoved(py::wrapper::Windows::ApplicationModel::Calls::PhoneLineWatcher* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Calls.PhoneLineWatcher", L"LineRemoved"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::ApplicationModel::Calls::PhoneLineWatcher, winrt::Windows::ApplicationModel::Calls::PhoneLineWatcherEventArgs>>(arg);

            return py::convert(self->obj.LineRemoved(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneLineWatcher_remove_LineRemoved(py::wrapper::Windows::ApplicationModel::Calls::PhoneLineWatcher* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Calls.PhoneLineWatcher", L"LineRemoved"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.LineRemoved(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneLineWatcher_add_LineUpdated(py::wrapper::Windows::ApplicationModel::Calls::PhoneLineWatcher* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Calls.PhoneLineWatcher", L"LineUpdated"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::ApplicationModel::Calls::PhoneLineWatcher, winrt::Windows::ApplicationModel::Calls::PhoneLineWatcherEventArgs>>(arg);

            return py::convert(self->obj.LineUpdated(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneLineWatcher_remove_LineUpdated(py::wrapper::Windows::ApplicationModel::Calls::PhoneLineWatcher* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Calls.PhoneLineWatcher", L"LineUpdated"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.LineUpdated(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneLineWatcher_add_Stopped(py::wrapper::Windows::ApplicationModel::Calls::PhoneLineWatcher* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Calls.PhoneLineWatcher", L"Stopped"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::ApplicationModel::Calls::PhoneLineWatcher, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.Stopped(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneLineWatcher_remove_Stopped(py::wrapper::Windows::ApplicationModel::Calls::PhoneLineWatcher* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Calls.PhoneLineWatcher", L"Stopped"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Stopped(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PhoneLineWatcher(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Calls::PhoneLineWatcher>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PhoneLineWatcher(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Calls::PhoneLineWatcher>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PhoneLineWatcher[] = {
        { "start", reinterpret_cast<PyCFunction>(PhoneLineWatcher_Start), METH_VARARGS, nullptr },
        { "stop", reinterpret_cast<PyCFunction>(PhoneLineWatcher_Stop), METH_VARARGS, nullptr },
        { "add_enumeration_completed", reinterpret_cast<PyCFunction>(PhoneLineWatcher_add_EnumerationCompleted), METH_O, nullptr },
        { "remove_enumeration_completed", reinterpret_cast<PyCFunction>(PhoneLineWatcher_remove_EnumerationCompleted), METH_O, nullptr },
        { "add_line_added", reinterpret_cast<PyCFunction>(PhoneLineWatcher_add_LineAdded), METH_O, nullptr },
        { "remove_line_added", reinterpret_cast<PyCFunction>(PhoneLineWatcher_remove_LineAdded), METH_O, nullptr },
        { "add_line_removed", reinterpret_cast<PyCFunction>(PhoneLineWatcher_add_LineRemoved), METH_O, nullptr },
        { "remove_line_removed", reinterpret_cast<PyCFunction>(PhoneLineWatcher_remove_LineRemoved), METH_O, nullptr },
        { "add_line_updated", reinterpret_cast<PyCFunction>(PhoneLineWatcher_add_LineUpdated), METH_O, nullptr },
        { "remove_line_updated", reinterpret_cast<PyCFunction>(PhoneLineWatcher_remove_LineUpdated), METH_O, nullptr },
        { "add_stopped", reinterpret_cast<PyCFunction>(PhoneLineWatcher_add_Stopped), METH_O, nullptr },
        { "remove_stopped", reinterpret_cast<PyCFunction>(PhoneLineWatcher_remove_Stopped), METH_O, nullptr },
        { "_assign_array_", _assign_array_PhoneLineWatcher, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PhoneLineWatcher), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PhoneLineWatcher[] = {
        { "status", reinterpret_cast<getter>(PhoneLineWatcher_get_Status), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PhoneLineWatcher[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PhoneLineWatcher) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PhoneLineWatcher) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PhoneLineWatcher) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PhoneLineWatcher) },
        { },
    };

    static PyType_Spec type_spec_PhoneLineWatcher =
    {
        "_winrt_windows_applicationmodel_calls.PhoneLineWatcher",
        sizeof(py::wrapper::Windows::ApplicationModel::Calls::PhoneLineWatcher),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PhoneLineWatcher
    };

    // ----- PhoneLineWatcherEventArgs class --------------------

    static PyObject* _new_PhoneLineWatcherEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Calls::PhoneLineWatcherEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Calls::PhoneLineWatcherEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_PhoneLineWatcherEventArgs(py::wrapper::Windows::ApplicationModel::Calls::PhoneLineWatcherEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PhoneLineWatcherEventArgs_get_LineId(py::wrapper::Windows::ApplicationModel::Calls::PhoneLineWatcherEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Calls.PhoneLineWatcherEventArgs", L"LineId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.LineId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PhoneLineWatcherEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Calls::PhoneLineWatcherEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PhoneLineWatcherEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Calls::PhoneLineWatcherEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PhoneLineWatcherEventArgs[] = {
        { "_assign_array_", _assign_array_PhoneLineWatcherEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PhoneLineWatcherEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PhoneLineWatcherEventArgs[] = {
        { "line_id", reinterpret_cast<getter>(PhoneLineWatcherEventArgs_get_LineId), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PhoneLineWatcherEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PhoneLineWatcherEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PhoneLineWatcherEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PhoneLineWatcherEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PhoneLineWatcherEventArgs) },
        { },
    };

    static PyType_Spec type_spec_PhoneLineWatcherEventArgs =
    {
        "_winrt_windows_applicationmodel_calls.PhoneLineWatcherEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Calls::PhoneLineWatcherEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PhoneLineWatcherEventArgs
    };

    // ----- PhoneVoicemail class --------------------

    static PyObject* _new_PhoneVoicemail(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Calls::PhoneVoicemail>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Calls::PhoneVoicemail>::type_name);
        return nullptr;
    }

    static void _dealloc_PhoneVoicemail(py::wrapper::Windows::ApplicationModel::Calls::PhoneVoicemail* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PhoneVoicemail_DialVoicemailAsync(py::wrapper::Windows::ApplicationModel::Calls::PhoneVoicemail* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Calls.PhoneVoicemail", L"DialVoicemailAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.DialVoicemailAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhoneVoicemail_get_MessageCount(py::wrapper::Windows::ApplicationModel::Calls::PhoneVoicemail* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Calls.PhoneVoicemail", L"MessageCount"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MessageCount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneVoicemail_get_Number(py::wrapper::Windows::ApplicationModel::Calls::PhoneVoicemail* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Calls.PhoneVoicemail", L"Number"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Number());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneVoicemail_get_Type(py::wrapper::Windows::ApplicationModel::Calls::PhoneVoicemail* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Calls.PhoneVoicemail", L"Type"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Type());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PhoneVoicemail(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Calls::PhoneVoicemail>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PhoneVoicemail(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Calls::PhoneVoicemail>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PhoneVoicemail[] = {
        { "dial_voicemail_async", reinterpret_cast<PyCFunction>(PhoneVoicemail_DialVoicemailAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_PhoneVoicemail, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PhoneVoicemail), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PhoneVoicemail[] = {
        { "message_count", reinterpret_cast<getter>(PhoneVoicemail_get_MessageCount), nullptr, nullptr, nullptr },
        { "number", reinterpret_cast<getter>(PhoneVoicemail_get_Number), nullptr, nullptr, nullptr },
        { "type", reinterpret_cast<getter>(PhoneVoicemail_get_Type), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PhoneVoicemail[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PhoneVoicemail) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PhoneVoicemail) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PhoneVoicemail) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PhoneVoicemail) },
        { },
    };

    static PyType_Spec type_spec_PhoneVoicemail =
    {
        "_winrt_windows_applicationmodel_calls.PhoneVoicemail",
        sizeof(py::wrapper::Windows::ApplicationModel::Calls::PhoneVoicemail),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PhoneVoicemail
    };

    // ----- VoipCallCoordinator class --------------------

    static PyObject* _new_VoipCallCoordinator(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Calls::VoipCallCoordinator>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Calls::VoipCallCoordinator>::type_name);
        return nullptr;
    }

    static void _dealloc_VoipCallCoordinator(py::wrapper::Windows::ApplicationModel::Calls::VoipCallCoordinator* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* VoipCallCoordinator_CancelUpgrade(py::wrapper::Windows::ApplicationModel::Calls::VoipCallCoordinator* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Calls.VoipCallCoordinator", L"CancelUpgrade", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::guid>(args, 0);

                self->obj.CancelUpgrade(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VoipCallCoordinator_GetDefault(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Calls.VoipCallCoordinator", L"GetDefault", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::ApplicationModel::Calls::VoipCallCoordinator::GetDefault());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VoipCallCoordinator_NotifyMuted(py::wrapper::Windows::ApplicationModel::Calls::VoipCallCoordinator* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Calls.VoipCallCoordinator", L"NotifyMuted", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.NotifyMuted();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VoipCallCoordinator_NotifyUnmuted(py::wrapper::Windows::ApplicationModel::Calls::VoipCallCoordinator* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Calls.VoipCallCoordinator", L"NotifyUnmuted", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.NotifyUnmuted();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VoipCallCoordinator_RequestIncomingUpgradeToVideoCall(py::wrapper::Windows::ApplicationModel::Calls::VoipCallCoordinator* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 9)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Calls.VoipCallCoordinator", L"RequestIncomingUpgradeToVideoCall", 9))
            {
                py::set_arg_count_version_error(9);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::hstring>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 3);
                auto param4 = py::convert_to<winrt::hstring>(args, 4);
                auto param5 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 5);
                auto param6 = py::convert_to<winrt::hstring>(args, 6);
                auto param7 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 7);
                auto param8 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(args, 8);

                return py::convert(self->obj.RequestIncomingUpgradeToVideoCall(param0, param1, param2, param3, param4, param5, param6, param7, param8));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VoipCallCoordinator_RequestNewAppInitiatedCall(py::wrapper::Windows::ApplicationModel::Calls::VoipCallCoordinator* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 5)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Calls.VoipCallCoordinator", L"RequestNewAppInitiatedCall", 5))
            {
                py::set_arg_count_version_error(5);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::hstring>(args, 2);
                auto param3 = py::convert_to<winrt::hstring>(args, 3);
                auto param4 = py::convert_to<winrt::Windows::ApplicationModel::Calls::VoipPhoneCallMedia>(args, 4);

                return py::convert(self->obj.RequestNewAppInitiatedCall(param0, param1, param2, param3, param4));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VoipCallCoordinator_RequestNewIncomingCall(py::wrapper::Windows::ApplicationModel::Calls::VoipCallCoordinator* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 10)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Calls.VoipCallCoordinator", L"RequestNewIncomingCall", 10))
            {
                py::set_arg_count_version_error(10);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::hstring>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 3);
                auto param4 = py::convert_to<winrt::hstring>(args, 4);
                auto param5 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 5);
                auto param6 = py::convert_to<winrt::hstring>(args, 6);
                auto param7 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 7);
                auto param8 = py::convert_to<winrt::Windows::ApplicationModel::Calls::VoipPhoneCallMedia>(args, 8);
                auto param9 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(args, 9);

                return py::convert(self->obj.RequestNewIncomingCall(param0, param1, param2, param3, param4, param5, param6, param7, param8, param9));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 11)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Calls.VoipCallCoordinator", L"RequestNewIncomingCall", 11))
            {
                py::set_arg_count_version_error(11);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::hstring>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 3);
                auto param4 = py::convert_to<winrt::hstring>(args, 4);
                auto param5 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 5);
                auto param6 = py::convert_to<winrt::hstring>(args, 6);
                auto param7 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 7);
                auto param8 = py::convert_to<winrt::Windows::ApplicationModel::Calls::VoipPhoneCallMedia>(args, 8);
                auto param9 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(args, 9);
                auto param10 = py::convert_to<winrt::hstring>(args, 10);

                return py::convert(self->obj.RequestNewIncomingCall(param0, param1, param2, param3, param4, param5, param6, param7, param8, param9, param10));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VoipCallCoordinator_RequestNewOutgoingCall(py::wrapper::Windows::ApplicationModel::Calls::VoipCallCoordinator* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 4)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Calls.VoipCallCoordinator", L"RequestNewOutgoingCall", 4))
            {
                py::set_arg_count_version_error(4);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::hstring>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::ApplicationModel::Calls::VoipPhoneCallMedia>(args, 3);

                return py::convert(self->obj.RequestNewOutgoingCall(param0, param1, param2, param3));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VoipCallCoordinator_RequestOutgoingUpgradeToVideoCall(py::wrapper::Windows::ApplicationModel::Calls::VoipCallCoordinator* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 4)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Calls.VoipCallCoordinator", L"RequestOutgoingUpgradeToVideoCall", 4))
            {
                py::set_arg_count_version_error(4);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::guid>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::hstring>(args, 2);
                auto param3 = py::convert_to<winrt::hstring>(args, 3);

                return py::convert(self->obj.RequestOutgoingUpgradeToVideoCall(param0, param1, param2, param3));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VoipCallCoordinator_ReserveCallResourcesAsync(py::wrapper::Windows::ApplicationModel::Calls::VoipCallCoordinator* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Calls.VoipCallCoordinator", L"ReserveCallResourcesAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.ReserveCallResourcesAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Calls.VoipCallCoordinator", L"ReserveCallResourcesAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.ReserveCallResourcesAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VoipCallCoordinator_SetupNewAcceptedCall(py::wrapper::Windows::ApplicationModel::Calls::VoipCallCoordinator* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 5)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Calls.VoipCallCoordinator", L"SetupNewAcceptedCall", 5))
            {
                py::set_arg_count_version_error(5);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::hstring>(args, 2);
                auto param3 = py::convert_to<winrt::hstring>(args, 3);
                auto param4 = py::convert_to<winrt::Windows::ApplicationModel::Calls::VoipPhoneCallMedia>(args, 4);

                return py::convert(self->obj.SetupNewAcceptedCall(param0, param1, param2, param3, param4));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VoipCallCoordinator_TerminateCellularCall(py::wrapper::Windows::ApplicationModel::Calls::VoipCallCoordinator* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Calls.VoipCallCoordinator", L"TerminateCellularCall", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::guid>(args, 0);

                self->obj.TerminateCellularCall(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VoipCallCoordinator_add_MuteStateChanged(py::wrapper::Windows::ApplicationModel::Calls::VoipCallCoordinator* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Calls.VoipCallCoordinator", L"MuteStateChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::ApplicationModel::Calls::VoipCallCoordinator, winrt::Windows::ApplicationModel::Calls::MuteChangeEventArgs>>(arg);

            return py::convert(self->obj.MuteStateChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VoipCallCoordinator_remove_MuteStateChanged(py::wrapper::Windows::ApplicationModel::Calls::VoipCallCoordinator* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Calls.VoipCallCoordinator", L"MuteStateChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.MuteStateChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_VoipCallCoordinator(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Calls::VoipCallCoordinator>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_VoipCallCoordinator(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Calls::VoipCallCoordinator>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_VoipCallCoordinator[] = {
        { "cancel_upgrade", reinterpret_cast<PyCFunction>(VoipCallCoordinator_CancelUpgrade), METH_VARARGS, nullptr },
        { "get_default", reinterpret_cast<PyCFunction>(VoipCallCoordinator_GetDefault), METH_VARARGS | METH_STATIC, nullptr },
        { "notify_muted", reinterpret_cast<PyCFunction>(VoipCallCoordinator_NotifyMuted), METH_VARARGS, nullptr },
        { "notify_unmuted", reinterpret_cast<PyCFunction>(VoipCallCoordinator_NotifyUnmuted), METH_VARARGS, nullptr },
        { "request_incoming_upgrade_to_video_call", reinterpret_cast<PyCFunction>(VoipCallCoordinator_RequestIncomingUpgradeToVideoCall), METH_VARARGS, nullptr },
        { "request_new_app_initiated_call", reinterpret_cast<PyCFunction>(VoipCallCoordinator_RequestNewAppInitiatedCall), METH_VARARGS, nullptr },
        { "request_new_incoming_call", reinterpret_cast<PyCFunction>(VoipCallCoordinator_RequestNewIncomingCall), METH_VARARGS, nullptr },
        { "request_new_outgoing_call", reinterpret_cast<PyCFunction>(VoipCallCoordinator_RequestNewOutgoingCall), METH_VARARGS, nullptr },
        { "request_outgoing_upgrade_to_video_call", reinterpret_cast<PyCFunction>(VoipCallCoordinator_RequestOutgoingUpgradeToVideoCall), METH_VARARGS, nullptr },
        { "reserve_call_resources_async", reinterpret_cast<PyCFunction>(VoipCallCoordinator_ReserveCallResourcesAsync), METH_VARARGS, nullptr },
        { "setup_new_accepted_call", reinterpret_cast<PyCFunction>(VoipCallCoordinator_SetupNewAcceptedCall), METH_VARARGS, nullptr },
        { "terminate_cellular_call", reinterpret_cast<PyCFunction>(VoipCallCoordinator_TerminateCellularCall), METH_VARARGS, nullptr },
        { "add_mute_state_changed", reinterpret_cast<PyCFunction>(VoipCallCoordinator_add_MuteStateChanged), METH_O, nullptr },
        { "remove_mute_state_changed", reinterpret_cast<PyCFunction>(VoipCallCoordinator_remove_MuteStateChanged), METH_O, nullptr },
        { "_assign_array_", _assign_array_VoipCallCoordinator, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_VoipCallCoordinator), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_VoipCallCoordinator[] = {
        { }
    };

    static PyType_Slot _type_slots_VoipCallCoordinator[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_VoipCallCoordinator) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_VoipCallCoordinator) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_VoipCallCoordinator) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_VoipCallCoordinator) },
        { },
    };

    static PyType_Spec type_spec_VoipCallCoordinator =
    {
        "_winrt_windows_applicationmodel_calls.VoipCallCoordinator",
        sizeof(py::wrapper::Windows::ApplicationModel::Calls::VoipCallCoordinator),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_VoipCallCoordinator
    };

    // ----- VoipPhoneCall class --------------------

    static PyObject* _new_VoipPhoneCall(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Calls::VoipPhoneCall>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Calls::VoipPhoneCall>::type_name);
        return nullptr;
    }

    static void _dealloc_VoipPhoneCall(py::wrapper::Windows::ApplicationModel::Calls::VoipPhoneCall* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* VoipPhoneCall_NotifyCallAccepted(py::wrapper::Windows::ApplicationModel::Calls::VoipPhoneCall* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Calls.VoipPhoneCall", L"NotifyCallAccepted", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Calls::VoipPhoneCallMedia>(args, 0);

                self->obj.NotifyCallAccepted(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VoipPhoneCall_NotifyCallActive(py::wrapper::Windows::ApplicationModel::Calls::VoipPhoneCall* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Calls.VoipPhoneCall", L"NotifyCallActive", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.NotifyCallActive();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VoipPhoneCall_NotifyCallEnded(py::wrapper::Windows::ApplicationModel::Calls::VoipPhoneCall* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Calls.VoipPhoneCall", L"NotifyCallEnded", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.NotifyCallEnded();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VoipPhoneCall_NotifyCallHeld(py::wrapper::Windows::ApplicationModel::Calls::VoipPhoneCall* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Calls.VoipPhoneCall", L"NotifyCallHeld", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.NotifyCallHeld();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VoipPhoneCall_NotifyCallReady(py::wrapper::Windows::ApplicationModel::Calls::VoipPhoneCall* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Calls.VoipPhoneCall", L"NotifyCallReady", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.NotifyCallReady();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VoipPhoneCall_TryShowAppUI(py::wrapper::Windows::ApplicationModel::Calls::VoipPhoneCall* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Calls.VoipPhoneCall", L"TryShowAppUI", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.TryShowAppUI();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VoipPhoneCall_get_StartTime(py::wrapper::Windows::ApplicationModel::Calls::VoipPhoneCall* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Calls.VoipPhoneCall", L"StartTime"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.StartTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VoipPhoneCall_put_StartTime(py::wrapper::Windows::ApplicationModel::Calls::VoipPhoneCall* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Calls.VoipPhoneCall", L"StartTime"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::DateTime>(arg);

            self->obj.StartTime(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VoipPhoneCall_get_ContactName(py::wrapper::Windows::ApplicationModel::Calls::VoipPhoneCall* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Calls.VoipPhoneCall", L"ContactName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ContactName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VoipPhoneCall_put_ContactName(py::wrapper::Windows::ApplicationModel::Calls::VoipPhoneCall* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Calls.VoipPhoneCall", L"ContactName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.ContactName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VoipPhoneCall_get_CallMedia(py::wrapper::Windows::ApplicationModel::Calls::VoipPhoneCall* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Calls.VoipPhoneCall", L"CallMedia"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CallMedia());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VoipPhoneCall_put_CallMedia(py::wrapper::Windows::ApplicationModel::Calls::VoipPhoneCall* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Calls.VoipPhoneCall", L"CallMedia"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Calls::VoipPhoneCallMedia>(arg);

            self->obj.CallMedia(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VoipPhoneCall_add_AnswerRequested(py::wrapper::Windows::ApplicationModel::Calls::VoipPhoneCall* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Calls.VoipPhoneCall", L"AnswerRequested"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::ApplicationModel::Calls::VoipPhoneCall, winrt::Windows::ApplicationModel::Calls::CallAnswerEventArgs>>(arg);

            return py::convert(self->obj.AnswerRequested(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VoipPhoneCall_remove_AnswerRequested(py::wrapper::Windows::ApplicationModel::Calls::VoipPhoneCall* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Calls.VoipPhoneCall", L"AnswerRequested"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.AnswerRequested(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VoipPhoneCall_add_EndRequested(py::wrapper::Windows::ApplicationModel::Calls::VoipPhoneCall* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Calls.VoipPhoneCall", L"EndRequested"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::ApplicationModel::Calls::VoipPhoneCall, winrt::Windows::ApplicationModel::Calls::CallStateChangeEventArgs>>(arg);

            return py::convert(self->obj.EndRequested(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VoipPhoneCall_remove_EndRequested(py::wrapper::Windows::ApplicationModel::Calls::VoipPhoneCall* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Calls.VoipPhoneCall", L"EndRequested"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.EndRequested(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VoipPhoneCall_add_HoldRequested(py::wrapper::Windows::ApplicationModel::Calls::VoipPhoneCall* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Calls.VoipPhoneCall", L"HoldRequested"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::ApplicationModel::Calls::VoipPhoneCall, winrt::Windows::ApplicationModel::Calls::CallStateChangeEventArgs>>(arg);

            return py::convert(self->obj.HoldRequested(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VoipPhoneCall_remove_HoldRequested(py::wrapper::Windows::ApplicationModel::Calls::VoipPhoneCall* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Calls.VoipPhoneCall", L"HoldRequested"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.HoldRequested(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VoipPhoneCall_add_RejectRequested(py::wrapper::Windows::ApplicationModel::Calls::VoipPhoneCall* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Calls.VoipPhoneCall", L"RejectRequested"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::ApplicationModel::Calls::VoipPhoneCall, winrt::Windows::ApplicationModel::Calls::CallRejectEventArgs>>(arg);

            return py::convert(self->obj.RejectRequested(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VoipPhoneCall_remove_RejectRequested(py::wrapper::Windows::ApplicationModel::Calls::VoipPhoneCall* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Calls.VoipPhoneCall", L"RejectRequested"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.RejectRequested(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VoipPhoneCall_add_ResumeRequested(py::wrapper::Windows::ApplicationModel::Calls::VoipPhoneCall* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Calls.VoipPhoneCall", L"ResumeRequested"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::ApplicationModel::Calls::VoipPhoneCall, winrt::Windows::ApplicationModel::Calls::CallStateChangeEventArgs>>(arg);

            return py::convert(self->obj.ResumeRequested(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VoipPhoneCall_remove_ResumeRequested(py::wrapper::Windows::ApplicationModel::Calls::VoipPhoneCall* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Calls.VoipPhoneCall", L"ResumeRequested"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ResumeRequested(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_VoipPhoneCall(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Calls::VoipPhoneCall>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_VoipPhoneCall(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Calls::VoipPhoneCall>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_VoipPhoneCall[] = {
        { "notify_call_accepted", reinterpret_cast<PyCFunction>(VoipPhoneCall_NotifyCallAccepted), METH_VARARGS, nullptr },
        { "notify_call_active", reinterpret_cast<PyCFunction>(VoipPhoneCall_NotifyCallActive), METH_VARARGS, nullptr },
        { "notify_call_ended", reinterpret_cast<PyCFunction>(VoipPhoneCall_NotifyCallEnded), METH_VARARGS, nullptr },
        { "notify_call_held", reinterpret_cast<PyCFunction>(VoipPhoneCall_NotifyCallHeld), METH_VARARGS, nullptr },
        { "notify_call_ready", reinterpret_cast<PyCFunction>(VoipPhoneCall_NotifyCallReady), METH_VARARGS, nullptr },
        { "try_show_app_u_i", reinterpret_cast<PyCFunction>(VoipPhoneCall_TryShowAppUI), METH_VARARGS, nullptr },
        { "add_answer_requested", reinterpret_cast<PyCFunction>(VoipPhoneCall_add_AnswerRequested), METH_O, nullptr },
        { "remove_answer_requested", reinterpret_cast<PyCFunction>(VoipPhoneCall_remove_AnswerRequested), METH_O, nullptr },
        { "add_end_requested", reinterpret_cast<PyCFunction>(VoipPhoneCall_add_EndRequested), METH_O, nullptr },
        { "remove_end_requested", reinterpret_cast<PyCFunction>(VoipPhoneCall_remove_EndRequested), METH_O, nullptr },
        { "add_hold_requested", reinterpret_cast<PyCFunction>(VoipPhoneCall_add_HoldRequested), METH_O, nullptr },
        { "remove_hold_requested", reinterpret_cast<PyCFunction>(VoipPhoneCall_remove_HoldRequested), METH_O, nullptr },
        { "add_reject_requested", reinterpret_cast<PyCFunction>(VoipPhoneCall_add_RejectRequested), METH_O, nullptr },
        { "remove_reject_requested", reinterpret_cast<PyCFunction>(VoipPhoneCall_remove_RejectRequested), METH_O, nullptr },
        { "add_resume_requested", reinterpret_cast<PyCFunction>(VoipPhoneCall_add_ResumeRequested), METH_O, nullptr },
        { "remove_resume_requested", reinterpret_cast<PyCFunction>(VoipPhoneCall_remove_ResumeRequested), METH_O, nullptr },
        { "_assign_array_", _assign_array_VoipPhoneCall, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_VoipPhoneCall), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_VoipPhoneCall[] = {
        { "start_time", reinterpret_cast<getter>(VoipPhoneCall_get_StartTime), reinterpret_cast<setter>(VoipPhoneCall_put_StartTime), nullptr, nullptr },
        { "contact_name", reinterpret_cast<getter>(VoipPhoneCall_get_ContactName), reinterpret_cast<setter>(VoipPhoneCall_put_ContactName), nullptr, nullptr },
        { "call_media", reinterpret_cast<getter>(VoipPhoneCall_get_CallMedia), reinterpret_cast<setter>(VoipPhoneCall_put_CallMedia), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_VoipPhoneCall[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_VoipPhoneCall) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_VoipPhoneCall) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_VoipPhoneCall) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_VoipPhoneCall) },
        { },
    };

    static PyType_Spec type_spec_VoipPhoneCall =
    {
        "_winrt_windows_applicationmodel_calls.VoipPhoneCall",
        sizeof(py::wrapper::Windows::ApplicationModel::Calls::VoipPhoneCall),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_VoipPhoneCall
    };

    // ----- Windows.ApplicationModel.Calls Initialization --------------------
    PyDoc_STRVAR(module_doc, "Windows::ApplicationModel::Calls");


    static PyModuleDef module_def
        = {PyModuleDef_HEAD_INIT,
           "_winrt_windows_applicationmodel_calls",
           module_doc,
           0,
           nullptr,
           nullptr,
           nullptr,
           nullptr,
           nullptr};

} // py::cpp::Windows::ApplicationModel::Calls

PyMODINIT_FUNC PyInit__winrt_windows_applicationmodel_calls(void) noexcept
{
    using namespace py::cpp::Windows::ApplicationModel::Calls;

    if (py::import_winrt_runtime() == -1)
    {
        return nullptr;
    }

    py::pyobj_handle module{PyModule_Create(&module_def)};

    if (!module)
    {
        return nullptr;
    }

    auto object_type = py::get_object_type();
    if (!object_type)
    {
        return nullptr;
    }

    py::pyobj_handle object_bases{PyTuple_Pack(1, object_type)};

    if (!object_bases)
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), &type_spec_CallAnswerEventArgs, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), &type_spec_CallAnswerEventArgs, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), &type_spec_CallRejectEventArgs, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), &type_spec_CallRejectEventArgs, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), &type_spec_CallStateChangeEventArgs, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), &type_spec_CallStateChangeEventArgs, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), &type_spec_LockScreenCallEndCallDeferral, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), &type_spec_LockScreenCallEndCallDeferral, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), &type_spec_LockScreenCallEndRequestedEventArgs, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), &type_spec_LockScreenCallEndRequestedEventArgs, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), &type_spec_LockScreenCallUI, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), &type_spec_LockScreenCallUI, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), &type_spec_MuteChangeEventArgs, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), &type_spec_MuteChangeEventArgs, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), &type_spec_PhoneCall, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), &type_spec_PhoneCall, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    py::pyobj_handle type_PhoneCallBlocking_Meta{PyType_FromSpec(&type_spec_PhoneCallBlocking_Meta)};
    if (!type_PhoneCallBlocking_Meta)
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), &type_spec_PhoneCallBlocking, nullptr, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_PhoneCallBlocking_Meta.get())) == -1)
    #else
    if (py::register_python_type(module.get(), &type_spec_PhoneCallBlocking, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_PhoneCallBlocking_Meta.get())) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), &type_spec_PhoneCallHistoryEntry, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), &type_spec_PhoneCallHistoryEntry, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), &type_spec_PhoneCallHistoryEntryAddress, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), &type_spec_PhoneCallHistoryEntryAddress, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), &type_spec_PhoneCallHistoryEntryQueryOptions, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), &type_spec_PhoneCallHistoryEntryQueryOptions, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), &type_spec_PhoneCallHistoryEntryReader, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), &type_spec_PhoneCallHistoryEntryReader, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), &type_spec_PhoneCallHistoryManager, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), &type_spec_PhoneCallHistoryManager, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), &type_spec_PhoneCallHistoryManagerForUser, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), &type_spec_PhoneCallHistoryManagerForUser, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), &type_spec_PhoneCallHistoryStore, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), &type_spec_PhoneCallHistoryStore, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), &type_spec_PhoneCallInfo, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), &type_spec_PhoneCallInfo, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    py::pyobj_handle type_PhoneCallManager_Meta{PyType_FromSpec(&type_spec_PhoneCallManager_Meta)};
    if (!type_PhoneCallManager_Meta)
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), &type_spec_PhoneCallManager, nullptr, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_PhoneCallManager_Meta.get())) == -1)
    #else
    if (py::register_python_type(module.get(), &type_spec_PhoneCallManager, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_PhoneCallManager_Meta.get())) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), &type_spec_PhoneCallStore, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), &type_spec_PhoneCallStore, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), &type_spec_PhoneCallVideoCapabilities, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), &type_spec_PhoneCallVideoCapabilities, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), &type_spec_PhoneCallVideoCapabilitiesManager, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), &type_spec_PhoneCallVideoCapabilitiesManager, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), &type_spec_PhoneCallsResult, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), &type_spec_PhoneCallsResult, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), &type_spec_PhoneDialOptions, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), &type_spec_PhoneDialOptions, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), &type_spec_PhoneLine, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), &type_spec_PhoneLine, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), &type_spec_PhoneLineCellularDetails, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), &type_spec_PhoneLineCellularDetails, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), &type_spec_PhoneLineConfiguration, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), &type_spec_PhoneLineConfiguration, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), &type_spec_PhoneLineDialResult, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), &type_spec_PhoneLineDialResult, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), &type_spec_PhoneLineTransportDevice, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), &type_spec_PhoneLineTransportDevice, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), &type_spec_PhoneLineWatcher, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), &type_spec_PhoneLineWatcher, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), &type_spec_PhoneLineWatcherEventArgs, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), &type_spec_PhoneLineWatcherEventArgs, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), &type_spec_PhoneVoicemail, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), &type_spec_PhoneVoicemail, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), &type_spec_VoipCallCoordinator, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), &type_spec_VoipCallCoordinator, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), &type_spec_VoipPhoneCall, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), &type_spec_VoipPhoneCall, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }


    return module.detach();
}
