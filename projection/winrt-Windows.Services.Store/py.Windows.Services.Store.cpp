// WARNING: Please don't edit this file. It was generated by Python/WinRT v2.0.0-beta.2

#include "py.Windows.Services.Store.h"


namespace py::cpp::Windows::Services::Store
{
    // ----- StoreAcquireLicenseResult class --------------------

    static PyObject* _new_StoreAcquireLicenseResult(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Services::Store::StoreAcquireLicenseResult>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Services::Store::StoreAcquireLicenseResult>::type_name);
        return nullptr;
    }

    static void _dealloc_StoreAcquireLicenseResult(py::wrapper::Windows::Services::Store::StoreAcquireLicenseResult* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* StoreAcquireLicenseResult_get_ExtendedError(py::wrapper::Windows::Services::Store::StoreAcquireLicenseResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreAcquireLicenseResult", L"ExtendedError"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ExtendedError());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreAcquireLicenseResult_get_StorePackageLicense(py::wrapper::Windows::Services::Store::StoreAcquireLicenseResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreAcquireLicenseResult", L"StorePackageLicense"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.StorePackageLicense());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_StoreAcquireLicenseResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Services::Store::StoreAcquireLicenseResult>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_StoreAcquireLicenseResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Services::Store::StoreAcquireLicenseResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StoreAcquireLicenseResult[] = {
        { "_assign_array_", _assign_array_StoreAcquireLicenseResult, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_StoreAcquireLicenseResult), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_StoreAcquireLicenseResult[] = {
        { "extended_error", reinterpret_cast<getter>(StoreAcquireLicenseResult_get_ExtendedError), nullptr, nullptr, nullptr },
        { "store_package_license", reinterpret_cast<getter>(StoreAcquireLicenseResult_get_StorePackageLicense), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_StoreAcquireLicenseResult[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_StoreAcquireLicenseResult) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_StoreAcquireLicenseResult) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_StoreAcquireLicenseResult) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_StoreAcquireLicenseResult) },
        { },
    };

    static PyType_Spec type_spec_StoreAcquireLicenseResult =
    {
        "winrt._winrt_windows_services_store.StoreAcquireLicenseResult",
        sizeof(py::wrapper::Windows::Services::Store::StoreAcquireLicenseResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StoreAcquireLicenseResult
    };

    // ----- StoreAppLicense class --------------------

    static PyObject* _new_StoreAppLicense(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Services::Store::StoreAppLicense>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Services::Store::StoreAppLicense>::type_name);
        return nullptr;
    }

    static void _dealloc_StoreAppLicense(py::wrapper::Windows::Services::Store::StoreAppLicense* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* StoreAppLicense_get_AddOnLicenses(py::wrapper::Windows::Services::Store::StoreAppLicense* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreAppLicense", L"AddOnLicenses"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AddOnLicenses());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreAppLicense_get_ExpirationDate(py::wrapper::Windows::Services::Store::StoreAppLicense* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreAppLicense", L"ExpirationDate"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ExpirationDate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreAppLicense_get_ExtendedJsonData(py::wrapper::Windows::Services::Store::StoreAppLicense* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreAppLicense", L"ExtendedJsonData"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ExtendedJsonData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreAppLicense_get_IsActive(py::wrapper::Windows::Services::Store::StoreAppLicense* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreAppLicense", L"IsActive"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsActive());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreAppLicense_get_IsTrial(py::wrapper::Windows::Services::Store::StoreAppLicense* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreAppLicense", L"IsTrial"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsTrial());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreAppLicense_get_IsTrialOwnedByThisUser(py::wrapper::Windows::Services::Store::StoreAppLicense* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreAppLicense", L"IsTrialOwnedByThisUser"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsTrialOwnedByThisUser());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreAppLicense_get_SkuStoreId(py::wrapper::Windows::Services::Store::StoreAppLicense* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreAppLicense", L"SkuStoreId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SkuStoreId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreAppLicense_get_TrialTimeRemaining(py::wrapper::Windows::Services::Store::StoreAppLicense* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreAppLicense", L"TrialTimeRemaining"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TrialTimeRemaining());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreAppLicense_get_TrialUniqueId(py::wrapper::Windows::Services::Store::StoreAppLicense* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreAppLicense", L"TrialUniqueId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TrialUniqueId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreAppLicense_get_IsDiscLicense(py::wrapper::Windows::Services::Store::StoreAppLicense* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreAppLicense", L"IsDiscLicense"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsDiscLicense());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_StoreAppLicense(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Services::Store::StoreAppLicense>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_StoreAppLicense(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Services::Store::StoreAppLicense>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StoreAppLicense[] = {
        { "_assign_array_", _assign_array_StoreAppLicense, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_StoreAppLicense), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_StoreAppLicense[] = {
        { "add_on_licenses", reinterpret_cast<getter>(StoreAppLicense_get_AddOnLicenses), nullptr, nullptr, nullptr },
        { "expiration_date", reinterpret_cast<getter>(StoreAppLicense_get_ExpirationDate), nullptr, nullptr, nullptr },
        { "extended_json_data", reinterpret_cast<getter>(StoreAppLicense_get_ExtendedJsonData), nullptr, nullptr, nullptr },
        { "is_active", reinterpret_cast<getter>(StoreAppLicense_get_IsActive), nullptr, nullptr, nullptr },
        { "is_trial", reinterpret_cast<getter>(StoreAppLicense_get_IsTrial), nullptr, nullptr, nullptr },
        { "is_trial_owned_by_this_user", reinterpret_cast<getter>(StoreAppLicense_get_IsTrialOwnedByThisUser), nullptr, nullptr, nullptr },
        { "sku_store_id", reinterpret_cast<getter>(StoreAppLicense_get_SkuStoreId), nullptr, nullptr, nullptr },
        { "trial_time_remaining", reinterpret_cast<getter>(StoreAppLicense_get_TrialTimeRemaining), nullptr, nullptr, nullptr },
        { "trial_unique_id", reinterpret_cast<getter>(StoreAppLicense_get_TrialUniqueId), nullptr, nullptr, nullptr },
        { "is_disc_license", reinterpret_cast<getter>(StoreAppLicense_get_IsDiscLicense), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_StoreAppLicense[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_StoreAppLicense) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_StoreAppLicense) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_StoreAppLicense) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_StoreAppLicense) },
        { },
    };

    static PyType_Spec type_spec_StoreAppLicense =
    {
        "winrt._winrt_windows_services_store.StoreAppLicense",
        sizeof(py::wrapper::Windows::Services::Store::StoreAppLicense),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StoreAppLicense
    };

    // ----- StoreAvailability class --------------------

    static PyObject* _new_StoreAvailability(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Services::Store::StoreAvailability>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Services::Store::StoreAvailability>::type_name);
        return nullptr;
    }

    static void _dealloc_StoreAvailability(py::wrapper::Windows::Services::Store::StoreAvailability* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* StoreAvailability_RequestPurchaseAsync(py::wrapper::Windows::Services::Store::StoreAvailability* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Services.Store.StoreAvailability", L"RequestPurchaseAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.RequestPurchaseAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Services.Store.StoreAvailability", L"RequestPurchaseAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Services::Store::StorePurchaseProperties>(args, 0);

                return py::convert(self->obj.RequestPurchaseAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StoreAvailability_get_EndDate(py::wrapper::Windows::Services::Store::StoreAvailability* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreAvailability", L"EndDate"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.EndDate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreAvailability_get_ExtendedJsonData(py::wrapper::Windows::Services::Store::StoreAvailability* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreAvailability", L"ExtendedJsonData"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ExtendedJsonData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreAvailability_get_Price(py::wrapper::Windows::Services::Store::StoreAvailability* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreAvailability", L"Price"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Price());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreAvailability_get_StoreId(py::wrapper::Windows::Services::Store::StoreAvailability* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreAvailability", L"StoreId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.StoreId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_StoreAvailability(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Services::Store::StoreAvailability>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_StoreAvailability(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Services::Store::StoreAvailability>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StoreAvailability[] = {
        { "request_purchase_async", reinterpret_cast<PyCFunction>(StoreAvailability_RequestPurchaseAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_StoreAvailability, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_StoreAvailability), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_StoreAvailability[] = {
        { "end_date", reinterpret_cast<getter>(StoreAvailability_get_EndDate), nullptr, nullptr, nullptr },
        { "extended_json_data", reinterpret_cast<getter>(StoreAvailability_get_ExtendedJsonData), nullptr, nullptr, nullptr },
        { "price", reinterpret_cast<getter>(StoreAvailability_get_Price), nullptr, nullptr, nullptr },
        { "store_id", reinterpret_cast<getter>(StoreAvailability_get_StoreId), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_StoreAvailability[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_StoreAvailability) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_StoreAvailability) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_StoreAvailability) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_StoreAvailability) },
        { },
    };

    static PyType_Spec type_spec_StoreAvailability =
    {
        "winrt._winrt_windows_services_store.StoreAvailability",
        sizeof(py::wrapper::Windows::Services::Store::StoreAvailability),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StoreAvailability
    };

    // ----- StoreCanAcquireLicenseResult class --------------------

    static PyObject* _new_StoreCanAcquireLicenseResult(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Services::Store::StoreCanAcquireLicenseResult>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Services::Store::StoreCanAcquireLicenseResult>::type_name);
        return nullptr;
    }

    static void _dealloc_StoreCanAcquireLicenseResult(py::wrapper::Windows::Services::Store::StoreCanAcquireLicenseResult* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* StoreCanAcquireLicenseResult_get_ExtendedError(py::wrapper::Windows::Services::Store::StoreCanAcquireLicenseResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreCanAcquireLicenseResult", L"ExtendedError"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ExtendedError());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreCanAcquireLicenseResult_get_LicensableSku(py::wrapper::Windows::Services::Store::StoreCanAcquireLicenseResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreCanAcquireLicenseResult", L"LicensableSku"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.LicensableSku());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreCanAcquireLicenseResult_get_Status(py::wrapper::Windows::Services::Store::StoreCanAcquireLicenseResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreCanAcquireLicenseResult", L"Status"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_StoreCanAcquireLicenseResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Services::Store::StoreCanAcquireLicenseResult>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_StoreCanAcquireLicenseResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Services::Store::StoreCanAcquireLicenseResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StoreCanAcquireLicenseResult[] = {
        { "_assign_array_", _assign_array_StoreCanAcquireLicenseResult, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_StoreCanAcquireLicenseResult), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_StoreCanAcquireLicenseResult[] = {
        { "extended_error", reinterpret_cast<getter>(StoreCanAcquireLicenseResult_get_ExtendedError), nullptr, nullptr, nullptr },
        { "licensable_sku", reinterpret_cast<getter>(StoreCanAcquireLicenseResult_get_LicensableSku), nullptr, nullptr, nullptr },
        { "status", reinterpret_cast<getter>(StoreCanAcquireLicenseResult_get_Status), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_StoreCanAcquireLicenseResult[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_StoreCanAcquireLicenseResult) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_StoreCanAcquireLicenseResult) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_StoreCanAcquireLicenseResult) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_StoreCanAcquireLicenseResult) },
        { },
    };

    static PyType_Spec type_spec_StoreCanAcquireLicenseResult =
    {
        "winrt._winrt_windows_services_store.StoreCanAcquireLicenseResult",
        sizeof(py::wrapper::Windows::Services::Store::StoreCanAcquireLicenseResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StoreCanAcquireLicenseResult
    };

    // ----- StoreCollectionData class --------------------

    static PyObject* _new_StoreCollectionData(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Services::Store::StoreCollectionData>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Services::Store::StoreCollectionData>::type_name);
        return nullptr;
    }

    static void _dealloc_StoreCollectionData(py::wrapper::Windows::Services::Store::StoreCollectionData* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* StoreCollectionData_get_AcquiredDate(py::wrapper::Windows::Services::Store::StoreCollectionData* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreCollectionData", L"AcquiredDate"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AcquiredDate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreCollectionData_get_CampaignId(py::wrapper::Windows::Services::Store::StoreCollectionData* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreCollectionData", L"CampaignId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CampaignId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreCollectionData_get_DeveloperOfferId(py::wrapper::Windows::Services::Store::StoreCollectionData* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreCollectionData", L"DeveloperOfferId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DeveloperOfferId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreCollectionData_get_EndDate(py::wrapper::Windows::Services::Store::StoreCollectionData* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreCollectionData", L"EndDate"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.EndDate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreCollectionData_get_ExtendedJsonData(py::wrapper::Windows::Services::Store::StoreCollectionData* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreCollectionData", L"ExtendedJsonData"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ExtendedJsonData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreCollectionData_get_IsTrial(py::wrapper::Windows::Services::Store::StoreCollectionData* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreCollectionData", L"IsTrial"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsTrial());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreCollectionData_get_StartDate(py::wrapper::Windows::Services::Store::StoreCollectionData* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreCollectionData", L"StartDate"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.StartDate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreCollectionData_get_TrialTimeRemaining(py::wrapper::Windows::Services::Store::StoreCollectionData* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreCollectionData", L"TrialTimeRemaining"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TrialTimeRemaining());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_StoreCollectionData(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Services::Store::StoreCollectionData>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_StoreCollectionData(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Services::Store::StoreCollectionData>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StoreCollectionData[] = {
        { "_assign_array_", _assign_array_StoreCollectionData, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_StoreCollectionData), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_StoreCollectionData[] = {
        { "acquired_date", reinterpret_cast<getter>(StoreCollectionData_get_AcquiredDate), nullptr, nullptr, nullptr },
        { "campaign_id", reinterpret_cast<getter>(StoreCollectionData_get_CampaignId), nullptr, nullptr, nullptr },
        { "developer_offer_id", reinterpret_cast<getter>(StoreCollectionData_get_DeveloperOfferId), nullptr, nullptr, nullptr },
        { "end_date", reinterpret_cast<getter>(StoreCollectionData_get_EndDate), nullptr, nullptr, nullptr },
        { "extended_json_data", reinterpret_cast<getter>(StoreCollectionData_get_ExtendedJsonData), nullptr, nullptr, nullptr },
        { "is_trial", reinterpret_cast<getter>(StoreCollectionData_get_IsTrial), nullptr, nullptr, nullptr },
        { "start_date", reinterpret_cast<getter>(StoreCollectionData_get_StartDate), nullptr, nullptr, nullptr },
        { "trial_time_remaining", reinterpret_cast<getter>(StoreCollectionData_get_TrialTimeRemaining), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_StoreCollectionData[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_StoreCollectionData) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_StoreCollectionData) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_StoreCollectionData) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_StoreCollectionData) },
        { },
    };

    static PyType_Spec type_spec_StoreCollectionData =
    {
        "winrt._winrt_windows_services_store.StoreCollectionData",
        sizeof(py::wrapper::Windows::Services::Store::StoreCollectionData),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StoreCollectionData
    };

    // ----- StoreConsumableResult class --------------------

    static PyObject* _new_StoreConsumableResult(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Services::Store::StoreConsumableResult>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Services::Store::StoreConsumableResult>::type_name);
        return nullptr;
    }

    static void _dealloc_StoreConsumableResult(py::wrapper::Windows::Services::Store::StoreConsumableResult* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* StoreConsumableResult_get_BalanceRemaining(py::wrapper::Windows::Services::Store::StoreConsumableResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreConsumableResult", L"BalanceRemaining"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.BalanceRemaining());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreConsumableResult_get_ExtendedError(py::wrapper::Windows::Services::Store::StoreConsumableResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreConsumableResult", L"ExtendedError"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ExtendedError());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreConsumableResult_get_Status(py::wrapper::Windows::Services::Store::StoreConsumableResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreConsumableResult", L"Status"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreConsumableResult_get_TrackingId(py::wrapper::Windows::Services::Store::StoreConsumableResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreConsumableResult", L"TrackingId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TrackingId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_StoreConsumableResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Services::Store::StoreConsumableResult>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_StoreConsumableResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Services::Store::StoreConsumableResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StoreConsumableResult[] = {
        { "_assign_array_", _assign_array_StoreConsumableResult, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_StoreConsumableResult), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_StoreConsumableResult[] = {
        { "balance_remaining", reinterpret_cast<getter>(StoreConsumableResult_get_BalanceRemaining), nullptr, nullptr, nullptr },
        { "extended_error", reinterpret_cast<getter>(StoreConsumableResult_get_ExtendedError), nullptr, nullptr, nullptr },
        { "status", reinterpret_cast<getter>(StoreConsumableResult_get_Status), nullptr, nullptr, nullptr },
        { "tracking_id", reinterpret_cast<getter>(StoreConsumableResult_get_TrackingId), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_StoreConsumableResult[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_StoreConsumableResult) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_StoreConsumableResult) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_StoreConsumableResult) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_StoreConsumableResult) },
        { },
    };

    static PyType_Spec type_spec_StoreConsumableResult =
    {
        "winrt._winrt_windows_services_store.StoreConsumableResult",
        sizeof(py::wrapper::Windows::Services::Store::StoreConsumableResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StoreConsumableResult
    };

    // ----- StoreContext class --------------------

    static PyObject* _new_StoreContext(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Services::Store::StoreContext>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Services::Store::StoreContext>::type_name);
        return nullptr;
    }

    static void _dealloc_StoreContext(py::wrapper::Windows::Services::Store::StoreContext* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* StoreContext_AcquireStoreLicenseForOptionalPackageAsync(py::wrapper::Windows::Services::Store::StoreContext* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Services.Store.StoreContext", L"AcquireStoreLicenseForOptionalPackageAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Package>(args, 0);

                return py::convert(self->obj.AcquireStoreLicenseForOptionalPackageAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StoreContext_CanAcquireStoreLicenseAsync(py::wrapper::Windows::Services::Store::StoreContext* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Services.Store.StoreContext", L"CanAcquireStoreLicenseAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.CanAcquireStoreLicenseAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StoreContext_CanAcquireStoreLicenseForOptionalPackageAsync(py::wrapper::Windows::Services::Store::StoreContext* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Services.Store.StoreContext", L"CanAcquireStoreLicenseForOptionalPackageAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Package>(args, 0);

                return py::convert(self->obj.CanAcquireStoreLicenseForOptionalPackageAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StoreContext_DownloadAndInstallStorePackagesAsync(py::wrapper::Windows::Services::Store::StoreContext* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Services.Store.StoreContext", L"DownloadAndInstallStorePackagesAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 0);

                return py::convert(self->obj.DownloadAndInstallStorePackagesAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StoreContext_FindStoreProductForPackageAsync(py::wrapper::Windows::Services::Store::StoreContext* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Services.Store.StoreContext", L"FindStoreProductForPackageAsync", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::ApplicationModel::Package>(args, 1);

                return py::convert(self->obj.FindStoreProductForPackageAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StoreContext_GetAppAndOptionalStorePackageUpdatesAsync(py::wrapper::Windows::Services::Store::StoreContext* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Services.Store.StoreContext", L"GetAppAndOptionalStorePackageUpdatesAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetAppAndOptionalStorePackageUpdatesAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StoreContext_GetAppLicenseAsync(py::wrapper::Windows::Services::Store::StoreContext* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Services.Store.StoreContext", L"GetAppLicenseAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetAppLicenseAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StoreContext_GetAssociatedStoreProductsAsync(py::wrapper::Windows::Services::Store::StoreContext* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Services.Store.StoreContext", L"GetAssociatedStoreProductsAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 0);

                return py::convert(self->obj.GetAssociatedStoreProductsAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StoreContext_GetAssociatedStoreProductsByInAppOfferTokenAsync(py::wrapper::Windows::Services::Store::StoreContext* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Services.Store.StoreContext", L"GetAssociatedStoreProductsByInAppOfferTokenAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 0);

                return py::convert(self->obj.GetAssociatedStoreProductsByInAppOfferTokenAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StoreContext_GetAssociatedStoreProductsWithPagingAsync(py::wrapper::Windows::Services::Store::StoreContext* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Services.Store.StoreContext", L"GetAssociatedStoreProductsWithPagingAsync", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);

                return py::convert(self->obj.GetAssociatedStoreProductsWithPagingAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StoreContext_GetAssociatedStoreQueueItemsAsync(py::wrapper::Windows::Services::Store::StoreContext* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Services.Store.StoreContext", L"GetAssociatedStoreQueueItemsAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetAssociatedStoreQueueItemsAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StoreContext_GetConsumableBalanceRemainingAsync(py::wrapper::Windows::Services::Store::StoreContext* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Services.Store.StoreContext", L"GetConsumableBalanceRemainingAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.GetConsumableBalanceRemainingAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StoreContext_GetCustomerCollectionsIdAsync(py::wrapper::Windows::Services::Store::StoreContext* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Services.Store.StoreContext", L"GetCustomerCollectionsIdAsync", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(self->obj.GetCustomerCollectionsIdAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StoreContext_GetCustomerPurchaseIdAsync(py::wrapper::Windows::Services::Store::StoreContext* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Services.Store.StoreContext", L"GetCustomerPurchaseIdAsync", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(self->obj.GetCustomerPurchaseIdAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StoreContext_GetDefault(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Services.Store.StoreContext", L"GetDefault", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::Services::Store::StoreContext::GetDefault());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StoreContext_GetForUser(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Services.Store.StoreContext", L"GetForUser", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::System::User>(args, 0);

                return py::convert(winrt::Windows::Services::Store::StoreContext::GetForUser(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StoreContext_GetStoreProductForCurrentAppAsync(py::wrapper::Windows::Services::Store::StoreContext* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Services.Store.StoreContext", L"GetStoreProductForCurrentAppAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetStoreProductForCurrentAppAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StoreContext_GetStoreProductsAsync(py::wrapper::Windows::Services::Store::StoreContext* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Services.Store.StoreContext", L"GetStoreProductsAsync", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 1);

                return py::convert(self->obj.GetStoreProductsAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Services.Store.StoreContext", L"GetStoreProductsAsync", 3))
            {
                py::set_arg_count_version_error(3);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Services::Store::StoreProductOptions>(args, 2);

                return py::convert(self->obj.GetStoreProductsAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StoreContext_GetStoreQueueItemsAsync(py::wrapper::Windows::Services::Store::StoreContext* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Services.Store.StoreContext", L"GetStoreQueueItemsAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 0);

                return py::convert(self->obj.GetStoreQueueItemsAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StoreContext_GetUserCollectionAsync(py::wrapper::Windows::Services::Store::StoreContext* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Services.Store.StoreContext", L"GetUserCollectionAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 0);

                return py::convert(self->obj.GetUserCollectionAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StoreContext_GetUserCollectionWithPagingAsync(py::wrapper::Windows::Services::Store::StoreContext* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Services.Store.StoreContext", L"GetUserCollectionWithPagingAsync", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);

                return py::convert(self->obj.GetUserCollectionWithPagingAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StoreContext_GetUserPurchaseHistoryAsync(py::wrapper::Windows::Services::Store::StoreContext* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Services.Store.StoreContext", L"GetUserPurchaseHistoryAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 0);

                return py::convert(self->obj.GetUserPurchaseHistoryAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StoreContext_ReportConsumableFulfillmentAsync(py::wrapper::Windows::Services::Store::StoreContext* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Services.Store.StoreContext", L"ReportConsumableFulfillmentAsync", 3))
            {
                py::set_arg_count_version_error(3);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);
                auto param2 = py::convert_to<winrt::guid>(args, 2);

                return py::convert(self->obj.ReportConsumableFulfillmentAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StoreContext_RequestDownloadAndInstallStorePackageUpdatesAsync(py::wrapper::Windows::Services::Store::StoreContext* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Services.Store.StoreContext", L"RequestDownloadAndInstallStorePackageUpdatesAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Services::Store::StorePackageUpdate>>(args, 0);

                return py::convert(self->obj.RequestDownloadAndInstallStorePackageUpdatesAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StoreContext_RequestDownloadAndInstallStorePackagesAsync(py::wrapper::Windows::Services::Store::StoreContext* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Services.Store.StoreContext", L"RequestDownloadAndInstallStorePackagesAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 0);

                return py::convert(self->obj.RequestDownloadAndInstallStorePackagesAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Services.Store.StoreContext", L"RequestDownloadAndInstallStorePackagesAsync", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Services::Store::StorePackageInstallOptions>(args, 1);

                return py::convert(self->obj.RequestDownloadAndInstallStorePackagesAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StoreContext_RequestDownloadStorePackageUpdatesAsync(py::wrapper::Windows::Services::Store::StoreContext* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Services.Store.StoreContext", L"RequestDownloadStorePackageUpdatesAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Services::Store::StorePackageUpdate>>(args, 0);

                return py::convert(self->obj.RequestDownloadStorePackageUpdatesAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StoreContext_RequestPurchaseAsync(py::wrapper::Windows::Services::Store::StoreContext* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Services.Store.StoreContext", L"RequestPurchaseAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.RequestPurchaseAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Services.Store.StoreContext", L"RequestPurchaseAsync", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Services::Store::StorePurchaseProperties>(args, 1);

                return py::convert(self->obj.RequestPurchaseAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StoreContext_RequestPurchaseByInAppOfferTokenAsync(py::wrapper::Windows::Services::Store::StoreContext* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Services.Store.StoreContext", L"RequestPurchaseByInAppOfferTokenAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.RequestPurchaseByInAppOfferTokenAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StoreContext_RequestRateAndReviewAppAsync(py::wrapper::Windows::Services::Store::StoreContext* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Services.Store.StoreContext", L"RequestRateAndReviewAppAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.RequestRateAndReviewAppAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StoreContext_RequestUninstallStorePackageAsync(py::wrapper::Windows::Services::Store::StoreContext* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Services.Store.StoreContext", L"RequestUninstallStorePackageAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Package>(args, 0);

                return py::convert(self->obj.RequestUninstallStorePackageAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StoreContext_RequestUninstallStorePackageByStoreIdAsync(py::wrapper::Windows::Services::Store::StoreContext* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Services.Store.StoreContext", L"RequestUninstallStorePackageByStoreIdAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.RequestUninstallStorePackageByStoreIdAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StoreContext_SetInstallOrderForAssociatedStoreQueueItemsAsync(py::wrapper::Windows::Services::Store::StoreContext* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Services.Store.StoreContext", L"SetInstallOrderForAssociatedStoreQueueItemsAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Services::Store::StoreQueueItem>>(args, 0);

                return py::convert(self->obj.SetInstallOrderForAssociatedStoreQueueItemsAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StoreContext_TrySilentDownloadAndInstallStorePackageUpdatesAsync(py::wrapper::Windows::Services::Store::StoreContext* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Services.Store.StoreContext", L"TrySilentDownloadAndInstallStorePackageUpdatesAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Services::Store::StorePackageUpdate>>(args, 0);

                return py::convert(self->obj.TrySilentDownloadAndInstallStorePackageUpdatesAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StoreContext_TrySilentDownloadStorePackageUpdatesAsync(py::wrapper::Windows::Services::Store::StoreContext* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Services.Store.StoreContext", L"TrySilentDownloadStorePackageUpdatesAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Services::Store::StorePackageUpdate>>(args, 0);

                return py::convert(self->obj.TrySilentDownloadStorePackageUpdatesAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StoreContext_UninstallStorePackageAsync(py::wrapper::Windows::Services::Store::StoreContext* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Services.Store.StoreContext", L"UninstallStorePackageAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Package>(args, 0);

                return py::convert(self->obj.UninstallStorePackageAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StoreContext_UninstallStorePackageByStoreIdAsync(py::wrapper::Windows::Services::Store::StoreContext* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Services.Store.StoreContext", L"UninstallStorePackageByStoreIdAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.UninstallStorePackageByStoreIdAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StoreContext_get_User(py::wrapper::Windows::Services::Store::StoreContext* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreContext", L"User"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.User());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreContext_get_CanSilentlyDownloadStorePackageUpdates(py::wrapper::Windows::Services::Store::StoreContext* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreContext", L"CanSilentlyDownloadStorePackageUpdates"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CanSilentlyDownloadStorePackageUpdates());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreContext_add_OfflineLicensesChanged(py::wrapper::Windows::Services::Store::StoreContext* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Services.Store.StoreContext", L"OfflineLicensesChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Services::Store::StoreContext, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.OfflineLicensesChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreContext_remove_OfflineLicensesChanged(py::wrapper::Windows::Services::Store::StoreContext* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Services.Store.StoreContext", L"OfflineLicensesChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.OfflineLicensesChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_StoreContext(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Services::Store::StoreContext>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_StoreContext(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Services::Store::StoreContext>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StoreContext[] = {
        { "acquire_store_license_for_optional_package_async", reinterpret_cast<PyCFunction>(StoreContext_AcquireStoreLicenseForOptionalPackageAsync), METH_VARARGS, nullptr },
        { "can_acquire_store_license_async", reinterpret_cast<PyCFunction>(StoreContext_CanAcquireStoreLicenseAsync), METH_VARARGS, nullptr },
        { "can_acquire_store_license_for_optional_package_async", reinterpret_cast<PyCFunction>(StoreContext_CanAcquireStoreLicenseForOptionalPackageAsync), METH_VARARGS, nullptr },
        { "download_and_install_store_packages_async", reinterpret_cast<PyCFunction>(StoreContext_DownloadAndInstallStorePackagesAsync), METH_VARARGS, nullptr },
        { "find_store_product_for_package_async", reinterpret_cast<PyCFunction>(StoreContext_FindStoreProductForPackageAsync), METH_VARARGS, nullptr },
        { "get_app_and_optional_store_package_updates_async", reinterpret_cast<PyCFunction>(StoreContext_GetAppAndOptionalStorePackageUpdatesAsync), METH_VARARGS, nullptr },
        { "get_app_license_async", reinterpret_cast<PyCFunction>(StoreContext_GetAppLicenseAsync), METH_VARARGS, nullptr },
        { "get_associated_store_products_async", reinterpret_cast<PyCFunction>(StoreContext_GetAssociatedStoreProductsAsync), METH_VARARGS, nullptr },
        { "get_associated_store_products_by_in_app_offer_token_async", reinterpret_cast<PyCFunction>(StoreContext_GetAssociatedStoreProductsByInAppOfferTokenAsync), METH_VARARGS, nullptr },
        { "get_associated_store_products_with_paging_async", reinterpret_cast<PyCFunction>(StoreContext_GetAssociatedStoreProductsWithPagingAsync), METH_VARARGS, nullptr },
        { "get_associated_store_queue_items_async", reinterpret_cast<PyCFunction>(StoreContext_GetAssociatedStoreQueueItemsAsync), METH_VARARGS, nullptr },
        { "get_consumable_balance_remaining_async", reinterpret_cast<PyCFunction>(StoreContext_GetConsumableBalanceRemainingAsync), METH_VARARGS, nullptr },
        { "get_customer_collections_id_async", reinterpret_cast<PyCFunction>(StoreContext_GetCustomerCollectionsIdAsync), METH_VARARGS, nullptr },
        { "get_customer_purchase_id_async", reinterpret_cast<PyCFunction>(StoreContext_GetCustomerPurchaseIdAsync), METH_VARARGS, nullptr },
        { "get_store_product_for_current_app_async", reinterpret_cast<PyCFunction>(StoreContext_GetStoreProductForCurrentAppAsync), METH_VARARGS, nullptr },
        { "get_store_products_async", reinterpret_cast<PyCFunction>(StoreContext_GetStoreProductsAsync), METH_VARARGS, nullptr },
        { "get_store_queue_items_async", reinterpret_cast<PyCFunction>(StoreContext_GetStoreQueueItemsAsync), METH_VARARGS, nullptr },
        { "get_user_collection_async", reinterpret_cast<PyCFunction>(StoreContext_GetUserCollectionAsync), METH_VARARGS, nullptr },
        { "get_user_collection_with_paging_async", reinterpret_cast<PyCFunction>(StoreContext_GetUserCollectionWithPagingAsync), METH_VARARGS, nullptr },
        { "get_user_purchase_history_async", reinterpret_cast<PyCFunction>(StoreContext_GetUserPurchaseHistoryAsync), METH_VARARGS, nullptr },
        { "report_consumable_fulfillment_async", reinterpret_cast<PyCFunction>(StoreContext_ReportConsumableFulfillmentAsync), METH_VARARGS, nullptr },
        { "request_download_and_install_store_package_updates_async", reinterpret_cast<PyCFunction>(StoreContext_RequestDownloadAndInstallStorePackageUpdatesAsync), METH_VARARGS, nullptr },
        { "request_download_and_install_store_packages_async", reinterpret_cast<PyCFunction>(StoreContext_RequestDownloadAndInstallStorePackagesAsync), METH_VARARGS, nullptr },
        { "request_download_store_package_updates_async", reinterpret_cast<PyCFunction>(StoreContext_RequestDownloadStorePackageUpdatesAsync), METH_VARARGS, nullptr },
        { "request_purchase_async", reinterpret_cast<PyCFunction>(StoreContext_RequestPurchaseAsync), METH_VARARGS, nullptr },
        { "request_purchase_by_in_app_offer_token_async", reinterpret_cast<PyCFunction>(StoreContext_RequestPurchaseByInAppOfferTokenAsync), METH_VARARGS, nullptr },
        { "request_rate_and_review_app_async", reinterpret_cast<PyCFunction>(StoreContext_RequestRateAndReviewAppAsync), METH_VARARGS, nullptr },
        { "request_uninstall_store_package_async", reinterpret_cast<PyCFunction>(StoreContext_RequestUninstallStorePackageAsync), METH_VARARGS, nullptr },
        { "request_uninstall_store_package_by_store_id_async", reinterpret_cast<PyCFunction>(StoreContext_RequestUninstallStorePackageByStoreIdAsync), METH_VARARGS, nullptr },
        { "set_install_order_for_associated_store_queue_items_async", reinterpret_cast<PyCFunction>(StoreContext_SetInstallOrderForAssociatedStoreQueueItemsAsync), METH_VARARGS, nullptr },
        { "try_silent_download_and_install_store_package_updates_async", reinterpret_cast<PyCFunction>(StoreContext_TrySilentDownloadAndInstallStorePackageUpdatesAsync), METH_VARARGS, nullptr },
        { "try_silent_download_store_package_updates_async", reinterpret_cast<PyCFunction>(StoreContext_TrySilentDownloadStorePackageUpdatesAsync), METH_VARARGS, nullptr },
        { "uninstall_store_package_async", reinterpret_cast<PyCFunction>(StoreContext_UninstallStorePackageAsync), METH_VARARGS, nullptr },
        { "uninstall_store_package_by_store_id_async", reinterpret_cast<PyCFunction>(StoreContext_UninstallStorePackageByStoreIdAsync), METH_VARARGS, nullptr },
        { "add_offline_licenses_changed", reinterpret_cast<PyCFunction>(StoreContext_add_OfflineLicensesChanged), METH_O, nullptr },
        { "remove_offline_licenses_changed", reinterpret_cast<PyCFunction>(StoreContext_remove_OfflineLicensesChanged), METH_O, nullptr },
        { "_assign_array_", _assign_array_StoreContext, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_StoreContext), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_StoreContext[] = {
        { "user", reinterpret_cast<getter>(StoreContext_get_User), nullptr, nullptr, nullptr },
        { "can_silently_download_store_package_updates", reinterpret_cast<getter>(StoreContext_get_CanSilentlyDownloadStorePackageUpdates), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_StoreContext[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_StoreContext) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_StoreContext) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_StoreContext) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_StoreContext) },
        { },
    };

    static PyType_Spec type_spec_StoreContext =
    {
        "winrt._winrt_windows_services_store.StoreContext",
        sizeof(py::wrapper::Windows::Services::Store::StoreContext),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StoreContext
    };

    static PyGetSetDef getset_StoreContext_Static[] = {
        { }
    };

    static PyMethodDef methods_StoreContext_Static[] = {
        { "get_default", reinterpret_cast<PyCFunction>(StoreContext_GetDefault), METH_VARARGS, nullptr },
        { "get_for_user", reinterpret_cast<PyCFunction>(StoreContext_GetForUser), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_StoreContext_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_StoreContext_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_StoreContext_Static) },
        { }
    };

    static PyType_Spec type_spec_StoreContext_Static =
    {
        "winrt._winrt_windows_services_store.StoreContext_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_StoreContext_Static
    };

    // ----- StoreImage class --------------------

    static PyObject* _new_StoreImage(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Services::Store::StoreImage>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Services::Store::StoreImage>::type_name);
        return nullptr;
    }

    static void _dealloc_StoreImage(py::wrapper::Windows::Services::Store::StoreImage* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* StoreImage_get_Caption(py::wrapper::Windows::Services::Store::StoreImage* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreImage", L"Caption"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Caption());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreImage_get_Height(py::wrapper::Windows::Services::Store::StoreImage* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreImage", L"Height"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Height());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreImage_get_ImagePurposeTag(py::wrapper::Windows::Services::Store::StoreImage* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreImage", L"ImagePurposeTag"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ImagePurposeTag());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreImage_get_Uri(py::wrapper::Windows::Services::Store::StoreImage* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreImage", L"Uri"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Uri());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreImage_get_Width(py::wrapper::Windows::Services::Store::StoreImage* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreImage", L"Width"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Width());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_StoreImage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Services::Store::StoreImage>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_StoreImage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Services::Store::StoreImage>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StoreImage[] = {
        { "_assign_array_", _assign_array_StoreImage, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_StoreImage), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_StoreImage[] = {
        { "caption", reinterpret_cast<getter>(StoreImage_get_Caption), nullptr, nullptr, nullptr },
        { "height", reinterpret_cast<getter>(StoreImage_get_Height), nullptr, nullptr, nullptr },
        { "image_purpose_tag", reinterpret_cast<getter>(StoreImage_get_ImagePurposeTag), nullptr, nullptr, nullptr },
        { "uri", reinterpret_cast<getter>(StoreImage_get_Uri), nullptr, nullptr, nullptr },
        { "width", reinterpret_cast<getter>(StoreImage_get_Width), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_StoreImage[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_StoreImage) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_StoreImage) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_StoreImage) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_StoreImage) },
        { },
    };

    static PyType_Spec type_spec_StoreImage =
    {
        "winrt._winrt_windows_services_store.StoreImage",
        sizeof(py::wrapper::Windows::Services::Store::StoreImage),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StoreImage
    };

    // ----- StoreLicense class --------------------

    static PyObject* _new_StoreLicense(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Services::Store::StoreLicense>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Services::Store::StoreLicense>::type_name);
        return nullptr;
    }

    static void _dealloc_StoreLicense(py::wrapper::Windows::Services::Store::StoreLicense* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* StoreLicense_get_ExpirationDate(py::wrapper::Windows::Services::Store::StoreLicense* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreLicense", L"ExpirationDate"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ExpirationDate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreLicense_get_ExtendedJsonData(py::wrapper::Windows::Services::Store::StoreLicense* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreLicense", L"ExtendedJsonData"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ExtendedJsonData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreLicense_get_InAppOfferToken(py::wrapper::Windows::Services::Store::StoreLicense* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreLicense", L"InAppOfferToken"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.InAppOfferToken());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreLicense_get_IsActive(py::wrapper::Windows::Services::Store::StoreLicense* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreLicense", L"IsActive"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsActive());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreLicense_get_SkuStoreId(py::wrapper::Windows::Services::Store::StoreLicense* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreLicense", L"SkuStoreId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SkuStoreId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_StoreLicense(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Services::Store::StoreLicense>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_StoreLicense(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Services::Store::StoreLicense>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StoreLicense[] = {
        { "_assign_array_", _assign_array_StoreLicense, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_StoreLicense), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_StoreLicense[] = {
        { "expiration_date", reinterpret_cast<getter>(StoreLicense_get_ExpirationDate), nullptr, nullptr, nullptr },
        { "extended_json_data", reinterpret_cast<getter>(StoreLicense_get_ExtendedJsonData), nullptr, nullptr, nullptr },
        { "in_app_offer_token", reinterpret_cast<getter>(StoreLicense_get_InAppOfferToken), nullptr, nullptr, nullptr },
        { "is_active", reinterpret_cast<getter>(StoreLicense_get_IsActive), nullptr, nullptr, nullptr },
        { "sku_store_id", reinterpret_cast<getter>(StoreLicense_get_SkuStoreId), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_StoreLicense[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_StoreLicense) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_StoreLicense) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_StoreLicense) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_StoreLicense) },
        { },
    };

    static PyType_Spec type_spec_StoreLicense =
    {
        "winrt._winrt_windows_services_store.StoreLicense",
        sizeof(py::wrapper::Windows::Services::Store::StoreLicense),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StoreLicense
    };

    // ----- StorePackageInstallOptions class --------------------

    static PyObject* _new_StorePackageInstallOptions(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Services::Store::StorePackageInstallOptions instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_StorePackageInstallOptions(py::wrapper::Windows::Services::Store::StorePackageInstallOptions* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* StorePackageInstallOptions_get_AllowForcedAppRestart(py::wrapper::Windows::Services::Store::StorePackageInstallOptions* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StorePackageInstallOptions", L"AllowForcedAppRestart"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AllowForcedAppRestart());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StorePackageInstallOptions_put_AllowForcedAppRestart(py::wrapper::Windows::Services::Store::StorePackageInstallOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StorePackageInstallOptions", L"AllowForcedAppRestart"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.AllowForcedAppRestart(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_StorePackageInstallOptions(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Services::Store::StorePackageInstallOptions>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_StorePackageInstallOptions(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Services::Store::StorePackageInstallOptions>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StorePackageInstallOptions[] = {
        { "_assign_array_", _assign_array_StorePackageInstallOptions, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_StorePackageInstallOptions), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_StorePackageInstallOptions[] = {
        { "allow_forced_app_restart", reinterpret_cast<getter>(StorePackageInstallOptions_get_AllowForcedAppRestart), reinterpret_cast<setter>(StorePackageInstallOptions_put_AllowForcedAppRestart), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_StorePackageInstallOptions[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_StorePackageInstallOptions) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_StorePackageInstallOptions) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_StorePackageInstallOptions) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_StorePackageInstallOptions) },
        { },
    };

    static PyType_Spec type_spec_StorePackageInstallOptions =
    {
        "winrt._winrt_windows_services_store.StorePackageInstallOptions",
        sizeof(py::wrapper::Windows::Services::Store::StorePackageInstallOptions),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StorePackageInstallOptions
    };

    // ----- StorePackageLicense class --------------------

    static PyObject* _new_StorePackageLicense(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Services::Store::StorePackageLicense>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Services::Store::StorePackageLicense>::type_name);
        return nullptr;
    }

    static void _dealloc_StorePackageLicense(py::wrapper::Windows::Services::Store::StorePackageLicense* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* StorePackageLicense_Close(py::wrapper::Windows::Services::Store::StorePackageLicense* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Services.Store.StorePackageLicense", L"Close", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorePackageLicense_ReleaseLicense(py::wrapper::Windows::Services::Store::StorePackageLicense* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Services.Store.StorePackageLicense", L"ReleaseLicense", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.ReleaseLicense();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorePackageLicense_get_IsValid(py::wrapper::Windows::Services::Store::StorePackageLicense* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StorePackageLicense", L"IsValid"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsValid());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StorePackageLicense_get_Package(py::wrapper::Windows::Services::Store::StorePackageLicense* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StorePackageLicense", L"Package"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Package());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StorePackageLicense_add_LicenseLost(py::wrapper::Windows::Services::Store::StorePackageLicense* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Services.Store.StorePackageLicense", L"LicenseLost"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Services::Store::StorePackageLicense, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.LicenseLost(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StorePackageLicense_remove_LicenseLost(py::wrapper::Windows::Services::Store::StorePackageLicense* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Services.Store.StorePackageLicense", L"LicenseLost"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.LicenseLost(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_StorePackageLicense(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Services::Store::StorePackageLicense>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_StorePackageLicense(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Services::Store::StorePackageLicense>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_StorePackageLicense(py::wrapper::Windows::Services::Store::StorePackageLicense* self, PyObject* /*unused*/) noexcept
    {
        return Py_NewRef(self);
    }

    static PyObject* _exit_StorePackageLicense(py::wrapper::Windows::Services::Store::StorePackageLicense* self, PyObject* /*unused*/) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StorePackageLicense[] = {
        { "close", reinterpret_cast<PyCFunction>(StorePackageLicense_Close), METH_VARARGS, nullptr },
        { "release_license", reinterpret_cast<PyCFunction>(StorePackageLicense_ReleaseLicense), METH_VARARGS, nullptr },
        { "add_license_lost", reinterpret_cast<PyCFunction>(StorePackageLicense_add_LicenseLost), METH_O, nullptr },
        { "remove_license_lost", reinterpret_cast<PyCFunction>(StorePackageLicense_remove_LicenseLost), METH_O, nullptr },
        { "_assign_array_", _assign_array_StorePackageLicense, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_StorePackageLicense), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_StorePackageLicense), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_StorePackageLicense), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_StorePackageLicense[] = {
        { "is_valid", reinterpret_cast<getter>(StorePackageLicense_get_IsValid), nullptr, nullptr, nullptr },
        { "package", reinterpret_cast<getter>(StorePackageLicense_get_Package), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_StorePackageLicense[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_StorePackageLicense) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_StorePackageLicense) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_StorePackageLicense) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_StorePackageLicense) },
        { },
    };

    static PyType_Spec type_spec_StorePackageLicense =
    {
        "winrt._winrt_windows_services_store.StorePackageLicense",
        sizeof(py::wrapper::Windows::Services::Store::StorePackageLicense),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StorePackageLicense
    };

    // ----- StorePackageUpdate class --------------------

    static PyObject* _new_StorePackageUpdate(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Services::Store::StorePackageUpdate>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Services::Store::StorePackageUpdate>::type_name);
        return nullptr;
    }

    static void _dealloc_StorePackageUpdate(py::wrapper::Windows::Services::Store::StorePackageUpdate* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* StorePackageUpdate_get_Mandatory(py::wrapper::Windows::Services::Store::StorePackageUpdate* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StorePackageUpdate", L"Mandatory"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Mandatory());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StorePackageUpdate_get_Package(py::wrapper::Windows::Services::Store::StorePackageUpdate* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StorePackageUpdate", L"Package"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Package());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_StorePackageUpdate(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Services::Store::StorePackageUpdate>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_StorePackageUpdate(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Services::Store::StorePackageUpdate>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StorePackageUpdate[] = {
        { "_assign_array_", _assign_array_StorePackageUpdate, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_StorePackageUpdate), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_StorePackageUpdate[] = {
        { "mandatory", reinterpret_cast<getter>(StorePackageUpdate_get_Mandatory), nullptr, nullptr, nullptr },
        { "package", reinterpret_cast<getter>(StorePackageUpdate_get_Package), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_StorePackageUpdate[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_StorePackageUpdate) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_StorePackageUpdate) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_StorePackageUpdate) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_StorePackageUpdate) },
        { },
    };

    static PyType_Spec type_spec_StorePackageUpdate =
    {
        "winrt._winrt_windows_services_store.StorePackageUpdate",
        sizeof(py::wrapper::Windows::Services::Store::StorePackageUpdate),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StorePackageUpdate
    };

    // ----- StorePackageUpdateResult class --------------------

    static PyObject* _new_StorePackageUpdateResult(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Services::Store::StorePackageUpdateResult>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Services::Store::StorePackageUpdateResult>::type_name);
        return nullptr;
    }

    static void _dealloc_StorePackageUpdateResult(py::wrapper::Windows::Services::Store::StorePackageUpdateResult* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* StorePackageUpdateResult_get_OverallState(py::wrapper::Windows::Services::Store::StorePackageUpdateResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StorePackageUpdateResult", L"OverallState"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.OverallState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StorePackageUpdateResult_get_StorePackageUpdateStatuses(py::wrapper::Windows::Services::Store::StorePackageUpdateResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StorePackageUpdateResult", L"StorePackageUpdateStatuses"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.StorePackageUpdateStatuses());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StorePackageUpdateResult_get_StoreQueueItems(py::wrapper::Windows::Services::Store::StorePackageUpdateResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StorePackageUpdateResult", L"StoreQueueItems"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.StoreQueueItems());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_StorePackageUpdateResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Services::Store::StorePackageUpdateResult>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_StorePackageUpdateResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Services::Store::StorePackageUpdateResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StorePackageUpdateResult[] = {
        { "_assign_array_", _assign_array_StorePackageUpdateResult, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_StorePackageUpdateResult), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_StorePackageUpdateResult[] = {
        { "overall_state", reinterpret_cast<getter>(StorePackageUpdateResult_get_OverallState), nullptr, nullptr, nullptr },
        { "store_package_update_statuses", reinterpret_cast<getter>(StorePackageUpdateResult_get_StorePackageUpdateStatuses), nullptr, nullptr, nullptr },
        { "store_queue_items", reinterpret_cast<getter>(StorePackageUpdateResult_get_StoreQueueItems), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_StorePackageUpdateResult[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_StorePackageUpdateResult) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_StorePackageUpdateResult) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_StorePackageUpdateResult) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_StorePackageUpdateResult) },
        { },
    };

    static PyType_Spec type_spec_StorePackageUpdateResult =
    {
        "winrt._winrt_windows_services_store.StorePackageUpdateResult",
        sizeof(py::wrapper::Windows::Services::Store::StorePackageUpdateResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StorePackageUpdateResult
    };

    // ----- StorePrice class --------------------

    static PyObject* _new_StorePrice(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Services::Store::StorePrice>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Services::Store::StorePrice>::type_name);
        return nullptr;
    }

    static void _dealloc_StorePrice(py::wrapper::Windows::Services::Store::StorePrice* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* StorePrice_get_CurrencyCode(py::wrapper::Windows::Services::Store::StorePrice* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StorePrice", L"CurrencyCode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CurrencyCode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StorePrice_get_FormattedBasePrice(py::wrapper::Windows::Services::Store::StorePrice* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StorePrice", L"FormattedBasePrice"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.FormattedBasePrice());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StorePrice_get_FormattedPrice(py::wrapper::Windows::Services::Store::StorePrice* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StorePrice", L"FormattedPrice"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.FormattedPrice());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StorePrice_get_FormattedRecurrencePrice(py::wrapper::Windows::Services::Store::StorePrice* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StorePrice", L"FormattedRecurrencePrice"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.FormattedRecurrencePrice());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StorePrice_get_IsOnSale(py::wrapper::Windows::Services::Store::StorePrice* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StorePrice", L"IsOnSale"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsOnSale());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StorePrice_get_SaleEndDate(py::wrapper::Windows::Services::Store::StorePrice* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StorePrice", L"SaleEndDate"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SaleEndDate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StorePrice_get_UnformattedBasePrice(py::wrapper::Windows::Services::Store::StorePrice* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StorePrice", L"UnformattedBasePrice"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.UnformattedBasePrice());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StorePrice_get_UnformattedPrice(py::wrapper::Windows::Services::Store::StorePrice* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StorePrice", L"UnformattedPrice"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.UnformattedPrice());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StorePrice_get_UnformattedRecurrencePrice(py::wrapper::Windows::Services::Store::StorePrice* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StorePrice", L"UnformattedRecurrencePrice"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.UnformattedRecurrencePrice());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_StorePrice(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Services::Store::StorePrice>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_StorePrice(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Services::Store::StorePrice>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StorePrice[] = {
        { "_assign_array_", _assign_array_StorePrice, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_StorePrice), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_StorePrice[] = {
        { "currency_code", reinterpret_cast<getter>(StorePrice_get_CurrencyCode), nullptr, nullptr, nullptr },
        { "formatted_base_price", reinterpret_cast<getter>(StorePrice_get_FormattedBasePrice), nullptr, nullptr, nullptr },
        { "formatted_price", reinterpret_cast<getter>(StorePrice_get_FormattedPrice), nullptr, nullptr, nullptr },
        { "formatted_recurrence_price", reinterpret_cast<getter>(StorePrice_get_FormattedRecurrencePrice), nullptr, nullptr, nullptr },
        { "is_on_sale", reinterpret_cast<getter>(StorePrice_get_IsOnSale), nullptr, nullptr, nullptr },
        { "sale_end_date", reinterpret_cast<getter>(StorePrice_get_SaleEndDate), nullptr, nullptr, nullptr },
        { "unformatted_base_price", reinterpret_cast<getter>(StorePrice_get_UnformattedBasePrice), nullptr, nullptr, nullptr },
        { "unformatted_price", reinterpret_cast<getter>(StorePrice_get_UnformattedPrice), nullptr, nullptr, nullptr },
        { "unformatted_recurrence_price", reinterpret_cast<getter>(StorePrice_get_UnformattedRecurrencePrice), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_StorePrice[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_StorePrice) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_StorePrice) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_StorePrice) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_StorePrice) },
        { },
    };

    static PyType_Spec type_spec_StorePrice =
    {
        "winrt._winrt_windows_services_store.StorePrice",
        sizeof(py::wrapper::Windows::Services::Store::StorePrice),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StorePrice
    };

    // ----- StoreProduct class --------------------

    static PyObject* _new_StoreProduct(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Services::Store::StoreProduct>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Services::Store::StoreProduct>::type_name);
        return nullptr;
    }

    static void _dealloc_StoreProduct(py::wrapper::Windows::Services::Store::StoreProduct* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* StoreProduct_GetIsAnySkuInstalledAsync(py::wrapper::Windows::Services::Store::StoreProduct* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Services.Store.StoreProduct", L"GetIsAnySkuInstalledAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetIsAnySkuInstalledAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StoreProduct_RequestPurchaseAsync(py::wrapper::Windows::Services::Store::StoreProduct* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Services.Store.StoreProduct", L"RequestPurchaseAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.RequestPurchaseAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Services.Store.StoreProduct", L"RequestPurchaseAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Services::Store::StorePurchaseProperties>(args, 0);

                return py::convert(self->obj.RequestPurchaseAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StoreProduct_get_Description(py::wrapper::Windows::Services::Store::StoreProduct* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreProduct", L"Description"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Description());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreProduct_get_ExtendedJsonData(py::wrapper::Windows::Services::Store::StoreProduct* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreProduct", L"ExtendedJsonData"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ExtendedJsonData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreProduct_get_HasDigitalDownload(py::wrapper::Windows::Services::Store::StoreProduct* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreProduct", L"HasDigitalDownload"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.HasDigitalDownload());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreProduct_get_Images(py::wrapper::Windows::Services::Store::StoreProduct* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreProduct", L"Images"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Images());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreProduct_get_InAppOfferToken(py::wrapper::Windows::Services::Store::StoreProduct* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreProduct", L"InAppOfferToken"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.InAppOfferToken());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreProduct_get_IsInUserCollection(py::wrapper::Windows::Services::Store::StoreProduct* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreProduct", L"IsInUserCollection"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsInUserCollection());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreProduct_get_Keywords(py::wrapper::Windows::Services::Store::StoreProduct* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreProduct", L"Keywords"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Keywords());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreProduct_get_Language(py::wrapper::Windows::Services::Store::StoreProduct* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreProduct", L"Language"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Language());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreProduct_get_LinkUri(py::wrapper::Windows::Services::Store::StoreProduct* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreProduct", L"LinkUri"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.LinkUri());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreProduct_get_Price(py::wrapper::Windows::Services::Store::StoreProduct* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreProduct", L"Price"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Price());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreProduct_get_ProductKind(py::wrapper::Windows::Services::Store::StoreProduct* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreProduct", L"ProductKind"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ProductKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreProduct_get_Skus(py::wrapper::Windows::Services::Store::StoreProduct* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreProduct", L"Skus"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Skus());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreProduct_get_StoreId(py::wrapper::Windows::Services::Store::StoreProduct* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreProduct", L"StoreId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.StoreId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreProduct_get_Title(py::wrapper::Windows::Services::Store::StoreProduct* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreProduct", L"Title"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Title());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreProduct_get_Videos(py::wrapper::Windows::Services::Store::StoreProduct* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreProduct", L"Videos"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Videos());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_StoreProduct(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Services::Store::StoreProduct>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_StoreProduct(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Services::Store::StoreProduct>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StoreProduct[] = {
        { "get_is_any_sku_installed_async", reinterpret_cast<PyCFunction>(StoreProduct_GetIsAnySkuInstalledAsync), METH_VARARGS, nullptr },
        { "request_purchase_async", reinterpret_cast<PyCFunction>(StoreProduct_RequestPurchaseAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_StoreProduct, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_StoreProduct), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_StoreProduct[] = {
        { "description", reinterpret_cast<getter>(StoreProduct_get_Description), nullptr, nullptr, nullptr },
        { "extended_json_data", reinterpret_cast<getter>(StoreProduct_get_ExtendedJsonData), nullptr, nullptr, nullptr },
        { "has_digital_download", reinterpret_cast<getter>(StoreProduct_get_HasDigitalDownload), nullptr, nullptr, nullptr },
        { "images", reinterpret_cast<getter>(StoreProduct_get_Images), nullptr, nullptr, nullptr },
        { "in_app_offer_token", reinterpret_cast<getter>(StoreProduct_get_InAppOfferToken), nullptr, nullptr, nullptr },
        { "is_in_user_collection", reinterpret_cast<getter>(StoreProduct_get_IsInUserCollection), nullptr, nullptr, nullptr },
        { "keywords", reinterpret_cast<getter>(StoreProduct_get_Keywords), nullptr, nullptr, nullptr },
        { "language", reinterpret_cast<getter>(StoreProduct_get_Language), nullptr, nullptr, nullptr },
        { "link_uri", reinterpret_cast<getter>(StoreProduct_get_LinkUri), nullptr, nullptr, nullptr },
        { "price", reinterpret_cast<getter>(StoreProduct_get_Price), nullptr, nullptr, nullptr },
        { "product_kind", reinterpret_cast<getter>(StoreProduct_get_ProductKind), nullptr, nullptr, nullptr },
        { "skus", reinterpret_cast<getter>(StoreProduct_get_Skus), nullptr, nullptr, nullptr },
        { "store_id", reinterpret_cast<getter>(StoreProduct_get_StoreId), nullptr, nullptr, nullptr },
        { "title", reinterpret_cast<getter>(StoreProduct_get_Title), nullptr, nullptr, nullptr },
        { "videos", reinterpret_cast<getter>(StoreProduct_get_Videos), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_StoreProduct[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_StoreProduct) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_StoreProduct) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_StoreProduct) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_StoreProduct) },
        { },
    };

    static PyType_Spec type_spec_StoreProduct =
    {
        "winrt._winrt_windows_services_store.StoreProduct",
        sizeof(py::wrapper::Windows::Services::Store::StoreProduct),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StoreProduct
    };

    // ----- StoreProductOptions class --------------------

    static PyObject* _new_StoreProductOptions(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Services::Store::StoreProductOptions instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_StoreProductOptions(py::wrapper::Windows::Services::Store::StoreProductOptions* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* StoreProductOptions_get_ActionFilters(py::wrapper::Windows::Services::Store::StoreProductOptions* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreProductOptions", L"ActionFilters"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ActionFilters());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_StoreProductOptions(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Services::Store::StoreProductOptions>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_StoreProductOptions(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Services::Store::StoreProductOptions>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StoreProductOptions[] = {
        { "_assign_array_", _assign_array_StoreProductOptions, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_StoreProductOptions), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_StoreProductOptions[] = {
        { "action_filters", reinterpret_cast<getter>(StoreProductOptions_get_ActionFilters), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_StoreProductOptions[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_StoreProductOptions) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_StoreProductOptions) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_StoreProductOptions) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_StoreProductOptions) },
        { },
    };

    static PyType_Spec type_spec_StoreProductOptions =
    {
        "winrt._winrt_windows_services_store.StoreProductOptions",
        sizeof(py::wrapper::Windows::Services::Store::StoreProductOptions),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StoreProductOptions
    };

    // ----- StoreProductPagedQueryResult class --------------------

    static PyObject* _new_StoreProductPagedQueryResult(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Services::Store::StoreProductPagedQueryResult>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Services::Store::StoreProductPagedQueryResult>::type_name);
        return nullptr;
    }

    static void _dealloc_StoreProductPagedQueryResult(py::wrapper::Windows::Services::Store::StoreProductPagedQueryResult* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* StoreProductPagedQueryResult_GetNextAsync(py::wrapper::Windows::Services::Store::StoreProductPagedQueryResult* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Services.Store.StoreProductPagedQueryResult", L"GetNextAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetNextAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StoreProductPagedQueryResult_get_ExtendedError(py::wrapper::Windows::Services::Store::StoreProductPagedQueryResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreProductPagedQueryResult", L"ExtendedError"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ExtendedError());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreProductPagedQueryResult_get_HasMoreResults(py::wrapper::Windows::Services::Store::StoreProductPagedQueryResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreProductPagedQueryResult", L"HasMoreResults"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.HasMoreResults());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreProductPagedQueryResult_get_Products(py::wrapper::Windows::Services::Store::StoreProductPagedQueryResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreProductPagedQueryResult", L"Products"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Products());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_StoreProductPagedQueryResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Services::Store::StoreProductPagedQueryResult>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_StoreProductPagedQueryResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Services::Store::StoreProductPagedQueryResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StoreProductPagedQueryResult[] = {
        { "get_next_async", reinterpret_cast<PyCFunction>(StoreProductPagedQueryResult_GetNextAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_StoreProductPagedQueryResult, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_StoreProductPagedQueryResult), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_StoreProductPagedQueryResult[] = {
        { "extended_error", reinterpret_cast<getter>(StoreProductPagedQueryResult_get_ExtendedError), nullptr, nullptr, nullptr },
        { "has_more_results", reinterpret_cast<getter>(StoreProductPagedQueryResult_get_HasMoreResults), nullptr, nullptr, nullptr },
        { "products", reinterpret_cast<getter>(StoreProductPagedQueryResult_get_Products), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_StoreProductPagedQueryResult[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_StoreProductPagedQueryResult) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_StoreProductPagedQueryResult) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_StoreProductPagedQueryResult) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_StoreProductPagedQueryResult) },
        { },
    };

    static PyType_Spec type_spec_StoreProductPagedQueryResult =
    {
        "winrt._winrt_windows_services_store.StoreProductPagedQueryResult",
        sizeof(py::wrapper::Windows::Services::Store::StoreProductPagedQueryResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StoreProductPagedQueryResult
    };

    // ----- StoreProductQueryResult class --------------------

    static PyObject* _new_StoreProductQueryResult(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Services::Store::StoreProductQueryResult>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Services::Store::StoreProductQueryResult>::type_name);
        return nullptr;
    }

    static void _dealloc_StoreProductQueryResult(py::wrapper::Windows::Services::Store::StoreProductQueryResult* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* StoreProductQueryResult_get_ExtendedError(py::wrapper::Windows::Services::Store::StoreProductQueryResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreProductQueryResult", L"ExtendedError"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ExtendedError());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreProductQueryResult_get_Products(py::wrapper::Windows::Services::Store::StoreProductQueryResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreProductQueryResult", L"Products"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Products());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_StoreProductQueryResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Services::Store::StoreProductQueryResult>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_StoreProductQueryResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Services::Store::StoreProductQueryResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StoreProductQueryResult[] = {
        { "_assign_array_", _assign_array_StoreProductQueryResult, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_StoreProductQueryResult), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_StoreProductQueryResult[] = {
        { "extended_error", reinterpret_cast<getter>(StoreProductQueryResult_get_ExtendedError), nullptr, nullptr, nullptr },
        { "products", reinterpret_cast<getter>(StoreProductQueryResult_get_Products), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_StoreProductQueryResult[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_StoreProductQueryResult) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_StoreProductQueryResult) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_StoreProductQueryResult) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_StoreProductQueryResult) },
        { },
    };

    static PyType_Spec type_spec_StoreProductQueryResult =
    {
        "winrt._winrt_windows_services_store.StoreProductQueryResult",
        sizeof(py::wrapper::Windows::Services::Store::StoreProductQueryResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StoreProductQueryResult
    };

    // ----- StoreProductResult class --------------------

    static PyObject* _new_StoreProductResult(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Services::Store::StoreProductResult>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Services::Store::StoreProductResult>::type_name);
        return nullptr;
    }

    static void _dealloc_StoreProductResult(py::wrapper::Windows::Services::Store::StoreProductResult* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* StoreProductResult_get_ExtendedError(py::wrapper::Windows::Services::Store::StoreProductResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreProductResult", L"ExtendedError"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ExtendedError());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreProductResult_get_Product(py::wrapper::Windows::Services::Store::StoreProductResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreProductResult", L"Product"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Product());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_StoreProductResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Services::Store::StoreProductResult>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_StoreProductResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Services::Store::StoreProductResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StoreProductResult[] = {
        { "_assign_array_", _assign_array_StoreProductResult, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_StoreProductResult), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_StoreProductResult[] = {
        { "extended_error", reinterpret_cast<getter>(StoreProductResult_get_ExtendedError), nullptr, nullptr, nullptr },
        { "product", reinterpret_cast<getter>(StoreProductResult_get_Product), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_StoreProductResult[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_StoreProductResult) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_StoreProductResult) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_StoreProductResult) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_StoreProductResult) },
        { },
    };

    static PyType_Spec type_spec_StoreProductResult =
    {
        "winrt._winrt_windows_services_store.StoreProductResult",
        sizeof(py::wrapper::Windows::Services::Store::StoreProductResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StoreProductResult
    };

    // ----- StorePurchaseProperties class --------------------

    static PyObject* _new_StorePurchaseProperties(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                winrt::Windows::Services::Store::StorePurchaseProperties instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Services::Store::StorePurchaseProperties instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_StorePurchaseProperties(py::wrapper::Windows::Services::Store::StorePurchaseProperties* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* StorePurchaseProperties_get_Name(py::wrapper::Windows::Services::Store::StorePurchaseProperties* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StorePurchaseProperties", L"Name"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Name());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StorePurchaseProperties_put_Name(py::wrapper::Windows::Services::Store::StorePurchaseProperties* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StorePurchaseProperties", L"Name"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Name(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StorePurchaseProperties_get_ExtendedJsonData(py::wrapper::Windows::Services::Store::StorePurchaseProperties* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StorePurchaseProperties", L"ExtendedJsonData"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ExtendedJsonData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StorePurchaseProperties_put_ExtendedJsonData(py::wrapper::Windows::Services::Store::StorePurchaseProperties* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StorePurchaseProperties", L"ExtendedJsonData"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.ExtendedJsonData(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_StorePurchaseProperties(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Services::Store::StorePurchaseProperties>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_StorePurchaseProperties(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Services::Store::StorePurchaseProperties>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StorePurchaseProperties[] = {
        { "_assign_array_", _assign_array_StorePurchaseProperties, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_StorePurchaseProperties), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_StorePurchaseProperties[] = {
        { "name", reinterpret_cast<getter>(StorePurchaseProperties_get_Name), reinterpret_cast<setter>(StorePurchaseProperties_put_Name), nullptr, nullptr },
        { "extended_json_data", reinterpret_cast<getter>(StorePurchaseProperties_get_ExtendedJsonData), reinterpret_cast<setter>(StorePurchaseProperties_put_ExtendedJsonData), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_StorePurchaseProperties[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_StorePurchaseProperties) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_StorePurchaseProperties) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_StorePurchaseProperties) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_StorePurchaseProperties) },
        { },
    };

    static PyType_Spec type_spec_StorePurchaseProperties =
    {
        "winrt._winrt_windows_services_store.StorePurchaseProperties",
        sizeof(py::wrapper::Windows::Services::Store::StorePurchaseProperties),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StorePurchaseProperties
    };

    // ----- StorePurchaseResult class --------------------

    static PyObject* _new_StorePurchaseResult(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Services::Store::StorePurchaseResult>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Services::Store::StorePurchaseResult>::type_name);
        return nullptr;
    }

    static void _dealloc_StorePurchaseResult(py::wrapper::Windows::Services::Store::StorePurchaseResult* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* StorePurchaseResult_get_ExtendedError(py::wrapper::Windows::Services::Store::StorePurchaseResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StorePurchaseResult", L"ExtendedError"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ExtendedError());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StorePurchaseResult_get_Status(py::wrapper::Windows::Services::Store::StorePurchaseResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StorePurchaseResult", L"Status"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_StorePurchaseResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Services::Store::StorePurchaseResult>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_StorePurchaseResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Services::Store::StorePurchaseResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StorePurchaseResult[] = {
        { "_assign_array_", _assign_array_StorePurchaseResult, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_StorePurchaseResult), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_StorePurchaseResult[] = {
        { "extended_error", reinterpret_cast<getter>(StorePurchaseResult_get_ExtendedError), nullptr, nullptr, nullptr },
        { "status", reinterpret_cast<getter>(StorePurchaseResult_get_Status), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_StorePurchaseResult[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_StorePurchaseResult) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_StorePurchaseResult) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_StorePurchaseResult) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_StorePurchaseResult) },
        { },
    };

    static PyType_Spec type_spec_StorePurchaseResult =
    {
        "winrt._winrt_windows_services_store.StorePurchaseResult",
        sizeof(py::wrapper::Windows::Services::Store::StorePurchaseResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StorePurchaseResult
    };

    // ----- StoreQueueItem class --------------------

    static PyObject* _new_StoreQueueItem(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Services::Store::StoreQueueItem>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Services::Store::StoreQueueItem>::type_name);
        return nullptr;
    }

    static void _dealloc_StoreQueueItem(py::wrapper::Windows::Services::Store::StoreQueueItem* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* StoreQueueItem_CancelInstallAsync(py::wrapper::Windows::Services::Store::StoreQueueItem* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Services.Store.StoreQueueItem", L"CancelInstallAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.CancelInstallAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StoreQueueItem_GetCurrentStatus(py::wrapper::Windows::Services::Store::StoreQueueItem* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Services.Store.StoreQueueItem", L"GetCurrentStatus", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetCurrentStatus());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StoreQueueItem_PauseInstallAsync(py::wrapper::Windows::Services::Store::StoreQueueItem* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Services.Store.StoreQueueItem", L"PauseInstallAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.PauseInstallAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StoreQueueItem_ResumeInstallAsync(py::wrapper::Windows::Services::Store::StoreQueueItem* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Services.Store.StoreQueueItem", L"ResumeInstallAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.ResumeInstallAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StoreQueueItem_get_InstallKind(py::wrapper::Windows::Services::Store::StoreQueueItem* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreQueueItem", L"InstallKind"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.InstallKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreQueueItem_get_PackageFamilyName(py::wrapper::Windows::Services::Store::StoreQueueItem* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreQueueItem", L"PackageFamilyName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PackageFamilyName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreQueueItem_get_ProductId(py::wrapper::Windows::Services::Store::StoreQueueItem* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreQueueItem", L"ProductId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ProductId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreQueueItem_add_Completed(py::wrapper::Windows::Services::Store::StoreQueueItem* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Services.Store.StoreQueueItem", L"Completed"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Services::Store::StoreQueueItem, winrt::Windows::Services::Store::StoreQueueItemCompletedEventArgs>>(arg);

            return py::convert(self->obj.Completed(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreQueueItem_remove_Completed(py::wrapper::Windows::Services::Store::StoreQueueItem* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Services.Store.StoreQueueItem", L"Completed"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Completed(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreQueueItem_add_StatusChanged(py::wrapper::Windows::Services::Store::StoreQueueItem* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Services.Store.StoreQueueItem", L"StatusChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Services::Store::StoreQueueItem, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.StatusChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreQueueItem_remove_StatusChanged(py::wrapper::Windows::Services::Store::StoreQueueItem* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Services.Store.StoreQueueItem", L"StatusChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.StatusChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_StoreQueueItem(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Services::Store::StoreQueueItem>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_StoreQueueItem(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Services::Store::StoreQueueItem>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StoreQueueItem[] = {
        { "cancel_install_async", reinterpret_cast<PyCFunction>(StoreQueueItem_CancelInstallAsync), METH_VARARGS, nullptr },
        { "get_current_status", reinterpret_cast<PyCFunction>(StoreQueueItem_GetCurrentStatus), METH_VARARGS, nullptr },
        { "pause_install_async", reinterpret_cast<PyCFunction>(StoreQueueItem_PauseInstallAsync), METH_VARARGS, nullptr },
        { "resume_install_async", reinterpret_cast<PyCFunction>(StoreQueueItem_ResumeInstallAsync), METH_VARARGS, nullptr },
        { "add_completed", reinterpret_cast<PyCFunction>(StoreQueueItem_add_Completed), METH_O, nullptr },
        { "remove_completed", reinterpret_cast<PyCFunction>(StoreQueueItem_remove_Completed), METH_O, nullptr },
        { "add_status_changed", reinterpret_cast<PyCFunction>(StoreQueueItem_add_StatusChanged), METH_O, nullptr },
        { "remove_status_changed", reinterpret_cast<PyCFunction>(StoreQueueItem_remove_StatusChanged), METH_O, nullptr },
        { "_assign_array_", _assign_array_StoreQueueItem, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_StoreQueueItem), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_StoreQueueItem[] = {
        { "install_kind", reinterpret_cast<getter>(StoreQueueItem_get_InstallKind), nullptr, nullptr, nullptr },
        { "package_family_name", reinterpret_cast<getter>(StoreQueueItem_get_PackageFamilyName), nullptr, nullptr, nullptr },
        { "product_id", reinterpret_cast<getter>(StoreQueueItem_get_ProductId), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_StoreQueueItem[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_StoreQueueItem) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_StoreQueueItem) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_StoreQueueItem) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_StoreQueueItem) },
        { },
    };

    static PyType_Spec type_spec_StoreQueueItem =
    {
        "winrt._winrt_windows_services_store.StoreQueueItem",
        sizeof(py::wrapper::Windows::Services::Store::StoreQueueItem),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StoreQueueItem
    };

    // ----- StoreQueueItemCompletedEventArgs class --------------------

    static PyObject* _new_StoreQueueItemCompletedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Services::Store::StoreQueueItemCompletedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Services::Store::StoreQueueItemCompletedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_StoreQueueItemCompletedEventArgs(py::wrapper::Windows::Services::Store::StoreQueueItemCompletedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* StoreQueueItemCompletedEventArgs_get_Status(py::wrapper::Windows::Services::Store::StoreQueueItemCompletedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreQueueItemCompletedEventArgs", L"Status"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_StoreQueueItemCompletedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Services::Store::StoreQueueItemCompletedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_StoreQueueItemCompletedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Services::Store::StoreQueueItemCompletedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StoreQueueItemCompletedEventArgs[] = {
        { "_assign_array_", _assign_array_StoreQueueItemCompletedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_StoreQueueItemCompletedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_StoreQueueItemCompletedEventArgs[] = {
        { "status", reinterpret_cast<getter>(StoreQueueItemCompletedEventArgs_get_Status), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_StoreQueueItemCompletedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_StoreQueueItemCompletedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_StoreQueueItemCompletedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_StoreQueueItemCompletedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_StoreQueueItemCompletedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_StoreQueueItemCompletedEventArgs =
    {
        "winrt._winrt_windows_services_store.StoreQueueItemCompletedEventArgs",
        sizeof(py::wrapper::Windows::Services::Store::StoreQueueItemCompletedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StoreQueueItemCompletedEventArgs
    };

    // ----- StoreQueueItemStatus class --------------------

    static PyObject* _new_StoreQueueItemStatus(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Services::Store::StoreQueueItemStatus>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Services::Store::StoreQueueItemStatus>::type_name);
        return nullptr;
    }

    static void _dealloc_StoreQueueItemStatus(py::wrapper::Windows::Services::Store::StoreQueueItemStatus* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* StoreQueueItemStatus_get_ExtendedError(py::wrapper::Windows::Services::Store::StoreQueueItemStatus* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreQueueItemStatus", L"ExtendedError"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ExtendedError());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreQueueItemStatus_get_PackageInstallExtendedState(py::wrapper::Windows::Services::Store::StoreQueueItemStatus* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreQueueItemStatus", L"PackageInstallExtendedState"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PackageInstallExtendedState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreQueueItemStatus_get_PackageInstallState(py::wrapper::Windows::Services::Store::StoreQueueItemStatus* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreQueueItemStatus", L"PackageInstallState"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PackageInstallState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreQueueItemStatus_get_UpdateStatus(py::wrapper::Windows::Services::Store::StoreQueueItemStatus* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreQueueItemStatus", L"UpdateStatus"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.UpdateStatus());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_StoreQueueItemStatus(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Services::Store::StoreQueueItemStatus>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_StoreQueueItemStatus(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Services::Store::StoreQueueItemStatus>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StoreQueueItemStatus[] = {
        { "_assign_array_", _assign_array_StoreQueueItemStatus, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_StoreQueueItemStatus), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_StoreQueueItemStatus[] = {
        { "extended_error", reinterpret_cast<getter>(StoreQueueItemStatus_get_ExtendedError), nullptr, nullptr, nullptr },
        { "package_install_extended_state", reinterpret_cast<getter>(StoreQueueItemStatus_get_PackageInstallExtendedState), nullptr, nullptr, nullptr },
        { "package_install_state", reinterpret_cast<getter>(StoreQueueItemStatus_get_PackageInstallState), nullptr, nullptr, nullptr },
        { "update_status", reinterpret_cast<getter>(StoreQueueItemStatus_get_UpdateStatus), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_StoreQueueItemStatus[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_StoreQueueItemStatus) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_StoreQueueItemStatus) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_StoreQueueItemStatus) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_StoreQueueItemStatus) },
        { },
    };

    static PyType_Spec type_spec_StoreQueueItemStatus =
    {
        "winrt._winrt_windows_services_store.StoreQueueItemStatus",
        sizeof(py::wrapper::Windows::Services::Store::StoreQueueItemStatus),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StoreQueueItemStatus
    };

    // ----- StoreRateAndReviewResult class --------------------

    static PyObject* _new_StoreRateAndReviewResult(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Services::Store::StoreRateAndReviewResult>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Services::Store::StoreRateAndReviewResult>::type_name);
        return nullptr;
    }

    static void _dealloc_StoreRateAndReviewResult(py::wrapper::Windows::Services::Store::StoreRateAndReviewResult* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* StoreRateAndReviewResult_get_ExtendedError(py::wrapper::Windows::Services::Store::StoreRateAndReviewResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreRateAndReviewResult", L"ExtendedError"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ExtendedError());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreRateAndReviewResult_get_ExtendedJsonData(py::wrapper::Windows::Services::Store::StoreRateAndReviewResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreRateAndReviewResult", L"ExtendedJsonData"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ExtendedJsonData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreRateAndReviewResult_get_Status(py::wrapper::Windows::Services::Store::StoreRateAndReviewResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreRateAndReviewResult", L"Status"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreRateAndReviewResult_get_WasUpdated(py::wrapper::Windows::Services::Store::StoreRateAndReviewResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreRateAndReviewResult", L"WasUpdated"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.WasUpdated());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_StoreRateAndReviewResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Services::Store::StoreRateAndReviewResult>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_StoreRateAndReviewResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Services::Store::StoreRateAndReviewResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StoreRateAndReviewResult[] = {
        { "_assign_array_", _assign_array_StoreRateAndReviewResult, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_StoreRateAndReviewResult), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_StoreRateAndReviewResult[] = {
        { "extended_error", reinterpret_cast<getter>(StoreRateAndReviewResult_get_ExtendedError), nullptr, nullptr, nullptr },
        { "extended_json_data", reinterpret_cast<getter>(StoreRateAndReviewResult_get_ExtendedJsonData), nullptr, nullptr, nullptr },
        { "status", reinterpret_cast<getter>(StoreRateAndReviewResult_get_Status), nullptr, nullptr, nullptr },
        { "was_updated", reinterpret_cast<getter>(StoreRateAndReviewResult_get_WasUpdated), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_StoreRateAndReviewResult[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_StoreRateAndReviewResult) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_StoreRateAndReviewResult) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_StoreRateAndReviewResult) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_StoreRateAndReviewResult) },
        { },
    };

    static PyType_Spec type_spec_StoreRateAndReviewResult =
    {
        "winrt._winrt_windows_services_store.StoreRateAndReviewResult",
        sizeof(py::wrapper::Windows::Services::Store::StoreRateAndReviewResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StoreRateAndReviewResult
    };

    // ----- StoreRequestHelper class --------------------

    static PyObject* _new_StoreRequestHelper(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Services::Store::StoreRequestHelper>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Services::Store::StoreRequestHelper>::type_name);
        return nullptr;
    }

    static PyObject* StoreRequestHelper_SendRequestAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Services.Store.StoreRequestHelper", L"SendRequestAsync", 3))
            {
                py::set_arg_count_version_error(3);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Services::Store::StoreContext>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);
                auto param2 = py::convert_to<winrt::hstring>(args, 2);

                return py::convert(winrt::Windows::Services::Store::StoreRequestHelper::SendRequestAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyMethodDef _methods_StoreRequestHelper[] = {
        { }
    };

    static PyGetSetDef _getset_StoreRequestHelper[] = {
        { }
    };

    static PyType_Slot _type_slots_StoreRequestHelper[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_StoreRequestHelper) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_StoreRequestHelper) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_StoreRequestHelper) },
        { },
    };

    static PyType_Spec type_spec_StoreRequestHelper =
    {
        "winrt._winrt_windows_services_store.StoreRequestHelper",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StoreRequestHelper
    };

    static PyGetSetDef getset_StoreRequestHelper_Static[] = {
        { }
    };

    static PyMethodDef methods_StoreRequestHelper_Static[] = {
        { "send_request_async", reinterpret_cast<PyCFunction>(StoreRequestHelper_SendRequestAsync), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_StoreRequestHelper_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_StoreRequestHelper_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_StoreRequestHelper_Static) },
        { }
    };

    static PyType_Spec type_spec_StoreRequestHelper_Static =
    {
        "winrt._winrt_windows_services_store.StoreRequestHelper_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_StoreRequestHelper_Static
    };

    // ----- StoreSendRequestResult class --------------------

    static PyObject* _new_StoreSendRequestResult(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Services::Store::StoreSendRequestResult>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Services::Store::StoreSendRequestResult>::type_name);
        return nullptr;
    }

    static void _dealloc_StoreSendRequestResult(py::wrapper::Windows::Services::Store::StoreSendRequestResult* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* StoreSendRequestResult_get_ExtendedError(py::wrapper::Windows::Services::Store::StoreSendRequestResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreSendRequestResult", L"ExtendedError"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ExtendedError());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreSendRequestResult_get_Response(py::wrapper::Windows::Services::Store::StoreSendRequestResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreSendRequestResult", L"Response"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Response());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreSendRequestResult_get_HttpStatusCode(py::wrapper::Windows::Services::Store::StoreSendRequestResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreSendRequestResult", L"HttpStatusCode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.HttpStatusCode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_StoreSendRequestResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Services::Store::StoreSendRequestResult>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_StoreSendRequestResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Services::Store::StoreSendRequestResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StoreSendRequestResult[] = {
        { "_assign_array_", _assign_array_StoreSendRequestResult, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_StoreSendRequestResult), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_StoreSendRequestResult[] = {
        { "extended_error", reinterpret_cast<getter>(StoreSendRequestResult_get_ExtendedError), nullptr, nullptr, nullptr },
        { "response", reinterpret_cast<getter>(StoreSendRequestResult_get_Response), nullptr, nullptr, nullptr },
        { "http_status_code", reinterpret_cast<getter>(StoreSendRequestResult_get_HttpStatusCode), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_StoreSendRequestResult[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_StoreSendRequestResult) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_StoreSendRequestResult) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_StoreSendRequestResult) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_StoreSendRequestResult) },
        { },
    };

    static PyType_Spec type_spec_StoreSendRequestResult =
    {
        "winrt._winrt_windows_services_store.StoreSendRequestResult",
        sizeof(py::wrapper::Windows::Services::Store::StoreSendRequestResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StoreSendRequestResult
    };

    // ----- StoreSku class --------------------

    static PyObject* _new_StoreSku(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Services::Store::StoreSku>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Services::Store::StoreSku>::type_name);
        return nullptr;
    }

    static void _dealloc_StoreSku(py::wrapper::Windows::Services::Store::StoreSku* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* StoreSku_GetIsInstalledAsync(py::wrapper::Windows::Services::Store::StoreSku* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Services.Store.StoreSku", L"GetIsInstalledAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetIsInstalledAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StoreSku_RequestPurchaseAsync(py::wrapper::Windows::Services::Store::StoreSku* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Services.Store.StoreSku", L"RequestPurchaseAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.RequestPurchaseAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Services.Store.StoreSku", L"RequestPurchaseAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Services::Store::StorePurchaseProperties>(args, 0);

                return py::convert(self->obj.RequestPurchaseAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StoreSku_get_Availabilities(py::wrapper::Windows::Services::Store::StoreSku* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreSku", L"Availabilities"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Availabilities());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreSku_get_BundledSkus(py::wrapper::Windows::Services::Store::StoreSku* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreSku", L"BundledSkus"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.BundledSkus());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreSku_get_CollectionData(py::wrapper::Windows::Services::Store::StoreSku* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreSku", L"CollectionData"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CollectionData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreSku_get_CustomDeveloperData(py::wrapper::Windows::Services::Store::StoreSku* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreSku", L"CustomDeveloperData"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CustomDeveloperData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreSku_get_Description(py::wrapper::Windows::Services::Store::StoreSku* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreSku", L"Description"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Description());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreSku_get_ExtendedJsonData(py::wrapper::Windows::Services::Store::StoreSku* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreSku", L"ExtendedJsonData"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ExtendedJsonData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreSku_get_Images(py::wrapper::Windows::Services::Store::StoreSku* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreSku", L"Images"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Images());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreSku_get_IsInUserCollection(py::wrapper::Windows::Services::Store::StoreSku* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreSku", L"IsInUserCollection"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsInUserCollection());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreSku_get_IsSubscription(py::wrapper::Windows::Services::Store::StoreSku* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreSku", L"IsSubscription"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsSubscription());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreSku_get_IsTrial(py::wrapper::Windows::Services::Store::StoreSku* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreSku", L"IsTrial"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsTrial());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreSku_get_Language(py::wrapper::Windows::Services::Store::StoreSku* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreSku", L"Language"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Language());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreSku_get_Price(py::wrapper::Windows::Services::Store::StoreSku* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreSku", L"Price"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Price());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreSku_get_StoreId(py::wrapper::Windows::Services::Store::StoreSku* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreSku", L"StoreId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.StoreId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreSku_get_SubscriptionInfo(py::wrapper::Windows::Services::Store::StoreSku* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreSku", L"SubscriptionInfo"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SubscriptionInfo());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreSku_get_Title(py::wrapper::Windows::Services::Store::StoreSku* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreSku", L"Title"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Title());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreSku_get_Videos(py::wrapper::Windows::Services::Store::StoreSku* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreSku", L"Videos"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Videos());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_StoreSku(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Services::Store::StoreSku>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_StoreSku(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Services::Store::StoreSku>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StoreSku[] = {
        { "get_is_installed_async", reinterpret_cast<PyCFunction>(StoreSku_GetIsInstalledAsync), METH_VARARGS, nullptr },
        { "request_purchase_async", reinterpret_cast<PyCFunction>(StoreSku_RequestPurchaseAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_StoreSku, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_StoreSku), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_StoreSku[] = {
        { "availabilities", reinterpret_cast<getter>(StoreSku_get_Availabilities), nullptr, nullptr, nullptr },
        { "bundled_skus", reinterpret_cast<getter>(StoreSku_get_BundledSkus), nullptr, nullptr, nullptr },
        { "collection_data", reinterpret_cast<getter>(StoreSku_get_CollectionData), nullptr, nullptr, nullptr },
        { "custom_developer_data", reinterpret_cast<getter>(StoreSku_get_CustomDeveloperData), nullptr, nullptr, nullptr },
        { "description", reinterpret_cast<getter>(StoreSku_get_Description), nullptr, nullptr, nullptr },
        { "extended_json_data", reinterpret_cast<getter>(StoreSku_get_ExtendedJsonData), nullptr, nullptr, nullptr },
        { "images", reinterpret_cast<getter>(StoreSku_get_Images), nullptr, nullptr, nullptr },
        { "is_in_user_collection", reinterpret_cast<getter>(StoreSku_get_IsInUserCollection), nullptr, nullptr, nullptr },
        { "is_subscription", reinterpret_cast<getter>(StoreSku_get_IsSubscription), nullptr, nullptr, nullptr },
        { "is_trial", reinterpret_cast<getter>(StoreSku_get_IsTrial), nullptr, nullptr, nullptr },
        { "language", reinterpret_cast<getter>(StoreSku_get_Language), nullptr, nullptr, nullptr },
        { "price", reinterpret_cast<getter>(StoreSku_get_Price), nullptr, nullptr, nullptr },
        { "store_id", reinterpret_cast<getter>(StoreSku_get_StoreId), nullptr, nullptr, nullptr },
        { "subscription_info", reinterpret_cast<getter>(StoreSku_get_SubscriptionInfo), nullptr, nullptr, nullptr },
        { "title", reinterpret_cast<getter>(StoreSku_get_Title), nullptr, nullptr, nullptr },
        { "videos", reinterpret_cast<getter>(StoreSku_get_Videos), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_StoreSku[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_StoreSku) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_StoreSku) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_StoreSku) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_StoreSku) },
        { },
    };

    static PyType_Spec type_spec_StoreSku =
    {
        "winrt._winrt_windows_services_store.StoreSku",
        sizeof(py::wrapper::Windows::Services::Store::StoreSku),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StoreSku
    };

    // ----- StoreSubscriptionInfo class --------------------

    static PyObject* _new_StoreSubscriptionInfo(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Services::Store::StoreSubscriptionInfo>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Services::Store::StoreSubscriptionInfo>::type_name);
        return nullptr;
    }

    static void _dealloc_StoreSubscriptionInfo(py::wrapper::Windows::Services::Store::StoreSubscriptionInfo* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* StoreSubscriptionInfo_get_BillingPeriod(py::wrapper::Windows::Services::Store::StoreSubscriptionInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreSubscriptionInfo", L"BillingPeriod"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.BillingPeriod());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreSubscriptionInfo_get_BillingPeriodUnit(py::wrapper::Windows::Services::Store::StoreSubscriptionInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreSubscriptionInfo", L"BillingPeriodUnit"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.BillingPeriodUnit());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreSubscriptionInfo_get_HasTrialPeriod(py::wrapper::Windows::Services::Store::StoreSubscriptionInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreSubscriptionInfo", L"HasTrialPeriod"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.HasTrialPeriod());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreSubscriptionInfo_get_TrialPeriod(py::wrapper::Windows::Services::Store::StoreSubscriptionInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreSubscriptionInfo", L"TrialPeriod"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TrialPeriod());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreSubscriptionInfo_get_TrialPeriodUnit(py::wrapper::Windows::Services::Store::StoreSubscriptionInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreSubscriptionInfo", L"TrialPeriodUnit"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TrialPeriodUnit());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_StoreSubscriptionInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Services::Store::StoreSubscriptionInfo>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_StoreSubscriptionInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Services::Store::StoreSubscriptionInfo>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StoreSubscriptionInfo[] = {
        { "_assign_array_", _assign_array_StoreSubscriptionInfo, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_StoreSubscriptionInfo), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_StoreSubscriptionInfo[] = {
        { "billing_period", reinterpret_cast<getter>(StoreSubscriptionInfo_get_BillingPeriod), nullptr, nullptr, nullptr },
        { "billing_period_unit", reinterpret_cast<getter>(StoreSubscriptionInfo_get_BillingPeriodUnit), nullptr, nullptr, nullptr },
        { "has_trial_period", reinterpret_cast<getter>(StoreSubscriptionInfo_get_HasTrialPeriod), nullptr, nullptr, nullptr },
        { "trial_period", reinterpret_cast<getter>(StoreSubscriptionInfo_get_TrialPeriod), nullptr, nullptr, nullptr },
        { "trial_period_unit", reinterpret_cast<getter>(StoreSubscriptionInfo_get_TrialPeriodUnit), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_StoreSubscriptionInfo[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_StoreSubscriptionInfo) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_StoreSubscriptionInfo) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_StoreSubscriptionInfo) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_StoreSubscriptionInfo) },
        { },
    };

    static PyType_Spec type_spec_StoreSubscriptionInfo =
    {
        "winrt._winrt_windows_services_store.StoreSubscriptionInfo",
        sizeof(py::wrapper::Windows::Services::Store::StoreSubscriptionInfo),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StoreSubscriptionInfo
    };

    // ----- StoreUninstallStorePackageResult class --------------------

    static PyObject* _new_StoreUninstallStorePackageResult(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Services::Store::StoreUninstallStorePackageResult>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Services::Store::StoreUninstallStorePackageResult>::type_name);
        return nullptr;
    }

    static void _dealloc_StoreUninstallStorePackageResult(py::wrapper::Windows::Services::Store::StoreUninstallStorePackageResult* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* StoreUninstallStorePackageResult_get_ExtendedError(py::wrapper::Windows::Services::Store::StoreUninstallStorePackageResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreUninstallStorePackageResult", L"ExtendedError"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ExtendedError());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreUninstallStorePackageResult_get_Status(py::wrapper::Windows::Services::Store::StoreUninstallStorePackageResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreUninstallStorePackageResult", L"Status"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_StoreUninstallStorePackageResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Services::Store::StoreUninstallStorePackageResult>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_StoreUninstallStorePackageResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Services::Store::StoreUninstallStorePackageResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StoreUninstallStorePackageResult[] = {
        { "_assign_array_", _assign_array_StoreUninstallStorePackageResult, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_StoreUninstallStorePackageResult), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_StoreUninstallStorePackageResult[] = {
        { "extended_error", reinterpret_cast<getter>(StoreUninstallStorePackageResult_get_ExtendedError), nullptr, nullptr, nullptr },
        { "status", reinterpret_cast<getter>(StoreUninstallStorePackageResult_get_Status), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_StoreUninstallStorePackageResult[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_StoreUninstallStorePackageResult) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_StoreUninstallStorePackageResult) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_StoreUninstallStorePackageResult) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_StoreUninstallStorePackageResult) },
        { },
    };

    static PyType_Spec type_spec_StoreUninstallStorePackageResult =
    {
        "winrt._winrt_windows_services_store.StoreUninstallStorePackageResult",
        sizeof(py::wrapper::Windows::Services::Store::StoreUninstallStorePackageResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StoreUninstallStorePackageResult
    };

    // ----- StoreVideo class --------------------

    static PyObject* _new_StoreVideo(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Services::Store::StoreVideo>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Services::Store::StoreVideo>::type_name);
        return nullptr;
    }

    static void _dealloc_StoreVideo(py::wrapper::Windows::Services::Store::StoreVideo* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* StoreVideo_get_Caption(py::wrapper::Windows::Services::Store::StoreVideo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreVideo", L"Caption"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Caption());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreVideo_get_Height(py::wrapper::Windows::Services::Store::StoreVideo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreVideo", L"Height"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Height());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreVideo_get_PreviewImage(py::wrapper::Windows::Services::Store::StoreVideo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreVideo", L"PreviewImage"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PreviewImage());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreVideo_get_Uri(py::wrapper::Windows::Services::Store::StoreVideo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreVideo", L"Uri"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Uri());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreVideo_get_VideoPurposeTag(py::wrapper::Windows::Services::Store::StoreVideo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreVideo", L"VideoPurposeTag"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.VideoPurposeTag());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreVideo_get_Width(py::wrapper::Windows::Services::Store::StoreVideo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreVideo", L"Width"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Width());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_StoreVideo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Services::Store::StoreVideo>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_StoreVideo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Services::Store::StoreVideo>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StoreVideo[] = {
        { "_assign_array_", _assign_array_StoreVideo, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_StoreVideo), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_StoreVideo[] = {
        { "caption", reinterpret_cast<getter>(StoreVideo_get_Caption), nullptr, nullptr, nullptr },
        { "height", reinterpret_cast<getter>(StoreVideo_get_Height), nullptr, nullptr, nullptr },
        { "preview_image", reinterpret_cast<getter>(StoreVideo_get_PreviewImage), nullptr, nullptr, nullptr },
        { "uri", reinterpret_cast<getter>(StoreVideo_get_Uri), nullptr, nullptr, nullptr },
        { "video_purpose_tag", reinterpret_cast<getter>(StoreVideo_get_VideoPurposeTag), nullptr, nullptr, nullptr },
        { "width", reinterpret_cast<getter>(StoreVideo_get_Width), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_StoreVideo[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_StoreVideo) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_StoreVideo) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_StoreVideo) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_StoreVideo) },
        { },
    };

    static PyType_Spec type_spec_StoreVideo =
    {
        "winrt._winrt_windows_services_store.StoreVideo",
        sizeof(py::wrapper::Windows::Services::Store::StoreVideo),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StoreVideo
    };

    // ----- StorePackageUpdateStatus struct --------------------

    winrt_struct_wrapper<winrt::Windows::Services::Store::StorePackageUpdateStatus>* _new_StorePackageUpdateStatus(PyTypeObject* subclass, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        auto self = reinterpret_cast<winrt_struct_wrapper<winrt::Windows::Services::Store::StorePackageUpdateStatus>*>(subclass->tp_alloc(subclass, 0));

        if (!self)
        {
            return nullptr;
        }

        std::construct_at(&self->obj);

        return self;
    }

    int _init_StorePackageUpdateStatus(winrt_struct_wrapper<winrt::Windows::Services::Store::StorePackageUpdateStatus>* self, PyObject* args, PyObject* kwds) noexcept
    {
        auto tuple_size = PyTuple_Size(args);

        if ((tuple_size == 0) && (kwds == nullptr))
        {
            self->obj = {};
            return 0;
        }

        winrt::hstring _PackageFamilyName{};
        uint64_t _PackageDownloadSizeInBytes{};
        uint64_t _PackageBytesDownloaded{};
        double _PackageDownloadProgress{};
        double _TotalDownloadProgress{};
        int32_t _PackageUpdateState{};

        static const char* kwlist[] = {"package_family_name", "package_download_size_in_bytes", "package_bytes_downloaded", "package_download_progress", "total_download_progress", "package_update_state", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "uKKddi", const_cast<char**>(kwlist), &_PackageFamilyName, &_PackageDownloadSizeInBytes, &_PackageBytesDownloaded, &_PackageDownloadProgress, &_TotalDownloadProgress, &_PackageUpdateState))
        {
            return -1;
        }

        try
        {
            self->obj = {_PackageFamilyName, _PackageDownloadSizeInBytes, _PackageBytesDownloaded, _PackageDownloadProgress, _TotalDownloadProgress, static_cast<winrt::Windows::Services::Store::StorePackageUpdateState>(_PackageUpdateState)};
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static void _dealloc_StorePackageUpdateStatus(py::wrapper::Windows::Services::Store::StorePackageUpdateStatus* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_StorePackageUpdateStatus(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Services::Store::StorePackageUpdateStatus>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyMethodDef _methods_StorePackageUpdateStatus[] = {
        { "_assign_array_", _assign_array_StorePackageUpdateStatus, METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyObject* StorePackageUpdateStatus_get_PackageFamilyName(py::wrapper::Windows::Services::Store::StorePackageUpdateStatus* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PackageFamilyName);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StorePackageUpdateStatus_set_PackageFamilyName(py::wrapper::Windows::Services::Store::StorePackageUpdateStatus* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.PackageFamilyName = py::converter<winrt::hstring>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StorePackageUpdateStatus_get_PackageDownloadSizeInBytes(py::wrapper::Windows::Services::Store::StorePackageUpdateStatus* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PackageDownloadSizeInBytes);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StorePackageUpdateStatus_set_PackageDownloadSizeInBytes(py::wrapper::Windows::Services::Store::StorePackageUpdateStatus* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.PackageDownloadSizeInBytes = py::converter<uint64_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StorePackageUpdateStatus_get_PackageBytesDownloaded(py::wrapper::Windows::Services::Store::StorePackageUpdateStatus* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PackageBytesDownloaded);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StorePackageUpdateStatus_set_PackageBytesDownloaded(py::wrapper::Windows::Services::Store::StorePackageUpdateStatus* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.PackageBytesDownloaded = py::converter<uint64_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StorePackageUpdateStatus_get_PackageDownloadProgress(py::wrapper::Windows::Services::Store::StorePackageUpdateStatus* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PackageDownloadProgress);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StorePackageUpdateStatus_set_PackageDownloadProgress(py::wrapper::Windows::Services::Store::StorePackageUpdateStatus* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.PackageDownloadProgress = py::converter<double>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StorePackageUpdateStatus_get_TotalDownloadProgress(py::wrapper::Windows::Services::Store::StorePackageUpdateStatus* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TotalDownloadProgress);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StorePackageUpdateStatus_set_TotalDownloadProgress(py::wrapper::Windows::Services::Store::StorePackageUpdateStatus* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.TotalDownloadProgress = py::converter<double>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StorePackageUpdateStatus_get_PackageUpdateState(py::wrapper::Windows::Services::Store::StorePackageUpdateStatus* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PackageUpdateState);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StorePackageUpdateStatus_set_PackageUpdateState(py::wrapper::Windows::Services::Store::StorePackageUpdateStatus* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.PackageUpdateState = py::converter<winrt::Windows::Services::Store::StorePackageUpdateState>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyGetSetDef _getset_StorePackageUpdateStatus[] = {
        { "package_family_name", reinterpret_cast<getter>(StorePackageUpdateStatus_get_PackageFamilyName), reinterpret_cast<setter>(StorePackageUpdateStatus_set_PackageFamilyName), nullptr, nullptr },
        { "package_download_size_in_bytes", reinterpret_cast<getter>(StorePackageUpdateStatus_get_PackageDownloadSizeInBytes), reinterpret_cast<setter>(StorePackageUpdateStatus_set_PackageDownloadSizeInBytes), nullptr, nullptr },
        { "package_bytes_downloaded", reinterpret_cast<getter>(StorePackageUpdateStatus_get_PackageBytesDownloaded), reinterpret_cast<setter>(StorePackageUpdateStatus_set_PackageBytesDownloaded), nullptr, nullptr },
        { "package_download_progress", reinterpret_cast<getter>(StorePackageUpdateStatus_get_PackageDownloadProgress), reinterpret_cast<setter>(StorePackageUpdateStatus_set_PackageDownloadProgress), nullptr, nullptr },
        { "total_download_progress", reinterpret_cast<getter>(StorePackageUpdateStatus_get_TotalDownloadProgress), reinterpret_cast<setter>(StorePackageUpdateStatus_set_TotalDownloadProgress), nullptr, nullptr },
        { "package_update_state", reinterpret_cast<getter>(StorePackageUpdateStatus_get_PackageUpdateState), reinterpret_cast<setter>(StorePackageUpdateStatus_set_PackageUpdateState), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_StorePackageUpdateStatus[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_StorePackageUpdateStatus) },
        { Py_tp_init, reinterpret_cast<void*>(_init_StorePackageUpdateStatus) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_StorePackageUpdateStatus) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_StorePackageUpdateStatus) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_StorePackageUpdateStatus) },
        { },
    };

    static PyType_Spec type_spec_StorePackageUpdateStatus =
    {
        "winrt._winrt_windows_services_store.StorePackageUpdateStatus",
        sizeof(py::wrapper::Windows::Services::Store::StorePackageUpdateStatus),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StorePackageUpdateStatus
    };

    // ----- Windows.Services.Store Initialization --------------------
    PyDoc_STRVAR(module_doc, "Windows::Services::Store");


    static PyModuleDef module_def
        = {PyModuleDef_HEAD_INIT,
           "_winrt_windows_services_store",
           module_doc,
           0,
           nullptr,
           nullptr,
           nullptr,
           nullptr,
           nullptr};

} // py::cpp::Windows::Services::Store

PyMODINIT_FUNC PyInit__winrt_windows_services_store(void) noexcept
{
    using namespace py::cpp::Windows::Services::Store;

    if (py::import_winrt_runtime() == -1)
    {
        return nullptr;
    }

    py::pyobj_handle module{PyModule_Create(&module_def)};

    if (!module)
    {
        return nullptr;
    }

    auto object_type = py::get_object_type();
    if (!object_type)
    {
        return nullptr;
    }

    py::pyobj_handle object_bases{PyTuple_Pack(1, object_type)};

    if (!object_bases)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_StoreAcquireLicenseResult, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_StoreAppLicense, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_StoreAvailability, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_StoreCanAcquireLicenseResult, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_StoreCollectionData, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_StoreConsumableResult, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_StoreContext_Static{PyType_FromSpec(&type_spec_StoreContext_Static)};
    if (!type_StoreContext_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_StoreContext, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_StoreContext_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_StoreImage, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_StoreLicense, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_StorePackageInstallOptions, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_StorePackageLicense, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_StorePackageUpdate, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_StorePackageUpdateResult, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_StorePrice, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_StoreProduct, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_StoreProductOptions, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_StoreProductPagedQueryResult, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_StoreProductQueryResult, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_StoreProductResult, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_StorePurchaseProperties, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_StorePurchaseResult, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_StoreQueueItem, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_StoreQueueItemCompletedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_StoreQueueItemStatus, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_StoreRateAndReviewResult, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_StoreRequestHelper_Static{PyType_FromSpec(&type_spec_StoreRequestHelper_Static)};
    if (!type_StoreRequestHelper_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_StoreRequestHelper, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_StoreRequestHelper_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_StoreSendRequestResult, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_StoreSku, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_StoreSubscriptionInfo, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_StoreUninstallStorePackageResult, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_StoreVideo, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_StorePackageUpdateStatus, nullptr, nullptr) == -1)
    {
        return nullptr;
    }


    return module.detach();
}
