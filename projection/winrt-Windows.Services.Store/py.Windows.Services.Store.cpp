// WARNING: Please don't edit this file. It was generated by Python/WinRT v0.0.0

#include "py.Windows.Services.Store.h"

namespace py::cpp::Windows::Services::Store
{
    // ----- StoreAcquireLicenseResult class --------------------

    static PyObject* _new_StoreAcquireLicenseResult(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Services::Store::StoreAcquireLicenseResult>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Services::Store::StoreAcquireLicenseResult>::type_name);
        return nullptr;
    }

    static void _dealloc_StoreAcquireLicenseResult(py::wrapper::Windows::Services::Store::StoreAcquireLicenseResult* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* StoreAcquireLicenseResult_get_ExtendedError(py::wrapper::Windows::Services::Store::StoreAcquireLicenseResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreAcquireLicenseResult", L"ExtendedError");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ExtendedError();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreAcquireLicenseResult_get_StorePackageLicense(py::wrapper::Windows::Services::Store::StoreAcquireLicenseResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreAcquireLicenseResult", L"StorePackageLicense");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.StorePackageLicense();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_StoreAcquireLicenseResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Services::Store::StoreAcquireLicenseResult>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_StoreAcquireLicenseResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Services::Store::StoreAcquireLicenseResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StoreAcquireLicenseResult[] = {
        { "_assign_array_", _assign_array_StoreAcquireLicenseResult, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_StoreAcquireLicenseResult), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_StoreAcquireLicenseResult[] = {
        { "extended_error", reinterpret_cast<getter>(StoreAcquireLicenseResult_get_ExtendedError), nullptr, nullptr, nullptr },
        { "store_package_license", reinterpret_cast<getter>(StoreAcquireLicenseResult_get_StorePackageLicense), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_StoreAcquireLicenseResult[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_StoreAcquireLicenseResult) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_StoreAcquireLicenseResult) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_StoreAcquireLicenseResult) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_StoreAcquireLicenseResult) },
        { }};

    static PyType_Spec type_spec_StoreAcquireLicenseResult = {
        "winrt._winrt_windows_services_store.StoreAcquireLicenseResult",
        sizeof(py::wrapper::Windows::Services::Store::StoreAcquireLicenseResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StoreAcquireLicenseResult};

    // ----- StoreAppLicense class --------------------

    static PyObject* _new_StoreAppLicense(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Services::Store::StoreAppLicense>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Services::Store::StoreAppLicense>::type_name);
        return nullptr;
    }

    static void _dealloc_StoreAppLicense(py::wrapper::Windows::Services::Store::StoreAppLicense* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* StoreAppLicense_get_AddOnLicenses(py::wrapper::Windows::Services::Store::StoreAppLicense* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreAppLicense", L"AddOnLicenses");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.AddOnLicenses();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreAppLicense_get_ExpirationDate(py::wrapper::Windows::Services::Store::StoreAppLicense* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreAppLicense", L"ExpirationDate");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ExpirationDate();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreAppLicense_get_ExtendedJsonData(py::wrapper::Windows::Services::Store::StoreAppLicense* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreAppLicense", L"ExtendedJsonData");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ExtendedJsonData();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreAppLicense_get_IsActive(py::wrapper::Windows::Services::Store::StoreAppLicense* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreAppLicense", L"IsActive");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsActive();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreAppLicense_get_IsTrial(py::wrapper::Windows::Services::Store::StoreAppLicense* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreAppLicense", L"IsTrial");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsTrial();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreAppLicense_get_IsTrialOwnedByThisUser(py::wrapper::Windows::Services::Store::StoreAppLicense* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreAppLicense", L"IsTrialOwnedByThisUser");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsTrialOwnedByThisUser();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreAppLicense_get_SkuStoreId(py::wrapper::Windows::Services::Store::StoreAppLicense* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreAppLicense", L"SkuStoreId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SkuStoreId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreAppLicense_get_TrialTimeRemaining(py::wrapper::Windows::Services::Store::StoreAppLicense* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreAppLicense", L"TrialTimeRemaining");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.TrialTimeRemaining();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreAppLicense_get_TrialUniqueId(py::wrapper::Windows::Services::Store::StoreAppLicense* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreAppLicense", L"TrialUniqueId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.TrialUniqueId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreAppLicense_get_IsDiscLicense(py::wrapper::Windows::Services::Store::StoreAppLicense* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreAppLicense", L"IsDiscLicense");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsDiscLicense();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_StoreAppLicense(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Services::Store::StoreAppLicense>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_StoreAppLicense(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Services::Store::StoreAppLicense>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StoreAppLicense[] = {
        { "_assign_array_", _assign_array_StoreAppLicense, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_StoreAppLicense), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_StoreAppLicense[] = {
        { "add_on_licenses", reinterpret_cast<getter>(StoreAppLicense_get_AddOnLicenses), nullptr, nullptr, nullptr },
        { "expiration_date", reinterpret_cast<getter>(StoreAppLicense_get_ExpirationDate), nullptr, nullptr, nullptr },
        { "extended_json_data", reinterpret_cast<getter>(StoreAppLicense_get_ExtendedJsonData), nullptr, nullptr, nullptr },
        { "is_active", reinterpret_cast<getter>(StoreAppLicense_get_IsActive), nullptr, nullptr, nullptr },
        { "is_trial", reinterpret_cast<getter>(StoreAppLicense_get_IsTrial), nullptr, nullptr, nullptr },
        { "is_trial_owned_by_this_user", reinterpret_cast<getter>(StoreAppLicense_get_IsTrialOwnedByThisUser), nullptr, nullptr, nullptr },
        { "sku_store_id", reinterpret_cast<getter>(StoreAppLicense_get_SkuStoreId), nullptr, nullptr, nullptr },
        { "trial_time_remaining", reinterpret_cast<getter>(StoreAppLicense_get_TrialTimeRemaining), nullptr, nullptr, nullptr },
        { "trial_unique_id", reinterpret_cast<getter>(StoreAppLicense_get_TrialUniqueId), nullptr, nullptr, nullptr },
        { "is_disc_license", reinterpret_cast<getter>(StoreAppLicense_get_IsDiscLicense), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_StoreAppLicense[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_StoreAppLicense) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_StoreAppLicense) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_StoreAppLicense) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_StoreAppLicense) },
        { }};

    static PyType_Spec type_spec_StoreAppLicense = {
        "winrt._winrt_windows_services_store.StoreAppLicense",
        sizeof(py::wrapper::Windows::Services::Store::StoreAppLicense),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StoreAppLicense};

    // ----- StoreAvailability class --------------------

    static PyObject* _new_StoreAvailability(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Services::Store::StoreAvailability>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Services::Store::StoreAvailability>::type_name);
        return nullptr;
    }

    static void _dealloc_StoreAvailability(py::wrapper::Windows::Services::Store::StoreAvailability* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* StoreAvailability_RequestPurchaseAsync(py::wrapper::Windows::Services::Store::StoreAvailability* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Services.Store.StoreAvailability", L"RequestPurchaseAsync", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.RequestPurchaseAsync();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StoreAvailability_RequestPurchaseWithPurchasePropertiesAsync(py::wrapper::Windows::Services::Store::StoreAvailability* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Services.Store.StoreAvailability", L"RequestPurchaseAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Services::Store::StorePurchaseProperties>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.RequestPurchaseAsync(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StoreAvailability_get_EndDate(py::wrapper::Windows::Services::Store::StoreAvailability* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreAvailability", L"EndDate");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.EndDate();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreAvailability_get_ExtendedJsonData(py::wrapper::Windows::Services::Store::StoreAvailability* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreAvailability", L"ExtendedJsonData");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ExtendedJsonData();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreAvailability_get_Price(py::wrapper::Windows::Services::Store::StoreAvailability* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreAvailability", L"Price");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Price();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreAvailability_get_StoreId(py::wrapper::Windows::Services::Store::StoreAvailability* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreAvailability", L"StoreId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.StoreId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_StoreAvailability(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Services::Store::StoreAvailability>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_StoreAvailability(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Services::Store::StoreAvailability>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StoreAvailability[] = {
        { "request_purchase_async", reinterpret_cast<PyCFunction>(StoreAvailability_RequestPurchaseAsync), METH_VARARGS, nullptr },
        { "request_purchase_with_purchase_properties_async", reinterpret_cast<PyCFunction>(StoreAvailability_RequestPurchaseWithPurchasePropertiesAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_StoreAvailability, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_StoreAvailability), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_StoreAvailability[] = {
        { "end_date", reinterpret_cast<getter>(StoreAvailability_get_EndDate), nullptr, nullptr, nullptr },
        { "extended_json_data", reinterpret_cast<getter>(StoreAvailability_get_ExtendedJsonData), nullptr, nullptr, nullptr },
        { "price", reinterpret_cast<getter>(StoreAvailability_get_Price), nullptr, nullptr, nullptr },
        { "store_id", reinterpret_cast<getter>(StoreAvailability_get_StoreId), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_StoreAvailability[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_StoreAvailability) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_StoreAvailability) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_StoreAvailability) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_StoreAvailability) },
        { }};

    static PyType_Spec type_spec_StoreAvailability = {
        "winrt._winrt_windows_services_store.StoreAvailability",
        sizeof(py::wrapper::Windows::Services::Store::StoreAvailability),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StoreAvailability};

    // ----- StoreCanAcquireLicenseResult class --------------------

    static PyObject* _new_StoreCanAcquireLicenseResult(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Services::Store::StoreCanAcquireLicenseResult>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Services::Store::StoreCanAcquireLicenseResult>::type_name);
        return nullptr;
    }

    static void _dealloc_StoreCanAcquireLicenseResult(py::wrapper::Windows::Services::Store::StoreCanAcquireLicenseResult* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* StoreCanAcquireLicenseResult_get_ExtendedError(py::wrapper::Windows::Services::Store::StoreCanAcquireLicenseResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreCanAcquireLicenseResult", L"ExtendedError");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ExtendedError();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreCanAcquireLicenseResult_get_LicensableSku(py::wrapper::Windows::Services::Store::StoreCanAcquireLicenseResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreCanAcquireLicenseResult", L"LicensableSku");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.LicensableSku();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreCanAcquireLicenseResult_get_Status(py::wrapper::Windows::Services::Store::StoreCanAcquireLicenseResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreCanAcquireLicenseResult", L"Status");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Status();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_StoreCanAcquireLicenseResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Services::Store::StoreCanAcquireLicenseResult>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_StoreCanAcquireLicenseResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Services::Store::StoreCanAcquireLicenseResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StoreCanAcquireLicenseResult[] = {
        { "_assign_array_", _assign_array_StoreCanAcquireLicenseResult, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_StoreCanAcquireLicenseResult), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_StoreCanAcquireLicenseResult[] = {
        { "extended_error", reinterpret_cast<getter>(StoreCanAcquireLicenseResult_get_ExtendedError), nullptr, nullptr, nullptr },
        { "licensable_sku", reinterpret_cast<getter>(StoreCanAcquireLicenseResult_get_LicensableSku), nullptr, nullptr, nullptr },
        { "status", reinterpret_cast<getter>(StoreCanAcquireLicenseResult_get_Status), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_StoreCanAcquireLicenseResult[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_StoreCanAcquireLicenseResult) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_StoreCanAcquireLicenseResult) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_StoreCanAcquireLicenseResult) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_StoreCanAcquireLicenseResult) },
        { }};

    static PyType_Spec type_spec_StoreCanAcquireLicenseResult = {
        "winrt._winrt_windows_services_store.StoreCanAcquireLicenseResult",
        sizeof(py::wrapper::Windows::Services::Store::StoreCanAcquireLicenseResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StoreCanAcquireLicenseResult};

    // ----- StoreCollectionData class --------------------

    static PyObject* _new_StoreCollectionData(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Services::Store::StoreCollectionData>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Services::Store::StoreCollectionData>::type_name);
        return nullptr;
    }

    static void _dealloc_StoreCollectionData(py::wrapper::Windows::Services::Store::StoreCollectionData* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* StoreCollectionData_get_AcquiredDate(py::wrapper::Windows::Services::Store::StoreCollectionData* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreCollectionData", L"AcquiredDate");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.AcquiredDate();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreCollectionData_get_CampaignId(py::wrapper::Windows::Services::Store::StoreCollectionData* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreCollectionData", L"CampaignId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.CampaignId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreCollectionData_get_DeveloperOfferId(py::wrapper::Windows::Services::Store::StoreCollectionData* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreCollectionData", L"DeveloperOfferId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.DeveloperOfferId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreCollectionData_get_EndDate(py::wrapper::Windows::Services::Store::StoreCollectionData* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreCollectionData", L"EndDate");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.EndDate();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreCollectionData_get_ExtendedJsonData(py::wrapper::Windows::Services::Store::StoreCollectionData* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreCollectionData", L"ExtendedJsonData");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ExtendedJsonData();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreCollectionData_get_IsTrial(py::wrapper::Windows::Services::Store::StoreCollectionData* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreCollectionData", L"IsTrial");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsTrial();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreCollectionData_get_StartDate(py::wrapper::Windows::Services::Store::StoreCollectionData* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreCollectionData", L"StartDate");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.StartDate();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreCollectionData_get_TrialTimeRemaining(py::wrapper::Windows::Services::Store::StoreCollectionData* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreCollectionData", L"TrialTimeRemaining");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.TrialTimeRemaining();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_StoreCollectionData(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Services::Store::StoreCollectionData>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_StoreCollectionData(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Services::Store::StoreCollectionData>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StoreCollectionData[] = {
        { "_assign_array_", _assign_array_StoreCollectionData, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_StoreCollectionData), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_StoreCollectionData[] = {
        { "acquired_date", reinterpret_cast<getter>(StoreCollectionData_get_AcquiredDate), nullptr, nullptr, nullptr },
        { "campaign_id", reinterpret_cast<getter>(StoreCollectionData_get_CampaignId), nullptr, nullptr, nullptr },
        { "developer_offer_id", reinterpret_cast<getter>(StoreCollectionData_get_DeveloperOfferId), nullptr, nullptr, nullptr },
        { "end_date", reinterpret_cast<getter>(StoreCollectionData_get_EndDate), nullptr, nullptr, nullptr },
        { "extended_json_data", reinterpret_cast<getter>(StoreCollectionData_get_ExtendedJsonData), nullptr, nullptr, nullptr },
        { "is_trial", reinterpret_cast<getter>(StoreCollectionData_get_IsTrial), nullptr, nullptr, nullptr },
        { "start_date", reinterpret_cast<getter>(StoreCollectionData_get_StartDate), nullptr, nullptr, nullptr },
        { "trial_time_remaining", reinterpret_cast<getter>(StoreCollectionData_get_TrialTimeRemaining), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_StoreCollectionData[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_StoreCollectionData) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_StoreCollectionData) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_StoreCollectionData) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_StoreCollectionData) },
        { }};

    static PyType_Spec type_spec_StoreCollectionData = {
        "winrt._winrt_windows_services_store.StoreCollectionData",
        sizeof(py::wrapper::Windows::Services::Store::StoreCollectionData),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StoreCollectionData};

    // ----- StoreConsumableResult class --------------------

    static PyObject* _new_StoreConsumableResult(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Services::Store::StoreConsumableResult>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Services::Store::StoreConsumableResult>::type_name);
        return nullptr;
    }

    static void _dealloc_StoreConsumableResult(py::wrapper::Windows::Services::Store::StoreConsumableResult* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* StoreConsumableResult_get_BalanceRemaining(py::wrapper::Windows::Services::Store::StoreConsumableResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreConsumableResult", L"BalanceRemaining");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.BalanceRemaining();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreConsumableResult_get_ExtendedError(py::wrapper::Windows::Services::Store::StoreConsumableResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreConsumableResult", L"ExtendedError");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ExtendedError();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreConsumableResult_get_Status(py::wrapper::Windows::Services::Store::StoreConsumableResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreConsumableResult", L"Status");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Status();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreConsumableResult_get_TrackingId(py::wrapper::Windows::Services::Store::StoreConsumableResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreConsumableResult", L"TrackingId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.TrackingId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_StoreConsumableResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Services::Store::StoreConsumableResult>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_StoreConsumableResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Services::Store::StoreConsumableResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StoreConsumableResult[] = {
        { "_assign_array_", _assign_array_StoreConsumableResult, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_StoreConsumableResult), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_StoreConsumableResult[] = {
        { "balance_remaining", reinterpret_cast<getter>(StoreConsumableResult_get_BalanceRemaining), nullptr, nullptr, nullptr },
        { "extended_error", reinterpret_cast<getter>(StoreConsumableResult_get_ExtendedError), nullptr, nullptr, nullptr },
        { "status", reinterpret_cast<getter>(StoreConsumableResult_get_Status), nullptr, nullptr, nullptr },
        { "tracking_id", reinterpret_cast<getter>(StoreConsumableResult_get_TrackingId), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_StoreConsumableResult[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_StoreConsumableResult) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_StoreConsumableResult) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_StoreConsumableResult) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_StoreConsumableResult) },
        { }};

    static PyType_Spec type_spec_StoreConsumableResult = {
        "winrt._winrt_windows_services_store.StoreConsumableResult",
        sizeof(py::wrapper::Windows::Services::Store::StoreConsumableResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StoreConsumableResult};

    // ----- StoreContext class --------------------

    static PyObject* _new_StoreContext(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Services::Store::StoreContext>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Services::Store::StoreContext>::type_name);
        return nullptr;
    }

    static void _dealloc_StoreContext(py::wrapper::Windows::Services::Store::StoreContext* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* StoreContext_AcquireStoreLicenseForOptionalPackageAsync(py::wrapper::Windows::Services::Store::StoreContext* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Services.Store.StoreContext", L"AcquireStoreLicenseForOptionalPackageAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Package>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.AcquireStoreLicenseForOptionalPackageAsync(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StoreContext_CanAcquireStoreLicenseAsync(py::wrapper::Windows::Services::Store::StoreContext* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Services.Store.StoreContext", L"CanAcquireStoreLicenseAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.CanAcquireStoreLicenseAsync(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StoreContext_CanAcquireStoreLicenseForOptionalPackageAsync(py::wrapper::Windows::Services::Store::StoreContext* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Services.Store.StoreContext", L"CanAcquireStoreLicenseForOptionalPackageAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Package>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.CanAcquireStoreLicenseForOptionalPackageAsync(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StoreContext_DownloadAndInstallStorePackagesAsync(py::wrapper::Windows::Services::Store::StoreContext* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Services.Store.StoreContext", L"DownloadAndInstallStorePackagesAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.DownloadAndInstallStorePackagesAsync(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StoreContext_FindStoreProductForPackageAsync(py::wrapper::Windows::Services::Store::StoreContext* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Services.Store.StoreContext", L"FindStoreProductForPackageAsync", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::ApplicationModel::Package>(args, 1);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.FindStoreProductForPackageAsync(param0, param1);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StoreContext_GetAppAndOptionalStorePackageUpdatesAsync(py::wrapper::Windows::Services::Store::StoreContext* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Services.Store.StoreContext", L"GetAppAndOptionalStorePackageUpdatesAsync", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetAppAndOptionalStorePackageUpdatesAsync();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StoreContext_GetAppLicenseAsync(py::wrapper::Windows::Services::Store::StoreContext* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Services.Store.StoreContext", L"GetAppLicenseAsync", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetAppLicenseAsync();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StoreContext_GetAssociatedStoreProductsAsync(py::wrapper::Windows::Services::Store::StoreContext* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Services.Store.StoreContext", L"GetAssociatedStoreProductsAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetAssociatedStoreProductsAsync(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StoreContext_GetAssociatedStoreProductsByInAppOfferTokenAsync(py::wrapper::Windows::Services::Store::StoreContext* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Services.Store.StoreContext", L"GetAssociatedStoreProductsByInAppOfferTokenAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetAssociatedStoreProductsByInAppOfferTokenAsync(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StoreContext_GetAssociatedStoreProductsWithPagingAsync(py::wrapper::Windows::Services::Store::StoreContext* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Services.Store.StoreContext", L"GetAssociatedStoreProductsWithPagingAsync", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetAssociatedStoreProductsWithPagingAsync(param0, param1);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StoreContext_GetAssociatedStoreQueueItemsAsync(py::wrapper::Windows::Services::Store::StoreContext* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Services.Store.StoreContext", L"GetAssociatedStoreQueueItemsAsync", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetAssociatedStoreQueueItemsAsync();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StoreContext_GetConsumableBalanceRemainingAsync(py::wrapper::Windows::Services::Store::StoreContext* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Services.Store.StoreContext", L"GetConsumableBalanceRemainingAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetConsumableBalanceRemainingAsync(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StoreContext_GetCustomerCollectionsIdAsync(py::wrapper::Windows::Services::Store::StoreContext* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Services.Store.StoreContext", L"GetCustomerCollectionsIdAsync", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetCustomerCollectionsIdAsync(param0, param1);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StoreContext_GetCustomerPurchaseIdAsync(py::wrapper::Windows::Services::Store::StoreContext* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Services.Store.StoreContext", L"GetCustomerPurchaseIdAsync", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetCustomerPurchaseIdAsync(param0, param1);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StoreContext_GetDefault(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Services.Store.StoreContext", L"GetDefault", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::Services::Store::StoreContext::GetDefault();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StoreContext_GetForUser(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Services.Store.StoreContext", L"GetForUser", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::System::User>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::Services::Store::StoreContext::GetForUser(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StoreContext_GetStoreProductForCurrentAppAsync(py::wrapper::Windows::Services::Store::StoreContext* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Services.Store.StoreContext", L"GetStoreProductForCurrentAppAsync", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetStoreProductForCurrentAppAsync();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StoreContext_GetStoreProductsAsync(py::wrapper::Windows::Services::Store::StoreContext* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Services.Store.StoreContext", L"GetStoreProductsAsync", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 1);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetStoreProductsAsync(param0, param1);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StoreContext_GetStoreProductsWithOptionsAsync(py::wrapper::Windows::Services::Store::StoreContext* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Services.Store.StoreContext", L"GetStoreProductsAsync", 3);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Services::Store::StoreProductOptions>(args, 2);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetStoreProductsAsync(param0, param1, param2);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StoreContext_GetStoreQueueItemsAsync(py::wrapper::Windows::Services::Store::StoreContext* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Services.Store.StoreContext", L"GetStoreQueueItemsAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetStoreQueueItemsAsync(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StoreContext_GetUserCollectionAsync(py::wrapper::Windows::Services::Store::StoreContext* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Services.Store.StoreContext", L"GetUserCollectionAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetUserCollectionAsync(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StoreContext_GetUserCollectionWithPagingAsync(py::wrapper::Windows::Services::Store::StoreContext* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Services.Store.StoreContext", L"GetUserCollectionWithPagingAsync", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetUserCollectionWithPagingAsync(param0, param1);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StoreContext_GetUserPurchaseHistoryAsync(py::wrapper::Windows::Services::Store::StoreContext* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Services.Store.StoreContext", L"GetUserPurchaseHistoryAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetUserPurchaseHistoryAsync(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StoreContext_ReportConsumableFulfillmentAsync(py::wrapper::Windows::Services::Store::StoreContext* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Services.Store.StoreContext", L"ReportConsumableFulfillmentAsync", 3);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);
                auto param2 = py::convert_to<winrt::guid>(args, 2);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.ReportConsumableFulfillmentAsync(param0, param1, param2);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StoreContext_RequestDownloadAndInstallStorePackageUpdatesAsync(py::wrapper::Windows::Services::Store::StoreContext* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Services.Store.StoreContext", L"RequestDownloadAndInstallStorePackageUpdatesAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Services::Store::StorePackageUpdate>>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.RequestDownloadAndInstallStorePackageUpdatesAsync(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StoreContext_RequestDownloadAndInstallStorePackagesAsync(py::wrapper::Windows::Services::Store::StoreContext* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Services.Store.StoreContext", L"RequestDownloadAndInstallStorePackagesAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.RequestDownloadAndInstallStorePackagesAsync(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StoreContext_RequestDownloadAndInstallStorePackagesWithInstallOptionsAsync(py::wrapper::Windows::Services::Store::StoreContext* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Services.Store.StoreContext", L"RequestDownloadAndInstallStorePackagesAsync", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Services::Store::StorePackageInstallOptions>(args, 1);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.RequestDownloadAndInstallStorePackagesAsync(param0, param1);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StoreContext_RequestDownloadStorePackageUpdatesAsync(py::wrapper::Windows::Services::Store::StoreContext* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Services.Store.StoreContext", L"RequestDownloadStorePackageUpdatesAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Services::Store::StorePackageUpdate>>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.RequestDownloadStorePackageUpdatesAsync(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StoreContext_RequestPurchaseAsync(py::wrapper::Windows::Services::Store::StoreContext* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Services.Store.StoreContext", L"RequestPurchaseAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.RequestPurchaseAsync(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StoreContext_RequestPurchaseByInAppOfferTokenAsync(py::wrapper::Windows::Services::Store::StoreContext* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Services.Store.StoreContext", L"RequestPurchaseByInAppOfferTokenAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.RequestPurchaseByInAppOfferTokenAsync(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StoreContext_RequestPurchaseWithPurchasePropertiesAsync(py::wrapper::Windows::Services::Store::StoreContext* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Services.Store.StoreContext", L"RequestPurchaseAsync", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Services::Store::StorePurchaseProperties>(args, 1);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.RequestPurchaseAsync(param0, param1);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StoreContext_RequestRateAndReviewAppAsync(py::wrapper::Windows::Services::Store::StoreContext* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Services.Store.StoreContext", L"RequestRateAndReviewAppAsync", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.RequestRateAndReviewAppAsync();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StoreContext_RequestUninstallStorePackageAsync(py::wrapper::Windows::Services::Store::StoreContext* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Services.Store.StoreContext", L"RequestUninstallStorePackageAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Package>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.RequestUninstallStorePackageAsync(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StoreContext_RequestUninstallStorePackageByStoreIdAsync(py::wrapper::Windows::Services::Store::StoreContext* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Services.Store.StoreContext", L"RequestUninstallStorePackageByStoreIdAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.RequestUninstallStorePackageByStoreIdAsync(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StoreContext_SetInstallOrderForAssociatedStoreQueueItemsAsync(py::wrapper::Windows::Services::Store::StoreContext* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Services.Store.StoreContext", L"SetInstallOrderForAssociatedStoreQueueItemsAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Services::Store::StoreQueueItem>>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.SetInstallOrderForAssociatedStoreQueueItemsAsync(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StoreContext_TrySilentDownloadAndInstallStorePackageUpdatesAsync(py::wrapper::Windows::Services::Store::StoreContext* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Services.Store.StoreContext", L"TrySilentDownloadAndInstallStorePackageUpdatesAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Services::Store::StorePackageUpdate>>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.TrySilentDownloadAndInstallStorePackageUpdatesAsync(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StoreContext_TrySilentDownloadStorePackageUpdatesAsync(py::wrapper::Windows::Services::Store::StoreContext* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Services.Store.StoreContext", L"TrySilentDownloadStorePackageUpdatesAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Services::Store::StorePackageUpdate>>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.TrySilentDownloadStorePackageUpdatesAsync(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StoreContext_UninstallStorePackageAsync(py::wrapper::Windows::Services::Store::StoreContext* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Services.Store.StoreContext", L"UninstallStorePackageAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Package>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.UninstallStorePackageAsync(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StoreContext_UninstallStorePackageByStoreIdAsync(py::wrapper::Windows::Services::Store::StoreContext* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Services.Store.StoreContext", L"UninstallStorePackageByStoreIdAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.UninstallStorePackageByStoreIdAsync(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StoreContext_get_User(py::wrapper::Windows::Services::Store::StoreContext* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreContext", L"User");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.User();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreContext_get_CanSilentlyDownloadStorePackageUpdates(py::wrapper::Windows::Services::Store::StoreContext* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreContext", L"CanSilentlyDownloadStorePackageUpdates");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.CanSilentlyDownloadStorePackageUpdates();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreContext_add_OfflineLicensesChanged(py::wrapper::Windows::Services::Store::StoreContext* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Services.Store.StoreContext", L"OfflineLicensesChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Services::Store::StoreContext, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.OfflineLicensesChanged(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreContext_remove_OfflineLicensesChanged(py::wrapper::Windows::Services::Store::StoreContext* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Services.Store.StoreContext", L"OfflineLicensesChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.OfflineLicensesChanged(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_StoreContext(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Services::Store::StoreContext>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_StoreContext(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Services::Store::StoreContext>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StoreContext[] = {
        { "acquire_store_license_for_optional_package_async", reinterpret_cast<PyCFunction>(StoreContext_AcquireStoreLicenseForOptionalPackageAsync), METH_VARARGS, nullptr },
        { "can_acquire_store_license_async", reinterpret_cast<PyCFunction>(StoreContext_CanAcquireStoreLicenseAsync), METH_VARARGS, nullptr },
        { "can_acquire_store_license_for_optional_package_async", reinterpret_cast<PyCFunction>(StoreContext_CanAcquireStoreLicenseForOptionalPackageAsync), METH_VARARGS, nullptr },
        { "download_and_install_store_packages_async", reinterpret_cast<PyCFunction>(StoreContext_DownloadAndInstallStorePackagesAsync), METH_VARARGS, nullptr },
        { "find_store_product_for_package_async", reinterpret_cast<PyCFunction>(StoreContext_FindStoreProductForPackageAsync), METH_VARARGS, nullptr },
        { "get_app_and_optional_store_package_updates_async", reinterpret_cast<PyCFunction>(StoreContext_GetAppAndOptionalStorePackageUpdatesAsync), METH_VARARGS, nullptr },
        { "get_app_license_async", reinterpret_cast<PyCFunction>(StoreContext_GetAppLicenseAsync), METH_VARARGS, nullptr },
        { "get_associated_store_products_async", reinterpret_cast<PyCFunction>(StoreContext_GetAssociatedStoreProductsAsync), METH_VARARGS, nullptr },
        { "get_associated_store_products_by_in_app_offer_token_async", reinterpret_cast<PyCFunction>(StoreContext_GetAssociatedStoreProductsByInAppOfferTokenAsync), METH_VARARGS, nullptr },
        { "get_associated_store_products_with_paging_async", reinterpret_cast<PyCFunction>(StoreContext_GetAssociatedStoreProductsWithPagingAsync), METH_VARARGS, nullptr },
        { "get_associated_store_queue_items_async", reinterpret_cast<PyCFunction>(StoreContext_GetAssociatedStoreQueueItemsAsync), METH_VARARGS, nullptr },
        { "get_consumable_balance_remaining_async", reinterpret_cast<PyCFunction>(StoreContext_GetConsumableBalanceRemainingAsync), METH_VARARGS, nullptr },
        { "get_customer_collections_id_async", reinterpret_cast<PyCFunction>(StoreContext_GetCustomerCollectionsIdAsync), METH_VARARGS, nullptr },
        { "get_customer_purchase_id_async", reinterpret_cast<PyCFunction>(StoreContext_GetCustomerPurchaseIdAsync), METH_VARARGS, nullptr },
        { "get_store_product_for_current_app_async", reinterpret_cast<PyCFunction>(StoreContext_GetStoreProductForCurrentAppAsync), METH_VARARGS, nullptr },
        { "get_store_products_async", reinterpret_cast<PyCFunction>(StoreContext_GetStoreProductsAsync), METH_VARARGS, nullptr },
        { "get_store_products_with_options_async", reinterpret_cast<PyCFunction>(StoreContext_GetStoreProductsWithOptionsAsync), METH_VARARGS, nullptr },
        { "get_store_queue_items_async", reinterpret_cast<PyCFunction>(StoreContext_GetStoreQueueItemsAsync), METH_VARARGS, nullptr },
        { "get_user_collection_async", reinterpret_cast<PyCFunction>(StoreContext_GetUserCollectionAsync), METH_VARARGS, nullptr },
        { "get_user_collection_with_paging_async", reinterpret_cast<PyCFunction>(StoreContext_GetUserCollectionWithPagingAsync), METH_VARARGS, nullptr },
        { "get_user_purchase_history_async", reinterpret_cast<PyCFunction>(StoreContext_GetUserPurchaseHistoryAsync), METH_VARARGS, nullptr },
        { "report_consumable_fulfillment_async", reinterpret_cast<PyCFunction>(StoreContext_ReportConsumableFulfillmentAsync), METH_VARARGS, nullptr },
        { "request_download_and_install_store_package_updates_async", reinterpret_cast<PyCFunction>(StoreContext_RequestDownloadAndInstallStorePackageUpdatesAsync), METH_VARARGS, nullptr },
        { "request_download_and_install_store_packages_async", reinterpret_cast<PyCFunction>(StoreContext_RequestDownloadAndInstallStorePackagesAsync), METH_VARARGS, nullptr },
        { "request_download_and_install_store_packages_with_install_options_async", reinterpret_cast<PyCFunction>(StoreContext_RequestDownloadAndInstallStorePackagesWithInstallOptionsAsync), METH_VARARGS, nullptr },
        { "request_download_store_package_updates_async", reinterpret_cast<PyCFunction>(StoreContext_RequestDownloadStorePackageUpdatesAsync), METH_VARARGS, nullptr },
        { "request_purchase_async", reinterpret_cast<PyCFunction>(StoreContext_RequestPurchaseAsync), METH_VARARGS, nullptr },
        { "request_purchase_by_in_app_offer_token_async", reinterpret_cast<PyCFunction>(StoreContext_RequestPurchaseByInAppOfferTokenAsync), METH_VARARGS, nullptr },
        { "request_purchase_with_purchase_properties_async", reinterpret_cast<PyCFunction>(StoreContext_RequestPurchaseWithPurchasePropertiesAsync), METH_VARARGS, nullptr },
        { "request_rate_and_review_app_async", reinterpret_cast<PyCFunction>(StoreContext_RequestRateAndReviewAppAsync), METH_VARARGS, nullptr },
        { "request_uninstall_store_package_async", reinterpret_cast<PyCFunction>(StoreContext_RequestUninstallStorePackageAsync), METH_VARARGS, nullptr },
        { "request_uninstall_store_package_by_store_id_async", reinterpret_cast<PyCFunction>(StoreContext_RequestUninstallStorePackageByStoreIdAsync), METH_VARARGS, nullptr },
        { "set_install_order_for_associated_store_queue_items_async", reinterpret_cast<PyCFunction>(StoreContext_SetInstallOrderForAssociatedStoreQueueItemsAsync), METH_VARARGS, nullptr },
        { "try_silent_download_and_install_store_package_updates_async", reinterpret_cast<PyCFunction>(StoreContext_TrySilentDownloadAndInstallStorePackageUpdatesAsync), METH_VARARGS, nullptr },
        { "try_silent_download_store_package_updates_async", reinterpret_cast<PyCFunction>(StoreContext_TrySilentDownloadStorePackageUpdatesAsync), METH_VARARGS, nullptr },
        { "uninstall_store_package_async", reinterpret_cast<PyCFunction>(StoreContext_UninstallStorePackageAsync), METH_VARARGS, nullptr },
        { "uninstall_store_package_by_store_id_async", reinterpret_cast<PyCFunction>(StoreContext_UninstallStorePackageByStoreIdAsync), METH_VARARGS, nullptr },
        { "add_offline_licenses_changed", reinterpret_cast<PyCFunction>(StoreContext_add_OfflineLicensesChanged), METH_O, nullptr },
        { "remove_offline_licenses_changed", reinterpret_cast<PyCFunction>(StoreContext_remove_OfflineLicensesChanged), METH_O, nullptr },
        { "_assign_array_", _assign_array_StoreContext, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_StoreContext), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_StoreContext[] = {
        { "user", reinterpret_cast<getter>(StoreContext_get_User), nullptr, nullptr, nullptr },
        { "can_silently_download_store_package_updates", reinterpret_cast<getter>(StoreContext_get_CanSilentlyDownloadStorePackageUpdates), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_StoreContext[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_StoreContext) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_StoreContext) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_StoreContext) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_StoreContext) },
        { }};

    static PyType_Spec type_spec_StoreContext = {
        "winrt._winrt_windows_services_store.StoreContext",
        sizeof(py::wrapper::Windows::Services::Store::StoreContext),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StoreContext};

    static PyGetSetDef getset_StoreContext_Static[] = {
        { }};

    static PyMethodDef methods_StoreContext_Static[] = {
        { "get_default", reinterpret_cast<PyCFunction>(StoreContext_GetDefault), METH_VARARGS, nullptr },
        { "get_for_user", reinterpret_cast<PyCFunction>(StoreContext_GetForUser), METH_VARARGS, nullptr },
        { }};

    static PyType_Slot type_slots_StoreContext_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_StoreContext_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_StoreContext_Static) },
        { }
    };

    static PyType_Spec type_spec_StoreContext_Static = {
        "winrt._winrt_windows_services_store.StoreContext_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_StoreContext_Static};

    // ----- StoreImage class --------------------

    static PyObject* _new_StoreImage(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Services::Store::StoreImage>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Services::Store::StoreImage>::type_name);
        return nullptr;
    }

    static void _dealloc_StoreImage(py::wrapper::Windows::Services::Store::StoreImage* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* StoreImage_get_Caption(py::wrapper::Windows::Services::Store::StoreImage* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreImage", L"Caption");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Caption();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreImage_get_Height(py::wrapper::Windows::Services::Store::StoreImage* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreImage", L"Height");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Height();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreImage_get_ImagePurposeTag(py::wrapper::Windows::Services::Store::StoreImage* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreImage", L"ImagePurposeTag");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ImagePurposeTag();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreImage_get_Uri(py::wrapper::Windows::Services::Store::StoreImage* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreImage", L"Uri");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Uri();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreImage_get_Width(py::wrapper::Windows::Services::Store::StoreImage* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreImage", L"Width");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Width();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_StoreImage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Services::Store::StoreImage>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_StoreImage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Services::Store::StoreImage>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StoreImage[] = {
        { "_assign_array_", _assign_array_StoreImage, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_StoreImage), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_StoreImage[] = {
        { "caption", reinterpret_cast<getter>(StoreImage_get_Caption), nullptr, nullptr, nullptr },
        { "height", reinterpret_cast<getter>(StoreImage_get_Height), nullptr, nullptr, nullptr },
        { "image_purpose_tag", reinterpret_cast<getter>(StoreImage_get_ImagePurposeTag), nullptr, nullptr, nullptr },
        { "uri", reinterpret_cast<getter>(StoreImage_get_Uri), nullptr, nullptr, nullptr },
        { "width", reinterpret_cast<getter>(StoreImage_get_Width), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_StoreImage[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_StoreImage) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_StoreImage) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_StoreImage) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_StoreImage) },
        { }};

    static PyType_Spec type_spec_StoreImage = {
        "winrt._winrt_windows_services_store.StoreImage",
        sizeof(py::wrapper::Windows::Services::Store::StoreImage),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StoreImage};

    // ----- StoreLicense class --------------------

    static PyObject* _new_StoreLicense(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Services::Store::StoreLicense>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Services::Store::StoreLicense>::type_name);
        return nullptr;
    }

    static void _dealloc_StoreLicense(py::wrapper::Windows::Services::Store::StoreLicense* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* StoreLicense_get_ExpirationDate(py::wrapper::Windows::Services::Store::StoreLicense* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreLicense", L"ExpirationDate");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ExpirationDate();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreLicense_get_ExtendedJsonData(py::wrapper::Windows::Services::Store::StoreLicense* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreLicense", L"ExtendedJsonData");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ExtendedJsonData();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreLicense_get_InAppOfferToken(py::wrapper::Windows::Services::Store::StoreLicense* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreLicense", L"InAppOfferToken");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.InAppOfferToken();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreLicense_get_IsActive(py::wrapper::Windows::Services::Store::StoreLicense* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreLicense", L"IsActive");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsActive();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreLicense_get_SkuStoreId(py::wrapper::Windows::Services::Store::StoreLicense* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreLicense", L"SkuStoreId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SkuStoreId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_StoreLicense(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Services::Store::StoreLicense>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_StoreLicense(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Services::Store::StoreLicense>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StoreLicense[] = {
        { "_assign_array_", _assign_array_StoreLicense, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_StoreLicense), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_StoreLicense[] = {
        { "expiration_date", reinterpret_cast<getter>(StoreLicense_get_ExpirationDate), nullptr, nullptr, nullptr },
        { "extended_json_data", reinterpret_cast<getter>(StoreLicense_get_ExtendedJsonData), nullptr, nullptr, nullptr },
        { "in_app_offer_token", reinterpret_cast<getter>(StoreLicense_get_InAppOfferToken), nullptr, nullptr, nullptr },
        { "is_active", reinterpret_cast<getter>(StoreLicense_get_IsActive), nullptr, nullptr, nullptr },
        { "sku_store_id", reinterpret_cast<getter>(StoreLicense_get_SkuStoreId), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_StoreLicense[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_StoreLicense) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_StoreLicense) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_StoreLicense) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_StoreLicense) },
        { }};

    static PyType_Spec type_spec_StoreLicense = {
        "winrt._winrt_windows_services_store.StoreLicense",
        sizeof(py::wrapper::Windows::Services::Store::StoreLicense),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StoreLicense};

    // ----- StorePackageInstallOptions class --------------------

    static PyObject* _new_StorePackageInstallOptions(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Services::Store::StorePackageInstallOptions instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_StorePackageInstallOptions(py::wrapper::Windows::Services::Store::StorePackageInstallOptions* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* StorePackageInstallOptions_get_AllowForcedAppRestart(py::wrapper::Windows::Services::Store::StorePackageInstallOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StorePackageInstallOptions", L"AllowForcedAppRestart");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.AllowForcedAppRestart();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StorePackageInstallOptions_put_AllowForcedAppRestart(py::wrapper::Windows::Services::Store::StorePackageInstallOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StorePackageInstallOptions", L"AllowForcedAppRestart");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.AllowForcedAppRestart(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_StorePackageInstallOptions(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Services::Store::StorePackageInstallOptions>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_StorePackageInstallOptions(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Services::Store::StorePackageInstallOptions>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StorePackageInstallOptions[] = {
        { "_assign_array_", _assign_array_StorePackageInstallOptions, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_StorePackageInstallOptions), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_StorePackageInstallOptions[] = {
        { "allow_forced_app_restart", reinterpret_cast<getter>(StorePackageInstallOptions_get_AllowForcedAppRestart), reinterpret_cast<setter>(StorePackageInstallOptions_put_AllowForcedAppRestart), nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_StorePackageInstallOptions[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_StorePackageInstallOptions) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_StorePackageInstallOptions) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_StorePackageInstallOptions) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_StorePackageInstallOptions) },
        { }};

    static PyType_Spec type_spec_StorePackageInstallOptions = {
        "winrt._winrt_windows_services_store.StorePackageInstallOptions",
        sizeof(py::wrapper::Windows::Services::Store::StorePackageInstallOptions),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StorePackageInstallOptions};

    // ----- StorePackageLicense class --------------------

    static PyObject* _new_StorePackageLicense(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Services::Store::StorePackageLicense>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Services::Store::StorePackageLicense>::type_name);
        return nullptr;
    }

    static void _dealloc_StorePackageLicense(py::wrapper::Windows::Services::Store::StorePackageLicense* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* StorePackageLicense_Close(py::wrapper::Windows::Services::Store::StorePackageLicense* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Services.Store.StorePackageLicense", L"Close", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.Close();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorePackageLicense_ReleaseLicense(py::wrapper::Windows::Services::Store::StorePackageLicense* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Services.Store.StorePackageLicense", L"ReleaseLicense", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.ReleaseLicense();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorePackageLicense_get_IsValid(py::wrapper::Windows::Services::Store::StorePackageLicense* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StorePackageLicense", L"IsValid");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsValid();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StorePackageLicense_get_Package(py::wrapper::Windows::Services::Store::StorePackageLicense* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StorePackageLicense", L"Package");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Package();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StorePackageLicense_add_LicenseLost(py::wrapper::Windows::Services::Store::StorePackageLicense* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Services.Store.StorePackageLicense", L"LicenseLost");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Services::Store::StorePackageLicense, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.LicenseLost(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StorePackageLicense_remove_LicenseLost(py::wrapper::Windows::Services::Store::StorePackageLicense* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Services.Store.StorePackageLicense", L"LicenseLost");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.LicenseLost(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_StorePackageLicense(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Services::Store::StorePackageLicense>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_StorePackageLicense(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Services::Store::StorePackageLicense>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_StorePackageLicense(py::wrapper::Windows::Services::Store::StorePackageLicense* self, PyObject* /*unused*/) noexcept
    {
        return Py_NewRef(self);
    }

    static PyObject* _exit_StorePackageLicense(py::wrapper::Windows::Services::Store::StorePackageLicense* self, PyObject* /*unused*/) noexcept
    {
        try
        {
            {
                auto _gil = py::release_gil();
                self->obj.Close();
            }

            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StorePackageLicense[] = {
        { "close", reinterpret_cast<PyCFunction>(StorePackageLicense_Close), METH_VARARGS, nullptr },
        { "release_license", reinterpret_cast<PyCFunction>(StorePackageLicense_ReleaseLicense), METH_VARARGS, nullptr },
        { "add_license_lost", reinterpret_cast<PyCFunction>(StorePackageLicense_add_LicenseLost), METH_O, nullptr },
        { "remove_license_lost", reinterpret_cast<PyCFunction>(StorePackageLicense_remove_LicenseLost), METH_O, nullptr },
        { "_assign_array_", _assign_array_StorePackageLicense, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_StorePackageLicense), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_StorePackageLicense), METH_NOARGS, nullptr },
        { "__exit__", reinterpret_cast<PyCFunction>(_exit_StorePackageLicense), METH_VARARGS, nullptr },
        { }};

    static PyGetSetDef _getset_StorePackageLicense[] = {
        { "is_valid", reinterpret_cast<getter>(StorePackageLicense_get_IsValid), nullptr, nullptr, nullptr },
        { "package", reinterpret_cast<getter>(StorePackageLicense_get_Package), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_StorePackageLicense[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_StorePackageLicense) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_StorePackageLicense) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_StorePackageLicense) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_StorePackageLicense) },
        { }};

    static PyType_Spec type_spec_StorePackageLicense = {
        "winrt._winrt_windows_services_store.StorePackageLicense",
        sizeof(py::wrapper::Windows::Services::Store::StorePackageLicense),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StorePackageLicense};

    // ----- StorePackageUpdate class --------------------

    static PyObject* _new_StorePackageUpdate(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Services::Store::StorePackageUpdate>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Services::Store::StorePackageUpdate>::type_name);
        return nullptr;
    }

    static void _dealloc_StorePackageUpdate(py::wrapper::Windows::Services::Store::StorePackageUpdate* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* StorePackageUpdate_get_Mandatory(py::wrapper::Windows::Services::Store::StorePackageUpdate* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StorePackageUpdate", L"Mandatory");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Mandatory();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StorePackageUpdate_get_Package(py::wrapper::Windows::Services::Store::StorePackageUpdate* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StorePackageUpdate", L"Package");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Package();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_StorePackageUpdate(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Services::Store::StorePackageUpdate>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_StorePackageUpdate(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Services::Store::StorePackageUpdate>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StorePackageUpdate[] = {
        { "_assign_array_", _assign_array_StorePackageUpdate, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_StorePackageUpdate), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_StorePackageUpdate[] = {
        { "mandatory", reinterpret_cast<getter>(StorePackageUpdate_get_Mandatory), nullptr, nullptr, nullptr },
        { "package", reinterpret_cast<getter>(StorePackageUpdate_get_Package), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_StorePackageUpdate[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_StorePackageUpdate) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_StorePackageUpdate) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_StorePackageUpdate) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_StorePackageUpdate) },
        { }};

    static PyType_Spec type_spec_StorePackageUpdate = {
        "winrt._winrt_windows_services_store.StorePackageUpdate",
        sizeof(py::wrapper::Windows::Services::Store::StorePackageUpdate),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StorePackageUpdate};

    // ----- StorePackageUpdateResult class --------------------

    static PyObject* _new_StorePackageUpdateResult(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Services::Store::StorePackageUpdateResult>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Services::Store::StorePackageUpdateResult>::type_name);
        return nullptr;
    }

    static void _dealloc_StorePackageUpdateResult(py::wrapper::Windows::Services::Store::StorePackageUpdateResult* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* StorePackageUpdateResult_get_OverallState(py::wrapper::Windows::Services::Store::StorePackageUpdateResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StorePackageUpdateResult", L"OverallState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.OverallState();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StorePackageUpdateResult_get_StorePackageUpdateStatuses(py::wrapper::Windows::Services::Store::StorePackageUpdateResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StorePackageUpdateResult", L"StorePackageUpdateStatuses");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.StorePackageUpdateStatuses();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StorePackageUpdateResult_get_StoreQueueItems(py::wrapper::Windows::Services::Store::StorePackageUpdateResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StorePackageUpdateResult", L"StoreQueueItems");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.StoreQueueItems();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_StorePackageUpdateResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Services::Store::StorePackageUpdateResult>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_StorePackageUpdateResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Services::Store::StorePackageUpdateResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StorePackageUpdateResult[] = {
        { "_assign_array_", _assign_array_StorePackageUpdateResult, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_StorePackageUpdateResult), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_StorePackageUpdateResult[] = {
        { "overall_state", reinterpret_cast<getter>(StorePackageUpdateResult_get_OverallState), nullptr, nullptr, nullptr },
        { "store_package_update_statuses", reinterpret_cast<getter>(StorePackageUpdateResult_get_StorePackageUpdateStatuses), nullptr, nullptr, nullptr },
        { "store_queue_items", reinterpret_cast<getter>(StorePackageUpdateResult_get_StoreQueueItems), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_StorePackageUpdateResult[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_StorePackageUpdateResult) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_StorePackageUpdateResult) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_StorePackageUpdateResult) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_StorePackageUpdateResult) },
        { }};

    static PyType_Spec type_spec_StorePackageUpdateResult = {
        "winrt._winrt_windows_services_store.StorePackageUpdateResult",
        sizeof(py::wrapper::Windows::Services::Store::StorePackageUpdateResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StorePackageUpdateResult};

    // ----- StorePrice class --------------------

    static PyObject* _new_StorePrice(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Services::Store::StorePrice>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Services::Store::StorePrice>::type_name);
        return nullptr;
    }

    static void _dealloc_StorePrice(py::wrapper::Windows::Services::Store::StorePrice* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* StorePrice_get_CurrencyCode(py::wrapper::Windows::Services::Store::StorePrice* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StorePrice", L"CurrencyCode");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.CurrencyCode();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StorePrice_get_FormattedBasePrice(py::wrapper::Windows::Services::Store::StorePrice* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StorePrice", L"FormattedBasePrice");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.FormattedBasePrice();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StorePrice_get_FormattedPrice(py::wrapper::Windows::Services::Store::StorePrice* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StorePrice", L"FormattedPrice");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.FormattedPrice();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StorePrice_get_FormattedRecurrencePrice(py::wrapper::Windows::Services::Store::StorePrice* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StorePrice", L"FormattedRecurrencePrice");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.FormattedRecurrencePrice();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StorePrice_get_IsOnSale(py::wrapper::Windows::Services::Store::StorePrice* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StorePrice", L"IsOnSale");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsOnSale();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StorePrice_get_SaleEndDate(py::wrapper::Windows::Services::Store::StorePrice* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StorePrice", L"SaleEndDate");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SaleEndDate();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StorePrice_get_UnformattedBasePrice(py::wrapper::Windows::Services::Store::StorePrice* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StorePrice", L"UnformattedBasePrice");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.UnformattedBasePrice();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StorePrice_get_UnformattedPrice(py::wrapper::Windows::Services::Store::StorePrice* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StorePrice", L"UnformattedPrice");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.UnformattedPrice();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StorePrice_get_UnformattedRecurrencePrice(py::wrapper::Windows::Services::Store::StorePrice* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StorePrice", L"UnformattedRecurrencePrice");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.UnformattedRecurrencePrice();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_StorePrice(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Services::Store::StorePrice>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_StorePrice(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Services::Store::StorePrice>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StorePrice[] = {
        { "_assign_array_", _assign_array_StorePrice, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_StorePrice), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_StorePrice[] = {
        { "currency_code", reinterpret_cast<getter>(StorePrice_get_CurrencyCode), nullptr, nullptr, nullptr },
        { "formatted_base_price", reinterpret_cast<getter>(StorePrice_get_FormattedBasePrice), nullptr, nullptr, nullptr },
        { "formatted_price", reinterpret_cast<getter>(StorePrice_get_FormattedPrice), nullptr, nullptr, nullptr },
        { "formatted_recurrence_price", reinterpret_cast<getter>(StorePrice_get_FormattedRecurrencePrice), nullptr, nullptr, nullptr },
        { "is_on_sale", reinterpret_cast<getter>(StorePrice_get_IsOnSale), nullptr, nullptr, nullptr },
        { "sale_end_date", reinterpret_cast<getter>(StorePrice_get_SaleEndDate), nullptr, nullptr, nullptr },
        { "unformatted_base_price", reinterpret_cast<getter>(StorePrice_get_UnformattedBasePrice), nullptr, nullptr, nullptr },
        { "unformatted_price", reinterpret_cast<getter>(StorePrice_get_UnformattedPrice), nullptr, nullptr, nullptr },
        { "unformatted_recurrence_price", reinterpret_cast<getter>(StorePrice_get_UnformattedRecurrencePrice), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_StorePrice[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_StorePrice) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_StorePrice) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_StorePrice) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_StorePrice) },
        { }};

    static PyType_Spec type_spec_StorePrice = {
        "winrt._winrt_windows_services_store.StorePrice",
        sizeof(py::wrapper::Windows::Services::Store::StorePrice),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StorePrice};

    // ----- StoreProduct class --------------------

    static PyObject* _new_StoreProduct(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Services::Store::StoreProduct>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Services::Store::StoreProduct>::type_name);
        return nullptr;
    }

    static void _dealloc_StoreProduct(py::wrapper::Windows::Services::Store::StoreProduct* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* StoreProduct_GetIsAnySkuInstalledAsync(py::wrapper::Windows::Services::Store::StoreProduct* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Services.Store.StoreProduct", L"GetIsAnySkuInstalledAsync", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetIsAnySkuInstalledAsync();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StoreProduct_RequestPurchaseAsync(py::wrapper::Windows::Services::Store::StoreProduct* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Services.Store.StoreProduct", L"RequestPurchaseAsync", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.RequestPurchaseAsync();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StoreProduct_RequestPurchaseWithPurchasePropertiesAsync(py::wrapper::Windows::Services::Store::StoreProduct* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Services.Store.StoreProduct", L"RequestPurchaseAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Services::Store::StorePurchaseProperties>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.RequestPurchaseAsync(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StoreProduct_get_Description(py::wrapper::Windows::Services::Store::StoreProduct* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreProduct", L"Description");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Description();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreProduct_get_ExtendedJsonData(py::wrapper::Windows::Services::Store::StoreProduct* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreProduct", L"ExtendedJsonData");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ExtendedJsonData();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreProduct_get_HasDigitalDownload(py::wrapper::Windows::Services::Store::StoreProduct* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreProduct", L"HasDigitalDownload");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.HasDigitalDownload();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreProduct_get_Images(py::wrapper::Windows::Services::Store::StoreProduct* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreProduct", L"Images");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Images();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreProduct_get_InAppOfferToken(py::wrapper::Windows::Services::Store::StoreProduct* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreProduct", L"InAppOfferToken");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.InAppOfferToken();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreProduct_get_IsInUserCollection(py::wrapper::Windows::Services::Store::StoreProduct* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreProduct", L"IsInUserCollection");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsInUserCollection();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreProduct_get_Keywords(py::wrapper::Windows::Services::Store::StoreProduct* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreProduct", L"Keywords");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Keywords();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreProduct_get_Language(py::wrapper::Windows::Services::Store::StoreProduct* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreProduct", L"Language");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Language();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreProduct_get_LinkUri(py::wrapper::Windows::Services::Store::StoreProduct* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreProduct", L"LinkUri");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.LinkUri();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreProduct_get_Price(py::wrapper::Windows::Services::Store::StoreProduct* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreProduct", L"Price");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Price();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreProduct_get_ProductKind(py::wrapper::Windows::Services::Store::StoreProduct* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreProduct", L"ProductKind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ProductKind();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreProduct_get_Skus(py::wrapper::Windows::Services::Store::StoreProduct* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreProduct", L"Skus");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Skus();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreProduct_get_StoreId(py::wrapper::Windows::Services::Store::StoreProduct* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreProduct", L"StoreId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.StoreId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreProduct_get_Title(py::wrapper::Windows::Services::Store::StoreProduct* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreProduct", L"Title");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Title();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreProduct_get_Videos(py::wrapper::Windows::Services::Store::StoreProduct* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreProduct", L"Videos");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Videos();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_StoreProduct(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Services::Store::StoreProduct>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_StoreProduct(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Services::Store::StoreProduct>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StoreProduct[] = {
        { "get_is_any_sku_installed_async", reinterpret_cast<PyCFunction>(StoreProduct_GetIsAnySkuInstalledAsync), METH_VARARGS, nullptr },
        { "request_purchase_async", reinterpret_cast<PyCFunction>(StoreProduct_RequestPurchaseAsync), METH_VARARGS, nullptr },
        { "request_purchase_with_purchase_properties_async", reinterpret_cast<PyCFunction>(StoreProduct_RequestPurchaseWithPurchasePropertiesAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_StoreProduct, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_StoreProduct), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_StoreProduct[] = {
        { "description", reinterpret_cast<getter>(StoreProduct_get_Description), nullptr, nullptr, nullptr },
        { "extended_json_data", reinterpret_cast<getter>(StoreProduct_get_ExtendedJsonData), nullptr, nullptr, nullptr },
        { "has_digital_download", reinterpret_cast<getter>(StoreProduct_get_HasDigitalDownload), nullptr, nullptr, nullptr },
        { "images", reinterpret_cast<getter>(StoreProduct_get_Images), nullptr, nullptr, nullptr },
        { "in_app_offer_token", reinterpret_cast<getter>(StoreProduct_get_InAppOfferToken), nullptr, nullptr, nullptr },
        { "is_in_user_collection", reinterpret_cast<getter>(StoreProduct_get_IsInUserCollection), nullptr, nullptr, nullptr },
        { "keywords", reinterpret_cast<getter>(StoreProduct_get_Keywords), nullptr, nullptr, nullptr },
        { "language", reinterpret_cast<getter>(StoreProduct_get_Language), nullptr, nullptr, nullptr },
        { "link_uri", reinterpret_cast<getter>(StoreProduct_get_LinkUri), nullptr, nullptr, nullptr },
        { "price", reinterpret_cast<getter>(StoreProduct_get_Price), nullptr, nullptr, nullptr },
        { "product_kind", reinterpret_cast<getter>(StoreProduct_get_ProductKind), nullptr, nullptr, nullptr },
        { "skus", reinterpret_cast<getter>(StoreProduct_get_Skus), nullptr, nullptr, nullptr },
        { "store_id", reinterpret_cast<getter>(StoreProduct_get_StoreId), nullptr, nullptr, nullptr },
        { "title", reinterpret_cast<getter>(StoreProduct_get_Title), nullptr, nullptr, nullptr },
        { "videos", reinterpret_cast<getter>(StoreProduct_get_Videos), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_StoreProduct[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_StoreProduct) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_StoreProduct) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_StoreProduct) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_StoreProduct) },
        { }};

    static PyType_Spec type_spec_StoreProduct = {
        "winrt._winrt_windows_services_store.StoreProduct",
        sizeof(py::wrapper::Windows::Services::Store::StoreProduct),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StoreProduct};

    // ----- StoreProductOptions class --------------------

    static PyObject* _new_StoreProductOptions(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Services::Store::StoreProductOptions instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_StoreProductOptions(py::wrapper::Windows::Services::Store::StoreProductOptions* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* StoreProductOptions_get_ActionFilters(py::wrapper::Windows::Services::Store::StoreProductOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreProductOptions", L"ActionFilters");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ActionFilters();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_StoreProductOptions(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Services::Store::StoreProductOptions>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_StoreProductOptions(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Services::Store::StoreProductOptions>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StoreProductOptions[] = {
        { "_assign_array_", _assign_array_StoreProductOptions, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_StoreProductOptions), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_StoreProductOptions[] = {
        { "action_filters", reinterpret_cast<getter>(StoreProductOptions_get_ActionFilters), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_StoreProductOptions[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_StoreProductOptions) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_StoreProductOptions) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_StoreProductOptions) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_StoreProductOptions) },
        { }};

    static PyType_Spec type_spec_StoreProductOptions = {
        "winrt._winrt_windows_services_store.StoreProductOptions",
        sizeof(py::wrapper::Windows::Services::Store::StoreProductOptions),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StoreProductOptions};

    // ----- StoreProductPagedQueryResult class --------------------

    static PyObject* _new_StoreProductPagedQueryResult(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Services::Store::StoreProductPagedQueryResult>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Services::Store::StoreProductPagedQueryResult>::type_name);
        return nullptr;
    }

    static void _dealloc_StoreProductPagedQueryResult(py::wrapper::Windows::Services::Store::StoreProductPagedQueryResult* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* StoreProductPagedQueryResult_GetNextAsync(py::wrapper::Windows::Services::Store::StoreProductPagedQueryResult* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Services.Store.StoreProductPagedQueryResult", L"GetNextAsync", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetNextAsync();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StoreProductPagedQueryResult_get_ExtendedError(py::wrapper::Windows::Services::Store::StoreProductPagedQueryResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreProductPagedQueryResult", L"ExtendedError");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ExtendedError();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreProductPagedQueryResult_get_HasMoreResults(py::wrapper::Windows::Services::Store::StoreProductPagedQueryResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreProductPagedQueryResult", L"HasMoreResults");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.HasMoreResults();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreProductPagedQueryResult_get_Products(py::wrapper::Windows::Services::Store::StoreProductPagedQueryResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreProductPagedQueryResult", L"Products");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Products();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_StoreProductPagedQueryResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Services::Store::StoreProductPagedQueryResult>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_StoreProductPagedQueryResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Services::Store::StoreProductPagedQueryResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StoreProductPagedQueryResult[] = {
        { "get_next_async", reinterpret_cast<PyCFunction>(StoreProductPagedQueryResult_GetNextAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_StoreProductPagedQueryResult, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_StoreProductPagedQueryResult), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_StoreProductPagedQueryResult[] = {
        { "extended_error", reinterpret_cast<getter>(StoreProductPagedQueryResult_get_ExtendedError), nullptr, nullptr, nullptr },
        { "has_more_results", reinterpret_cast<getter>(StoreProductPagedQueryResult_get_HasMoreResults), nullptr, nullptr, nullptr },
        { "products", reinterpret_cast<getter>(StoreProductPagedQueryResult_get_Products), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_StoreProductPagedQueryResult[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_StoreProductPagedQueryResult) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_StoreProductPagedQueryResult) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_StoreProductPagedQueryResult) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_StoreProductPagedQueryResult) },
        { }};

    static PyType_Spec type_spec_StoreProductPagedQueryResult = {
        "winrt._winrt_windows_services_store.StoreProductPagedQueryResult",
        sizeof(py::wrapper::Windows::Services::Store::StoreProductPagedQueryResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StoreProductPagedQueryResult};

    // ----- StoreProductQueryResult class --------------------

    static PyObject* _new_StoreProductQueryResult(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Services::Store::StoreProductQueryResult>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Services::Store::StoreProductQueryResult>::type_name);
        return nullptr;
    }

    static void _dealloc_StoreProductQueryResult(py::wrapper::Windows::Services::Store::StoreProductQueryResult* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* StoreProductQueryResult_get_ExtendedError(py::wrapper::Windows::Services::Store::StoreProductQueryResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreProductQueryResult", L"ExtendedError");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ExtendedError();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreProductQueryResult_get_Products(py::wrapper::Windows::Services::Store::StoreProductQueryResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreProductQueryResult", L"Products");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Products();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_StoreProductQueryResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Services::Store::StoreProductQueryResult>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_StoreProductQueryResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Services::Store::StoreProductQueryResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StoreProductQueryResult[] = {
        { "_assign_array_", _assign_array_StoreProductQueryResult, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_StoreProductQueryResult), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_StoreProductQueryResult[] = {
        { "extended_error", reinterpret_cast<getter>(StoreProductQueryResult_get_ExtendedError), nullptr, nullptr, nullptr },
        { "products", reinterpret_cast<getter>(StoreProductQueryResult_get_Products), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_StoreProductQueryResult[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_StoreProductQueryResult) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_StoreProductQueryResult) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_StoreProductQueryResult) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_StoreProductQueryResult) },
        { }};

    static PyType_Spec type_spec_StoreProductQueryResult = {
        "winrt._winrt_windows_services_store.StoreProductQueryResult",
        sizeof(py::wrapper::Windows::Services::Store::StoreProductQueryResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StoreProductQueryResult};

    // ----- StoreProductResult class --------------------

    static PyObject* _new_StoreProductResult(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Services::Store::StoreProductResult>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Services::Store::StoreProductResult>::type_name);
        return nullptr;
    }

    static void _dealloc_StoreProductResult(py::wrapper::Windows::Services::Store::StoreProductResult* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* StoreProductResult_get_ExtendedError(py::wrapper::Windows::Services::Store::StoreProductResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreProductResult", L"ExtendedError");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ExtendedError();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreProductResult_get_Product(py::wrapper::Windows::Services::Store::StoreProductResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreProductResult", L"Product");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Product();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_StoreProductResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Services::Store::StoreProductResult>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_StoreProductResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Services::Store::StoreProductResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StoreProductResult[] = {
        { "_assign_array_", _assign_array_StoreProductResult, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_StoreProductResult), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_StoreProductResult[] = {
        { "extended_error", reinterpret_cast<getter>(StoreProductResult_get_ExtendedError), nullptr, nullptr, nullptr },
        { "product", reinterpret_cast<getter>(StoreProductResult_get_Product), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_StoreProductResult[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_StoreProductResult) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_StoreProductResult) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_StoreProductResult) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_StoreProductResult) },
        { }};

    static PyType_Spec type_spec_StoreProductResult = {
        "winrt._winrt_windows_services_store.StoreProductResult",
        sizeof(py::wrapper::Windows::Services::Store::StoreProductResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StoreProductResult};

    // ----- StorePurchaseProperties class --------------------

    static PyObject* _new_StorePurchaseProperties(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                winrt::Windows::Services::Store::StorePurchaseProperties instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Services::Store::StorePurchaseProperties instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_StorePurchaseProperties(py::wrapper::Windows::Services::Store::StorePurchaseProperties* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* StorePurchaseProperties_get_Name(py::wrapper::Windows::Services::Store::StorePurchaseProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StorePurchaseProperties", L"Name");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Name();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StorePurchaseProperties_put_Name(py::wrapper::Windows::Services::Store::StorePurchaseProperties* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StorePurchaseProperties", L"Name");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            {
                auto _gil = release_gil();
                self->obj.Name(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StorePurchaseProperties_get_ExtendedJsonData(py::wrapper::Windows::Services::Store::StorePurchaseProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StorePurchaseProperties", L"ExtendedJsonData");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ExtendedJsonData();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StorePurchaseProperties_put_ExtendedJsonData(py::wrapper::Windows::Services::Store::StorePurchaseProperties* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StorePurchaseProperties", L"ExtendedJsonData");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            {
                auto _gil = release_gil();
                self->obj.ExtendedJsonData(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_StorePurchaseProperties(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Services::Store::StorePurchaseProperties>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_StorePurchaseProperties(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Services::Store::StorePurchaseProperties>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StorePurchaseProperties[] = {
        { "_assign_array_", _assign_array_StorePurchaseProperties, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_StorePurchaseProperties), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_StorePurchaseProperties[] = {
        { "name", reinterpret_cast<getter>(StorePurchaseProperties_get_Name), reinterpret_cast<setter>(StorePurchaseProperties_put_Name), nullptr, nullptr },
        { "extended_json_data", reinterpret_cast<getter>(StorePurchaseProperties_get_ExtendedJsonData), reinterpret_cast<setter>(StorePurchaseProperties_put_ExtendedJsonData), nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_StorePurchaseProperties[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_StorePurchaseProperties) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_StorePurchaseProperties) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_StorePurchaseProperties) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_StorePurchaseProperties) },
        { }};

    static PyType_Spec type_spec_StorePurchaseProperties = {
        "winrt._winrt_windows_services_store.StorePurchaseProperties",
        sizeof(py::wrapper::Windows::Services::Store::StorePurchaseProperties),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StorePurchaseProperties};

    // ----- StorePurchaseResult class --------------------

    static PyObject* _new_StorePurchaseResult(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Services::Store::StorePurchaseResult>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Services::Store::StorePurchaseResult>::type_name);
        return nullptr;
    }

    static void _dealloc_StorePurchaseResult(py::wrapper::Windows::Services::Store::StorePurchaseResult* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* StorePurchaseResult_get_ExtendedError(py::wrapper::Windows::Services::Store::StorePurchaseResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StorePurchaseResult", L"ExtendedError");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ExtendedError();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StorePurchaseResult_get_Status(py::wrapper::Windows::Services::Store::StorePurchaseResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StorePurchaseResult", L"Status");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Status();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_StorePurchaseResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Services::Store::StorePurchaseResult>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_StorePurchaseResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Services::Store::StorePurchaseResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StorePurchaseResult[] = {
        { "_assign_array_", _assign_array_StorePurchaseResult, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_StorePurchaseResult), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_StorePurchaseResult[] = {
        { "extended_error", reinterpret_cast<getter>(StorePurchaseResult_get_ExtendedError), nullptr, nullptr, nullptr },
        { "status", reinterpret_cast<getter>(StorePurchaseResult_get_Status), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_StorePurchaseResult[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_StorePurchaseResult) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_StorePurchaseResult) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_StorePurchaseResult) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_StorePurchaseResult) },
        { }};

    static PyType_Spec type_spec_StorePurchaseResult = {
        "winrt._winrt_windows_services_store.StorePurchaseResult",
        sizeof(py::wrapper::Windows::Services::Store::StorePurchaseResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StorePurchaseResult};

    // ----- StoreQueueItem class --------------------

    static PyObject* _new_StoreQueueItem(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Services::Store::StoreQueueItem>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Services::Store::StoreQueueItem>::type_name);
        return nullptr;
    }

    static void _dealloc_StoreQueueItem(py::wrapper::Windows::Services::Store::StoreQueueItem* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* StoreQueueItem_CancelInstallAsync(py::wrapper::Windows::Services::Store::StoreQueueItem* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Services.Store.StoreQueueItem", L"CancelInstallAsync", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.CancelInstallAsync();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StoreQueueItem_GetCurrentStatus(py::wrapper::Windows::Services::Store::StoreQueueItem* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Services.Store.StoreQueueItem", L"GetCurrentStatus", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetCurrentStatus();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StoreQueueItem_PauseInstallAsync(py::wrapper::Windows::Services::Store::StoreQueueItem* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Services.Store.StoreQueueItem", L"PauseInstallAsync", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.PauseInstallAsync();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StoreQueueItem_ResumeInstallAsync(py::wrapper::Windows::Services::Store::StoreQueueItem* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Services.Store.StoreQueueItem", L"ResumeInstallAsync", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.ResumeInstallAsync();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StoreQueueItem_get_InstallKind(py::wrapper::Windows::Services::Store::StoreQueueItem* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreQueueItem", L"InstallKind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.InstallKind();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreQueueItem_get_PackageFamilyName(py::wrapper::Windows::Services::Store::StoreQueueItem* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreQueueItem", L"PackageFamilyName");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PackageFamilyName();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreQueueItem_get_ProductId(py::wrapper::Windows::Services::Store::StoreQueueItem* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreQueueItem", L"ProductId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ProductId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreQueueItem_add_Completed(py::wrapper::Windows::Services::Store::StoreQueueItem* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Services.Store.StoreQueueItem", L"Completed");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Services::Store::StoreQueueItem, winrt::Windows::Services::Store::StoreQueueItemCompletedEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Completed(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreQueueItem_remove_Completed(py::wrapper::Windows::Services::Store::StoreQueueItem* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Services.Store.StoreQueueItem", L"Completed");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.Completed(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreQueueItem_add_StatusChanged(py::wrapper::Windows::Services::Store::StoreQueueItem* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Services.Store.StoreQueueItem", L"StatusChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Services::Store::StoreQueueItem, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.StatusChanged(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreQueueItem_remove_StatusChanged(py::wrapper::Windows::Services::Store::StoreQueueItem* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Services.Store.StoreQueueItem", L"StatusChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.StatusChanged(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_StoreQueueItem(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Services::Store::StoreQueueItem>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_StoreQueueItem(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Services::Store::StoreQueueItem>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StoreQueueItem[] = {
        { "cancel_install_async", reinterpret_cast<PyCFunction>(StoreQueueItem_CancelInstallAsync), METH_VARARGS, nullptr },
        { "get_current_status", reinterpret_cast<PyCFunction>(StoreQueueItem_GetCurrentStatus), METH_VARARGS, nullptr },
        { "pause_install_async", reinterpret_cast<PyCFunction>(StoreQueueItem_PauseInstallAsync), METH_VARARGS, nullptr },
        { "resume_install_async", reinterpret_cast<PyCFunction>(StoreQueueItem_ResumeInstallAsync), METH_VARARGS, nullptr },
        { "add_completed", reinterpret_cast<PyCFunction>(StoreQueueItem_add_Completed), METH_O, nullptr },
        { "remove_completed", reinterpret_cast<PyCFunction>(StoreQueueItem_remove_Completed), METH_O, nullptr },
        { "add_status_changed", reinterpret_cast<PyCFunction>(StoreQueueItem_add_StatusChanged), METH_O, nullptr },
        { "remove_status_changed", reinterpret_cast<PyCFunction>(StoreQueueItem_remove_StatusChanged), METH_O, nullptr },
        { "_assign_array_", _assign_array_StoreQueueItem, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_StoreQueueItem), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_StoreQueueItem[] = {
        { "install_kind", reinterpret_cast<getter>(StoreQueueItem_get_InstallKind), nullptr, nullptr, nullptr },
        { "package_family_name", reinterpret_cast<getter>(StoreQueueItem_get_PackageFamilyName), nullptr, nullptr, nullptr },
        { "product_id", reinterpret_cast<getter>(StoreQueueItem_get_ProductId), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_StoreQueueItem[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_StoreQueueItem) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_StoreQueueItem) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_StoreQueueItem) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_StoreQueueItem) },
        { }};

    static PyType_Spec type_spec_StoreQueueItem = {
        "winrt._winrt_windows_services_store.StoreQueueItem",
        sizeof(py::wrapper::Windows::Services::Store::StoreQueueItem),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StoreQueueItem};

    // ----- StoreQueueItemCompletedEventArgs class --------------------

    static PyObject* _new_StoreQueueItemCompletedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Services::Store::StoreQueueItemCompletedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Services::Store::StoreQueueItemCompletedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_StoreQueueItemCompletedEventArgs(py::wrapper::Windows::Services::Store::StoreQueueItemCompletedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* StoreQueueItemCompletedEventArgs_get_Status(py::wrapper::Windows::Services::Store::StoreQueueItemCompletedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreQueueItemCompletedEventArgs", L"Status");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Status();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_StoreQueueItemCompletedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Services::Store::StoreQueueItemCompletedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_StoreQueueItemCompletedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Services::Store::StoreQueueItemCompletedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StoreQueueItemCompletedEventArgs[] = {
        { "_assign_array_", _assign_array_StoreQueueItemCompletedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_StoreQueueItemCompletedEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_StoreQueueItemCompletedEventArgs[] = {
        { "status", reinterpret_cast<getter>(StoreQueueItemCompletedEventArgs_get_Status), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_StoreQueueItemCompletedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_StoreQueueItemCompletedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_StoreQueueItemCompletedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_StoreQueueItemCompletedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_StoreQueueItemCompletedEventArgs) },
        { }};

    static PyType_Spec type_spec_StoreQueueItemCompletedEventArgs = {
        "winrt._winrt_windows_services_store.StoreQueueItemCompletedEventArgs",
        sizeof(py::wrapper::Windows::Services::Store::StoreQueueItemCompletedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StoreQueueItemCompletedEventArgs};

    // ----- StoreQueueItemStatus class --------------------

    static PyObject* _new_StoreQueueItemStatus(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Services::Store::StoreQueueItemStatus>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Services::Store::StoreQueueItemStatus>::type_name);
        return nullptr;
    }

    static void _dealloc_StoreQueueItemStatus(py::wrapper::Windows::Services::Store::StoreQueueItemStatus* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* StoreQueueItemStatus_get_ExtendedError(py::wrapper::Windows::Services::Store::StoreQueueItemStatus* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreQueueItemStatus", L"ExtendedError");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ExtendedError();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreQueueItemStatus_get_PackageInstallExtendedState(py::wrapper::Windows::Services::Store::StoreQueueItemStatus* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreQueueItemStatus", L"PackageInstallExtendedState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PackageInstallExtendedState();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreQueueItemStatus_get_PackageInstallState(py::wrapper::Windows::Services::Store::StoreQueueItemStatus* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreQueueItemStatus", L"PackageInstallState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PackageInstallState();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreQueueItemStatus_get_UpdateStatus(py::wrapper::Windows::Services::Store::StoreQueueItemStatus* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreQueueItemStatus", L"UpdateStatus");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.UpdateStatus();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_StoreQueueItemStatus(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Services::Store::StoreQueueItemStatus>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_StoreQueueItemStatus(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Services::Store::StoreQueueItemStatus>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StoreQueueItemStatus[] = {
        { "_assign_array_", _assign_array_StoreQueueItemStatus, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_StoreQueueItemStatus), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_StoreQueueItemStatus[] = {
        { "extended_error", reinterpret_cast<getter>(StoreQueueItemStatus_get_ExtendedError), nullptr, nullptr, nullptr },
        { "package_install_extended_state", reinterpret_cast<getter>(StoreQueueItemStatus_get_PackageInstallExtendedState), nullptr, nullptr, nullptr },
        { "package_install_state", reinterpret_cast<getter>(StoreQueueItemStatus_get_PackageInstallState), nullptr, nullptr, nullptr },
        { "update_status", reinterpret_cast<getter>(StoreQueueItemStatus_get_UpdateStatus), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_StoreQueueItemStatus[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_StoreQueueItemStatus) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_StoreQueueItemStatus) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_StoreQueueItemStatus) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_StoreQueueItemStatus) },
        { }};

    static PyType_Spec type_spec_StoreQueueItemStatus = {
        "winrt._winrt_windows_services_store.StoreQueueItemStatus",
        sizeof(py::wrapper::Windows::Services::Store::StoreQueueItemStatus),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StoreQueueItemStatus};

    // ----- StoreRateAndReviewResult class --------------------

    static PyObject* _new_StoreRateAndReviewResult(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Services::Store::StoreRateAndReviewResult>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Services::Store::StoreRateAndReviewResult>::type_name);
        return nullptr;
    }

    static void _dealloc_StoreRateAndReviewResult(py::wrapper::Windows::Services::Store::StoreRateAndReviewResult* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* StoreRateAndReviewResult_get_ExtendedError(py::wrapper::Windows::Services::Store::StoreRateAndReviewResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreRateAndReviewResult", L"ExtendedError");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ExtendedError();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreRateAndReviewResult_get_ExtendedJsonData(py::wrapper::Windows::Services::Store::StoreRateAndReviewResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreRateAndReviewResult", L"ExtendedJsonData");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ExtendedJsonData();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreRateAndReviewResult_get_Status(py::wrapper::Windows::Services::Store::StoreRateAndReviewResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreRateAndReviewResult", L"Status");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Status();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreRateAndReviewResult_get_WasUpdated(py::wrapper::Windows::Services::Store::StoreRateAndReviewResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreRateAndReviewResult", L"WasUpdated");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.WasUpdated();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_StoreRateAndReviewResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Services::Store::StoreRateAndReviewResult>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_StoreRateAndReviewResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Services::Store::StoreRateAndReviewResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StoreRateAndReviewResult[] = {
        { "_assign_array_", _assign_array_StoreRateAndReviewResult, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_StoreRateAndReviewResult), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_StoreRateAndReviewResult[] = {
        { "extended_error", reinterpret_cast<getter>(StoreRateAndReviewResult_get_ExtendedError), nullptr, nullptr, nullptr },
        { "extended_json_data", reinterpret_cast<getter>(StoreRateAndReviewResult_get_ExtendedJsonData), nullptr, nullptr, nullptr },
        { "status", reinterpret_cast<getter>(StoreRateAndReviewResult_get_Status), nullptr, nullptr, nullptr },
        { "was_updated", reinterpret_cast<getter>(StoreRateAndReviewResult_get_WasUpdated), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_StoreRateAndReviewResult[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_StoreRateAndReviewResult) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_StoreRateAndReviewResult) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_StoreRateAndReviewResult) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_StoreRateAndReviewResult) },
        { }};

    static PyType_Spec type_spec_StoreRateAndReviewResult = {
        "winrt._winrt_windows_services_store.StoreRateAndReviewResult",
        sizeof(py::wrapper::Windows::Services::Store::StoreRateAndReviewResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StoreRateAndReviewResult};

    // ----- StoreRequestHelper class --------------------

    static PyObject* _new_StoreRequestHelper(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Services::Store::StoreRequestHelper>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Services::Store::StoreRequestHelper>::type_name);
        return nullptr;
    }

    static PyObject* StoreRequestHelper_SendRequestAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Services.Store.StoreRequestHelper", L"SendRequestAsync", 3);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Services::Store::StoreContext>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);
                auto param2 = py::convert_to<winrt::hstring>(args, 2);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::Services::Store::StoreRequestHelper::SendRequestAsync(param0, param1, param2);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyMethodDef _methods_StoreRequestHelper[] = {
        { }};

    static PyGetSetDef _getset_StoreRequestHelper[] = {
        { }};

    static PyType_Slot _type_slots_StoreRequestHelper[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_StoreRequestHelper) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_StoreRequestHelper) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_StoreRequestHelper) },
        { }};

    static PyType_Spec type_spec_StoreRequestHelper = {
        "winrt._winrt_windows_services_store.StoreRequestHelper",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StoreRequestHelper};

    static PyGetSetDef getset_StoreRequestHelper_Static[] = {
        { }};

    static PyMethodDef methods_StoreRequestHelper_Static[] = {
        { "send_request_async", reinterpret_cast<PyCFunction>(StoreRequestHelper_SendRequestAsync), METH_VARARGS, nullptr },
        { }};

    static PyType_Slot type_slots_StoreRequestHelper_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_StoreRequestHelper_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_StoreRequestHelper_Static) },
        { }
    };

    static PyType_Spec type_spec_StoreRequestHelper_Static = {
        "winrt._winrt_windows_services_store.StoreRequestHelper_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_StoreRequestHelper_Static};

    // ----- StoreSendRequestResult class --------------------

    static PyObject* _new_StoreSendRequestResult(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Services::Store::StoreSendRequestResult>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Services::Store::StoreSendRequestResult>::type_name);
        return nullptr;
    }

    static void _dealloc_StoreSendRequestResult(py::wrapper::Windows::Services::Store::StoreSendRequestResult* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* StoreSendRequestResult_get_ExtendedError(py::wrapper::Windows::Services::Store::StoreSendRequestResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreSendRequestResult", L"ExtendedError");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ExtendedError();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreSendRequestResult_get_Response(py::wrapper::Windows::Services::Store::StoreSendRequestResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreSendRequestResult", L"Response");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Response();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreSendRequestResult_get_HttpStatusCode(py::wrapper::Windows::Services::Store::StoreSendRequestResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreSendRequestResult", L"HttpStatusCode");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.HttpStatusCode();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_StoreSendRequestResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Services::Store::StoreSendRequestResult>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_StoreSendRequestResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Services::Store::StoreSendRequestResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StoreSendRequestResult[] = {
        { "_assign_array_", _assign_array_StoreSendRequestResult, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_StoreSendRequestResult), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_StoreSendRequestResult[] = {
        { "extended_error", reinterpret_cast<getter>(StoreSendRequestResult_get_ExtendedError), nullptr, nullptr, nullptr },
        { "response", reinterpret_cast<getter>(StoreSendRequestResult_get_Response), nullptr, nullptr, nullptr },
        { "http_status_code", reinterpret_cast<getter>(StoreSendRequestResult_get_HttpStatusCode), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_StoreSendRequestResult[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_StoreSendRequestResult) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_StoreSendRequestResult) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_StoreSendRequestResult) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_StoreSendRequestResult) },
        { }};

    static PyType_Spec type_spec_StoreSendRequestResult = {
        "winrt._winrt_windows_services_store.StoreSendRequestResult",
        sizeof(py::wrapper::Windows::Services::Store::StoreSendRequestResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StoreSendRequestResult};

    // ----- StoreSku class --------------------

    static PyObject* _new_StoreSku(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Services::Store::StoreSku>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Services::Store::StoreSku>::type_name);
        return nullptr;
    }

    static void _dealloc_StoreSku(py::wrapper::Windows::Services::Store::StoreSku* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* StoreSku_GetIsInstalledAsync(py::wrapper::Windows::Services::Store::StoreSku* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Services.Store.StoreSku", L"GetIsInstalledAsync", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetIsInstalledAsync();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StoreSku_RequestPurchaseAsync(py::wrapper::Windows::Services::Store::StoreSku* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Services.Store.StoreSku", L"RequestPurchaseAsync", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.RequestPurchaseAsync();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StoreSku_RequestPurchaseWithPurchasePropertiesAsync(py::wrapper::Windows::Services::Store::StoreSku* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Services.Store.StoreSku", L"RequestPurchaseAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Services::Store::StorePurchaseProperties>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.RequestPurchaseAsync(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StoreSku_get_Availabilities(py::wrapper::Windows::Services::Store::StoreSku* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreSku", L"Availabilities");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Availabilities();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreSku_get_BundledSkus(py::wrapper::Windows::Services::Store::StoreSku* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreSku", L"BundledSkus");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.BundledSkus();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreSku_get_CollectionData(py::wrapper::Windows::Services::Store::StoreSku* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreSku", L"CollectionData");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.CollectionData();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreSku_get_CustomDeveloperData(py::wrapper::Windows::Services::Store::StoreSku* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreSku", L"CustomDeveloperData");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.CustomDeveloperData();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreSku_get_Description(py::wrapper::Windows::Services::Store::StoreSku* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreSku", L"Description");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Description();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreSku_get_ExtendedJsonData(py::wrapper::Windows::Services::Store::StoreSku* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreSku", L"ExtendedJsonData");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ExtendedJsonData();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreSku_get_Images(py::wrapper::Windows::Services::Store::StoreSku* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreSku", L"Images");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Images();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreSku_get_IsInUserCollection(py::wrapper::Windows::Services::Store::StoreSku* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreSku", L"IsInUserCollection");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsInUserCollection();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreSku_get_IsSubscription(py::wrapper::Windows::Services::Store::StoreSku* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreSku", L"IsSubscription");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsSubscription();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreSku_get_IsTrial(py::wrapper::Windows::Services::Store::StoreSku* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreSku", L"IsTrial");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsTrial();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreSku_get_Language(py::wrapper::Windows::Services::Store::StoreSku* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreSku", L"Language");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Language();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreSku_get_Price(py::wrapper::Windows::Services::Store::StoreSku* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreSku", L"Price");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Price();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreSku_get_StoreId(py::wrapper::Windows::Services::Store::StoreSku* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreSku", L"StoreId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.StoreId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreSku_get_SubscriptionInfo(py::wrapper::Windows::Services::Store::StoreSku* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreSku", L"SubscriptionInfo");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SubscriptionInfo();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreSku_get_Title(py::wrapper::Windows::Services::Store::StoreSku* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreSku", L"Title");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Title();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreSku_get_Videos(py::wrapper::Windows::Services::Store::StoreSku* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreSku", L"Videos");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Videos();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_StoreSku(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Services::Store::StoreSku>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_StoreSku(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Services::Store::StoreSku>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StoreSku[] = {
        { "get_is_installed_async", reinterpret_cast<PyCFunction>(StoreSku_GetIsInstalledAsync), METH_VARARGS, nullptr },
        { "request_purchase_async", reinterpret_cast<PyCFunction>(StoreSku_RequestPurchaseAsync), METH_VARARGS, nullptr },
        { "request_purchase_with_purchase_properties_async", reinterpret_cast<PyCFunction>(StoreSku_RequestPurchaseWithPurchasePropertiesAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_StoreSku, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_StoreSku), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_StoreSku[] = {
        { "availabilities", reinterpret_cast<getter>(StoreSku_get_Availabilities), nullptr, nullptr, nullptr },
        { "bundled_skus", reinterpret_cast<getter>(StoreSku_get_BundledSkus), nullptr, nullptr, nullptr },
        { "collection_data", reinterpret_cast<getter>(StoreSku_get_CollectionData), nullptr, nullptr, nullptr },
        { "custom_developer_data", reinterpret_cast<getter>(StoreSku_get_CustomDeveloperData), nullptr, nullptr, nullptr },
        { "description", reinterpret_cast<getter>(StoreSku_get_Description), nullptr, nullptr, nullptr },
        { "extended_json_data", reinterpret_cast<getter>(StoreSku_get_ExtendedJsonData), nullptr, nullptr, nullptr },
        { "images", reinterpret_cast<getter>(StoreSku_get_Images), nullptr, nullptr, nullptr },
        { "is_in_user_collection", reinterpret_cast<getter>(StoreSku_get_IsInUserCollection), nullptr, nullptr, nullptr },
        { "is_subscription", reinterpret_cast<getter>(StoreSku_get_IsSubscription), nullptr, nullptr, nullptr },
        { "is_trial", reinterpret_cast<getter>(StoreSku_get_IsTrial), nullptr, nullptr, nullptr },
        { "language", reinterpret_cast<getter>(StoreSku_get_Language), nullptr, nullptr, nullptr },
        { "price", reinterpret_cast<getter>(StoreSku_get_Price), nullptr, nullptr, nullptr },
        { "store_id", reinterpret_cast<getter>(StoreSku_get_StoreId), nullptr, nullptr, nullptr },
        { "subscription_info", reinterpret_cast<getter>(StoreSku_get_SubscriptionInfo), nullptr, nullptr, nullptr },
        { "title", reinterpret_cast<getter>(StoreSku_get_Title), nullptr, nullptr, nullptr },
        { "videos", reinterpret_cast<getter>(StoreSku_get_Videos), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_StoreSku[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_StoreSku) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_StoreSku) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_StoreSku) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_StoreSku) },
        { }};

    static PyType_Spec type_spec_StoreSku = {
        "winrt._winrt_windows_services_store.StoreSku",
        sizeof(py::wrapper::Windows::Services::Store::StoreSku),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StoreSku};

    // ----- StoreSubscriptionInfo class --------------------

    static PyObject* _new_StoreSubscriptionInfo(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Services::Store::StoreSubscriptionInfo>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Services::Store::StoreSubscriptionInfo>::type_name);
        return nullptr;
    }

    static void _dealloc_StoreSubscriptionInfo(py::wrapper::Windows::Services::Store::StoreSubscriptionInfo* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* StoreSubscriptionInfo_get_BillingPeriod(py::wrapper::Windows::Services::Store::StoreSubscriptionInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreSubscriptionInfo", L"BillingPeriod");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.BillingPeriod();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreSubscriptionInfo_get_BillingPeriodUnit(py::wrapper::Windows::Services::Store::StoreSubscriptionInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreSubscriptionInfo", L"BillingPeriodUnit");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.BillingPeriodUnit();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreSubscriptionInfo_get_HasTrialPeriod(py::wrapper::Windows::Services::Store::StoreSubscriptionInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreSubscriptionInfo", L"HasTrialPeriod");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.HasTrialPeriod();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreSubscriptionInfo_get_TrialPeriod(py::wrapper::Windows::Services::Store::StoreSubscriptionInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreSubscriptionInfo", L"TrialPeriod");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.TrialPeriod();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreSubscriptionInfo_get_TrialPeriodUnit(py::wrapper::Windows::Services::Store::StoreSubscriptionInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreSubscriptionInfo", L"TrialPeriodUnit");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.TrialPeriodUnit();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_StoreSubscriptionInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Services::Store::StoreSubscriptionInfo>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_StoreSubscriptionInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Services::Store::StoreSubscriptionInfo>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StoreSubscriptionInfo[] = {
        { "_assign_array_", _assign_array_StoreSubscriptionInfo, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_StoreSubscriptionInfo), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_StoreSubscriptionInfo[] = {
        { "billing_period", reinterpret_cast<getter>(StoreSubscriptionInfo_get_BillingPeriod), nullptr, nullptr, nullptr },
        { "billing_period_unit", reinterpret_cast<getter>(StoreSubscriptionInfo_get_BillingPeriodUnit), nullptr, nullptr, nullptr },
        { "has_trial_period", reinterpret_cast<getter>(StoreSubscriptionInfo_get_HasTrialPeriod), nullptr, nullptr, nullptr },
        { "trial_period", reinterpret_cast<getter>(StoreSubscriptionInfo_get_TrialPeriod), nullptr, nullptr, nullptr },
        { "trial_period_unit", reinterpret_cast<getter>(StoreSubscriptionInfo_get_TrialPeriodUnit), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_StoreSubscriptionInfo[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_StoreSubscriptionInfo) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_StoreSubscriptionInfo) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_StoreSubscriptionInfo) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_StoreSubscriptionInfo) },
        { }};

    static PyType_Spec type_spec_StoreSubscriptionInfo = {
        "winrt._winrt_windows_services_store.StoreSubscriptionInfo",
        sizeof(py::wrapper::Windows::Services::Store::StoreSubscriptionInfo),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StoreSubscriptionInfo};

    // ----- StoreUninstallStorePackageResult class --------------------

    static PyObject* _new_StoreUninstallStorePackageResult(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Services::Store::StoreUninstallStorePackageResult>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Services::Store::StoreUninstallStorePackageResult>::type_name);
        return nullptr;
    }

    static void _dealloc_StoreUninstallStorePackageResult(py::wrapper::Windows::Services::Store::StoreUninstallStorePackageResult* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* StoreUninstallStorePackageResult_get_ExtendedError(py::wrapper::Windows::Services::Store::StoreUninstallStorePackageResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreUninstallStorePackageResult", L"ExtendedError");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ExtendedError();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreUninstallStorePackageResult_get_Status(py::wrapper::Windows::Services::Store::StoreUninstallStorePackageResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreUninstallStorePackageResult", L"Status");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Status();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_StoreUninstallStorePackageResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Services::Store::StoreUninstallStorePackageResult>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_StoreUninstallStorePackageResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Services::Store::StoreUninstallStorePackageResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StoreUninstallStorePackageResult[] = {
        { "_assign_array_", _assign_array_StoreUninstallStorePackageResult, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_StoreUninstallStorePackageResult), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_StoreUninstallStorePackageResult[] = {
        { "extended_error", reinterpret_cast<getter>(StoreUninstallStorePackageResult_get_ExtendedError), nullptr, nullptr, nullptr },
        { "status", reinterpret_cast<getter>(StoreUninstallStorePackageResult_get_Status), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_StoreUninstallStorePackageResult[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_StoreUninstallStorePackageResult) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_StoreUninstallStorePackageResult) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_StoreUninstallStorePackageResult) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_StoreUninstallStorePackageResult) },
        { }};

    static PyType_Spec type_spec_StoreUninstallStorePackageResult = {
        "winrt._winrt_windows_services_store.StoreUninstallStorePackageResult",
        sizeof(py::wrapper::Windows::Services::Store::StoreUninstallStorePackageResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StoreUninstallStorePackageResult};

    // ----- StoreVideo class --------------------

    static PyObject* _new_StoreVideo(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Services::Store::StoreVideo>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Services::Store::StoreVideo>::type_name);
        return nullptr;
    }

    static void _dealloc_StoreVideo(py::wrapper::Windows::Services::Store::StoreVideo* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* StoreVideo_get_Caption(py::wrapper::Windows::Services::Store::StoreVideo* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreVideo", L"Caption");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Caption();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreVideo_get_Height(py::wrapper::Windows::Services::Store::StoreVideo* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreVideo", L"Height");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Height();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreVideo_get_PreviewImage(py::wrapper::Windows::Services::Store::StoreVideo* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreVideo", L"PreviewImage");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PreviewImage();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreVideo_get_Uri(py::wrapper::Windows::Services::Store::StoreVideo* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreVideo", L"Uri");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Uri();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreVideo_get_VideoPurposeTag(py::wrapper::Windows::Services::Store::StoreVideo* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreVideo", L"VideoPurposeTag");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.VideoPurposeTag();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreVideo_get_Width(py::wrapper::Windows::Services::Store::StoreVideo* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Services.Store.StoreVideo", L"Width");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Width();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_StoreVideo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Services::Store::StoreVideo>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_StoreVideo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Services::Store::StoreVideo>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StoreVideo[] = {
        { "_assign_array_", _assign_array_StoreVideo, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_StoreVideo), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_StoreVideo[] = {
        { "caption", reinterpret_cast<getter>(StoreVideo_get_Caption), nullptr, nullptr, nullptr },
        { "height", reinterpret_cast<getter>(StoreVideo_get_Height), nullptr, nullptr, nullptr },
        { "preview_image", reinterpret_cast<getter>(StoreVideo_get_PreviewImage), nullptr, nullptr, nullptr },
        { "uri", reinterpret_cast<getter>(StoreVideo_get_Uri), nullptr, nullptr, nullptr },
        { "video_purpose_tag", reinterpret_cast<getter>(StoreVideo_get_VideoPurposeTag), nullptr, nullptr, nullptr },
        { "width", reinterpret_cast<getter>(StoreVideo_get_Width), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_StoreVideo[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_StoreVideo) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_StoreVideo) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_StoreVideo) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_StoreVideo) },
        { }};

    static PyType_Spec type_spec_StoreVideo = {
        "winrt._winrt_windows_services_store.StoreVideo",
        sizeof(py::wrapper::Windows::Services::Store::StoreVideo),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StoreVideo};

    // ----- StorePackageUpdateStatus struct --------------------

    winrt_struct_wrapper<winrt::Windows::Services::Store::StorePackageUpdateStatus>* _new_StorePackageUpdateStatus(PyTypeObject* subclass, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        auto self = reinterpret_cast<winrt_struct_wrapper<winrt::Windows::Services::Store::StorePackageUpdateStatus>*>(subclass->tp_alloc(subclass, 0));

        if (!self)
        {
            return nullptr;
        }

        std::construct_at(&self->obj);

        return self;
    }

    int _init_StorePackageUpdateStatus(winrt_struct_wrapper<winrt::Windows::Services::Store::StorePackageUpdateStatus>* self, PyObject* args, PyObject* kwds) noexcept
    {
        auto tuple_size = PyTuple_Size(args);

        if ((tuple_size == 0) && (!kwds))
        {
            self->obj = {};
            return 0;
        }

        PyObject* _PackageFamilyName{};
        uint64_t _PackageDownloadSizeInBytes{};
        uint64_t _PackageBytesDownloaded{};
        double _PackageDownloadProgress{};
        double _TotalDownloadProgress{};
        int32_t _PackageUpdateState{};

        static const char* kwlist[] = {"package_family_name", "package_download_size_in_bytes", "package_bytes_downloaded", "package_download_progress", "total_download_progress", "package_update_state", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "OKKddi", const_cast<char**>(kwlist), &_PackageFamilyName, &_PackageDownloadSizeInBytes, &_PackageBytesDownloaded, &_PackageDownloadProgress, &_TotalDownloadProgress, &_PackageUpdateState))
        {
            return -1;
        }

        try
        {
            self->obj.PackageFamilyName = py::convert_to<winrt::hstring>(_PackageFamilyName);
            self->obj.PackageDownloadSizeInBytes = _PackageDownloadSizeInBytes;
            self->obj.PackageBytesDownloaded = _PackageBytesDownloaded;
            self->obj.PackageDownloadProgress = _PackageDownloadProgress;
            self->obj.TotalDownloadProgress = _TotalDownloadProgress;
            self->obj.PackageUpdateState = static_cast<winrt::Windows::Services::Store::StorePackageUpdateState>(_PackageUpdateState);

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static void _dealloc_StorePackageUpdateStatus(py::wrapper::Windows::Services::Store::StorePackageUpdateStatus* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_StorePackageUpdateStatus(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Services::Store::StorePackageUpdateStatus>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyMethodDef _methods_StorePackageUpdateStatus[] = {
        { "_assign_array_", _assign_array_StorePackageUpdateStatus, METH_O | METH_STATIC, nullptr },
        { }};

    static PyObject* StorePackageUpdateStatus_get_PackageFamilyName(py::wrapper::Windows::Services::Store::StorePackageUpdateStatus* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PackageFamilyName);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StorePackageUpdateStatus_get_PackageDownloadSizeInBytes(py::wrapper::Windows::Services::Store::StorePackageUpdateStatus* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PackageDownloadSizeInBytes);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StorePackageUpdateStatus_get_PackageBytesDownloaded(py::wrapper::Windows::Services::Store::StorePackageUpdateStatus* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PackageBytesDownloaded);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StorePackageUpdateStatus_get_PackageDownloadProgress(py::wrapper::Windows::Services::Store::StorePackageUpdateStatus* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PackageDownloadProgress);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StorePackageUpdateStatus_get_TotalDownloadProgress(py::wrapper::Windows::Services::Store::StorePackageUpdateStatus* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TotalDownloadProgress);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StorePackageUpdateStatus_get_PackageUpdateState(py::wrapper::Windows::Services::Store::StorePackageUpdateStatus* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PackageUpdateState);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyGetSetDef _getset_StorePackageUpdateStatus[] = {
        { "package_family_name", reinterpret_cast<getter>(StorePackageUpdateStatus_get_PackageFamilyName), nullptr, nullptr, nullptr },
        { "package_download_size_in_bytes", reinterpret_cast<getter>(StorePackageUpdateStatus_get_PackageDownloadSizeInBytes), nullptr, nullptr, nullptr },
        { "package_bytes_downloaded", reinterpret_cast<getter>(StorePackageUpdateStatus_get_PackageBytesDownloaded), nullptr, nullptr, nullptr },
        { "package_download_progress", reinterpret_cast<getter>(StorePackageUpdateStatus_get_PackageDownloadProgress), nullptr, nullptr, nullptr },
        { "total_download_progress", reinterpret_cast<getter>(StorePackageUpdateStatus_get_TotalDownloadProgress), nullptr, nullptr, nullptr },
        { "package_update_state", reinterpret_cast<getter>(StorePackageUpdateStatus_get_PackageUpdateState), nullptr, nullptr, nullptr },
        { }};

    static PyObject* _richcompare_StorePackageUpdateStatus(py::wrapper::Windows::Services::Store::StorePackageUpdateStatus* self, PyObject* other, int op) noexcept
    {
        try
        {
            auto _other = py::convert_to<winrt::Windows::Services::Store::StorePackageUpdateStatus>(other);

            if (op == Py_EQ)
            {
                if (self->obj == _other)
                {
                    Py_RETURN_TRUE;
                }

                Py_RETURN_FALSE;
            }

            if (op == Py_NE)
            {
                if (self->obj != _other)
                {
                    Py_RETURN_TRUE;
                }

                Py_RETURN_FALSE;
            }

            Py_RETURN_NOTIMPLEMENTED;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _repr_StorePackageUpdateStatus(PyObject* self) noexcept
    {
        py::pyobj_handle PackageFamilyName{PyObject_GetAttrString(self, "package_family_name")};
        if (!PackageFamilyName)
        {
            return nullptr;
        }

        py::pyobj_handle PackageDownloadSizeInBytes{PyObject_GetAttrString(self, "package_download_size_in_bytes")};
        if (!PackageDownloadSizeInBytes)
        {
            return nullptr;
        }

        py::pyobj_handle PackageBytesDownloaded{PyObject_GetAttrString(self, "package_bytes_downloaded")};
        if (!PackageBytesDownloaded)
        {
            return nullptr;
        }

        py::pyobj_handle PackageDownloadProgress{PyObject_GetAttrString(self, "package_download_progress")};
        if (!PackageDownloadProgress)
        {
            return nullptr;
        }

        py::pyobj_handle TotalDownloadProgress{PyObject_GetAttrString(self, "total_download_progress")};
        if (!TotalDownloadProgress)
        {
            return nullptr;
        }

        py::pyobj_handle PackageUpdateState{PyObject_GetAttrString(self, "package_update_state")};
        if (!PackageUpdateState)
        {
            return nullptr;
        }

        return PyUnicode_FromFormat("StorePackageUpdateStatus(package_family_name=%R, package_download_size_in_bytes=%R, package_bytes_downloaded=%R, package_download_progress=%R, total_download_progress=%R, package_update_state=%R)", PackageFamilyName.get(), PackageDownloadSizeInBytes.get(), PackageBytesDownloaded.get(), PackageDownloadProgress.get(), TotalDownloadProgress.get(), PackageUpdateState.get());
    }

    static PyType_Slot _type_slots_StorePackageUpdateStatus[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_StorePackageUpdateStatus) },
        { Py_tp_init, reinterpret_cast<void*>(_init_StorePackageUpdateStatus) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_StorePackageUpdateStatus) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_StorePackageUpdateStatus) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_StorePackageUpdateStatus) },
        { Py_tp_richcompare, reinterpret_cast<void*>(_richcompare_StorePackageUpdateStatus) },
        { Py_tp_repr, reinterpret_cast<void*>(_repr_StorePackageUpdateStatus) },
        { }};

    static PyType_Spec type_spec_StorePackageUpdateStatus = {
        "winrt._winrt_windows_services_store.StorePackageUpdateStatus",
        sizeof(py::wrapper::Windows::Services::Store::StorePackageUpdateStatus),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StorePackageUpdateStatus};

    // ----- Windows.Services.Store Initialization --------------------

    PyDoc_STRVAR(module_doc, "Windows.Services.Store");

    static PyModuleDef module_def = {
        PyModuleDef_HEAD_INIT,
        "_winrt_windows_services_store",
        module_doc,
        0,
        nullptr,
        nullptr,
        nullptr,
        nullptr,
        nullptr};
} // py::cpp::Windows::Services::Store

PyMODINIT_FUNC PyInit__winrt_windows_services_store(void) noexcept
{
    using namespace py::cpp::Windows::Services::Store;

    if (py::import_winrt_runtime() == -1)
    {
        return nullptr;
    }

    py::pyobj_handle module{PyModule_Create(&module_def)};

    if (!module)
    {
        return nullptr;
    }

    auto inspectable_meta_type = py::get_inspectable_meta_type();
    if (!inspectable_meta_type)
    {
        return nullptr;
    }

    auto object_type = py::get_object_type();
    if (!object_type)
    {
        return nullptr;
    }

    py::pyobj_handle object_bases{PyTuple_Pack(1, object_type)};

    if (!object_bases)
    {
        return nullptr;
    }

    py::pytype_handle StoreAcquireLicenseResult_type{py::register_python_type(module.get(), &type_spec_StoreAcquireLicenseResult, object_bases.get(), inspectable_meta_type)};
    if (!StoreAcquireLicenseResult_type)
    {
        return nullptr;
    }

    py::pytype_handle StoreAppLicense_type{py::register_python_type(module.get(), &type_spec_StoreAppLicense, object_bases.get(), inspectable_meta_type)};
    if (!StoreAppLicense_type)
    {
        return nullptr;
    }

    py::pytype_handle StoreAvailability_type{py::register_python_type(module.get(), &type_spec_StoreAvailability, object_bases.get(), inspectable_meta_type)};
    if (!StoreAvailability_type)
    {
        return nullptr;
    }

    py::pytype_handle StoreCanAcquireLicenseResult_type{py::register_python_type(module.get(), &type_spec_StoreCanAcquireLicenseResult, object_bases.get(), inspectable_meta_type)};
    if (!StoreCanAcquireLicenseResult_type)
    {
        return nullptr;
    }

    py::pytype_handle StoreCollectionData_type{py::register_python_type(module.get(), &type_spec_StoreCollectionData, object_bases.get(), inspectable_meta_type)};
    if (!StoreCollectionData_type)
    {
        return nullptr;
    }

    py::pytype_handle StoreConsumableResult_type{py::register_python_type(module.get(), &type_spec_StoreConsumableResult, object_bases.get(), inspectable_meta_type)};
    if (!StoreConsumableResult_type)
    {
        return nullptr;
    }

    py::pyobj_handle StoreContext_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(inspectable_meta_type))};
    if (!StoreContext_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_StoreContext_Static{PyType_FromSpecWithBases(&type_spec_StoreContext_Static, StoreContext_Static_bases.get())};
    if (!type_StoreContext_Static)
    {
        return nullptr;
    }

    py::pytype_handle StoreContext_type{py::register_python_type(module.get(), &type_spec_StoreContext, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_StoreContext_Static.get()))};
    if (!StoreContext_type)
    {
        return nullptr;
    }

    py::pytype_handle StoreImage_type{py::register_python_type(module.get(), &type_spec_StoreImage, object_bases.get(), inspectable_meta_type)};
    if (!StoreImage_type)
    {
        return nullptr;
    }

    py::pytype_handle StoreLicense_type{py::register_python_type(module.get(), &type_spec_StoreLicense, object_bases.get(), inspectable_meta_type)};
    if (!StoreLicense_type)
    {
        return nullptr;
    }

    py::pytype_handle StorePackageInstallOptions_type{py::register_python_type(module.get(), &type_spec_StorePackageInstallOptions, object_bases.get(), inspectable_meta_type)};
    if (!StorePackageInstallOptions_type)
    {
        return nullptr;
    }

    py::pytype_handle StorePackageLicense_type{py::register_python_type(module.get(), &type_spec_StorePackageLicense, object_bases.get(), inspectable_meta_type)};
    if (!StorePackageLicense_type)
    {
        return nullptr;
    }

    py::pytype_handle StorePackageUpdate_type{py::register_python_type(module.get(), &type_spec_StorePackageUpdate, object_bases.get(), inspectable_meta_type)};
    if (!StorePackageUpdate_type)
    {
        return nullptr;
    }

    py::pytype_handle StorePackageUpdateResult_type{py::register_python_type(module.get(), &type_spec_StorePackageUpdateResult, object_bases.get(), inspectable_meta_type)};
    if (!StorePackageUpdateResult_type)
    {
        return nullptr;
    }

    py::pytype_handle StorePrice_type{py::register_python_type(module.get(), &type_spec_StorePrice, object_bases.get(), inspectable_meta_type)};
    if (!StorePrice_type)
    {
        return nullptr;
    }

    py::pytype_handle StoreProduct_type{py::register_python_type(module.get(), &type_spec_StoreProduct, object_bases.get(), inspectable_meta_type)};
    if (!StoreProduct_type)
    {
        return nullptr;
    }

    py::pytype_handle StoreProductOptions_type{py::register_python_type(module.get(), &type_spec_StoreProductOptions, object_bases.get(), inspectable_meta_type)};
    if (!StoreProductOptions_type)
    {
        return nullptr;
    }

    py::pytype_handle StoreProductPagedQueryResult_type{py::register_python_type(module.get(), &type_spec_StoreProductPagedQueryResult, object_bases.get(), inspectable_meta_type)};
    if (!StoreProductPagedQueryResult_type)
    {
        return nullptr;
    }

    py::pytype_handle StoreProductQueryResult_type{py::register_python_type(module.get(), &type_spec_StoreProductQueryResult, object_bases.get(), inspectable_meta_type)};
    if (!StoreProductQueryResult_type)
    {
        return nullptr;
    }

    py::pytype_handle StoreProductResult_type{py::register_python_type(module.get(), &type_spec_StoreProductResult, object_bases.get(), inspectable_meta_type)};
    if (!StoreProductResult_type)
    {
        return nullptr;
    }

    py::pytype_handle StorePurchaseProperties_type{py::register_python_type(module.get(), &type_spec_StorePurchaseProperties, object_bases.get(), inspectable_meta_type)};
    if (!StorePurchaseProperties_type)
    {
        return nullptr;
    }

    py::pytype_handle StorePurchaseResult_type{py::register_python_type(module.get(), &type_spec_StorePurchaseResult, object_bases.get(), inspectable_meta_type)};
    if (!StorePurchaseResult_type)
    {
        return nullptr;
    }

    py::pytype_handle StoreQueueItem_type{py::register_python_type(module.get(), &type_spec_StoreQueueItem, object_bases.get(), inspectable_meta_type)};
    if (!StoreQueueItem_type)
    {
        return nullptr;
    }

    py::pytype_handle StoreQueueItemCompletedEventArgs_type{py::register_python_type(module.get(), &type_spec_StoreQueueItemCompletedEventArgs, object_bases.get(), inspectable_meta_type)};
    if (!StoreQueueItemCompletedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle StoreQueueItemStatus_type{py::register_python_type(module.get(), &type_spec_StoreQueueItemStatus, object_bases.get(), inspectable_meta_type)};
    if (!StoreQueueItemStatus_type)
    {
        return nullptr;
    }

    py::pytype_handle StoreRateAndReviewResult_type{py::register_python_type(module.get(), &type_spec_StoreRateAndReviewResult, object_bases.get(), inspectable_meta_type)};
    if (!StoreRateAndReviewResult_type)
    {
        return nullptr;
    }

    py::pyobj_handle StoreRequestHelper_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(inspectable_meta_type))};
    if (!StoreRequestHelper_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_StoreRequestHelper_Static{PyType_FromSpecWithBases(&type_spec_StoreRequestHelper_Static, StoreRequestHelper_Static_bases.get())};
    if (!type_StoreRequestHelper_Static)
    {
        return nullptr;
    }

    py::pytype_handle StoreRequestHelper_type{py::register_python_type(module.get(), &type_spec_StoreRequestHelper, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_StoreRequestHelper_Static.get()))};
    if (!StoreRequestHelper_type)
    {
        return nullptr;
    }

    py::pytype_handle StoreSendRequestResult_type{py::register_python_type(module.get(), &type_spec_StoreSendRequestResult, object_bases.get(), inspectable_meta_type)};
    if (!StoreSendRequestResult_type)
    {
        return nullptr;
    }

    py::pytype_handle StoreSku_type{py::register_python_type(module.get(), &type_spec_StoreSku, object_bases.get(), inspectable_meta_type)};
    if (!StoreSku_type)
    {
        return nullptr;
    }

    py::pytype_handle StoreSubscriptionInfo_type{py::register_python_type(module.get(), &type_spec_StoreSubscriptionInfo, object_bases.get(), inspectable_meta_type)};
    if (!StoreSubscriptionInfo_type)
    {
        return nullptr;
    }

    py::pytype_handle StoreUninstallStorePackageResult_type{py::register_python_type(module.get(), &type_spec_StoreUninstallStorePackageResult, object_bases.get(), inspectable_meta_type)};
    if (!StoreUninstallStorePackageResult_type)
    {
        return nullptr;
    }

    py::pytype_handle StoreVideo_type{py::register_python_type(module.get(), &type_spec_StoreVideo, object_bases.get(), inspectable_meta_type)};
    if (!StoreVideo_type)
    {
        return nullptr;
    }

    py::pytype_handle StorePackageUpdateStatus_type{py::register_python_type(module.get(), &type_spec_StorePackageUpdateStatus, nullptr, nullptr)};
    if (!StorePackageUpdateStatus_type)
    {
        return nullptr;
    }


    return module.detach();
}
