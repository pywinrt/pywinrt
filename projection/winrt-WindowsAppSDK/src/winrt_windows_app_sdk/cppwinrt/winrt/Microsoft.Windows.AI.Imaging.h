// WARNING: Please don't edit this file. It was generated by C++/WinRT v2.0.250303.1

#pragma once
#ifndef WINRT_Microsoft_Windows_AI_Imaging_H
#define WINRT_Microsoft_Windows_AI_Imaging_H
#include "winrt/base.h"
static_assert(winrt::check_version(CPPWINRT_VERSION, "2.0.250303.1"), "Mismatched C++/WinRT headers.");
#define CPPWINRT_VERSION "2.0.250303.1"
#include "winrt/Microsoft.Windows.AI.h"
#include "winrt/impl/Microsoft.Graphics.Imaging.2.h"
#include "winrt/impl/Microsoft.Windows.AI.2.h"
#include "winrt/impl/Microsoft.Windows.AI.ContentSafety.2.h"
#include "winrt/impl/Windows.Foundation.2.h"
#include "winrt/impl/Windows.Foundation.Collections.2.h"
#include "winrt/impl/Windows.Graphics.2.h"
#include "winrt/impl/Windows.Graphics.Imaging.2.h"
#include "winrt/impl/Microsoft.Windows.AI.Imaging.2.h"
namespace winrt::impl
{
    template <typename D> auto consume_Microsoft_Windows_AI_Imaging_IImageDescriptionGenerator<D>::DescribeAsync(winrt::Microsoft::Graphics::Imaging::ImageBuffer const& image, winrt::Microsoft::Windows::AI::Imaging::ImageDescriptionKind const& kind, winrt::Microsoft::Windows::AI::ContentSafety::ContentFilterOptions const& contentFilterOptions) const
    {
        void* operation{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::AI::Imaging::IImageDescriptionGenerator>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::AI::Imaging::IImageDescriptionGenerator, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Imaging::IImageDescriptionGenerator>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->DescribeAsync(*(void**)(&image), static_cast<int32_t>(kind), *(void**)(&contentFilterOptions), &operation));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Imaging::IImageDescriptionGenerator>**)this;
            check_hresult(_winrt_abi_type->DescribeAsync(*(void**)(&image), static_cast<int32_t>(kind), *(void**)(&contentFilterOptions), &operation));
        }
        return winrt::Windows::Foundation::IAsyncOperationWithProgress<winrt::Microsoft::Windows::AI::Imaging::ImageDescriptionResult, hstring>{ operation, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Windows_AI_Imaging_IImageDescriptionGeneratorStatics<D>::GetReadyState() const
    {
        winrt::Microsoft::Windows::AI::AIFeatureReadyState result{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::AI::Imaging::IImageDescriptionGeneratorStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::AI::Imaging::IImageDescriptionGeneratorStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Imaging::IImageDescriptionGeneratorStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->GetReadyState(reinterpret_cast<int32_t*>(&result)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Imaging::IImageDescriptionGeneratorStatics>**)this;
            check_hresult(_winrt_abi_type->GetReadyState(reinterpret_cast<int32_t*>(&result)));
        }
        return result;
    }
    template <typename D> auto consume_Microsoft_Windows_AI_Imaging_IImageDescriptionGeneratorStatics<D>::EnsureReadyAsync() const
    {
        void* operation{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::AI::Imaging::IImageDescriptionGeneratorStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::AI::Imaging::IImageDescriptionGeneratorStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Imaging::IImageDescriptionGeneratorStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->EnsureReadyAsync(&operation));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Imaging::IImageDescriptionGeneratorStatics>**)this;
            check_hresult(_winrt_abi_type->EnsureReadyAsync(&operation));
        }
        return winrt::Windows::Foundation::IAsyncOperationWithProgress<winrt::Microsoft::Windows::AI::AIFeatureReadyResult, double>{ operation, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Windows_AI_Imaging_IImageDescriptionGeneratorStatics<D>::CreateAsync() const
    {
        void* operation{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::AI::Imaging::IImageDescriptionGeneratorStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::AI::Imaging::IImageDescriptionGeneratorStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Imaging::IImageDescriptionGeneratorStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->CreateAsync(&operation));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Imaging::IImageDescriptionGeneratorStatics>**)this;
            check_hresult(_winrt_abi_type->CreateAsync(&operation));
        }
        return winrt::Windows::Foundation::IAsyncOperation<winrt::Microsoft::Windows::AI::Imaging::ImageDescriptionGenerator>{ operation, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Windows_AI_Imaging_IImageDescriptionResult<D>::Description() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::AI::Imaging::IImageDescriptionResult>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::AI::Imaging::IImageDescriptionResult, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Imaging::IImageDescriptionResult>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Description(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Imaging::IImageDescriptionResult>**)this;
            check_hresult(_winrt_abi_type->get_Description(&value));
        }
        return hstring{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Windows_AI_Imaging_IImageDescriptionResult<D>::Status() const
    {
        winrt::Microsoft::Windows::AI::Imaging::ImageDescriptionResultStatus value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::AI::Imaging::IImageDescriptionResult>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::AI::Imaging::IImageDescriptionResult, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Imaging::IImageDescriptionResult>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Status(reinterpret_cast<int32_t*>(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Imaging::IImageDescriptionResult>**)this;
            check_hresult(_winrt_abi_type->get_Status(reinterpret_cast<int32_t*>(&value)));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_Windows_AI_Imaging_IImageObjectExtractor<D>::GetSoftwareBitmapObjectMask(winrt::Microsoft::Windows::AI::Imaging::ImageObjectExtractorHint const& hint) const
    {
        void* result{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::AI::Imaging::IImageObjectExtractor>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::AI::Imaging::IImageObjectExtractor, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Imaging::IImageObjectExtractor>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->GetSoftwareBitmapObjectMask(*(void**)(&hint), &result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Imaging::IImageObjectExtractor>**)this;
            check_hresult(_winrt_abi_type->GetSoftwareBitmapObjectMask(*(void**)(&hint), &result));
        }
        return winrt::Windows::Graphics::Imaging::SoftwareBitmap{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Windows_AI_Imaging_IImageObjectExtractor<D>::GetImageBufferObjectMask(winrt::Microsoft::Windows::AI::Imaging::ImageObjectExtractorHint const& hint) const
    {
        void* result{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::AI::Imaging::IImageObjectExtractor>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::AI::Imaging::IImageObjectExtractor, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Imaging::IImageObjectExtractor>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->GetImageBufferObjectMask(*(void**)(&hint), &result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Imaging::IImageObjectExtractor>**)this;
            check_hresult(_winrt_abi_type->GetImageBufferObjectMask(*(void**)(&hint), &result));
        }
        return winrt::Microsoft::Graphics::Imaging::ImageBuffer{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Windows_AI_Imaging_IImageObjectExtractorHint<D>::IncludeRects() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::AI::Imaging::IImageObjectExtractorHint>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::AI::Imaging::IImageObjectExtractorHint, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Imaging::IImageObjectExtractorHint>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_IncludeRects(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Imaging::IImageObjectExtractorHint>**)this;
            check_hresult(_winrt_abi_type->get_IncludeRects(&value));
        }
        return winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::Graphics::RectInt32>{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Windows_AI_Imaging_IImageObjectExtractorHint<D>::IncludePoints() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::AI::Imaging::IImageObjectExtractorHint>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::AI::Imaging::IImageObjectExtractorHint, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Imaging::IImageObjectExtractorHint>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_IncludePoints(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Imaging::IImageObjectExtractorHint>**)this;
            check_hresult(_winrt_abi_type->get_IncludePoints(&value));
        }
        return winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::Graphics::PointInt32>{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Windows_AI_Imaging_IImageObjectExtractorHint<D>::ExcludePoints() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::AI::Imaging::IImageObjectExtractorHint>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::AI::Imaging::IImageObjectExtractorHint, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Imaging::IImageObjectExtractorHint>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_ExcludePoints(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Imaging::IImageObjectExtractorHint>**)this;
            check_hresult(_winrt_abi_type->get_ExcludePoints(&value));
        }
        return winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::Graphics::PointInt32>{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Windows_AI_Imaging_IImageObjectExtractorHintFactory<D>::CreateInstance(param::vector<winrt::Windows::Graphics::RectInt32> const& includeRects, param::vector<winrt::Windows::Graphics::PointInt32> const& includePoints, param::vector<winrt::Windows::Graphics::PointInt32> const& excludePoints) const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::AI::Imaging::IImageObjectExtractorHintFactory>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::AI::Imaging::IImageObjectExtractorHintFactory, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Imaging::IImageObjectExtractorHintFactory>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->CreateInstance(*(void**)(&includeRects), *(void**)(&includePoints), *(void**)(&excludePoints), &value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Imaging::IImageObjectExtractorHintFactory>**)this;
            check_hresult(_winrt_abi_type->CreateInstance(*(void**)(&includeRects), *(void**)(&includePoints), *(void**)(&excludePoints), &value));
        }
        return winrt::Microsoft::Windows::AI::Imaging::ImageObjectExtractorHint{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Windows_AI_Imaging_IImageObjectExtractorStatics<D>::CreateWithSoftwareBitmapAsync(winrt::Windows::Graphics::Imaging::SoftwareBitmap const& softwareBitmap) const
    {
        void* operation{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::AI::Imaging::IImageObjectExtractorStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::AI::Imaging::IImageObjectExtractorStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Imaging::IImageObjectExtractorStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->CreateWithSoftwareBitmapAsync(*(void**)(&softwareBitmap), &operation));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Imaging::IImageObjectExtractorStatics>**)this;
            check_hresult(_winrt_abi_type->CreateWithSoftwareBitmapAsync(*(void**)(&softwareBitmap), &operation));
        }
        return winrt::Windows::Foundation::IAsyncOperation<winrt::Microsoft::Windows::AI::Imaging::ImageObjectExtractor>{ operation, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Windows_AI_Imaging_IImageObjectExtractorStatics<D>::CreateWithImageBufferAsync(winrt::Microsoft::Graphics::Imaging::ImageBuffer const& imageBuffer) const
    {
        void* operation{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::AI::Imaging::IImageObjectExtractorStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::AI::Imaging::IImageObjectExtractorStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Imaging::IImageObjectExtractorStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->CreateWithImageBufferAsync(*(void**)(&imageBuffer), &operation));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Imaging::IImageObjectExtractorStatics>**)this;
            check_hresult(_winrt_abi_type->CreateWithImageBufferAsync(*(void**)(&imageBuffer), &operation));
        }
        return winrt::Windows::Foundation::IAsyncOperation<winrt::Microsoft::Windows::AI::Imaging::ImageObjectExtractor>{ operation, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Windows_AI_Imaging_IImageObjectExtractorStatics<D>::GetReadyState() const
    {
        winrt::Microsoft::Windows::AI::AIFeatureReadyState result{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::AI::Imaging::IImageObjectExtractorStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::AI::Imaging::IImageObjectExtractorStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Imaging::IImageObjectExtractorStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->GetReadyState(reinterpret_cast<int32_t*>(&result)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Imaging::IImageObjectExtractorStatics>**)this;
            check_hresult(_winrt_abi_type->GetReadyState(reinterpret_cast<int32_t*>(&result)));
        }
        return result;
    }
    template <typename D> auto consume_Microsoft_Windows_AI_Imaging_IImageObjectExtractorStatics<D>::EnsureReadyAsync() const
    {
        void* operation{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::AI::Imaging::IImageObjectExtractorStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::AI::Imaging::IImageObjectExtractorStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Imaging::IImageObjectExtractorStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->EnsureReadyAsync(&operation));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Imaging::IImageObjectExtractorStatics>**)this;
            check_hresult(_winrt_abi_type->EnsureReadyAsync(&operation));
        }
        return winrt::Windows::Foundation::IAsyncOperationWithProgress<winrt::Microsoft::Windows::AI::AIFeatureReadyResult, double>{ operation, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Windows_AI_Imaging_IImageScaler<D>::ScaleSoftwareBitmap(winrt::Windows::Graphics::Imaging::SoftwareBitmap const& softwareBitmap, int32_t width, int32_t height) const
    {
        void* result{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::AI::Imaging::IImageScaler>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::AI::Imaging::IImageScaler, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Imaging::IImageScaler>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->ScaleSoftwareBitmap(*(void**)(&softwareBitmap), width, height, &result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Imaging::IImageScaler>**)this;
            check_hresult(_winrt_abi_type->ScaleSoftwareBitmap(*(void**)(&softwareBitmap), width, height, &result));
        }
        return winrt::Windows::Graphics::Imaging::SoftwareBitmap{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Windows_AI_Imaging_IImageScaler<D>::ScaleImageBuffer(winrt::Microsoft::Graphics::Imaging::ImageBuffer const& imageBuffer, int32_t width, int32_t height) const
    {
        void* result{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::AI::Imaging::IImageScaler>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::AI::Imaging::IImageScaler, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Imaging::IImageScaler>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->ScaleImageBuffer(*(void**)(&imageBuffer), width, height, &result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Imaging::IImageScaler>**)this;
            check_hresult(_winrt_abi_type->ScaleImageBuffer(*(void**)(&imageBuffer), width, height, &result));
        }
        return winrt::Microsoft::Graphics::Imaging::ImageBuffer{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Windows_AI_Imaging_IImageScaler<D>::MaxSupportedScaleFactor() const
    {
        int32_t value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::AI::Imaging::IImageScaler>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::AI::Imaging::IImageScaler, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Imaging::IImageScaler>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_MaxSupportedScaleFactor(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Imaging::IImageScaler>**)this;
            check_hresult(_winrt_abi_type->get_MaxSupportedScaleFactor(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_Windows_AI_Imaging_IImageScalerStatics<D>::GetReadyState() const
    {
        winrt::Microsoft::Windows::AI::AIFeatureReadyState result{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::AI::Imaging::IImageScalerStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::AI::Imaging::IImageScalerStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Imaging::IImageScalerStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->GetReadyState(reinterpret_cast<int32_t*>(&result)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Imaging::IImageScalerStatics>**)this;
            check_hresult(_winrt_abi_type->GetReadyState(reinterpret_cast<int32_t*>(&result)));
        }
        return result;
    }
    template <typename D> auto consume_Microsoft_Windows_AI_Imaging_IImageScalerStatics<D>::EnsureReadyAsync() const
    {
        void* operation{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::AI::Imaging::IImageScalerStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::AI::Imaging::IImageScalerStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Imaging::IImageScalerStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->EnsureReadyAsync(&operation));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Imaging::IImageScalerStatics>**)this;
            check_hresult(_winrt_abi_type->EnsureReadyAsync(&operation));
        }
        return winrt::Windows::Foundation::IAsyncOperationWithProgress<winrt::Microsoft::Windows::AI::AIFeatureReadyResult, double>{ operation, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Windows_AI_Imaging_IImageScalerStatics<D>::CreateAsync() const
    {
        void* operation{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::AI::Imaging::IImageScalerStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::AI::Imaging::IImageScalerStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Imaging::IImageScalerStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->CreateAsync(&operation));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Imaging::IImageScalerStatics>**)this;
            check_hresult(_winrt_abi_type->CreateAsync(&operation));
        }
        return winrt::Windows::Foundation::IAsyncOperation<winrt::Microsoft::Windows::AI::Imaging::ImageScaler>{ operation, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Windows_AI_Imaging_IRecognizedLine<D>::Text() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::AI::Imaging::IRecognizedLine>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::AI::Imaging::IRecognizedLine, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Imaging::IRecognizedLine>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Text(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Imaging::IRecognizedLine>**)this;
            check_hresult(_winrt_abi_type->get_Text(&value));
        }
        return hstring{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Windows_AI_Imaging_IRecognizedLine<D>::BoundingBox() const
    {
        winrt::Microsoft::Windows::AI::Imaging::RecognizedTextBoundingBox value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::AI::Imaging::IRecognizedLine>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::AI::Imaging::IRecognizedLine, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Imaging::IRecognizedLine>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_BoundingBox(put_abi(value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Imaging::IRecognizedLine>**)this;
            check_hresult(_winrt_abi_type->get_BoundingBox(put_abi(value)));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_Windows_AI_Imaging_IRecognizedLine<D>::Words() const
    {
        uint32_t value_impl_size{};
        void** value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::AI::Imaging::IRecognizedLine>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::AI::Imaging::IRecognizedLine, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Imaging::IRecognizedLine>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Words(&value_impl_size, &value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Imaging::IRecognizedLine>**)this;
            check_hresult(_winrt_abi_type->get_Words(&value_impl_size, &value));
        }
        return com_array<winrt::Microsoft::Windows::AI::Imaging::RecognizedWord>{ value, value_impl_size, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Windows_AI_Imaging_IRecognizedLine<D>::Style() const
    {
        winrt::Microsoft::Windows::AI::Imaging::RecognizedLineStyle value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::AI::Imaging::IRecognizedLine>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::AI::Imaging::IRecognizedLine, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Imaging::IRecognizedLine>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Style(reinterpret_cast<int32_t*>(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Imaging::IRecognizedLine>**)this;
            check_hresult(_winrt_abi_type->get_Style(reinterpret_cast<int32_t*>(&value)));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_Windows_AI_Imaging_IRecognizedLine<D>::LineStyleConfidence() const
    {
        float value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::AI::Imaging::IRecognizedLine>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::AI::Imaging::IRecognizedLine, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Imaging::IRecognizedLine>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_LineStyleConfidence(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Imaging::IRecognizedLine>**)this;
            check_hresult(_winrt_abi_type->get_LineStyleConfidence(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_Windows_AI_Imaging_IRecognizedText<D>::Lines() const
    {
        uint32_t value_impl_size{};
        void** value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::AI::Imaging::IRecognizedText>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::AI::Imaging::IRecognizedText, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Imaging::IRecognizedText>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Lines(&value_impl_size, &value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Imaging::IRecognizedText>**)this;
            check_hresult(_winrt_abi_type->get_Lines(&value_impl_size, &value));
        }
        return com_array<winrt::Microsoft::Windows::AI::Imaging::RecognizedLine>{ value, value_impl_size, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Windows_AI_Imaging_IRecognizedText<D>::TextAngle() const
    {
        float value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::AI::Imaging::IRecognizedText>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::AI::Imaging::IRecognizedText, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Imaging::IRecognizedText>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_TextAngle(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Imaging::IRecognizedText>**)this;
            check_hresult(_winrt_abi_type->get_TextAngle(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_Windows_AI_Imaging_IRecognizedWord<D>::Text() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::AI::Imaging::IRecognizedWord>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::AI::Imaging::IRecognizedWord, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Imaging::IRecognizedWord>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Text(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Imaging::IRecognizedWord>**)this;
            check_hresult(_winrt_abi_type->get_Text(&value));
        }
        return hstring{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Windows_AI_Imaging_IRecognizedWord<D>::BoundingBox() const
    {
        winrt::Microsoft::Windows::AI::Imaging::RecognizedTextBoundingBox value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::AI::Imaging::IRecognizedWord>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::AI::Imaging::IRecognizedWord, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Imaging::IRecognizedWord>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_BoundingBox(put_abi(value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Imaging::IRecognizedWord>**)this;
            check_hresult(_winrt_abi_type->get_BoundingBox(put_abi(value)));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_Windows_AI_Imaging_IRecognizedWord<D>::MatchConfidence() const
    {
        float value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::AI::Imaging::IRecognizedWord>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::AI::Imaging::IRecognizedWord, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Imaging::IRecognizedWord>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_MatchConfidence(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Imaging::IRecognizedWord>**)this;
            check_hresult(_winrt_abi_type->get_MatchConfidence(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_Windows_AI_Imaging_ITextRecognizer<D>::RecognizeTextFromImageAsync(winrt::Microsoft::Graphics::Imaging::ImageBuffer const& imageBuffer) const
    {
        void* operation{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::AI::Imaging::ITextRecognizer>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::AI::Imaging::ITextRecognizer, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Imaging::ITextRecognizer>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->RecognizeTextFromImageAsync(*(void**)(&imageBuffer), &operation));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Imaging::ITextRecognizer>**)this;
            check_hresult(_winrt_abi_type->RecognizeTextFromImageAsync(*(void**)(&imageBuffer), &operation));
        }
        return winrt::Windows::Foundation::IAsyncOperation<winrt::Microsoft::Windows::AI::Imaging::RecognizedText>{ operation, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Windows_AI_Imaging_ITextRecognizer<D>::RecognizeTextFromImage(winrt::Microsoft::Graphics::Imaging::ImageBuffer const& imageBuffer) const
    {
        void* result{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::AI::Imaging::ITextRecognizer>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::AI::Imaging::ITextRecognizer, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Imaging::ITextRecognizer>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->RecognizeTextFromImage(*(void**)(&imageBuffer), &result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Imaging::ITextRecognizer>**)this;
            check_hresult(_winrt_abi_type->RecognizeTextFromImage(*(void**)(&imageBuffer), &result));
        }
        return winrt::Microsoft::Windows::AI::Imaging::RecognizedText{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Windows_AI_Imaging_ITextRecognizerStatics<D>::GetReadyState() const
    {
        winrt::Microsoft::Windows::AI::AIFeatureReadyState result{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::AI::Imaging::ITextRecognizerStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::AI::Imaging::ITextRecognizerStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Imaging::ITextRecognizerStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->GetReadyState(reinterpret_cast<int32_t*>(&result)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Imaging::ITextRecognizerStatics>**)this;
            check_hresult(_winrt_abi_type->GetReadyState(reinterpret_cast<int32_t*>(&result)));
        }
        return result;
    }
    template <typename D> auto consume_Microsoft_Windows_AI_Imaging_ITextRecognizerStatics<D>::EnsureReadyAsync() const
    {
        void* operation{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::AI::Imaging::ITextRecognizerStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::AI::Imaging::ITextRecognizerStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Imaging::ITextRecognizerStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->EnsureReadyAsync(&operation));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Imaging::ITextRecognizerStatics>**)this;
            check_hresult(_winrt_abi_type->EnsureReadyAsync(&operation));
        }
        return winrt::Windows::Foundation::IAsyncOperationWithProgress<winrt::Microsoft::Windows::AI::AIFeatureReadyResult, double>{ operation, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Windows_AI_Imaging_ITextRecognizerStatics<D>::CreateAsync() const
    {
        void* operation{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::AI::Imaging::ITextRecognizerStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::AI::Imaging::ITextRecognizerStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Imaging::ITextRecognizerStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->CreateAsync(&operation));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Imaging::ITextRecognizerStatics>**)this;
            check_hresult(_winrt_abi_type->CreateAsync(&operation));
        }
        return winrt::Windows::Foundation::IAsyncOperation<winrt::Microsoft::Windows::AI::Imaging::TextRecognizer>{ operation, take_ownership_from_abi };
    }
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::Windows::AI::Imaging::IImageDescriptionGenerator> : produce_base<D, winrt::Microsoft::Windows::AI::Imaging::IImageDescriptionGenerator>
    {
        int32_t __stdcall DescribeAsync(void* image, int32_t kind, void* contentFilterOptions, void** operation) noexcept final try
        {
            clear_abi(operation);
            typename D::abi_guard guard(this->shim());
            *operation = detach_from<winrt::Windows::Foundation::IAsyncOperationWithProgress<winrt::Microsoft::Windows::AI::Imaging::ImageDescriptionResult, hstring>>(this->shim().DescribeAsync(*reinterpret_cast<winrt::Microsoft::Graphics::Imaging::ImageBuffer const*>(&image), *reinterpret_cast<winrt::Microsoft::Windows::AI::Imaging::ImageDescriptionKind const*>(&kind), *reinterpret_cast<winrt::Microsoft::Windows::AI::ContentSafety::ContentFilterOptions const*>(&contentFilterOptions)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::Windows::AI::Imaging::IImageDescriptionGeneratorStatics> : produce_base<D, winrt::Microsoft::Windows::AI::Imaging::IImageDescriptionGeneratorStatics>
    {
        int32_t __stdcall GetReadyState(int32_t* result) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Microsoft::Windows::AI::AIFeatureReadyState>(this->shim().GetReadyState());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall EnsureReadyAsync(void** operation) noexcept final try
        {
            clear_abi(operation);
            typename D::abi_guard guard(this->shim());
            *operation = detach_from<winrt::Windows::Foundation::IAsyncOperationWithProgress<winrt::Microsoft::Windows::AI::AIFeatureReadyResult, double>>(this->shim().EnsureReadyAsync());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall CreateAsync(void** operation) noexcept final try
        {
            clear_abi(operation);
            typename D::abi_guard guard(this->shim());
            *operation = detach_from<winrt::Windows::Foundation::IAsyncOperation<winrt::Microsoft::Windows::AI::Imaging::ImageDescriptionGenerator>>(this->shim().CreateAsync());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::Windows::AI::Imaging::IImageDescriptionResult> : produce_base<D, winrt::Microsoft::Windows::AI::Imaging::IImageDescriptionResult>
    {
        int32_t __stdcall get_Description(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<hstring>(this->shim().Description());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Status(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::Windows::AI::Imaging::ImageDescriptionResultStatus>(this->shim().Status());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::Windows::AI::Imaging::IImageObjectExtractor> : produce_base<D, winrt::Microsoft::Windows::AI::Imaging::IImageObjectExtractor>
    {
        int32_t __stdcall GetSoftwareBitmapObjectMask(void* hint, void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Windows::Graphics::Imaging::SoftwareBitmap>(this->shim().GetSoftwareBitmapObjectMask(*reinterpret_cast<winrt::Microsoft::Windows::AI::Imaging::ImageObjectExtractorHint const*>(&hint)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall GetImageBufferObjectMask(void* hint, void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Microsoft::Graphics::Imaging::ImageBuffer>(this->shim().GetImageBufferObjectMask(*reinterpret_cast<winrt::Microsoft::Windows::AI::Imaging::ImageObjectExtractorHint const*>(&hint)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::Windows::AI::Imaging::IImageObjectExtractorHint> : produce_base<D, winrt::Microsoft::Windows::AI::Imaging::IImageObjectExtractorHint>
    {
        int32_t __stdcall get_IncludeRects(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::Graphics::RectInt32>>(this->shim().IncludeRects());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_IncludePoints(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::Graphics::PointInt32>>(this->shim().IncludePoints());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_ExcludePoints(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::Graphics::PointInt32>>(this->shim().ExcludePoints());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::Windows::AI::Imaging::IImageObjectExtractorHintFactory> : produce_base<D, winrt::Microsoft::Windows::AI::Imaging::IImageObjectExtractorHintFactory>
    {
        int32_t __stdcall CreateInstance(void* includeRects, void* includePoints, void* excludePoints, void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::Windows::AI::Imaging::ImageObjectExtractorHint>(this->shim().CreateInstance(*reinterpret_cast<winrt::Windows::Foundation::Collections::IVector<winrt::Windows::Graphics::RectInt32> const*>(&includeRects), *reinterpret_cast<winrt::Windows::Foundation::Collections::IVector<winrt::Windows::Graphics::PointInt32> const*>(&includePoints), *reinterpret_cast<winrt::Windows::Foundation::Collections::IVector<winrt::Windows::Graphics::PointInt32> const*>(&excludePoints)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::Windows::AI::Imaging::IImageObjectExtractorStatics> : produce_base<D, winrt::Microsoft::Windows::AI::Imaging::IImageObjectExtractorStatics>
    {
        int32_t __stdcall CreateWithSoftwareBitmapAsync(void* softwareBitmap, void** operation) noexcept final try
        {
            clear_abi(operation);
            typename D::abi_guard guard(this->shim());
            *operation = detach_from<winrt::Windows::Foundation::IAsyncOperation<winrt::Microsoft::Windows::AI::Imaging::ImageObjectExtractor>>(this->shim().CreateWithSoftwareBitmapAsync(*reinterpret_cast<winrt::Windows::Graphics::Imaging::SoftwareBitmap const*>(&softwareBitmap)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall CreateWithImageBufferAsync(void* imageBuffer, void** operation) noexcept final try
        {
            clear_abi(operation);
            typename D::abi_guard guard(this->shim());
            *operation = detach_from<winrt::Windows::Foundation::IAsyncOperation<winrt::Microsoft::Windows::AI::Imaging::ImageObjectExtractor>>(this->shim().CreateWithImageBufferAsync(*reinterpret_cast<winrt::Microsoft::Graphics::Imaging::ImageBuffer const*>(&imageBuffer)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall GetReadyState(int32_t* result) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Microsoft::Windows::AI::AIFeatureReadyState>(this->shim().GetReadyState());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall EnsureReadyAsync(void** operation) noexcept final try
        {
            clear_abi(operation);
            typename D::abi_guard guard(this->shim());
            *operation = detach_from<winrt::Windows::Foundation::IAsyncOperationWithProgress<winrt::Microsoft::Windows::AI::AIFeatureReadyResult, double>>(this->shim().EnsureReadyAsync());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::Windows::AI::Imaging::IImageScaler> : produce_base<D, winrt::Microsoft::Windows::AI::Imaging::IImageScaler>
    {
        int32_t __stdcall ScaleSoftwareBitmap(void* softwareBitmap, int32_t width, int32_t height, void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Windows::Graphics::Imaging::SoftwareBitmap>(this->shim().ScaleSoftwareBitmap(*reinterpret_cast<winrt::Windows::Graphics::Imaging::SoftwareBitmap const*>(&softwareBitmap), width, height));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall ScaleImageBuffer(void* imageBuffer, int32_t width, int32_t height, void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Microsoft::Graphics::Imaging::ImageBuffer>(this->shim().ScaleImageBuffer(*reinterpret_cast<winrt::Microsoft::Graphics::Imaging::ImageBuffer const*>(&imageBuffer), width, height));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_MaxSupportedScaleFactor(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<int32_t>(this->shim().MaxSupportedScaleFactor());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::Windows::AI::Imaging::IImageScalerStatics> : produce_base<D, winrt::Microsoft::Windows::AI::Imaging::IImageScalerStatics>
    {
        int32_t __stdcall GetReadyState(int32_t* result) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Microsoft::Windows::AI::AIFeatureReadyState>(this->shim().GetReadyState());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall EnsureReadyAsync(void** operation) noexcept final try
        {
            clear_abi(operation);
            typename D::abi_guard guard(this->shim());
            *operation = detach_from<winrt::Windows::Foundation::IAsyncOperationWithProgress<winrt::Microsoft::Windows::AI::AIFeatureReadyResult, double>>(this->shim().EnsureReadyAsync());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall CreateAsync(void** operation) noexcept final try
        {
            clear_abi(operation);
            typename D::abi_guard guard(this->shim());
            *operation = detach_from<winrt::Windows::Foundation::IAsyncOperation<winrt::Microsoft::Windows::AI::Imaging::ImageScaler>>(this->shim().CreateAsync());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::Windows::AI::Imaging::IRecognizedLine> : produce_base<D, winrt::Microsoft::Windows::AI::Imaging::IRecognizedLine>
    {
        int32_t __stdcall get_Text(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<hstring>(this->shim().Text());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_BoundingBox(struct struct_Microsoft_Windows_AI_Imaging_RecognizedTextBoundingBox* value) noexcept final try
        {
            zero_abi<winrt::Microsoft::Windows::AI::Imaging::RecognizedTextBoundingBox>(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::Windows::AI::Imaging::RecognizedTextBoundingBox>(this->shim().BoundingBox());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Words(uint32_t* __valueSize, void*** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            std::tie(*__valueSize, *value) = detach_abi(this->shim().Words());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Style(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::Windows::AI::Imaging::RecognizedLineStyle>(this->shim().Style());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_LineStyleConfidence(float* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<float>(this->shim().LineStyleConfidence());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::Windows::AI::Imaging::IRecognizedText> : produce_base<D, winrt::Microsoft::Windows::AI::Imaging::IRecognizedText>
    {
        int32_t __stdcall get_Lines(uint32_t* __valueSize, void*** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            std::tie(*__valueSize, *value) = detach_abi(this->shim().Lines());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_TextAngle(float* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<float>(this->shim().TextAngle());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::Windows::AI::Imaging::IRecognizedWord> : produce_base<D, winrt::Microsoft::Windows::AI::Imaging::IRecognizedWord>
    {
        int32_t __stdcall get_Text(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<hstring>(this->shim().Text());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_BoundingBox(struct struct_Microsoft_Windows_AI_Imaging_RecognizedTextBoundingBox* value) noexcept final try
        {
            zero_abi<winrt::Microsoft::Windows::AI::Imaging::RecognizedTextBoundingBox>(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::Windows::AI::Imaging::RecognizedTextBoundingBox>(this->shim().BoundingBox());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_MatchConfidence(float* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<float>(this->shim().MatchConfidence());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::Windows::AI::Imaging::ITextRecognizer> : produce_base<D, winrt::Microsoft::Windows::AI::Imaging::ITextRecognizer>
    {
        int32_t __stdcall RecognizeTextFromImageAsync(void* imageBuffer, void** operation) noexcept final try
        {
            clear_abi(operation);
            typename D::abi_guard guard(this->shim());
            *operation = detach_from<winrt::Windows::Foundation::IAsyncOperation<winrt::Microsoft::Windows::AI::Imaging::RecognizedText>>(this->shim().RecognizeTextFromImageAsync(*reinterpret_cast<winrt::Microsoft::Graphics::Imaging::ImageBuffer const*>(&imageBuffer)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall RecognizeTextFromImage(void* imageBuffer, void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Microsoft::Windows::AI::Imaging::RecognizedText>(this->shim().RecognizeTextFromImage(*reinterpret_cast<winrt::Microsoft::Graphics::Imaging::ImageBuffer const*>(&imageBuffer)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::Windows::AI::Imaging::ITextRecognizerStatics> : produce_base<D, winrt::Microsoft::Windows::AI::Imaging::ITextRecognizerStatics>
    {
        int32_t __stdcall GetReadyState(int32_t* result) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Microsoft::Windows::AI::AIFeatureReadyState>(this->shim().GetReadyState());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall EnsureReadyAsync(void** operation) noexcept final try
        {
            clear_abi(operation);
            typename D::abi_guard guard(this->shim());
            *operation = detach_from<winrt::Windows::Foundation::IAsyncOperationWithProgress<winrt::Microsoft::Windows::AI::AIFeatureReadyResult, double>>(this->shim().EnsureReadyAsync());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall CreateAsync(void** operation) noexcept final try
        {
            clear_abi(operation);
            typename D::abi_guard guard(this->shim());
            *operation = detach_from<winrt::Windows::Foundation::IAsyncOperation<winrt::Microsoft::Windows::AI::Imaging::TextRecognizer>>(this->shim().CreateAsync());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
}
WINRT_EXPORT namespace winrt::Microsoft::Windows::AI::Imaging
{
    inline auto ImageDescriptionGenerator::GetReadyState()
    {
        return impl::call_factory_cast<winrt::Microsoft::Windows::AI::AIFeatureReadyState(*)(IImageDescriptionGeneratorStatics const&), ImageDescriptionGenerator, IImageDescriptionGeneratorStatics>([](IImageDescriptionGeneratorStatics const& f) { return f.GetReadyState(); });
    }
    inline auto ImageDescriptionGenerator::EnsureReadyAsync()
    {
        return impl::call_factory_cast<winrt::Windows::Foundation::IAsyncOperationWithProgress<winrt::Microsoft::Windows::AI::AIFeatureReadyResult, double>(*)(IImageDescriptionGeneratorStatics const&), ImageDescriptionGenerator, IImageDescriptionGeneratorStatics>([](IImageDescriptionGeneratorStatics const& f) { return f.EnsureReadyAsync(); });
    }
    inline auto ImageDescriptionGenerator::CreateAsync()
    {
        return impl::call_factory_cast<winrt::Windows::Foundation::IAsyncOperation<winrt::Microsoft::Windows::AI::Imaging::ImageDescriptionGenerator>(*)(IImageDescriptionGeneratorStatics const&), ImageDescriptionGenerator, IImageDescriptionGeneratorStatics>([](IImageDescriptionGeneratorStatics const& f) { return f.CreateAsync(); });
    }
    inline auto ImageObjectExtractor::CreateWithSoftwareBitmapAsync(winrt::Windows::Graphics::Imaging::SoftwareBitmap const& softwareBitmap)
    {
        return impl::call_factory<ImageObjectExtractor, IImageObjectExtractorStatics>([&](IImageObjectExtractorStatics const& f) { return f.CreateWithSoftwareBitmapAsync(softwareBitmap); });
    }
    inline auto ImageObjectExtractor::CreateWithImageBufferAsync(winrt::Microsoft::Graphics::Imaging::ImageBuffer const& imageBuffer)
    {
        return impl::call_factory<ImageObjectExtractor, IImageObjectExtractorStatics>([&](IImageObjectExtractorStatics const& f) { return f.CreateWithImageBufferAsync(imageBuffer); });
    }
    inline auto ImageObjectExtractor::GetReadyState()
    {
        return impl::call_factory_cast<winrt::Microsoft::Windows::AI::AIFeatureReadyState(*)(IImageObjectExtractorStatics const&), ImageObjectExtractor, IImageObjectExtractorStatics>([](IImageObjectExtractorStatics const& f) { return f.GetReadyState(); });
    }
    inline auto ImageObjectExtractor::EnsureReadyAsync()
    {
        return impl::call_factory_cast<winrt::Windows::Foundation::IAsyncOperationWithProgress<winrt::Microsoft::Windows::AI::AIFeatureReadyResult, double>(*)(IImageObjectExtractorStatics const&), ImageObjectExtractor, IImageObjectExtractorStatics>([](IImageObjectExtractorStatics const& f) { return f.EnsureReadyAsync(); });
    }
    inline ImageObjectExtractorHint::ImageObjectExtractorHint(param::vector<winrt::Windows::Graphics::RectInt32> const& includeRects, param::vector<winrt::Windows::Graphics::PointInt32> const& includePoints, param::vector<winrt::Windows::Graphics::PointInt32> const& excludePoints) :
        ImageObjectExtractorHint(impl::call_factory<ImageObjectExtractorHint, IImageObjectExtractorHintFactory>([&](IImageObjectExtractorHintFactory const& f) { return f.CreateInstance(includeRects, includePoints, excludePoints); }))
    {
    }
    inline auto ImageScaler::GetReadyState()
    {
        return impl::call_factory_cast<winrt::Microsoft::Windows::AI::AIFeatureReadyState(*)(IImageScalerStatics const&), ImageScaler, IImageScalerStatics>([](IImageScalerStatics const& f) { return f.GetReadyState(); });
    }
    inline auto ImageScaler::EnsureReadyAsync()
    {
        return impl::call_factory_cast<winrt::Windows::Foundation::IAsyncOperationWithProgress<winrt::Microsoft::Windows::AI::AIFeatureReadyResult, double>(*)(IImageScalerStatics const&), ImageScaler, IImageScalerStatics>([](IImageScalerStatics const& f) { return f.EnsureReadyAsync(); });
    }
    inline auto ImageScaler::CreateAsync()
    {
        return impl::call_factory_cast<winrt::Windows::Foundation::IAsyncOperation<winrt::Microsoft::Windows::AI::Imaging::ImageScaler>(*)(IImageScalerStatics const&), ImageScaler, IImageScalerStatics>([](IImageScalerStatics const& f) { return f.CreateAsync(); });
    }
    inline auto TextRecognizer::GetReadyState()
    {
        return impl::call_factory_cast<winrt::Microsoft::Windows::AI::AIFeatureReadyState(*)(ITextRecognizerStatics const&), TextRecognizer, ITextRecognizerStatics>([](ITextRecognizerStatics const& f) { return f.GetReadyState(); });
    }
    inline auto TextRecognizer::EnsureReadyAsync()
    {
        return impl::call_factory_cast<winrt::Windows::Foundation::IAsyncOperationWithProgress<winrt::Microsoft::Windows::AI::AIFeatureReadyResult, double>(*)(ITextRecognizerStatics const&), TextRecognizer, ITextRecognizerStatics>([](ITextRecognizerStatics const& f) { return f.EnsureReadyAsync(); });
    }
    inline auto TextRecognizer::CreateAsync()
    {
        return impl::call_factory_cast<winrt::Windows::Foundation::IAsyncOperation<winrt::Microsoft::Windows::AI::Imaging::TextRecognizer>(*)(ITextRecognizerStatics const&), TextRecognizer, ITextRecognizerStatics>([](ITextRecognizerStatics const& f) { return f.CreateAsync(); });
    }
}
namespace std
{
#ifndef WINRT_LEAN_AND_MEAN
    template<> struct hash<winrt::Microsoft::Windows::AI::Imaging::IImageDescriptionGenerator> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Windows::AI::Imaging::IImageDescriptionGeneratorStatics> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Windows::AI::Imaging::IImageDescriptionResult> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Windows::AI::Imaging::IImageObjectExtractor> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Windows::AI::Imaging::IImageObjectExtractorHint> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Windows::AI::Imaging::IImageObjectExtractorHintFactory> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Windows::AI::Imaging::IImageObjectExtractorStatics> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Windows::AI::Imaging::IImageScaler> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Windows::AI::Imaging::IImageScalerStatics> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Windows::AI::Imaging::IRecognizedLine> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Windows::AI::Imaging::IRecognizedText> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Windows::AI::Imaging::IRecognizedWord> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Windows::AI::Imaging::ITextRecognizer> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Windows::AI::Imaging::ITextRecognizerStatics> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Windows::AI::Imaging::ImageDescriptionGenerator> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Windows::AI::Imaging::ImageDescriptionResult> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Windows::AI::Imaging::ImageObjectExtractor> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Windows::AI::Imaging::ImageObjectExtractorHint> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Windows::AI::Imaging::ImageScaler> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Windows::AI::Imaging::RecognizedLine> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Windows::AI::Imaging::RecognizedText> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Windows::AI::Imaging::RecognizedWord> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Windows::AI::Imaging::TextRecognizer> : winrt::impl::hash_base {};
#endif
#ifdef __cpp_lib_format
#endif
}
#endif
