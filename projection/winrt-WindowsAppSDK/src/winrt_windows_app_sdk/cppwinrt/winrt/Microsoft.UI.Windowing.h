// WARNING: Please don't edit this file. It was generated by C++/WinRT v2.0.250303.1

#pragma once
#ifndef WINRT_Microsoft_UI_Windowing_H
#define WINRT_Microsoft_UI_Windowing_H
#include "winrt/base.h"
static_assert(winrt::check_version(CPPWINRT_VERSION, "2.0.250303.1"), "Mismatched C++/WinRT headers.");
#define CPPWINRT_VERSION "2.0.250303.1"
#include "winrt/Microsoft.UI.h"
#include "winrt/impl/Microsoft.UI.2.h"
#include "winrt/impl/Microsoft.UI.Dispatching.2.h"
#include "winrt/impl/Windows.Foundation.2.h"
#include "winrt/impl/Windows.Foundation.Collections.2.h"
#include "winrt/impl/Windows.Graphics.2.h"
#include "winrt/impl/Windows.UI.2.h"
#include "winrt/impl/Microsoft.UI.Windowing.2.h"
namespace winrt::impl
{
    template <typename D> auto consume_Microsoft_UI_Windowing_IAppWindow<D>::Id() const
    {
        winrt::Microsoft::UI::WindowId value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Windowing::IAppWindow>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Windowing::IAppWindow, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindow>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Id(put_abi(value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindow>**)this;
            check_hresult(_winrt_abi_type->get_Id(put_abi(value)));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Windowing_IAppWindow<D>::IsShownInSwitchers() const
    {
        bool value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Windowing::IAppWindow>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Windowing::IAppWindow, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindow>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_IsShownInSwitchers(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindow>**)this;
            check_hresult(_winrt_abi_type->get_IsShownInSwitchers(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Windowing_IAppWindow<D>::IsShownInSwitchers(bool value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Windowing::IAppWindow>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Windowing::IAppWindow, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindow>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_IsShownInSwitchers(value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindow>**)this;
            check_hresult(_winrt_abi_type->put_IsShownInSwitchers(value));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Windowing_IAppWindow<D>::IsVisible() const
    {
        bool value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Windowing::IAppWindow>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Windowing::IAppWindow, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindow>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_IsVisible(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindow>**)this;
            check_hresult(_winrt_abi_type->get_IsVisible(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Windowing_IAppWindow<D>::OwnerWindowId() const
    {
        winrt::Microsoft::UI::WindowId value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Windowing::IAppWindow>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Windowing::IAppWindow, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindow>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_OwnerWindowId(put_abi(value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindow>**)this;
            check_hresult(_winrt_abi_type->get_OwnerWindowId(put_abi(value)));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Windowing_IAppWindow<D>::Position() const
    {
        winrt::Windows::Graphics::PointInt32 value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Windowing::IAppWindow>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Windowing::IAppWindow, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindow>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Position(put_abi(value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindow>**)this;
            check_hresult(_winrt_abi_type->get_Position(put_abi(value)));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Windowing_IAppWindow<D>::Presenter() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Windowing::IAppWindow>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Windowing::IAppWindow, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindow>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Presenter(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindow>**)this;
            check_hresult(_winrt_abi_type->get_Presenter(&value));
        }
        return winrt::Microsoft::UI::Windowing::AppWindowPresenter{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Windowing_IAppWindow<D>::Size() const
    {
        winrt::Windows::Graphics::SizeInt32 value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Windowing::IAppWindow>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Windowing::IAppWindow, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindow>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Size(put_abi(value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindow>**)this;
            check_hresult(_winrt_abi_type->get_Size(put_abi(value)));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Windowing_IAppWindow<D>::Title() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Windowing::IAppWindow>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Windowing::IAppWindow, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindow>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Title(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindow>**)this;
            check_hresult(_winrt_abi_type->get_Title(&value));
        }
        return hstring{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Windowing_IAppWindow<D>::Title(param::hstring const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Windowing::IAppWindow>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Windowing::IAppWindow, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindow>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_Title(*(void**)(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindow>**)this;
            check_hresult(_winrt_abi_type->put_Title(*(void**)(&value)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Windowing_IAppWindow<D>::TitleBar() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Windowing::IAppWindow>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Windowing::IAppWindow, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindow>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_TitleBar(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindow>**)this;
            check_hresult(_winrt_abi_type->get_TitleBar(&value));
        }
        return winrt::Microsoft::UI::Windowing::AppWindowTitleBar{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Windowing_IAppWindow<D>::Destroy() const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Windowing::IAppWindow>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Windowing::IAppWindow, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindow>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->Destroy());
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindow>**)this;
            check_hresult(_winrt_abi_type->Destroy());
        }
    }
    template <typename D> auto consume_Microsoft_UI_Windowing_IAppWindow<D>::Hide() const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Windowing::IAppWindow>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Windowing::IAppWindow, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindow>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->Hide());
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindow>**)this;
            check_hresult(_winrt_abi_type->Hide());
        }
    }
    template <typename D> auto consume_Microsoft_UI_Windowing_IAppWindow<D>::Move(winrt::Windows::Graphics::PointInt32 const& position) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Windowing::IAppWindow>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Windowing::IAppWindow, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindow>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->Move(impl::bind_in(position)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindow>**)this;
            check_hresult(_winrt_abi_type->Move(impl::bind_in(position)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Windowing_IAppWindow<D>::MoveAndResize(winrt::Windows::Graphics::RectInt32 const& rect) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Windowing::IAppWindow>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Windowing::IAppWindow, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindow>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->MoveAndResize(impl::bind_in(rect)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindow>**)this;
            check_hresult(_winrt_abi_type->MoveAndResize(impl::bind_in(rect)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Windowing_IAppWindow<D>::MoveAndResize(winrt::Windows::Graphics::RectInt32 const& rect, winrt::Microsoft::UI::Windowing::DisplayArea const& displayarea) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Windowing::IAppWindow>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Windowing::IAppWindow, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindow>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->MoveAndResizeRelativeToDisplayArea(impl::bind_in(rect), *(void**)(&displayarea)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindow>**)this;
            check_hresult(_winrt_abi_type->MoveAndResizeRelativeToDisplayArea(impl::bind_in(rect), *(void**)(&displayarea)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Windowing_IAppWindow<D>::Resize(winrt::Windows::Graphics::SizeInt32 const& size) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Windowing::IAppWindow>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Windowing::IAppWindow, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindow>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->Resize(impl::bind_in(size)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindow>**)this;
            check_hresult(_winrt_abi_type->Resize(impl::bind_in(size)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Windowing_IAppWindow<D>::SetIcon(param::hstring const& iconPath) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Windowing::IAppWindow>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Windowing::IAppWindow, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindow>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->SetIcon(*(void**)(&iconPath)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindow>**)this;
            check_hresult(_winrt_abi_type->SetIcon(*(void**)(&iconPath)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Windowing_IAppWindow<D>::SetIcon(winrt::Microsoft::UI::IconId const& iconId) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Windowing::IAppWindow>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Windowing::IAppWindow, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindow>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->SetIconWithIconId(impl::bind_in(iconId)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindow>**)this;
            check_hresult(_winrt_abi_type->SetIconWithIconId(impl::bind_in(iconId)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Windowing_IAppWindow<D>::SetPresenter(winrt::Microsoft::UI::Windowing::AppWindowPresenter const& appWindowPresenter) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Windowing::IAppWindow>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Windowing::IAppWindow, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindow>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->SetPresenter(*(void**)(&appWindowPresenter)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindow>**)this;
            check_hresult(_winrt_abi_type->SetPresenter(*(void**)(&appWindowPresenter)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Windowing_IAppWindow<D>::SetPresenter(winrt::Microsoft::UI::Windowing::AppWindowPresenterKind const& appWindowPresenterKind) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Windowing::IAppWindow>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Windowing::IAppWindow, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindow>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->SetPresenterByKind(static_cast<int32_t>(appWindowPresenterKind)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindow>**)this;
            check_hresult(_winrt_abi_type->SetPresenterByKind(static_cast<int32_t>(appWindowPresenterKind)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Windowing_IAppWindow<D>::Show() const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Windowing::IAppWindow>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Windowing::IAppWindow, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindow>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->Show());
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindow>**)this;
            check_hresult(_winrt_abi_type->Show());
        }
    }
    template <typename D> auto consume_Microsoft_UI_Windowing_IAppWindow<D>::Show(bool activateWindow) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Windowing::IAppWindow>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Windowing::IAppWindow, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindow>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->ShowWithActivation(activateWindow));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindow>**)this;
            check_hresult(_winrt_abi_type->ShowWithActivation(activateWindow));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Windowing_IAppWindow<D>::Changed(winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Windowing::AppWindow, winrt::Microsoft::UI::Windowing::AppWindowChangedEventArgs> const& handler) const
    {
        winrt::event_token token{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Windowing::IAppWindow>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Windowing::IAppWindow, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindow>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->add_Changed(*(void**)(&handler), put_abi(token)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindow>**)this;
            check_hresult(_winrt_abi_type->add_Changed(*(void**)(&handler), put_abi(token)));
        }
        return token;
    }
    template <typename D> auto consume_Microsoft_UI_Windowing_IAppWindow<D>::Changed(auto_revoke_t, winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Windowing::AppWindow, winrt::Microsoft::UI::Windowing::AppWindowChangedEventArgs> const& handler) const
    {
        return impl::make_event_revoker<D, Changed_revoker>(this, Changed(handler));
    }
    template <typename D> auto consume_Microsoft_UI_Windowing_IAppWindow<D>::Changed(winrt::event_token const& token) const noexcept
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Windowing::IAppWindow>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Windowing::IAppWindow, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindow>**)&_winrt_casted_result;
            _winrt_abi_type->remove_Changed(impl::bind_in(token));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindow>**)this;
            _winrt_abi_type->remove_Changed(impl::bind_in(token));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Windowing_IAppWindow<D>::Closing(winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Windowing::AppWindow, winrt::Microsoft::UI::Windowing::AppWindowClosingEventArgs> const& handler) const
    {
        winrt::event_token token{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Windowing::IAppWindow>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Windowing::IAppWindow, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindow>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->add_Closing(*(void**)(&handler), put_abi(token)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindow>**)this;
            check_hresult(_winrt_abi_type->add_Closing(*(void**)(&handler), put_abi(token)));
        }
        return token;
    }
    template <typename D> auto consume_Microsoft_UI_Windowing_IAppWindow<D>::Closing(auto_revoke_t, winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Windowing::AppWindow, winrt::Microsoft::UI::Windowing::AppWindowClosingEventArgs> const& handler) const
    {
        return impl::make_event_revoker<D, Closing_revoker>(this, Closing(handler));
    }
    template <typename D> auto consume_Microsoft_UI_Windowing_IAppWindow<D>::Closing(winrt::event_token const& token) const noexcept
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Windowing::IAppWindow>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Windowing::IAppWindow, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindow>**)&_winrt_casted_result;
            _winrt_abi_type->remove_Closing(impl::bind_in(token));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindow>**)this;
            _winrt_abi_type->remove_Closing(impl::bind_in(token));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Windowing_IAppWindow<D>::Destroying(winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Windowing::AppWindow, winrt::Windows::Foundation::IInspectable> const& handler) const
    {
        winrt::event_token token{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Windowing::IAppWindow>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Windowing::IAppWindow, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindow>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->add_Destroying(*(void**)(&handler), put_abi(token)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindow>**)this;
            check_hresult(_winrt_abi_type->add_Destroying(*(void**)(&handler), put_abi(token)));
        }
        return token;
    }
    template <typename D> auto consume_Microsoft_UI_Windowing_IAppWindow<D>::Destroying(auto_revoke_t, winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Windowing::AppWindow, winrt::Windows::Foundation::IInspectable> const& handler) const
    {
        return impl::make_event_revoker<D, Destroying_revoker>(this, Destroying(handler));
    }
    template <typename D> auto consume_Microsoft_UI_Windowing_IAppWindow<D>::Destroying(winrt::event_token const& token) const noexcept
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Windowing::IAppWindow>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Windowing::IAppWindow, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindow>**)&_winrt_casted_result;
            _winrt_abi_type->remove_Destroying(impl::bind_in(token));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindow>**)this;
            _winrt_abi_type->remove_Destroying(impl::bind_in(token));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Windowing_IAppWindow2<D>::ClientSize() const
    {
        winrt::Windows::Graphics::SizeInt32 value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Windowing::IAppWindow2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Windowing::IAppWindow2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindow2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_ClientSize(put_abi(value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindow2>**)this;
            check_hresult(_winrt_abi_type->get_ClientSize(put_abi(value)));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Windowing_IAppWindow2<D>::MoveInZOrderAtBottom() const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Windowing::IAppWindow2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Windowing::IAppWindow2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindow2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->MoveInZOrderAtBottom());
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindow2>**)this;
            check_hresult(_winrt_abi_type->MoveInZOrderAtBottom());
        }
    }
    template <typename D> auto consume_Microsoft_UI_Windowing_IAppWindow2<D>::MoveInZOrderAtTop() const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Windowing::IAppWindow2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Windowing::IAppWindow2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindow2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->MoveInZOrderAtTop());
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindow2>**)this;
            check_hresult(_winrt_abi_type->MoveInZOrderAtTop());
        }
    }
    template <typename D> auto consume_Microsoft_UI_Windowing_IAppWindow2<D>::MoveInZOrderBelow(winrt::Microsoft::UI::WindowId const& windowId) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Windowing::IAppWindow2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Windowing::IAppWindow2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindow2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->MoveInZOrderBelow(impl::bind_in(windowId)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindow2>**)this;
            check_hresult(_winrt_abi_type->MoveInZOrderBelow(impl::bind_in(windowId)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Windowing_IAppWindow2<D>::ResizeClient(winrt::Windows::Graphics::SizeInt32 const& size) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Windowing::IAppWindow2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Windowing::IAppWindow2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindow2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->ResizeClient(impl::bind_in(size)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindow2>**)this;
            check_hresult(_winrt_abi_type->ResizeClient(impl::bind_in(size)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Windowing_IAppWindow2<D>::ShowOnceWithRequestedStartupState() const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Windowing::IAppWindow2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Windowing::IAppWindow2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindow2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->ShowOnceWithRequestedStartupState());
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindow2>**)this;
            check_hresult(_winrt_abi_type->ShowOnceWithRequestedStartupState());
        }
    }
    template <typename D> auto consume_Microsoft_UI_Windowing_IAppWindow3<D>::AssociateWithDispatcherQueue(winrt::Microsoft::UI::Dispatching::DispatcherQueue const& dispatcherQueue) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Windowing::IAppWindow3>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Windowing::IAppWindow3, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindow3>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->AssociateWithDispatcherQueue(*(void**)(&dispatcherQueue)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindow3>**)this;
            check_hresult(_winrt_abi_type->AssociateWithDispatcherQueue(*(void**)(&dispatcherQueue)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Windowing_IAppWindow3<D>::DispatcherQueue() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Windowing::IAppWindow3>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Windowing::IAppWindow3, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindow3>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_DispatcherQueue(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindow3>**)this;
            check_hresult(_winrt_abi_type->get_DispatcherQueue(&value));
        }
        return winrt::Microsoft::UI::Dispatching::DispatcherQueue{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Windowing_IAppWindow4<D>::SetTaskbarIcon(param::hstring const& iconPath) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Windowing::IAppWindow4>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Windowing::IAppWindow4, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindow4>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->SetTaskbarIcon(*(void**)(&iconPath)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindow4>**)this;
            check_hresult(_winrt_abi_type->SetTaskbarIcon(*(void**)(&iconPath)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Windowing_IAppWindow4<D>::SetTaskbarIcon(winrt::Microsoft::UI::IconId const& iconId) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Windowing::IAppWindow4>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Windowing::IAppWindow4, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindow4>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->SetTaskbarIconWithIconId(impl::bind_in(iconId)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindow4>**)this;
            check_hresult(_winrt_abi_type->SetTaskbarIconWithIconId(impl::bind_in(iconId)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Windowing_IAppWindow4<D>::SetTitleBarIcon(param::hstring const& iconPath) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Windowing::IAppWindow4>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Windowing::IAppWindow4, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindow4>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->SetTitleBarIcon(*(void**)(&iconPath)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindow4>**)this;
            check_hresult(_winrt_abi_type->SetTitleBarIcon(*(void**)(&iconPath)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Windowing_IAppWindow4<D>::SetTitleBarIcon(winrt::Microsoft::UI::IconId const& iconId) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Windowing::IAppWindow4>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Windowing::IAppWindow4, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindow4>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->SetTitleBarIconWithIconId(impl::bind_in(iconId)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindow4>**)this;
            check_hresult(_winrt_abi_type->SetTitleBarIconWithIconId(impl::bind_in(iconId)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Windowing_IAppWindowChangedEventArgs<D>::DidPositionChange() const
    {
        bool value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Windowing::IAppWindowChangedEventArgs>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Windowing::IAppWindowChangedEventArgs, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindowChangedEventArgs>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_DidPositionChange(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindowChangedEventArgs>**)this;
            check_hresult(_winrt_abi_type->get_DidPositionChange(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Windowing_IAppWindowChangedEventArgs<D>::DidPresenterChange() const
    {
        bool value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Windowing::IAppWindowChangedEventArgs>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Windowing::IAppWindowChangedEventArgs, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindowChangedEventArgs>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_DidPresenterChange(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindowChangedEventArgs>**)this;
            check_hresult(_winrt_abi_type->get_DidPresenterChange(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Windowing_IAppWindowChangedEventArgs<D>::DidSizeChange() const
    {
        bool value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Windowing::IAppWindowChangedEventArgs>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Windowing::IAppWindowChangedEventArgs, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindowChangedEventArgs>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_DidSizeChange(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindowChangedEventArgs>**)this;
            check_hresult(_winrt_abi_type->get_DidSizeChange(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Windowing_IAppWindowChangedEventArgs<D>::DidVisibilityChange() const
    {
        bool value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Windowing::IAppWindowChangedEventArgs>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Windowing::IAppWindowChangedEventArgs, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindowChangedEventArgs>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_DidVisibilityChange(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindowChangedEventArgs>**)this;
            check_hresult(_winrt_abi_type->get_DidVisibilityChange(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Windowing_IAppWindowChangedEventArgs2<D>::DidZOrderChange() const
    {
        bool value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Windowing::IAppWindowChangedEventArgs2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Windowing::IAppWindowChangedEventArgs2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindowChangedEventArgs2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_DidZOrderChange(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindowChangedEventArgs2>**)this;
            check_hresult(_winrt_abi_type->get_DidZOrderChange(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Windowing_IAppWindowChangedEventArgs2<D>::IsZOrderAtBottom() const
    {
        bool value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Windowing::IAppWindowChangedEventArgs2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Windowing::IAppWindowChangedEventArgs2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindowChangedEventArgs2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_IsZOrderAtBottom(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindowChangedEventArgs2>**)this;
            check_hresult(_winrt_abi_type->get_IsZOrderAtBottom(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Windowing_IAppWindowChangedEventArgs2<D>::IsZOrderAtTop() const
    {
        bool value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Windowing::IAppWindowChangedEventArgs2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Windowing::IAppWindowChangedEventArgs2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindowChangedEventArgs2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_IsZOrderAtTop(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindowChangedEventArgs2>**)this;
            check_hresult(_winrt_abi_type->get_IsZOrderAtTop(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Windowing_IAppWindowChangedEventArgs2<D>::ZOrderBelowWindowId() const
    {
        winrt::Microsoft::UI::WindowId value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Windowing::IAppWindowChangedEventArgs2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Windowing::IAppWindowChangedEventArgs2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindowChangedEventArgs2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_ZOrderBelowWindowId(put_abi(value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindowChangedEventArgs2>**)this;
            check_hresult(_winrt_abi_type->get_ZOrderBelowWindowId(put_abi(value)));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Windowing_IAppWindowClosingEventArgs<D>::Cancel() const
    {
        bool value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Windowing::IAppWindowClosingEventArgs>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Windowing::IAppWindowClosingEventArgs, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindowClosingEventArgs>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Cancel(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindowClosingEventArgs>**)this;
            check_hresult(_winrt_abi_type->get_Cancel(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Windowing_IAppWindowClosingEventArgs<D>::Cancel(bool value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Windowing::IAppWindowClosingEventArgs>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Windowing::IAppWindowClosingEventArgs, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindowClosingEventArgs>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_Cancel(value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindowClosingEventArgs>**)this;
            check_hresult(_winrt_abi_type->put_Cancel(value));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Windowing_IAppWindowPresenter<D>::Kind() const
    {
        winrt::Microsoft::UI::Windowing::AppWindowPresenterKind value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Windowing::IAppWindowPresenter>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Windowing::IAppWindowPresenter, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindowPresenter>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Kind(reinterpret_cast<int32_t*>(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindowPresenter>**)this;
            check_hresult(_winrt_abi_type->get_Kind(reinterpret_cast<int32_t*>(&value)));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Windowing_IAppWindowStatics<D>::Create() const
    {
        void* result{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Windowing::IAppWindowStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Windowing::IAppWindowStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindowStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->Create(&result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindowStatics>**)this;
            check_hresult(_winrt_abi_type->Create(&result));
        }
        return winrt::Microsoft::UI::Windowing::AppWindow{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Windowing_IAppWindowStatics<D>::Create(winrt::Microsoft::UI::Windowing::AppWindowPresenter const& appWindowPresenter) const
    {
        void* result{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Windowing::IAppWindowStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Windowing::IAppWindowStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindowStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->CreateWithPresenter(*(void**)(&appWindowPresenter), &result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindowStatics>**)this;
            check_hresult(_winrt_abi_type->CreateWithPresenter(*(void**)(&appWindowPresenter), &result));
        }
        return winrt::Microsoft::UI::Windowing::AppWindow{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Windowing_IAppWindowStatics<D>::Create(winrt::Microsoft::UI::Windowing::AppWindowPresenter const& appWindowPresenter, winrt::Microsoft::UI::WindowId const& ownerWindowId) const
    {
        void* result{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Windowing::IAppWindowStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Windowing::IAppWindowStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindowStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->CreateWithPresenterAndOwner(*(void**)(&appWindowPresenter), impl::bind_in(ownerWindowId), &result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindowStatics>**)this;
            check_hresult(_winrt_abi_type->CreateWithPresenterAndOwner(*(void**)(&appWindowPresenter), impl::bind_in(ownerWindowId), &result));
        }
        return winrt::Microsoft::UI::Windowing::AppWindow{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Windowing_IAppWindowStatics<D>::GetFromWindowId(winrt::Microsoft::UI::WindowId const& windowId) const
    {
        void* result{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Windowing::IAppWindowStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Windowing::IAppWindowStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindowStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->GetFromWindowId(impl::bind_in(windowId), &result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindowStatics>**)this;
            check_hresult(_winrt_abi_type->GetFromWindowId(impl::bind_in(windowId), &result));
        }
        return winrt::Microsoft::UI::Windowing::AppWindow{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Windowing_IAppWindowStatics2<D>::Create(winrt::Microsoft::UI::Windowing::AppWindowPresenter const& appWindowPresenter, winrt::Microsoft::UI::WindowId const& ownerWindowId, winrt::Microsoft::UI::Dispatching::DispatcherQueue const& DispatcherQueue) const
    {
        void* result{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Windowing::IAppWindowStatics2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Windowing::IAppWindowStatics2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindowStatics2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->CreateWithDispatcherQueue(*(void**)(&appWindowPresenter), impl::bind_in(ownerWindowId), *(void**)(&DispatcherQueue), &result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindowStatics2>**)this;
            check_hresult(_winrt_abi_type->CreateWithDispatcherQueue(*(void**)(&appWindowPresenter), impl::bind_in(ownerWindowId), *(void**)(&DispatcherQueue), &result));
        }
        return winrt::Microsoft::UI::Windowing::AppWindow{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Windowing_IAppWindowTitleBar<D>::BackgroundColor() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Windowing::IAppWindowTitleBar>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Windowing::IAppWindowTitleBar, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindowTitleBar>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_BackgroundColor(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindowTitleBar>**)this;
            check_hresult(_winrt_abi_type->get_BackgroundColor(&value));
        }
        return winrt::Windows::Foundation::IReference<winrt::Windows::UI::Color>{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Windowing_IAppWindowTitleBar<D>::BackgroundColor(winrt::Windows::Foundation::IReference<winrt::Windows::UI::Color> const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Windowing::IAppWindowTitleBar>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Windowing::IAppWindowTitleBar, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindowTitleBar>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_BackgroundColor(*(void**)(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindowTitleBar>**)this;
            check_hresult(_winrt_abi_type->put_BackgroundColor(*(void**)(&value)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Windowing_IAppWindowTitleBar<D>::ButtonBackgroundColor() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Windowing::IAppWindowTitleBar>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Windowing::IAppWindowTitleBar, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindowTitleBar>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_ButtonBackgroundColor(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindowTitleBar>**)this;
            check_hresult(_winrt_abi_type->get_ButtonBackgroundColor(&value));
        }
        return winrt::Windows::Foundation::IReference<winrt::Windows::UI::Color>{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Windowing_IAppWindowTitleBar<D>::ButtonBackgroundColor(winrt::Windows::Foundation::IReference<winrt::Windows::UI::Color> const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Windowing::IAppWindowTitleBar>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Windowing::IAppWindowTitleBar, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindowTitleBar>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_ButtonBackgroundColor(*(void**)(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindowTitleBar>**)this;
            check_hresult(_winrt_abi_type->put_ButtonBackgroundColor(*(void**)(&value)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Windowing_IAppWindowTitleBar<D>::ButtonForegroundColor() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Windowing::IAppWindowTitleBar>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Windowing::IAppWindowTitleBar, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindowTitleBar>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_ButtonForegroundColor(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindowTitleBar>**)this;
            check_hresult(_winrt_abi_type->get_ButtonForegroundColor(&value));
        }
        return winrt::Windows::Foundation::IReference<winrt::Windows::UI::Color>{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Windowing_IAppWindowTitleBar<D>::ButtonForegroundColor(winrt::Windows::Foundation::IReference<winrt::Windows::UI::Color> const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Windowing::IAppWindowTitleBar>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Windowing::IAppWindowTitleBar, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindowTitleBar>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_ButtonForegroundColor(*(void**)(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindowTitleBar>**)this;
            check_hresult(_winrt_abi_type->put_ButtonForegroundColor(*(void**)(&value)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Windowing_IAppWindowTitleBar<D>::ButtonHoverBackgroundColor() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Windowing::IAppWindowTitleBar>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Windowing::IAppWindowTitleBar, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindowTitleBar>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_ButtonHoverBackgroundColor(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindowTitleBar>**)this;
            check_hresult(_winrt_abi_type->get_ButtonHoverBackgroundColor(&value));
        }
        return winrt::Windows::Foundation::IReference<winrt::Windows::UI::Color>{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Windowing_IAppWindowTitleBar<D>::ButtonHoverBackgroundColor(winrt::Windows::Foundation::IReference<winrt::Windows::UI::Color> const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Windowing::IAppWindowTitleBar>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Windowing::IAppWindowTitleBar, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindowTitleBar>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_ButtonHoverBackgroundColor(*(void**)(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindowTitleBar>**)this;
            check_hresult(_winrt_abi_type->put_ButtonHoverBackgroundColor(*(void**)(&value)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Windowing_IAppWindowTitleBar<D>::ButtonHoverForegroundColor() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Windowing::IAppWindowTitleBar>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Windowing::IAppWindowTitleBar, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindowTitleBar>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_ButtonHoverForegroundColor(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindowTitleBar>**)this;
            check_hresult(_winrt_abi_type->get_ButtonHoverForegroundColor(&value));
        }
        return winrt::Windows::Foundation::IReference<winrt::Windows::UI::Color>{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Windowing_IAppWindowTitleBar<D>::ButtonHoverForegroundColor(winrt::Windows::Foundation::IReference<winrt::Windows::UI::Color> const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Windowing::IAppWindowTitleBar>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Windowing::IAppWindowTitleBar, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindowTitleBar>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_ButtonHoverForegroundColor(*(void**)(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindowTitleBar>**)this;
            check_hresult(_winrt_abi_type->put_ButtonHoverForegroundColor(*(void**)(&value)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Windowing_IAppWindowTitleBar<D>::ButtonInactiveBackgroundColor() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Windowing::IAppWindowTitleBar>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Windowing::IAppWindowTitleBar, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindowTitleBar>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_ButtonInactiveBackgroundColor(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindowTitleBar>**)this;
            check_hresult(_winrt_abi_type->get_ButtonInactiveBackgroundColor(&value));
        }
        return winrt::Windows::Foundation::IReference<winrt::Windows::UI::Color>{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Windowing_IAppWindowTitleBar<D>::ButtonInactiveBackgroundColor(winrt::Windows::Foundation::IReference<winrt::Windows::UI::Color> const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Windowing::IAppWindowTitleBar>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Windowing::IAppWindowTitleBar, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindowTitleBar>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_ButtonInactiveBackgroundColor(*(void**)(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindowTitleBar>**)this;
            check_hresult(_winrt_abi_type->put_ButtonInactiveBackgroundColor(*(void**)(&value)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Windowing_IAppWindowTitleBar<D>::ButtonInactiveForegroundColor() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Windowing::IAppWindowTitleBar>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Windowing::IAppWindowTitleBar, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindowTitleBar>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_ButtonInactiveForegroundColor(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindowTitleBar>**)this;
            check_hresult(_winrt_abi_type->get_ButtonInactiveForegroundColor(&value));
        }
        return winrt::Windows::Foundation::IReference<winrt::Windows::UI::Color>{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Windowing_IAppWindowTitleBar<D>::ButtonInactiveForegroundColor(winrt::Windows::Foundation::IReference<winrt::Windows::UI::Color> const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Windowing::IAppWindowTitleBar>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Windowing::IAppWindowTitleBar, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindowTitleBar>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_ButtonInactiveForegroundColor(*(void**)(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindowTitleBar>**)this;
            check_hresult(_winrt_abi_type->put_ButtonInactiveForegroundColor(*(void**)(&value)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Windowing_IAppWindowTitleBar<D>::ButtonPressedBackgroundColor() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Windowing::IAppWindowTitleBar>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Windowing::IAppWindowTitleBar, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindowTitleBar>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_ButtonPressedBackgroundColor(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindowTitleBar>**)this;
            check_hresult(_winrt_abi_type->get_ButtonPressedBackgroundColor(&value));
        }
        return winrt::Windows::Foundation::IReference<winrt::Windows::UI::Color>{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Windowing_IAppWindowTitleBar<D>::ButtonPressedBackgroundColor(winrt::Windows::Foundation::IReference<winrt::Windows::UI::Color> const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Windowing::IAppWindowTitleBar>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Windowing::IAppWindowTitleBar, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindowTitleBar>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_ButtonPressedBackgroundColor(*(void**)(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindowTitleBar>**)this;
            check_hresult(_winrt_abi_type->put_ButtonPressedBackgroundColor(*(void**)(&value)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Windowing_IAppWindowTitleBar<D>::ButtonPressedForegroundColor() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Windowing::IAppWindowTitleBar>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Windowing::IAppWindowTitleBar, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindowTitleBar>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_ButtonPressedForegroundColor(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindowTitleBar>**)this;
            check_hresult(_winrt_abi_type->get_ButtonPressedForegroundColor(&value));
        }
        return winrt::Windows::Foundation::IReference<winrt::Windows::UI::Color>{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Windowing_IAppWindowTitleBar<D>::ButtonPressedForegroundColor(winrt::Windows::Foundation::IReference<winrt::Windows::UI::Color> const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Windowing::IAppWindowTitleBar>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Windowing::IAppWindowTitleBar, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindowTitleBar>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_ButtonPressedForegroundColor(*(void**)(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindowTitleBar>**)this;
            check_hresult(_winrt_abi_type->put_ButtonPressedForegroundColor(*(void**)(&value)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Windowing_IAppWindowTitleBar<D>::ExtendsContentIntoTitleBar() const
    {
        bool value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Windowing::IAppWindowTitleBar>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Windowing::IAppWindowTitleBar, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindowTitleBar>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_ExtendsContentIntoTitleBar(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindowTitleBar>**)this;
            check_hresult(_winrt_abi_type->get_ExtendsContentIntoTitleBar(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Windowing_IAppWindowTitleBar<D>::ExtendsContentIntoTitleBar(bool value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Windowing::IAppWindowTitleBar>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Windowing::IAppWindowTitleBar, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindowTitleBar>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_ExtendsContentIntoTitleBar(value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindowTitleBar>**)this;
            check_hresult(_winrt_abi_type->put_ExtendsContentIntoTitleBar(value));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Windowing_IAppWindowTitleBar<D>::ForegroundColor() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Windowing::IAppWindowTitleBar>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Windowing::IAppWindowTitleBar, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindowTitleBar>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_ForegroundColor(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindowTitleBar>**)this;
            check_hresult(_winrt_abi_type->get_ForegroundColor(&value));
        }
        return winrt::Windows::Foundation::IReference<winrt::Windows::UI::Color>{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Windowing_IAppWindowTitleBar<D>::ForegroundColor(winrt::Windows::Foundation::IReference<winrt::Windows::UI::Color> const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Windowing::IAppWindowTitleBar>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Windowing::IAppWindowTitleBar, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindowTitleBar>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_ForegroundColor(*(void**)(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindowTitleBar>**)this;
            check_hresult(_winrt_abi_type->put_ForegroundColor(*(void**)(&value)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Windowing_IAppWindowTitleBar<D>::Height() const
    {
        int32_t value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Windowing::IAppWindowTitleBar>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Windowing::IAppWindowTitleBar, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindowTitleBar>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Height(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindowTitleBar>**)this;
            check_hresult(_winrt_abi_type->get_Height(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Windowing_IAppWindowTitleBar<D>::IconShowOptions() const
    {
        winrt::Microsoft::UI::Windowing::IconShowOptions value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Windowing::IAppWindowTitleBar>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Windowing::IAppWindowTitleBar, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindowTitleBar>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_IconShowOptions(reinterpret_cast<int32_t*>(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindowTitleBar>**)this;
            check_hresult(_winrt_abi_type->get_IconShowOptions(reinterpret_cast<int32_t*>(&value)));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Windowing_IAppWindowTitleBar<D>::IconShowOptions(winrt::Microsoft::UI::Windowing::IconShowOptions const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Windowing::IAppWindowTitleBar>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Windowing::IAppWindowTitleBar, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindowTitleBar>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_IconShowOptions(static_cast<int32_t>(value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindowTitleBar>**)this;
            check_hresult(_winrt_abi_type->put_IconShowOptions(static_cast<int32_t>(value)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Windowing_IAppWindowTitleBar<D>::InactiveBackgroundColor() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Windowing::IAppWindowTitleBar>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Windowing::IAppWindowTitleBar, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindowTitleBar>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_InactiveBackgroundColor(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindowTitleBar>**)this;
            check_hresult(_winrt_abi_type->get_InactiveBackgroundColor(&value));
        }
        return winrt::Windows::Foundation::IReference<winrt::Windows::UI::Color>{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Windowing_IAppWindowTitleBar<D>::InactiveBackgroundColor(winrt::Windows::Foundation::IReference<winrt::Windows::UI::Color> const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Windowing::IAppWindowTitleBar>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Windowing::IAppWindowTitleBar, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindowTitleBar>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_InactiveBackgroundColor(*(void**)(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindowTitleBar>**)this;
            check_hresult(_winrt_abi_type->put_InactiveBackgroundColor(*(void**)(&value)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Windowing_IAppWindowTitleBar<D>::InactiveForegroundColor() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Windowing::IAppWindowTitleBar>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Windowing::IAppWindowTitleBar, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindowTitleBar>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_InactiveForegroundColor(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindowTitleBar>**)this;
            check_hresult(_winrt_abi_type->get_InactiveForegroundColor(&value));
        }
        return winrt::Windows::Foundation::IReference<winrt::Windows::UI::Color>{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Windowing_IAppWindowTitleBar<D>::InactiveForegroundColor(winrt::Windows::Foundation::IReference<winrt::Windows::UI::Color> const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Windowing::IAppWindowTitleBar>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Windowing::IAppWindowTitleBar, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindowTitleBar>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_InactiveForegroundColor(*(void**)(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindowTitleBar>**)this;
            check_hresult(_winrt_abi_type->put_InactiveForegroundColor(*(void**)(&value)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Windowing_IAppWindowTitleBar<D>::LeftInset() const
    {
        int32_t value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Windowing::IAppWindowTitleBar>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Windowing::IAppWindowTitleBar, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindowTitleBar>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_LeftInset(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindowTitleBar>**)this;
            check_hresult(_winrt_abi_type->get_LeftInset(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Windowing_IAppWindowTitleBar<D>::RightInset() const
    {
        int32_t value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Windowing::IAppWindowTitleBar>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Windowing::IAppWindowTitleBar, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindowTitleBar>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_RightInset(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindowTitleBar>**)this;
            check_hresult(_winrt_abi_type->get_RightInset(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Windowing_IAppWindowTitleBar<D>::ResetToDefault() const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Windowing::IAppWindowTitleBar>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Windowing::IAppWindowTitleBar, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindowTitleBar>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->ResetToDefault());
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindowTitleBar>**)this;
            check_hresult(_winrt_abi_type->ResetToDefault());
        }
    }
    template <typename D> auto consume_Microsoft_UI_Windowing_IAppWindowTitleBar<D>::SetDragRectangles(array_view<winrt::Windows::Graphics::RectInt32 const> value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Windowing::IAppWindowTitleBar>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Windowing::IAppWindowTitleBar, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindowTitleBar>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->SetDragRectangles(value.size(), get_abi(value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindowTitleBar>**)this;
            check_hresult(_winrt_abi_type->SetDragRectangles(value.size(), get_abi(value)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Windowing_IAppWindowTitleBar2<D>::PreferredHeightOption() const
    {
        winrt::Microsoft::UI::Windowing::TitleBarHeightOption value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Windowing::IAppWindowTitleBar2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Windowing::IAppWindowTitleBar2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindowTitleBar2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_PreferredHeightOption(reinterpret_cast<int32_t*>(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindowTitleBar2>**)this;
            check_hresult(_winrt_abi_type->get_PreferredHeightOption(reinterpret_cast<int32_t*>(&value)));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Windowing_IAppWindowTitleBar2<D>::PreferredHeightOption(winrt::Microsoft::UI::Windowing::TitleBarHeightOption const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Windowing::IAppWindowTitleBar2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Windowing::IAppWindowTitleBar2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindowTitleBar2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_PreferredHeightOption(static_cast<int32_t>(value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindowTitleBar2>**)this;
            check_hresult(_winrt_abi_type->put_PreferredHeightOption(static_cast<int32_t>(value)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Windowing_IAppWindowTitleBar3<D>::PreferredTheme() const
    {
        winrt::Microsoft::UI::Windowing::TitleBarTheme value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Windowing::IAppWindowTitleBar3>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Windowing::IAppWindowTitleBar3, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindowTitleBar3>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_PreferredTheme(reinterpret_cast<int32_t*>(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindowTitleBar3>**)this;
            check_hresult(_winrt_abi_type->get_PreferredTheme(reinterpret_cast<int32_t*>(&value)));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Windowing_IAppWindowTitleBar3<D>::PreferredTheme(winrt::Microsoft::UI::Windowing::TitleBarTheme const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Windowing::IAppWindowTitleBar3>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Windowing::IAppWindowTitleBar3, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindowTitleBar3>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_PreferredTheme(static_cast<int32_t>(value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindowTitleBar3>**)this;
            check_hresult(_winrt_abi_type->put_PreferredTheme(static_cast<int32_t>(value)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Windowing_IAppWindowTitleBarStatics<D>::IsCustomizationSupported() const
    {
        bool result{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Windowing::IAppWindowTitleBarStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Windowing::IAppWindowTitleBarStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindowTitleBarStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->IsCustomizationSupported(&result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IAppWindowTitleBarStatics>**)this;
            check_hresult(_winrt_abi_type->IsCustomizationSupported(&result));
        }
        return result;
    }
    template <typename D> auto consume_Microsoft_UI_Windowing_ICompactOverlayPresenter<D>::InitialSize() const
    {
        winrt::Microsoft::UI::Windowing::CompactOverlaySize value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Windowing::ICompactOverlayPresenter>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Windowing::ICompactOverlayPresenter, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::ICompactOverlayPresenter>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_InitialSize(reinterpret_cast<int32_t*>(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::ICompactOverlayPresenter>**)this;
            check_hresult(_winrt_abi_type->get_InitialSize(reinterpret_cast<int32_t*>(&value)));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Windowing_ICompactOverlayPresenter<D>::InitialSize(winrt::Microsoft::UI::Windowing::CompactOverlaySize const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Windowing::ICompactOverlayPresenter>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Windowing::ICompactOverlayPresenter, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::ICompactOverlayPresenter>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_InitialSize(static_cast<int32_t>(value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::ICompactOverlayPresenter>**)this;
            check_hresult(_winrt_abi_type->put_InitialSize(static_cast<int32_t>(value)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Windowing_ICompactOverlayPresenterStatics<D>::Create() const
    {
        void* result{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Windowing::ICompactOverlayPresenterStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Windowing::ICompactOverlayPresenterStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::ICompactOverlayPresenterStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->Create(&result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::ICompactOverlayPresenterStatics>**)this;
            check_hresult(_winrt_abi_type->Create(&result));
        }
        return winrt::Microsoft::UI::Windowing::CompactOverlayPresenter{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Windowing_IDisplayArea<D>::DisplayId() const
    {
        winrt::Microsoft::UI::DisplayId value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Windowing::IDisplayArea>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Windowing::IDisplayArea, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IDisplayArea>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_DisplayId(put_abi(value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IDisplayArea>**)this;
            check_hresult(_winrt_abi_type->get_DisplayId(put_abi(value)));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Windowing_IDisplayArea<D>::IsPrimary() const
    {
        bool value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Windowing::IDisplayArea>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Windowing::IDisplayArea, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IDisplayArea>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_IsPrimary(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IDisplayArea>**)this;
            check_hresult(_winrt_abi_type->get_IsPrimary(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Windowing_IDisplayArea<D>::OuterBounds() const
    {
        winrt::Windows::Graphics::RectInt32 value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Windowing::IDisplayArea>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Windowing::IDisplayArea, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IDisplayArea>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_OuterBounds(put_abi(value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IDisplayArea>**)this;
            check_hresult(_winrt_abi_type->get_OuterBounds(put_abi(value)));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Windowing_IDisplayArea<D>::WorkArea() const
    {
        winrt::Windows::Graphics::RectInt32 value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Windowing::IDisplayArea>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Windowing::IDisplayArea, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IDisplayArea>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_WorkArea(put_abi(value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IDisplayArea>**)this;
            check_hresult(_winrt_abi_type->get_WorkArea(put_abi(value)));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Windowing_IDisplayAreaStatics<D>::Primary() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Windowing::IDisplayAreaStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Windowing::IDisplayAreaStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IDisplayAreaStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Primary(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IDisplayAreaStatics>**)this;
            check_hresult(_winrt_abi_type->get_Primary(&value));
        }
        return winrt::Microsoft::UI::Windowing::DisplayArea{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Windowing_IDisplayAreaStatics<D>::CreateWatcher() const
    {
        void* result{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Windowing::IDisplayAreaStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Windowing::IDisplayAreaStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IDisplayAreaStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->CreateWatcher(&result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IDisplayAreaStatics>**)this;
            check_hresult(_winrt_abi_type->CreateWatcher(&result));
        }
        return winrt::Microsoft::UI::Windowing::DisplayAreaWatcher{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Windowing_IDisplayAreaStatics<D>::FindAll() const
    {
        void* result{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Windowing::IDisplayAreaStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Windowing::IDisplayAreaStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IDisplayAreaStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->FindAll(&result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IDisplayAreaStatics>**)this;
            check_hresult(_winrt_abi_type->FindAll(&result));
        }
        return winrt::Windows::Foundation::Collections::IVectorView<winrt::Microsoft::UI::Windowing::DisplayArea>{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Windowing_IDisplayAreaStatics<D>::GetFromWindowId(winrt::Microsoft::UI::WindowId const& windowId, winrt::Microsoft::UI::Windowing::DisplayAreaFallback const& displayAreaFallback) const
    {
        void* result{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Windowing::IDisplayAreaStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Windowing::IDisplayAreaStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IDisplayAreaStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->GetFromWindowId(impl::bind_in(windowId), static_cast<int32_t>(displayAreaFallback), &result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IDisplayAreaStatics>**)this;
            check_hresult(_winrt_abi_type->GetFromWindowId(impl::bind_in(windowId), static_cast<int32_t>(displayAreaFallback), &result));
        }
        return winrt::Microsoft::UI::Windowing::DisplayArea{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Windowing_IDisplayAreaStatics<D>::GetFromPoint(winrt::Windows::Graphics::PointInt32 const& point, winrt::Microsoft::UI::Windowing::DisplayAreaFallback const& displayAreaFallback) const
    {
        void* result{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Windowing::IDisplayAreaStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Windowing::IDisplayAreaStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IDisplayAreaStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->GetFromPoint(impl::bind_in(point), static_cast<int32_t>(displayAreaFallback), &result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IDisplayAreaStatics>**)this;
            check_hresult(_winrt_abi_type->GetFromPoint(impl::bind_in(point), static_cast<int32_t>(displayAreaFallback), &result));
        }
        return winrt::Microsoft::UI::Windowing::DisplayArea{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Windowing_IDisplayAreaStatics<D>::GetFromRect(winrt::Windows::Graphics::RectInt32 const& rect, winrt::Microsoft::UI::Windowing::DisplayAreaFallback const& displayAreaFallback) const
    {
        void* result{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Windowing::IDisplayAreaStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Windowing::IDisplayAreaStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IDisplayAreaStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->GetFromRect(impl::bind_in(rect), static_cast<int32_t>(displayAreaFallback), &result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IDisplayAreaStatics>**)this;
            check_hresult(_winrt_abi_type->GetFromRect(impl::bind_in(rect), static_cast<int32_t>(displayAreaFallback), &result));
        }
        return winrt::Microsoft::UI::Windowing::DisplayArea{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Windowing_IDisplayAreaStatics2<D>::GetFromDisplayId(winrt::Microsoft::UI::DisplayId const& displayId) const
    {
        void* result{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Windowing::IDisplayAreaStatics2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Windowing::IDisplayAreaStatics2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IDisplayAreaStatics2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->GetFromDisplayId(impl::bind_in(displayId), &result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IDisplayAreaStatics2>**)this;
            check_hresult(_winrt_abi_type->GetFromDisplayId(impl::bind_in(displayId), &result));
        }
        return winrt::Microsoft::UI::Windowing::DisplayArea{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Windowing_IDisplayAreaWatcher<D>::Status() const
    {
        winrt::Microsoft::UI::Windowing::DisplayAreaWatcherStatus value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Windowing::IDisplayAreaWatcher>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Windowing::IDisplayAreaWatcher, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IDisplayAreaWatcher>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Status(reinterpret_cast<int32_t*>(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IDisplayAreaWatcher>**)this;
            check_hresult(_winrt_abi_type->get_Status(reinterpret_cast<int32_t*>(&value)));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Windowing_IDisplayAreaWatcher<D>::Start() const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Windowing::IDisplayAreaWatcher>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Windowing::IDisplayAreaWatcher, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IDisplayAreaWatcher>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->Start());
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IDisplayAreaWatcher>**)this;
            check_hresult(_winrt_abi_type->Start());
        }
    }
    template <typename D> auto consume_Microsoft_UI_Windowing_IDisplayAreaWatcher<D>::Stop() const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Windowing::IDisplayAreaWatcher>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Windowing::IDisplayAreaWatcher, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IDisplayAreaWatcher>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->Stop());
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IDisplayAreaWatcher>**)this;
            check_hresult(_winrt_abi_type->Stop());
        }
    }
    template <typename D> auto consume_Microsoft_UI_Windowing_IDisplayAreaWatcher<D>::Added(winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Windowing::DisplayAreaWatcher, winrt::Microsoft::UI::Windowing::DisplayArea> const& handler) const
    {
        winrt::event_token token{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Windowing::IDisplayAreaWatcher>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Windowing::IDisplayAreaWatcher, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IDisplayAreaWatcher>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->add_Added(*(void**)(&handler), put_abi(token)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IDisplayAreaWatcher>**)this;
            check_hresult(_winrt_abi_type->add_Added(*(void**)(&handler), put_abi(token)));
        }
        return token;
    }
    template <typename D> auto consume_Microsoft_UI_Windowing_IDisplayAreaWatcher<D>::Added(auto_revoke_t, winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Windowing::DisplayAreaWatcher, winrt::Microsoft::UI::Windowing::DisplayArea> const& handler) const
    {
        return impl::make_event_revoker<D, Added_revoker>(this, Added(handler));
    }
    template <typename D> auto consume_Microsoft_UI_Windowing_IDisplayAreaWatcher<D>::Added(winrt::event_token const& token) const noexcept
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Windowing::IDisplayAreaWatcher>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Windowing::IDisplayAreaWatcher, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IDisplayAreaWatcher>**)&_winrt_casted_result;
            _winrt_abi_type->remove_Added(impl::bind_in(token));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IDisplayAreaWatcher>**)this;
            _winrt_abi_type->remove_Added(impl::bind_in(token));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Windowing_IDisplayAreaWatcher<D>::EnumerationCompleted(winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Windowing::DisplayAreaWatcher, winrt::Windows::Foundation::IInspectable> const& handler) const
    {
        winrt::event_token token{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Windowing::IDisplayAreaWatcher>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Windowing::IDisplayAreaWatcher, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IDisplayAreaWatcher>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->add_EnumerationCompleted(*(void**)(&handler), put_abi(token)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IDisplayAreaWatcher>**)this;
            check_hresult(_winrt_abi_type->add_EnumerationCompleted(*(void**)(&handler), put_abi(token)));
        }
        return token;
    }
    template <typename D> auto consume_Microsoft_UI_Windowing_IDisplayAreaWatcher<D>::EnumerationCompleted(auto_revoke_t, winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Windowing::DisplayAreaWatcher, winrt::Windows::Foundation::IInspectable> const& handler) const
    {
        return impl::make_event_revoker<D, EnumerationCompleted_revoker>(this, EnumerationCompleted(handler));
    }
    template <typename D> auto consume_Microsoft_UI_Windowing_IDisplayAreaWatcher<D>::EnumerationCompleted(winrt::event_token const& token) const noexcept
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Windowing::IDisplayAreaWatcher>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Windowing::IDisplayAreaWatcher, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IDisplayAreaWatcher>**)&_winrt_casted_result;
            _winrt_abi_type->remove_EnumerationCompleted(impl::bind_in(token));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IDisplayAreaWatcher>**)this;
            _winrt_abi_type->remove_EnumerationCompleted(impl::bind_in(token));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Windowing_IDisplayAreaWatcher<D>::Removed(winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Windowing::DisplayAreaWatcher, winrt::Microsoft::UI::Windowing::DisplayArea> const& handler) const
    {
        winrt::event_token token{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Windowing::IDisplayAreaWatcher>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Windowing::IDisplayAreaWatcher, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IDisplayAreaWatcher>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->add_Removed(*(void**)(&handler), put_abi(token)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IDisplayAreaWatcher>**)this;
            check_hresult(_winrt_abi_type->add_Removed(*(void**)(&handler), put_abi(token)));
        }
        return token;
    }
    template <typename D> auto consume_Microsoft_UI_Windowing_IDisplayAreaWatcher<D>::Removed(auto_revoke_t, winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Windowing::DisplayAreaWatcher, winrt::Microsoft::UI::Windowing::DisplayArea> const& handler) const
    {
        return impl::make_event_revoker<D, Removed_revoker>(this, Removed(handler));
    }
    template <typename D> auto consume_Microsoft_UI_Windowing_IDisplayAreaWatcher<D>::Removed(winrt::event_token const& token) const noexcept
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Windowing::IDisplayAreaWatcher>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Windowing::IDisplayAreaWatcher, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IDisplayAreaWatcher>**)&_winrt_casted_result;
            _winrt_abi_type->remove_Removed(impl::bind_in(token));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IDisplayAreaWatcher>**)this;
            _winrt_abi_type->remove_Removed(impl::bind_in(token));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Windowing_IDisplayAreaWatcher<D>::Stopped(winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Windowing::DisplayAreaWatcher, winrt::Windows::Foundation::IInspectable> const& handler) const
    {
        winrt::event_token token{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Windowing::IDisplayAreaWatcher>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Windowing::IDisplayAreaWatcher, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IDisplayAreaWatcher>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->add_Stopped(*(void**)(&handler), put_abi(token)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IDisplayAreaWatcher>**)this;
            check_hresult(_winrt_abi_type->add_Stopped(*(void**)(&handler), put_abi(token)));
        }
        return token;
    }
    template <typename D> auto consume_Microsoft_UI_Windowing_IDisplayAreaWatcher<D>::Stopped(auto_revoke_t, winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Windowing::DisplayAreaWatcher, winrt::Windows::Foundation::IInspectable> const& handler) const
    {
        return impl::make_event_revoker<D, Stopped_revoker>(this, Stopped(handler));
    }
    template <typename D> auto consume_Microsoft_UI_Windowing_IDisplayAreaWatcher<D>::Stopped(winrt::event_token const& token) const noexcept
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Windowing::IDisplayAreaWatcher>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Windowing::IDisplayAreaWatcher, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IDisplayAreaWatcher>**)&_winrt_casted_result;
            _winrt_abi_type->remove_Stopped(impl::bind_in(token));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IDisplayAreaWatcher>**)this;
            _winrt_abi_type->remove_Stopped(impl::bind_in(token));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Windowing_IDisplayAreaWatcher<D>::Updated(winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Windowing::DisplayAreaWatcher, winrt::Microsoft::UI::Windowing::DisplayArea> const& handler) const
    {
        winrt::event_token token{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Windowing::IDisplayAreaWatcher>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Windowing::IDisplayAreaWatcher, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IDisplayAreaWatcher>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->add_Updated(*(void**)(&handler), put_abi(token)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IDisplayAreaWatcher>**)this;
            check_hresult(_winrt_abi_type->add_Updated(*(void**)(&handler), put_abi(token)));
        }
        return token;
    }
    template <typename D> auto consume_Microsoft_UI_Windowing_IDisplayAreaWatcher<D>::Updated(auto_revoke_t, winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Windowing::DisplayAreaWatcher, winrt::Microsoft::UI::Windowing::DisplayArea> const& handler) const
    {
        return impl::make_event_revoker<D, Updated_revoker>(this, Updated(handler));
    }
    template <typename D> auto consume_Microsoft_UI_Windowing_IDisplayAreaWatcher<D>::Updated(winrt::event_token const& token) const noexcept
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Windowing::IDisplayAreaWatcher>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Windowing::IDisplayAreaWatcher, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IDisplayAreaWatcher>**)&_winrt_casted_result;
            _winrt_abi_type->remove_Updated(impl::bind_in(token));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IDisplayAreaWatcher>**)this;
            _winrt_abi_type->remove_Updated(impl::bind_in(token));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Windowing_IFullScreenPresenterStatics<D>::Create() const
    {
        void* result{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Windowing::IFullScreenPresenterStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Windowing::IFullScreenPresenterStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IFullScreenPresenterStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->Create(&result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IFullScreenPresenterStatics>**)this;
            check_hresult(_winrt_abi_type->Create(&result));
        }
        return winrt::Microsoft::UI::Windowing::FullScreenPresenter{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Windowing_IOverlappedPresenter<D>::HasBorder() const
    {
        bool value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Windowing::IOverlappedPresenter>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Windowing::IOverlappedPresenter, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IOverlappedPresenter>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_HasBorder(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IOverlappedPresenter>**)this;
            check_hresult(_winrt_abi_type->get_HasBorder(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Windowing_IOverlappedPresenter<D>::HasTitleBar() const
    {
        bool value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Windowing::IOverlappedPresenter>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Windowing::IOverlappedPresenter, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IOverlappedPresenter>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_HasTitleBar(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IOverlappedPresenter>**)this;
            check_hresult(_winrt_abi_type->get_HasTitleBar(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Windowing_IOverlappedPresenter<D>::IsAlwaysOnTop() const
    {
        bool value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Windowing::IOverlappedPresenter>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Windowing::IOverlappedPresenter, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IOverlappedPresenter>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_IsAlwaysOnTop(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IOverlappedPresenter>**)this;
            check_hresult(_winrt_abi_type->get_IsAlwaysOnTop(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Windowing_IOverlappedPresenter<D>::IsAlwaysOnTop(bool value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Windowing::IOverlappedPresenter>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Windowing::IOverlappedPresenter, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IOverlappedPresenter>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_IsAlwaysOnTop(value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IOverlappedPresenter>**)this;
            check_hresult(_winrt_abi_type->put_IsAlwaysOnTop(value));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Windowing_IOverlappedPresenter<D>::IsMaximizable() const
    {
        bool value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Windowing::IOverlappedPresenter>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Windowing::IOverlappedPresenter, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IOverlappedPresenter>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_IsMaximizable(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IOverlappedPresenter>**)this;
            check_hresult(_winrt_abi_type->get_IsMaximizable(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Windowing_IOverlappedPresenter<D>::IsMaximizable(bool value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Windowing::IOverlappedPresenter>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Windowing::IOverlappedPresenter, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IOverlappedPresenter>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_IsMaximizable(value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IOverlappedPresenter>**)this;
            check_hresult(_winrt_abi_type->put_IsMaximizable(value));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Windowing_IOverlappedPresenter<D>::IsMinimizable() const
    {
        bool value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Windowing::IOverlappedPresenter>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Windowing::IOverlappedPresenter, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IOverlappedPresenter>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_IsMinimizable(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IOverlappedPresenter>**)this;
            check_hresult(_winrt_abi_type->get_IsMinimizable(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Windowing_IOverlappedPresenter<D>::IsMinimizable(bool value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Windowing::IOverlappedPresenter>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Windowing::IOverlappedPresenter, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IOverlappedPresenter>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_IsMinimizable(value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IOverlappedPresenter>**)this;
            check_hresult(_winrt_abi_type->put_IsMinimizable(value));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Windowing_IOverlappedPresenter<D>::IsModal() const
    {
        bool value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Windowing::IOverlappedPresenter>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Windowing::IOverlappedPresenter, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IOverlappedPresenter>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_IsModal(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IOverlappedPresenter>**)this;
            check_hresult(_winrt_abi_type->get_IsModal(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Windowing_IOverlappedPresenter<D>::IsModal(bool value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Windowing::IOverlappedPresenter>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Windowing::IOverlappedPresenter, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IOverlappedPresenter>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_IsModal(value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IOverlappedPresenter>**)this;
            check_hresult(_winrt_abi_type->put_IsModal(value));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Windowing_IOverlappedPresenter<D>::IsResizable() const
    {
        bool value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Windowing::IOverlappedPresenter>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Windowing::IOverlappedPresenter, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IOverlappedPresenter>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_IsResizable(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IOverlappedPresenter>**)this;
            check_hresult(_winrt_abi_type->get_IsResizable(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Windowing_IOverlappedPresenter<D>::IsResizable(bool value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Windowing::IOverlappedPresenter>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Windowing::IOverlappedPresenter, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IOverlappedPresenter>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_IsResizable(value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IOverlappedPresenter>**)this;
            check_hresult(_winrt_abi_type->put_IsResizable(value));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Windowing_IOverlappedPresenter<D>::State() const
    {
        winrt::Microsoft::UI::Windowing::OverlappedPresenterState value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Windowing::IOverlappedPresenter>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Windowing::IOverlappedPresenter, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IOverlappedPresenter>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_State(reinterpret_cast<int32_t*>(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IOverlappedPresenter>**)this;
            check_hresult(_winrt_abi_type->get_State(reinterpret_cast<int32_t*>(&value)));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Windowing_IOverlappedPresenter<D>::Maximize() const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Windowing::IOverlappedPresenter>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Windowing::IOverlappedPresenter, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IOverlappedPresenter>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->Maximize());
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IOverlappedPresenter>**)this;
            check_hresult(_winrt_abi_type->Maximize());
        }
    }
    template <typename D> auto consume_Microsoft_UI_Windowing_IOverlappedPresenter<D>::Minimize() const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Windowing::IOverlappedPresenter>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Windowing::IOverlappedPresenter, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IOverlappedPresenter>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->Minimize());
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IOverlappedPresenter>**)this;
            check_hresult(_winrt_abi_type->Minimize());
        }
    }
    template <typename D> auto consume_Microsoft_UI_Windowing_IOverlappedPresenter<D>::Restore() const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Windowing::IOverlappedPresenter>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Windowing::IOverlappedPresenter, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IOverlappedPresenter>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->Restore());
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IOverlappedPresenter>**)this;
            check_hresult(_winrt_abi_type->Restore());
        }
    }
    template <typename D> auto consume_Microsoft_UI_Windowing_IOverlappedPresenter<D>::SetBorderAndTitleBar(bool hasBorder, bool hasTitleBar) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Windowing::IOverlappedPresenter>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Windowing::IOverlappedPresenter, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IOverlappedPresenter>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->SetBorderAndTitleBar(hasBorder, hasTitleBar));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IOverlappedPresenter>**)this;
            check_hresult(_winrt_abi_type->SetBorderAndTitleBar(hasBorder, hasTitleBar));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Windowing_IOverlappedPresenter2<D>::Minimize(bool activateWindow) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Windowing::IOverlappedPresenter2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Windowing::IOverlappedPresenter2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IOverlappedPresenter2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->MinimizeWithActivation(activateWindow));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IOverlappedPresenter2>**)this;
            check_hresult(_winrt_abi_type->MinimizeWithActivation(activateWindow));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Windowing_IOverlappedPresenter2<D>::Restore(bool activateWindow) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Windowing::IOverlappedPresenter2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Windowing::IOverlappedPresenter2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IOverlappedPresenter2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->RestoreWithActivation(activateWindow));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IOverlappedPresenter2>**)this;
            check_hresult(_winrt_abi_type->RestoreWithActivation(activateWindow));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Windowing_IOverlappedPresenter3<D>::PreferredMinimumHeight() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Windowing::IOverlappedPresenter3>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Windowing::IOverlappedPresenter3, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IOverlappedPresenter3>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_PreferredMinimumHeight(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IOverlappedPresenter3>**)this;
            check_hresult(_winrt_abi_type->get_PreferredMinimumHeight(&value));
        }
        return winrt::Windows::Foundation::IReference<int32_t>{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Windowing_IOverlappedPresenter3<D>::PreferredMinimumHeight(winrt::Windows::Foundation::IReference<int32_t> const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Windowing::IOverlappedPresenter3>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Windowing::IOverlappedPresenter3, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IOverlappedPresenter3>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_PreferredMinimumHeight(*(void**)(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IOverlappedPresenter3>**)this;
            check_hresult(_winrt_abi_type->put_PreferredMinimumHeight(*(void**)(&value)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Windowing_IOverlappedPresenter3<D>::PreferredMinimumWidth() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Windowing::IOverlappedPresenter3>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Windowing::IOverlappedPresenter3, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IOverlappedPresenter3>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_PreferredMinimumWidth(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IOverlappedPresenter3>**)this;
            check_hresult(_winrt_abi_type->get_PreferredMinimumWidth(&value));
        }
        return winrt::Windows::Foundation::IReference<int32_t>{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Windowing_IOverlappedPresenter3<D>::PreferredMinimumWidth(winrt::Windows::Foundation::IReference<int32_t> const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Windowing::IOverlappedPresenter3>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Windowing::IOverlappedPresenter3, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IOverlappedPresenter3>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_PreferredMinimumWidth(*(void**)(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IOverlappedPresenter3>**)this;
            check_hresult(_winrt_abi_type->put_PreferredMinimumWidth(*(void**)(&value)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Windowing_IOverlappedPresenter3<D>::PreferredMaximumWidth() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Windowing::IOverlappedPresenter3>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Windowing::IOverlappedPresenter3, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IOverlappedPresenter3>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_PreferredMaximumWidth(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IOverlappedPresenter3>**)this;
            check_hresult(_winrt_abi_type->get_PreferredMaximumWidth(&value));
        }
        return winrt::Windows::Foundation::IReference<int32_t>{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Windowing_IOverlappedPresenter3<D>::PreferredMaximumWidth(winrt::Windows::Foundation::IReference<int32_t> const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Windowing::IOverlappedPresenter3>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Windowing::IOverlappedPresenter3, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IOverlappedPresenter3>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_PreferredMaximumWidth(*(void**)(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IOverlappedPresenter3>**)this;
            check_hresult(_winrt_abi_type->put_PreferredMaximumWidth(*(void**)(&value)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Windowing_IOverlappedPresenter3<D>::PreferredMaximumHeight() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Windowing::IOverlappedPresenter3>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Windowing::IOverlappedPresenter3, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IOverlappedPresenter3>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_PreferredMaximumHeight(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IOverlappedPresenter3>**)this;
            check_hresult(_winrt_abi_type->get_PreferredMaximumHeight(&value));
        }
        return winrt::Windows::Foundation::IReference<int32_t>{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Windowing_IOverlappedPresenter3<D>::PreferredMaximumHeight(winrt::Windows::Foundation::IReference<int32_t> const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Windowing::IOverlappedPresenter3>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Windowing::IOverlappedPresenter3, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IOverlappedPresenter3>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_PreferredMaximumHeight(*(void**)(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IOverlappedPresenter3>**)this;
            check_hresult(_winrt_abi_type->put_PreferredMaximumHeight(*(void**)(&value)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Windowing_IOverlappedPresenterStatics<D>::Create() const
    {
        void* result{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Windowing::IOverlappedPresenterStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Windowing::IOverlappedPresenterStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IOverlappedPresenterStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->Create(&result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IOverlappedPresenterStatics>**)this;
            check_hresult(_winrt_abi_type->Create(&result));
        }
        return winrt::Microsoft::UI::Windowing::OverlappedPresenter{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Windowing_IOverlappedPresenterStatics<D>::CreateForContextMenu() const
    {
        void* result{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Windowing::IOverlappedPresenterStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Windowing::IOverlappedPresenterStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IOverlappedPresenterStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->CreateForContextMenu(&result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IOverlappedPresenterStatics>**)this;
            check_hresult(_winrt_abi_type->CreateForContextMenu(&result));
        }
        return winrt::Microsoft::UI::Windowing::OverlappedPresenter{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Windowing_IOverlappedPresenterStatics<D>::CreateForDialog() const
    {
        void* result{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Windowing::IOverlappedPresenterStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Windowing::IOverlappedPresenterStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IOverlappedPresenterStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->CreateForDialog(&result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IOverlappedPresenterStatics>**)this;
            check_hresult(_winrt_abi_type->CreateForDialog(&result));
        }
        return winrt::Microsoft::UI::Windowing::OverlappedPresenter{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Windowing_IOverlappedPresenterStatics<D>::CreateForToolWindow() const
    {
        void* result{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Windowing::IOverlappedPresenterStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Windowing::IOverlappedPresenterStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IOverlappedPresenterStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->CreateForToolWindow(&result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IOverlappedPresenterStatics>**)this;
            check_hresult(_winrt_abi_type->CreateForToolWindow(&result));
        }
        return winrt::Microsoft::UI::Windowing::OverlappedPresenter{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Windowing_IOverlappedPresenterStatics2<D>::RequestedStartupState() const
    {
        winrt::Microsoft::UI::Windowing::OverlappedPresenterState value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Windowing::IOverlappedPresenterStatics2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Windowing::IOverlappedPresenterStatics2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IOverlappedPresenterStatics2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_RequestedStartupState(reinterpret_cast<int32_t*>(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Windowing::IOverlappedPresenterStatics2>**)this;
            check_hresult(_winrt_abi_type->get_RequestedStartupState(reinterpret_cast<int32_t*>(&value)));
        }
        return value;
    }
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Windowing::IAppWindow> : produce_base<D, winrt::Microsoft::UI::Windowing::IAppWindow>
    {
        int32_t __stdcall get_Id(struct struct_Microsoft_UI_WindowId* value) noexcept final try
        {
            zero_abi<winrt::Microsoft::UI::WindowId>(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::UI::WindowId>(this->shim().Id());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_IsShownInSwitchers(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().IsShownInSwitchers());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_IsShownInSwitchers(bool value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().IsShownInSwitchers(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_IsVisible(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().IsVisible());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_OwnerWindowId(struct struct_Microsoft_UI_WindowId* value) noexcept final try
        {
            zero_abi<winrt::Microsoft::UI::WindowId>(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::UI::WindowId>(this->shim().OwnerWindowId());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Position(struct struct_Windows_Graphics_PointInt32* value) noexcept final try
        {
            zero_abi<winrt::Windows::Graphics::PointInt32>(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Graphics::PointInt32>(this->shim().Position());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Presenter(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::UI::Windowing::AppWindowPresenter>(this->shim().Presenter());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Size(struct struct_Windows_Graphics_SizeInt32* value) noexcept final try
        {
            zero_abi<winrt::Windows::Graphics::SizeInt32>(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Graphics::SizeInt32>(this->shim().Size());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Title(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<hstring>(this->shim().Title());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_Title(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Title(*reinterpret_cast<hstring const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_TitleBar(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::UI::Windowing::AppWindowTitleBar>(this->shim().TitleBar());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall Destroy() noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Destroy();
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall Hide() noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Hide();
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall Move(struct struct_Windows_Graphics_PointInt32 position) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Move(*reinterpret_cast<winrt::Windows::Graphics::PointInt32 const*>(&position));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall MoveAndResize(struct struct_Windows_Graphics_RectInt32 rect) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().MoveAndResize(*reinterpret_cast<winrt::Windows::Graphics::RectInt32 const*>(&rect));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall MoveAndResizeRelativeToDisplayArea(struct struct_Windows_Graphics_RectInt32 rect, void* displayarea) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().MoveAndResize(*reinterpret_cast<winrt::Windows::Graphics::RectInt32 const*>(&rect), *reinterpret_cast<winrt::Microsoft::UI::Windowing::DisplayArea const*>(&displayarea));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall Resize(struct struct_Windows_Graphics_SizeInt32 size) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Resize(*reinterpret_cast<winrt::Windows::Graphics::SizeInt32 const*>(&size));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall SetIcon(void* iconPath) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().SetIcon(*reinterpret_cast<hstring const*>(&iconPath));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall SetIconWithIconId(struct struct_Microsoft_UI_IconId iconId) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().SetIcon(*reinterpret_cast<winrt::Microsoft::UI::IconId const*>(&iconId));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall SetPresenter(void* appWindowPresenter) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().SetPresenter(*reinterpret_cast<winrt::Microsoft::UI::Windowing::AppWindowPresenter const*>(&appWindowPresenter));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall SetPresenterByKind(int32_t appWindowPresenterKind) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().SetPresenter(*reinterpret_cast<winrt::Microsoft::UI::Windowing::AppWindowPresenterKind const*>(&appWindowPresenterKind));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall Show() noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Show();
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall ShowWithActivation(bool activateWindow) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Show(activateWindow);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall add_Changed(void* handler, winrt::event_token* token) noexcept final try
        {
            zero_abi<winrt::event_token>(token);
            typename D::abi_guard guard(this->shim());
            *token = detach_from<winrt::event_token>(this->shim().Changed(*reinterpret_cast<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Windowing::AppWindow, winrt::Microsoft::UI::Windowing::AppWindowChangedEventArgs> const*>(&handler)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall remove_Changed(winrt::event_token token) noexcept final
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Changed(*reinterpret_cast<winrt::event_token const*>(&token));
            return 0;
        }
        int32_t __stdcall add_Closing(void* handler, winrt::event_token* token) noexcept final try
        {
            zero_abi<winrt::event_token>(token);
            typename D::abi_guard guard(this->shim());
            *token = detach_from<winrt::event_token>(this->shim().Closing(*reinterpret_cast<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Windowing::AppWindow, winrt::Microsoft::UI::Windowing::AppWindowClosingEventArgs> const*>(&handler)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall remove_Closing(winrt::event_token token) noexcept final
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Closing(*reinterpret_cast<winrt::event_token const*>(&token));
            return 0;
        }
        int32_t __stdcall add_Destroying(void* handler, winrt::event_token* token) noexcept final try
        {
            zero_abi<winrt::event_token>(token);
            typename D::abi_guard guard(this->shim());
            *token = detach_from<winrt::event_token>(this->shim().Destroying(*reinterpret_cast<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Windowing::AppWindow, winrt::Windows::Foundation::IInspectable> const*>(&handler)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall remove_Destroying(winrt::event_token token) noexcept final
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Destroying(*reinterpret_cast<winrt::event_token const*>(&token));
            return 0;
        }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Windowing::IAppWindow2> : produce_base<D, winrt::Microsoft::UI::Windowing::IAppWindow2>
    {
        int32_t __stdcall get_ClientSize(struct struct_Windows_Graphics_SizeInt32* value) noexcept final try
        {
            zero_abi<winrt::Windows::Graphics::SizeInt32>(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Graphics::SizeInt32>(this->shim().ClientSize());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall MoveInZOrderAtBottom() noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().MoveInZOrderAtBottom();
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall MoveInZOrderAtTop() noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().MoveInZOrderAtTop();
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall MoveInZOrderBelow(struct struct_Microsoft_UI_WindowId windowId) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().MoveInZOrderBelow(*reinterpret_cast<winrt::Microsoft::UI::WindowId const*>(&windowId));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall ResizeClient(struct struct_Windows_Graphics_SizeInt32 size) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().ResizeClient(*reinterpret_cast<winrt::Windows::Graphics::SizeInt32 const*>(&size));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall ShowOnceWithRequestedStartupState() noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().ShowOnceWithRequestedStartupState();
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Windowing::IAppWindow3> : produce_base<D, winrt::Microsoft::UI::Windowing::IAppWindow3>
    {
        int32_t __stdcall AssociateWithDispatcherQueue(void* dispatcherQueue) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().AssociateWithDispatcherQueue(*reinterpret_cast<winrt::Microsoft::UI::Dispatching::DispatcherQueue const*>(&dispatcherQueue));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_DispatcherQueue(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::UI::Dispatching::DispatcherQueue>(this->shim().DispatcherQueue());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Windowing::IAppWindow4> : produce_base<D, winrt::Microsoft::UI::Windowing::IAppWindow4>
    {
        int32_t __stdcall SetTaskbarIcon(void* iconPath) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().SetTaskbarIcon(*reinterpret_cast<hstring const*>(&iconPath));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall SetTaskbarIconWithIconId(struct struct_Microsoft_UI_IconId iconId) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().SetTaskbarIcon(*reinterpret_cast<winrt::Microsoft::UI::IconId const*>(&iconId));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall SetTitleBarIcon(void* iconPath) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().SetTitleBarIcon(*reinterpret_cast<hstring const*>(&iconPath));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall SetTitleBarIconWithIconId(struct struct_Microsoft_UI_IconId iconId) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().SetTitleBarIcon(*reinterpret_cast<winrt::Microsoft::UI::IconId const*>(&iconId));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Windowing::IAppWindowChangedEventArgs> : produce_base<D, winrt::Microsoft::UI::Windowing::IAppWindowChangedEventArgs>
    {
        int32_t __stdcall get_DidPositionChange(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().DidPositionChange());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_DidPresenterChange(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().DidPresenterChange());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_DidSizeChange(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().DidSizeChange());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_DidVisibilityChange(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().DidVisibilityChange());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Windowing::IAppWindowChangedEventArgs2> : produce_base<D, winrt::Microsoft::UI::Windowing::IAppWindowChangedEventArgs2>
    {
        int32_t __stdcall get_DidZOrderChange(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().DidZOrderChange());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_IsZOrderAtBottom(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().IsZOrderAtBottom());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_IsZOrderAtTop(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().IsZOrderAtTop());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_ZOrderBelowWindowId(struct struct_Microsoft_UI_WindowId* value) noexcept final try
        {
            zero_abi<winrt::Microsoft::UI::WindowId>(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::UI::WindowId>(this->shim().ZOrderBelowWindowId());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Windowing::IAppWindowClosingEventArgs> : produce_base<D, winrt::Microsoft::UI::Windowing::IAppWindowClosingEventArgs>
    {
        int32_t __stdcall get_Cancel(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().Cancel());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_Cancel(bool value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Cancel(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Windowing::IAppWindowPresenter> : produce_base<D, winrt::Microsoft::UI::Windowing::IAppWindowPresenter>
    {
        int32_t __stdcall get_Kind(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::UI::Windowing::AppWindowPresenterKind>(this->shim().Kind());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Windowing::IAppWindowPresenterFactory> : produce_base<D, winrt::Microsoft::UI::Windowing::IAppWindowPresenterFactory>
    {
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Windowing::IAppWindowStatics> : produce_base<D, winrt::Microsoft::UI::Windowing::IAppWindowStatics>
    {
        int32_t __stdcall Create(void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Microsoft::UI::Windowing::AppWindow>(this->shim().Create());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall CreateWithPresenter(void* appWindowPresenter, void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Microsoft::UI::Windowing::AppWindow>(this->shim().Create(*reinterpret_cast<winrt::Microsoft::UI::Windowing::AppWindowPresenter const*>(&appWindowPresenter)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall CreateWithPresenterAndOwner(void* appWindowPresenter, struct struct_Microsoft_UI_WindowId ownerWindowId, void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Microsoft::UI::Windowing::AppWindow>(this->shim().Create(*reinterpret_cast<winrt::Microsoft::UI::Windowing::AppWindowPresenter const*>(&appWindowPresenter), *reinterpret_cast<winrt::Microsoft::UI::WindowId const*>(&ownerWindowId)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall GetFromWindowId(struct struct_Microsoft_UI_WindowId windowId, void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Microsoft::UI::Windowing::AppWindow>(this->shim().GetFromWindowId(*reinterpret_cast<winrt::Microsoft::UI::WindowId const*>(&windowId)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Windowing::IAppWindowStatics2> : produce_base<D, winrt::Microsoft::UI::Windowing::IAppWindowStatics2>
    {
        int32_t __stdcall CreateWithDispatcherQueue(void* appWindowPresenter, struct struct_Microsoft_UI_WindowId ownerWindowId, void* DispatcherQueue, void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Microsoft::UI::Windowing::AppWindow>(this->shim().Create(*reinterpret_cast<winrt::Microsoft::UI::Windowing::AppWindowPresenter const*>(&appWindowPresenter), *reinterpret_cast<winrt::Microsoft::UI::WindowId const*>(&ownerWindowId), *reinterpret_cast<winrt::Microsoft::UI::Dispatching::DispatcherQueue const*>(&DispatcherQueue)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Windowing::IAppWindowTitleBar> : produce_base<D, winrt::Microsoft::UI::Windowing::IAppWindowTitleBar>
    {
        int32_t __stdcall get_BackgroundColor(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::IReference<winrt::Windows::UI::Color>>(this->shim().BackgroundColor());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_BackgroundColor(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().BackgroundColor(*reinterpret_cast<winrt::Windows::Foundation::IReference<winrt::Windows::UI::Color> const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_ButtonBackgroundColor(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::IReference<winrt::Windows::UI::Color>>(this->shim().ButtonBackgroundColor());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_ButtonBackgroundColor(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().ButtonBackgroundColor(*reinterpret_cast<winrt::Windows::Foundation::IReference<winrt::Windows::UI::Color> const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_ButtonForegroundColor(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::IReference<winrt::Windows::UI::Color>>(this->shim().ButtonForegroundColor());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_ButtonForegroundColor(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().ButtonForegroundColor(*reinterpret_cast<winrt::Windows::Foundation::IReference<winrt::Windows::UI::Color> const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_ButtonHoverBackgroundColor(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::IReference<winrt::Windows::UI::Color>>(this->shim().ButtonHoverBackgroundColor());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_ButtonHoverBackgroundColor(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().ButtonHoverBackgroundColor(*reinterpret_cast<winrt::Windows::Foundation::IReference<winrt::Windows::UI::Color> const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_ButtonHoverForegroundColor(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::IReference<winrt::Windows::UI::Color>>(this->shim().ButtonHoverForegroundColor());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_ButtonHoverForegroundColor(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().ButtonHoverForegroundColor(*reinterpret_cast<winrt::Windows::Foundation::IReference<winrt::Windows::UI::Color> const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_ButtonInactiveBackgroundColor(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::IReference<winrt::Windows::UI::Color>>(this->shim().ButtonInactiveBackgroundColor());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_ButtonInactiveBackgroundColor(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().ButtonInactiveBackgroundColor(*reinterpret_cast<winrt::Windows::Foundation::IReference<winrt::Windows::UI::Color> const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_ButtonInactiveForegroundColor(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::IReference<winrt::Windows::UI::Color>>(this->shim().ButtonInactiveForegroundColor());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_ButtonInactiveForegroundColor(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().ButtonInactiveForegroundColor(*reinterpret_cast<winrt::Windows::Foundation::IReference<winrt::Windows::UI::Color> const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_ButtonPressedBackgroundColor(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::IReference<winrt::Windows::UI::Color>>(this->shim().ButtonPressedBackgroundColor());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_ButtonPressedBackgroundColor(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().ButtonPressedBackgroundColor(*reinterpret_cast<winrt::Windows::Foundation::IReference<winrt::Windows::UI::Color> const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_ButtonPressedForegroundColor(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::IReference<winrt::Windows::UI::Color>>(this->shim().ButtonPressedForegroundColor());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_ButtonPressedForegroundColor(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().ButtonPressedForegroundColor(*reinterpret_cast<winrt::Windows::Foundation::IReference<winrt::Windows::UI::Color> const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_ExtendsContentIntoTitleBar(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().ExtendsContentIntoTitleBar());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_ExtendsContentIntoTitleBar(bool value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().ExtendsContentIntoTitleBar(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_ForegroundColor(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::IReference<winrt::Windows::UI::Color>>(this->shim().ForegroundColor());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_ForegroundColor(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().ForegroundColor(*reinterpret_cast<winrt::Windows::Foundation::IReference<winrt::Windows::UI::Color> const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Height(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<int32_t>(this->shim().Height());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_IconShowOptions(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::UI::Windowing::IconShowOptions>(this->shim().IconShowOptions());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_IconShowOptions(int32_t value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().IconShowOptions(*reinterpret_cast<winrt::Microsoft::UI::Windowing::IconShowOptions const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_InactiveBackgroundColor(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::IReference<winrt::Windows::UI::Color>>(this->shim().InactiveBackgroundColor());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_InactiveBackgroundColor(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().InactiveBackgroundColor(*reinterpret_cast<winrt::Windows::Foundation::IReference<winrt::Windows::UI::Color> const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_InactiveForegroundColor(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::IReference<winrt::Windows::UI::Color>>(this->shim().InactiveForegroundColor());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_InactiveForegroundColor(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().InactiveForegroundColor(*reinterpret_cast<winrt::Windows::Foundation::IReference<winrt::Windows::UI::Color> const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_LeftInset(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<int32_t>(this->shim().LeftInset());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_RightInset(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<int32_t>(this->shim().RightInset());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall ResetToDefault() noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().ResetToDefault();
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall SetDragRectangles(uint32_t __valueSize, struct struct_Windows_Graphics_RectInt32* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().SetDragRectangles(array_view<winrt::Windows::Graphics::RectInt32 const>(reinterpret_cast<winrt::Windows::Graphics::RectInt32 const *>(value), reinterpret_cast<winrt::Windows::Graphics::RectInt32 const *>(value) + __valueSize));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Windowing::IAppWindowTitleBar2> : produce_base<D, winrt::Microsoft::UI::Windowing::IAppWindowTitleBar2>
    {
        int32_t __stdcall get_PreferredHeightOption(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::UI::Windowing::TitleBarHeightOption>(this->shim().PreferredHeightOption());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_PreferredHeightOption(int32_t value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().PreferredHeightOption(*reinterpret_cast<winrt::Microsoft::UI::Windowing::TitleBarHeightOption const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Windowing::IAppWindowTitleBar3> : produce_base<D, winrt::Microsoft::UI::Windowing::IAppWindowTitleBar3>
    {
        int32_t __stdcall get_PreferredTheme(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::UI::Windowing::TitleBarTheme>(this->shim().PreferredTheme());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_PreferredTheme(int32_t value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().PreferredTheme(*reinterpret_cast<winrt::Microsoft::UI::Windowing::TitleBarTheme const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Windowing::IAppWindowTitleBarStatics> : produce_base<D, winrt::Microsoft::UI::Windowing::IAppWindowTitleBarStatics>
    {
        int32_t __stdcall IsCustomizationSupported(bool* result) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *result = detach_from<bool>(this->shim().IsCustomizationSupported());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Windowing::ICompactOverlayPresenter> : produce_base<D, winrt::Microsoft::UI::Windowing::ICompactOverlayPresenter>
    {
        int32_t __stdcall get_InitialSize(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::UI::Windowing::CompactOverlaySize>(this->shim().InitialSize());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_InitialSize(int32_t value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().InitialSize(*reinterpret_cast<winrt::Microsoft::UI::Windowing::CompactOverlaySize const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Windowing::ICompactOverlayPresenterStatics> : produce_base<D, winrt::Microsoft::UI::Windowing::ICompactOverlayPresenterStatics>
    {
        int32_t __stdcall Create(void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Microsoft::UI::Windowing::CompactOverlayPresenter>(this->shim().Create());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Windowing::IDisplayArea> : produce_base<D, winrt::Microsoft::UI::Windowing::IDisplayArea>
    {
        int32_t __stdcall get_DisplayId(struct struct_Microsoft_UI_DisplayId* value) noexcept final try
        {
            zero_abi<winrt::Microsoft::UI::DisplayId>(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::UI::DisplayId>(this->shim().DisplayId());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_IsPrimary(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().IsPrimary());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_OuterBounds(struct struct_Windows_Graphics_RectInt32* value) noexcept final try
        {
            zero_abi<winrt::Windows::Graphics::RectInt32>(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Graphics::RectInt32>(this->shim().OuterBounds());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_WorkArea(struct struct_Windows_Graphics_RectInt32* value) noexcept final try
        {
            zero_abi<winrt::Windows::Graphics::RectInt32>(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Graphics::RectInt32>(this->shim().WorkArea());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Windowing::IDisplayAreaStatics> : produce_base<D, winrt::Microsoft::UI::Windowing::IDisplayAreaStatics>
    {
        int32_t __stdcall get_Primary(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::UI::Windowing::DisplayArea>(this->shim().Primary());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall CreateWatcher(void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Microsoft::UI::Windowing::DisplayAreaWatcher>(this->shim().CreateWatcher());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall FindAll(void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Windows::Foundation::Collections::IVectorView<winrt::Microsoft::UI::Windowing::DisplayArea>>(this->shim().FindAll());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall GetFromWindowId(struct struct_Microsoft_UI_WindowId windowId, int32_t displayAreaFallback, void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Microsoft::UI::Windowing::DisplayArea>(this->shim().GetFromWindowId(*reinterpret_cast<winrt::Microsoft::UI::WindowId const*>(&windowId), *reinterpret_cast<winrt::Microsoft::UI::Windowing::DisplayAreaFallback const*>(&displayAreaFallback)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall GetFromPoint(struct struct_Windows_Graphics_PointInt32 point, int32_t displayAreaFallback, void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Microsoft::UI::Windowing::DisplayArea>(this->shim().GetFromPoint(*reinterpret_cast<winrt::Windows::Graphics::PointInt32 const*>(&point), *reinterpret_cast<winrt::Microsoft::UI::Windowing::DisplayAreaFallback const*>(&displayAreaFallback)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall GetFromRect(struct struct_Windows_Graphics_RectInt32 rect, int32_t displayAreaFallback, void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Microsoft::UI::Windowing::DisplayArea>(this->shim().GetFromRect(*reinterpret_cast<winrt::Windows::Graphics::RectInt32 const*>(&rect), *reinterpret_cast<winrt::Microsoft::UI::Windowing::DisplayAreaFallback const*>(&displayAreaFallback)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Windowing::IDisplayAreaStatics2> : produce_base<D, winrt::Microsoft::UI::Windowing::IDisplayAreaStatics2>
    {
        int32_t __stdcall GetFromDisplayId(struct struct_Microsoft_UI_DisplayId displayId, void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Microsoft::UI::Windowing::DisplayArea>(this->shim().GetFromDisplayId(*reinterpret_cast<winrt::Microsoft::UI::DisplayId const*>(&displayId)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Windowing::IDisplayAreaWatcher> : produce_base<D, winrt::Microsoft::UI::Windowing::IDisplayAreaWatcher>
    {
        int32_t __stdcall get_Status(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::UI::Windowing::DisplayAreaWatcherStatus>(this->shim().Status());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall Start() noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Start();
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall Stop() noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Stop();
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall add_Added(void* handler, winrt::event_token* token) noexcept final try
        {
            zero_abi<winrt::event_token>(token);
            typename D::abi_guard guard(this->shim());
            *token = detach_from<winrt::event_token>(this->shim().Added(*reinterpret_cast<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Windowing::DisplayAreaWatcher, winrt::Microsoft::UI::Windowing::DisplayArea> const*>(&handler)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall remove_Added(winrt::event_token token) noexcept final
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Added(*reinterpret_cast<winrt::event_token const*>(&token));
            return 0;
        }
        int32_t __stdcall add_EnumerationCompleted(void* handler, winrt::event_token* token) noexcept final try
        {
            zero_abi<winrt::event_token>(token);
            typename D::abi_guard guard(this->shim());
            *token = detach_from<winrt::event_token>(this->shim().EnumerationCompleted(*reinterpret_cast<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Windowing::DisplayAreaWatcher, winrt::Windows::Foundation::IInspectable> const*>(&handler)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall remove_EnumerationCompleted(winrt::event_token token) noexcept final
        {
            typename D::abi_guard guard(this->shim());
            this->shim().EnumerationCompleted(*reinterpret_cast<winrt::event_token const*>(&token));
            return 0;
        }
        int32_t __stdcall add_Removed(void* handler, winrt::event_token* token) noexcept final try
        {
            zero_abi<winrt::event_token>(token);
            typename D::abi_guard guard(this->shim());
            *token = detach_from<winrt::event_token>(this->shim().Removed(*reinterpret_cast<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Windowing::DisplayAreaWatcher, winrt::Microsoft::UI::Windowing::DisplayArea> const*>(&handler)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall remove_Removed(winrt::event_token token) noexcept final
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Removed(*reinterpret_cast<winrt::event_token const*>(&token));
            return 0;
        }
        int32_t __stdcall add_Stopped(void* handler, winrt::event_token* token) noexcept final try
        {
            zero_abi<winrt::event_token>(token);
            typename D::abi_guard guard(this->shim());
            *token = detach_from<winrt::event_token>(this->shim().Stopped(*reinterpret_cast<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Windowing::DisplayAreaWatcher, winrt::Windows::Foundation::IInspectable> const*>(&handler)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall remove_Stopped(winrt::event_token token) noexcept final
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Stopped(*reinterpret_cast<winrt::event_token const*>(&token));
            return 0;
        }
        int32_t __stdcall add_Updated(void* handler, winrt::event_token* token) noexcept final try
        {
            zero_abi<winrt::event_token>(token);
            typename D::abi_guard guard(this->shim());
            *token = detach_from<winrt::event_token>(this->shim().Updated(*reinterpret_cast<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Windowing::DisplayAreaWatcher, winrt::Microsoft::UI::Windowing::DisplayArea> const*>(&handler)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall remove_Updated(winrt::event_token token) noexcept final
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Updated(*reinterpret_cast<winrt::event_token const*>(&token));
            return 0;
        }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Windowing::IFullScreenPresenter> : produce_base<D, winrt::Microsoft::UI::Windowing::IFullScreenPresenter>
    {
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Windowing::IFullScreenPresenterStatics> : produce_base<D, winrt::Microsoft::UI::Windowing::IFullScreenPresenterStatics>
    {
        int32_t __stdcall Create(void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Microsoft::UI::Windowing::FullScreenPresenter>(this->shim().Create());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Windowing::IOverlappedPresenter> : produce_base<D, winrt::Microsoft::UI::Windowing::IOverlappedPresenter>
    {
        int32_t __stdcall get_HasBorder(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().HasBorder());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_HasTitleBar(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().HasTitleBar());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_IsAlwaysOnTop(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().IsAlwaysOnTop());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_IsAlwaysOnTop(bool value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().IsAlwaysOnTop(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_IsMaximizable(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().IsMaximizable());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_IsMaximizable(bool value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().IsMaximizable(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_IsMinimizable(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().IsMinimizable());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_IsMinimizable(bool value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().IsMinimizable(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_IsModal(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().IsModal());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_IsModal(bool value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().IsModal(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_IsResizable(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().IsResizable());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_IsResizable(bool value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().IsResizable(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_State(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::UI::Windowing::OverlappedPresenterState>(this->shim().State());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall Maximize() noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Maximize();
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall Minimize() noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Minimize();
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall Restore() noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Restore();
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall SetBorderAndTitleBar(bool hasBorder, bool hasTitleBar) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().SetBorderAndTitleBar(hasBorder, hasTitleBar);
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Windowing::IOverlappedPresenter2> : produce_base<D, winrt::Microsoft::UI::Windowing::IOverlappedPresenter2>
    {
        int32_t __stdcall MinimizeWithActivation(bool activateWindow) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Minimize(activateWindow);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall RestoreWithActivation(bool activateWindow) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Restore(activateWindow);
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Windowing::IOverlappedPresenter3> : produce_base<D, winrt::Microsoft::UI::Windowing::IOverlappedPresenter3>
    {
        int32_t __stdcall get_PreferredMinimumHeight(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::IReference<int32_t>>(this->shim().PreferredMinimumHeight());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_PreferredMinimumHeight(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().PreferredMinimumHeight(*reinterpret_cast<winrt::Windows::Foundation::IReference<int32_t> const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_PreferredMinimumWidth(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::IReference<int32_t>>(this->shim().PreferredMinimumWidth());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_PreferredMinimumWidth(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().PreferredMinimumWidth(*reinterpret_cast<winrt::Windows::Foundation::IReference<int32_t> const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_PreferredMaximumWidth(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::IReference<int32_t>>(this->shim().PreferredMaximumWidth());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_PreferredMaximumWidth(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().PreferredMaximumWidth(*reinterpret_cast<winrt::Windows::Foundation::IReference<int32_t> const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_PreferredMaximumHeight(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::IReference<int32_t>>(this->shim().PreferredMaximumHeight());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_PreferredMaximumHeight(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().PreferredMaximumHeight(*reinterpret_cast<winrt::Windows::Foundation::IReference<int32_t> const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Windowing::IOverlappedPresenterStatics> : produce_base<D, winrt::Microsoft::UI::Windowing::IOverlappedPresenterStatics>
    {
        int32_t __stdcall Create(void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Microsoft::UI::Windowing::OverlappedPresenter>(this->shim().Create());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall CreateForContextMenu(void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Microsoft::UI::Windowing::OverlappedPresenter>(this->shim().CreateForContextMenu());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall CreateForDialog(void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Microsoft::UI::Windowing::OverlappedPresenter>(this->shim().CreateForDialog());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall CreateForToolWindow(void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Microsoft::UI::Windowing::OverlappedPresenter>(this->shim().CreateForToolWindow());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Windowing::IOverlappedPresenterStatics2> : produce_base<D, winrt::Microsoft::UI::Windowing::IOverlappedPresenterStatics2>
    {
        int32_t __stdcall get_RequestedStartupState(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::UI::Windowing::OverlappedPresenterState>(this->shim().RequestedStartupState());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
}
WINRT_EXPORT namespace winrt::Microsoft::UI::Windowing
{
    inline auto AppWindow::Create()
    {
        return impl::call_factory_cast<winrt::Microsoft::UI::Windowing::AppWindow(*)(IAppWindowStatics const&), AppWindow, IAppWindowStatics>([](IAppWindowStatics const& f) { return f.Create(); });
    }
    inline auto AppWindow::Create(winrt::Microsoft::UI::Windowing::AppWindowPresenter const& appWindowPresenter)
    {
        return impl::call_factory<AppWindow, IAppWindowStatics>([&](IAppWindowStatics const& f) { return f.Create(appWindowPresenter); });
    }
    inline auto AppWindow::Create(winrt::Microsoft::UI::Windowing::AppWindowPresenter const& appWindowPresenter, winrt::Microsoft::UI::WindowId const& ownerWindowId)
    {
        return impl::call_factory<AppWindow, IAppWindowStatics>([&](IAppWindowStatics const& f) { return f.Create(appWindowPresenter, ownerWindowId); });
    }
    inline auto AppWindow::GetFromWindowId(winrt::Microsoft::UI::WindowId const& windowId)
    {
        return impl::call_factory<AppWindow, IAppWindowStatics>([&](IAppWindowStatics const& f) { return f.GetFromWindowId(windowId); });
    }
    inline auto AppWindow::Create(winrt::Microsoft::UI::Windowing::AppWindowPresenter const& appWindowPresenter, winrt::Microsoft::UI::WindowId const& ownerWindowId, winrt::Microsoft::UI::Dispatching::DispatcherQueue const& DispatcherQueue)
    {
        return impl::call_factory<AppWindow, IAppWindowStatics2>([&](IAppWindowStatics2 const& f) { return f.Create(appWindowPresenter, ownerWindowId, DispatcherQueue); });
    }
    inline auto AppWindowTitleBar::IsCustomizationSupported()
    {
        return impl::call_factory_cast<bool(*)(IAppWindowTitleBarStatics const&), AppWindowTitleBar, IAppWindowTitleBarStatics>([](IAppWindowTitleBarStatics const& f) { return f.IsCustomizationSupported(); });
    }
    inline auto CompactOverlayPresenter::Create()
    {
        return impl::call_factory_cast<winrt::Microsoft::UI::Windowing::CompactOverlayPresenter(*)(ICompactOverlayPresenterStatics const&), CompactOverlayPresenter, ICompactOverlayPresenterStatics>([](ICompactOverlayPresenterStatics const& f) { return f.Create(); });
    }
    inline auto DisplayArea::Primary()
    {
        return impl::call_factory_cast<winrt::Microsoft::UI::Windowing::DisplayArea(*)(IDisplayAreaStatics const&), DisplayArea, IDisplayAreaStatics>([](IDisplayAreaStatics const& f) { return f.Primary(); });
    }
    inline auto DisplayArea::CreateWatcher()
    {
        return impl::call_factory_cast<winrt::Microsoft::UI::Windowing::DisplayAreaWatcher(*)(IDisplayAreaStatics const&), DisplayArea, IDisplayAreaStatics>([](IDisplayAreaStatics const& f) { return f.CreateWatcher(); });
    }
    inline auto DisplayArea::FindAll()
    {
        return impl::call_factory_cast<winrt::Windows::Foundation::Collections::IVectorView<winrt::Microsoft::UI::Windowing::DisplayArea>(*)(IDisplayAreaStatics const&), DisplayArea, IDisplayAreaStatics>([](IDisplayAreaStatics const& f) { return f.FindAll(); });
    }
    inline auto DisplayArea::GetFromWindowId(winrt::Microsoft::UI::WindowId const& windowId, winrt::Microsoft::UI::Windowing::DisplayAreaFallback const& displayAreaFallback)
    {
        return impl::call_factory<DisplayArea, IDisplayAreaStatics>([&](IDisplayAreaStatics const& f) { return f.GetFromWindowId(windowId, displayAreaFallback); });
    }
    inline auto DisplayArea::GetFromPoint(winrt::Windows::Graphics::PointInt32 const& point, winrt::Microsoft::UI::Windowing::DisplayAreaFallback const& displayAreaFallback)
    {
        return impl::call_factory<DisplayArea, IDisplayAreaStatics>([&](IDisplayAreaStatics const& f) { return f.GetFromPoint(point, displayAreaFallback); });
    }
    inline auto DisplayArea::GetFromRect(winrt::Windows::Graphics::RectInt32 const& rect, winrt::Microsoft::UI::Windowing::DisplayAreaFallback const& displayAreaFallback)
    {
        return impl::call_factory<DisplayArea, IDisplayAreaStatics>([&](IDisplayAreaStatics const& f) { return f.GetFromRect(rect, displayAreaFallback); });
    }
    inline auto DisplayArea::GetFromDisplayId(winrt::Microsoft::UI::DisplayId const& displayId)
    {
        return impl::call_factory<DisplayArea, IDisplayAreaStatics2>([&](IDisplayAreaStatics2 const& f) { return f.GetFromDisplayId(displayId); });
    }
    inline auto FullScreenPresenter::Create()
    {
        return impl::call_factory_cast<winrt::Microsoft::UI::Windowing::FullScreenPresenter(*)(IFullScreenPresenterStatics const&), FullScreenPresenter, IFullScreenPresenterStatics>([](IFullScreenPresenterStatics const& f) { return f.Create(); });
    }
    inline auto OverlappedPresenter::Create()
    {
        return impl::call_factory_cast<winrt::Microsoft::UI::Windowing::OverlappedPresenter(*)(IOverlappedPresenterStatics const&), OverlappedPresenter, IOverlappedPresenterStatics>([](IOverlappedPresenterStatics const& f) { return f.Create(); });
    }
    inline auto OverlappedPresenter::CreateForContextMenu()
    {
        return impl::call_factory_cast<winrt::Microsoft::UI::Windowing::OverlappedPresenter(*)(IOverlappedPresenterStatics const&), OverlappedPresenter, IOverlappedPresenterStatics>([](IOverlappedPresenterStatics const& f) { return f.CreateForContextMenu(); });
    }
    inline auto OverlappedPresenter::CreateForDialog()
    {
        return impl::call_factory_cast<winrt::Microsoft::UI::Windowing::OverlappedPresenter(*)(IOverlappedPresenterStatics const&), OverlappedPresenter, IOverlappedPresenterStatics>([](IOverlappedPresenterStatics const& f) { return f.CreateForDialog(); });
    }
    inline auto OverlappedPresenter::CreateForToolWindow()
    {
        return impl::call_factory_cast<winrt::Microsoft::UI::Windowing::OverlappedPresenter(*)(IOverlappedPresenterStatics const&), OverlappedPresenter, IOverlappedPresenterStatics>([](IOverlappedPresenterStatics const& f) { return f.CreateForToolWindow(); });
    }
    inline auto OverlappedPresenter::RequestedStartupState()
    {
        return impl::call_factory_cast<winrt::Microsoft::UI::Windowing::OverlappedPresenterState(*)(IOverlappedPresenterStatics2 const&), OverlappedPresenter, IOverlappedPresenterStatics2>([](IOverlappedPresenterStatics2 const& f) { return f.RequestedStartupState(); });
    }
}
namespace std
{
#ifndef WINRT_LEAN_AND_MEAN
    template<> struct hash<winrt::Microsoft::UI::Windowing::IAppWindow> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Windowing::IAppWindow2> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Windowing::IAppWindow3> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Windowing::IAppWindow4> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Windowing::IAppWindowChangedEventArgs> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Windowing::IAppWindowChangedEventArgs2> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Windowing::IAppWindowClosingEventArgs> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Windowing::IAppWindowPresenter> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Windowing::IAppWindowPresenterFactory> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Windowing::IAppWindowStatics> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Windowing::IAppWindowStatics2> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Windowing::IAppWindowTitleBar> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Windowing::IAppWindowTitleBar2> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Windowing::IAppWindowTitleBar3> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Windowing::IAppWindowTitleBarStatics> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Windowing::ICompactOverlayPresenter> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Windowing::ICompactOverlayPresenterStatics> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Windowing::IDisplayArea> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Windowing::IDisplayAreaStatics> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Windowing::IDisplayAreaStatics2> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Windowing::IDisplayAreaWatcher> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Windowing::IFullScreenPresenter> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Windowing::IFullScreenPresenterStatics> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Windowing::IOverlappedPresenter> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Windowing::IOverlappedPresenter2> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Windowing::IOverlappedPresenter3> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Windowing::IOverlappedPresenterStatics> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Windowing::IOverlappedPresenterStatics2> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Windowing::AppWindow> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Windowing::AppWindowChangedEventArgs> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Windowing::AppWindowClosingEventArgs> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Windowing::AppWindowPresenter> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Windowing::AppWindowTitleBar> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Windowing::CompactOverlayPresenter> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Windowing::DisplayArea> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Windowing::DisplayAreaWatcher> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Windowing::FullScreenPresenter> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Windowing::OverlappedPresenter> : winrt::impl::hash_base {};
#endif
#ifdef __cpp_lib_format
#endif
}
#endif
