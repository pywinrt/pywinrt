// WARNING: Please don't edit this file. It was generated by C++/WinRT v2.0.250303.1

#pragma once
#ifndef WINRT_Microsoft_Windows_AI_Text_H
#define WINRT_Microsoft_Windows_AI_Text_H
#include "winrt/base.h"
static_assert(winrt::check_version(CPPWINRT_VERSION, "2.0.250303.1"), "Mismatched C++/WinRT headers.");
#define CPPWINRT_VERSION "2.0.250303.1"
#include "winrt/Microsoft.Windows.AI.h"
#include "winrt/impl/Microsoft.Windows.AI.2.h"
#include "winrt/impl/Microsoft.Windows.AI.ContentSafety.2.h"
#include "winrt/impl/Windows.Foundation.2.h"
#include "winrt/impl/Microsoft.Windows.AI.Text.2.h"
namespace winrt::impl
{
    template <typename D> auto consume_Microsoft_Windows_AI_Text_ILanguageModelOptions<D>::Temperature() const
    {
        float value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::AI::Text::ILanguageModelOptions>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::AI::Text::ILanguageModelOptions, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Text::ILanguageModelOptions>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Temperature(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Text::ILanguageModelOptions>**)this;
            check_hresult(_winrt_abi_type->get_Temperature(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_Windows_AI_Text_ILanguageModelOptions<D>::Temperature(float value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::AI::Text::ILanguageModelOptions>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::AI::Text::ILanguageModelOptions, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Text::ILanguageModelOptions>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_Temperature(value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Text::ILanguageModelOptions>**)this;
            check_hresult(_winrt_abi_type->put_Temperature(value));
        }
    }
    template <typename D> auto consume_Microsoft_Windows_AI_Text_ILanguageModelOptions<D>::TopP() const
    {
        float value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::AI::Text::ILanguageModelOptions>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::AI::Text::ILanguageModelOptions, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Text::ILanguageModelOptions>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_TopP(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Text::ILanguageModelOptions>**)this;
            check_hresult(_winrt_abi_type->get_TopP(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_Windows_AI_Text_ILanguageModelOptions<D>::TopP(float value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::AI::Text::ILanguageModelOptions>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::AI::Text::ILanguageModelOptions, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Text::ILanguageModelOptions>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_TopP(value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Text::ILanguageModelOptions>**)this;
            check_hresult(_winrt_abi_type->put_TopP(value));
        }
    }
    template <typename D> auto consume_Microsoft_Windows_AI_Text_ILanguageModelOptions<D>::TopK() const
    {
        uint32_t value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::AI::Text::ILanguageModelOptions>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::AI::Text::ILanguageModelOptions, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Text::ILanguageModelOptions>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_TopK(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Text::ILanguageModelOptions>**)this;
            check_hresult(_winrt_abi_type->get_TopK(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_Windows_AI_Text_ILanguageModelOptions<D>::TopK(uint32_t value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::AI::Text::ILanguageModelOptions>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::AI::Text::ILanguageModelOptions, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Text::ILanguageModelOptions>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_TopK(value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Text::ILanguageModelOptions>**)this;
            check_hresult(_winrt_abi_type->put_TopK(value));
        }
    }
    template <typename D> auto consume_Microsoft_Windows_AI_Text_ILanguageModelOptions<D>::ContentFilterOptions() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::AI::Text::ILanguageModelOptions>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::AI::Text::ILanguageModelOptions, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Text::ILanguageModelOptions>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_ContentFilterOptions(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Text::ILanguageModelOptions>**)this;
            check_hresult(_winrt_abi_type->get_ContentFilterOptions(&value));
        }
        return winrt::Microsoft::Windows::AI::ContentSafety::ContentFilterOptions{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Windows_AI_Text_ILanguageModelOptions<D>::ContentFilterOptions(winrt::Microsoft::Windows::AI::ContentSafety::ContentFilterOptions const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::AI::Text::ILanguageModelOptions>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::AI::Text::ILanguageModelOptions, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Text::ILanguageModelOptions>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_ContentFilterOptions(*(void**)(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Text::ILanguageModelOptions>**)this;
            check_hresult(_winrt_abi_type->put_ContentFilterOptions(*(void**)(&value)));
        }
    }
    template <typename D> auto consume_Microsoft_Windows_AI_Text_ILanguageModelResponseResult<D>::Text() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::AI::Text::ILanguageModelResponseResult>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::AI::Text::ILanguageModelResponseResult, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Text::ILanguageModelResponseResult>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Text(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Text::ILanguageModelResponseResult>**)this;
            check_hresult(_winrt_abi_type->get_Text(&value));
        }
        return hstring{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Windows_AI_Text_ILanguageModelResponseResult<D>::Status() const
    {
        winrt::Microsoft::Windows::AI::Text::LanguageModelResponseStatus value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::AI::Text::ILanguageModelResponseResult>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::AI::Text::ILanguageModelResponseResult, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Text::ILanguageModelResponseResult>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Status(reinterpret_cast<int32_t*>(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Text::ILanguageModelResponseResult>**)this;
            check_hresult(_winrt_abi_type->get_Status(reinterpret_cast<int32_t*>(&value)));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_Windows_AI_Text_ILanguageModelResponseResult<D>::ExtendedError() const
    {
        winrt::hresult value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::AI::Text::ILanguageModelResponseResult>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::AI::Text::ILanguageModelResponseResult, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Text::ILanguageModelResponseResult>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_ExtendedError(put_abi(value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Text::ILanguageModelResponseResult>**)this;
            check_hresult(_winrt_abi_type->get_ExtendedError(put_abi(value)));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_Windows_AI_Text_ILanguageModelStatics<D>::GetReadyState() const
    {
        winrt::Microsoft::Windows::AI::AIFeatureReadyState result{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::AI::Text::ILanguageModelStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::AI::Text::ILanguageModelStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Text::ILanguageModelStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->GetReadyState(reinterpret_cast<int32_t*>(&result)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Text::ILanguageModelStatics>**)this;
            check_hresult(_winrt_abi_type->GetReadyState(reinterpret_cast<int32_t*>(&result)));
        }
        return result;
    }
    template <typename D> auto consume_Microsoft_Windows_AI_Text_ILanguageModelStatics<D>::EnsureReadyAsync() const
    {
        void* operation{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::AI::Text::ILanguageModelStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::AI::Text::ILanguageModelStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Text::ILanguageModelStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->EnsureReadyAsync(&operation));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Text::ILanguageModelStatics>**)this;
            check_hresult(_winrt_abi_type->EnsureReadyAsync(&operation));
        }
        return winrt::Windows::Foundation::IAsyncOperationWithProgress<winrt::Microsoft::Windows::AI::AIFeatureReadyResult, double>{ operation, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Windows_AI_Text_ILanguageModelStatics<D>::CreateAsync() const
    {
        void* operation{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::AI::Text::ILanguageModelStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::AI::Text::ILanguageModelStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Text::ILanguageModelStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->CreateAsync(&operation));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Text::ILanguageModelStatics>**)this;
            check_hresult(_winrt_abi_type->CreateAsync(&operation));
        }
        return winrt::Windows::Foundation::IAsyncOperation<winrt::Microsoft::Windows::AI::Text::LanguageModel>{ operation, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Windows_AI_Text_ITextRewriter<D>::RewriteAsync(param::hstring const& text) const
    {
        void* operation{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::AI::Text::ITextRewriter>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::AI::Text::ITextRewriter, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Text::ITextRewriter>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->RewriteAsync(*(void**)(&text), &operation));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Text::ITextRewriter>**)this;
            check_hresult(_winrt_abi_type->RewriteAsync(*(void**)(&text), &operation));
        }
        return winrt::Windows::Foundation::IAsyncOperationWithProgress<winrt::Microsoft::Windows::AI::Text::LanguageModelResponseResult, hstring>{ operation, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Windows_AI_Text_ITextRewriterFactory<D>::CreateInstance(winrt::Microsoft::Windows::AI::Text::LanguageModel const& languageModel) const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::AI::Text::ITextRewriterFactory>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::AI::Text::ITextRewriterFactory, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Text::ITextRewriterFactory>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->CreateInstance(*(void**)(&languageModel), &value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Text::ITextRewriterFactory>**)this;
            check_hresult(_winrt_abi_type->CreateInstance(*(void**)(&languageModel), &value));
        }
        return winrt::Microsoft::Windows::AI::Text::TextRewriter{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Windows_AI_Text_ITextSummarizer<D>::SummarizeAsync(param::hstring const& text) const
    {
        void* operation{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::AI::Text::ITextSummarizer>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::AI::Text::ITextSummarizer, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Text::ITextSummarizer>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->SummarizeAsync(*(void**)(&text), &operation));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Text::ITextSummarizer>**)this;
            check_hresult(_winrt_abi_type->SummarizeAsync(*(void**)(&text), &operation));
        }
        return winrt::Windows::Foundation::IAsyncOperationWithProgress<winrt::Microsoft::Windows::AI::Text::LanguageModelResponseResult, hstring>{ operation, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Windows_AI_Text_ITextSummarizer<D>::SummarizeParagraphAsync(param::hstring const& text) const
    {
        void* operation{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::AI::Text::ITextSummarizer>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::AI::Text::ITextSummarizer, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Text::ITextSummarizer>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->SummarizeParagraphAsync(*(void**)(&text), &operation));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Text::ITextSummarizer>**)this;
            check_hresult(_winrt_abi_type->SummarizeParagraphAsync(*(void**)(&text), &operation));
        }
        return winrt::Windows::Foundation::IAsyncOperationWithProgress<winrt::Microsoft::Windows::AI::Text::LanguageModelResponseResult, hstring>{ operation, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Windows_AI_Text_ITextSummarizerFactory<D>::CreateInstance(winrt::Microsoft::Windows::AI::Text::LanguageModel const& languageModel) const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::AI::Text::ITextSummarizerFactory>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::AI::Text::ITextSummarizerFactory, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Text::ITextSummarizerFactory>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->CreateInstance(*(void**)(&languageModel), &value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Text::ITextSummarizerFactory>**)this;
            check_hresult(_winrt_abi_type->CreateInstance(*(void**)(&languageModel), &value));
        }
        return winrt::Microsoft::Windows::AI::Text::TextSummarizer{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Windows_AI_Text_ITextToTableConverter<D>::ConvertAsync(param::hstring const& text) const
    {
        void* operation{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::AI::Text::ITextToTableConverter>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::AI::Text::ITextToTableConverter, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Text::ITextToTableConverter>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->ConvertAsync(*(void**)(&text), &operation));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Text::ITextToTableConverter>**)this;
            check_hresult(_winrt_abi_type->ConvertAsync(*(void**)(&text), &operation));
        }
        return winrt::Windows::Foundation::IAsyncOperationWithProgress<winrt::Microsoft::Windows::AI::Text::TextToTableResponseResult, hstring>{ operation, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Windows_AI_Text_ITextToTableConverterFactory<D>::CreateInstance(winrt::Microsoft::Windows::AI::Text::LanguageModel const& languageModel) const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::AI::Text::ITextToTableConverterFactory>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::AI::Text::ITextToTableConverterFactory, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Text::ITextToTableConverterFactory>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->CreateInstance(*(void**)(&languageModel), &value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Text::ITextToTableConverterFactory>**)this;
            check_hresult(_winrt_abi_type->CreateInstance(*(void**)(&languageModel), &value));
        }
        return winrt::Microsoft::Windows::AI::Text::TextToTableConverter{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Windows_AI_Text_ITextToTableResponseResult<D>::GetRows() const
    {
        uint32_t result_impl_size{};
        void** result{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::AI::Text::ITextToTableResponseResult>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::AI::Text::ITextToTableResponseResult, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Text::ITextToTableResponseResult>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->GetRows(&result_impl_size, &result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Text::ITextToTableResponseResult>**)this;
            check_hresult(_winrt_abi_type->GetRows(&result_impl_size, &result));
        }
        return com_array<winrt::Microsoft::Windows::AI::Text::TextToTableRow>{ result, result_impl_size, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Windows_AI_Text_ITextToTableResponseResult<D>::Status() const
    {
        winrt::Microsoft::Windows::AI::Text::LanguageModelResponseStatus value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::AI::Text::ITextToTableResponseResult>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::AI::Text::ITextToTableResponseResult, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Text::ITextToTableResponseResult>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Status(reinterpret_cast<int32_t*>(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Text::ITextToTableResponseResult>**)this;
            check_hresult(_winrt_abi_type->get_Status(reinterpret_cast<int32_t*>(&value)));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_Windows_AI_Text_ITextToTableResponseResult<D>::ExtendedError() const
    {
        winrt::hresult value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::AI::Text::ITextToTableResponseResult>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::AI::Text::ITextToTableResponseResult, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Text::ITextToTableResponseResult>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_ExtendedError(put_abi(value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Text::ITextToTableResponseResult>**)this;
            check_hresult(_winrt_abi_type->get_ExtendedError(put_abi(value)));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_Windows_AI_Text_ITextToTableRow<D>::GetColumns() const
    {
        uint32_t result_impl_size{};
        void** result{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::AI::Text::ITextToTableRow>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::AI::Text::ITextToTableRow, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Text::ITextToTableRow>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->GetColumns(&result_impl_size, &result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::AI::Text::ITextToTableRow>**)this;
            check_hresult(_winrt_abi_type->GetColumns(&result_impl_size, &result));
        }
        return com_array<hstring>{ result, result_impl_size, take_ownership_from_abi };
    }
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::Windows::AI::Text::ILanguageModel> : produce_base<D, winrt::Microsoft::Windows::AI::Text::ILanguageModel>
    {
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::Windows::AI::Text::ILanguageModelContext> : produce_base<D, winrt::Microsoft::Windows::AI::Text::ILanguageModelContext>
    {
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::Windows::AI::Text::ILanguageModelOptions> : produce_base<D, winrt::Microsoft::Windows::AI::Text::ILanguageModelOptions>
    {
        int32_t __stdcall get_Temperature(float* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<float>(this->shim().Temperature());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_Temperature(float value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Temperature(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_TopP(float* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<float>(this->shim().TopP());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_TopP(float value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().TopP(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_TopK(uint32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<uint32_t>(this->shim().TopK());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_TopK(uint32_t value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().TopK(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_ContentFilterOptions(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::Windows::AI::ContentSafety::ContentFilterOptions>(this->shim().ContentFilterOptions());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_ContentFilterOptions(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().ContentFilterOptions(*reinterpret_cast<winrt::Microsoft::Windows::AI::ContentSafety::ContentFilterOptions const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::Windows::AI::Text::ILanguageModelResponseResult> : produce_base<D, winrt::Microsoft::Windows::AI::Text::ILanguageModelResponseResult>
    {
        int32_t __stdcall get_Text(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<hstring>(this->shim().Text());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Status(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::Windows::AI::Text::LanguageModelResponseStatus>(this->shim().Status());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_ExtendedError(winrt::hresult* value) noexcept final try
        {
            zero_abi<winrt::hresult>(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::hresult>(this->shim().ExtendedError());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::Windows::AI::Text::ILanguageModelStatics> : produce_base<D, winrt::Microsoft::Windows::AI::Text::ILanguageModelStatics>
    {
        int32_t __stdcall GetReadyState(int32_t* result) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Microsoft::Windows::AI::AIFeatureReadyState>(this->shim().GetReadyState());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall EnsureReadyAsync(void** operation) noexcept final try
        {
            clear_abi(operation);
            typename D::abi_guard guard(this->shim());
            *operation = detach_from<winrt::Windows::Foundation::IAsyncOperationWithProgress<winrt::Microsoft::Windows::AI::AIFeatureReadyResult, double>>(this->shim().EnsureReadyAsync());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall CreateAsync(void** operation) noexcept final try
        {
            clear_abi(operation);
            typename D::abi_guard guard(this->shim());
            *operation = detach_from<winrt::Windows::Foundation::IAsyncOperation<winrt::Microsoft::Windows::AI::Text::LanguageModel>>(this->shim().CreateAsync());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::Windows::AI::Text::ITextRewriter> : produce_base<D, winrt::Microsoft::Windows::AI::Text::ITextRewriter>
    {
        int32_t __stdcall RewriteAsync(void* text, void** operation) noexcept final try
        {
            clear_abi(operation);
            typename D::abi_guard guard(this->shim());
            *operation = detach_from<winrt::Windows::Foundation::IAsyncOperationWithProgress<winrt::Microsoft::Windows::AI::Text::LanguageModelResponseResult, hstring>>(this->shim().RewriteAsync(*reinterpret_cast<hstring const*>(&text)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::Windows::AI::Text::ITextRewriterFactory> : produce_base<D, winrt::Microsoft::Windows::AI::Text::ITextRewriterFactory>
    {
        int32_t __stdcall CreateInstance(void* languageModel, void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::Windows::AI::Text::TextRewriter>(this->shim().CreateInstance(*reinterpret_cast<winrt::Microsoft::Windows::AI::Text::LanguageModel const*>(&languageModel)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::Windows::AI::Text::ITextSummarizer> : produce_base<D, winrt::Microsoft::Windows::AI::Text::ITextSummarizer>
    {
        int32_t __stdcall SummarizeAsync(void* text, void** operation) noexcept final try
        {
            clear_abi(operation);
            typename D::abi_guard guard(this->shim());
            *operation = detach_from<winrt::Windows::Foundation::IAsyncOperationWithProgress<winrt::Microsoft::Windows::AI::Text::LanguageModelResponseResult, hstring>>(this->shim().SummarizeAsync(*reinterpret_cast<hstring const*>(&text)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall SummarizeParagraphAsync(void* text, void** operation) noexcept final try
        {
            clear_abi(operation);
            typename D::abi_guard guard(this->shim());
            *operation = detach_from<winrt::Windows::Foundation::IAsyncOperationWithProgress<winrt::Microsoft::Windows::AI::Text::LanguageModelResponseResult, hstring>>(this->shim().SummarizeParagraphAsync(*reinterpret_cast<hstring const*>(&text)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::Windows::AI::Text::ITextSummarizerFactory> : produce_base<D, winrt::Microsoft::Windows::AI::Text::ITextSummarizerFactory>
    {
        int32_t __stdcall CreateInstance(void* languageModel, void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::Windows::AI::Text::TextSummarizer>(this->shim().CreateInstance(*reinterpret_cast<winrt::Microsoft::Windows::AI::Text::LanguageModel const*>(&languageModel)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::Windows::AI::Text::ITextToTableConverter> : produce_base<D, winrt::Microsoft::Windows::AI::Text::ITextToTableConverter>
    {
        int32_t __stdcall ConvertAsync(void* text, void** operation) noexcept final try
        {
            clear_abi(operation);
            typename D::abi_guard guard(this->shim());
            *operation = detach_from<winrt::Windows::Foundation::IAsyncOperationWithProgress<winrt::Microsoft::Windows::AI::Text::TextToTableResponseResult, hstring>>(this->shim().ConvertAsync(*reinterpret_cast<hstring const*>(&text)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::Windows::AI::Text::ITextToTableConverterFactory> : produce_base<D, winrt::Microsoft::Windows::AI::Text::ITextToTableConverterFactory>
    {
        int32_t __stdcall CreateInstance(void* languageModel, void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::Windows::AI::Text::TextToTableConverter>(this->shim().CreateInstance(*reinterpret_cast<winrt::Microsoft::Windows::AI::Text::LanguageModel const*>(&languageModel)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::Windows::AI::Text::ITextToTableResponseResult> : produce_base<D, winrt::Microsoft::Windows::AI::Text::ITextToTableResponseResult>
    {
        int32_t __stdcall GetRows(uint32_t* __resultSize, void*** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            std::tie(*__resultSize, *result) = detach_abi(this->shim().GetRows());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Status(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::Windows::AI::Text::LanguageModelResponseStatus>(this->shim().Status());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_ExtendedError(winrt::hresult* value) noexcept final try
        {
            zero_abi<winrt::hresult>(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::hresult>(this->shim().ExtendedError());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::Windows::AI::Text::ITextToTableRow> : produce_base<D, winrt::Microsoft::Windows::AI::Text::ITextToTableRow>
    {
        int32_t __stdcall GetColumns(uint32_t* __resultSize, void*** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            std::tie(*__resultSize, *result) = detach_abi(this->shim().GetColumns());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
}
WINRT_EXPORT namespace winrt::Microsoft::Windows::AI::Text
{
    inline auto LanguageModel::GetReadyState()
    {
        return impl::call_factory_cast<winrt::Microsoft::Windows::AI::AIFeatureReadyState(*)(ILanguageModelStatics const&), LanguageModel, ILanguageModelStatics>([](ILanguageModelStatics const& f) { return f.GetReadyState(); });
    }
    inline auto LanguageModel::EnsureReadyAsync()
    {
        return impl::call_factory_cast<winrt::Windows::Foundation::IAsyncOperationWithProgress<winrt::Microsoft::Windows::AI::AIFeatureReadyResult, double>(*)(ILanguageModelStatics const&), LanguageModel, ILanguageModelStatics>([](ILanguageModelStatics const& f) { return f.EnsureReadyAsync(); });
    }
    inline auto LanguageModel::CreateAsync()
    {
        return impl::call_factory_cast<winrt::Windows::Foundation::IAsyncOperation<winrt::Microsoft::Windows::AI::Text::LanguageModel>(*)(ILanguageModelStatics const&), LanguageModel, ILanguageModelStatics>([](ILanguageModelStatics const& f) { return f.CreateAsync(); });
    }
    inline LanguageModelOptions::LanguageModelOptions() :
        LanguageModelOptions(impl::call_factory_cast<LanguageModelOptions(*)(winrt::Windows::Foundation::IActivationFactory const&), LanguageModelOptions>([](winrt::Windows::Foundation::IActivationFactory const& f) { return f.template ActivateInstance<LanguageModelOptions>(); }))
    {
    }
    inline TextRewriter::TextRewriter(winrt::Microsoft::Windows::AI::Text::LanguageModel const& languageModel) :
        TextRewriter(impl::call_factory<TextRewriter, ITextRewriterFactory>([&](ITextRewriterFactory const& f) { return f.CreateInstance(languageModel); }))
    {
    }
    inline TextSummarizer::TextSummarizer(winrt::Microsoft::Windows::AI::Text::LanguageModel const& languageModel) :
        TextSummarizer(impl::call_factory<TextSummarizer, ITextSummarizerFactory>([&](ITextSummarizerFactory const& f) { return f.CreateInstance(languageModel); }))
    {
    }
    inline TextToTableConverter::TextToTableConverter(winrt::Microsoft::Windows::AI::Text::LanguageModel const& languageModel) :
        TextToTableConverter(impl::call_factory<TextToTableConverter, ITextToTableConverterFactory>([&](ITextToTableConverterFactory const& f) { return f.CreateInstance(languageModel); }))
    {
    }
}
namespace std
{
#ifndef WINRT_LEAN_AND_MEAN
    template<> struct hash<winrt::Microsoft::Windows::AI::Text::ILanguageModel> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Windows::AI::Text::ILanguageModelContext> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Windows::AI::Text::ILanguageModelOptions> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Windows::AI::Text::ILanguageModelResponseResult> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Windows::AI::Text::ILanguageModelStatics> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Windows::AI::Text::ITextRewriter> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Windows::AI::Text::ITextRewriterFactory> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Windows::AI::Text::ITextSummarizer> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Windows::AI::Text::ITextSummarizerFactory> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Windows::AI::Text::ITextToTableConverter> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Windows::AI::Text::ITextToTableConverterFactory> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Windows::AI::Text::ITextToTableResponseResult> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Windows::AI::Text::ITextToTableRow> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Windows::AI::Text::LanguageModel> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Windows::AI::Text::LanguageModelContext> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Windows::AI::Text::LanguageModelOptions> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Windows::AI::Text::LanguageModelResponseResult> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Windows::AI::Text::TextRewriter> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Windows::AI::Text::TextSummarizer> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Windows::AI::Text::TextToTableConverter> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Windows::AI::Text::TextToTableResponseResult> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Windows::AI::Text::TextToTableRow> : winrt::impl::hash_base {};
#endif
#ifdef __cpp_lib_format
#endif
}
#endif
