// WARNING: Please don't edit this file. It was generated by C++/WinRT v2.0.250303.1

#pragma once
#ifndef WINRT_Microsoft_UI_Input_H
#define WINRT_Microsoft_UI_Input_H
#include "winrt/base.h"
static_assert(winrt::check_version(CPPWINRT_VERSION, "2.0.250303.1"), "Mismatched C++/WinRT headers.");
#define CPPWINRT_VERSION "2.0.250303.1"
#include "winrt/Microsoft.UI.h"
#include "winrt/impl/Microsoft.UI.2.h"
#include "winrt/impl/Microsoft.UI.Content.2.h"
#include "winrt/impl/Microsoft.UI.Dispatching.2.h"
#include "winrt/impl/Windows.Foundation.2.h"
#include "winrt/impl/Windows.Foundation.Collections.2.h"
#include "winrt/impl/Windows.Graphics.2.h"
#include "winrt/impl/Windows.System.2.h"
#include "winrt/impl/Windows.UI.Core.2.h"
#include "winrt/impl/Microsoft.UI.Input.2.h"
namespace winrt::impl
{
    template <typename D> auto consume_Microsoft_UI_Input_ICharacterReceivedEventArgs<D>::Handled() const
    {
        bool value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::ICharacterReceivedEventArgs>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::ICharacterReceivedEventArgs, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::ICharacterReceivedEventArgs>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Handled(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::ICharacterReceivedEventArgs>**)this;
            check_hresult(_winrt_abi_type->get_Handled(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Input_ICharacterReceivedEventArgs<D>::Handled(bool value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::ICharacterReceivedEventArgs>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::ICharacterReceivedEventArgs, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::ICharacterReceivedEventArgs>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_Handled(value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::ICharacterReceivedEventArgs>**)this;
            check_hresult(_winrt_abi_type->put_Handled(value));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Input_ICharacterReceivedEventArgs<D>::KeyCode() const
    {
        uint32_t value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::ICharacterReceivedEventArgs>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::ICharacterReceivedEventArgs, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::ICharacterReceivedEventArgs>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_KeyCode(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::ICharacterReceivedEventArgs>**)this;
            check_hresult(_winrt_abi_type->get_KeyCode(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Input_ICharacterReceivedEventArgs<D>::KeyStatus() const
    {
        winrt::Microsoft::UI::Input::PhysicalKeyStatus value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::ICharacterReceivedEventArgs>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::ICharacterReceivedEventArgs, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::ICharacterReceivedEventArgs>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_KeyStatus(put_abi(value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::ICharacterReceivedEventArgs>**)this;
            check_hresult(_winrt_abi_type->get_KeyStatus(put_abi(value)));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Input_IContextMenuKeyEventArgs<D>::Handled() const
    {
        bool value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IContextMenuKeyEventArgs>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IContextMenuKeyEventArgs, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IContextMenuKeyEventArgs>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Handled(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IContextMenuKeyEventArgs>**)this;
            check_hresult(_winrt_abi_type->get_Handled(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Input_IContextMenuKeyEventArgs<D>::Handled(bool value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IContextMenuKeyEventArgs>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IContextMenuKeyEventArgs, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IContextMenuKeyEventArgs>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_Handled(value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IContextMenuKeyEventArgs>**)this;
            check_hresult(_winrt_abi_type->put_Handled(value));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Input_ICrossSlidingEventArgs<D>::CrossSlidingState() const
    {
        winrt::Microsoft::UI::Input::CrossSlidingState value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::ICrossSlidingEventArgs>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::ICrossSlidingEventArgs, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::ICrossSlidingEventArgs>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_CrossSlidingState(reinterpret_cast<int32_t*>(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::ICrossSlidingEventArgs>**)this;
            check_hresult(_winrt_abi_type->get_CrossSlidingState(reinterpret_cast<int32_t*>(&value)));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Input_ICrossSlidingEventArgs<D>::PointerDeviceType() const
    {
        winrt::Microsoft::UI::Input::PointerDeviceType value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::ICrossSlidingEventArgs>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::ICrossSlidingEventArgs, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::ICrossSlidingEventArgs>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_PointerDeviceType(reinterpret_cast<int32_t*>(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::ICrossSlidingEventArgs>**)this;
            check_hresult(_winrt_abi_type->get_PointerDeviceType(reinterpret_cast<int32_t*>(&value)));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Input_ICrossSlidingEventArgs<D>::Position() const
    {
        winrt::Windows::Foundation::Point value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::ICrossSlidingEventArgs>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::ICrossSlidingEventArgs, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::ICrossSlidingEventArgs>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Position(put_abi(value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::ICrossSlidingEventArgs>**)this;
            check_hresult(_winrt_abi_type->get_Position(put_abi(value)));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Input_IDraggingEventArgs<D>::DraggingState() const
    {
        winrt::Microsoft::UI::Input::DraggingState value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IDraggingEventArgs>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IDraggingEventArgs, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IDraggingEventArgs>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_DraggingState(reinterpret_cast<int32_t*>(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IDraggingEventArgs>**)this;
            check_hresult(_winrt_abi_type->get_DraggingState(reinterpret_cast<int32_t*>(&value)));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Input_IDraggingEventArgs<D>::PointerDeviceType() const
    {
        winrt::Microsoft::UI::Input::PointerDeviceType value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IDraggingEventArgs>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IDraggingEventArgs, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IDraggingEventArgs>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_PointerDeviceType(reinterpret_cast<int32_t*>(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IDraggingEventArgs>**)this;
            check_hresult(_winrt_abi_type->get_PointerDeviceType(reinterpret_cast<int32_t*>(&value)));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Input_IDraggingEventArgs<D>::Position() const
    {
        winrt::Windows::Foundation::Point value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IDraggingEventArgs>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IDraggingEventArgs, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IDraggingEventArgs>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Position(put_abi(value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IDraggingEventArgs>**)this;
            check_hresult(_winrt_abi_type->get_Position(put_abi(value)));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Input_IEnteredMoveSizeEventArgs<D>::PointerScreenPoint() const
    {
        winrt::Windows::Graphics::PointInt32 value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IEnteredMoveSizeEventArgs>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IEnteredMoveSizeEventArgs, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IEnteredMoveSizeEventArgs>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_PointerScreenPoint(put_abi(value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IEnteredMoveSizeEventArgs>**)this;
            check_hresult(_winrt_abi_type->get_PointerScreenPoint(put_abi(value)));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Input_IEnteredMoveSizeEventArgs<D>::MoveSizeOperation() const
    {
        winrt::Microsoft::UI::Input::MoveSizeOperation value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IEnteredMoveSizeEventArgs>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IEnteredMoveSizeEventArgs, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IEnteredMoveSizeEventArgs>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_MoveSizeOperation(reinterpret_cast<int32_t*>(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IEnteredMoveSizeEventArgs>**)this;
            check_hresult(_winrt_abi_type->get_MoveSizeOperation(reinterpret_cast<int32_t*>(&value)));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Input_IEnteringMoveSizeEventArgs<D>::PointerScreenPoint() const
    {
        winrt::Windows::Graphics::PointInt32 value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IEnteringMoveSizeEventArgs>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IEnteringMoveSizeEventArgs, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IEnteringMoveSizeEventArgs>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_PointerScreenPoint(put_abi(value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IEnteringMoveSizeEventArgs>**)this;
            check_hresult(_winrt_abi_type->get_PointerScreenPoint(put_abi(value)));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Input_IEnteringMoveSizeEventArgs<D>::MoveSizeOperation() const
    {
        winrt::Microsoft::UI::Input::MoveSizeOperation value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IEnteringMoveSizeEventArgs>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IEnteringMoveSizeEventArgs, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IEnteringMoveSizeEventArgs>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_MoveSizeOperation(reinterpret_cast<int32_t*>(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IEnteringMoveSizeEventArgs>**)this;
            check_hresult(_winrt_abi_type->get_MoveSizeOperation(reinterpret_cast<int32_t*>(&value)));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Input_IEnteringMoveSizeEventArgs<D>::MoveSizeWindowId() const
    {
        winrt::Microsoft::UI::WindowId value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IEnteringMoveSizeEventArgs>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IEnteringMoveSizeEventArgs, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IEnteringMoveSizeEventArgs>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_MoveSizeWindowId(put_abi(value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IEnteringMoveSizeEventArgs>**)this;
            check_hresult(_winrt_abi_type->get_MoveSizeWindowId(put_abi(value)));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Input_IEnteringMoveSizeEventArgs<D>::MoveSizeWindowId(winrt::Microsoft::UI::WindowId const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IEnteringMoveSizeEventArgs>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IEnteringMoveSizeEventArgs, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IEnteringMoveSizeEventArgs>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_MoveSizeWindowId(impl::bind_in(value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IEnteringMoveSizeEventArgs>**)this;
            check_hresult(_winrt_abi_type->put_MoveSizeWindowId(impl::bind_in(value)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Input_IExitedMoveSizeEventArgs<D>::PointerScreenPoint() const
    {
        winrt::Windows::Graphics::PointInt32 value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IExitedMoveSizeEventArgs>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IExitedMoveSizeEventArgs, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IExitedMoveSizeEventArgs>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_PointerScreenPoint(put_abi(value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IExitedMoveSizeEventArgs>**)this;
            check_hresult(_winrt_abi_type->get_PointerScreenPoint(put_abi(value)));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Input_IExitedMoveSizeEventArgs<D>::MoveSizeOperation() const
    {
        winrt::Microsoft::UI::Input::MoveSizeOperation value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IExitedMoveSizeEventArgs>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IExitedMoveSizeEventArgs, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IExitedMoveSizeEventArgs>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_MoveSizeOperation(reinterpret_cast<int32_t*>(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IExitedMoveSizeEventArgs>**)this;
            check_hresult(_winrt_abi_type->get_MoveSizeOperation(reinterpret_cast<int32_t*>(&value)));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Input_IFocusChangedEventArgs<D>::Handled() const
    {
        bool value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IFocusChangedEventArgs>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IFocusChangedEventArgs, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IFocusChangedEventArgs>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Handled(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IFocusChangedEventArgs>**)this;
            check_hresult(_winrt_abi_type->get_Handled(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Input_IFocusChangedEventArgs<D>::Handled(bool value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IFocusChangedEventArgs>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IFocusChangedEventArgs, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IFocusChangedEventArgs>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_Handled(value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IFocusChangedEventArgs>**)this;
            check_hresult(_winrt_abi_type->put_Handled(value));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Input_IFocusNavigationRequest<D>::CorrelationId() const
    {
        winrt::guid value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IFocusNavigationRequest>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IFocusNavigationRequest, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IFocusNavigationRequest>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_CorrelationId(put_abi(value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IFocusNavigationRequest>**)this;
            check_hresult(_winrt_abi_type->get_CorrelationId(put_abi(value)));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Input_IFocusNavigationRequest<D>::HintRect() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IFocusNavigationRequest>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IFocusNavigationRequest, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IFocusNavigationRequest>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_HintRect(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IFocusNavigationRequest>**)this;
            check_hresult(_winrt_abi_type->get_HintRect(&value));
        }
        return winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::Rect>{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Input_IFocusNavigationRequest<D>::Reason() const
    {
        winrt::Microsoft::UI::Input::FocusNavigationReason value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IFocusNavigationRequest>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IFocusNavigationRequest, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IFocusNavigationRequest>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Reason(reinterpret_cast<int32_t*>(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IFocusNavigationRequest>**)this;
            check_hresult(_winrt_abi_type->get_Reason(reinterpret_cast<int32_t*>(&value)));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Input_IFocusNavigationRequestEventArgs<D>::Request() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IFocusNavigationRequestEventArgs>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IFocusNavigationRequestEventArgs, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IFocusNavigationRequestEventArgs>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Request(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IFocusNavigationRequestEventArgs>**)this;
            check_hresult(_winrt_abi_type->get_Request(&value));
        }
        return winrt::Microsoft::UI::Input::FocusNavigationRequest{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Input_IFocusNavigationRequestEventArgs<D>::Result() const
    {
        winrt::Microsoft::UI::Input::FocusNavigationResult value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IFocusNavigationRequestEventArgs>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IFocusNavigationRequestEventArgs, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IFocusNavigationRequestEventArgs>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Result(reinterpret_cast<int32_t*>(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IFocusNavigationRequestEventArgs>**)this;
            check_hresult(_winrt_abi_type->get_Result(reinterpret_cast<int32_t*>(&value)));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Input_IFocusNavigationRequestEventArgs<D>::Result(winrt::Microsoft::UI::Input::FocusNavigationResult const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IFocusNavigationRequestEventArgs>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IFocusNavigationRequestEventArgs, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IFocusNavigationRequestEventArgs>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_Result(static_cast<int32_t>(value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IFocusNavigationRequestEventArgs>**)this;
            check_hresult(_winrt_abi_type->put_Result(static_cast<int32_t>(value)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Input_IFocusNavigationRequestStatics<D>::Create(winrt::Microsoft::UI::Input::FocusNavigationReason const& reason) const
    {
        void* result{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IFocusNavigationRequestStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IFocusNavigationRequestStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IFocusNavigationRequestStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->Create(static_cast<int32_t>(reason), &result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IFocusNavigationRequestStatics>**)this;
            check_hresult(_winrt_abi_type->Create(static_cast<int32_t>(reason), &result));
        }
        return winrt::Microsoft::UI::Input::FocusNavigationRequest{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Input_IFocusNavigationRequestStatics<D>::Create(winrt::Microsoft::UI::Input::FocusNavigationReason const& reason, winrt::Windows::Foundation::Rect const& hintRect) const
    {
        void* result{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IFocusNavigationRequestStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IFocusNavigationRequestStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IFocusNavigationRequestStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->CreateWithHintRect(static_cast<int32_t>(reason), impl::bind_in(hintRect), &result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IFocusNavigationRequestStatics>**)this;
            check_hresult(_winrt_abi_type->CreateWithHintRect(static_cast<int32_t>(reason), impl::bind_in(hintRect), &result));
        }
        return winrt::Microsoft::UI::Input::FocusNavigationRequest{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Input_IFocusNavigationRequestStatics<D>::Create(winrt::Microsoft::UI::Input::FocusNavigationReason const& reason, winrt::Windows::Foundation::Rect const& hintRect, winrt::guid const& correlationId) const
    {
        void* result{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IFocusNavigationRequestStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IFocusNavigationRequestStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IFocusNavigationRequestStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->CreateWithHintRectAndId(static_cast<int32_t>(reason), impl::bind_in(hintRect), impl::bind_in(correlationId), &result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IFocusNavigationRequestStatics>**)this;
            check_hresult(_winrt_abi_type->CreateWithHintRectAndId(static_cast<int32_t>(reason), impl::bind_in(hintRect), impl::bind_in(correlationId), &result));
        }
        return winrt::Microsoft::UI::Input::FocusNavigationRequest{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Input_IGestureRecognizer<D>::AutoProcessInertia() const
    {
        bool value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IGestureRecognizer>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IGestureRecognizer, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IGestureRecognizer>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_AutoProcessInertia(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IGestureRecognizer>**)this;
            check_hresult(_winrt_abi_type->get_AutoProcessInertia(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Input_IGestureRecognizer<D>::AutoProcessInertia(bool value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IGestureRecognizer>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IGestureRecognizer, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IGestureRecognizer>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_AutoProcessInertia(value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IGestureRecognizer>**)this;
            check_hresult(_winrt_abi_type->put_AutoProcessInertia(value));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Input_IGestureRecognizer<D>::CrossSlideExact() const
    {
        bool value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IGestureRecognizer>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IGestureRecognizer, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IGestureRecognizer>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_CrossSlideExact(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IGestureRecognizer>**)this;
            check_hresult(_winrt_abi_type->get_CrossSlideExact(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Input_IGestureRecognizer<D>::CrossSlideExact(bool value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IGestureRecognizer>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IGestureRecognizer, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IGestureRecognizer>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_CrossSlideExact(value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IGestureRecognizer>**)this;
            check_hresult(_winrt_abi_type->put_CrossSlideExact(value));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Input_IGestureRecognizer<D>::CrossSlideHorizontally() const
    {
        bool value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IGestureRecognizer>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IGestureRecognizer, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IGestureRecognizer>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_CrossSlideHorizontally(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IGestureRecognizer>**)this;
            check_hresult(_winrt_abi_type->get_CrossSlideHorizontally(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Input_IGestureRecognizer<D>::CrossSlideHorizontally(bool value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IGestureRecognizer>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IGestureRecognizer, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IGestureRecognizer>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_CrossSlideHorizontally(value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IGestureRecognizer>**)this;
            check_hresult(_winrt_abi_type->put_CrossSlideHorizontally(value));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Input_IGestureRecognizer<D>::CrossSlideThresholds() const
    {
        winrt::Microsoft::UI::Input::CrossSlideThresholds value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IGestureRecognizer>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IGestureRecognizer, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IGestureRecognizer>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_CrossSlideThresholds(put_abi(value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IGestureRecognizer>**)this;
            check_hresult(_winrt_abi_type->get_CrossSlideThresholds(put_abi(value)));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Input_IGestureRecognizer<D>::CrossSlideThresholds(winrt::Microsoft::UI::Input::CrossSlideThresholds const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IGestureRecognizer>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IGestureRecognizer, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IGestureRecognizer>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_CrossSlideThresholds(impl::bind_in(value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IGestureRecognizer>**)this;
            check_hresult(_winrt_abi_type->put_CrossSlideThresholds(impl::bind_in(value)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Input_IGestureRecognizer<D>::GestureSettings() const
    {
        winrt::Microsoft::UI::Input::GestureSettings value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IGestureRecognizer>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IGestureRecognizer, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IGestureRecognizer>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_GestureSettings(reinterpret_cast<uint32_t*>(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IGestureRecognizer>**)this;
            check_hresult(_winrt_abi_type->get_GestureSettings(reinterpret_cast<uint32_t*>(&value)));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Input_IGestureRecognizer<D>::GestureSettings(winrt::Microsoft::UI::Input::GestureSettings const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IGestureRecognizer>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IGestureRecognizer, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IGestureRecognizer>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_GestureSettings(static_cast<uint32_t>(value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IGestureRecognizer>**)this;
            check_hresult(_winrt_abi_type->put_GestureSettings(static_cast<uint32_t>(value)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Input_IGestureRecognizer<D>::IsActive() const
    {
        bool value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IGestureRecognizer>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IGestureRecognizer, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IGestureRecognizer>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_IsActive(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IGestureRecognizer>**)this;
            check_hresult(_winrt_abi_type->get_IsActive(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Input_IGestureRecognizer<D>::IsInertial() const
    {
        bool value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IGestureRecognizer>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IGestureRecognizer, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IGestureRecognizer>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_IsInertial(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IGestureRecognizer>**)this;
            check_hresult(_winrt_abi_type->get_IsInertial(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Input_IGestureRecognizer<D>::PivotCenter() const
    {
        winrt::Windows::Foundation::Point value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IGestureRecognizer>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IGestureRecognizer, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IGestureRecognizer>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_PivotCenter(put_abi(value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IGestureRecognizer>**)this;
            check_hresult(_winrt_abi_type->get_PivotCenter(put_abi(value)));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Input_IGestureRecognizer<D>::PivotCenter(winrt::Windows::Foundation::Point const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IGestureRecognizer>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IGestureRecognizer, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IGestureRecognizer>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_PivotCenter(impl::bind_in(value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IGestureRecognizer>**)this;
            check_hresult(_winrt_abi_type->put_PivotCenter(impl::bind_in(value)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Input_IGestureRecognizer<D>::PivotRadius() const
    {
        float value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IGestureRecognizer>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IGestureRecognizer, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IGestureRecognizer>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_PivotRadius(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IGestureRecognizer>**)this;
            check_hresult(_winrt_abi_type->get_PivotRadius(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Input_IGestureRecognizer<D>::PivotRadius(float value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IGestureRecognizer>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IGestureRecognizer, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IGestureRecognizer>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_PivotRadius(value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IGestureRecognizer>**)this;
            check_hresult(_winrt_abi_type->put_PivotRadius(value));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Input_IGestureRecognizer<D>::InertiaExpansionDeceleration() const
    {
        float value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IGestureRecognizer>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IGestureRecognizer, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IGestureRecognizer>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_InertiaExpansionDeceleration(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IGestureRecognizer>**)this;
            check_hresult(_winrt_abi_type->get_InertiaExpansionDeceleration(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Input_IGestureRecognizer<D>::InertiaExpansionDeceleration(float value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IGestureRecognizer>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IGestureRecognizer, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IGestureRecognizer>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_InertiaExpansionDeceleration(value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IGestureRecognizer>**)this;
            check_hresult(_winrt_abi_type->put_InertiaExpansionDeceleration(value));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Input_IGestureRecognizer<D>::InertiaExpansion() const
    {
        float value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IGestureRecognizer>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IGestureRecognizer, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IGestureRecognizer>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_InertiaExpansion(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IGestureRecognizer>**)this;
            check_hresult(_winrt_abi_type->get_InertiaExpansion(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Input_IGestureRecognizer<D>::InertiaExpansion(float value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IGestureRecognizer>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IGestureRecognizer, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IGestureRecognizer>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_InertiaExpansion(value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IGestureRecognizer>**)this;
            check_hresult(_winrt_abi_type->put_InertiaExpansion(value));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Input_IGestureRecognizer<D>::InertiaRotationAngle() const
    {
        float value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IGestureRecognizer>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IGestureRecognizer, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IGestureRecognizer>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_InertiaRotationAngle(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IGestureRecognizer>**)this;
            check_hresult(_winrt_abi_type->get_InertiaRotationAngle(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Input_IGestureRecognizer<D>::InertiaRotationAngle(float value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IGestureRecognizer>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IGestureRecognizer, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IGestureRecognizer>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_InertiaRotationAngle(value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IGestureRecognizer>**)this;
            check_hresult(_winrt_abi_type->put_InertiaRotationAngle(value));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Input_IGestureRecognizer<D>::InertiaRotationDeceleration() const
    {
        float value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IGestureRecognizer>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IGestureRecognizer, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IGestureRecognizer>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_InertiaRotationDeceleration(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IGestureRecognizer>**)this;
            check_hresult(_winrt_abi_type->get_InertiaRotationDeceleration(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Input_IGestureRecognizer<D>::InertiaRotationDeceleration(float value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IGestureRecognizer>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IGestureRecognizer, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IGestureRecognizer>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_InertiaRotationDeceleration(value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IGestureRecognizer>**)this;
            check_hresult(_winrt_abi_type->put_InertiaRotationDeceleration(value));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Input_IGestureRecognizer<D>::InertiaTranslationDeceleration() const
    {
        float value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IGestureRecognizer>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IGestureRecognizer, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IGestureRecognizer>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_InertiaTranslationDeceleration(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IGestureRecognizer>**)this;
            check_hresult(_winrt_abi_type->get_InertiaTranslationDeceleration(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Input_IGestureRecognizer<D>::InertiaTranslationDeceleration(float value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IGestureRecognizer>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IGestureRecognizer, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IGestureRecognizer>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_InertiaTranslationDeceleration(value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IGestureRecognizer>**)this;
            check_hresult(_winrt_abi_type->put_InertiaTranslationDeceleration(value));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Input_IGestureRecognizer<D>::InertiaTranslationDisplacement() const
    {
        float value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IGestureRecognizer>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IGestureRecognizer, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IGestureRecognizer>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_InertiaTranslationDisplacement(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IGestureRecognizer>**)this;
            check_hresult(_winrt_abi_type->get_InertiaTranslationDisplacement(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Input_IGestureRecognizer<D>::InertiaTranslationDisplacement(float value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IGestureRecognizer>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IGestureRecognizer, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IGestureRecognizer>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_InertiaTranslationDisplacement(value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IGestureRecognizer>**)this;
            check_hresult(_winrt_abi_type->put_InertiaTranslationDisplacement(value));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Input_IGestureRecognizer<D>::ManipulationExact() const
    {
        bool value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IGestureRecognizer>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IGestureRecognizer, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IGestureRecognizer>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_ManipulationExact(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IGestureRecognizer>**)this;
            check_hresult(_winrt_abi_type->get_ManipulationExact(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Input_IGestureRecognizer<D>::ManipulationExact(bool value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IGestureRecognizer>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IGestureRecognizer, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IGestureRecognizer>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_ManipulationExact(value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IGestureRecognizer>**)this;
            check_hresult(_winrt_abi_type->put_ManipulationExact(value));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Input_IGestureRecognizer<D>::MouseWheelParameters() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IGestureRecognizer>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IGestureRecognizer, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IGestureRecognizer>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_MouseWheelParameters(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IGestureRecognizer>**)this;
            check_hresult(_winrt_abi_type->get_MouseWheelParameters(&value));
        }
        return winrt::Microsoft::UI::Input::MouseWheelParameters{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Input_IGestureRecognizer<D>::ShowGestureFeedback() const
    {
        bool value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IGestureRecognizer>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IGestureRecognizer, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IGestureRecognizer>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_ShowGestureFeedback(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IGestureRecognizer>**)this;
            check_hresult(_winrt_abi_type->get_ShowGestureFeedback(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Input_IGestureRecognizer<D>::ShowGestureFeedback(bool value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IGestureRecognizer>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IGestureRecognizer, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IGestureRecognizer>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_ShowGestureFeedback(value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IGestureRecognizer>**)this;
            check_hresult(_winrt_abi_type->put_ShowGestureFeedback(value));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Input_IGestureRecognizer<D>::CanBeDoubleTap(winrt::Microsoft::UI::Input::PointerPoint const& value) const
    {
        bool result{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IGestureRecognizer>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IGestureRecognizer, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IGestureRecognizer>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->CanBeDoubleTap(*(void**)(&value), &result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IGestureRecognizer>**)this;
            check_hresult(_winrt_abi_type->CanBeDoubleTap(*(void**)(&value), &result));
        }
        return result;
    }
    template <typename D> auto consume_Microsoft_UI_Input_IGestureRecognizer<D>::CompleteGesture() const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IGestureRecognizer>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IGestureRecognizer, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IGestureRecognizer>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->CompleteGesture());
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IGestureRecognizer>**)this;
            check_hresult(_winrt_abi_type->CompleteGesture());
        }
    }
    template <typename D> auto consume_Microsoft_UI_Input_IGestureRecognizer<D>::ProcessDownEvent(winrt::Microsoft::UI::Input::PointerPoint const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IGestureRecognizer>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IGestureRecognizer, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IGestureRecognizer>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->ProcessDownEvent(*(void**)(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IGestureRecognizer>**)this;
            check_hresult(_winrt_abi_type->ProcessDownEvent(*(void**)(&value)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Input_IGestureRecognizer<D>::ProcessMoveEvents(param::vector<winrt::Microsoft::UI::Input::PointerPoint> const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IGestureRecognizer>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IGestureRecognizer, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IGestureRecognizer>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->ProcessMoveEvents(*(void**)(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IGestureRecognizer>**)this;
            check_hresult(_winrt_abi_type->ProcessMoveEvents(*(void**)(&value)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Input_IGestureRecognizer<D>::ProcessMouseWheelEvent(winrt::Microsoft::UI::Input::PointerPoint const& value, bool isShiftKeyDown, bool isControlKeyDown) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IGestureRecognizer>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IGestureRecognizer, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IGestureRecognizer>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->ProcessMouseWheelEvent(*(void**)(&value), isShiftKeyDown, isControlKeyDown));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IGestureRecognizer>**)this;
            check_hresult(_winrt_abi_type->ProcessMouseWheelEvent(*(void**)(&value), isShiftKeyDown, isControlKeyDown));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Input_IGestureRecognizer<D>::ProcessInertia() const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IGestureRecognizer>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IGestureRecognizer, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IGestureRecognizer>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->ProcessInertia());
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IGestureRecognizer>**)this;
            check_hresult(_winrt_abi_type->ProcessInertia());
        }
    }
    template <typename D> auto consume_Microsoft_UI_Input_IGestureRecognizer<D>::ProcessUpEvent(winrt::Microsoft::UI::Input::PointerPoint const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IGestureRecognizer>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IGestureRecognizer, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IGestureRecognizer>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->ProcessUpEvent(*(void**)(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IGestureRecognizer>**)this;
            check_hresult(_winrt_abi_type->ProcessUpEvent(*(void**)(&value)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Input_IGestureRecognizer<D>::Tapped(winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Input::GestureRecognizer, winrt::Microsoft::UI::Input::TappedEventArgs> const& handler) const
    {
        winrt::event_token token{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IGestureRecognizer>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IGestureRecognizer, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IGestureRecognizer>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->add_Tapped(*(void**)(&handler), put_abi(token)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IGestureRecognizer>**)this;
            check_hresult(_winrt_abi_type->add_Tapped(*(void**)(&handler), put_abi(token)));
        }
        return token;
    }
    template <typename D> auto consume_Microsoft_UI_Input_IGestureRecognizer<D>::Tapped(auto_revoke_t, winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Input::GestureRecognizer, winrt::Microsoft::UI::Input::TappedEventArgs> const& handler) const
    {
        return impl::make_event_revoker<D, Tapped_revoker>(this, Tapped(handler));
    }
    template <typename D> auto consume_Microsoft_UI_Input_IGestureRecognizer<D>::Tapped(winrt::event_token const& token) const noexcept
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IGestureRecognizer>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IGestureRecognizer, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IGestureRecognizer>**)&_winrt_casted_result;
            _winrt_abi_type->remove_Tapped(impl::bind_in(token));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IGestureRecognizer>**)this;
            _winrt_abi_type->remove_Tapped(impl::bind_in(token));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Input_IGestureRecognizer<D>::RightTapped(winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Input::GestureRecognizer, winrt::Microsoft::UI::Input::RightTappedEventArgs> const& handler) const
    {
        winrt::event_token token{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IGestureRecognizer>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IGestureRecognizer, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IGestureRecognizer>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->add_RightTapped(*(void**)(&handler), put_abi(token)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IGestureRecognizer>**)this;
            check_hresult(_winrt_abi_type->add_RightTapped(*(void**)(&handler), put_abi(token)));
        }
        return token;
    }
    template <typename D> auto consume_Microsoft_UI_Input_IGestureRecognizer<D>::RightTapped(auto_revoke_t, winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Input::GestureRecognizer, winrt::Microsoft::UI::Input::RightTappedEventArgs> const& handler) const
    {
        return impl::make_event_revoker<D, RightTapped_revoker>(this, RightTapped(handler));
    }
    template <typename D> auto consume_Microsoft_UI_Input_IGestureRecognizer<D>::RightTapped(winrt::event_token const& token) const noexcept
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IGestureRecognizer>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IGestureRecognizer, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IGestureRecognizer>**)&_winrt_casted_result;
            _winrt_abi_type->remove_RightTapped(impl::bind_in(token));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IGestureRecognizer>**)this;
            _winrt_abi_type->remove_RightTapped(impl::bind_in(token));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Input_IGestureRecognizer<D>::Holding(winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Input::GestureRecognizer, winrt::Microsoft::UI::Input::HoldingEventArgs> const& handler) const
    {
        winrt::event_token token{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IGestureRecognizer>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IGestureRecognizer, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IGestureRecognizer>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->add_Holding(*(void**)(&handler), put_abi(token)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IGestureRecognizer>**)this;
            check_hresult(_winrt_abi_type->add_Holding(*(void**)(&handler), put_abi(token)));
        }
        return token;
    }
    template <typename D> auto consume_Microsoft_UI_Input_IGestureRecognizer<D>::Holding(auto_revoke_t, winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Input::GestureRecognizer, winrt::Microsoft::UI::Input::HoldingEventArgs> const& handler) const
    {
        return impl::make_event_revoker<D, Holding_revoker>(this, Holding(handler));
    }
    template <typename D> auto consume_Microsoft_UI_Input_IGestureRecognizer<D>::Holding(winrt::event_token const& token) const noexcept
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IGestureRecognizer>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IGestureRecognizer, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IGestureRecognizer>**)&_winrt_casted_result;
            _winrt_abi_type->remove_Holding(impl::bind_in(token));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IGestureRecognizer>**)this;
            _winrt_abi_type->remove_Holding(impl::bind_in(token));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Input_IGestureRecognizer<D>::Dragging(winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Input::GestureRecognizer, winrt::Microsoft::UI::Input::DraggingEventArgs> const& handler) const
    {
        winrt::event_token token{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IGestureRecognizer>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IGestureRecognizer, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IGestureRecognizer>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->add_Dragging(*(void**)(&handler), put_abi(token)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IGestureRecognizer>**)this;
            check_hresult(_winrt_abi_type->add_Dragging(*(void**)(&handler), put_abi(token)));
        }
        return token;
    }
    template <typename D> auto consume_Microsoft_UI_Input_IGestureRecognizer<D>::Dragging(auto_revoke_t, winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Input::GestureRecognizer, winrt::Microsoft::UI::Input::DraggingEventArgs> const& handler) const
    {
        return impl::make_event_revoker<D, Dragging_revoker>(this, Dragging(handler));
    }
    template <typename D> auto consume_Microsoft_UI_Input_IGestureRecognizer<D>::Dragging(winrt::event_token const& token) const noexcept
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IGestureRecognizer>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IGestureRecognizer, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IGestureRecognizer>**)&_winrt_casted_result;
            _winrt_abi_type->remove_Dragging(impl::bind_in(token));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IGestureRecognizer>**)this;
            _winrt_abi_type->remove_Dragging(impl::bind_in(token));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Input_IGestureRecognizer<D>::ManipulationStarted(winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Input::GestureRecognizer, winrt::Microsoft::UI::Input::ManipulationStartedEventArgs> const& handler) const
    {
        winrt::event_token token{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IGestureRecognizer>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IGestureRecognizer, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IGestureRecognizer>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->add_ManipulationStarted(*(void**)(&handler), put_abi(token)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IGestureRecognizer>**)this;
            check_hresult(_winrt_abi_type->add_ManipulationStarted(*(void**)(&handler), put_abi(token)));
        }
        return token;
    }
    template <typename D> auto consume_Microsoft_UI_Input_IGestureRecognizer<D>::ManipulationStarted(auto_revoke_t, winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Input::GestureRecognizer, winrt::Microsoft::UI::Input::ManipulationStartedEventArgs> const& handler) const
    {
        return impl::make_event_revoker<D, ManipulationStarted_revoker>(this, ManipulationStarted(handler));
    }
    template <typename D> auto consume_Microsoft_UI_Input_IGestureRecognizer<D>::ManipulationStarted(winrt::event_token const& token) const noexcept
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IGestureRecognizer>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IGestureRecognizer, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IGestureRecognizer>**)&_winrt_casted_result;
            _winrt_abi_type->remove_ManipulationStarted(impl::bind_in(token));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IGestureRecognizer>**)this;
            _winrt_abi_type->remove_ManipulationStarted(impl::bind_in(token));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Input_IGestureRecognizer<D>::ManipulationUpdated(winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Input::GestureRecognizer, winrt::Microsoft::UI::Input::ManipulationUpdatedEventArgs> const& handler) const
    {
        winrt::event_token token{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IGestureRecognizer>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IGestureRecognizer, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IGestureRecognizer>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->add_ManipulationUpdated(*(void**)(&handler), put_abi(token)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IGestureRecognizer>**)this;
            check_hresult(_winrt_abi_type->add_ManipulationUpdated(*(void**)(&handler), put_abi(token)));
        }
        return token;
    }
    template <typename D> auto consume_Microsoft_UI_Input_IGestureRecognizer<D>::ManipulationUpdated(auto_revoke_t, winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Input::GestureRecognizer, winrt::Microsoft::UI::Input::ManipulationUpdatedEventArgs> const& handler) const
    {
        return impl::make_event_revoker<D, ManipulationUpdated_revoker>(this, ManipulationUpdated(handler));
    }
    template <typename D> auto consume_Microsoft_UI_Input_IGestureRecognizer<D>::ManipulationUpdated(winrt::event_token const& token) const noexcept
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IGestureRecognizer>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IGestureRecognizer, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IGestureRecognizer>**)&_winrt_casted_result;
            _winrt_abi_type->remove_ManipulationUpdated(impl::bind_in(token));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IGestureRecognizer>**)this;
            _winrt_abi_type->remove_ManipulationUpdated(impl::bind_in(token));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Input_IGestureRecognizer<D>::ManipulationInertiaStarting(winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Input::GestureRecognizer, winrt::Microsoft::UI::Input::ManipulationInertiaStartingEventArgs> const& handler) const
    {
        winrt::event_token token{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IGestureRecognizer>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IGestureRecognizer, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IGestureRecognizer>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->add_ManipulationInertiaStarting(*(void**)(&handler), put_abi(token)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IGestureRecognizer>**)this;
            check_hresult(_winrt_abi_type->add_ManipulationInertiaStarting(*(void**)(&handler), put_abi(token)));
        }
        return token;
    }
    template <typename D> auto consume_Microsoft_UI_Input_IGestureRecognizer<D>::ManipulationInertiaStarting(auto_revoke_t, winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Input::GestureRecognizer, winrt::Microsoft::UI::Input::ManipulationInertiaStartingEventArgs> const& handler) const
    {
        return impl::make_event_revoker<D, ManipulationInertiaStarting_revoker>(this, ManipulationInertiaStarting(handler));
    }
    template <typename D> auto consume_Microsoft_UI_Input_IGestureRecognizer<D>::ManipulationInertiaStarting(winrt::event_token const& token) const noexcept
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IGestureRecognizer>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IGestureRecognizer, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IGestureRecognizer>**)&_winrt_casted_result;
            _winrt_abi_type->remove_ManipulationInertiaStarting(impl::bind_in(token));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IGestureRecognizer>**)this;
            _winrt_abi_type->remove_ManipulationInertiaStarting(impl::bind_in(token));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Input_IGestureRecognizer<D>::ManipulationCompleted(winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Input::GestureRecognizer, winrt::Microsoft::UI::Input::ManipulationCompletedEventArgs> const& handler) const
    {
        winrt::event_token token{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IGestureRecognizer>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IGestureRecognizer, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IGestureRecognizer>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->add_ManipulationCompleted(*(void**)(&handler), put_abi(token)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IGestureRecognizer>**)this;
            check_hresult(_winrt_abi_type->add_ManipulationCompleted(*(void**)(&handler), put_abi(token)));
        }
        return token;
    }
    template <typename D> auto consume_Microsoft_UI_Input_IGestureRecognizer<D>::ManipulationCompleted(auto_revoke_t, winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Input::GestureRecognizer, winrt::Microsoft::UI::Input::ManipulationCompletedEventArgs> const& handler) const
    {
        return impl::make_event_revoker<D, ManipulationCompleted_revoker>(this, ManipulationCompleted(handler));
    }
    template <typename D> auto consume_Microsoft_UI_Input_IGestureRecognizer<D>::ManipulationCompleted(winrt::event_token const& token) const noexcept
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IGestureRecognizer>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IGestureRecognizer, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IGestureRecognizer>**)&_winrt_casted_result;
            _winrt_abi_type->remove_ManipulationCompleted(impl::bind_in(token));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IGestureRecognizer>**)this;
            _winrt_abi_type->remove_ManipulationCompleted(impl::bind_in(token));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Input_IGestureRecognizer<D>::CrossSliding(winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Input::GestureRecognizer, winrt::Microsoft::UI::Input::CrossSlidingEventArgs> const& handler) const
    {
        winrt::event_token token{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IGestureRecognizer>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IGestureRecognizer, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IGestureRecognizer>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->add_CrossSliding(*(void**)(&handler), put_abi(token)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IGestureRecognizer>**)this;
            check_hresult(_winrt_abi_type->add_CrossSliding(*(void**)(&handler), put_abi(token)));
        }
        return token;
    }
    template <typename D> auto consume_Microsoft_UI_Input_IGestureRecognizer<D>::CrossSliding(auto_revoke_t, winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Input::GestureRecognizer, winrt::Microsoft::UI::Input::CrossSlidingEventArgs> const& handler) const
    {
        return impl::make_event_revoker<D, CrossSliding_revoker>(this, CrossSliding(handler));
    }
    template <typename D> auto consume_Microsoft_UI_Input_IGestureRecognizer<D>::CrossSliding(winrt::event_token const& token) const noexcept
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IGestureRecognizer>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IGestureRecognizer, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IGestureRecognizer>**)&_winrt_casted_result;
            _winrt_abi_type->remove_CrossSliding(impl::bind_in(token));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IGestureRecognizer>**)this;
            _winrt_abi_type->remove_CrossSliding(impl::bind_in(token));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Input_IHoldingEventArgs<D>::HoldingState() const
    {
        winrt::Microsoft::UI::Input::HoldingState value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IHoldingEventArgs>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IHoldingEventArgs, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IHoldingEventArgs>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_HoldingState(reinterpret_cast<int32_t*>(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IHoldingEventArgs>**)this;
            check_hresult(_winrt_abi_type->get_HoldingState(reinterpret_cast<int32_t*>(&value)));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Input_IHoldingEventArgs<D>::PointerDeviceType() const
    {
        winrt::Microsoft::UI::Input::PointerDeviceType value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IHoldingEventArgs>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IHoldingEventArgs, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IHoldingEventArgs>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_PointerDeviceType(reinterpret_cast<int32_t*>(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IHoldingEventArgs>**)this;
            check_hresult(_winrt_abi_type->get_PointerDeviceType(reinterpret_cast<int32_t*>(&value)));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Input_IHoldingEventArgs<D>::Position() const
    {
        winrt::Windows::Foundation::Point value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IHoldingEventArgs>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IHoldingEventArgs, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IHoldingEventArgs>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Position(put_abi(value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IHoldingEventArgs>**)this;
            check_hresult(_winrt_abi_type->get_Position(put_abi(value)));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Input_IInputActivationListener<D>::State() const
    {
        winrt::Microsoft::UI::Input::InputActivationState value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IInputActivationListener>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IInputActivationListener, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IInputActivationListener>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_State(reinterpret_cast<int32_t*>(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IInputActivationListener>**)this;
            check_hresult(_winrt_abi_type->get_State(reinterpret_cast<int32_t*>(&value)));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Input_IInputActivationListener<D>::InputActivationChanged(winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Input::InputActivationListener, winrt::Microsoft::UI::Input::InputActivationListenerActivationChangedEventArgs> const& handler) const
    {
        winrt::event_token token{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IInputActivationListener>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IInputActivationListener, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IInputActivationListener>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->add_InputActivationChanged(*(void**)(&handler), put_abi(token)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IInputActivationListener>**)this;
            check_hresult(_winrt_abi_type->add_InputActivationChanged(*(void**)(&handler), put_abi(token)));
        }
        return token;
    }
    template <typename D> auto consume_Microsoft_UI_Input_IInputActivationListener<D>::InputActivationChanged(auto_revoke_t, winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Input::InputActivationListener, winrt::Microsoft::UI::Input::InputActivationListenerActivationChangedEventArgs> const& handler) const
    {
        return impl::make_event_revoker<D, InputActivationChanged_revoker>(this, InputActivationChanged(handler));
    }
    template <typename D> auto consume_Microsoft_UI_Input_IInputActivationListener<D>::InputActivationChanged(winrt::event_token const& token) const noexcept
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IInputActivationListener>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IInputActivationListener, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IInputActivationListener>**)&_winrt_casted_result;
            _winrt_abi_type->remove_InputActivationChanged(impl::bind_in(token));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IInputActivationListener>**)this;
            _winrt_abi_type->remove_InputActivationChanged(impl::bind_in(token));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Input_IInputActivationListenerStatics<D>::GetForWindowId(winrt::Microsoft::UI::WindowId const& windowId) const
    {
        void* result{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IInputActivationListenerStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IInputActivationListenerStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IInputActivationListenerStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->GetForWindowId(impl::bind_in(windowId), &result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IInputActivationListenerStatics>**)this;
            check_hresult(_winrt_abi_type->GetForWindowId(impl::bind_in(windowId), &result));
        }
        return winrt::Microsoft::UI::Input::InputActivationListener{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Input_IInputActivationListenerStatics2<D>::GetForIsland(winrt::Microsoft::UI::Content::ContentIsland const& island) const
    {
        void* result{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IInputActivationListenerStatics2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IInputActivationListenerStatics2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IInputActivationListenerStatics2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->GetForIsland(*(void**)(&island), &result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IInputActivationListenerStatics2>**)this;
            check_hresult(_winrt_abi_type->GetForIsland(*(void**)(&island), &result));
        }
        return winrt::Microsoft::UI::Input::InputActivationListener{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Input_IInputCursorStatics<D>::CreateFromCoreCursor(winrt::Windows::UI::Core::CoreCursor const& cursor) const
    {
        void* result{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IInputCursorStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IInputCursorStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IInputCursorStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->CreateFromCoreCursor(*(void**)(&cursor), &result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IInputCursorStatics>**)this;
            check_hresult(_winrt_abi_type->CreateFromCoreCursor(*(void**)(&cursor), &result));
        }
        return winrt::Microsoft::UI::Input::InputCursor{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Input_IInputDesktopNamedResourceCursor<D>::ModuleName() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IInputDesktopNamedResourceCursor>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IInputDesktopNamedResourceCursor, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IInputDesktopNamedResourceCursor>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_ModuleName(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IInputDesktopNamedResourceCursor>**)this;
            check_hresult(_winrt_abi_type->get_ModuleName(&value));
        }
        return hstring{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Input_IInputDesktopNamedResourceCursor<D>::ResourceName() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IInputDesktopNamedResourceCursor>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IInputDesktopNamedResourceCursor, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IInputDesktopNamedResourceCursor>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_ResourceName(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IInputDesktopNamedResourceCursor>**)this;
            check_hresult(_winrt_abi_type->get_ResourceName(&value));
        }
        return hstring{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Input_IInputDesktopNamedResourceCursorStatics<D>::Create(param::hstring const& resourceName) const
    {
        void* result{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IInputDesktopNamedResourceCursorStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IInputDesktopNamedResourceCursorStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IInputDesktopNamedResourceCursorStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->Create(*(void**)(&resourceName), &result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IInputDesktopNamedResourceCursorStatics>**)this;
            check_hresult(_winrt_abi_type->Create(*(void**)(&resourceName), &result));
        }
        return winrt::Microsoft::UI::Input::InputDesktopNamedResourceCursor{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Input_IInputDesktopNamedResourceCursorStatics<D>::CreateFromModule(param::hstring const& moduleName, param::hstring const& resourceName) const
    {
        void* result{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IInputDesktopNamedResourceCursorStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IInputDesktopNamedResourceCursorStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IInputDesktopNamedResourceCursorStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->CreateFromModule(*(void**)(&moduleName), *(void**)(&resourceName), &result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IInputDesktopNamedResourceCursorStatics>**)this;
            check_hresult(_winrt_abi_type->CreateFromModule(*(void**)(&moduleName), *(void**)(&resourceName), &result));
        }
        return winrt::Microsoft::UI::Input::InputDesktopNamedResourceCursor{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Input_IInputDesktopResourceCursor<D>::ModuleName() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IInputDesktopResourceCursor>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IInputDesktopResourceCursor, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IInputDesktopResourceCursor>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_ModuleName(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IInputDesktopResourceCursor>**)this;
            check_hresult(_winrt_abi_type->get_ModuleName(&value));
        }
        return hstring{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Input_IInputDesktopResourceCursor<D>::ResourceId() const
    {
        uint32_t value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IInputDesktopResourceCursor>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IInputDesktopResourceCursor, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IInputDesktopResourceCursor>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_ResourceId(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IInputDesktopResourceCursor>**)this;
            check_hresult(_winrt_abi_type->get_ResourceId(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Input_IInputDesktopResourceCursorStatics<D>::Create(uint32_t resourceId) const
    {
        void* result{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IInputDesktopResourceCursorStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IInputDesktopResourceCursorStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IInputDesktopResourceCursorStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->Create(resourceId, &result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IInputDesktopResourceCursorStatics>**)this;
            check_hresult(_winrt_abi_type->Create(resourceId, &result));
        }
        return winrt::Microsoft::UI::Input::InputDesktopResourceCursor{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Input_IInputDesktopResourceCursorStatics<D>::CreateFromModule(param::hstring const& moduleName, uint32_t resourceId) const
    {
        void* result{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IInputDesktopResourceCursorStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IInputDesktopResourceCursorStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IInputDesktopResourceCursorStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->CreateFromModule(*(void**)(&moduleName), resourceId, &result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IInputDesktopResourceCursorStatics>**)this;
            check_hresult(_winrt_abi_type->CreateFromModule(*(void**)(&moduleName), resourceId, &result));
        }
        return winrt::Microsoft::UI::Input::InputDesktopResourceCursor{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Input_IInputFocusController<D>::HasFocus() const
    {
        bool value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IInputFocusController>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IInputFocusController, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IInputFocusController>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_HasFocus(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IInputFocusController>**)this;
            check_hresult(_winrt_abi_type->get_HasFocus(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Input_IInputFocusController<D>::TrySetFocus() const
    {
        bool result{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IInputFocusController>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IInputFocusController, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IInputFocusController>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->TrySetFocus(&result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IInputFocusController>**)this;
            check_hresult(_winrt_abi_type->TrySetFocus(&result));
        }
        return result;
    }
    template <typename D> auto consume_Microsoft_UI_Input_IInputFocusController<D>::GotFocus(winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Input::InputFocusController, winrt::Microsoft::UI::Input::FocusChangedEventArgs> const& handler) const
    {
        winrt::event_token token{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IInputFocusController>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IInputFocusController, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IInputFocusController>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->add_GotFocus(*(void**)(&handler), put_abi(token)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IInputFocusController>**)this;
            check_hresult(_winrt_abi_type->add_GotFocus(*(void**)(&handler), put_abi(token)));
        }
        return token;
    }
    template <typename D> auto consume_Microsoft_UI_Input_IInputFocusController<D>::GotFocus(auto_revoke_t, winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Input::InputFocusController, winrt::Microsoft::UI::Input::FocusChangedEventArgs> const& handler) const
    {
        return impl::make_event_revoker<D, GotFocus_revoker>(this, GotFocus(handler));
    }
    template <typename D> auto consume_Microsoft_UI_Input_IInputFocusController<D>::GotFocus(winrt::event_token const& token) const noexcept
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IInputFocusController>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IInputFocusController, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IInputFocusController>**)&_winrt_casted_result;
            _winrt_abi_type->remove_GotFocus(impl::bind_in(token));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IInputFocusController>**)this;
            _winrt_abi_type->remove_GotFocus(impl::bind_in(token));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Input_IInputFocusController<D>::LostFocus(winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Input::InputFocusController, winrt::Microsoft::UI::Input::FocusChangedEventArgs> const& handler) const
    {
        winrt::event_token token{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IInputFocusController>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IInputFocusController, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IInputFocusController>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->add_LostFocus(*(void**)(&handler), put_abi(token)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IInputFocusController>**)this;
            check_hresult(_winrt_abi_type->add_LostFocus(*(void**)(&handler), put_abi(token)));
        }
        return token;
    }
    template <typename D> auto consume_Microsoft_UI_Input_IInputFocusController<D>::LostFocus(auto_revoke_t, winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Input::InputFocusController, winrt::Microsoft::UI::Input::FocusChangedEventArgs> const& handler) const
    {
        return impl::make_event_revoker<D, LostFocus_revoker>(this, LostFocus(handler));
    }
    template <typename D> auto consume_Microsoft_UI_Input_IInputFocusController<D>::LostFocus(winrt::event_token const& token) const noexcept
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IInputFocusController>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IInputFocusController, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IInputFocusController>**)&_winrt_casted_result;
            _winrt_abi_type->remove_LostFocus(impl::bind_in(token));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IInputFocusController>**)this;
            _winrt_abi_type->remove_LostFocus(impl::bind_in(token));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Input_IInputFocusController2<D>::DepartFocus(winrt::Microsoft::UI::Input::FocusNavigationRequest const& request) const
    {
        winrt::Microsoft::UI::Input::FocusNavigationResult result{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IInputFocusController2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IInputFocusController2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IInputFocusController2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->DepartFocus(*(void**)(&request), reinterpret_cast<int32_t*>(&result)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IInputFocusController2>**)this;
            check_hresult(_winrt_abi_type->DepartFocus(*(void**)(&request), reinterpret_cast<int32_t*>(&result)));
        }
        return result;
    }
    template <typename D> auto consume_Microsoft_UI_Input_IInputFocusController2<D>::NavigateFocusRequested(winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Input::InputFocusController, winrt::Microsoft::UI::Input::FocusNavigationRequestEventArgs> const& handler) const
    {
        winrt::event_token token{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IInputFocusController2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IInputFocusController2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IInputFocusController2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->add_NavigateFocusRequested(*(void**)(&handler), put_abi(token)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IInputFocusController2>**)this;
            check_hresult(_winrt_abi_type->add_NavigateFocusRequested(*(void**)(&handler), put_abi(token)));
        }
        return token;
    }
    template <typename D> auto consume_Microsoft_UI_Input_IInputFocusController2<D>::NavigateFocusRequested(auto_revoke_t, winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Input::InputFocusController, winrt::Microsoft::UI::Input::FocusNavigationRequestEventArgs> const& handler) const
    {
        return impl::make_event_revoker<D, NavigateFocusRequested_revoker>(this, NavigateFocusRequested(handler));
    }
    template <typename D> auto consume_Microsoft_UI_Input_IInputFocusController2<D>::NavigateFocusRequested(winrt::event_token const& token) const noexcept
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IInputFocusController2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IInputFocusController2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IInputFocusController2>**)&_winrt_casted_result;
            _winrt_abi_type->remove_NavigateFocusRequested(impl::bind_in(token));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IInputFocusController2>**)this;
            _winrt_abi_type->remove_NavigateFocusRequested(impl::bind_in(token));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Input_IInputFocusControllerStatics<D>::GetForIsland(winrt::Microsoft::UI::Content::ContentIsland const& island) const
    {
        void* result{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IInputFocusControllerStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IInputFocusControllerStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IInputFocusControllerStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->GetForIsland(*(void**)(&island), &result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IInputFocusControllerStatics>**)this;
            check_hresult(_winrt_abi_type->GetForIsland(*(void**)(&island), &result));
        }
        return winrt::Microsoft::UI::Input::InputFocusController{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Input_IInputFocusNavigationHost<D>::ContainsFocus() const
    {
        bool value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IInputFocusNavigationHost>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IInputFocusNavigationHost, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IInputFocusNavigationHost>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_ContainsFocus(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IInputFocusNavigationHost>**)this;
            check_hresult(_winrt_abi_type->get_ContainsFocus(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Input_IInputFocusNavigationHost<D>::NavigateFocus(winrt::Microsoft::UI::Input::FocusNavigationRequest const& request) const
    {
        winrt::Microsoft::UI::Input::FocusNavigationResult result{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IInputFocusNavigationHost>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IInputFocusNavigationHost, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IInputFocusNavigationHost>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->NavigateFocus(*(void**)(&request), reinterpret_cast<int32_t*>(&result)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IInputFocusNavigationHost>**)this;
            check_hresult(_winrt_abi_type->NavigateFocus(*(void**)(&request), reinterpret_cast<int32_t*>(&result)));
        }
        return result;
    }
    template <typename D> auto consume_Microsoft_UI_Input_IInputFocusNavigationHost<D>::DepartFocusRequested(winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Input::InputFocusNavigationHost, winrt::Microsoft::UI::Input::FocusNavigationRequestEventArgs> const& handler) const
    {
        winrt::event_token token{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IInputFocusNavigationHost>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IInputFocusNavigationHost, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IInputFocusNavigationHost>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->add_DepartFocusRequested(*(void**)(&handler), put_abi(token)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IInputFocusNavigationHost>**)this;
            check_hresult(_winrt_abi_type->add_DepartFocusRequested(*(void**)(&handler), put_abi(token)));
        }
        return token;
    }
    template <typename D> auto consume_Microsoft_UI_Input_IInputFocusNavigationHost<D>::DepartFocusRequested(auto_revoke_t, winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Input::InputFocusNavigationHost, winrt::Microsoft::UI::Input::FocusNavigationRequestEventArgs> const& handler) const
    {
        return impl::make_event_revoker<D, DepartFocusRequested_revoker>(this, DepartFocusRequested(handler));
    }
    template <typename D> auto consume_Microsoft_UI_Input_IInputFocusNavigationHost<D>::DepartFocusRequested(winrt::event_token const& token) const noexcept
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IInputFocusNavigationHost>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IInputFocusNavigationHost, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IInputFocusNavigationHost>**)&_winrt_casted_result;
            _winrt_abi_type->remove_DepartFocusRequested(impl::bind_in(token));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IInputFocusNavigationHost>**)this;
            _winrt_abi_type->remove_DepartFocusRequested(impl::bind_in(token));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Input_IInputFocusNavigationHostStatics<D>::GetForSiteBridge(winrt::Microsoft::UI::Content::IContentSiteBridge const& site) const
    {
        void* result{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IInputFocusNavigationHostStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IInputFocusNavigationHostStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IInputFocusNavigationHostStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->GetForSiteBridge(*(void**)(&site), &result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IInputFocusNavigationHostStatics>**)this;
            check_hresult(_winrt_abi_type->GetForSiteBridge(*(void**)(&site), &result));
        }
        return winrt::Microsoft::UI::Input::InputFocusNavigationHost{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Input_IInputFocusNavigationHostStatics2<D>::GetForSiteLink(winrt::Microsoft::UI::Content::IContentSiteLink const& contentSiteLink) const
    {
        void* result{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IInputFocusNavigationHostStatics2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IInputFocusNavigationHostStatics2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IInputFocusNavigationHostStatics2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->GetForSiteLink(*(void**)(&contentSiteLink), &result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IInputFocusNavigationHostStatics2>**)this;
            check_hresult(_winrt_abi_type->GetForSiteLink(*(void**)(&contentSiteLink), &result));
        }
        return winrt::Microsoft::UI::Input::InputFocusNavigationHost{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Input_IInputKeyboardSource2<D>::GetCurrentKeyState(winrt::Windows::System::VirtualKey const& virtualKey) const
    {
        winrt::Microsoft::UI::Input::VirtualKeyStates result{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IInputKeyboardSource2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IInputKeyboardSource2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IInputKeyboardSource2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->GetCurrentKeyState(static_cast<int32_t>(virtualKey), reinterpret_cast<uint32_t*>(&result)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IInputKeyboardSource2>**)this;
            check_hresult(_winrt_abi_type->GetCurrentKeyState(static_cast<int32_t>(virtualKey), reinterpret_cast<uint32_t*>(&result)));
        }
        return result;
    }
    template <typename D> auto consume_Microsoft_UI_Input_IInputKeyboardSource2<D>::GetKeyState(winrt::Windows::System::VirtualKey const& virtualKey) const
    {
        winrt::Microsoft::UI::Input::VirtualKeyStates result{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IInputKeyboardSource2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IInputKeyboardSource2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IInputKeyboardSource2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->GetKeyState(static_cast<int32_t>(virtualKey), reinterpret_cast<uint32_t*>(&result)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IInputKeyboardSource2>**)this;
            check_hresult(_winrt_abi_type->GetKeyState(static_cast<int32_t>(virtualKey), reinterpret_cast<uint32_t*>(&result)));
        }
        return result;
    }
    template <typename D> auto consume_Microsoft_UI_Input_IInputKeyboardSource2<D>::CharacterReceived(winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Input::InputKeyboardSource, winrt::Microsoft::UI::Input::CharacterReceivedEventArgs> const& handler) const
    {
        winrt::event_token token{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IInputKeyboardSource2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IInputKeyboardSource2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IInputKeyboardSource2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->add_CharacterReceived(*(void**)(&handler), put_abi(token)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IInputKeyboardSource2>**)this;
            check_hresult(_winrt_abi_type->add_CharacterReceived(*(void**)(&handler), put_abi(token)));
        }
        return token;
    }
    template <typename D> auto consume_Microsoft_UI_Input_IInputKeyboardSource2<D>::CharacterReceived(auto_revoke_t, winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Input::InputKeyboardSource, winrt::Microsoft::UI::Input::CharacterReceivedEventArgs> const& handler) const
    {
        return impl::make_event_revoker<D, CharacterReceived_revoker>(this, CharacterReceived(handler));
    }
    template <typename D> auto consume_Microsoft_UI_Input_IInputKeyboardSource2<D>::CharacterReceived(winrt::event_token const& token) const noexcept
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IInputKeyboardSource2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IInputKeyboardSource2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IInputKeyboardSource2>**)&_winrt_casted_result;
            _winrt_abi_type->remove_CharacterReceived(impl::bind_in(token));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IInputKeyboardSource2>**)this;
            _winrt_abi_type->remove_CharacterReceived(impl::bind_in(token));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Input_IInputKeyboardSource2<D>::ContextMenuKey(winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Input::InputKeyboardSource, winrt::Microsoft::UI::Input::ContextMenuKeyEventArgs> const& handler) const
    {
        winrt::event_token token{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IInputKeyboardSource2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IInputKeyboardSource2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IInputKeyboardSource2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->add_ContextMenuKey(*(void**)(&handler), put_abi(token)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IInputKeyboardSource2>**)this;
            check_hresult(_winrt_abi_type->add_ContextMenuKey(*(void**)(&handler), put_abi(token)));
        }
        return token;
    }
    template <typename D> auto consume_Microsoft_UI_Input_IInputKeyboardSource2<D>::ContextMenuKey(auto_revoke_t, winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Input::InputKeyboardSource, winrt::Microsoft::UI::Input::ContextMenuKeyEventArgs> const& handler) const
    {
        return impl::make_event_revoker<D, ContextMenuKey_revoker>(this, ContextMenuKey(handler));
    }
    template <typename D> auto consume_Microsoft_UI_Input_IInputKeyboardSource2<D>::ContextMenuKey(winrt::event_token const& token) const noexcept
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IInputKeyboardSource2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IInputKeyboardSource2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IInputKeyboardSource2>**)&_winrt_casted_result;
            _winrt_abi_type->remove_ContextMenuKey(impl::bind_in(token));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IInputKeyboardSource2>**)this;
            _winrt_abi_type->remove_ContextMenuKey(impl::bind_in(token));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Input_IInputKeyboardSource2<D>::KeyDown(winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Input::InputKeyboardSource, winrt::Microsoft::UI::Input::KeyEventArgs> const& handler) const
    {
        winrt::event_token token{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IInputKeyboardSource2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IInputKeyboardSource2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IInputKeyboardSource2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->add_KeyDown(*(void**)(&handler), put_abi(token)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IInputKeyboardSource2>**)this;
            check_hresult(_winrt_abi_type->add_KeyDown(*(void**)(&handler), put_abi(token)));
        }
        return token;
    }
    template <typename D> auto consume_Microsoft_UI_Input_IInputKeyboardSource2<D>::KeyDown(auto_revoke_t, winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Input::InputKeyboardSource, winrt::Microsoft::UI::Input::KeyEventArgs> const& handler) const
    {
        return impl::make_event_revoker<D, KeyDown_revoker>(this, KeyDown(handler));
    }
    template <typename D> auto consume_Microsoft_UI_Input_IInputKeyboardSource2<D>::KeyDown(winrt::event_token const& token) const noexcept
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IInputKeyboardSource2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IInputKeyboardSource2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IInputKeyboardSource2>**)&_winrt_casted_result;
            _winrt_abi_type->remove_KeyDown(impl::bind_in(token));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IInputKeyboardSource2>**)this;
            _winrt_abi_type->remove_KeyDown(impl::bind_in(token));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Input_IInputKeyboardSource2<D>::KeyUp(winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Input::InputKeyboardSource, winrt::Microsoft::UI::Input::KeyEventArgs> const& handler) const
    {
        winrt::event_token token{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IInputKeyboardSource2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IInputKeyboardSource2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IInputKeyboardSource2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->add_KeyUp(*(void**)(&handler), put_abi(token)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IInputKeyboardSource2>**)this;
            check_hresult(_winrt_abi_type->add_KeyUp(*(void**)(&handler), put_abi(token)));
        }
        return token;
    }
    template <typename D> auto consume_Microsoft_UI_Input_IInputKeyboardSource2<D>::KeyUp(auto_revoke_t, winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Input::InputKeyboardSource, winrt::Microsoft::UI::Input::KeyEventArgs> const& handler) const
    {
        return impl::make_event_revoker<D, KeyUp_revoker>(this, KeyUp(handler));
    }
    template <typename D> auto consume_Microsoft_UI_Input_IInputKeyboardSource2<D>::KeyUp(winrt::event_token const& token) const noexcept
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IInputKeyboardSource2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IInputKeyboardSource2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IInputKeyboardSource2>**)&_winrt_casted_result;
            _winrt_abi_type->remove_KeyUp(impl::bind_in(token));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IInputKeyboardSource2>**)this;
            _winrt_abi_type->remove_KeyUp(impl::bind_in(token));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Input_IInputKeyboardSource2<D>::SystemKeyDown(winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Input::InputKeyboardSource, winrt::Microsoft::UI::Input::KeyEventArgs> const& handler) const
    {
        winrt::event_token token{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IInputKeyboardSource2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IInputKeyboardSource2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IInputKeyboardSource2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->add_SystemKeyDown(*(void**)(&handler), put_abi(token)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IInputKeyboardSource2>**)this;
            check_hresult(_winrt_abi_type->add_SystemKeyDown(*(void**)(&handler), put_abi(token)));
        }
        return token;
    }
    template <typename D> auto consume_Microsoft_UI_Input_IInputKeyboardSource2<D>::SystemKeyDown(auto_revoke_t, winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Input::InputKeyboardSource, winrt::Microsoft::UI::Input::KeyEventArgs> const& handler) const
    {
        return impl::make_event_revoker<D, SystemKeyDown_revoker>(this, SystemKeyDown(handler));
    }
    template <typename D> auto consume_Microsoft_UI_Input_IInputKeyboardSource2<D>::SystemKeyDown(winrt::event_token const& token) const noexcept
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IInputKeyboardSource2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IInputKeyboardSource2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IInputKeyboardSource2>**)&_winrt_casted_result;
            _winrt_abi_type->remove_SystemKeyDown(impl::bind_in(token));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IInputKeyboardSource2>**)this;
            _winrt_abi_type->remove_SystemKeyDown(impl::bind_in(token));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Input_IInputKeyboardSource2<D>::SystemKeyUp(winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Input::InputKeyboardSource, winrt::Microsoft::UI::Input::KeyEventArgs> const& handler) const
    {
        winrt::event_token token{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IInputKeyboardSource2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IInputKeyboardSource2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IInputKeyboardSource2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->add_SystemKeyUp(*(void**)(&handler), put_abi(token)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IInputKeyboardSource2>**)this;
            check_hresult(_winrt_abi_type->add_SystemKeyUp(*(void**)(&handler), put_abi(token)));
        }
        return token;
    }
    template <typename D> auto consume_Microsoft_UI_Input_IInputKeyboardSource2<D>::SystemKeyUp(auto_revoke_t, winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Input::InputKeyboardSource, winrt::Microsoft::UI::Input::KeyEventArgs> const& handler) const
    {
        return impl::make_event_revoker<D, SystemKeyUp_revoker>(this, SystemKeyUp(handler));
    }
    template <typename D> auto consume_Microsoft_UI_Input_IInputKeyboardSource2<D>::SystemKeyUp(winrt::event_token const& token) const noexcept
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IInputKeyboardSource2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IInputKeyboardSource2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IInputKeyboardSource2>**)&_winrt_casted_result;
            _winrt_abi_type->remove_SystemKeyUp(impl::bind_in(token));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IInputKeyboardSource2>**)this;
            _winrt_abi_type->remove_SystemKeyUp(impl::bind_in(token));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Input_IInputKeyboardSourceStatics<D>::GetKeyStateForCurrentThread(winrt::Windows::System::VirtualKey const& virtualKey) const
    {
        winrt::Windows::UI::Core::CoreVirtualKeyStates result{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IInputKeyboardSourceStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IInputKeyboardSourceStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IInputKeyboardSourceStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->GetKeyStateForCurrentThread(static_cast<int32_t>(virtualKey), reinterpret_cast<uint32_t*>(&result)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IInputKeyboardSourceStatics>**)this;
            check_hresult(_winrt_abi_type->GetKeyStateForCurrentThread(static_cast<int32_t>(virtualKey), reinterpret_cast<uint32_t*>(&result)));
        }
        return result;
    }
    template <typename D> auto consume_Microsoft_UI_Input_IInputKeyboardSourceStatics2<D>::GetForIsland(winrt::Microsoft::UI::Content::ContentIsland const& island) const
    {
        void* result{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IInputKeyboardSourceStatics2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IInputKeyboardSourceStatics2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IInputKeyboardSourceStatics2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->GetForIsland(*(void**)(&island), &result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IInputKeyboardSourceStatics2>**)this;
            check_hresult(_winrt_abi_type->GetForIsland(*(void**)(&island), &result));
        }
        return winrt::Microsoft::UI::Input::InputKeyboardSource{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Input_IInputLightDismissAction<D>::Dismissed(winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Input::InputLightDismissAction, winrt::Microsoft::UI::Input::InputLightDismissEventArgs> const& handler) const
    {
        winrt::event_token token{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IInputLightDismissAction>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IInputLightDismissAction, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IInputLightDismissAction>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->add_Dismissed(*(void**)(&handler), put_abi(token)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IInputLightDismissAction>**)this;
            check_hresult(_winrt_abi_type->add_Dismissed(*(void**)(&handler), put_abi(token)));
        }
        return token;
    }
    template <typename D> auto consume_Microsoft_UI_Input_IInputLightDismissAction<D>::Dismissed(auto_revoke_t, winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Input::InputLightDismissAction, winrt::Microsoft::UI::Input::InputLightDismissEventArgs> const& handler) const
    {
        return impl::make_event_revoker<D, Dismissed_revoker>(this, Dismissed(handler));
    }
    template <typename D> auto consume_Microsoft_UI_Input_IInputLightDismissAction<D>::Dismissed(winrt::event_token const& token) const noexcept
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IInputLightDismissAction>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IInputLightDismissAction, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IInputLightDismissAction>**)&_winrt_casted_result;
            _winrt_abi_type->remove_Dismissed(impl::bind_in(token));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IInputLightDismissAction>**)this;
            _winrt_abi_type->remove_Dismissed(impl::bind_in(token));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Input_IInputLightDismissActionStatics<D>::GetForWindowId(winrt::Microsoft::UI::WindowId const& windowId) const
    {
        void* result{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IInputLightDismissActionStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IInputLightDismissActionStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IInputLightDismissActionStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->GetForWindowId(impl::bind_in(windowId), &result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IInputLightDismissActionStatics>**)this;
            check_hresult(_winrt_abi_type->GetForWindowId(impl::bind_in(windowId), &result));
        }
        return winrt::Microsoft::UI::Input::InputLightDismissAction{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Input_IInputNonClientPointerSource<D>::DispatcherQueue() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IInputNonClientPointerSource>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IInputNonClientPointerSource, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IInputNonClientPointerSource>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_DispatcherQueue(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IInputNonClientPointerSource>**)this;
            check_hresult(_winrt_abi_type->get_DispatcherQueue(&value));
        }
        return winrt::Microsoft::UI::Dispatching::DispatcherQueue{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Input_IInputNonClientPointerSource<D>::ClearAllRegionRects() const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IInputNonClientPointerSource>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IInputNonClientPointerSource, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IInputNonClientPointerSource>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->ClearAllRegionRects());
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IInputNonClientPointerSource>**)this;
            check_hresult(_winrt_abi_type->ClearAllRegionRects());
        }
    }
    template <typename D> auto consume_Microsoft_UI_Input_IInputNonClientPointerSource<D>::ClearRegionRects(winrt::Microsoft::UI::Input::NonClientRegionKind const& region) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IInputNonClientPointerSource>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IInputNonClientPointerSource, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IInputNonClientPointerSource>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->ClearRegionRects(static_cast<int32_t>(region)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IInputNonClientPointerSource>**)this;
            check_hresult(_winrt_abi_type->ClearRegionRects(static_cast<int32_t>(region)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Input_IInputNonClientPointerSource<D>::GetRegionRects(winrt::Microsoft::UI::Input::NonClientRegionKind const& region) const
    {
        uint32_t result_impl_size{};
        struct struct_Windows_Graphics_RectInt32* result{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IInputNonClientPointerSource>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IInputNonClientPointerSource, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IInputNonClientPointerSource>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->GetRegionRects(static_cast<int32_t>(region), &result_impl_size, &result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IInputNonClientPointerSource>**)this;
            check_hresult(_winrt_abi_type->GetRegionRects(static_cast<int32_t>(region), &result_impl_size, &result));
        }
        return com_array<winrt::Windows::Graphics::RectInt32>{ result, result_impl_size, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Input_IInputNonClientPointerSource<D>::SetRegionRects(winrt::Microsoft::UI::Input::NonClientRegionKind const& region, array_view<winrt::Windows::Graphics::RectInt32 const> rects) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IInputNonClientPointerSource>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IInputNonClientPointerSource, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IInputNonClientPointerSource>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->SetRegionRects(static_cast<int32_t>(region), rects.size(), get_abi(rects)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IInputNonClientPointerSource>**)this;
            check_hresult(_winrt_abi_type->SetRegionRects(static_cast<int32_t>(region), rects.size(), get_abi(rects)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Input_IInputNonClientPointerSource<D>::CaptionTapped(winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Input::InputNonClientPointerSource, winrt::Microsoft::UI::Input::NonClientCaptionTappedEventArgs> const& handler) const
    {
        winrt::event_token token{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IInputNonClientPointerSource>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IInputNonClientPointerSource, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IInputNonClientPointerSource>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->add_CaptionTapped(*(void**)(&handler), put_abi(token)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IInputNonClientPointerSource>**)this;
            check_hresult(_winrt_abi_type->add_CaptionTapped(*(void**)(&handler), put_abi(token)));
        }
        return token;
    }
    template <typename D> auto consume_Microsoft_UI_Input_IInputNonClientPointerSource<D>::CaptionTapped(auto_revoke_t, winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Input::InputNonClientPointerSource, winrt::Microsoft::UI::Input::NonClientCaptionTappedEventArgs> const& handler) const
    {
        return impl::make_event_revoker<D, CaptionTapped_revoker>(this, CaptionTapped(handler));
    }
    template <typename D> auto consume_Microsoft_UI_Input_IInputNonClientPointerSource<D>::CaptionTapped(winrt::event_token const& token) const noexcept
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IInputNonClientPointerSource>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IInputNonClientPointerSource, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IInputNonClientPointerSource>**)&_winrt_casted_result;
            _winrt_abi_type->remove_CaptionTapped(impl::bind_in(token));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IInputNonClientPointerSource>**)this;
            _winrt_abi_type->remove_CaptionTapped(impl::bind_in(token));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Input_IInputNonClientPointerSource<D>::PointerEntered(winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Input::InputNonClientPointerSource, winrt::Microsoft::UI::Input::NonClientPointerEventArgs> const& handler) const
    {
        winrt::event_token token{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IInputNonClientPointerSource>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IInputNonClientPointerSource, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IInputNonClientPointerSource>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->add_PointerEntered(*(void**)(&handler), put_abi(token)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IInputNonClientPointerSource>**)this;
            check_hresult(_winrt_abi_type->add_PointerEntered(*(void**)(&handler), put_abi(token)));
        }
        return token;
    }
    template <typename D> auto consume_Microsoft_UI_Input_IInputNonClientPointerSource<D>::PointerEntered(auto_revoke_t, winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Input::InputNonClientPointerSource, winrt::Microsoft::UI::Input::NonClientPointerEventArgs> const& handler) const
    {
        return impl::make_event_revoker<D, PointerEntered_revoker>(this, PointerEntered(handler));
    }
    template <typename D> auto consume_Microsoft_UI_Input_IInputNonClientPointerSource<D>::PointerEntered(winrt::event_token const& token) const noexcept
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IInputNonClientPointerSource>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IInputNonClientPointerSource, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IInputNonClientPointerSource>**)&_winrt_casted_result;
            _winrt_abi_type->remove_PointerEntered(impl::bind_in(token));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IInputNonClientPointerSource>**)this;
            _winrt_abi_type->remove_PointerEntered(impl::bind_in(token));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Input_IInputNonClientPointerSource<D>::PointerExited(winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Input::InputNonClientPointerSource, winrt::Microsoft::UI::Input::NonClientPointerEventArgs> const& handler) const
    {
        winrt::event_token token{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IInputNonClientPointerSource>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IInputNonClientPointerSource, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IInputNonClientPointerSource>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->add_PointerExited(*(void**)(&handler), put_abi(token)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IInputNonClientPointerSource>**)this;
            check_hresult(_winrt_abi_type->add_PointerExited(*(void**)(&handler), put_abi(token)));
        }
        return token;
    }
    template <typename D> auto consume_Microsoft_UI_Input_IInputNonClientPointerSource<D>::PointerExited(auto_revoke_t, winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Input::InputNonClientPointerSource, winrt::Microsoft::UI::Input::NonClientPointerEventArgs> const& handler) const
    {
        return impl::make_event_revoker<D, PointerExited_revoker>(this, PointerExited(handler));
    }
    template <typename D> auto consume_Microsoft_UI_Input_IInputNonClientPointerSource<D>::PointerExited(winrt::event_token const& token) const noexcept
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IInputNonClientPointerSource>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IInputNonClientPointerSource, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IInputNonClientPointerSource>**)&_winrt_casted_result;
            _winrt_abi_type->remove_PointerExited(impl::bind_in(token));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IInputNonClientPointerSource>**)this;
            _winrt_abi_type->remove_PointerExited(impl::bind_in(token));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Input_IInputNonClientPointerSource<D>::PointerMoved(winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Input::InputNonClientPointerSource, winrt::Microsoft::UI::Input::NonClientPointerEventArgs> const& handler) const
    {
        winrt::event_token token{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IInputNonClientPointerSource>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IInputNonClientPointerSource, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IInputNonClientPointerSource>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->add_PointerMoved(*(void**)(&handler), put_abi(token)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IInputNonClientPointerSource>**)this;
            check_hresult(_winrt_abi_type->add_PointerMoved(*(void**)(&handler), put_abi(token)));
        }
        return token;
    }
    template <typename D> auto consume_Microsoft_UI_Input_IInputNonClientPointerSource<D>::PointerMoved(auto_revoke_t, winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Input::InputNonClientPointerSource, winrt::Microsoft::UI::Input::NonClientPointerEventArgs> const& handler) const
    {
        return impl::make_event_revoker<D, PointerMoved_revoker>(this, PointerMoved(handler));
    }
    template <typename D> auto consume_Microsoft_UI_Input_IInputNonClientPointerSource<D>::PointerMoved(winrt::event_token const& token) const noexcept
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IInputNonClientPointerSource>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IInputNonClientPointerSource, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IInputNonClientPointerSource>**)&_winrt_casted_result;
            _winrt_abi_type->remove_PointerMoved(impl::bind_in(token));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IInputNonClientPointerSource>**)this;
            _winrt_abi_type->remove_PointerMoved(impl::bind_in(token));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Input_IInputNonClientPointerSource<D>::PointerPressed(winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Input::InputNonClientPointerSource, winrt::Microsoft::UI::Input::NonClientPointerEventArgs> const& handler) const
    {
        winrt::event_token token{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IInputNonClientPointerSource>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IInputNonClientPointerSource, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IInputNonClientPointerSource>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->add_PointerPressed(*(void**)(&handler), put_abi(token)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IInputNonClientPointerSource>**)this;
            check_hresult(_winrt_abi_type->add_PointerPressed(*(void**)(&handler), put_abi(token)));
        }
        return token;
    }
    template <typename D> auto consume_Microsoft_UI_Input_IInputNonClientPointerSource<D>::PointerPressed(auto_revoke_t, winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Input::InputNonClientPointerSource, winrt::Microsoft::UI::Input::NonClientPointerEventArgs> const& handler) const
    {
        return impl::make_event_revoker<D, PointerPressed_revoker>(this, PointerPressed(handler));
    }
    template <typename D> auto consume_Microsoft_UI_Input_IInputNonClientPointerSource<D>::PointerPressed(winrt::event_token const& token) const noexcept
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IInputNonClientPointerSource>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IInputNonClientPointerSource, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IInputNonClientPointerSource>**)&_winrt_casted_result;
            _winrt_abi_type->remove_PointerPressed(impl::bind_in(token));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IInputNonClientPointerSource>**)this;
            _winrt_abi_type->remove_PointerPressed(impl::bind_in(token));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Input_IInputNonClientPointerSource<D>::PointerReleased(winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Input::InputNonClientPointerSource, winrt::Microsoft::UI::Input::NonClientPointerEventArgs> const& handler) const
    {
        winrt::event_token token{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IInputNonClientPointerSource>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IInputNonClientPointerSource, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IInputNonClientPointerSource>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->add_PointerReleased(*(void**)(&handler), put_abi(token)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IInputNonClientPointerSource>**)this;
            check_hresult(_winrt_abi_type->add_PointerReleased(*(void**)(&handler), put_abi(token)));
        }
        return token;
    }
    template <typename D> auto consume_Microsoft_UI_Input_IInputNonClientPointerSource<D>::PointerReleased(auto_revoke_t, winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Input::InputNonClientPointerSource, winrt::Microsoft::UI::Input::NonClientPointerEventArgs> const& handler) const
    {
        return impl::make_event_revoker<D, PointerReleased_revoker>(this, PointerReleased(handler));
    }
    template <typename D> auto consume_Microsoft_UI_Input_IInputNonClientPointerSource<D>::PointerReleased(winrt::event_token const& token) const noexcept
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IInputNonClientPointerSource>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IInputNonClientPointerSource, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IInputNonClientPointerSource>**)&_winrt_casted_result;
            _winrt_abi_type->remove_PointerReleased(impl::bind_in(token));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IInputNonClientPointerSource>**)this;
            _winrt_abi_type->remove_PointerReleased(impl::bind_in(token));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Input_IInputNonClientPointerSource<D>::RegionsChanged(winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Input::InputNonClientPointerSource, winrt::Microsoft::UI::Input::NonClientRegionsChangedEventArgs> const& handler) const
    {
        winrt::event_token token{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IInputNonClientPointerSource>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IInputNonClientPointerSource, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IInputNonClientPointerSource>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->add_RegionsChanged(*(void**)(&handler), put_abi(token)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IInputNonClientPointerSource>**)this;
            check_hresult(_winrt_abi_type->add_RegionsChanged(*(void**)(&handler), put_abi(token)));
        }
        return token;
    }
    template <typename D> auto consume_Microsoft_UI_Input_IInputNonClientPointerSource<D>::RegionsChanged(auto_revoke_t, winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Input::InputNonClientPointerSource, winrt::Microsoft::UI::Input::NonClientRegionsChangedEventArgs> const& handler) const
    {
        return impl::make_event_revoker<D, RegionsChanged_revoker>(this, RegionsChanged(handler));
    }
    template <typename D> auto consume_Microsoft_UI_Input_IInputNonClientPointerSource<D>::RegionsChanged(winrt::event_token const& token) const noexcept
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IInputNonClientPointerSource>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IInputNonClientPointerSource, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IInputNonClientPointerSource>**)&_winrt_casted_result;
            _winrt_abi_type->remove_RegionsChanged(impl::bind_in(token));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IInputNonClientPointerSource>**)this;
            _winrt_abi_type->remove_RegionsChanged(impl::bind_in(token));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Input_IInputNonClientPointerSource2<D>::EnteringMoveSize(winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Input::InputNonClientPointerSource, winrt::Microsoft::UI::Input::EnteringMoveSizeEventArgs> const& handler) const
    {
        winrt::event_token token{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IInputNonClientPointerSource2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IInputNonClientPointerSource2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IInputNonClientPointerSource2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->add_EnteringMoveSize(*(void**)(&handler), put_abi(token)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IInputNonClientPointerSource2>**)this;
            check_hresult(_winrt_abi_type->add_EnteringMoveSize(*(void**)(&handler), put_abi(token)));
        }
        return token;
    }
    template <typename D> auto consume_Microsoft_UI_Input_IInputNonClientPointerSource2<D>::EnteringMoveSize(auto_revoke_t, winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Input::InputNonClientPointerSource, winrt::Microsoft::UI::Input::EnteringMoveSizeEventArgs> const& handler) const
    {
        return impl::make_event_revoker<D, EnteringMoveSize_revoker>(this, EnteringMoveSize(handler));
    }
    template <typename D> auto consume_Microsoft_UI_Input_IInputNonClientPointerSource2<D>::EnteringMoveSize(winrt::event_token const& token) const noexcept
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IInputNonClientPointerSource2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IInputNonClientPointerSource2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IInputNonClientPointerSource2>**)&_winrt_casted_result;
            _winrt_abi_type->remove_EnteringMoveSize(impl::bind_in(token));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IInputNonClientPointerSource2>**)this;
            _winrt_abi_type->remove_EnteringMoveSize(impl::bind_in(token));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Input_IInputNonClientPointerSource2<D>::EnteredMoveSize(winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Input::InputNonClientPointerSource, winrt::Microsoft::UI::Input::EnteredMoveSizeEventArgs> const& handler) const
    {
        winrt::event_token token{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IInputNonClientPointerSource2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IInputNonClientPointerSource2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IInputNonClientPointerSource2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->add_EnteredMoveSize(*(void**)(&handler), put_abi(token)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IInputNonClientPointerSource2>**)this;
            check_hresult(_winrt_abi_type->add_EnteredMoveSize(*(void**)(&handler), put_abi(token)));
        }
        return token;
    }
    template <typename D> auto consume_Microsoft_UI_Input_IInputNonClientPointerSource2<D>::EnteredMoveSize(auto_revoke_t, winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Input::InputNonClientPointerSource, winrt::Microsoft::UI::Input::EnteredMoveSizeEventArgs> const& handler) const
    {
        return impl::make_event_revoker<D, EnteredMoveSize_revoker>(this, EnteredMoveSize(handler));
    }
    template <typename D> auto consume_Microsoft_UI_Input_IInputNonClientPointerSource2<D>::EnteredMoveSize(winrt::event_token const& token) const noexcept
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IInputNonClientPointerSource2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IInputNonClientPointerSource2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IInputNonClientPointerSource2>**)&_winrt_casted_result;
            _winrt_abi_type->remove_EnteredMoveSize(impl::bind_in(token));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IInputNonClientPointerSource2>**)this;
            _winrt_abi_type->remove_EnteredMoveSize(impl::bind_in(token));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Input_IInputNonClientPointerSource2<D>::WindowRectChanging(winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Input::InputNonClientPointerSource, winrt::Microsoft::UI::Input::WindowRectChangingEventArgs> const& handler) const
    {
        winrt::event_token token{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IInputNonClientPointerSource2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IInputNonClientPointerSource2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IInputNonClientPointerSource2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->add_WindowRectChanging(*(void**)(&handler), put_abi(token)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IInputNonClientPointerSource2>**)this;
            check_hresult(_winrt_abi_type->add_WindowRectChanging(*(void**)(&handler), put_abi(token)));
        }
        return token;
    }
    template <typename D> auto consume_Microsoft_UI_Input_IInputNonClientPointerSource2<D>::WindowRectChanging(auto_revoke_t, winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Input::InputNonClientPointerSource, winrt::Microsoft::UI::Input::WindowRectChangingEventArgs> const& handler) const
    {
        return impl::make_event_revoker<D, WindowRectChanging_revoker>(this, WindowRectChanging(handler));
    }
    template <typename D> auto consume_Microsoft_UI_Input_IInputNonClientPointerSource2<D>::WindowRectChanging(winrt::event_token const& token) const noexcept
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IInputNonClientPointerSource2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IInputNonClientPointerSource2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IInputNonClientPointerSource2>**)&_winrt_casted_result;
            _winrt_abi_type->remove_WindowRectChanging(impl::bind_in(token));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IInputNonClientPointerSource2>**)this;
            _winrt_abi_type->remove_WindowRectChanging(impl::bind_in(token));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Input_IInputNonClientPointerSource2<D>::WindowRectChanged(winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Input::InputNonClientPointerSource, winrt::Microsoft::UI::Input::WindowRectChangedEventArgs> const& handler) const
    {
        winrt::event_token token{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IInputNonClientPointerSource2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IInputNonClientPointerSource2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IInputNonClientPointerSource2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->add_WindowRectChanged(*(void**)(&handler), put_abi(token)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IInputNonClientPointerSource2>**)this;
            check_hresult(_winrt_abi_type->add_WindowRectChanged(*(void**)(&handler), put_abi(token)));
        }
        return token;
    }
    template <typename D> auto consume_Microsoft_UI_Input_IInputNonClientPointerSource2<D>::WindowRectChanged(auto_revoke_t, winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Input::InputNonClientPointerSource, winrt::Microsoft::UI::Input::WindowRectChangedEventArgs> const& handler) const
    {
        return impl::make_event_revoker<D, WindowRectChanged_revoker>(this, WindowRectChanged(handler));
    }
    template <typename D> auto consume_Microsoft_UI_Input_IInputNonClientPointerSource2<D>::WindowRectChanged(winrt::event_token const& token) const noexcept
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IInputNonClientPointerSource2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IInputNonClientPointerSource2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IInputNonClientPointerSource2>**)&_winrt_casted_result;
            _winrt_abi_type->remove_WindowRectChanged(impl::bind_in(token));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IInputNonClientPointerSource2>**)this;
            _winrt_abi_type->remove_WindowRectChanged(impl::bind_in(token));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Input_IInputNonClientPointerSource2<D>::ExitedMoveSize(winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Input::InputNonClientPointerSource, winrt::Microsoft::UI::Input::ExitedMoveSizeEventArgs> const& handler) const
    {
        winrt::event_token token{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IInputNonClientPointerSource2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IInputNonClientPointerSource2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IInputNonClientPointerSource2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->add_ExitedMoveSize(*(void**)(&handler), put_abi(token)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IInputNonClientPointerSource2>**)this;
            check_hresult(_winrt_abi_type->add_ExitedMoveSize(*(void**)(&handler), put_abi(token)));
        }
        return token;
    }
    template <typename D> auto consume_Microsoft_UI_Input_IInputNonClientPointerSource2<D>::ExitedMoveSize(auto_revoke_t, winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Input::InputNonClientPointerSource, winrt::Microsoft::UI::Input::ExitedMoveSizeEventArgs> const& handler) const
    {
        return impl::make_event_revoker<D, ExitedMoveSize_revoker>(this, ExitedMoveSize(handler));
    }
    template <typename D> auto consume_Microsoft_UI_Input_IInputNonClientPointerSource2<D>::ExitedMoveSize(winrt::event_token const& token) const noexcept
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IInputNonClientPointerSource2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IInputNonClientPointerSource2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IInputNonClientPointerSource2>**)&_winrt_casted_result;
            _winrt_abi_type->remove_ExitedMoveSize(impl::bind_in(token));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IInputNonClientPointerSource2>**)this;
            _winrt_abi_type->remove_ExitedMoveSize(impl::bind_in(token));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Input_IInputNonClientPointerSourceStatics<D>::GetForWindowId(winrt::Microsoft::UI::WindowId const& windowId) const
    {
        void* result{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IInputNonClientPointerSourceStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IInputNonClientPointerSourceStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IInputNonClientPointerSourceStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->GetForWindowId(impl::bind_in(windowId), &result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IInputNonClientPointerSourceStatics>**)this;
            check_hresult(_winrt_abi_type->GetForWindowId(impl::bind_in(windowId), &result));
        }
        return winrt::Microsoft::UI::Input::InputNonClientPointerSource{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Input_IInputObject<D>::DispatcherQueue() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IInputObject>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IInputObject, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IInputObject>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_DispatcherQueue(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IInputObject>**)this;
            check_hresult(_winrt_abi_type->get_DispatcherQueue(&value));
        }
        return winrt::Microsoft::UI::Dispatching::DispatcherQueue{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Input_IInputPointerSource<D>::Cursor() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IInputPointerSource>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IInputPointerSource, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IInputPointerSource>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Cursor(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IInputPointerSource>**)this;
            check_hresult(_winrt_abi_type->get_Cursor(&value));
        }
        return winrt::Microsoft::UI::Input::InputCursor{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Input_IInputPointerSource<D>::Cursor(winrt::Microsoft::UI::Input::InputCursor const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IInputPointerSource>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IInputPointerSource, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IInputPointerSource>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_Cursor(*(void**)(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IInputPointerSource>**)this;
            check_hresult(_winrt_abi_type->put_Cursor(*(void**)(&value)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Input_IInputPointerSource<D>::DeviceKinds() const
    {
        winrt::Microsoft::UI::Input::InputPointerSourceDeviceKinds value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IInputPointerSource>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IInputPointerSource, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IInputPointerSource>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_DeviceKinds(reinterpret_cast<uint32_t*>(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IInputPointerSource>**)this;
            check_hresult(_winrt_abi_type->get_DeviceKinds(reinterpret_cast<uint32_t*>(&value)));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Input_IInputPointerSource<D>::PointerCaptureLost(winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Input::InputPointerSource, winrt::Microsoft::UI::Input::PointerEventArgs> const& handler) const
    {
        winrt::event_token token{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IInputPointerSource>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IInputPointerSource, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IInputPointerSource>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->add_PointerCaptureLost(*(void**)(&handler), put_abi(token)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IInputPointerSource>**)this;
            check_hresult(_winrt_abi_type->add_PointerCaptureLost(*(void**)(&handler), put_abi(token)));
        }
        return token;
    }
    template <typename D> auto consume_Microsoft_UI_Input_IInputPointerSource<D>::PointerCaptureLost(auto_revoke_t, winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Input::InputPointerSource, winrt::Microsoft::UI::Input::PointerEventArgs> const& handler) const
    {
        return impl::make_event_revoker<D, PointerCaptureLost_revoker>(this, PointerCaptureLost(handler));
    }
    template <typename D> auto consume_Microsoft_UI_Input_IInputPointerSource<D>::PointerCaptureLost(winrt::event_token const& token) const noexcept
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IInputPointerSource>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IInputPointerSource, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IInputPointerSource>**)&_winrt_casted_result;
            _winrt_abi_type->remove_PointerCaptureLost(impl::bind_in(token));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IInputPointerSource>**)this;
            _winrt_abi_type->remove_PointerCaptureLost(impl::bind_in(token));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Input_IInputPointerSource<D>::PointerEntered(winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Input::InputPointerSource, winrt::Microsoft::UI::Input::PointerEventArgs> const& handler) const
    {
        winrt::event_token token{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IInputPointerSource>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IInputPointerSource, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IInputPointerSource>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->add_PointerEntered(*(void**)(&handler), put_abi(token)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IInputPointerSource>**)this;
            check_hresult(_winrt_abi_type->add_PointerEntered(*(void**)(&handler), put_abi(token)));
        }
        return token;
    }
    template <typename D> auto consume_Microsoft_UI_Input_IInputPointerSource<D>::PointerEntered(auto_revoke_t, winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Input::InputPointerSource, winrt::Microsoft::UI::Input::PointerEventArgs> const& handler) const
    {
        return impl::make_event_revoker<D, PointerEntered_revoker>(this, PointerEntered(handler));
    }
    template <typename D> auto consume_Microsoft_UI_Input_IInputPointerSource<D>::PointerEntered(winrt::event_token const& token) const noexcept
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IInputPointerSource>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IInputPointerSource, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IInputPointerSource>**)&_winrt_casted_result;
            _winrt_abi_type->remove_PointerEntered(impl::bind_in(token));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IInputPointerSource>**)this;
            _winrt_abi_type->remove_PointerEntered(impl::bind_in(token));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Input_IInputPointerSource<D>::PointerExited(winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Input::InputPointerSource, winrt::Microsoft::UI::Input::PointerEventArgs> const& handler) const
    {
        winrt::event_token token{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IInputPointerSource>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IInputPointerSource, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IInputPointerSource>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->add_PointerExited(*(void**)(&handler), put_abi(token)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IInputPointerSource>**)this;
            check_hresult(_winrt_abi_type->add_PointerExited(*(void**)(&handler), put_abi(token)));
        }
        return token;
    }
    template <typename D> auto consume_Microsoft_UI_Input_IInputPointerSource<D>::PointerExited(auto_revoke_t, winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Input::InputPointerSource, winrt::Microsoft::UI::Input::PointerEventArgs> const& handler) const
    {
        return impl::make_event_revoker<D, PointerExited_revoker>(this, PointerExited(handler));
    }
    template <typename D> auto consume_Microsoft_UI_Input_IInputPointerSource<D>::PointerExited(winrt::event_token const& token) const noexcept
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IInputPointerSource>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IInputPointerSource, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IInputPointerSource>**)&_winrt_casted_result;
            _winrt_abi_type->remove_PointerExited(impl::bind_in(token));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IInputPointerSource>**)this;
            _winrt_abi_type->remove_PointerExited(impl::bind_in(token));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Input_IInputPointerSource<D>::PointerMoved(winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Input::InputPointerSource, winrt::Microsoft::UI::Input::PointerEventArgs> const& handler) const
    {
        winrt::event_token token{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IInputPointerSource>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IInputPointerSource, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IInputPointerSource>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->add_PointerMoved(*(void**)(&handler), put_abi(token)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IInputPointerSource>**)this;
            check_hresult(_winrt_abi_type->add_PointerMoved(*(void**)(&handler), put_abi(token)));
        }
        return token;
    }
    template <typename D> auto consume_Microsoft_UI_Input_IInputPointerSource<D>::PointerMoved(auto_revoke_t, winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Input::InputPointerSource, winrt::Microsoft::UI::Input::PointerEventArgs> const& handler) const
    {
        return impl::make_event_revoker<D, PointerMoved_revoker>(this, PointerMoved(handler));
    }
    template <typename D> auto consume_Microsoft_UI_Input_IInputPointerSource<D>::PointerMoved(winrt::event_token const& token) const noexcept
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IInputPointerSource>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IInputPointerSource, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IInputPointerSource>**)&_winrt_casted_result;
            _winrt_abi_type->remove_PointerMoved(impl::bind_in(token));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IInputPointerSource>**)this;
            _winrt_abi_type->remove_PointerMoved(impl::bind_in(token));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Input_IInputPointerSource<D>::PointerPressed(winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Input::InputPointerSource, winrt::Microsoft::UI::Input::PointerEventArgs> const& handler) const
    {
        winrt::event_token token{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IInputPointerSource>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IInputPointerSource, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IInputPointerSource>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->add_PointerPressed(*(void**)(&handler), put_abi(token)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IInputPointerSource>**)this;
            check_hresult(_winrt_abi_type->add_PointerPressed(*(void**)(&handler), put_abi(token)));
        }
        return token;
    }
    template <typename D> auto consume_Microsoft_UI_Input_IInputPointerSource<D>::PointerPressed(auto_revoke_t, winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Input::InputPointerSource, winrt::Microsoft::UI::Input::PointerEventArgs> const& handler) const
    {
        return impl::make_event_revoker<D, PointerPressed_revoker>(this, PointerPressed(handler));
    }
    template <typename D> auto consume_Microsoft_UI_Input_IInputPointerSource<D>::PointerPressed(winrt::event_token const& token) const noexcept
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IInputPointerSource>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IInputPointerSource, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IInputPointerSource>**)&_winrt_casted_result;
            _winrt_abi_type->remove_PointerPressed(impl::bind_in(token));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IInputPointerSource>**)this;
            _winrt_abi_type->remove_PointerPressed(impl::bind_in(token));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Input_IInputPointerSource<D>::PointerReleased(winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Input::InputPointerSource, winrt::Microsoft::UI::Input::PointerEventArgs> const& handler) const
    {
        winrt::event_token token{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IInputPointerSource>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IInputPointerSource, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IInputPointerSource>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->add_PointerReleased(*(void**)(&handler), put_abi(token)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IInputPointerSource>**)this;
            check_hresult(_winrt_abi_type->add_PointerReleased(*(void**)(&handler), put_abi(token)));
        }
        return token;
    }
    template <typename D> auto consume_Microsoft_UI_Input_IInputPointerSource<D>::PointerReleased(auto_revoke_t, winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Input::InputPointerSource, winrt::Microsoft::UI::Input::PointerEventArgs> const& handler) const
    {
        return impl::make_event_revoker<D, PointerReleased_revoker>(this, PointerReleased(handler));
    }
    template <typename D> auto consume_Microsoft_UI_Input_IInputPointerSource<D>::PointerReleased(winrt::event_token const& token) const noexcept
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IInputPointerSource>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IInputPointerSource, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IInputPointerSource>**)&_winrt_casted_result;
            _winrt_abi_type->remove_PointerReleased(impl::bind_in(token));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IInputPointerSource>**)this;
            _winrt_abi_type->remove_PointerReleased(impl::bind_in(token));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Input_IInputPointerSource<D>::PointerRoutedAway(winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Input::InputPointerSource, winrt::Microsoft::UI::Input::PointerEventArgs> const& handler) const
    {
        winrt::event_token token{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IInputPointerSource>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IInputPointerSource, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IInputPointerSource>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->add_PointerRoutedAway(*(void**)(&handler), put_abi(token)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IInputPointerSource>**)this;
            check_hresult(_winrt_abi_type->add_PointerRoutedAway(*(void**)(&handler), put_abi(token)));
        }
        return token;
    }
    template <typename D> auto consume_Microsoft_UI_Input_IInputPointerSource<D>::PointerRoutedAway(auto_revoke_t, winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Input::InputPointerSource, winrt::Microsoft::UI::Input::PointerEventArgs> const& handler) const
    {
        return impl::make_event_revoker<D, PointerRoutedAway_revoker>(this, PointerRoutedAway(handler));
    }
    template <typename D> auto consume_Microsoft_UI_Input_IInputPointerSource<D>::PointerRoutedAway(winrt::event_token const& token) const noexcept
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IInputPointerSource>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IInputPointerSource, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IInputPointerSource>**)&_winrt_casted_result;
            _winrt_abi_type->remove_PointerRoutedAway(impl::bind_in(token));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IInputPointerSource>**)this;
            _winrt_abi_type->remove_PointerRoutedAway(impl::bind_in(token));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Input_IInputPointerSource<D>::PointerRoutedReleased(winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Input::InputPointerSource, winrt::Microsoft::UI::Input::PointerEventArgs> const& handler) const
    {
        winrt::event_token token{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IInputPointerSource>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IInputPointerSource, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IInputPointerSource>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->add_PointerRoutedReleased(*(void**)(&handler), put_abi(token)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IInputPointerSource>**)this;
            check_hresult(_winrt_abi_type->add_PointerRoutedReleased(*(void**)(&handler), put_abi(token)));
        }
        return token;
    }
    template <typename D> auto consume_Microsoft_UI_Input_IInputPointerSource<D>::PointerRoutedReleased(auto_revoke_t, winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Input::InputPointerSource, winrt::Microsoft::UI::Input::PointerEventArgs> const& handler) const
    {
        return impl::make_event_revoker<D, PointerRoutedReleased_revoker>(this, PointerRoutedReleased(handler));
    }
    template <typename D> auto consume_Microsoft_UI_Input_IInputPointerSource<D>::PointerRoutedReleased(winrt::event_token const& token) const noexcept
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IInputPointerSource>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IInputPointerSource, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IInputPointerSource>**)&_winrt_casted_result;
            _winrt_abi_type->remove_PointerRoutedReleased(impl::bind_in(token));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IInputPointerSource>**)this;
            _winrt_abi_type->remove_PointerRoutedReleased(impl::bind_in(token));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Input_IInputPointerSource<D>::PointerRoutedTo(winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Input::InputPointerSource, winrt::Microsoft::UI::Input::PointerEventArgs> const& handler) const
    {
        winrt::event_token token{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IInputPointerSource>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IInputPointerSource, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IInputPointerSource>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->add_PointerRoutedTo(*(void**)(&handler), put_abi(token)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IInputPointerSource>**)this;
            check_hresult(_winrt_abi_type->add_PointerRoutedTo(*(void**)(&handler), put_abi(token)));
        }
        return token;
    }
    template <typename D> auto consume_Microsoft_UI_Input_IInputPointerSource<D>::PointerRoutedTo(auto_revoke_t, winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Input::InputPointerSource, winrt::Microsoft::UI::Input::PointerEventArgs> const& handler) const
    {
        return impl::make_event_revoker<D, PointerRoutedTo_revoker>(this, PointerRoutedTo(handler));
    }
    template <typename D> auto consume_Microsoft_UI_Input_IInputPointerSource<D>::PointerRoutedTo(winrt::event_token const& token) const noexcept
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IInputPointerSource>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IInputPointerSource, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IInputPointerSource>**)&_winrt_casted_result;
            _winrt_abi_type->remove_PointerRoutedTo(impl::bind_in(token));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IInputPointerSource>**)this;
            _winrt_abi_type->remove_PointerRoutedTo(impl::bind_in(token));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Input_IInputPointerSource<D>::PointerWheelChanged(winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Input::InputPointerSource, winrt::Microsoft::UI::Input::PointerEventArgs> const& handler) const
    {
        winrt::event_token token{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IInputPointerSource>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IInputPointerSource, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IInputPointerSource>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->add_PointerWheelChanged(*(void**)(&handler), put_abi(token)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IInputPointerSource>**)this;
            check_hresult(_winrt_abi_type->add_PointerWheelChanged(*(void**)(&handler), put_abi(token)));
        }
        return token;
    }
    template <typename D> auto consume_Microsoft_UI_Input_IInputPointerSource<D>::PointerWheelChanged(auto_revoke_t, winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Input::InputPointerSource, winrt::Microsoft::UI::Input::PointerEventArgs> const& handler) const
    {
        return impl::make_event_revoker<D, PointerWheelChanged_revoker>(this, PointerWheelChanged(handler));
    }
    template <typename D> auto consume_Microsoft_UI_Input_IInputPointerSource<D>::PointerWheelChanged(winrt::event_token const& token) const noexcept
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IInputPointerSource>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IInputPointerSource, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IInputPointerSource>**)&_winrt_casted_result;
            _winrt_abi_type->remove_PointerWheelChanged(impl::bind_in(token));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IInputPointerSource>**)this;
            _winrt_abi_type->remove_PointerWheelChanged(impl::bind_in(token));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Input_IInputPointerSourceStatics<D>::GetForIsland(winrt::Microsoft::UI::Content::ContentIsland const& island) const
    {
        void* result{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IInputPointerSourceStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IInputPointerSourceStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IInputPointerSourceStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->GetForIsland(*(void**)(&island), &result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IInputPointerSourceStatics>**)this;
            check_hresult(_winrt_abi_type->GetForIsland(*(void**)(&island), &result));
        }
        return winrt::Microsoft::UI::Input::InputPointerSource{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Input_IInputPreTranslateKeyboardSourceStatics<D>::GetForIsland(winrt::Microsoft::UI::Content::ContentIsland const& island) const
    {
        void* result{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IInputPreTranslateKeyboardSourceStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IInputPreTranslateKeyboardSourceStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IInputPreTranslateKeyboardSourceStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->GetForIsland(*(void**)(&island), &result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IInputPreTranslateKeyboardSourceStatics>**)this;
            check_hresult(_winrt_abi_type->GetForIsland(*(void**)(&island), &result));
        }
        return winrt::Microsoft::UI::Input::InputPreTranslateKeyboardSource{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Input_IInputSystemCursor<D>::CursorShape() const
    {
        winrt::Microsoft::UI::Input::InputSystemCursorShape value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IInputSystemCursor>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IInputSystemCursor, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IInputSystemCursor>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_CursorShape(reinterpret_cast<int32_t*>(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IInputSystemCursor>**)this;
            check_hresult(_winrt_abi_type->get_CursorShape(reinterpret_cast<int32_t*>(&value)));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Input_IInputSystemCursorStatics<D>::Create(winrt::Microsoft::UI::Input::InputSystemCursorShape const& type) const
    {
        void* result{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IInputSystemCursorStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IInputSystemCursorStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IInputSystemCursorStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->Create(static_cast<int32_t>(type), &result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IInputSystemCursorStatics>**)this;
            check_hresult(_winrt_abi_type->Create(static_cast<int32_t>(type), &result));
        }
        return winrt::Microsoft::UI::Input::InputSystemCursor{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Input_IKeyEventArgs<D>::Handled() const
    {
        bool value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IKeyEventArgs>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IKeyEventArgs, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IKeyEventArgs>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Handled(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IKeyEventArgs>**)this;
            check_hresult(_winrt_abi_type->get_Handled(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Input_IKeyEventArgs<D>::Handled(bool value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IKeyEventArgs>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IKeyEventArgs, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IKeyEventArgs>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_Handled(value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IKeyEventArgs>**)this;
            check_hresult(_winrt_abi_type->put_Handled(value));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Input_IKeyEventArgs<D>::KeyStatus() const
    {
        winrt::Microsoft::UI::Input::PhysicalKeyStatus value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IKeyEventArgs>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IKeyEventArgs, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IKeyEventArgs>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_KeyStatus(put_abi(value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IKeyEventArgs>**)this;
            check_hresult(_winrt_abi_type->get_KeyStatus(put_abi(value)));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Input_IKeyEventArgs<D>::Timestamp() const
    {
        uint64_t value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IKeyEventArgs>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IKeyEventArgs, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IKeyEventArgs>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Timestamp(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IKeyEventArgs>**)this;
            check_hresult(_winrt_abi_type->get_Timestamp(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Input_IKeyEventArgs<D>::VirtualKey() const
    {
        winrt::Windows::System::VirtualKey value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IKeyEventArgs>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IKeyEventArgs, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IKeyEventArgs>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_VirtualKey(reinterpret_cast<int32_t*>(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IKeyEventArgs>**)this;
            check_hresult(_winrt_abi_type->get_VirtualKey(reinterpret_cast<int32_t*>(&value)));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Input_IManipulationCompletedEventArgs<D>::Cumulative() const
    {
        winrt::Microsoft::UI::Input::ManipulationDelta value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IManipulationCompletedEventArgs>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IManipulationCompletedEventArgs, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IManipulationCompletedEventArgs>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Cumulative(put_abi(value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IManipulationCompletedEventArgs>**)this;
            check_hresult(_winrt_abi_type->get_Cumulative(put_abi(value)));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Input_IManipulationCompletedEventArgs<D>::PointerDeviceType() const
    {
        winrt::Microsoft::UI::Input::PointerDeviceType value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IManipulationCompletedEventArgs>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IManipulationCompletedEventArgs, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IManipulationCompletedEventArgs>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_PointerDeviceType(reinterpret_cast<int32_t*>(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IManipulationCompletedEventArgs>**)this;
            check_hresult(_winrt_abi_type->get_PointerDeviceType(reinterpret_cast<int32_t*>(&value)));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Input_IManipulationCompletedEventArgs<D>::Position() const
    {
        winrt::Windows::Foundation::Point value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IManipulationCompletedEventArgs>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IManipulationCompletedEventArgs, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IManipulationCompletedEventArgs>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Position(put_abi(value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IManipulationCompletedEventArgs>**)this;
            check_hresult(_winrt_abi_type->get_Position(put_abi(value)));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Input_IManipulationCompletedEventArgs<D>::Velocities() const
    {
        winrt::Microsoft::UI::Input::ManipulationVelocities value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IManipulationCompletedEventArgs>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IManipulationCompletedEventArgs, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IManipulationCompletedEventArgs>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Velocities(put_abi(value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IManipulationCompletedEventArgs>**)this;
            check_hresult(_winrt_abi_type->get_Velocities(put_abi(value)));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Input_IManipulationInertiaStartingEventArgs<D>::Cumulative() const
    {
        winrt::Microsoft::UI::Input::ManipulationDelta value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IManipulationInertiaStartingEventArgs>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IManipulationInertiaStartingEventArgs, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IManipulationInertiaStartingEventArgs>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Cumulative(put_abi(value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IManipulationInertiaStartingEventArgs>**)this;
            check_hresult(_winrt_abi_type->get_Cumulative(put_abi(value)));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Input_IManipulationInertiaStartingEventArgs<D>::Delta() const
    {
        winrt::Microsoft::UI::Input::ManipulationDelta value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IManipulationInertiaStartingEventArgs>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IManipulationInertiaStartingEventArgs, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IManipulationInertiaStartingEventArgs>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Delta(put_abi(value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IManipulationInertiaStartingEventArgs>**)this;
            check_hresult(_winrt_abi_type->get_Delta(put_abi(value)));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Input_IManipulationInertiaStartingEventArgs<D>::PointerDeviceType() const
    {
        winrt::Microsoft::UI::Input::PointerDeviceType value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IManipulationInertiaStartingEventArgs>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IManipulationInertiaStartingEventArgs, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IManipulationInertiaStartingEventArgs>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_PointerDeviceType(reinterpret_cast<int32_t*>(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IManipulationInertiaStartingEventArgs>**)this;
            check_hresult(_winrt_abi_type->get_PointerDeviceType(reinterpret_cast<int32_t*>(&value)));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Input_IManipulationInertiaStartingEventArgs<D>::Position() const
    {
        winrt::Windows::Foundation::Point value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IManipulationInertiaStartingEventArgs>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IManipulationInertiaStartingEventArgs, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IManipulationInertiaStartingEventArgs>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Position(put_abi(value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IManipulationInertiaStartingEventArgs>**)this;
            check_hresult(_winrt_abi_type->get_Position(put_abi(value)));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Input_IManipulationInertiaStartingEventArgs<D>::Velocities() const
    {
        winrt::Microsoft::UI::Input::ManipulationVelocities value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IManipulationInertiaStartingEventArgs>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IManipulationInertiaStartingEventArgs, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IManipulationInertiaStartingEventArgs>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Velocities(put_abi(value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IManipulationInertiaStartingEventArgs>**)this;
            check_hresult(_winrt_abi_type->get_Velocities(put_abi(value)));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Input_IManipulationStartedEventArgs<D>::Cumulative() const
    {
        winrt::Microsoft::UI::Input::ManipulationDelta value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IManipulationStartedEventArgs>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IManipulationStartedEventArgs, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IManipulationStartedEventArgs>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Cumulative(put_abi(value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IManipulationStartedEventArgs>**)this;
            check_hresult(_winrt_abi_type->get_Cumulative(put_abi(value)));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Input_IManipulationStartedEventArgs<D>::PointerDeviceType() const
    {
        winrt::Microsoft::UI::Input::PointerDeviceType value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IManipulationStartedEventArgs>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IManipulationStartedEventArgs, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IManipulationStartedEventArgs>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_PointerDeviceType(reinterpret_cast<int32_t*>(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IManipulationStartedEventArgs>**)this;
            check_hresult(_winrt_abi_type->get_PointerDeviceType(reinterpret_cast<int32_t*>(&value)));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Input_IManipulationStartedEventArgs<D>::Position() const
    {
        winrt::Windows::Foundation::Point value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IManipulationStartedEventArgs>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IManipulationStartedEventArgs, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IManipulationStartedEventArgs>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Position(put_abi(value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IManipulationStartedEventArgs>**)this;
            check_hresult(_winrt_abi_type->get_Position(put_abi(value)));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Input_IManipulationUpdatedEventArgs<D>::Cumulative() const
    {
        winrt::Microsoft::UI::Input::ManipulationDelta value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IManipulationUpdatedEventArgs>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IManipulationUpdatedEventArgs, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IManipulationUpdatedEventArgs>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Cumulative(put_abi(value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IManipulationUpdatedEventArgs>**)this;
            check_hresult(_winrt_abi_type->get_Cumulative(put_abi(value)));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Input_IManipulationUpdatedEventArgs<D>::Delta() const
    {
        winrt::Microsoft::UI::Input::ManipulationDelta value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IManipulationUpdatedEventArgs>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IManipulationUpdatedEventArgs, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IManipulationUpdatedEventArgs>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Delta(put_abi(value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IManipulationUpdatedEventArgs>**)this;
            check_hresult(_winrt_abi_type->get_Delta(put_abi(value)));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Input_IManipulationUpdatedEventArgs<D>::PointerDeviceType() const
    {
        winrt::Microsoft::UI::Input::PointerDeviceType value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IManipulationUpdatedEventArgs>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IManipulationUpdatedEventArgs, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IManipulationUpdatedEventArgs>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_PointerDeviceType(reinterpret_cast<int32_t*>(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IManipulationUpdatedEventArgs>**)this;
            check_hresult(_winrt_abi_type->get_PointerDeviceType(reinterpret_cast<int32_t*>(&value)));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Input_IManipulationUpdatedEventArgs<D>::Position() const
    {
        winrt::Windows::Foundation::Point value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IManipulationUpdatedEventArgs>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IManipulationUpdatedEventArgs, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IManipulationUpdatedEventArgs>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Position(put_abi(value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IManipulationUpdatedEventArgs>**)this;
            check_hresult(_winrt_abi_type->get_Position(put_abi(value)));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Input_IManipulationUpdatedEventArgs<D>::Velocities() const
    {
        winrt::Microsoft::UI::Input::ManipulationVelocities value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IManipulationUpdatedEventArgs>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IManipulationUpdatedEventArgs, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IManipulationUpdatedEventArgs>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Velocities(put_abi(value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IManipulationUpdatedEventArgs>**)this;
            check_hresult(_winrt_abi_type->get_Velocities(put_abi(value)));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Input_IMouseWheelParameters<D>::CharTranslation() const
    {
        winrt::Windows::Foundation::Point value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IMouseWheelParameters>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IMouseWheelParameters, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IMouseWheelParameters>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_CharTranslation(put_abi(value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IMouseWheelParameters>**)this;
            check_hresult(_winrt_abi_type->get_CharTranslation(put_abi(value)));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Input_IMouseWheelParameters<D>::CharTranslation(winrt::Windows::Foundation::Point const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IMouseWheelParameters>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IMouseWheelParameters, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IMouseWheelParameters>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_CharTranslation(impl::bind_in(value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IMouseWheelParameters>**)this;
            check_hresult(_winrt_abi_type->put_CharTranslation(impl::bind_in(value)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Input_IMouseWheelParameters<D>::DeltaScale() const
    {
        float value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IMouseWheelParameters>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IMouseWheelParameters, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IMouseWheelParameters>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_DeltaScale(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IMouseWheelParameters>**)this;
            check_hresult(_winrt_abi_type->get_DeltaScale(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Input_IMouseWheelParameters<D>::DeltaScale(float value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IMouseWheelParameters>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IMouseWheelParameters, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IMouseWheelParameters>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_DeltaScale(value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IMouseWheelParameters>**)this;
            check_hresult(_winrt_abi_type->put_DeltaScale(value));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Input_IMouseWheelParameters<D>::DeltaRotationAngle() const
    {
        float value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IMouseWheelParameters>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IMouseWheelParameters, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IMouseWheelParameters>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_DeltaRotationAngle(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IMouseWheelParameters>**)this;
            check_hresult(_winrt_abi_type->get_DeltaRotationAngle(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Input_IMouseWheelParameters<D>::DeltaRotationAngle(float value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IMouseWheelParameters>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IMouseWheelParameters, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IMouseWheelParameters>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_DeltaRotationAngle(value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IMouseWheelParameters>**)this;
            check_hresult(_winrt_abi_type->put_DeltaRotationAngle(value));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Input_IMouseWheelParameters<D>::PageTranslation() const
    {
        winrt::Windows::Foundation::Point value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IMouseWheelParameters>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IMouseWheelParameters, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IMouseWheelParameters>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_PageTranslation(put_abi(value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IMouseWheelParameters>**)this;
            check_hresult(_winrt_abi_type->get_PageTranslation(put_abi(value)));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Input_IMouseWheelParameters<D>::PageTranslation(winrt::Windows::Foundation::Point const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IMouseWheelParameters>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IMouseWheelParameters, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IMouseWheelParameters>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_PageTranslation(impl::bind_in(value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IMouseWheelParameters>**)this;
            check_hresult(_winrt_abi_type->put_PageTranslation(impl::bind_in(value)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Input_INonClientCaptionTappedEventArgs<D>::Point() const
    {
        winrt::Windows::Foundation::Point value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::INonClientCaptionTappedEventArgs>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::INonClientCaptionTappedEventArgs, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::INonClientCaptionTappedEventArgs>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Point(put_abi(value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::INonClientCaptionTappedEventArgs>**)this;
            check_hresult(_winrt_abi_type->get_Point(put_abi(value)));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Input_INonClientCaptionTappedEventArgs<D>::PointerDeviceType() const
    {
        winrt::Microsoft::UI::Input::PointerDeviceType value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::INonClientCaptionTappedEventArgs>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::INonClientCaptionTappedEventArgs, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::INonClientCaptionTappedEventArgs>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_PointerDeviceType(reinterpret_cast<int32_t*>(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::INonClientCaptionTappedEventArgs>**)this;
            check_hresult(_winrt_abi_type->get_PointerDeviceType(reinterpret_cast<int32_t*>(&value)));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Input_INonClientPointerEventArgs<D>::Point() const
    {
        winrt::Windows::Foundation::Point value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::INonClientPointerEventArgs>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::INonClientPointerEventArgs, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::INonClientPointerEventArgs>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Point(put_abi(value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::INonClientPointerEventArgs>**)this;
            check_hresult(_winrt_abi_type->get_Point(put_abi(value)));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Input_INonClientPointerEventArgs<D>::PointerDeviceType() const
    {
        winrt::Microsoft::UI::Input::PointerDeviceType value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::INonClientPointerEventArgs>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::INonClientPointerEventArgs, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::INonClientPointerEventArgs>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_PointerDeviceType(reinterpret_cast<int32_t*>(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::INonClientPointerEventArgs>**)this;
            check_hresult(_winrt_abi_type->get_PointerDeviceType(reinterpret_cast<int32_t*>(&value)));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Input_INonClientPointerEventArgs<D>::RegionKind() const
    {
        winrt::Microsoft::UI::Input::NonClientRegionKind value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::INonClientPointerEventArgs>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::INonClientPointerEventArgs, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::INonClientPointerEventArgs>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_RegionKind(reinterpret_cast<int32_t*>(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::INonClientPointerEventArgs>**)this;
            check_hresult(_winrt_abi_type->get_RegionKind(reinterpret_cast<int32_t*>(&value)));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Input_INonClientPointerEventArgs<D>::IsPointInRegion() const
    {
        bool value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::INonClientPointerEventArgs>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::INonClientPointerEventArgs, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::INonClientPointerEventArgs>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_IsPointInRegion(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::INonClientPointerEventArgs>**)this;
            check_hresult(_winrt_abi_type->get_IsPointInRegion(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Input_INonClientRegionsChangedEventArgs<D>::ChangedRegions() const
    {
        uint32_t value_impl_size{};
        int32_t* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::INonClientRegionsChangedEventArgs>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::INonClientRegionsChangedEventArgs, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::INonClientRegionsChangedEventArgs>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_ChangedRegions(&value_impl_size, &value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::INonClientRegionsChangedEventArgs>**)this;
            check_hresult(_winrt_abi_type->get_ChangedRegions(&value_impl_size, &value));
        }
        return com_array<winrt::Microsoft::UI::Input::NonClientRegionKind>{ value, value_impl_size, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Input_IPointerEventArgs<D>::CurrentPoint() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IPointerEventArgs>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IPointerEventArgs, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IPointerEventArgs>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_CurrentPoint(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IPointerEventArgs>**)this;
            check_hresult(_winrt_abi_type->get_CurrentPoint(&value));
        }
        return winrt::Microsoft::UI::Input::PointerPoint{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Input_IPointerEventArgs<D>::Handled() const
    {
        bool value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IPointerEventArgs>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IPointerEventArgs, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IPointerEventArgs>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Handled(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IPointerEventArgs>**)this;
            check_hresult(_winrt_abi_type->get_Handled(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Input_IPointerEventArgs<D>::Handled(bool value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IPointerEventArgs>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IPointerEventArgs, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IPointerEventArgs>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_Handled(value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IPointerEventArgs>**)this;
            check_hresult(_winrt_abi_type->put_Handled(value));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Input_IPointerEventArgs<D>::KeyModifiers() const
    {
        winrt::Windows::System::VirtualKeyModifiers value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IPointerEventArgs>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IPointerEventArgs, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IPointerEventArgs>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_KeyModifiers(reinterpret_cast<uint32_t*>(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IPointerEventArgs>**)this;
            check_hresult(_winrt_abi_type->get_KeyModifiers(reinterpret_cast<uint32_t*>(&value)));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Input_IPointerEventArgs<D>::GetIntermediatePoints() const
    {
        void* result{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IPointerEventArgs>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IPointerEventArgs, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IPointerEventArgs>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->GetIntermediatePoints(&result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IPointerEventArgs>**)this;
            check_hresult(_winrt_abi_type->GetIntermediatePoints(&result));
        }
        return winrt::Windows::Foundation::Collections::IVector<winrt::Microsoft::UI::Input::PointerPoint>{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Input_IPointerEventArgs<D>::GetIntermediateTransformedPoints(winrt::Microsoft::UI::Input::IPointerPointTransform const& transform) const
    {
        void* result{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IPointerEventArgs>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IPointerEventArgs, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IPointerEventArgs>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->GetIntermediateTransformedPoints(*(void**)(&transform), &result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IPointerEventArgs>**)this;
            check_hresult(_winrt_abi_type->GetIntermediateTransformedPoints(*(void**)(&transform), &result));
        }
        return winrt::Windows::Foundation::Collections::IVector<winrt::Microsoft::UI::Input::PointerPoint>{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Input_IPointerPoint<D>::FrameId() const
    {
        uint32_t value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IPointerPoint>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IPointerPoint, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IPointerPoint>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_FrameId(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IPointerPoint>**)this;
            check_hresult(_winrt_abi_type->get_FrameId(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Input_IPointerPoint<D>::IsInContact() const
    {
        bool value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IPointerPoint>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IPointerPoint, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IPointerPoint>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_IsInContact(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IPointerPoint>**)this;
            check_hresult(_winrt_abi_type->get_IsInContact(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Input_IPointerPoint<D>::PointerDeviceType() const
    {
        winrt::Microsoft::UI::Input::PointerDeviceType value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IPointerPoint>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IPointerPoint, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IPointerPoint>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_PointerDeviceType(reinterpret_cast<int32_t*>(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IPointerPoint>**)this;
            check_hresult(_winrt_abi_type->get_PointerDeviceType(reinterpret_cast<int32_t*>(&value)));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Input_IPointerPoint<D>::PointerId() const
    {
        uint32_t value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IPointerPoint>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IPointerPoint, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IPointerPoint>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_PointerId(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IPointerPoint>**)this;
            check_hresult(_winrt_abi_type->get_PointerId(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Input_IPointerPoint<D>::Position() const
    {
        winrt::Windows::Foundation::Point value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IPointerPoint>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IPointerPoint, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IPointerPoint>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Position(put_abi(value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IPointerPoint>**)this;
            check_hresult(_winrt_abi_type->get_Position(put_abi(value)));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Input_IPointerPoint<D>::Properties() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IPointerPoint>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IPointerPoint, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IPointerPoint>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Properties(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IPointerPoint>**)this;
            check_hresult(_winrt_abi_type->get_Properties(&value));
        }
        return winrt::Microsoft::UI::Input::PointerPointProperties{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Input_IPointerPoint<D>::Timestamp() const
    {
        uint64_t value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IPointerPoint>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IPointerPoint, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IPointerPoint>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Timestamp(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IPointerPoint>**)this;
            check_hresult(_winrt_abi_type->get_Timestamp(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Input_IPointerPoint<D>::GetTransformedPoint(winrt::Microsoft::UI::Input::IPointerPointTransform const& transform) const
    {
        void* result{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IPointerPoint>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IPointerPoint, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IPointerPoint>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->GetTransformedPoint(*(void**)(&transform), &result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IPointerPoint>**)this;
            check_hresult(_winrt_abi_type->GetTransformedPoint(*(void**)(&transform), &result));
        }
        return winrt::Microsoft::UI::Input::PointerPoint{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Input_IPointerPointProperties<D>::ContactRect() const
    {
        winrt::Windows::Foundation::Rect value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IPointerPointProperties>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IPointerPointProperties, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IPointerPointProperties>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_ContactRect(put_abi(value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IPointerPointProperties>**)this;
            check_hresult(_winrt_abi_type->get_ContactRect(put_abi(value)));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Input_IPointerPointProperties<D>::IsBarrelButtonPressed() const
    {
        bool value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IPointerPointProperties>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IPointerPointProperties, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IPointerPointProperties>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_IsBarrelButtonPressed(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IPointerPointProperties>**)this;
            check_hresult(_winrt_abi_type->get_IsBarrelButtonPressed(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Input_IPointerPointProperties<D>::IsCanceled() const
    {
        bool value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IPointerPointProperties>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IPointerPointProperties, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IPointerPointProperties>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_IsCanceled(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IPointerPointProperties>**)this;
            check_hresult(_winrt_abi_type->get_IsCanceled(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Input_IPointerPointProperties<D>::IsEraser() const
    {
        bool value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IPointerPointProperties>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IPointerPointProperties, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IPointerPointProperties>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_IsEraser(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IPointerPointProperties>**)this;
            check_hresult(_winrt_abi_type->get_IsEraser(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Input_IPointerPointProperties<D>::IsHorizontalMouseWheel() const
    {
        bool value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IPointerPointProperties>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IPointerPointProperties, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IPointerPointProperties>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_IsHorizontalMouseWheel(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IPointerPointProperties>**)this;
            check_hresult(_winrt_abi_type->get_IsHorizontalMouseWheel(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Input_IPointerPointProperties<D>::IsInRange() const
    {
        bool value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IPointerPointProperties>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IPointerPointProperties, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IPointerPointProperties>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_IsInRange(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IPointerPointProperties>**)this;
            check_hresult(_winrt_abi_type->get_IsInRange(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Input_IPointerPointProperties<D>::IsInverted() const
    {
        bool value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IPointerPointProperties>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IPointerPointProperties, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IPointerPointProperties>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_IsInverted(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IPointerPointProperties>**)this;
            check_hresult(_winrt_abi_type->get_IsInverted(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Input_IPointerPointProperties<D>::IsLeftButtonPressed() const
    {
        bool value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IPointerPointProperties>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IPointerPointProperties, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IPointerPointProperties>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_IsLeftButtonPressed(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IPointerPointProperties>**)this;
            check_hresult(_winrt_abi_type->get_IsLeftButtonPressed(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Input_IPointerPointProperties<D>::IsMiddleButtonPressed() const
    {
        bool value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IPointerPointProperties>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IPointerPointProperties, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IPointerPointProperties>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_IsMiddleButtonPressed(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IPointerPointProperties>**)this;
            check_hresult(_winrt_abi_type->get_IsMiddleButtonPressed(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Input_IPointerPointProperties<D>::IsPrimary() const
    {
        bool value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IPointerPointProperties>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IPointerPointProperties, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IPointerPointProperties>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_IsPrimary(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IPointerPointProperties>**)this;
            check_hresult(_winrt_abi_type->get_IsPrimary(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Input_IPointerPointProperties<D>::IsRightButtonPressed() const
    {
        bool value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IPointerPointProperties>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IPointerPointProperties, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IPointerPointProperties>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_IsRightButtonPressed(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IPointerPointProperties>**)this;
            check_hresult(_winrt_abi_type->get_IsRightButtonPressed(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Input_IPointerPointProperties<D>::IsXButton1Pressed() const
    {
        bool value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IPointerPointProperties>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IPointerPointProperties, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IPointerPointProperties>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_IsXButton1Pressed(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IPointerPointProperties>**)this;
            check_hresult(_winrt_abi_type->get_IsXButton1Pressed(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Input_IPointerPointProperties<D>::IsXButton2Pressed() const
    {
        bool value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IPointerPointProperties>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IPointerPointProperties, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IPointerPointProperties>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_IsXButton2Pressed(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IPointerPointProperties>**)this;
            check_hresult(_winrt_abi_type->get_IsXButton2Pressed(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Input_IPointerPointProperties<D>::MouseWheelDelta() const
    {
        int32_t value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IPointerPointProperties>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IPointerPointProperties, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IPointerPointProperties>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_MouseWheelDelta(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IPointerPointProperties>**)this;
            check_hresult(_winrt_abi_type->get_MouseWheelDelta(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Input_IPointerPointProperties<D>::Orientation() const
    {
        float value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IPointerPointProperties>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IPointerPointProperties, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IPointerPointProperties>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Orientation(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IPointerPointProperties>**)this;
            check_hresult(_winrt_abi_type->get_Orientation(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Input_IPointerPointProperties<D>::PointerUpdateKind() const
    {
        winrt::Microsoft::UI::Input::PointerUpdateKind value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IPointerPointProperties>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IPointerPointProperties, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IPointerPointProperties>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_PointerUpdateKind(reinterpret_cast<int32_t*>(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IPointerPointProperties>**)this;
            check_hresult(_winrt_abi_type->get_PointerUpdateKind(reinterpret_cast<int32_t*>(&value)));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Input_IPointerPointProperties<D>::Pressure() const
    {
        float value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IPointerPointProperties>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IPointerPointProperties, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IPointerPointProperties>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Pressure(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IPointerPointProperties>**)this;
            check_hresult(_winrt_abi_type->get_Pressure(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Input_IPointerPointProperties<D>::TouchConfidence() const
    {
        bool value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IPointerPointProperties>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IPointerPointProperties, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IPointerPointProperties>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_TouchConfidence(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IPointerPointProperties>**)this;
            check_hresult(_winrt_abi_type->get_TouchConfidence(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Input_IPointerPointProperties<D>::Twist() const
    {
        float value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IPointerPointProperties>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IPointerPointProperties, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IPointerPointProperties>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Twist(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IPointerPointProperties>**)this;
            check_hresult(_winrt_abi_type->get_Twist(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Input_IPointerPointProperties<D>::XTilt() const
    {
        float value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IPointerPointProperties>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IPointerPointProperties, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IPointerPointProperties>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_XTilt(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IPointerPointProperties>**)this;
            check_hresult(_winrt_abi_type->get_XTilt(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Input_IPointerPointProperties<D>::YTilt() const
    {
        float value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IPointerPointProperties>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IPointerPointProperties, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IPointerPointProperties>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_YTilt(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IPointerPointProperties>**)this;
            check_hresult(_winrt_abi_type->get_YTilt(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Input_IPointerPointTransform<D>::Inverse() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IPointerPointTransform>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IPointerPointTransform, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IPointerPointTransform>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Inverse(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IPointerPointTransform>**)this;
            check_hresult(_winrt_abi_type->get_Inverse(&value));
        }
        return winrt::Microsoft::UI::Input::IPointerPointTransform{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Input_IPointerPointTransform<D>::TryTransform(winrt::Windows::Foundation::Point const& inPoint, winrt::Windows::Foundation::Point& outPoint) const
    {
        bool result{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IPointerPointTransform>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IPointerPointTransform, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IPointerPointTransform>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->TryTransform(impl::bind_in(inPoint), impl::bind_out(outPoint), &result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IPointerPointTransform>**)this;
            check_hresult(_winrt_abi_type->TryTransform(impl::bind_in(inPoint), impl::bind_out(outPoint), &result));
        }
        return result;
    }
    template <typename D> auto consume_Microsoft_UI_Input_IPointerPointTransform<D>::TryTransformBounds(winrt::Windows::Foundation::Rect const& inRect, winrt::Windows::Foundation::Rect& outRect) const
    {
        bool result{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IPointerPointTransform>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IPointerPointTransform, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IPointerPointTransform>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->TryTransformBounds(impl::bind_in(inRect), impl::bind_out(outRect), &result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IPointerPointTransform>**)this;
            check_hresult(_winrt_abi_type->TryTransformBounds(impl::bind_in(inRect), impl::bind_out(outRect), &result));
        }
        return result;
    }
    template <typename D> auto consume_Microsoft_UI_Input_IPointerPredictor<D>::PredictionTime() const
    {
        winrt::Windows::Foundation::TimeSpan value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IPointerPredictor>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IPointerPredictor, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IPointerPredictor>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_PredictionTime(put_abi(value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IPointerPredictor>**)this;
            check_hresult(_winrt_abi_type->get_PredictionTime(put_abi(value)));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Input_IPointerPredictor<D>::PredictionTime(winrt::Windows::Foundation::TimeSpan const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IPointerPredictor>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IPointerPredictor, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IPointerPredictor>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_PredictionTime(impl::bind_in(value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IPointerPredictor>**)this;
            check_hresult(_winrt_abi_type->put_PredictionTime(impl::bind_in(value)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Input_IPointerPredictor<D>::GetPredictedPoints(winrt::Microsoft::UI::Input::PointerPoint const& point) const
    {
        uint32_t result_impl_size{};
        void** result{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IPointerPredictor>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IPointerPredictor, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IPointerPredictor>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->GetPredictedPoints(*(void**)(&point), &result_impl_size, &result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IPointerPredictor>**)this;
            check_hresult(_winrt_abi_type->GetPredictedPoints(*(void**)(&point), &result_impl_size, &result));
        }
        return com_array<winrt::Microsoft::UI::Input::PointerPoint>{ result, result_impl_size, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Input_IPointerPredictorStatics<D>::CreateForInputPointerSource(winrt::Microsoft::UI::Input::InputPointerSource const& inputPointerSource) const
    {
        void* result{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IPointerPredictorStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IPointerPredictorStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IPointerPredictorStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->CreateForInputPointerSource(*(void**)(&inputPointerSource), &result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IPointerPredictorStatics>**)this;
            check_hresult(_winrt_abi_type->CreateForInputPointerSource(*(void**)(&inputPointerSource), &result));
        }
        return winrt::Microsoft::UI::Input::PointerPredictor{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Input_IRightTappedEventArgs<D>::PointerDeviceType() const
    {
        winrt::Microsoft::UI::Input::PointerDeviceType value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IRightTappedEventArgs>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IRightTappedEventArgs, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IRightTappedEventArgs>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_PointerDeviceType(reinterpret_cast<int32_t*>(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IRightTappedEventArgs>**)this;
            check_hresult(_winrt_abi_type->get_PointerDeviceType(reinterpret_cast<int32_t*>(&value)));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Input_IRightTappedEventArgs<D>::Position() const
    {
        winrt::Windows::Foundation::Point value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IRightTappedEventArgs>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IRightTappedEventArgs, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IRightTappedEventArgs>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Position(put_abi(value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IRightTappedEventArgs>**)this;
            check_hresult(_winrt_abi_type->get_Position(put_abi(value)));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Input_ITappedEventArgs<D>::PointerDeviceType() const
    {
        winrt::Microsoft::UI::Input::PointerDeviceType value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::ITappedEventArgs>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::ITappedEventArgs, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::ITappedEventArgs>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_PointerDeviceType(reinterpret_cast<int32_t*>(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::ITappedEventArgs>**)this;
            check_hresult(_winrt_abi_type->get_PointerDeviceType(reinterpret_cast<int32_t*>(&value)));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Input_ITappedEventArgs<D>::Position() const
    {
        winrt::Windows::Foundation::Point value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::ITappedEventArgs>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::ITappedEventArgs, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::ITappedEventArgs>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Position(put_abi(value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::ITappedEventArgs>**)this;
            check_hresult(_winrt_abi_type->get_Position(put_abi(value)));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Input_ITappedEventArgs<D>::TapCount() const
    {
        uint32_t value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::ITappedEventArgs>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::ITappedEventArgs, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::ITappedEventArgs>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_TapCount(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::ITappedEventArgs>**)this;
            check_hresult(_winrt_abi_type->get_TapCount(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Input_IWindowRectChangedEventArgs<D>::PointerScreenPoint() const
    {
        winrt::Windows::Graphics::PointInt32 value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IWindowRectChangedEventArgs>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IWindowRectChangedEventArgs, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IWindowRectChangedEventArgs>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_PointerScreenPoint(put_abi(value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IWindowRectChangedEventArgs>**)this;
            check_hresult(_winrt_abi_type->get_PointerScreenPoint(put_abi(value)));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Input_IWindowRectChangedEventArgs<D>::MoveSizeOperation() const
    {
        winrt::Microsoft::UI::Input::MoveSizeOperation value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IWindowRectChangedEventArgs>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IWindowRectChangedEventArgs, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IWindowRectChangedEventArgs>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_MoveSizeOperation(reinterpret_cast<int32_t*>(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IWindowRectChangedEventArgs>**)this;
            check_hresult(_winrt_abi_type->get_MoveSizeOperation(reinterpret_cast<int32_t*>(&value)));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Input_IWindowRectChangedEventArgs<D>::OldWindowRect() const
    {
        winrt::Windows::Graphics::RectInt32 value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IWindowRectChangedEventArgs>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IWindowRectChangedEventArgs, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IWindowRectChangedEventArgs>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_OldWindowRect(put_abi(value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IWindowRectChangedEventArgs>**)this;
            check_hresult(_winrt_abi_type->get_OldWindowRect(put_abi(value)));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Input_IWindowRectChangedEventArgs<D>::NewWindowRect() const
    {
        winrt::Windows::Graphics::RectInt32 value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IWindowRectChangedEventArgs>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IWindowRectChangedEventArgs, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IWindowRectChangedEventArgs>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_NewWindowRect(put_abi(value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IWindowRectChangedEventArgs>**)this;
            check_hresult(_winrt_abi_type->get_NewWindowRect(put_abi(value)));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Input_IWindowRectChangingEventArgs<D>::PointerScreenPoint() const
    {
        winrt::Windows::Graphics::PointInt32 value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IWindowRectChangingEventArgs>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IWindowRectChangingEventArgs, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IWindowRectChangingEventArgs>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_PointerScreenPoint(put_abi(value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IWindowRectChangingEventArgs>**)this;
            check_hresult(_winrt_abi_type->get_PointerScreenPoint(put_abi(value)));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Input_IWindowRectChangingEventArgs<D>::MoveSizeOperation() const
    {
        winrt::Microsoft::UI::Input::MoveSizeOperation value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IWindowRectChangingEventArgs>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IWindowRectChangingEventArgs, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IWindowRectChangingEventArgs>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_MoveSizeOperation(reinterpret_cast<int32_t*>(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IWindowRectChangingEventArgs>**)this;
            check_hresult(_winrt_abi_type->get_MoveSizeOperation(reinterpret_cast<int32_t*>(&value)));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Input_IWindowRectChangingEventArgs<D>::OldWindowRect() const
    {
        winrt::Windows::Graphics::RectInt32 value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IWindowRectChangingEventArgs>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IWindowRectChangingEventArgs, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IWindowRectChangingEventArgs>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_OldWindowRect(put_abi(value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IWindowRectChangingEventArgs>**)this;
            check_hresult(_winrt_abi_type->get_OldWindowRect(put_abi(value)));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Input_IWindowRectChangingEventArgs<D>::NewWindowRect() const
    {
        winrt::Windows::Graphics::RectInt32 value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IWindowRectChangingEventArgs>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IWindowRectChangingEventArgs, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IWindowRectChangingEventArgs>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_NewWindowRect(put_abi(value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IWindowRectChangingEventArgs>**)this;
            check_hresult(_winrt_abi_type->get_NewWindowRect(put_abi(value)));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Input_IWindowRectChangingEventArgs<D>::NewWindowRect(winrt::Windows::Graphics::RectInt32 const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IWindowRectChangingEventArgs>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IWindowRectChangingEventArgs, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IWindowRectChangingEventArgs>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_NewWindowRect(impl::bind_in(value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IWindowRectChangingEventArgs>**)this;
            check_hresult(_winrt_abi_type->put_NewWindowRect(impl::bind_in(value)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Input_IWindowRectChangingEventArgs<D>::AllowRectChange() const
    {
        bool value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IWindowRectChangingEventArgs>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IWindowRectChangingEventArgs, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IWindowRectChangingEventArgs>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_AllowRectChange(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IWindowRectChangingEventArgs>**)this;
            check_hresult(_winrt_abi_type->get_AllowRectChange(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Input_IWindowRectChangingEventArgs<D>::AllowRectChange(bool value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IWindowRectChangingEventArgs>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IWindowRectChangingEventArgs, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IWindowRectChangingEventArgs>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_AllowRectChange(value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IWindowRectChangingEventArgs>**)this;
            check_hresult(_winrt_abi_type->put_AllowRectChange(value));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Input_IWindowRectChangingEventArgs<D>::ShowWindow() const
    {
        bool value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IWindowRectChangingEventArgs>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IWindowRectChangingEventArgs, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IWindowRectChangingEventArgs>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_ShowWindow(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IWindowRectChangingEventArgs>**)this;
            check_hresult(_winrt_abi_type->get_ShowWindow(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Input_IWindowRectChangingEventArgs<D>::ShowWindow(bool value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::IWindowRectChangingEventArgs>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::IWindowRectChangingEventArgs, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IWindowRectChangingEventArgs>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_ShowWindow(value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::IWindowRectChangingEventArgs>**)this;
            check_hresult(_winrt_abi_type->put_ShowWindow(value));
        }
    }
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Input::ICharacterReceivedEventArgs> : produce_base<D, winrt::Microsoft::UI::Input::ICharacterReceivedEventArgs>
    {
        int32_t __stdcall get_Handled(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().Handled());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_Handled(bool value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Handled(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_KeyCode(uint32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<uint32_t>(this->shim().KeyCode());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_KeyStatus(struct struct_Microsoft_UI_Input_PhysicalKeyStatus* value) noexcept final try
        {
            zero_abi<winrt::Microsoft::UI::Input::PhysicalKeyStatus>(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::UI::Input::PhysicalKeyStatus>(this->shim().KeyStatus());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Input::IContextMenuKeyEventArgs> : produce_base<D, winrt::Microsoft::UI::Input::IContextMenuKeyEventArgs>
    {
        int32_t __stdcall get_Handled(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().Handled());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_Handled(bool value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Handled(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Input::ICrossSlidingEventArgs> : produce_base<D, winrt::Microsoft::UI::Input::ICrossSlidingEventArgs>
    {
        int32_t __stdcall get_CrossSlidingState(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::UI::Input::CrossSlidingState>(this->shim().CrossSlidingState());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_PointerDeviceType(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::UI::Input::PointerDeviceType>(this->shim().PointerDeviceType());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Position(winrt::Windows::Foundation::Point* value) noexcept final try
        {
            zero_abi<winrt::Windows::Foundation::Point>(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::Point>(this->shim().Position());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Input::IDraggingEventArgs> : produce_base<D, winrt::Microsoft::UI::Input::IDraggingEventArgs>
    {
        int32_t __stdcall get_DraggingState(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::UI::Input::DraggingState>(this->shim().DraggingState());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_PointerDeviceType(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::UI::Input::PointerDeviceType>(this->shim().PointerDeviceType());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Position(winrt::Windows::Foundation::Point* value) noexcept final try
        {
            zero_abi<winrt::Windows::Foundation::Point>(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::Point>(this->shim().Position());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Input::IEnteredMoveSizeEventArgs> : produce_base<D, winrt::Microsoft::UI::Input::IEnteredMoveSizeEventArgs>
    {
        int32_t __stdcall get_PointerScreenPoint(struct struct_Windows_Graphics_PointInt32* value) noexcept final try
        {
            zero_abi<winrt::Windows::Graphics::PointInt32>(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Graphics::PointInt32>(this->shim().PointerScreenPoint());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_MoveSizeOperation(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::UI::Input::MoveSizeOperation>(this->shim().MoveSizeOperation());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Input::IEnteringMoveSizeEventArgs> : produce_base<D, winrt::Microsoft::UI::Input::IEnteringMoveSizeEventArgs>
    {
        int32_t __stdcall get_PointerScreenPoint(struct struct_Windows_Graphics_PointInt32* value) noexcept final try
        {
            zero_abi<winrt::Windows::Graphics::PointInt32>(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Graphics::PointInt32>(this->shim().PointerScreenPoint());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_MoveSizeOperation(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::UI::Input::MoveSizeOperation>(this->shim().MoveSizeOperation());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_MoveSizeWindowId(struct struct_Microsoft_UI_WindowId* value) noexcept final try
        {
            zero_abi<winrt::Microsoft::UI::WindowId>(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::UI::WindowId>(this->shim().MoveSizeWindowId());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_MoveSizeWindowId(struct struct_Microsoft_UI_WindowId value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().MoveSizeWindowId(*reinterpret_cast<winrt::Microsoft::UI::WindowId const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Input::IExitedMoveSizeEventArgs> : produce_base<D, winrt::Microsoft::UI::Input::IExitedMoveSizeEventArgs>
    {
        int32_t __stdcall get_PointerScreenPoint(struct struct_Windows_Graphics_PointInt32* value) noexcept final try
        {
            zero_abi<winrt::Windows::Graphics::PointInt32>(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Graphics::PointInt32>(this->shim().PointerScreenPoint());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_MoveSizeOperation(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::UI::Input::MoveSizeOperation>(this->shim().MoveSizeOperation());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Input::IFocusChangedEventArgs> : produce_base<D, winrt::Microsoft::UI::Input::IFocusChangedEventArgs>
    {
        int32_t __stdcall get_Handled(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().Handled());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_Handled(bool value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Handled(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Input::IFocusNavigationRequest> : produce_base<D, winrt::Microsoft::UI::Input::IFocusNavigationRequest>
    {
        int32_t __stdcall get_CorrelationId(winrt::guid* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::guid>(this->shim().CorrelationId());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_HintRect(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::Rect>>(this->shim().HintRect());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Reason(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::UI::Input::FocusNavigationReason>(this->shim().Reason());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Input::IFocusNavigationRequestEventArgs> : produce_base<D, winrt::Microsoft::UI::Input::IFocusNavigationRequestEventArgs>
    {
        int32_t __stdcall get_Request(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::UI::Input::FocusNavigationRequest>(this->shim().Request());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Result(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::UI::Input::FocusNavigationResult>(this->shim().Result());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_Result(int32_t value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Result(*reinterpret_cast<winrt::Microsoft::UI::Input::FocusNavigationResult const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Input::IFocusNavigationRequestStatics> : produce_base<D, winrt::Microsoft::UI::Input::IFocusNavigationRequestStatics>
    {
        int32_t __stdcall Create(int32_t reason, void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Microsoft::UI::Input::FocusNavigationRequest>(this->shim().Create(*reinterpret_cast<winrt::Microsoft::UI::Input::FocusNavigationReason const*>(&reason)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall CreateWithHintRect(int32_t reason, winrt::Windows::Foundation::Rect hintRect, void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Microsoft::UI::Input::FocusNavigationRequest>(this->shim().Create(*reinterpret_cast<winrt::Microsoft::UI::Input::FocusNavigationReason const*>(&reason), *reinterpret_cast<winrt::Windows::Foundation::Rect const*>(&hintRect)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall CreateWithHintRectAndId(int32_t reason, winrt::Windows::Foundation::Rect hintRect, winrt::guid correlationId, void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Microsoft::UI::Input::FocusNavigationRequest>(this->shim().Create(*reinterpret_cast<winrt::Microsoft::UI::Input::FocusNavigationReason const*>(&reason), *reinterpret_cast<winrt::Windows::Foundation::Rect const*>(&hintRect), *reinterpret_cast<winrt::guid const*>(&correlationId)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Input::IGestureRecognizer> : produce_base<D, winrt::Microsoft::UI::Input::IGestureRecognizer>
    {
        int32_t __stdcall get_AutoProcessInertia(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().AutoProcessInertia());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_AutoProcessInertia(bool value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().AutoProcessInertia(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_CrossSlideExact(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().CrossSlideExact());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_CrossSlideExact(bool value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().CrossSlideExact(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_CrossSlideHorizontally(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().CrossSlideHorizontally());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_CrossSlideHorizontally(bool value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().CrossSlideHorizontally(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_CrossSlideThresholds(struct struct_Microsoft_UI_Input_CrossSlideThresholds* value) noexcept final try
        {
            zero_abi<winrt::Microsoft::UI::Input::CrossSlideThresholds>(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::UI::Input::CrossSlideThresholds>(this->shim().CrossSlideThresholds());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_CrossSlideThresholds(struct struct_Microsoft_UI_Input_CrossSlideThresholds value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().CrossSlideThresholds(*reinterpret_cast<winrt::Microsoft::UI::Input::CrossSlideThresholds const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_GestureSettings(uint32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::UI::Input::GestureSettings>(this->shim().GestureSettings());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_GestureSettings(uint32_t value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().GestureSettings(*reinterpret_cast<winrt::Microsoft::UI::Input::GestureSettings const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_IsActive(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().IsActive());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_IsInertial(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().IsInertial());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_PivotCenter(winrt::Windows::Foundation::Point* value) noexcept final try
        {
            zero_abi<winrt::Windows::Foundation::Point>(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::Point>(this->shim().PivotCenter());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_PivotCenter(winrt::Windows::Foundation::Point value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().PivotCenter(*reinterpret_cast<winrt::Windows::Foundation::Point const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_PivotRadius(float* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<float>(this->shim().PivotRadius());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_PivotRadius(float value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().PivotRadius(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_InertiaExpansionDeceleration(float* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<float>(this->shim().InertiaExpansionDeceleration());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_InertiaExpansionDeceleration(float value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().InertiaExpansionDeceleration(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_InertiaExpansion(float* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<float>(this->shim().InertiaExpansion());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_InertiaExpansion(float value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().InertiaExpansion(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_InertiaRotationAngle(float* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<float>(this->shim().InertiaRotationAngle());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_InertiaRotationAngle(float value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().InertiaRotationAngle(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_InertiaRotationDeceleration(float* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<float>(this->shim().InertiaRotationDeceleration());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_InertiaRotationDeceleration(float value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().InertiaRotationDeceleration(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_InertiaTranslationDeceleration(float* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<float>(this->shim().InertiaTranslationDeceleration());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_InertiaTranslationDeceleration(float value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().InertiaTranslationDeceleration(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_InertiaTranslationDisplacement(float* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<float>(this->shim().InertiaTranslationDisplacement());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_InertiaTranslationDisplacement(float value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().InertiaTranslationDisplacement(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_ManipulationExact(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().ManipulationExact());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_ManipulationExact(bool value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().ManipulationExact(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_MouseWheelParameters(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::UI::Input::MouseWheelParameters>(this->shim().MouseWheelParameters());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_ShowGestureFeedback(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().ShowGestureFeedback());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_ShowGestureFeedback(bool value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().ShowGestureFeedback(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall CanBeDoubleTap(void* value, bool* result) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *result = detach_from<bool>(this->shim().CanBeDoubleTap(*reinterpret_cast<winrt::Microsoft::UI::Input::PointerPoint const*>(&value)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall CompleteGesture() noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().CompleteGesture();
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall ProcessDownEvent(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().ProcessDownEvent(*reinterpret_cast<winrt::Microsoft::UI::Input::PointerPoint const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall ProcessMoveEvents(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().ProcessMoveEvents(*reinterpret_cast<winrt::Windows::Foundation::Collections::IVector<winrt::Microsoft::UI::Input::PointerPoint> const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall ProcessMouseWheelEvent(void* value, bool isShiftKeyDown, bool isControlKeyDown) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().ProcessMouseWheelEvent(*reinterpret_cast<winrt::Microsoft::UI::Input::PointerPoint const*>(&value), isShiftKeyDown, isControlKeyDown);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall ProcessInertia() noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().ProcessInertia();
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall ProcessUpEvent(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().ProcessUpEvent(*reinterpret_cast<winrt::Microsoft::UI::Input::PointerPoint const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall add_Tapped(void* handler, winrt::event_token* token) noexcept final try
        {
            zero_abi<winrt::event_token>(token);
            typename D::abi_guard guard(this->shim());
            *token = detach_from<winrt::event_token>(this->shim().Tapped(*reinterpret_cast<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Input::GestureRecognizer, winrt::Microsoft::UI::Input::TappedEventArgs> const*>(&handler)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall remove_Tapped(winrt::event_token token) noexcept final
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Tapped(*reinterpret_cast<winrt::event_token const*>(&token));
            return 0;
        }
        int32_t __stdcall add_RightTapped(void* handler, winrt::event_token* token) noexcept final try
        {
            zero_abi<winrt::event_token>(token);
            typename D::abi_guard guard(this->shim());
            *token = detach_from<winrt::event_token>(this->shim().RightTapped(*reinterpret_cast<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Input::GestureRecognizer, winrt::Microsoft::UI::Input::RightTappedEventArgs> const*>(&handler)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall remove_RightTapped(winrt::event_token token) noexcept final
        {
            typename D::abi_guard guard(this->shim());
            this->shim().RightTapped(*reinterpret_cast<winrt::event_token const*>(&token));
            return 0;
        }
        int32_t __stdcall add_Holding(void* handler, winrt::event_token* token) noexcept final try
        {
            zero_abi<winrt::event_token>(token);
            typename D::abi_guard guard(this->shim());
            *token = detach_from<winrt::event_token>(this->shim().Holding(*reinterpret_cast<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Input::GestureRecognizer, winrt::Microsoft::UI::Input::HoldingEventArgs> const*>(&handler)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall remove_Holding(winrt::event_token token) noexcept final
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Holding(*reinterpret_cast<winrt::event_token const*>(&token));
            return 0;
        }
        int32_t __stdcall add_Dragging(void* handler, winrt::event_token* token) noexcept final try
        {
            zero_abi<winrt::event_token>(token);
            typename D::abi_guard guard(this->shim());
            *token = detach_from<winrt::event_token>(this->shim().Dragging(*reinterpret_cast<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Input::GestureRecognizer, winrt::Microsoft::UI::Input::DraggingEventArgs> const*>(&handler)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall remove_Dragging(winrt::event_token token) noexcept final
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Dragging(*reinterpret_cast<winrt::event_token const*>(&token));
            return 0;
        }
        int32_t __stdcall add_ManipulationStarted(void* handler, winrt::event_token* token) noexcept final try
        {
            zero_abi<winrt::event_token>(token);
            typename D::abi_guard guard(this->shim());
            *token = detach_from<winrt::event_token>(this->shim().ManipulationStarted(*reinterpret_cast<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Input::GestureRecognizer, winrt::Microsoft::UI::Input::ManipulationStartedEventArgs> const*>(&handler)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall remove_ManipulationStarted(winrt::event_token token) noexcept final
        {
            typename D::abi_guard guard(this->shim());
            this->shim().ManipulationStarted(*reinterpret_cast<winrt::event_token const*>(&token));
            return 0;
        }
        int32_t __stdcall add_ManipulationUpdated(void* handler, winrt::event_token* token) noexcept final try
        {
            zero_abi<winrt::event_token>(token);
            typename D::abi_guard guard(this->shim());
            *token = detach_from<winrt::event_token>(this->shim().ManipulationUpdated(*reinterpret_cast<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Input::GestureRecognizer, winrt::Microsoft::UI::Input::ManipulationUpdatedEventArgs> const*>(&handler)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall remove_ManipulationUpdated(winrt::event_token token) noexcept final
        {
            typename D::abi_guard guard(this->shim());
            this->shim().ManipulationUpdated(*reinterpret_cast<winrt::event_token const*>(&token));
            return 0;
        }
        int32_t __stdcall add_ManipulationInertiaStarting(void* handler, winrt::event_token* token) noexcept final try
        {
            zero_abi<winrt::event_token>(token);
            typename D::abi_guard guard(this->shim());
            *token = detach_from<winrt::event_token>(this->shim().ManipulationInertiaStarting(*reinterpret_cast<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Input::GestureRecognizer, winrt::Microsoft::UI::Input::ManipulationInertiaStartingEventArgs> const*>(&handler)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall remove_ManipulationInertiaStarting(winrt::event_token token) noexcept final
        {
            typename D::abi_guard guard(this->shim());
            this->shim().ManipulationInertiaStarting(*reinterpret_cast<winrt::event_token const*>(&token));
            return 0;
        }
        int32_t __stdcall add_ManipulationCompleted(void* handler, winrt::event_token* token) noexcept final try
        {
            zero_abi<winrt::event_token>(token);
            typename D::abi_guard guard(this->shim());
            *token = detach_from<winrt::event_token>(this->shim().ManipulationCompleted(*reinterpret_cast<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Input::GestureRecognizer, winrt::Microsoft::UI::Input::ManipulationCompletedEventArgs> const*>(&handler)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall remove_ManipulationCompleted(winrt::event_token token) noexcept final
        {
            typename D::abi_guard guard(this->shim());
            this->shim().ManipulationCompleted(*reinterpret_cast<winrt::event_token const*>(&token));
            return 0;
        }
        int32_t __stdcall add_CrossSliding(void* handler, winrt::event_token* token) noexcept final try
        {
            zero_abi<winrt::event_token>(token);
            typename D::abi_guard guard(this->shim());
            *token = detach_from<winrt::event_token>(this->shim().CrossSliding(*reinterpret_cast<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Input::GestureRecognizer, winrt::Microsoft::UI::Input::CrossSlidingEventArgs> const*>(&handler)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall remove_CrossSliding(winrt::event_token token) noexcept final
        {
            typename D::abi_guard guard(this->shim());
            this->shim().CrossSliding(*reinterpret_cast<winrt::event_token const*>(&token));
            return 0;
        }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Input::IHoldingEventArgs> : produce_base<D, winrt::Microsoft::UI::Input::IHoldingEventArgs>
    {
        int32_t __stdcall get_HoldingState(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::UI::Input::HoldingState>(this->shim().HoldingState());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_PointerDeviceType(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::UI::Input::PointerDeviceType>(this->shim().PointerDeviceType());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Position(winrt::Windows::Foundation::Point* value) noexcept final try
        {
            zero_abi<winrt::Windows::Foundation::Point>(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::Point>(this->shim().Position());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Input::IInputActivationListener> : produce_base<D, winrt::Microsoft::UI::Input::IInputActivationListener>
    {
        int32_t __stdcall get_State(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::UI::Input::InputActivationState>(this->shim().State());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall add_InputActivationChanged(void* handler, winrt::event_token* token) noexcept final try
        {
            zero_abi<winrt::event_token>(token);
            typename D::abi_guard guard(this->shim());
            *token = detach_from<winrt::event_token>(this->shim().InputActivationChanged(*reinterpret_cast<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Input::InputActivationListener, winrt::Microsoft::UI::Input::InputActivationListenerActivationChangedEventArgs> const*>(&handler)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall remove_InputActivationChanged(winrt::event_token token) noexcept final
        {
            typename D::abi_guard guard(this->shim());
            this->shim().InputActivationChanged(*reinterpret_cast<winrt::event_token const*>(&token));
            return 0;
        }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Input::IInputActivationListenerActivationChangedEventArgs> : produce_base<D, winrt::Microsoft::UI::Input::IInputActivationListenerActivationChangedEventArgs>
    {
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Input::IInputActivationListenerStatics> : produce_base<D, winrt::Microsoft::UI::Input::IInputActivationListenerStatics>
    {
        int32_t __stdcall GetForWindowId(struct struct_Microsoft_UI_WindowId windowId, void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Microsoft::UI::Input::InputActivationListener>(this->shim().GetForWindowId(*reinterpret_cast<winrt::Microsoft::UI::WindowId const*>(&windowId)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Input::IInputActivationListenerStatics2> : produce_base<D, winrt::Microsoft::UI::Input::IInputActivationListenerStatics2>
    {
        int32_t __stdcall GetForIsland(void* island, void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Microsoft::UI::Input::InputActivationListener>(this->shim().GetForIsland(*reinterpret_cast<winrt::Microsoft::UI::Content::ContentIsland const*>(&island)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Input::IInputCursor> : produce_base<D, winrt::Microsoft::UI::Input::IInputCursor>
    {
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Input::IInputCursorFactory> : produce_base<D, winrt::Microsoft::UI::Input::IInputCursorFactory>
    {
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Input::IInputCursorStatics> : produce_base<D, winrt::Microsoft::UI::Input::IInputCursorStatics>
    {
        int32_t __stdcall CreateFromCoreCursor(void* cursor, void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Microsoft::UI::Input::InputCursor>(this->shim().CreateFromCoreCursor(*reinterpret_cast<winrt::Windows::UI::Core::CoreCursor const*>(&cursor)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Input::IInputCustomCursor> : produce_base<D, winrt::Microsoft::UI::Input::IInputCustomCursor>
    {
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Input::IInputCustomCursorFactory> : produce_base<D, winrt::Microsoft::UI::Input::IInputCustomCursorFactory>
    {
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Input::IInputDesktopNamedResourceCursor> : produce_base<D, winrt::Microsoft::UI::Input::IInputDesktopNamedResourceCursor>
    {
        int32_t __stdcall get_ModuleName(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<hstring>(this->shim().ModuleName());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_ResourceName(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<hstring>(this->shim().ResourceName());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Input::IInputDesktopNamedResourceCursorStatics> : produce_base<D, winrt::Microsoft::UI::Input::IInputDesktopNamedResourceCursorStatics>
    {
        int32_t __stdcall Create(void* resourceName, void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Microsoft::UI::Input::InputDesktopNamedResourceCursor>(this->shim().Create(*reinterpret_cast<hstring const*>(&resourceName)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall CreateFromModule(void* moduleName, void* resourceName, void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Microsoft::UI::Input::InputDesktopNamedResourceCursor>(this->shim().CreateFromModule(*reinterpret_cast<hstring const*>(&moduleName), *reinterpret_cast<hstring const*>(&resourceName)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Input::IInputDesktopResourceCursor> : produce_base<D, winrt::Microsoft::UI::Input::IInputDesktopResourceCursor>
    {
        int32_t __stdcall get_ModuleName(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<hstring>(this->shim().ModuleName());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_ResourceId(uint32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<uint32_t>(this->shim().ResourceId());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Input::IInputDesktopResourceCursorStatics> : produce_base<D, winrt::Microsoft::UI::Input::IInputDesktopResourceCursorStatics>
    {
        int32_t __stdcall Create(uint32_t resourceId, void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Microsoft::UI::Input::InputDesktopResourceCursor>(this->shim().Create(resourceId));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall CreateFromModule(void* moduleName, uint32_t resourceId, void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Microsoft::UI::Input::InputDesktopResourceCursor>(this->shim().CreateFromModule(*reinterpret_cast<hstring const*>(&moduleName), resourceId));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Input::IInputFocusController> : produce_base<D, winrt::Microsoft::UI::Input::IInputFocusController>
    {
        int32_t __stdcall get_HasFocus(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().HasFocus());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall TrySetFocus(bool* result) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *result = detach_from<bool>(this->shim().TrySetFocus());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall add_GotFocus(void* handler, winrt::event_token* token) noexcept final try
        {
            zero_abi<winrt::event_token>(token);
            typename D::abi_guard guard(this->shim());
            *token = detach_from<winrt::event_token>(this->shim().GotFocus(*reinterpret_cast<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Input::InputFocusController, winrt::Microsoft::UI::Input::FocusChangedEventArgs> const*>(&handler)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall remove_GotFocus(winrt::event_token token) noexcept final
        {
            typename D::abi_guard guard(this->shim());
            this->shim().GotFocus(*reinterpret_cast<winrt::event_token const*>(&token));
            return 0;
        }
        int32_t __stdcall add_LostFocus(void* handler, winrt::event_token* token) noexcept final try
        {
            zero_abi<winrt::event_token>(token);
            typename D::abi_guard guard(this->shim());
            *token = detach_from<winrt::event_token>(this->shim().LostFocus(*reinterpret_cast<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Input::InputFocusController, winrt::Microsoft::UI::Input::FocusChangedEventArgs> const*>(&handler)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall remove_LostFocus(winrt::event_token token) noexcept final
        {
            typename D::abi_guard guard(this->shim());
            this->shim().LostFocus(*reinterpret_cast<winrt::event_token const*>(&token));
            return 0;
        }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Input::IInputFocusController2> : produce_base<D, winrt::Microsoft::UI::Input::IInputFocusController2>
    {
        int32_t __stdcall DepartFocus(void* request, int32_t* result) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Microsoft::UI::Input::FocusNavigationResult>(this->shim().DepartFocus(*reinterpret_cast<winrt::Microsoft::UI::Input::FocusNavigationRequest const*>(&request)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall add_NavigateFocusRequested(void* handler, winrt::event_token* token) noexcept final try
        {
            zero_abi<winrt::event_token>(token);
            typename D::abi_guard guard(this->shim());
            *token = detach_from<winrt::event_token>(this->shim().NavigateFocusRequested(*reinterpret_cast<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Input::InputFocusController, winrt::Microsoft::UI::Input::FocusNavigationRequestEventArgs> const*>(&handler)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall remove_NavigateFocusRequested(winrt::event_token token) noexcept final
        {
            typename D::abi_guard guard(this->shim());
            this->shim().NavigateFocusRequested(*reinterpret_cast<winrt::event_token const*>(&token));
            return 0;
        }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Input::IInputFocusControllerStatics> : produce_base<D, winrt::Microsoft::UI::Input::IInputFocusControllerStatics>
    {
        int32_t __stdcall GetForIsland(void* island, void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Microsoft::UI::Input::InputFocusController>(this->shim().GetForIsland(*reinterpret_cast<winrt::Microsoft::UI::Content::ContentIsland const*>(&island)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Input::IInputFocusNavigationHost> : produce_base<D, winrt::Microsoft::UI::Input::IInputFocusNavigationHost>
    {
        int32_t __stdcall get_ContainsFocus(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().ContainsFocus());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall NavigateFocus(void* request, int32_t* result) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Microsoft::UI::Input::FocusNavigationResult>(this->shim().NavigateFocus(*reinterpret_cast<winrt::Microsoft::UI::Input::FocusNavigationRequest const*>(&request)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall add_DepartFocusRequested(void* handler, winrt::event_token* token) noexcept final try
        {
            zero_abi<winrt::event_token>(token);
            typename D::abi_guard guard(this->shim());
            *token = detach_from<winrt::event_token>(this->shim().DepartFocusRequested(*reinterpret_cast<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Input::InputFocusNavigationHost, winrt::Microsoft::UI::Input::FocusNavigationRequestEventArgs> const*>(&handler)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall remove_DepartFocusRequested(winrt::event_token token) noexcept final
        {
            typename D::abi_guard guard(this->shim());
            this->shim().DepartFocusRequested(*reinterpret_cast<winrt::event_token const*>(&token));
            return 0;
        }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Input::IInputFocusNavigationHostStatics> : produce_base<D, winrt::Microsoft::UI::Input::IInputFocusNavigationHostStatics>
    {
        int32_t __stdcall GetForSiteBridge(void* site, void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Microsoft::UI::Input::InputFocusNavigationHost>(this->shim().GetForSiteBridge(*reinterpret_cast<winrt::Microsoft::UI::Content::IContentSiteBridge const*>(&site)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Input::IInputFocusNavigationHostStatics2> : produce_base<D, winrt::Microsoft::UI::Input::IInputFocusNavigationHostStatics2>
    {
        int32_t __stdcall GetForSiteLink(void* contentSiteLink, void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Microsoft::UI::Input::InputFocusNavigationHost>(this->shim().GetForSiteLink(*reinterpret_cast<winrt::Microsoft::UI::Content::IContentSiteLink const*>(&contentSiteLink)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Input::IInputKeyboardSource> : produce_base<D, winrt::Microsoft::UI::Input::IInputKeyboardSource>
    {
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Input::IInputKeyboardSource2> : produce_base<D, winrt::Microsoft::UI::Input::IInputKeyboardSource2>
    {
        int32_t __stdcall GetCurrentKeyState(int32_t virtualKey, uint32_t* result) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Microsoft::UI::Input::VirtualKeyStates>(this->shim().GetCurrentKeyState(*reinterpret_cast<winrt::Windows::System::VirtualKey const*>(&virtualKey)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall GetKeyState(int32_t virtualKey, uint32_t* result) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Microsoft::UI::Input::VirtualKeyStates>(this->shim().GetKeyState(*reinterpret_cast<winrt::Windows::System::VirtualKey const*>(&virtualKey)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall add_CharacterReceived(void* handler, winrt::event_token* token) noexcept final try
        {
            zero_abi<winrt::event_token>(token);
            typename D::abi_guard guard(this->shim());
            *token = detach_from<winrt::event_token>(this->shim().CharacterReceived(*reinterpret_cast<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Input::InputKeyboardSource, winrt::Microsoft::UI::Input::CharacterReceivedEventArgs> const*>(&handler)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall remove_CharacterReceived(winrt::event_token token) noexcept final
        {
            typename D::abi_guard guard(this->shim());
            this->shim().CharacterReceived(*reinterpret_cast<winrt::event_token const*>(&token));
            return 0;
        }
        int32_t __stdcall add_ContextMenuKey(void* handler, winrt::event_token* token) noexcept final try
        {
            zero_abi<winrt::event_token>(token);
            typename D::abi_guard guard(this->shim());
            *token = detach_from<winrt::event_token>(this->shim().ContextMenuKey(*reinterpret_cast<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Input::InputKeyboardSource, winrt::Microsoft::UI::Input::ContextMenuKeyEventArgs> const*>(&handler)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall remove_ContextMenuKey(winrt::event_token token) noexcept final
        {
            typename D::abi_guard guard(this->shim());
            this->shim().ContextMenuKey(*reinterpret_cast<winrt::event_token const*>(&token));
            return 0;
        }
        int32_t __stdcall add_KeyDown(void* handler, winrt::event_token* token) noexcept final try
        {
            zero_abi<winrt::event_token>(token);
            typename D::abi_guard guard(this->shim());
            *token = detach_from<winrt::event_token>(this->shim().KeyDown(*reinterpret_cast<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Input::InputKeyboardSource, winrt::Microsoft::UI::Input::KeyEventArgs> const*>(&handler)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall remove_KeyDown(winrt::event_token token) noexcept final
        {
            typename D::abi_guard guard(this->shim());
            this->shim().KeyDown(*reinterpret_cast<winrt::event_token const*>(&token));
            return 0;
        }
        int32_t __stdcall add_KeyUp(void* handler, winrt::event_token* token) noexcept final try
        {
            zero_abi<winrt::event_token>(token);
            typename D::abi_guard guard(this->shim());
            *token = detach_from<winrt::event_token>(this->shim().KeyUp(*reinterpret_cast<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Input::InputKeyboardSource, winrt::Microsoft::UI::Input::KeyEventArgs> const*>(&handler)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall remove_KeyUp(winrt::event_token token) noexcept final
        {
            typename D::abi_guard guard(this->shim());
            this->shim().KeyUp(*reinterpret_cast<winrt::event_token const*>(&token));
            return 0;
        }
        int32_t __stdcall add_SystemKeyDown(void* handler, winrt::event_token* token) noexcept final try
        {
            zero_abi<winrt::event_token>(token);
            typename D::abi_guard guard(this->shim());
            *token = detach_from<winrt::event_token>(this->shim().SystemKeyDown(*reinterpret_cast<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Input::InputKeyboardSource, winrt::Microsoft::UI::Input::KeyEventArgs> const*>(&handler)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall remove_SystemKeyDown(winrt::event_token token) noexcept final
        {
            typename D::abi_guard guard(this->shim());
            this->shim().SystemKeyDown(*reinterpret_cast<winrt::event_token const*>(&token));
            return 0;
        }
        int32_t __stdcall add_SystemKeyUp(void* handler, winrt::event_token* token) noexcept final try
        {
            zero_abi<winrt::event_token>(token);
            typename D::abi_guard guard(this->shim());
            *token = detach_from<winrt::event_token>(this->shim().SystemKeyUp(*reinterpret_cast<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Input::InputKeyboardSource, winrt::Microsoft::UI::Input::KeyEventArgs> const*>(&handler)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall remove_SystemKeyUp(winrt::event_token token) noexcept final
        {
            typename D::abi_guard guard(this->shim());
            this->shim().SystemKeyUp(*reinterpret_cast<winrt::event_token const*>(&token));
            return 0;
        }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Input::IInputKeyboardSourceStatics> : produce_base<D, winrt::Microsoft::UI::Input::IInputKeyboardSourceStatics>
    {
        int32_t __stdcall GetKeyStateForCurrentThread(int32_t virtualKey, uint32_t* result) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Windows::UI::Core::CoreVirtualKeyStates>(this->shim().GetKeyStateForCurrentThread(*reinterpret_cast<winrt::Windows::System::VirtualKey const*>(&virtualKey)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Input::IInputKeyboardSourceStatics2> : produce_base<D, winrt::Microsoft::UI::Input::IInputKeyboardSourceStatics2>
    {
        int32_t __stdcall GetForIsland(void* island, void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Microsoft::UI::Input::InputKeyboardSource>(this->shim().GetForIsland(*reinterpret_cast<winrt::Microsoft::UI::Content::ContentIsland const*>(&island)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Input::IInputLightDismissAction> : produce_base<D, winrt::Microsoft::UI::Input::IInputLightDismissAction>
    {
        int32_t __stdcall add_Dismissed(void* handler, winrt::event_token* token) noexcept final try
        {
            zero_abi<winrt::event_token>(token);
            typename D::abi_guard guard(this->shim());
            *token = detach_from<winrt::event_token>(this->shim().Dismissed(*reinterpret_cast<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Input::InputLightDismissAction, winrt::Microsoft::UI::Input::InputLightDismissEventArgs> const*>(&handler)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall remove_Dismissed(winrt::event_token token) noexcept final
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Dismissed(*reinterpret_cast<winrt::event_token const*>(&token));
            return 0;
        }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Input::IInputLightDismissActionStatics> : produce_base<D, winrt::Microsoft::UI::Input::IInputLightDismissActionStatics>
    {
        int32_t __stdcall GetForWindowId(struct struct_Microsoft_UI_WindowId windowId, void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Microsoft::UI::Input::InputLightDismissAction>(this->shim().GetForWindowId(*reinterpret_cast<winrt::Microsoft::UI::WindowId const*>(&windowId)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Input::IInputLightDismissEventArgs> : produce_base<D, winrt::Microsoft::UI::Input::IInputLightDismissEventArgs>
    {
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Input::IInputNonClientPointerSource> : produce_base<D, winrt::Microsoft::UI::Input::IInputNonClientPointerSource>
    {
        int32_t __stdcall get_DispatcherQueue(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::UI::Dispatching::DispatcherQueue>(this->shim().DispatcherQueue());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall ClearAllRegionRects() noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().ClearAllRegionRects();
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall ClearRegionRects(int32_t region) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().ClearRegionRects(*reinterpret_cast<winrt::Microsoft::UI::Input::NonClientRegionKind const*>(&region));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall GetRegionRects(int32_t region, uint32_t* __resultSize, struct struct_Windows_Graphics_RectInt32** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            std::tie(*__resultSize, *result) = detach_abi(this->shim().GetRegionRects(*reinterpret_cast<winrt::Microsoft::UI::Input::NonClientRegionKind const*>(&region)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall SetRegionRects(int32_t region, uint32_t __rectsSize, struct struct_Windows_Graphics_RectInt32* rects) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().SetRegionRects(*reinterpret_cast<winrt::Microsoft::UI::Input::NonClientRegionKind const*>(&region), array_view<winrt::Windows::Graphics::RectInt32 const>(reinterpret_cast<winrt::Windows::Graphics::RectInt32 const *>(rects), reinterpret_cast<winrt::Windows::Graphics::RectInt32 const *>(rects) + __rectsSize));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall add_CaptionTapped(void* handler, winrt::event_token* token) noexcept final try
        {
            zero_abi<winrt::event_token>(token);
            typename D::abi_guard guard(this->shim());
            *token = detach_from<winrt::event_token>(this->shim().CaptionTapped(*reinterpret_cast<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Input::InputNonClientPointerSource, winrt::Microsoft::UI::Input::NonClientCaptionTappedEventArgs> const*>(&handler)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall remove_CaptionTapped(winrt::event_token token) noexcept final
        {
            typename D::abi_guard guard(this->shim());
            this->shim().CaptionTapped(*reinterpret_cast<winrt::event_token const*>(&token));
            return 0;
        }
        int32_t __stdcall add_PointerEntered(void* handler, winrt::event_token* token) noexcept final try
        {
            zero_abi<winrt::event_token>(token);
            typename D::abi_guard guard(this->shim());
            *token = detach_from<winrt::event_token>(this->shim().PointerEntered(*reinterpret_cast<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Input::InputNonClientPointerSource, winrt::Microsoft::UI::Input::NonClientPointerEventArgs> const*>(&handler)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall remove_PointerEntered(winrt::event_token token) noexcept final
        {
            typename D::abi_guard guard(this->shim());
            this->shim().PointerEntered(*reinterpret_cast<winrt::event_token const*>(&token));
            return 0;
        }
        int32_t __stdcall add_PointerExited(void* handler, winrt::event_token* token) noexcept final try
        {
            zero_abi<winrt::event_token>(token);
            typename D::abi_guard guard(this->shim());
            *token = detach_from<winrt::event_token>(this->shim().PointerExited(*reinterpret_cast<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Input::InputNonClientPointerSource, winrt::Microsoft::UI::Input::NonClientPointerEventArgs> const*>(&handler)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall remove_PointerExited(winrt::event_token token) noexcept final
        {
            typename D::abi_guard guard(this->shim());
            this->shim().PointerExited(*reinterpret_cast<winrt::event_token const*>(&token));
            return 0;
        }
        int32_t __stdcall add_PointerMoved(void* handler, winrt::event_token* token) noexcept final try
        {
            zero_abi<winrt::event_token>(token);
            typename D::abi_guard guard(this->shim());
            *token = detach_from<winrt::event_token>(this->shim().PointerMoved(*reinterpret_cast<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Input::InputNonClientPointerSource, winrt::Microsoft::UI::Input::NonClientPointerEventArgs> const*>(&handler)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall remove_PointerMoved(winrt::event_token token) noexcept final
        {
            typename D::abi_guard guard(this->shim());
            this->shim().PointerMoved(*reinterpret_cast<winrt::event_token const*>(&token));
            return 0;
        }
        int32_t __stdcall add_PointerPressed(void* handler, winrt::event_token* token) noexcept final try
        {
            zero_abi<winrt::event_token>(token);
            typename D::abi_guard guard(this->shim());
            *token = detach_from<winrt::event_token>(this->shim().PointerPressed(*reinterpret_cast<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Input::InputNonClientPointerSource, winrt::Microsoft::UI::Input::NonClientPointerEventArgs> const*>(&handler)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall remove_PointerPressed(winrt::event_token token) noexcept final
        {
            typename D::abi_guard guard(this->shim());
            this->shim().PointerPressed(*reinterpret_cast<winrt::event_token const*>(&token));
            return 0;
        }
        int32_t __stdcall add_PointerReleased(void* handler, winrt::event_token* token) noexcept final try
        {
            zero_abi<winrt::event_token>(token);
            typename D::abi_guard guard(this->shim());
            *token = detach_from<winrt::event_token>(this->shim().PointerReleased(*reinterpret_cast<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Input::InputNonClientPointerSource, winrt::Microsoft::UI::Input::NonClientPointerEventArgs> const*>(&handler)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall remove_PointerReleased(winrt::event_token token) noexcept final
        {
            typename D::abi_guard guard(this->shim());
            this->shim().PointerReleased(*reinterpret_cast<winrt::event_token const*>(&token));
            return 0;
        }
        int32_t __stdcall add_RegionsChanged(void* handler, winrt::event_token* token) noexcept final try
        {
            zero_abi<winrt::event_token>(token);
            typename D::abi_guard guard(this->shim());
            *token = detach_from<winrt::event_token>(this->shim().RegionsChanged(*reinterpret_cast<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Input::InputNonClientPointerSource, winrt::Microsoft::UI::Input::NonClientRegionsChangedEventArgs> const*>(&handler)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall remove_RegionsChanged(winrt::event_token token) noexcept final
        {
            typename D::abi_guard guard(this->shim());
            this->shim().RegionsChanged(*reinterpret_cast<winrt::event_token const*>(&token));
            return 0;
        }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Input::IInputNonClientPointerSource2> : produce_base<D, winrt::Microsoft::UI::Input::IInputNonClientPointerSource2>
    {
        int32_t __stdcall add_EnteringMoveSize(void* handler, winrt::event_token* token) noexcept final try
        {
            zero_abi<winrt::event_token>(token);
            typename D::abi_guard guard(this->shim());
            *token = detach_from<winrt::event_token>(this->shim().EnteringMoveSize(*reinterpret_cast<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Input::InputNonClientPointerSource, winrt::Microsoft::UI::Input::EnteringMoveSizeEventArgs> const*>(&handler)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall remove_EnteringMoveSize(winrt::event_token token) noexcept final
        {
            typename D::abi_guard guard(this->shim());
            this->shim().EnteringMoveSize(*reinterpret_cast<winrt::event_token const*>(&token));
            return 0;
        }
        int32_t __stdcall add_EnteredMoveSize(void* handler, winrt::event_token* token) noexcept final try
        {
            zero_abi<winrt::event_token>(token);
            typename D::abi_guard guard(this->shim());
            *token = detach_from<winrt::event_token>(this->shim().EnteredMoveSize(*reinterpret_cast<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Input::InputNonClientPointerSource, winrt::Microsoft::UI::Input::EnteredMoveSizeEventArgs> const*>(&handler)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall remove_EnteredMoveSize(winrt::event_token token) noexcept final
        {
            typename D::abi_guard guard(this->shim());
            this->shim().EnteredMoveSize(*reinterpret_cast<winrt::event_token const*>(&token));
            return 0;
        }
        int32_t __stdcall add_WindowRectChanging(void* handler, winrt::event_token* token) noexcept final try
        {
            zero_abi<winrt::event_token>(token);
            typename D::abi_guard guard(this->shim());
            *token = detach_from<winrt::event_token>(this->shim().WindowRectChanging(*reinterpret_cast<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Input::InputNonClientPointerSource, winrt::Microsoft::UI::Input::WindowRectChangingEventArgs> const*>(&handler)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall remove_WindowRectChanging(winrt::event_token token) noexcept final
        {
            typename D::abi_guard guard(this->shim());
            this->shim().WindowRectChanging(*reinterpret_cast<winrt::event_token const*>(&token));
            return 0;
        }
        int32_t __stdcall add_WindowRectChanged(void* handler, winrt::event_token* token) noexcept final try
        {
            zero_abi<winrt::event_token>(token);
            typename D::abi_guard guard(this->shim());
            *token = detach_from<winrt::event_token>(this->shim().WindowRectChanged(*reinterpret_cast<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Input::InputNonClientPointerSource, winrt::Microsoft::UI::Input::WindowRectChangedEventArgs> const*>(&handler)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall remove_WindowRectChanged(winrt::event_token token) noexcept final
        {
            typename D::abi_guard guard(this->shim());
            this->shim().WindowRectChanged(*reinterpret_cast<winrt::event_token const*>(&token));
            return 0;
        }
        int32_t __stdcall add_ExitedMoveSize(void* handler, winrt::event_token* token) noexcept final try
        {
            zero_abi<winrt::event_token>(token);
            typename D::abi_guard guard(this->shim());
            *token = detach_from<winrt::event_token>(this->shim().ExitedMoveSize(*reinterpret_cast<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Input::InputNonClientPointerSource, winrt::Microsoft::UI::Input::ExitedMoveSizeEventArgs> const*>(&handler)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall remove_ExitedMoveSize(winrt::event_token token) noexcept final
        {
            typename D::abi_guard guard(this->shim());
            this->shim().ExitedMoveSize(*reinterpret_cast<winrt::event_token const*>(&token));
            return 0;
        }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Input::IInputNonClientPointerSourceStatics> : produce_base<D, winrt::Microsoft::UI::Input::IInputNonClientPointerSourceStatics>
    {
        int32_t __stdcall GetForWindowId(struct struct_Microsoft_UI_WindowId windowId, void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Microsoft::UI::Input::InputNonClientPointerSource>(this->shim().GetForWindowId(*reinterpret_cast<winrt::Microsoft::UI::WindowId const*>(&windowId)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Input::IInputObject> : produce_base<D, winrt::Microsoft::UI::Input::IInputObject>
    {
        int32_t __stdcall get_DispatcherQueue(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::UI::Dispatching::DispatcherQueue>(this->shim().DispatcherQueue());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Input::IInputObjectFactory> : produce_base<D, winrt::Microsoft::UI::Input::IInputObjectFactory>
    {
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Input::IInputPointerSource> : produce_base<D, winrt::Microsoft::UI::Input::IInputPointerSource>
    {
        int32_t __stdcall get_Cursor(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::UI::Input::InputCursor>(this->shim().Cursor());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_Cursor(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Cursor(*reinterpret_cast<winrt::Microsoft::UI::Input::InputCursor const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_DeviceKinds(uint32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::UI::Input::InputPointerSourceDeviceKinds>(this->shim().DeviceKinds());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall add_PointerCaptureLost(void* handler, winrt::event_token* token) noexcept final try
        {
            zero_abi<winrt::event_token>(token);
            typename D::abi_guard guard(this->shim());
            *token = detach_from<winrt::event_token>(this->shim().PointerCaptureLost(*reinterpret_cast<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Input::InputPointerSource, winrt::Microsoft::UI::Input::PointerEventArgs> const*>(&handler)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall remove_PointerCaptureLost(winrt::event_token token) noexcept final
        {
            typename D::abi_guard guard(this->shim());
            this->shim().PointerCaptureLost(*reinterpret_cast<winrt::event_token const*>(&token));
            return 0;
        }
        int32_t __stdcall add_PointerEntered(void* handler, winrt::event_token* token) noexcept final try
        {
            zero_abi<winrt::event_token>(token);
            typename D::abi_guard guard(this->shim());
            *token = detach_from<winrt::event_token>(this->shim().PointerEntered(*reinterpret_cast<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Input::InputPointerSource, winrt::Microsoft::UI::Input::PointerEventArgs> const*>(&handler)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall remove_PointerEntered(winrt::event_token token) noexcept final
        {
            typename D::abi_guard guard(this->shim());
            this->shim().PointerEntered(*reinterpret_cast<winrt::event_token const*>(&token));
            return 0;
        }
        int32_t __stdcall add_PointerExited(void* handler, winrt::event_token* token) noexcept final try
        {
            zero_abi<winrt::event_token>(token);
            typename D::abi_guard guard(this->shim());
            *token = detach_from<winrt::event_token>(this->shim().PointerExited(*reinterpret_cast<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Input::InputPointerSource, winrt::Microsoft::UI::Input::PointerEventArgs> const*>(&handler)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall remove_PointerExited(winrt::event_token token) noexcept final
        {
            typename D::abi_guard guard(this->shim());
            this->shim().PointerExited(*reinterpret_cast<winrt::event_token const*>(&token));
            return 0;
        }
        int32_t __stdcall add_PointerMoved(void* handler, winrt::event_token* token) noexcept final try
        {
            zero_abi<winrt::event_token>(token);
            typename D::abi_guard guard(this->shim());
            *token = detach_from<winrt::event_token>(this->shim().PointerMoved(*reinterpret_cast<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Input::InputPointerSource, winrt::Microsoft::UI::Input::PointerEventArgs> const*>(&handler)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall remove_PointerMoved(winrt::event_token token) noexcept final
        {
            typename D::abi_guard guard(this->shim());
            this->shim().PointerMoved(*reinterpret_cast<winrt::event_token const*>(&token));
            return 0;
        }
        int32_t __stdcall add_PointerPressed(void* handler, winrt::event_token* token) noexcept final try
        {
            zero_abi<winrt::event_token>(token);
            typename D::abi_guard guard(this->shim());
            *token = detach_from<winrt::event_token>(this->shim().PointerPressed(*reinterpret_cast<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Input::InputPointerSource, winrt::Microsoft::UI::Input::PointerEventArgs> const*>(&handler)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall remove_PointerPressed(winrt::event_token token) noexcept final
        {
            typename D::abi_guard guard(this->shim());
            this->shim().PointerPressed(*reinterpret_cast<winrt::event_token const*>(&token));
            return 0;
        }
        int32_t __stdcall add_PointerReleased(void* handler, winrt::event_token* token) noexcept final try
        {
            zero_abi<winrt::event_token>(token);
            typename D::abi_guard guard(this->shim());
            *token = detach_from<winrt::event_token>(this->shim().PointerReleased(*reinterpret_cast<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Input::InputPointerSource, winrt::Microsoft::UI::Input::PointerEventArgs> const*>(&handler)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall remove_PointerReleased(winrt::event_token token) noexcept final
        {
            typename D::abi_guard guard(this->shim());
            this->shim().PointerReleased(*reinterpret_cast<winrt::event_token const*>(&token));
            return 0;
        }
        int32_t __stdcall add_PointerRoutedAway(void* handler, winrt::event_token* token) noexcept final try
        {
            zero_abi<winrt::event_token>(token);
            typename D::abi_guard guard(this->shim());
            *token = detach_from<winrt::event_token>(this->shim().PointerRoutedAway(*reinterpret_cast<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Input::InputPointerSource, winrt::Microsoft::UI::Input::PointerEventArgs> const*>(&handler)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall remove_PointerRoutedAway(winrt::event_token token) noexcept final
        {
            typename D::abi_guard guard(this->shim());
            this->shim().PointerRoutedAway(*reinterpret_cast<winrt::event_token const*>(&token));
            return 0;
        }
        int32_t __stdcall add_PointerRoutedReleased(void* handler, winrt::event_token* token) noexcept final try
        {
            zero_abi<winrt::event_token>(token);
            typename D::abi_guard guard(this->shim());
            *token = detach_from<winrt::event_token>(this->shim().PointerRoutedReleased(*reinterpret_cast<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Input::InputPointerSource, winrt::Microsoft::UI::Input::PointerEventArgs> const*>(&handler)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall remove_PointerRoutedReleased(winrt::event_token token) noexcept final
        {
            typename D::abi_guard guard(this->shim());
            this->shim().PointerRoutedReleased(*reinterpret_cast<winrt::event_token const*>(&token));
            return 0;
        }
        int32_t __stdcall add_PointerRoutedTo(void* handler, winrt::event_token* token) noexcept final try
        {
            zero_abi<winrt::event_token>(token);
            typename D::abi_guard guard(this->shim());
            *token = detach_from<winrt::event_token>(this->shim().PointerRoutedTo(*reinterpret_cast<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Input::InputPointerSource, winrt::Microsoft::UI::Input::PointerEventArgs> const*>(&handler)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall remove_PointerRoutedTo(winrt::event_token token) noexcept final
        {
            typename D::abi_guard guard(this->shim());
            this->shim().PointerRoutedTo(*reinterpret_cast<winrt::event_token const*>(&token));
            return 0;
        }
        int32_t __stdcall add_PointerWheelChanged(void* handler, winrt::event_token* token) noexcept final try
        {
            zero_abi<winrt::event_token>(token);
            typename D::abi_guard guard(this->shim());
            *token = detach_from<winrt::event_token>(this->shim().PointerWheelChanged(*reinterpret_cast<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Input::InputPointerSource, winrt::Microsoft::UI::Input::PointerEventArgs> const*>(&handler)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall remove_PointerWheelChanged(winrt::event_token token) noexcept final
        {
            typename D::abi_guard guard(this->shim());
            this->shim().PointerWheelChanged(*reinterpret_cast<winrt::event_token const*>(&token));
            return 0;
        }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Input::IInputPointerSourceStatics> : produce_base<D, winrt::Microsoft::UI::Input::IInputPointerSourceStatics>
    {
        int32_t __stdcall GetForIsland(void* island, void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Microsoft::UI::Input::InputPointerSource>(this->shim().GetForIsland(*reinterpret_cast<winrt::Microsoft::UI::Content::ContentIsland const*>(&island)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Input::IInputPreTranslateKeyboardSource> : produce_base<D, winrt::Microsoft::UI::Input::IInputPreTranslateKeyboardSource>
    {
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Input::IInputPreTranslateKeyboardSourceStatics> : produce_base<D, winrt::Microsoft::UI::Input::IInputPreTranslateKeyboardSourceStatics>
    {
        int32_t __stdcall GetForIsland(void* island, void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Microsoft::UI::Input::InputPreTranslateKeyboardSource>(this->shim().GetForIsland(*reinterpret_cast<winrt::Microsoft::UI::Content::ContentIsland const*>(&island)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Input::IInputSystemCursor> : produce_base<D, winrt::Microsoft::UI::Input::IInputSystemCursor>
    {
        int32_t __stdcall get_CursorShape(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::UI::Input::InputSystemCursorShape>(this->shim().CursorShape());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Input::IInputSystemCursorStatics> : produce_base<D, winrt::Microsoft::UI::Input::IInputSystemCursorStatics>
    {
        int32_t __stdcall Create(int32_t type, void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Microsoft::UI::Input::InputSystemCursor>(this->shim().Create(*reinterpret_cast<winrt::Microsoft::UI::Input::InputSystemCursorShape const*>(&type)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Input::IKeyEventArgs> : produce_base<D, winrt::Microsoft::UI::Input::IKeyEventArgs>
    {
        int32_t __stdcall get_Handled(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().Handled());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_Handled(bool value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Handled(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_KeyStatus(struct struct_Microsoft_UI_Input_PhysicalKeyStatus* value) noexcept final try
        {
            zero_abi<winrt::Microsoft::UI::Input::PhysicalKeyStatus>(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::UI::Input::PhysicalKeyStatus>(this->shim().KeyStatus());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Timestamp(uint64_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<uint64_t>(this->shim().Timestamp());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_VirtualKey(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::System::VirtualKey>(this->shim().VirtualKey());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Input::IManipulationCompletedEventArgs> : produce_base<D, winrt::Microsoft::UI::Input::IManipulationCompletedEventArgs>
    {
        int32_t __stdcall get_Cumulative(struct struct_Microsoft_UI_Input_ManipulationDelta* value) noexcept final try
        {
            zero_abi<winrt::Microsoft::UI::Input::ManipulationDelta>(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::UI::Input::ManipulationDelta>(this->shim().Cumulative());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_PointerDeviceType(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::UI::Input::PointerDeviceType>(this->shim().PointerDeviceType());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Position(winrt::Windows::Foundation::Point* value) noexcept final try
        {
            zero_abi<winrt::Windows::Foundation::Point>(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::Point>(this->shim().Position());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Velocities(struct struct_Microsoft_UI_Input_ManipulationVelocities* value) noexcept final try
        {
            zero_abi<winrt::Microsoft::UI::Input::ManipulationVelocities>(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::UI::Input::ManipulationVelocities>(this->shim().Velocities());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Input::IManipulationInertiaStartingEventArgs> : produce_base<D, winrt::Microsoft::UI::Input::IManipulationInertiaStartingEventArgs>
    {
        int32_t __stdcall get_Cumulative(struct struct_Microsoft_UI_Input_ManipulationDelta* value) noexcept final try
        {
            zero_abi<winrt::Microsoft::UI::Input::ManipulationDelta>(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::UI::Input::ManipulationDelta>(this->shim().Cumulative());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Delta(struct struct_Microsoft_UI_Input_ManipulationDelta* value) noexcept final try
        {
            zero_abi<winrt::Microsoft::UI::Input::ManipulationDelta>(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::UI::Input::ManipulationDelta>(this->shim().Delta());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_PointerDeviceType(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::UI::Input::PointerDeviceType>(this->shim().PointerDeviceType());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Position(winrt::Windows::Foundation::Point* value) noexcept final try
        {
            zero_abi<winrt::Windows::Foundation::Point>(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::Point>(this->shim().Position());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Velocities(struct struct_Microsoft_UI_Input_ManipulationVelocities* value) noexcept final try
        {
            zero_abi<winrt::Microsoft::UI::Input::ManipulationVelocities>(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::UI::Input::ManipulationVelocities>(this->shim().Velocities());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Input::IManipulationStartedEventArgs> : produce_base<D, winrt::Microsoft::UI::Input::IManipulationStartedEventArgs>
    {
        int32_t __stdcall get_Cumulative(struct struct_Microsoft_UI_Input_ManipulationDelta* value) noexcept final try
        {
            zero_abi<winrt::Microsoft::UI::Input::ManipulationDelta>(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::UI::Input::ManipulationDelta>(this->shim().Cumulative());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_PointerDeviceType(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::UI::Input::PointerDeviceType>(this->shim().PointerDeviceType());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Position(winrt::Windows::Foundation::Point* value) noexcept final try
        {
            zero_abi<winrt::Windows::Foundation::Point>(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::Point>(this->shim().Position());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Input::IManipulationUpdatedEventArgs> : produce_base<D, winrt::Microsoft::UI::Input::IManipulationUpdatedEventArgs>
    {
        int32_t __stdcall get_Cumulative(struct struct_Microsoft_UI_Input_ManipulationDelta* value) noexcept final try
        {
            zero_abi<winrt::Microsoft::UI::Input::ManipulationDelta>(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::UI::Input::ManipulationDelta>(this->shim().Cumulative());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Delta(struct struct_Microsoft_UI_Input_ManipulationDelta* value) noexcept final try
        {
            zero_abi<winrt::Microsoft::UI::Input::ManipulationDelta>(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::UI::Input::ManipulationDelta>(this->shim().Delta());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_PointerDeviceType(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::UI::Input::PointerDeviceType>(this->shim().PointerDeviceType());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Position(winrt::Windows::Foundation::Point* value) noexcept final try
        {
            zero_abi<winrt::Windows::Foundation::Point>(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::Point>(this->shim().Position());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Velocities(struct struct_Microsoft_UI_Input_ManipulationVelocities* value) noexcept final try
        {
            zero_abi<winrt::Microsoft::UI::Input::ManipulationVelocities>(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::UI::Input::ManipulationVelocities>(this->shim().Velocities());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Input::IMouseWheelParameters> : produce_base<D, winrt::Microsoft::UI::Input::IMouseWheelParameters>
    {
        int32_t __stdcall get_CharTranslation(winrt::Windows::Foundation::Point* value) noexcept final try
        {
            zero_abi<winrt::Windows::Foundation::Point>(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::Point>(this->shim().CharTranslation());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_CharTranslation(winrt::Windows::Foundation::Point value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().CharTranslation(*reinterpret_cast<winrt::Windows::Foundation::Point const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_DeltaScale(float* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<float>(this->shim().DeltaScale());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_DeltaScale(float value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().DeltaScale(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_DeltaRotationAngle(float* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<float>(this->shim().DeltaRotationAngle());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_DeltaRotationAngle(float value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().DeltaRotationAngle(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_PageTranslation(winrt::Windows::Foundation::Point* value) noexcept final try
        {
            zero_abi<winrt::Windows::Foundation::Point>(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::Point>(this->shim().PageTranslation());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_PageTranslation(winrt::Windows::Foundation::Point value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().PageTranslation(*reinterpret_cast<winrt::Windows::Foundation::Point const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Input::INonClientCaptionTappedEventArgs> : produce_base<D, winrt::Microsoft::UI::Input::INonClientCaptionTappedEventArgs>
    {
        int32_t __stdcall get_Point(winrt::Windows::Foundation::Point* value) noexcept final try
        {
            zero_abi<winrt::Windows::Foundation::Point>(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::Point>(this->shim().Point());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_PointerDeviceType(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::UI::Input::PointerDeviceType>(this->shim().PointerDeviceType());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Input::INonClientPointerEventArgs> : produce_base<D, winrt::Microsoft::UI::Input::INonClientPointerEventArgs>
    {
        int32_t __stdcall get_Point(winrt::Windows::Foundation::Point* value) noexcept final try
        {
            zero_abi<winrt::Windows::Foundation::Point>(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::Point>(this->shim().Point());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_PointerDeviceType(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::UI::Input::PointerDeviceType>(this->shim().PointerDeviceType());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_RegionKind(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::UI::Input::NonClientRegionKind>(this->shim().RegionKind());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_IsPointInRegion(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().IsPointInRegion());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Input::INonClientRegionsChangedEventArgs> : produce_base<D, winrt::Microsoft::UI::Input::INonClientRegionsChangedEventArgs>
    {
        int32_t __stdcall get_ChangedRegions(uint32_t* __valueSize, int32_t** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            std::tie(*__valueSize, *value) = detach_abi(this->shim().ChangedRegions());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Input::IPointerEventArgs> : produce_base<D, winrt::Microsoft::UI::Input::IPointerEventArgs>
    {
        int32_t __stdcall get_CurrentPoint(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::UI::Input::PointerPoint>(this->shim().CurrentPoint());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Handled(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().Handled());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_Handled(bool value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Handled(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_KeyModifiers(uint32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::System::VirtualKeyModifiers>(this->shim().KeyModifiers());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall GetIntermediatePoints(void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Windows::Foundation::Collections::IVector<winrt::Microsoft::UI::Input::PointerPoint>>(this->shim().GetIntermediatePoints());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall GetIntermediateTransformedPoints(void* transform, void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Windows::Foundation::Collections::IVector<winrt::Microsoft::UI::Input::PointerPoint>>(this->shim().GetIntermediateTransformedPoints(*reinterpret_cast<winrt::Microsoft::UI::Input::IPointerPointTransform const*>(&transform)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Input::IPointerPoint> : produce_base<D, winrt::Microsoft::UI::Input::IPointerPoint>
    {
        int32_t __stdcall get_FrameId(uint32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<uint32_t>(this->shim().FrameId());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_IsInContact(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().IsInContact());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_PointerDeviceType(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::UI::Input::PointerDeviceType>(this->shim().PointerDeviceType());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_PointerId(uint32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<uint32_t>(this->shim().PointerId());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Position(winrt::Windows::Foundation::Point* value) noexcept final try
        {
            zero_abi<winrt::Windows::Foundation::Point>(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::Point>(this->shim().Position());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Properties(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::UI::Input::PointerPointProperties>(this->shim().Properties());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Timestamp(uint64_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<uint64_t>(this->shim().Timestamp());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall GetTransformedPoint(void* transform, void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Microsoft::UI::Input::PointerPoint>(this->shim().GetTransformedPoint(*reinterpret_cast<winrt::Microsoft::UI::Input::IPointerPointTransform const*>(&transform)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Input::IPointerPointProperties> : produce_base<D, winrt::Microsoft::UI::Input::IPointerPointProperties>
    {
        int32_t __stdcall get_ContactRect(winrt::Windows::Foundation::Rect* value) noexcept final try
        {
            zero_abi<winrt::Windows::Foundation::Rect>(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::Rect>(this->shim().ContactRect());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_IsBarrelButtonPressed(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().IsBarrelButtonPressed());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_IsCanceled(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().IsCanceled());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_IsEraser(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().IsEraser());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_IsHorizontalMouseWheel(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().IsHorizontalMouseWheel());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_IsInRange(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().IsInRange());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_IsInverted(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().IsInverted());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_IsLeftButtonPressed(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().IsLeftButtonPressed());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_IsMiddleButtonPressed(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().IsMiddleButtonPressed());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_IsPrimary(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().IsPrimary());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_IsRightButtonPressed(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().IsRightButtonPressed());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_IsXButton1Pressed(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().IsXButton1Pressed());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_IsXButton2Pressed(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().IsXButton2Pressed());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_MouseWheelDelta(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<int32_t>(this->shim().MouseWheelDelta());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Orientation(float* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<float>(this->shim().Orientation());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_PointerUpdateKind(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::UI::Input::PointerUpdateKind>(this->shim().PointerUpdateKind());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Pressure(float* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<float>(this->shim().Pressure());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_TouchConfidence(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().TouchConfidence());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Twist(float* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<float>(this->shim().Twist());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_XTilt(float* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<float>(this->shim().XTilt());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_YTilt(float* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<float>(this->shim().YTilt());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Input::IPointerPointTransform> : produce_base<D, winrt::Microsoft::UI::Input::IPointerPointTransform>
    {
        int32_t __stdcall get_Inverse(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::UI::Input::IPointerPointTransform>(this->shim().Inverse());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall TryTransform(winrt::Windows::Foundation::Point inPoint, winrt::Windows::Foundation::Point* outPoint, bool* result) noexcept final try
        {
            zero_abi<winrt::Windows::Foundation::Point>(outPoint);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<bool>(this->shim().TryTransform(*reinterpret_cast<winrt::Windows::Foundation::Point const*>(&inPoint), *reinterpret_cast<winrt::Windows::Foundation::Point*>(outPoint)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall TryTransformBounds(winrt::Windows::Foundation::Rect inRect, winrt::Windows::Foundation::Rect* outRect, bool* result) noexcept final try
        {
            zero_abi<winrt::Windows::Foundation::Rect>(outRect);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<bool>(this->shim().TryTransformBounds(*reinterpret_cast<winrt::Windows::Foundation::Rect const*>(&inRect), *reinterpret_cast<winrt::Windows::Foundation::Rect*>(outRect)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Input::IPointerPredictor> : produce_base<D, winrt::Microsoft::UI::Input::IPointerPredictor>
    {
        int32_t __stdcall get_PredictionTime(int64_t* value) noexcept final try
        {
            zero_abi<winrt::Windows::Foundation::TimeSpan>(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::TimeSpan>(this->shim().PredictionTime());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_PredictionTime(int64_t value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().PredictionTime(*reinterpret_cast<winrt::Windows::Foundation::TimeSpan const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall GetPredictedPoints(void* point, uint32_t* __resultSize, void*** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            std::tie(*__resultSize, *result) = detach_abi(this->shim().GetPredictedPoints(*reinterpret_cast<winrt::Microsoft::UI::Input::PointerPoint const*>(&point)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Input::IPointerPredictorStatics> : produce_base<D, winrt::Microsoft::UI::Input::IPointerPredictorStatics>
    {
        int32_t __stdcall CreateForInputPointerSource(void* inputPointerSource, void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Microsoft::UI::Input::PointerPredictor>(this->shim().CreateForInputPointerSource(*reinterpret_cast<winrt::Microsoft::UI::Input::InputPointerSource const*>(&inputPointerSource)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Input::IRightTappedEventArgs> : produce_base<D, winrt::Microsoft::UI::Input::IRightTappedEventArgs>
    {
        int32_t __stdcall get_PointerDeviceType(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::UI::Input::PointerDeviceType>(this->shim().PointerDeviceType());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Position(winrt::Windows::Foundation::Point* value) noexcept final try
        {
            zero_abi<winrt::Windows::Foundation::Point>(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::Point>(this->shim().Position());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Input::ITappedEventArgs> : produce_base<D, winrt::Microsoft::UI::Input::ITappedEventArgs>
    {
        int32_t __stdcall get_PointerDeviceType(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::UI::Input::PointerDeviceType>(this->shim().PointerDeviceType());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Position(winrt::Windows::Foundation::Point* value) noexcept final try
        {
            zero_abi<winrt::Windows::Foundation::Point>(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::Point>(this->shim().Position());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_TapCount(uint32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<uint32_t>(this->shim().TapCount());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Input::IWindowRectChangedEventArgs> : produce_base<D, winrt::Microsoft::UI::Input::IWindowRectChangedEventArgs>
    {
        int32_t __stdcall get_PointerScreenPoint(struct struct_Windows_Graphics_PointInt32* value) noexcept final try
        {
            zero_abi<winrt::Windows::Graphics::PointInt32>(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Graphics::PointInt32>(this->shim().PointerScreenPoint());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_MoveSizeOperation(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::UI::Input::MoveSizeOperation>(this->shim().MoveSizeOperation());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_OldWindowRect(struct struct_Windows_Graphics_RectInt32* value) noexcept final try
        {
            zero_abi<winrt::Windows::Graphics::RectInt32>(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Graphics::RectInt32>(this->shim().OldWindowRect());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_NewWindowRect(struct struct_Windows_Graphics_RectInt32* value) noexcept final try
        {
            zero_abi<winrt::Windows::Graphics::RectInt32>(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Graphics::RectInt32>(this->shim().NewWindowRect());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Input::IWindowRectChangingEventArgs> : produce_base<D, winrt::Microsoft::UI::Input::IWindowRectChangingEventArgs>
    {
        int32_t __stdcall get_PointerScreenPoint(struct struct_Windows_Graphics_PointInt32* value) noexcept final try
        {
            zero_abi<winrt::Windows::Graphics::PointInt32>(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Graphics::PointInt32>(this->shim().PointerScreenPoint());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_MoveSizeOperation(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::UI::Input::MoveSizeOperation>(this->shim().MoveSizeOperation());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_OldWindowRect(struct struct_Windows_Graphics_RectInt32* value) noexcept final try
        {
            zero_abi<winrt::Windows::Graphics::RectInt32>(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Graphics::RectInt32>(this->shim().OldWindowRect());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_NewWindowRect(struct struct_Windows_Graphics_RectInt32* value) noexcept final try
        {
            zero_abi<winrt::Windows::Graphics::RectInt32>(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Graphics::RectInt32>(this->shim().NewWindowRect());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_NewWindowRect(struct struct_Windows_Graphics_RectInt32 value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().NewWindowRect(*reinterpret_cast<winrt::Windows::Graphics::RectInt32 const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_AllowRectChange(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().AllowRectChange());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_AllowRectChange(bool value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().AllowRectChange(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_ShowWindow(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().ShowWindow());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_ShowWindow(bool value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().ShowWindow(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
}
WINRT_EXPORT namespace winrt::Microsoft::UI::Input
{
    constexpr auto operator|(GestureSettings const left, GestureSettings const right) noexcept
    {
        return static_cast<GestureSettings>(impl::to_underlying_type(left) | impl::to_underlying_type(right));
    }
    constexpr auto operator|=(GestureSettings& left, GestureSettings const right) noexcept
    {
        left = left | right;
        return left;
    }
    constexpr auto operator&(GestureSettings const left, GestureSettings const right) noexcept
    {
        return static_cast<GestureSettings>(impl::to_underlying_type(left) & impl::to_underlying_type(right));
    }
    constexpr auto operator&=(GestureSettings& left, GestureSettings const right) noexcept
    {
        left = left & right;
        return left;
    }
    constexpr auto operator~(GestureSettings const value) noexcept
    {
        return static_cast<GestureSettings>(~impl::to_underlying_type(value));
    }
    constexpr auto operator^(GestureSettings const left, GestureSettings const right) noexcept
    {
        return static_cast<GestureSettings>(impl::to_underlying_type(left) ^ impl::to_underlying_type(right));
    }
    constexpr auto operator^=(GestureSettings& left, GestureSettings const right) noexcept
    {
        left = left ^ right;
        return left;
    }
    constexpr auto operator|(InputPointerSourceDeviceKinds const left, InputPointerSourceDeviceKinds const right) noexcept
    {
        return static_cast<InputPointerSourceDeviceKinds>(impl::to_underlying_type(left) | impl::to_underlying_type(right));
    }
    constexpr auto operator|=(InputPointerSourceDeviceKinds& left, InputPointerSourceDeviceKinds const right) noexcept
    {
        left = left | right;
        return left;
    }
    constexpr auto operator&(InputPointerSourceDeviceKinds const left, InputPointerSourceDeviceKinds const right) noexcept
    {
        return static_cast<InputPointerSourceDeviceKinds>(impl::to_underlying_type(left) & impl::to_underlying_type(right));
    }
    constexpr auto operator&=(InputPointerSourceDeviceKinds& left, InputPointerSourceDeviceKinds const right) noexcept
    {
        left = left & right;
        return left;
    }
    constexpr auto operator~(InputPointerSourceDeviceKinds const value) noexcept
    {
        return static_cast<InputPointerSourceDeviceKinds>(~impl::to_underlying_type(value));
    }
    constexpr auto operator^(InputPointerSourceDeviceKinds const left, InputPointerSourceDeviceKinds const right) noexcept
    {
        return static_cast<InputPointerSourceDeviceKinds>(impl::to_underlying_type(left) ^ impl::to_underlying_type(right));
    }
    constexpr auto operator^=(InputPointerSourceDeviceKinds& left, InputPointerSourceDeviceKinds const right) noexcept
    {
        left = left ^ right;
        return left;
    }
    constexpr auto operator|(VirtualKeyStates const left, VirtualKeyStates const right) noexcept
    {
        return static_cast<VirtualKeyStates>(impl::to_underlying_type(left) | impl::to_underlying_type(right));
    }
    constexpr auto operator|=(VirtualKeyStates& left, VirtualKeyStates const right) noexcept
    {
        left = left | right;
        return left;
    }
    constexpr auto operator&(VirtualKeyStates const left, VirtualKeyStates const right) noexcept
    {
        return static_cast<VirtualKeyStates>(impl::to_underlying_type(left) & impl::to_underlying_type(right));
    }
    constexpr auto operator&=(VirtualKeyStates& left, VirtualKeyStates const right) noexcept
    {
        left = left & right;
        return left;
    }
    constexpr auto operator~(VirtualKeyStates const value) noexcept
    {
        return static_cast<VirtualKeyStates>(~impl::to_underlying_type(value));
    }
    constexpr auto operator^(VirtualKeyStates const left, VirtualKeyStates const right) noexcept
    {
        return static_cast<VirtualKeyStates>(impl::to_underlying_type(left) ^ impl::to_underlying_type(right));
    }
    constexpr auto operator^=(VirtualKeyStates& left, VirtualKeyStates const right) noexcept
    {
        left = left ^ right;
        return left;
    }
    inline auto FocusNavigationRequest::Create(winrt::Microsoft::UI::Input::FocusNavigationReason const& reason)
    {
        return impl::call_factory<FocusNavigationRequest, IFocusNavigationRequestStatics>([&](IFocusNavigationRequestStatics const& f) { return f.Create(reason); });
    }
    inline auto FocusNavigationRequest::Create(winrt::Microsoft::UI::Input::FocusNavigationReason const& reason, winrt::Windows::Foundation::Rect const& hintRect)
    {
        return impl::call_factory<FocusNavigationRequest, IFocusNavigationRequestStatics>([&](IFocusNavigationRequestStatics const& f) { return f.Create(reason, hintRect); });
    }
    inline auto FocusNavigationRequest::Create(winrt::Microsoft::UI::Input::FocusNavigationReason const& reason, winrt::Windows::Foundation::Rect const& hintRect, winrt::guid const& correlationId)
    {
        return impl::call_factory<FocusNavigationRequest, IFocusNavigationRequestStatics>([&](IFocusNavigationRequestStatics const& f) { return f.Create(reason, hintRect, correlationId); });
    }
    inline GestureRecognizer::GestureRecognizer() :
        GestureRecognizer(impl::call_factory_cast<GestureRecognizer(*)(winrt::Windows::Foundation::IActivationFactory const&), GestureRecognizer>([](winrt::Windows::Foundation::IActivationFactory const& f) { return f.template ActivateInstance<GestureRecognizer>(); }))
    {
    }
    inline auto InputActivationListener::GetForWindowId(winrt::Microsoft::UI::WindowId const& windowId)
    {
        return impl::call_factory<InputActivationListener, IInputActivationListenerStatics>([&](IInputActivationListenerStatics const& f) { return f.GetForWindowId(windowId); });
    }
    inline auto InputActivationListener::GetForIsland(winrt::Microsoft::UI::Content::ContentIsland const& island)
    {
        return impl::call_factory<InputActivationListener, IInputActivationListenerStatics2>([&](IInputActivationListenerStatics2 const& f) { return f.GetForIsland(island); });
    }
    inline auto InputCursor::CreateFromCoreCursor(winrt::Windows::UI::Core::CoreCursor const& cursor)
    {
        return impl::call_factory<InputCursor, IInputCursorStatics>([&](IInputCursorStatics const& f) { return f.CreateFromCoreCursor(cursor); });
    }
    inline auto InputDesktopNamedResourceCursor::Create(param::hstring const& resourceName)
    {
        return impl::call_factory<InputDesktopNamedResourceCursor, IInputDesktopNamedResourceCursorStatics>([&](IInputDesktopNamedResourceCursorStatics const& f) { return f.Create(resourceName); });
    }
    inline auto InputDesktopNamedResourceCursor::CreateFromModule(param::hstring const& moduleName, param::hstring const& resourceName)
    {
        return impl::call_factory<InputDesktopNamedResourceCursor, IInputDesktopNamedResourceCursorStatics>([&](IInputDesktopNamedResourceCursorStatics const& f) { return f.CreateFromModule(moduleName, resourceName); });
    }
    inline auto InputDesktopResourceCursor::Create(uint32_t resourceId)
    {
        return impl::call_factory<InputDesktopResourceCursor, IInputDesktopResourceCursorStatics>([&](IInputDesktopResourceCursorStatics const& f) { return f.Create(resourceId); });
    }
    inline auto InputDesktopResourceCursor::CreateFromModule(param::hstring const& moduleName, uint32_t resourceId)
    {
        return impl::call_factory<InputDesktopResourceCursor, IInputDesktopResourceCursorStatics>([&](IInputDesktopResourceCursorStatics const& f) { return f.CreateFromModule(moduleName, resourceId); });
    }
    inline auto InputFocusController::GetForIsland(winrt::Microsoft::UI::Content::ContentIsland const& island)
    {
        return impl::call_factory<InputFocusController, IInputFocusControllerStatics>([&](IInputFocusControllerStatics const& f) { return f.GetForIsland(island); });
    }
    inline auto InputFocusNavigationHost::GetForSiteBridge(winrt::Microsoft::UI::Content::IContentSiteBridge const& site)
    {
        return impl::call_factory<InputFocusNavigationHost, IInputFocusNavigationHostStatics>([&](IInputFocusNavigationHostStatics const& f) { return f.GetForSiteBridge(site); });
    }
    inline auto InputFocusNavigationHost::GetForSiteLink(winrt::Microsoft::UI::Content::IContentSiteLink const& contentSiteLink)
    {
        return impl::call_factory<InputFocusNavigationHost, IInputFocusNavigationHostStatics2>([&](IInputFocusNavigationHostStatics2 const& f) { return f.GetForSiteLink(contentSiteLink); });
    }
    inline auto InputKeyboardSource::GetKeyStateForCurrentThread(winrt::Windows::System::VirtualKey const& virtualKey)
    {
        return impl::call_factory<InputKeyboardSource, IInputKeyboardSourceStatics>([&](IInputKeyboardSourceStatics const& f) { return f.GetKeyStateForCurrentThread(virtualKey); });
    }
    inline auto InputKeyboardSource::GetForIsland(winrt::Microsoft::UI::Content::ContentIsland const& island)
    {
        return impl::call_factory<InputKeyboardSource, IInputKeyboardSourceStatics2>([&](IInputKeyboardSourceStatics2 const& f) { return f.GetForIsland(island); });
    }
    inline auto InputLightDismissAction::GetForWindowId(winrt::Microsoft::UI::WindowId const& windowId)
    {
        return impl::call_factory<InputLightDismissAction, IInputLightDismissActionStatics>([&](IInputLightDismissActionStatics const& f) { return f.GetForWindowId(windowId); });
    }
    inline auto InputNonClientPointerSource::GetForWindowId(winrt::Microsoft::UI::WindowId const& windowId)
    {
        return impl::call_factory<InputNonClientPointerSource, IInputNonClientPointerSourceStatics>([&](IInputNonClientPointerSourceStatics const& f) { return f.GetForWindowId(windowId); });
    }
    inline auto InputPointerSource::GetForIsland(winrt::Microsoft::UI::Content::ContentIsland const& island)
    {
        return impl::call_factory<InputPointerSource, IInputPointerSourceStatics>([&](IInputPointerSourceStatics const& f) { return f.GetForIsland(island); });
    }
    inline auto InputPreTranslateKeyboardSource::GetForIsland(winrt::Microsoft::UI::Content::ContentIsland const& island)
    {
        return impl::call_factory<InputPreTranslateKeyboardSource, IInputPreTranslateKeyboardSourceStatics>([&](IInputPreTranslateKeyboardSourceStatics const& f) { return f.GetForIsland(island); });
    }
    inline auto InputSystemCursor::Create(winrt::Microsoft::UI::Input::InputSystemCursorShape const& type)
    {
        return impl::call_factory<InputSystemCursor, IInputSystemCursorStatics>([&](IInputSystemCursorStatics const& f) { return f.Create(type); });
    }
    inline auto PointerPredictor::CreateForInputPointerSource(winrt::Microsoft::UI::Input::InputPointerSource const& inputPointerSource)
    {
        return impl::call_factory<PointerPredictor, IPointerPredictorStatics>([&](IPointerPredictorStatics const& f) { return f.CreateForInputPointerSource(inputPointerSource); });
    }
}
namespace std
{
#ifndef WINRT_LEAN_AND_MEAN
    template<> struct hash<winrt::Microsoft::UI::Input::ICharacterReceivedEventArgs> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Input::IContextMenuKeyEventArgs> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Input::ICrossSlidingEventArgs> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Input::IDraggingEventArgs> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Input::IEnteredMoveSizeEventArgs> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Input::IEnteringMoveSizeEventArgs> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Input::IExitedMoveSizeEventArgs> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Input::IFocusChangedEventArgs> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Input::IFocusNavigationRequest> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Input::IFocusNavigationRequestEventArgs> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Input::IFocusNavigationRequestStatics> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Input::IGestureRecognizer> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Input::IHoldingEventArgs> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Input::IInputActivationListener> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Input::IInputActivationListenerActivationChangedEventArgs> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Input::IInputActivationListenerStatics> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Input::IInputActivationListenerStatics2> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Input::IInputCursor> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Input::IInputCursorFactory> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Input::IInputCursorStatics> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Input::IInputCustomCursor> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Input::IInputCustomCursorFactory> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Input::IInputDesktopNamedResourceCursor> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Input::IInputDesktopNamedResourceCursorStatics> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Input::IInputDesktopResourceCursor> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Input::IInputDesktopResourceCursorStatics> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Input::IInputFocusController> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Input::IInputFocusController2> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Input::IInputFocusControllerStatics> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Input::IInputFocusNavigationHost> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Input::IInputFocusNavigationHostStatics> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Input::IInputFocusNavigationHostStatics2> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Input::IInputKeyboardSource> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Input::IInputKeyboardSource2> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Input::IInputKeyboardSourceStatics> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Input::IInputKeyboardSourceStatics2> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Input::IInputLightDismissAction> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Input::IInputLightDismissActionStatics> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Input::IInputLightDismissEventArgs> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Input::IInputNonClientPointerSource> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Input::IInputNonClientPointerSource2> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Input::IInputNonClientPointerSourceStatics> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Input::IInputObject> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Input::IInputObjectFactory> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Input::IInputPointerSource> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Input::IInputPointerSourceStatics> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Input::IInputPreTranslateKeyboardSource> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Input::IInputPreTranslateKeyboardSourceStatics> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Input::IInputSystemCursor> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Input::IInputSystemCursorStatics> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Input::IKeyEventArgs> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Input::IManipulationCompletedEventArgs> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Input::IManipulationInertiaStartingEventArgs> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Input::IManipulationStartedEventArgs> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Input::IManipulationUpdatedEventArgs> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Input::IMouseWheelParameters> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Input::INonClientCaptionTappedEventArgs> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Input::INonClientPointerEventArgs> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Input::INonClientRegionsChangedEventArgs> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Input::IPointerEventArgs> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Input::IPointerPoint> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Input::IPointerPointProperties> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Input::IPointerPointTransform> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Input::IPointerPredictor> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Input::IPointerPredictorStatics> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Input::IRightTappedEventArgs> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Input::ITappedEventArgs> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Input::IWindowRectChangedEventArgs> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Input::IWindowRectChangingEventArgs> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Input::CharacterReceivedEventArgs> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Input::ContextMenuKeyEventArgs> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Input::CrossSlidingEventArgs> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Input::DraggingEventArgs> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Input::EnteredMoveSizeEventArgs> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Input::EnteringMoveSizeEventArgs> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Input::ExitedMoveSizeEventArgs> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Input::FocusChangedEventArgs> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Input::FocusNavigationRequest> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Input::FocusNavigationRequestEventArgs> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Input::GestureRecognizer> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Input::HoldingEventArgs> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Input::InputActivationListener> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Input::InputActivationListenerActivationChangedEventArgs> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Input::InputCursor> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Input::InputCustomCursor> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Input::InputDesktopNamedResourceCursor> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Input::InputDesktopResourceCursor> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Input::InputFocusController> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Input::InputFocusNavigationHost> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Input::InputKeyboardSource> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Input::InputLightDismissAction> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Input::InputLightDismissEventArgs> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Input::InputNonClientPointerSource> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Input::InputObject> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Input::InputPointerSource> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Input::InputPreTranslateKeyboardSource> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Input::InputSystemCursor> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Input::KeyEventArgs> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Input::ManipulationCompletedEventArgs> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Input::ManipulationInertiaStartingEventArgs> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Input::ManipulationStartedEventArgs> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Input::ManipulationUpdatedEventArgs> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Input::MouseWheelParameters> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Input::NonClientCaptionTappedEventArgs> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Input::NonClientPointerEventArgs> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Input::NonClientRegionsChangedEventArgs> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Input::PointerEventArgs> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Input::PointerPoint> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Input::PointerPointProperties> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Input::PointerPredictor> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Input::RightTappedEventArgs> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Input::TappedEventArgs> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Input::WindowRectChangedEventArgs> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Input::WindowRectChangingEventArgs> : winrt::impl::hash_base {};
#endif
#ifdef __cpp_lib_format
#endif
}
#endif
