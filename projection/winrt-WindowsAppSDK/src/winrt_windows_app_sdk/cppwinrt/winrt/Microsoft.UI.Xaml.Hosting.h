// WARNING: Please don't edit this file. It was generated by C++/WinRT v2.0.250303.1

#pragma once
#ifndef WINRT_Microsoft_UI_Xaml_Hosting_H
#define WINRT_Microsoft_UI_Xaml_Hosting_H
#include "winrt/base.h"
static_assert(winrt::check_version(CPPWINRT_VERSION, "2.0.250303.1"), "Mismatched C++/WinRT headers.");
#define CPPWINRT_VERSION "2.0.250303.1"
#include "winrt/Microsoft.UI.Xaml.h"
#include "winrt/impl/Microsoft.UI.2.h"
#include "winrt/impl/Microsoft.UI.Composition.2.h"
#include "winrt/impl/Microsoft.UI.Content.2.h"
#include "winrt/impl/Microsoft.UI.Xaml.2.h"
#include "winrt/impl/Microsoft.UI.Xaml.Controls.2.h"
#include "winrt/impl/Microsoft.UI.Xaml.Media.2.h"
#include "winrt/impl/Windows.Foundation.2.h"
#include "winrt/impl/Microsoft.UI.Xaml.Hosting.2.h"
namespace winrt::impl
{
    template <typename D> auto consume_Microsoft_UI_Xaml_Hosting_IDesktopWindowXamlSource<D>::Content() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Hosting::IDesktopWindowXamlSource>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Hosting::IDesktopWindowXamlSource, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Hosting::IDesktopWindowXamlSource>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Content(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Hosting::IDesktopWindowXamlSource>**)this;
            check_hresult(_winrt_abi_type->get_Content(&value));
        }
        return winrt::Microsoft::UI::Xaml::UIElement{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Hosting_IDesktopWindowXamlSource<D>::Content(winrt::Microsoft::UI::Xaml::UIElement const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Hosting::IDesktopWindowXamlSource>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Hosting::IDesktopWindowXamlSource, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Hosting::IDesktopWindowXamlSource>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_Content(*(void**)(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Hosting::IDesktopWindowXamlSource>**)this;
            check_hresult(_winrt_abi_type->put_Content(*(void**)(&value)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Hosting_IDesktopWindowXamlSource<D>::HasFocus() const
    {
        bool value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Hosting::IDesktopWindowXamlSource>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Hosting::IDesktopWindowXamlSource, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Hosting::IDesktopWindowXamlSource>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_HasFocus(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Hosting::IDesktopWindowXamlSource>**)this;
            check_hresult(_winrt_abi_type->get_HasFocus(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Hosting_IDesktopWindowXamlSource<D>::SystemBackdrop() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Hosting::IDesktopWindowXamlSource>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Hosting::IDesktopWindowXamlSource, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Hosting::IDesktopWindowXamlSource>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_SystemBackdrop(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Hosting::IDesktopWindowXamlSource>**)this;
            check_hresult(_winrt_abi_type->get_SystemBackdrop(&value));
        }
        return winrt::Microsoft::UI::Xaml::Media::SystemBackdrop{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Hosting_IDesktopWindowXamlSource<D>::SystemBackdrop(winrt::Microsoft::UI::Xaml::Media::SystemBackdrop const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Hosting::IDesktopWindowXamlSource>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Hosting::IDesktopWindowXamlSource, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Hosting::IDesktopWindowXamlSource>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_SystemBackdrop(*(void**)(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Hosting::IDesktopWindowXamlSource>**)this;
            check_hresult(_winrt_abi_type->put_SystemBackdrop(*(void**)(&value)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Hosting_IDesktopWindowXamlSource<D>::SiteBridge() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Hosting::IDesktopWindowXamlSource>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Hosting::IDesktopWindowXamlSource, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Hosting::IDesktopWindowXamlSource>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_SiteBridge(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Hosting::IDesktopWindowXamlSource>**)this;
            check_hresult(_winrt_abi_type->get_SiteBridge(&value));
        }
        return winrt::Microsoft::UI::Content::DesktopChildSiteBridge{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Hosting_IDesktopWindowXamlSource<D>::TakeFocusRequested(winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Hosting::DesktopWindowXamlSource, winrt::Microsoft::UI::Xaml::Hosting::DesktopWindowXamlSourceTakeFocusRequestedEventArgs> const& handler) const
    {
        winrt::event_token token{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Hosting::IDesktopWindowXamlSource>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Hosting::IDesktopWindowXamlSource, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Hosting::IDesktopWindowXamlSource>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->add_TakeFocusRequested(*(void**)(&handler), put_abi(token)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Hosting::IDesktopWindowXamlSource>**)this;
            check_hresult(_winrt_abi_type->add_TakeFocusRequested(*(void**)(&handler), put_abi(token)));
        }
        return token;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Hosting_IDesktopWindowXamlSource<D>::TakeFocusRequested(auto_revoke_t, winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Hosting::DesktopWindowXamlSource, winrt::Microsoft::UI::Xaml::Hosting::DesktopWindowXamlSourceTakeFocusRequestedEventArgs> const& handler) const
    {
        return impl::make_event_revoker<D, TakeFocusRequested_revoker>(this, TakeFocusRequested(handler));
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Hosting_IDesktopWindowXamlSource<D>::TakeFocusRequested(winrt::event_token const& token) const noexcept
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Hosting::IDesktopWindowXamlSource>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Hosting::IDesktopWindowXamlSource, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Hosting::IDesktopWindowXamlSource>**)&_winrt_casted_result;
            _winrt_abi_type->remove_TakeFocusRequested(impl::bind_in(token));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Hosting::IDesktopWindowXamlSource>**)this;
            _winrt_abi_type->remove_TakeFocusRequested(impl::bind_in(token));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Hosting_IDesktopWindowXamlSource<D>::GotFocus(winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Hosting::DesktopWindowXamlSource, winrt::Microsoft::UI::Xaml::Hosting::DesktopWindowXamlSourceGotFocusEventArgs> const& handler) const
    {
        winrt::event_token token{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Hosting::IDesktopWindowXamlSource>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Hosting::IDesktopWindowXamlSource, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Hosting::IDesktopWindowXamlSource>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->add_GotFocus(*(void**)(&handler), put_abi(token)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Hosting::IDesktopWindowXamlSource>**)this;
            check_hresult(_winrt_abi_type->add_GotFocus(*(void**)(&handler), put_abi(token)));
        }
        return token;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Hosting_IDesktopWindowXamlSource<D>::GotFocus(auto_revoke_t, winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Hosting::DesktopWindowXamlSource, winrt::Microsoft::UI::Xaml::Hosting::DesktopWindowXamlSourceGotFocusEventArgs> const& handler) const
    {
        return impl::make_event_revoker<D, GotFocus_revoker>(this, GotFocus(handler));
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Hosting_IDesktopWindowXamlSource<D>::GotFocus(winrt::event_token const& token) const noexcept
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Hosting::IDesktopWindowXamlSource>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Hosting::IDesktopWindowXamlSource, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Hosting::IDesktopWindowXamlSource>**)&_winrt_casted_result;
            _winrt_abi_type->remove_GotFocus(impl::bind_in(token));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Hosting::IDesktopWindowXamlSource>**)this;
            _winrt_abi_type->remove_GotFocus(impl::bind_in(token));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Hosting_IDesktopWindowXamlSource<D>::NavigateFocus(winrt::Microsoft::UI::Xaml::Hosting::XamlSourceFocusNavigationRequest const& request) const
    {
        void* result{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Hosting::IDesktopWindowXamlSource>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Hosting::IDesktopWindowXamlSource, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Hosting::IDesktopWindowXamlSource>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->NavigateFocus(*(void**)(&request), &result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Hosting::IDesktopWindowXamlSource>**)this;
            check_hresult(_winrt_abi_type->NavigateFocus(*(void**)(&request), &result));
        }
        return winrt::Microsoft::UI::Xaml::Hosting::XamlSourceFocusNavigationResult{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Hosting_IDesktopWindowXamlSource<D>::Initialize(winrt::Microsoft::UI::WindowId const& parentWindowId) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Hosting::IDesktopWindowXamlSource>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Hosting::IDesktopWindowXamlSource, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Hosting::IDesktopWindowXamlSource>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->Initialize(impl::bind_in(parentWindowId)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Hosting::IDesktopWindowXamlSource>**)this;
            check_hresult(_winrt_abi_type->Initialize(impl::bind_in(parentWindowId)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Hosting_IDesktopWindowXamlSource2<D>::ShouldConstrainPopupsToWorkArea() const
    {
        bool value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Hosting::IDesktopWindowXamlSource2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Hosting::IDesktopWindowXamlSource2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Hosting::IDesktopWindowXamlSource2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_ShouldConstrainPopupsToWorkArea(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Hosting::IDesktopWindowXamlSource2>**)this;
            check_hresult(_winrt_abi_type->get_ShouldConstrainPopupsToWorkArea(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Hosting_IDesktopWindowXamlSource2<D>::ShouldConstrainPopupsToWorkArea(bool value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Hosting::IDesktopWindowXamlSource2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Hosting::IDesktopWindowXamlSource2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Hosting::IDesktopWindowXamlSource2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_ShouldConstrainPopupsToWorkArea(value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Hosting::IDesktopWindowXamlSource2>**)this;
            check_hresult(_winrt_abi_type->put_ShouldConstrainPopupsToWorkArea(value));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Hosting_IDesktopWindowXamlSourceFactory<D>::CreateInstance(winrt::Windows::Foundation::IInspectable const& baseInterface, winrt::Windows::Foundation::IInspectable& innerInterface) const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Hosting::IDesktopWindowXamlSourceFactory>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Hosting::IDesktopWindowXamlSourceFactory, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Hosting::IDesktopWindowXamlSourceFactory>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->CreateInstance(*(void**)(&baseInterface), impl::bind_out(innerInterface), &value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Hosting::IDesktopWindowXamlSourceFactory>**)this;
            check_hresult(_winrt_abi_type->CreateInstance(*(void**)(&baseInterface), impl::bind_out(innerInterface), &value));
        }
        return winrt::Microsoft::UI::Xaml::Hosting::DesktopWindowXamlSource{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Hosting_IDesktopWindowXamlSourceGotFocusEventArgs<D>::Request() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Hosting::IDesktopWindowXamlSourceGotFocusEventArgs>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Hosting::IDesktopWindowXamlSourceGotFocusEventArgs, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Hosting::IDesktopWindowXamlSourceGotFocusEventArgs>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Request(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Hosting::IDesktopWindowXamlSourceGotFocusEventArgs>**)this;
            check_hresult(_winrt_abi_type->get_Request(&value));
        }
        return winrt::Microsoft::UI::Xaml::Hosting::XamlSourceFocusNavigationRequest{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Hosting_IDesktopWindowXamlSourceTakeFocusRequestedEventArgs<D>::Request() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Hosting::IDesktopWindowXamlSourceTakeFocusRequestedEventArgs>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Hosting::IDesktopWindowXamlSourceTakeFocusRequestedEventArgs, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Hosting::IDesktopWindowXamlSourceTakeFocusRequestedEventArgs>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Request(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Hosting::IDesktopWindowXamlSourceTakeFocusRequestedEventArgs>**)this;
            check_hresult(_winrt_abi_type->get_Request(&value));
        }
        return winrt::Microsoft::UI::Xaml::Hosting::XamlSourceFocusNavigationRequest{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Hosting_IElementCompositionPreviewStatics<D>::GetElementVisual(winrt::Microsoft::UI::Xaml::UIElement const& element) const
    {
        void* result{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Hosting::IElementCompositionPreviewStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Hosting::IElementCompositionPreviewStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Hosting::IElementCompositionPreviewStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->GetElementVisual(*(void**)(&element), &result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Hosting::IElementCompositionPreviewStatics>**)this;
            check_hresult(_winrt_abi_type->GetElementVisual(*(void**)(&element), &result));
        }
        return winrt::Microsoft::UI::Composition::Visual{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Hosting_IElementCompositionPreviewStatics<D>::GetElementChildVisual(winrt::Microsoft::UI::Xaml::UIElement const& element) const
    {
        void* result{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Hosting::IElementCompositionPreviewStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Hosting::IElementCompositionPreviewStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Hosting::IElementCompositionPreviewStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->GetElementChildVisual(*(void**)(&element), &result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Hosting::IElementCompositionPreviewStatics>**)this;
            check_hresult(_winrt_abi_type->GetElementChildVisual(*(void**)(&element), &result));
        }
        return winrt::Microsoft::UI::Composition::Visual{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Hosting_IElementCompositionPreviewStatics<D>::SetElementChildVisual(winrt::Microsoft::UI::Xaml::UIElement const& element, winrt::Microsoft::UI::Composition::Visual const& visual) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Hosting::IElementCompositionPreviewStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Hosting::IElementCompositionPreviewStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Hosting::IElementCompositionPreviewStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->SetElementChildVisual(*(void**)(&element), *(void**)(&visual)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Hosting::IElementCompositionPreviewStatics>**)this;
            check_hresult(_winrt_abi_type->SetElementChildVisual(*(void**)(&element), *(void**)(&visual)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Hosting_IElementCompositionPreviewStatics<D>::GetScrollViewerManipulationPropertySet(winrt::Microsoft::UI::Xaml::Controls::ScrollViewer const& scrollViewer) const
    {
        void* result{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Hosting::IElementCompositionPreviewStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Hosting::IElementCompositionPreviewStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Hosting::IElementCompositionPreviewStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->GetScrollViewerManipulationPropertySet(*(void**)(&scrollViewer), &result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Hosting::IElementCompositionPreviewStatics>**)this;
            check_hresult(_winrt_abi_type->GetScrollViewerManipulationPropertySet(*(void**)(&scrollViewer), &result));
        }
        return winrt::Microsoft::UI::Composition::CompositionPropertySet{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Hosting_IElementCompositionPreviewStatics<D>::SetImplicitShowAnimation(winrt::Microsoft::UI::Xaml::UIElement const& element, winrt::Microsoft::UI::Composition::ICompositionAnimationBase const& animation) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Hosting::IElementCompositionPreviewStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Hosting::IElementCompositionPreviewStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Hosting::IElementCompositionPreviewStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->SetImplicitShowAnimation(*(void**)(&element), *(void**)(&animation)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Hosting::IElementCompositionPreviewStatics>**)this;
            check_hresult(_winrt_abi_type->SetImplicitShowAnimation(*(void**)(&element), *(void**)(&animation)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Hosting_IElementCompositionPreviewStatics<D>::SetImplicitHideAnimation(winrt::Microsoft::UI::Xaml::UIElement const& element, winrt::Microsoft::UI::Composition::ICompositionAnimationBase const& animation) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Hosting::IElementCompositionPreviewStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Hosting::IElementCompositionPreviewStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Hosting::IElementCompositionPreviewStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->SetImplicitHideAnimation(*(void**)(&element), *(void**)(&animation)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Hosting::IElementCompositionPreviewStatics>**)this;
            check_hresult(_winrt_abi_type->SetImplicitHideAnimation(*(void**)(&element), *(void**)(&animation)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Hosting_IElementCompositionPreviewStatics<D>::SetIsTranslationEnabled(winrt::Microsoft::UI::Xaml::UIElement const& element, bool value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Hosting::IElementCompositionPreviewStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Hosting::IElementCompositionPreviewStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Hosting::IElementCompositionPreviewStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->SetIsTranslationEnabled(*(void**)(&element), value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Hosting::IElementCompositionPreviewStatics>**)this;
            check_hresult(_winrt_abi_type->SetIsTranslationEnabled(*(void**)(&element), value));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Hosting_IElementCompositionPreviewStatics<D>::GetPointerPositionPropertySet(winrt::Microsoft::UI::Xaml::UIElement const& targetElement) const
    {
        void* result{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Hosting::IElementCompositionPreviewStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Hosting::IElementCompositionPreviewStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Hosting::IElementCompositionPreviewStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->GetPointerPositionPropertySet(*(void**)(&targetElement), &result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Hosting::IElementCompositionPreviewStatics>**)this;
            check_hresult(_winrt_abi_type->GetPointerPositionPropertySet(*(void**)(&targetElement), &result));
        }
        return winrt::Microsoft::UI::Composition::CompositionPropertySet{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Hosting_IWindowsXamlManager2<D>::XamlShutdownCompletedOnThread(winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Hosting::WindowsXamlManager, winrt::Microsoft::UI::Xaml::Hosting::XamlShutdownCompletedOnThreadEventArgs> const& handler) const
    {
        winrt::event_token token{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Hosting::IWindowsXamlManager2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Hosting::IWindowsXamlManager2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Hosting::IWindowsXamlManager2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->add_XamlShutdownCompletedOnThread(*(void**)(&handler), put_abi(token)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Hosting::IWindowsXamlManager2>**)this;
            check_hresult(_winrt_abi_type->add_XamlShutdownCompletedOnThread(*(void**)(&handler), put_abi(token)));
        }
        return token;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Hosting_IWindowsXamlManager2<D>::XamlShutdownCompletedOnThread(auto_revoke_t, winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Hosting::WindowsXamlManager, winrt::Microsoft::UI::Xaml::Hosting::XamlShutdownCompletedOnThreadEventArgs> const& handler) const
    {
        return impl::make_event_revoker<D, XamlShutdownCompletedOnThread_revoker>(this, XamlShutdownCompletedOnThread(handler));
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Hosting_IWindowsXamlManager2<D>::XamlShutdownCompletedOnThread(winrt::event_token const& token) const noexcept
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Hosting::IWindowsXamlManager2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Hosting::IWindowsXamlManager2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Hosting::IWindowsXamlManager2>**)&_winrt_casted_result;
            _winrt_abi_type->remove_XamlShutdownCompletedOnThread(impl::bind_in(token));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Hosting::IWindowsXamlManager2>**)this;
            _winrt_abi_type->remove_XamlShutdownCompletedOnThread(impl::bind_in(token));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Hosting_IWindowsXamlManagerStatics<D>::InitializeForCurrentThread() const
    {
        void* result{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Hosting::IWindowsXamlManagerStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Hosting::IWindowsXamlManagerStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Hosting::IWindowsXamlManagerStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->InitializeForCurrentThread(&result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Hosting::IWindowsXamlManagerStatics>**)this;
            check_hresult(_winrt_abi_type->InitializeForCurrentThread(&result));
        }
        return winrt::Microsoft::UI::Xaml::Hosting::WindowsXamlManager{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Hosting_IWindowsXamlManagerStatics2<D>::GetForCurrentThread() const
    {
        void* result{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Hosting::IWindowsXamlManagerStatics2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Hosting::IWindowsXamlManagerStatics2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Hosting::IWindowsXamlManagerStatics2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->GetForCurrentThread(&result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Hosting::IWindowsXamlManagerStatics2>**)this;
            check_hresult(_winrt_abi_type->GetForCurrentThread(&result));
        }
        return winrt::Microsoft::UI::Xaml::Hosting::WindowsXamlManager{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Hosting_IXamlShutdownCompletedOnThreadEventArgs<D>::GetDispatcherQueueDeferral() const
    {
        void* result{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Hosting::IXamlShutdownCompletedOnThreadEventArgs>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Hosting::IXamlShutdownCompletedOnThreadEventArgs, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Hosting::IXamlShutdownCompletedOnThreadEventArgs>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->GetDispatcherQueueDeferral(&result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Hosting::IXamlShutdownCompletedOnThreadEventArgs>**)this;
            check_hresult(_winrt_abi_type->GetDispatcherQueueDeferral(&result));
        }
        return winrt::Windows::Foundation::Deferral{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Hosting_IXamlSourceFocusNavigationRequest<D>::Reason() const
    {
        winrt::Microsoft::UI::Xaml::Hosting::XamlSourceFocusNavigationReason value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Hosting::IXamlSourceFocusNavigationRequest>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Hosting::IXamlSourceFocusNavigationRequest, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Hosting::IXamlSourceFocusNavigationRequest>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Reason(reinterpret_cast<int32_t*>(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Hosting::IXamlSourceFocusNavigationRequest>**)this;
            check_hresult(_winrt_abi_type->get_Reason(reinterpret_cast<int32_t*>(&value)));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Hosting_IXamlSourceFocusNavigationRequest<D>::HintRect() const
    {
        winrt::Windows::Foundation::Rect value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Hosting::IXamlSourceFocusNavigationRequest>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Hosting::IXamlSourceFocusNavigationRequest, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Hosting::IXamlSourceFocusNavigationRequest>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_HintRect(put_abi(value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Hosting::IXamlSourceFocusNavigationRequest>**)this;
            check_hresult(_winrt_abi_type->get_HintRect(put_abi(value)));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Hosting_IXamlSourceFocusNavigationRequest<D>::CorrelationId() const
    {
        winrt::guid value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Hosting::IXamlSourceFocusNavigationRequest>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Hosting::IXamlSourceFocusNavigationRequest, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Hosting::IXamlSourceFocusNavigationRequest>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_CorrelationId(put_abi(value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Hosting::IXamlSourceFocusNavigationRequest>**)this;
            check_hresult(_winrt_abi_type->get_CorrelationId(put_abi(value)));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Hosting_IXamlSourceFocusNavigationRequestFactory<D>::CreateInstance(winrt::Microsoft::UI::Xaml::Hosting::XamlSourceFocusNavigationReason const& reason) const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Hosting::IXamlSourceFocusNavigationRequestFactory>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Hosting::IXamlSourceFocusNavigationRequestFactory, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Hosting::IXamlSourceFocusNavigationRequestFactory>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->CreateInstance(static_cast<int32_t>(reason), &value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Hosting::IXamlSourceFocusNavigationRequestFactory>**)this;
            check_hresult(_winrt_abi_type->CreateInstance(static_cast<int32_t>(reason), &value));
        }
        return winrt::Microsoft::UI::Xaml::Hosting::XamlSourceFocusNavigationRequest{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Hosting_IXamlSourceFocusNavigationRequestFactory<D>::CreateInstanceWithHintRect(winrt::Microsoft::UI::Xaml::Hosting::XamlSourceFocusNavigationReason const& reason, winrt::Windows::Foundation::Rect const& hintRect) const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Hosting::IXamlSourceFocusNavigationRequestFactory>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Hosting::IXamlSourceFocusNavigationRequestFactory, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Hosting::IXamlSourceFocusNavigationRequestFactory>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->CreateInstanceWithHintRect(static_cast<int32_t>(reason), impl::bind_in(hintRect), &value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Hosting::IXamlSourceFocusNavigationRequestFactory>**)this;
            check_hresult(_winrt_abi_type->CreateInstanceWithHintRect(static_cast<int32_t>(reason), impl::bind_in(hintRect), &value));
        }
        return winrt::Microsoft::UI::Xaml::Hosting::XamlSourceFocusNavigationRequest{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Hosting_IXamlSourceFocusNavigationRequestFactory<D>::CreateInstanceWithHintRectAndCorrelationId(winrt::Microsoft::UI::Xaml::Hosting::XamlSourceFocusNavigationReason const& reason, winrt::Windows::Foundation::Rect const& hintRect, winrt::guid const& correlationId) const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Hosting::IXamlSourceFocusNavigationRequestFactory>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Hosting::IXamlSourceFocusNavigationRequestFactory, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Hosting::IXamlSourceFocusNavigationRequestFactory>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->CreateInstanceWithHintRectAndCorrelationId(static_cast<int32_t>(reason), impl::bind_in(hintRect), impl::bind_in(correlationId), &value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Hosting::IXamlSourceFocusNavigationRequestFactory>**)this;
            check_hresult(_winrt_abi_type->CreateInstanceWithHintRectAndCorrelationId(static_cast<int32_t>(reason), impl::bind_in(hintRect), impl::bind_in(correlationId), &value));
        }
        return winrt::Microsoft::UI::Xaml::Hosting::XamlSourceFocusNavigationRequest{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Hosting_IXamlSourceFocusNavigationResult<D>::WasFocusMoved() const
    {
        bool value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Hosting::IXamlSourceFocusNavigationResult>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Hosting::IXamlSourceFocusNavigationResult, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Hosting::IXamlSourceFocusNavigationResult>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_WasFocusMoved(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Hosting::IXamlSourceFocusNavigationResult>**)this;
            check_hresult(_winrt_abi_type->get_WasFocusMoved(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Xaml_Hosting_IXamlSourceFocusNavigationResultFactory<D>::CreateInstance(bool focusMoved) const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Xaml::Hosting::IXamlSourceFocusNavigationResultFactory>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Xaml::Hosting::IXamlSourceFocusNavigationResultFactory, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Hosting::IXamlSourceFocusNavigationResultFactory>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->CreateInstance(focusMoved, &value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Xaml::Hosting::IXamlSourceFocusNavigationResultFactory>**)this;
            check_hresult(_winrt_abi_type->CreateInstance(focusMoved, &value));
        }
        return winrt::Microsoft::UI::Xaml::Hosting::XamlSourceFocusNavigationResult{ value, take_ownership_from_abi };
    }
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Hosting::IDesktopWindowXamlSource> : produce_base<D, winrt::Microsoft::UI::Xaml::Hosting::IDesktopWindowXamlSource>
    {
        int32_t __stdcall get_Content(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::UI::Xaml::UIElement>(this->shim().Content());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_Content(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Content(*reinterpret_cast<winrt::Microsoft::UI::Xaml::UIElement const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_HasFocus(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().HasFocus());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_SystemBackdrop(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::UI::Xaml::Media::SystemBackdrop>(this->shim().SystemBackdrop());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_SystemBackdrop(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().SystemBackdrop(*reinterpret_cast<winrt::Microsoft::UI::Xaml::Media::SystemBackdrop const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_SiteBridge(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::UI::Content::DesktopChildSiteBridge>(this->shim().SiteBridge());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall add_TakeFocusRequested(void* handler, winrt::event_token* token) noexcept final try
        {
            zero_abi<winrt::event_token>(token);
            typename D::abi_guard guard(this->shim());
            *token = detach_from<winrt::event_token>(this->shim().TakeFocusRequested(*reinterpret_cast<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Hosting::DesktopWindowXamlSource, winrt::Microsoft::UI::Xaml::Hosting::DesktopWindowXamlSourceTakeFocusRequestedEventArgs> const*>(&handler)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall remove_TakeFocusRequested(winrt::event_token token) noexcept final
        {
            typename D::abi_guard guard(this->shim());
            this->shim().TakeFocusRequested(*reinterpret_cast<winrt::event_token const*>(&token));
            return 0;
        }
        int32_t __stdcall add_GotFocus(void* handler, winrt::event_token* token) noexcept final try
        {
            zero_abi<winrt::event_token>(token);
            typename D::abi_guard guard(this->shim());
            *token = detach_from<winrt::event_token>(this->shim().GotFocus(*reinterpret_cast<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Hosting::DesktopWindowXamlSource, winrt::Microsoft::UI::Xaml::Hosting::DesktopWindowXamlSourceGotFocusEventArgs> const*>(&handler)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall remove_GotFocus(winrt::event_token token) noexcept final
        {
            typename D::abi_guard guard(this->shim());
            this->shim().GotFocus(*reinterpret_cast<winrt::event_token const*>(&token));
            return 0;
        }
        int32_t __stdcall NavigateFocus(void* request, void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Microsoft::UI::Xaml::Hosting::XamlSourceFocusNavigationResult>(this->shim().NavigateFocus(*reinterpret_cast<winrt::Microsoft::UI::Xaml::Hosting::XamlSourceFocusNavigationRequest const*>(&request)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall Initialize(struct struct_Microsoft_UI_WindowId parentWindowId) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Initialize(*reinterpret_cast<winrt::Microsoft::UI::WindowId const*>(&parentWindowId));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Hosting::IDesktopWindowXamlSource2> : produce_base<D, winrt::Microsoft::UI::Xaml::Hosting::IDesktopWindowXamlSource2>
    {
        int32_t __stdcall get_ShouldConstrainPopupsToWorkArea(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().ShouldConstrainPopupsToWorkArea());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_ShouldConstrainPopupsToWorkArea(bool value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().ShouldConstrainPopupsToWorkArea(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Hosting::IDesktopWindowXamlSourceFactory> : produce_base<D, winrt::Microsoft::UI::Xaml::Hosting::IDesktopWindowXamlSourceFactory>
    {
        int32_t __stdcall CreateInstance(void* baseInterface, void** innerInterface, void** value) noexcept final try
        {
            if (innerInterface) *innerInterface = nullptr;
            winrt::Windows::Foundation::IInspectable winrt_impl_innerInterface;
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::UI::Xaml::Hosting::DesktopWindowXamlSource>(this->shim().CreateInstance(*reinterpret_cast<winrt::Windows::Foundation::IInspectable const*>(&baseInterface), winrt_impl_innerInterface));
                if (innerInterface) *innerInterface = detach_abi(winrt_impl_innerInterface);
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Hosting::IDesktopWindowXamlSourceGotFocusEventArgs> : produce_base<D, winrt::Microsoft::UI::Xaml::Hosting::IDesktopWindowXamlSourceGotFocusEventArgs>
    {
        int32_t __stdcall get_Request(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::UI::Xaml::Hosting::XamlSourceFocusNavigationRequest>(this->shim().Request());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Hosting::IDesktopWindowXamlSourceTakeFocusRequestedEventArgs> : produce_base<D, winrt::Microsoft::UI::Xaml::Hosting::IDesktopWindowXamlSourceTakeFocusRequestedEventArgs>
    {
        int32_t __stdcall get_Request(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::UI::Xaml::Hosting::XamlSourceFocusNavigationRequest>(this->shim().Request());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Hosting::IElementCompositionPreview> : produce_base<D, winrt::Microsoft::UI::Xaml::Hosting::IElementCompositionPreview>
    {
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Hosting::IElementCompositionPreviewStatics> : produce_base<D, winrt::Microsoft::UI::Xaml::Hosting::IElementCompositionPreviewStatics>
    {
        int32_t __stdcall GetElementVisual(void* element, void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Microsoft::UI::Composition::Visual>(this->shim().GetElementVisual(*reinterpret_cast<winrt::Microsoft::UI::Xaml::UIElement const*>(&element)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall GetElementChildVisual(void* element, void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Microsoft::UI::Composition::Visual>(this->shim().GetElementChildVisual(*reinterpret_cast<winrt::Microsoft::UI::Xaml::UIElement const*>(&element)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall SetElementChildVisual(void* element, void* visual) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().SetElementChildVisual(*reinterpret_cast<winrt::Microsoft::UI::Xaml::UIElement const*>(&element), *reinterpret_cast<winrt::Microsoft::UI::Composition::Visual const*>(&visual));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall GetScrollViewerManipulationPropertySet(void* scrollViewer, void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Microsoft::UI::Composition::CompositionPropertySet>(this->shim().GetScrollViewerManipulationPropertySet(*reinterpret_cast<winrt::Microsoft::UI::Xaml::Controls::ScrollViewer const*>(&scrollViewer)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall SetImplicitShowAnimation(void* element, void* animation) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().SetImplicitShowAnimation(*reinterpret_cast<winrt::Microsoft::UI::Xaml::UIElement const*>(&element), *reinterpret_cast<winrt::Microsoft::UI::Composition::ICompositionAnimationBase const*>(&animation));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall SetImplicitHideAnimation(void* element, void* animation) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().SetImplicitHideAnimation(*reinterpret_cast<winrt::Microsoft::UI::Xaml::UIElement const*>(&element), *reinterpret_cast<winrt::Microsoft::UI::Composition::ICompositionAnimationBase const*>(&animation));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall SetIsTranslationEnabled(void* element, bool value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().SetIsTranslationEnabled(*reinterpret_cast<winrt::Microsoft::UI::Xaml::UIElement const*>(&element), value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall GetPointerPositionPropertySet(void* targetElement, void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Microsoft::UI::Composition::CompositionPropertySet>(this->shim().GetPointerPositionPropertySet(*reinterpret_cast<winrt::Microsoft::UI::Xaml::UIElement const*>(&targetElement)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Hosting::IWindowsXamlManager> : produce_base<D, winrt::Microsoft::UI::Xaml::Hosting::IWindowsXamlManager>
    {
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Hosting::IWindowsXamlManager2> : produce_base<D, winrt::Microsoft::UI::Xaml::Hosting::IWindowsXamlManager2>
    {
        int32_t __stdcall add_XamlShutdownCompletedOnThread(void* handler, winrt::event_token* token) noexcept final try
        {
            zero_abi<winrt::event_token>(token);
            typename D::abi_guard guard(this->shim());
            *token = detach_from<winrt::event_token>(this->shim().XamlShutdownCompletedOnThread(*reinterpret_cast<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Hosting::WindowsXamlManager, winrt::Microsoft::UI::Xaml::Hosting::XamlShutdownCompletedOnThreadEventArgs> const*>(&handler)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall remove_XamlShutdownCompletedOnThread(winrt::event_token token) noexcept final
        {
            typename D::abi_guard guard(this->shim());
            this->shim().XamlShutdownCompletedOnThread(*reinterpret_cast<winrt::event_token const*>(&token));
            return 0;
        }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Hosting::IWindowsXamlManagerStatics> : produce_base<D, winrt::Microsoft::UI::Xaml::Hosting::IWindowsXamlManagerStatics>
    {
        int32_t __stdcall InitializeForCurrentThread(void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Microsoft::UI::Xaml::Hosting::WindowsXamlManager>(this->shim().InitializeForCurrentThread());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Hosting::IWindowsXamlManagerStatics2> : produce_base<D, winrt::Microsoft::UI::Xaml::Hosting::IWindowsXamlManagerStatics2>
    {
        int32_t __stdcall GetForCurrentThread(void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Microsoft::UI::Xaml::Hosting::WindowsXamlManager>(this->shim().GetForCurrentThread());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Hosting::IXamlShutdownCompletedOnThreadEventArgs> : produce_base<D, winrt::Microsoft::UI::Xaml::Hosting::IXamlShutdownCompletedOnThreadEventArgs>
    {
        int32_t __stdcall GetDispatcherQueueDeferral(void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Windows::Foundation::Deferral>(this->shim().GetDispatcherQueueDeferral());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Hosting::IXamlSourceFocusNavigationRequest> : produce_base<D, winrt::Microsoft::UI::Xaml::Hosting::IXamlSourceFocusNavigationRequest>
    {
        int32_t __stdcall get_Reason(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::UI::Xaml::Hosting::XamlSourceFocusNavigationReason>(this->shim().Reason());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_HintRect(winrt::Windows::Foundation::Rect* value) noexcept final try
        {
            zero_abi<winrt::Windows::Foundation::Rect>(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::Rect>(this->shim().HintRect());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_CorrelationId(winrt::guid* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::guid>(this->shim().CorrelationId());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Hosting::IXamlSourceFocusNavigationRequestFactory> : produce_base<D, winrt::Microsoft::UI::Xaml::Hosting::IXamlSourceFocusNavigationRequestFactory>
    {
        int32_t __stdcall CreateInstance(int32_t reason, void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::UI::Xaml::Hosting::XamlSourceFocusNavigationRequest>(this->shim().CreateInstance(*reinterpret_cast<winrt::Microsoft::UI::Xaml::Hosting::XamlSourceFocusNavigationReason const*>(&reason)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall CreateInstanceWithHintRect(int32_t reason, winrt::Windows::Foundation::Rect hintRect, void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::UI::Xaml::Hosting::XamlSourceFocusNavigationRequest>(this->shim().CreateInstanceWithHintRect(*reinterpret_cast<winrt::Microsoft::UI::Xaml::Hosting::XamlSourceFocusNavigationReason const*>(&reason), *reinterpret_cast<winrt::Windows::Foundation::Rect const*>(&hintRect)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall CreateInstanceWithHintRectAndCorrelationId(int32_t reason, winrt::Windows::Foundation::Rect hintRect, winrt::guid correlationId, void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::UI::Xaml::Hosting::XamlSourceFocusNavigationRequest>(this->shim().CreateInstanceWithHintRectAndCorrelationId(*reinterpret_cast<winrt::Microsoft::UI::Xaml::Hosting::XamlSourceFocusNavigationReason const*>(&reason), *reinterpret_cast<winrt::Windows::Foundation::Rect const*>(&hintRect), *reinterpret_cast<winrt::guid const*>(&correlationId)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Hosting::IXamlSourceFocusNavigationResult> : produce_base<D, winrt::Microsoft::UI::Xaml::Hosting::IXamlSourceFocusNavigationResult>
    {
        int32_t __stdcall get_WasFocusMoved(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().WasFocusMoved());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Xaml::Hosting::IXamlSourceFocusNavigationResultFactory> : produce_base<D, winrt::Microsoft::UI::Xaml::Hosting::IXamlSourceFocusNavigationResultFactory>
    {
        int32_t __stdcall CreateInstance(bool focusMoved, void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::UI::Xaml::Hosting::XamlSourceFocusNavigationResult>(this->shim().CreateInstance(focusMoved));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
}
WINRT_EXPORT namespace winrt::Microsoft::UI::Xaml::Hosting
{
    inline DesktopWindowXamlSource::DesktopWindowXamlSource()
    {
        winrt::Windows::Foundation::IInspectable baseInterface, innerInterface;
        *this = impl::call_factory<DesktopWindowXamlSource, IDesktopWindowXamlSourceFactory>([&](IDesktopWindowXamlSourceFactory const& f) { return f.CreateInstance(baseInterface, innerInterface); });
    }
    inline auto ElementCompositionPreview::GetElementVisual(winrt::Microsoft::UI::Xaml::UIElement const& element)
    {
        return impl::call_factory<ElementCompositionPreview, IElementCompositionPreviewStatics>([&](IElementCompositionPreviewStatics const& f) { return f.GetElementVisual(element); });
    }
    inline auto ElementCompositionPreview::GetElementChildVisual(winrt::Microsoft::UI::Xaml::UIElement const& element)
    {
        return impl::call_factory<ElementCompositionPreview, IElementCompositionPreviewStatics>([&](IElementCompositionPreviewStatics const& f) { return f.GetElementChildVisual(element); });
    }
    inline auto ElementCompositionPreview::SetElementChildVisual(winrt::Microsoft::UI::Xaml::UIElement const& element, winrt::Microsoft::UI::Composition::Visual const& visual)
    {
        impl::call_factory<ElementCompositionPreview, IElementCompositionPreviewStatics>([&](IElementCompositionPreviewStatics const& f) { return f.SetElementChildVisual(element, visual); });
    }
    inline auto ElementCompositionPreview::GetScrollViewerManipulationPropertySet(winrt::Microsoft::UI::Xaml::Controls::ScrollViewer const& scrollViewer)
    {
        return impl::call_factory<ElementCompositionPreview, IElementCompositionPreviewStatics>([&](IElementCompositionPreviewStatics const& f) { return f.GetScrollViewerManipulationPropertySet(scrollViewer); });
    }
    inline auto ElementCompositionPreview::SetImplicitShowAnimation(winrt::Microsoft::UI::Xaml::UIElement const& element, winrt::Microsoft::UI::Composition::ICompositionAnimationBase const& animation)
    {
        impl::call_factory<ElementCompositionPreview, IElementCompositionPreviewStatics>([&](IElementCompositionPreviewStatics const& f) { return f.SetImplicitShowAnimation(element, animation); });
    }
    inline auto ElementCompositionPreview::SetImplicitHideAnimation(winrt::Microsoft::UI::Xaml::UIElement const& element, winrt::Microsoft::UI::Composition::ICompositionAnimationBase const& animation)
    {
        impl::call_factory<ElementCompositionPreview, IElementCompositionPreviewStatics>([&](IElementCompositionPreviewStatics const& f) { return f.SetImplicitHideAnimation(element, animation); });
    }
    inline auto ElementCompositionPreview::SetIsTranslationEnabled(winrt::Microsoft::UI::Xaml::UIElement const& element, bool value)
    {
        impl::call_factory<ElementCompositionPreview, IElementCompositionPreviewStatics>([&](IElementCompositionPreviewStatics const& f) { return f.SetIsTranslationEnabled(element, value); });
    }
    inline auto ElementCompositionPreview::GetPointerPositionPropertySet(winrt::Microsoft::UI::Xaml::UIElement const& targetElement)
    {
        return impl::call_factory<ElementCompositionPreview, IElementCompositionPreviewStatics>([&](IElementCompositionPreviewStatics const& f) { return f.GetPointerPositionPropertySet(targetElement); });
    }
    inline auto WindowsXamlManager::InitializeForCurrentThread()
    {
        return impl::call_factory_cast<winrt::Microsoft::UI::Xaml::Hosting::WindowsXamlManager(*)(IWindowsXamlManagerStatics const&), WindowsXamlManager, IWindowsXamlManagerStatics>([](IWindowsXamlManagerStatics const& f) { return f.InitializeForCurrentThread(); });
    }
    inline auto WindowsXamlManager::GetForCurrentThread()
    {
        return impl::call_factory_cast<winrt::Microsoft::UI::Xaml::Hosting::WindowsXamlManager(*)(IWindowsXamlManagerStatics2 const&), WindowsXamlManager, IWindowsXamlManagerStatics2>([](IWindowsXamlManagerStatics2 const& f) { return f.GetForCurrentThread(); });
    }
    inline XamlSourceFocusNavigationRequest::XamlSourceFocusNavigationRequest(winrt::Microsoft::UI::Xaml::Hosting::XamlSourceFocusNavigationReason const& reason) :
        XamlSourceFocusNavigationRequest(impl::call_factory<XamlSourceFocusNavigationRequest, IXamlSourceFocusNavigationRequestFactory>([&](IXamlSourceFocusNavigationRequestFactory const& f) { return f.CreateInstance(reason); }))
    {
    }
    inline XamlSourceFocusNavigationRequest::XamlSourceFocusNavigationRequest(winrt::Microsoft::UI::Xaml::Hosting::XamlSourceFocusNavigationReason const& reason, winrt::Windows::Foundation::Rect const& hintRect) :
        XamlSourceFocusNavigationRequest(impl::call_factory<XamlSourceFocusNavigationRequest, IXamlSourceFocusNavigationRequestFactory>([&](IXamlSourceFocusNavigationRequestFactory const& f) { return f.CreateInstanceWithHintRect(reason, hintRect); }))
    {
    }
    inline XamlSourceFocusNavigationRequest::XamlSourceFocusNavigationRequest(winrt::Microsoft::UI::Xaml::Hosting::XamlSourceFocusNavigationReason const& reason, winrt::Windows::Foundation::Rect const& hintRect, winrt::guid const& correlationId) :
        XamlSourceFocusNavigationRequest(impl::call_factory<XamlSourceFocusNavigationRequest, IXamlSourceFocusNavigationRequestFactory>([&](IXamlSourceFocusNavigationRequestFactory const& f) { return f.CreateInstanceWithHintRectAndCorrelationId(reason, hintRect, correlationId); }))
    {
    }
    inline XamlSourceFocusNavigationResult::XamlSourceFocusNavigationResult(bool focusMoved) :
        XamlSourceFocusNavigationResult(impl::call_factory<XamlSourceFocusNavigationResult, IXamlSourceFocusNavigationResultFactory>([&](IXamlSourceFocusNavigationResultFactory const& f) { return f.CreateInstance(focusMoved); }))
    {
    }
    template <typename D, typename... Interfaces>
    struct DesktopWindowXamlSourceT :
        implements<D, winrt::Windows::Foundation::IInspectable, composing, Interfaces...>,
        impl::require<D, winrt::Microsoft::UI::Xaml::Hosting::IDesktopWindowXamlSource, winrt::Microsoft::UI::Xaml::Hosting::IDesktopWindowXamlSource2, winrt::Windows::Foundation::IClosable>,
        impl::base<D, DesktopWindowXamlSource>
    {
        using composable = DesktopWindowXamlSource;
    protected:
        DesktopWindowXamlSourceT()
        {
            impl::call_factory<DesktopWindowXamlSource, IDesktopWindowXamlSourceFactory>([&](IDesktopWindowXamlSourceFactory const& f) { [[maybe_unused]] auto winrt_impl_discarded = f.CreateInstance(*this, this->m_inner); });
        }
    };
}
namespace std
{
#ifndef WINRT_LEAN_AND_MEAN
    template<> struct hash<winrt::Microsoft::UI::Xaml::Hosting::IDesktopWindowXamlSource> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Hosting::IDesktopWindowXamlSource2> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Hosting::IDesktopWindowXamlSourceFactory> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Hosting::IDesktopWindowXamlSourceGotFocusEventArgs> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Hosting::IDesktopWindowXamlSourceTakeFocusRequestedEventArgs> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Hosting::IElementCompositionPreview> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Hosting::IElementCompositionPreviewStatics> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Hosting::IWindowsXamlManager> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Hosting::IWindowsXamlManager2> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Hosting::IWindowsXamlManagerStatics> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Hosting::IWindowsXamlManagerStatics2> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Hosting::IXamlShutdownCompletedOnThreadEventArgs> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Hosting::IXamlSourceFocusNavigationRequest> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Hosting::IXamlSourceFocusNavigationRequestFactory> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Hosting::IXamlSourceFocusNavigationResult> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Hosting::IXamlSourceFocusNavigationResultFactory> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Hosting::DesktopWindowXamlSource> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Hosting::DesktopWindowXamlSourceGotFocusEventArgs> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Hosting::DesktopWindowXamlSourceTakeFocusRequestedEventArgs> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Hosting::ElementCompositionPreview> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Hosting::WindowsXamlManager> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Hosting::XamlShutdownCompletedOnThreadEventArgs> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Hosting::XamlSourceFocusNavigationRequest> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Xaml::Hosting::XamlSourceFocusNavigationResult> : winrt::impl::hash_base {};
#endif
#ifdef __cpp_lib_format
#endif
}
#endif
