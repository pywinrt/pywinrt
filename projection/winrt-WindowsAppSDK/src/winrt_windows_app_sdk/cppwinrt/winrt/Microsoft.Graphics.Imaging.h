// WARNING: Please don't edit this file. It was generated by C++/WinRT v2.0.250303.1

#pragma once
#ifndef WINRT_Microsoft_Graphics_Imaging_H
#define WINRT_Microsoft_Graphics_Imaging_H
#include "winrt/base.h"
static_assert(winrt::check_version(CPPWINRT_VERSION, "2.0.250303.1"), "Mismatched C++/WinRT headers.");
#define CPPWINRT_VERSION "2.0.250303.1"
#include "winrt/impl/Windows.Foundation.2.h"
#include "winrt/impl/Windows.Graphics.Imaging.2.h"
#include "winrt/impl/Windows.Storage.Streams.2.h"
#include "winrt/impl/Microsoft.Graphics.Imaging.2.h"
namespace winrt::impl
{
    template <typename D> auto consume_Microsoft_Graphics_Imaging_IImageBuffer<D>::Buffer() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Imaging::IImageBuffer>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Imaging::IImageBuffer, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Imaging::IImageBuffer>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Buffer(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Imaging::IImageBuffer>**)this;
            check_hresult(_winrt_abi_type->get_Buffer(&value));
        }
        return winrt::Windows::Storage::Streams::IBuffer{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Graphics_Imaging_IImageBuffer<D>::PixelFormat() const
    {
        winrt::Microsoft::Graphics::Imaging::ImageBufferPixelFormat value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Imaging::IImageBuffer>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Imaging::IImageBuffer, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Imaging::IImageBuffer>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_PixelFormat(reinterpret_cast<int32_t*>(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Imaging::IImageBuffer>**)this;
            check_hresult(_winrt_abi_type->get_PixelFormat(reinterpret_cast<int32_t*>(&value)));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_Graphics_Imaging_IImageBuffer<D>::PixelHeight() const
    {
        int32_t value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Imaging::IImageBuffer>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Imaging::IImageBuffer, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Imaging::IImageBuffer>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_PixelHeight(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Imaging::IImageBuffer>**)this;
            check_hresult(_winrt_abi_type->get_PixelHeight(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_Graphics_Imaging_IImageBuffer<D>::PixelWidth() const
    {
        int32_t value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Imaging::IImageBuffer>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Imaging::IImageBuffer, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Imaging::IImageBuffer>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_PixelWidth(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Imaging::IImageBuffer>**)this;
            check_hresult(_winrt_abi_type->get_PixelWidth(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_Graphics_Imaging_IImageBuffer<D>::RowStride() const
    {
        int32_t value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Imaging::IImageBuffer>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Imaging::IImageBuffer, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Imaging::IImageBuffer>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_RowStride(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Imaging::IImageBuffer>**)this;
            check_hresult(_winrt_abi_type->get_RowStride(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_Graphics_Imaging_IImageBuffer<D>::CopyToByteArray(array_view<uint8_t> values) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Imaging::IImageBuffer>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Imaging::IImageBuffer, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Imaging::IImageBuffer>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->CopyToByteArray(values.size(), put_abi(values)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Imaging::IImageBuffer>**)this;
            check_hresult(_winrt_abi_type->CopyToByteArray(values.size(), put_abi(values)));
        }
    }
    template <typename D> auto consume_Microsoft_Graphics_Imaging_IImageBuffer<D>::CopyToSoftwareBitmap() const
    {
        void* result{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Imaging::IImageBuffer>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Imaging::IImageBuffer, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Imaging::IImageBuffer>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->CopyToSoftwareBitmap(&result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Imaging::IImageBuffer>**)this;
            check_hresult(_winrt_abi_type->CopyToSoftwareBitmap(&result));
        }
        return winrt::Windows::Graphics::Imaging::SoftwareBitmap{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Graphics_Imaging_IImageBufferStatics<D>::CreateForBuffer(winrt::Windows::Storage::Streams::IBuffer const& buffer, winrt::Microsoft::Graphics::Imaging::ImageBufferPixelFormat const& pixelFormat, int32_t width, int32_t height, int32_t rowStride) const
    {
        void* result{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Imaging::IImageBufferStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Imaging::IImageBufferStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Imaging::IImageBufferStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->CreateForBuffer(*(void**)(&buffer), static_cast<int32_t>(pixelFormat), width, height, rowStride, &result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Imaging::IImageBufferStatics>**)this;
            check_hresult(_winrt_abi_type->CreateForBuffer(*(void**)(&buffer), static_cast<int32_t>(pixelFormat), width, height, rowStride, &result));
        }
        return winrt::Microsoft::Graphics::Imaging::ImageBuffer{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Graphics_Imaging_IImageBufferStatics<D>::CreateForSoftwareBitmap(winrt::Windows::Graphics::Imaging::SoftwareBitmap const& softwareBitmap) const
    {
        void* result{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Imaging::IImageBufferStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Imaging::IImageBufferStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Imaging::IImageBufferStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->CreateForSoftwareBitmap(*(void**)(&softwareBitmap), &result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Imaging::IImageBufferStatics>**)this;
            check_hresult(_winrt_abi_type->CreateForSoftwareBitmap(*(void**)(&softwareBitmap), &result));
        }
        return winrt::Microsoft::Graphics::Imaging::ImageBuffer{ result, take_ownership_from_abi };
    }
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::Graphics::Imaging::IImageBuffer> : produce_base<D, winrt::Microsoft::Graphics::Imaging::IImageBuffer>
    {
        int32_t __stdcall get_Buffer(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Storage::Streams::IBuffer>(this->shim().Buffer());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_PixelFormat(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::Graphics::Imaging::ImageBufferPixelFormat>(this->shim().PixelFormat());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_PixelHeight(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<int32_t>(this->shim().PixelHeight());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_PixelWidth(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<int32_t>(this->shim().PixelWidth());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_RowStride(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<int32_t>(this->shim().RowStride());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall CopyToByteArray(uint32_t __valuesSize, uint8_t* values) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().CopyToByteArray(array_view<uint8_t>(reinterpret_cast<uint8_t*>(values), reinterpret_cast<uint8_t*>(values) + __valuesSize));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall CopyToSoftwareBitmap(void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Windows::Graphics::Imaging::SoftwareBitmap>(this->shim().CopyToSoftwareBitmap());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::Graphics::Imaging::IImageBufferStatics> : produce_base<D, winrt::Microsoft::Graphics::Imaging::IImageBufferStatics>
    {
        int32_t __stdcall CreateForBuffer(void* buffer, int32_t pixelFormat, int32_t width, int32_t height, int32_t rowStride, void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Microsoft::Graphics::Imaging::ImageBuffer>(this->shim().CreateForBuffer(*reinterpret_cast<winrt::Windows::Storage::Streams::IBuffer const*>(&buffer), *reinterpret_cast<winrt::Microsoft::Graphics::Imaging::ImageBufferPixelFormat const*>(&pixelFormat), width, height, rowStride));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall CreateForSoftwareBitmap(void* softwareBitmap, void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Microsoft::Graphics::Imaging::ImageBuffer>(this->shim().CreateForSoftwareBitmap(*reinterpret_cast<winrt::Windows::Graphics::Imaging::SoftwareBitmap const*>(&softwareBitmap)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
}
WINRT_EXPORT namespace winrt::Microsoft::Graphics::Imaging
{
    inline auto ImageBuffer::CreateForBuffer(winrt::Windows::Storage::Streams::IBuffer const& buffer, winrt::Microsoft::Graphics::Imaging::ImageBufferPixelFormat const& pixelFormat, int32_t width, int32_t height, int32_t rowStride)
    {
        return impl::call_factory<ImageBuffer, IImageBufferStatics>([&](IImageBufferStatics const& f) { return f.CreateForBuffer(buffer, pixelFormat, width, height, rowStride); });
    }
    inline auto ImageBuffer::CreateForSoftwareBitmap(winrt::Windows::Graphics::Imaging::SoftwareBitmap const& softwareBitmap)
    {
        return impl::call_factory<ImageBuffer, IImageBufferStatics>([&](IImageBufferStatics const& f) { return f.CreateForSoftwareBitmap(softwareBitmap); });
    }
}
namespace std
{
#ifndef WINRT_LEAN_AND_MEAN
    template<> struct hash<winrt::Microsoft::Graphics::Imaging::IImageBuffer> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Graphics::Imaging::IImageBufferStatics> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Graphics::Imaging::ImageBuffer> : winrt::impl::hash_base {};
#endif
#ifdef __cpp_lib_format
#endif
}
#endif
