// WARNING: Please don't edit this file. It was generated by C++/WinRT v2.0.250303.1

#pragma once
#ifndef WINRT_Microsoft_Windows_ApplicationModel_DynamicDependency_H
#define WINRT_Microsoft_Windows_ApplicationModel_DynamicDependency_H
#include "winrt/base.h"
static_assert(winrt::check_version(CPPWINRT_VERSION, "2.0.250303.1"), "Mismatched C++/WinRT headers.");
#define CPPWINRT_VERSION "2.0.250303.1"
#include "winrt/impl/Windows.ApplicationModel.2.h"
#include "winrt/impl/Microsoft.Windows.ApplicationModel.DynamicDependency.2.h"
namespace winrt::impl
{
    template <typename D> auto consume_Microsoft_Windows_ApplicationModel_DynamicDependency_IAddPackageDependencyOptions<D>::Rank() const
    {
        int32_t value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::IAddPackageDependencyOptions>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::IAddPackageDependencyOptions, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::IAddPackageDependencyOptions>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Rank(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::IAddPackageDependencyOptions>**)this;
            check_hresult(_winrt_abi_type->get_Rank(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_Windows_ApplicationModel_DynamicDependency_IAddPackageDependencyOptions<D>::Rank(int32_t value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::IAddPackageDependencyOptions>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::IAddPackageDependencyOptions, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::IAddPackageDependencyOptions>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_Rank(value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::IAddPackageDependencyOptions>**)this;
            check_hresult(_winrt_abi_type->put_Rank(value));
        }
    }
    template <typename D> auto consume_Microsoft_Windows_ApplicationModel_DynamicDependency_IAddPackageDependencyOptions<D>::PrependIfRankCollision() const
    {
        bool value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::IAddPackageDependencyOptions>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::IAddPackageDependencyOptions, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::IAddPackageDependencyOptions>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_PrependIfRankCollision(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::IAddPackageDependencyOptions>**)this;
            check_hresult(_winrt_abi_type->get_PrependIfRankCollision(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_Windows_ApplicationModel_DynamicDependency_IAddPackageDependencyOptions<D>::PrependIfRankCollision(bool value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::IAddPackageDependencyOptions>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::IAddPackageDependencyOptions, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::IAddPackageDependencyOptions>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_PrependIfRankCollision(value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::IAddPackageDependencyOptions>**)this;
            check_hresult(_winrt_abi_type->put_PrependIfRankCollision(value));
        }
    }
    template <typename D> auto consume_Microsoft_Windows_ApplicationModel_DynamicDependency_ICreatePackageDependencyOptions<D>::Architectures() const
    {
        winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::PackageDependencyProcessorArchitectures value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::ICreatePackageDependencyOptions>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::ICreatePackageDependencyOptions, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::ICreatePackageDependencyOptions>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Architectures(reinterpret_cast<uint32_t*>(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::ICreatePackageDependencyOptions>**)this;
            check_hresult(_winrt_abi_type->get_Architectures(reinterpret_cast<uint32_t*>(&value)));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_Windows_ApplicationModel_DynamicDependency_ICreatePackageDependencyOptions<D>::Architectures(winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::PackageDependencyProcessorArchitectures const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::ICreatePackageDependencyOptions>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::ICreatePackageDependencyOptions, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::ICreatePackageDependencyOptions>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_Architectures(static_cast<uint32_t>(value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::ICreatePackageDependencyOptions>**)this;
            check_hresult(_winrt_abi_type->put_Architectures(static_cast<uint32_t>(value)));
        }
    }
    template <typename D> auto consume_Microsoft_Windows_ApplicationModel_DynamicDependency_ICreatePackageDependencyOptions<D>::VerifyDependencyResolution() const
    {
        bool value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::ICreatePackageDependencyOptions>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::ICreatePackageDependencyOptions, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::ICreatePackageDependencyOptions>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_VerifyDependencyResolution(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::ICreatePackageDependencyOptions>**)this;
            check_hresult(_winrt_abi_type->get_VerifyDependencyResolution(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_Windows_ApplicationModel_DynamicDependency_ICreatePackageDependencyOptions<D>::VerifyDependencyResolution(bool value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::ICreatePackageDependencyOptions>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::ICreatePackageDependencyOptions, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::ICreatePackageDependencyOptions>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_VerifyDependencyResolution(value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::ICreatePackageDependencyOptions>**)this;
            check_hresult(_winrt_abi_type->put_VerifyDependencyResolution(value));
        }
    }
    template <typename D> auto consume_Microsoft_Windows_ApplicationModel_DynamicDependency_ICreatePackageDependencyOptions<D>::LifetimeArtifactKind() const
    {
        winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::PackageDependencyLifetimeArtifactKind value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::ICreatePackageDependencyOptions>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::ICreatePackageDependencyOptions, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::ICreatePackageDependencyOptions>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_LifetimeArtifactKind(reinterpret_cast<int32_t*>(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::ICreatePackageDependencyOptions>**)this;
            check_hresult(_winrt_abi_type->get_LifetimeArtifactKind(reinterpret_cast<int32_t*>(&value)));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_Windows_ApplicationModel_DynamicDependency_ICreatePackageDependencyOptions<D>::LifetimeArtifactKind(winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::PackageDependencyLifetimeArtifactKind const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::ICreatePackageDependencyOptions>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::ICreatePackageDependencyOptions, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::ICreatePackageDependencyOptions>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_LifetimeArtifactKind(static_cast<int32_t>(value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::ICreatePackageDependencyOptions>**)this;
            check_hresult(_winrt_abi_type->put_LifetimeArtifactKind(static_cast<int32_t>(value)));
        }
    }
    template <typename D> auto consume_Microsoft_Windows_ApplicationModel_DynamicDependency_ICreatePackageDependencyOptions<D>::LifetimeArtifact() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::ICreatePackageDependencyOptions>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::ICreatePackageDependencyOptions, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::ICreatePackageDependencyOptions>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_LifetimeArtifact(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::ICreatePackageDependencyOptions>**)this;
            check_hresult(_winrt_abi_type->get_LifetimeArtifact(&value));
        }
        return hstring{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Windows_ApplicationModel_DynamicDependency_ICreatePackageDependencyOptions<D>::LifetimeArtifact(param::hstring const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::ICreatePackageDependencyOptions>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::ICreatePackageDependencyOptions, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::ICreatePackageDependencyOptions>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_LifetimeArtifact(*(void**)(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::ICreatePackageDependencyOptions>**)this;
            check_hresult(_winrt_abi_type->put_LifetimeArtifact(*(void**)(&value)));
        }
    }
    template <typename D> auto consume_Microsoft_Windows_ApplicationModel_DynamicDependency_IPackageDependency<D>::Id() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::IPackageDependency>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::IPackageDependency, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::IPackageDependency>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Id(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::IPackageDependency>**)this;
            check_hresult(_winrt_abi_type->get_Id(&value));
        }
        return hstring{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Windows_ApplicationModel_DynamicDependency_IPackageDependency<D>::Delete() const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::IPackageDependency>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::IPackageDependency, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::IPackageDependency>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->Delete());
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::IPackageDependency>**)this;
            check_hresult(_winrt_abi_type->Delete());
        }
    }
    template <typename D> auto consume_Microsoft_Windows_ApplicationModel_DynamicDependency_IPackageDependency<D>::Add() const
    {
        void* result{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::IPackageDependency>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::IPackageDependency, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::IPackageDependency>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->Add(&result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::IPackageDependency>**)this;
            check_hresult(_winrt_abi_type->Add(&result));
        }
        return winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::PackageDependencyContext{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Windows_ApplicationModel_DynamicDependency_IPackageDependency<D>::Add(winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::AddPackageDependencyOptions const& options) const
    {
        void* result{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::IPackageDependency>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::IPackageDependency, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::IPackageDependency>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->Add2(*(void**)(&options), &result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::IPackageDependency>**)this;
            check_hresult(_winrt_abi_type->Add2(*(void**)(&options), &result));
        }
        return winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::PackageDependencyContext{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Windows_ApplicationModel_DynamicDependency_IPackageDependencyContext<D>::ContextId() const
    {
        winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::PackageDependencyContextId value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::IPackageDependencyContext>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::IPackageDependencyContext, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::IPackageDependencyContext>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_ContextId(put_abi(value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::IPackageDependencyContext>**)this;
            check_hresult(_winrt_abi_type->get_ContextId(put_abi(value)));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_Windows_ApplicationModel_DynamicDependency_IPackageDependencyContext<D>::PackageDependencyId() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::IPackageDependencyContext>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::IPackageDependencyContext, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::IPackageDependencyContext>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_PackageDependencyId(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::IPackageDependencyContext>**)this;
            check_hresult(_winrt_abi_type->get_PackageDependencyId(&value));
        }
        return hstring{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Windows_ApplicationModel_DynamicDependency_IPackageDependencyContext<D>::PackageFullName() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::IPackageDependencyContext>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::IPackageDependencyContext, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::IPackageDependencyContext>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_PackageFullName(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::IPackageDependencyContext>**)this;
            check_hresult(_winrt_abi_type->get_PackageFullName(&value));
        }
        return hstring{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Windows_ApplicationModel_DynamicDependency_IPackageDependencyContext<D>::Remove() const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::IPackageDependencyContext>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::IPackageDependencyContext, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::IPackageDependencyContext>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->Remove());
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::IPackageDependencyContext>**)this;
            check_hresult(_winrt_abi_type->Remove());
        }
    }
    template <typename D> auto consume_Microsoft_Windows_ApplicationModel_DynamicDependency_IPackageDependencyContextFactory<D>::CreateInstance(winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::PackageDependencyContextId const& contextId) const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::IPackageDependencyContextFactory>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::IPackageDependencyContextFactory, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::IPackageDependencyContextFactory>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->CreateInstance(impl::bind_in(contextId), &value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::IPackageDependencyContextFactory>**)this;
            check_hresult(_winrt_abi_type->CreateInstance(impl::bind_in(contextId), &value));
        }
        return winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::PackageDependencyContext{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Windows_ApplicationModel_DynamicDependency_IPackageDependencyRankStatics<D>::Default() const
    {
        int32_t value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::IPackageDependencyRankStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::IPackageDependencyRankStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::IPackageDependencyRankStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Default(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::IPackageDependencyRankStatics>**)this;
            check_hresult(_winrt_abi_type->get_Default(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_Windows_ApplicationModel_DynamicDependency_IPackageDependencyStatics<D>::GetFromId(param::hstring const& id) const
    {
        void* result{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::IPackageDependencyStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::IPackageDependencyStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::IPackageDependencyStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->GetFromId(*(void**)(&id), &result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::IPackageDependencyStatics>**)this;
            check_hresult(_winrt_abi_type->GetFromId(*(void**)(&id), &result));
        }
        return winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::PackageDependency{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Windows_ApplicationModel_DynamicDependency_IPackageDependencyStatics<D>::GetFromIdForSystem(param::hstring const& id) const
    {
        void* result{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::IPackageDependencyStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::IPackageDependencyStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::IPackageDependencyStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->GetFromIdForSystem(*(void**)(&id), &result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::IPackageDependencyStatics>**)this;
            check_hresult(_winrt_abi_type->GetFromIdForSystem(*(void**)(&id), &result));
        }
        return winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::PackageDependency{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Windows_ApplicationModel_DynamicDependency_IPackageDependencyStatics<D>::Create(param::hstring const& packageFamilyName, winrt::Windows::ApplicationModel::PackageVersion const& minVersion) const
    {
        void* result{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::IPackageDependencyStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::IPackageDependencyStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::IPackageDependencyStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->Create(*(void**)(&packageFamilyName), impl::bind_in(minVersion), &result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::IPackageDependencyStatics>**)this;
            check_hresult(_winrt_abi_type->Create(*(void**)(&packageFamilyName), impl::bind_in(minVersion), &result));
        }
        return winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::PackageDependency{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Windows_ApplicationModel_DynamicDependency_IPackageDependencyStatics<D>::Create(param::hstring const& packageFamilyName, winrt::Windows::ApplicationModel::PackageVersion const& minVersion, winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::CreatePackageDependencyOptions const& options) const
    {
        void* result{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::IPackageDependencyStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::IPackageDependencyStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::IPackageDependencyStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->Create2(*(void**)(&packageFamilyName), impl::bind_in(minVersion), *(void**)(&options), &result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::IPackageDependencyStatics>**)this;
            check_hresult(_winrt_abi_type->Create2(*(void**)(&packageFamilyName), impl::bind_in(minVersion), *(void**)(&options), &result));
        }
        return winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::PackageDependency{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Windows_ApplicationModel_DynamicDependency_IPackageDependencyStatics<D>::CreateForSystem(param::hstring const& packageFamilyName, winrt::Windows::ApplicationModel::PackageVersion const& minVersion, winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::CreatePackageDependencyOptions const& options) const
    {
        void* result{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::IPackageDependencyStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::IPackageDependencyStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::IPackageDependencyStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->CreateForSystem(*(void**)(&packageFamilyName), impl::bind_in(minVersion), *(void**)(&options), &result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::IPackageDependencyStatics>**)this;
            check_hresult(_winrt_abi_type->CreateForSystem(*(void**)(&packageFamilyName), impl::bind_in(minVersion), *(void**)(&options), &result));
        }
        return winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::PackageDependency{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Windows_ApplicationModel_DynamicDependency_IPackageDependencyStatics<D>::GenerationId() const
    {
        uint32_t value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::IPackageDependencyStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::IPackageDependencyStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::IPackageDependencyStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_GenerationId(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::IPackageDependencyStatics>**)this;
            check_hresult(_winrt_abi_type->get_GenerationId(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_Windows_ApplicationModel_DynamicDependency_IPackageDependencyStatics2<D>::PackageGraphRevisionId() const
    {
        uint32_t value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::IPackageDependencyStatics2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::IPackageDependencyStatics2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::IPackageDependencyStatics2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_PackageGraphRevisionId(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::IPackageDependencyStatics2>**)this;
            check_hresult(_winrt_abi_type->get_PackageGraphRevisionId(&value));
        }
        return value;
    }
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::IAddPackageDependencyOptions> : produce_base<D, winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::IAddPackageDependencyOptions>
    {
        int32_t __stdcall get_Rank(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<int32_t>(this->shim().Rank());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_Rank(int32_t value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Rank(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_PrependIfRankCollision(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().PrependIfRankCollision());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_PrependIfRankCollision(bool value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().PrependIfRankCollision(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::ICreatePackageDependencyOptions> : produce_base<D, winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::ICreatePackageDependencyOptions>
    {
        int32_t __stdcall get_Architectures(uint32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::PackageDependencyProcessorArchitectures>(this->shim().Architectures());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_Architectures(uint32_t value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Architectures(*reinterpret_cast<winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::PackageDependencyProcessorArchitectures const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_VerifyDependencyResolution(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().VerifyDependencyResolution());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_VerifyDependencyResolution(bool value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().VerifyDependencyResolution(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_LifetimeArtifactKind(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::PackageDependencyLifetimeArtifactKind>(this->shim().LifetimeArtifactKind());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_LifetimeArtifactKind(int32_t value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().LifetimeArtifactKind(*reinterpret_cast<winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::PackageDependencyLifetimeArtifactKind const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_LifetimeArtifact(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<hstring>(this->shim().LifetimeArtifact());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_LifetimeArtifact(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().LifetimeArtifact(*reinterpret_cast<hstring const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::IPackageDependency> : produce_base<D, winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::IPackageDependency>
    {
        int32_t __stdcall get_Id(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<hstring>(this->shim().Id());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall Delete() noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Delete();
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall Add(void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::PackageDependencyContext>(this->shim().Add());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall Add2(void* options, void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::PackageDependencyContext>(this->shim().Add(*reinterpret_cast<winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::AddPackageDependencyOptions const*>(&options)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::IPackageDependencyContext> : produce_base<D, winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::IPackageDependencyContext>
    {
        int32_t __stdcall get_ContextId(struct struct_Microsoft_Windows_ApplicationModel_DynamicDependency_PackageDependencyContextId* value) noexcept final try
        {
            zero_abi<winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::PackageDependencyContextId>(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::PackageDependencyContextId>(this->shim().ContextId());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_PackageDependencyId(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<hstring>(this->shim().PackageDependencyId());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_PackageFullName(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<hstring>(this->shim().PackageFullName());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall Remove() noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Remove();
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::IPackageDependencyContextFactory> : produce_base<D, winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::IPackageDependencyContextFactory>
    {
        int32_t __stdcall CreateInstance(struct struct_Microsoft_Windows_ApplicationModel_DynamicDependency_PackageDependencyContextId contextId, void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::PackageDependencyContext>(this->shim().CreateInstance(*reinterpret_cast<winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::PackageDependencyContextId const*>(&contextId)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::IPackageDependencyRankStatics> : produce_base<D, winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::IPackageDependencyRankStatics>
    {
        int32_t __stdcall get_Default(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<int32_t>(this->shim().Default());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::IPackageDependencyStatics> : produce_base<D, winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::IPackageDependencyStatics>
    {
        int32_t __stdcall GetFromId(void* id, void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::PackageDependency>(this->shim().GetFromId(*reinterpret_cast<hstring const*>(&id)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall GetFromIdForSystem(void* id, void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::PackageDependency>(this->shim().GetFromIdForSystem(*reinterpret_cast<hstring const*>(&id)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall Create(void* packageFamilyName, struct struct_Windows_ApplicationModel_PackageVersion minVersion, void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::PackageDependency>(this->shim().Create(*reinterpret_cast<hstring const*>(&packageFamilyName), *reinterpret_cast<winrt::Windows::ApplicationModel::PackageVersion const*>(&minVersion)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall Create2(void* packageFamilyName, struct struct_Windows_ApplicationModel_PackageVersion minVersion, void* options, void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::PackageDependency>(this->shim().Create(*reinterpret_cast<hstring const*>(&packageFamilyName), *reinterpret_cast<winrt::Windows::ApplicationModel::PackageVersion const*>(&minVersion), *reinterpret_cast<winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::CreatePackageDependencyOptions const*>(&options)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall CreateForSystem(void* packageFamilyName, struct struct_Windows_ApplicationModel_PackageVersion minVersion, void* options, void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::PackageDependency>(this->shim().CreateForSystem(*reinterpret_cast<hstring const*>(&packageFamilyName), *reinterpret_cast<winrt::Windows::ApplicationModel::PackageVersion const*>(&minVersion), *reinterpret_cast<winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::CreatePackageDependencyOptions const*>(&options)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_GenerationId(uint32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<uint32_t>(this->shim().GenerationId());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::IPackageDependencyStatics2> : produce_base<D, winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::IPackageDependencyStatics2>
    {
        int32_t __stdcall get_PackageGraphRevisionId(uint32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<uint32_t>(this->shim().PackageGraphRevisionId());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
}
WINRT_EXPORT namespace winrt::Microsoft::Windows::ApplicationModel::DynamicDependency
{
    constexpr auto operator|(PackageDependencyProcessorArchitectures const left, PackageDependencyProcessorArchitectures const right) noexcept
    {
        return static_cast<PackageDependencyProcessorArchitectures>(impl::to_underlying_type(left) | impl::to_underlying_type(right));
    }
    constexpr auto operator|=(PackageDependencyProcessorArchitectures& left, PackageDependencyProcessorArchitectures const right) noexcept
    {
        left = left | right;
        return left;
    }
    constexpr auto operator&(PackageDependencyProcessorArchitectures const left, PackageDependencyProcessorArchitectures const right) noexcept
    {
        return static_cast<PackageDependencyProcessorArchitectures>(impl::to_underlying_type(left) & impl::to_underlying_type(right));
    }
    constexpr auto operator&=(PackageDependencyProcessorArchitectures& left, PackageDependencyProcessorArchitectures const right) noexcept
    {
        left = left & right;
        return left;
    }
    constexpr auto operator~(PackageDependencyProcessorArchitectures const value) noexcept
    {
        return static_cast<PackageDependencyProcessorArchitectures>(~impl::to_underlying_type(value));
    }
    constexpr auto operator^(PackageDependencyProcessorArchitectures const left, PackageDependencyProcessorArchitectures const right) noexcept
    {
        return static_cast<PackageDependencyProcessorArchitectures>(impl::to_underlying_type(left) ^ impl::to_underlying_type(right));
    }
    constexpr auto operator^=(PackageDependencyProcessorArchitectures& left, PackageDependencyProcessorArchitectures const right) noexcept
    {
        left = left ^ right;
        return left;
    }
    inline AddPackageDependencyOptions::AddPackageDependencyOptions() :
        AddPackageDependencyOptions(impl::call_factory_cast<AddPackageDependencyOptions(*)(winrt::Windows::Foundation::IActivationFactory const&), AddPackageDependencyOptions>([](winrt::Windows::Foundation::IActivationFactory const& f) { return f.template ActivateInstance<AddPackageDependencyOptions>(); }))
    {
    }
    inline CreatePackageDependencyOptions::CreatePackageDependencyOptions() :
        CreatePackageDependencyOptions(impl::call_factory_cast<CreatePackageDependencyOptions(*)(winrt::Windows::Foundation::IActivationFactory const&), CreatePackageDependencyOptions>([](winrt::Windows::Foundation::IActivationFactory const& f) { return f.template ActivateInstance<CreatePackageDependencyOptions>(); }))
    {
    }
    inline auto PackageDependency::GetFromId(param::hstring const& id)
    {
        return impl::call_factory<PackageDependency, IPackageDependencyStatics>([&](IPackageDependencyStatics const& f) { return f.GetFromId(id); });
    }
    inline auto PackageDependency::GetFromIdForSystem(param::hstring const& id)
    {
        return impl::call_factory<PackageDependency, IPackageDependencyStatics>([&](IPackageDependencyStatics const& f) { return f.GetFromIdForSystem(id); });
    }
    inline auto PackageDependency::Create(param::hstring const& packageFamilyName, winrt::Windows::ApplicationModel::PackageVersion const& minVersion)
    {
        return impl::call_factory<PackageDependency, IPackageDependencyStatics>([&](IPackageDependencyStatics const& f) { return f.Create(packageFamilyName, minVersion); });
    }
    inline auto PackageDependency::Create(param::hstring const& packageFamilyName, winrt::Windows::ApplicationModel::PackageVersion const& minVersion, winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::CreatePackageDependencyOptions const& options)
    {
        return impl::call_factory<PackageDependency, IPackageDependencyStatics>([&](IPackageDependencyStatics const& f) { return f.Create(packageFamilyName, minVersion, options); });
    }
    inline auto PackageDependency::CreateForSystem(param::hstring const& packageFamilyName, winrt::Windows::ApplicationModel::PackageVersion const& minVersion, winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::CreatePackageDependencyOptions const& options)
    {
        return impl::call_factory<PackageDependency, IPackageDependencyStatics>([&](IPackageDependencyStatics const& f) { return f.CreateForSystem(packageFamilyName, minVersion, options); });
    }
    inline auto PackageDependency::GenerationId()
    {
        return impl::call_factory_cast<uint32_t(*)(IPackageDependencyStatics const&), PackageDependency, IPackageDependencyStatics>([](IPackageDependencyStatics const& f) { return f.GenerationId(); });
    }
    inline auto PackageDependency::PackageGraphRevisionId()
    {
        return impl::call_factory_cast<uint32_t(*)(IPackageDependencyStatics2 const&), PackageDependency, IPackageDependencyStatics2>([](IPackageDependencyStatics2 const& f) { return f.PackageGraphRevisionId(); });
    }
    inline PackageDependencyContext::PackageDependencyContext(winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::PackageDependencyContextId const& contextId) :
        PackageDependencyContext(impl::call_factory<PackageDependencyContext, IPackageDependencyContextFactory>([&](IPackageDependencyContextFactory const& f) { return f.CreateInstance(contextId); }))
    {
    }
    inline auto PackageDependencyRank::Default()
    {
        return impl::call_factory_cast<int32_t(*)(IPackageDependencyRankStatics const&), PackageDependencyRank, IPackageDependencyRankStatics>([](IPackageDependencyRankStatics const& f) { return f.Default(); });
    }
}
namespace std
{
#ifndef WINRT_LEAN_AND_MEAN
    template<> struct hash<winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::IAddPackageDependencyOptions> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::ICreatePackageDependencyOptions> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::IPackageDependency> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::IPackageDependencyContext> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::IPackageDependencyContextFactory> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::IPackageDependencyRankStatics> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::IPackageDependencyStatics> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::IPackageDependencyStatics2> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::AddPackageDependencyOptions> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::CreatePackageDependencyOptions> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::PackageDependency> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::PackageDependencyContext> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::PackageDependencyRank> : winrt::impl::hash_base {};
#endif
#ifdef __cpp_lib_format
#endif
}
#endif
