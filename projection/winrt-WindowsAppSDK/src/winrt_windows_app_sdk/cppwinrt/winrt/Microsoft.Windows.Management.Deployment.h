// WARNING: Please don't edit this file. It was generated by C++/WinRT v2.0.240111.5

#pragma once
#ifndef WINRT_Microsoft_Windows_Management_Deployment_H
#define WINRT_Microsoft_Windows_Management_Deployment_H
#include "winrt/base.h"
static_assert(winrt::check_version(CPPWINRT_VERSION, "2.0.240111.5"), "Mismatched C++/WinRT headers.");
#define CPPWINRT_VERSION "2.0.240111.5"
#include "winrt/impl/Microsoft.Windows.ApplicationModel.DynamicDependency.2.h"
#include "winrt/impl/Windows.ApplicationModel.2.h"
#include "winrt/impl/Windows.Foundation.2.h"
#include "winrt/impl/Windows.Foundation.Collections.2.h"
#include "winrt/impl/Microsoft.Windows.Management.Deployment.2.h"
namespace winrt::impl
{
    template <typename D> auto consume_Microsoft_Windows_Management_Deployment_IAddPackageOptions<D>::TargetVolume() const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IAddPackageOptions)->get_TargetVolume(&value));
        return winrt::Microsoft::Windows::Management::Deployment::PackageVolume{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Windows_Management_Deployment_IAddPackageOptions<D>::TargetVolume(winrt::Microsoft::Windows::Management::Deployment::PackageVolume const& value) const
    {
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IAddPackageOptions)->put_TargetVolume(*(void**)(&value)));
    }
    template <typename D> auto consume_Microsoft_Windows_Management_Deployment_IAddPackageOptions<D>::DependencyPackageUris() const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IAddPackageOptions)->get_DependencyPackageUris(&value));
        return winrt::Windows::Foundation::Collections::IVector<winrt::Windows::Foundation::Uri>{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Windows_Management_Deployment_IAddPackageOptions<D>::OptionalPackageFamilyNames() const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IAddPackageOptions)->get_OptionalPackageFamilyNames(&value));
        return winrt::Windows::Foundation::Collections::IVector<hstring>{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Windows_Management_Deployment_IAddPackageOptions<D>::OptionalPackageUris() const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IAddPackageOptions)->get_OptionalPackageUris(&value));
        return winrt::Windows::Foundation::Collections::IVector<winrt::Windows::Foundation::Uri>{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Windows_Management_Deployment_IAddPackageOptions<D>::RelatedPackageUris() const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IAddPackageOptions)->get_RelatedPackageUris(&value));
        return winrt::Windows::Foundation::Collections::IVector<winrt::Windows::Foundation::Uri>{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Windows_Management_Deployment_IAddPackageOptions<D>::ExternalLocationUri() const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IAddPackageOptions)->get_ExternalLocationUri(&value));
        return winrt::Windows::Foundation::Uri{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Windows_Management_Deployment_IAddPackageOptions<D>::ExternalLocationUri(winrt::Windows::Foundation::Uri const& value) const
    {
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IAddPackageOptions)->put_ExternalLocationUri(*(void**)(&value)));
    }
    template <typename D> auto consume_Microsoft_Windows_Management_Deployment_IAddPackageOptions<D>::StubPackageOption() const
    {
        winrt::Microsoft::Windows::Management::Deployment::StubPackageOption value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IAddPackageOptions)->get_StubPackageOption(reinterpret_cast<int32_t*>(&value)));
        return value;
    }
    template <typename D> auto consume_Microsoft_Windows_Management_Deployment_IAddPackageOptions<D>::StubPackageOption(winrt::Microsoft::Windows::Management::Deployment::StubPackageOption const& value) const
    {
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IAddPackageOptions)->put_StubPackageOption(static_cast<int32_t>(value)));
    }
    template <typename D> auto consume_Microsoft_Windows_Management_Deployment_IAddPackageOptions<D>::AllowUnsigned() const
    {
        bool value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IAddPackageOptions)->get_AllowUnsigned(&value));
        return value;
    }
    template <typename D> auto consume_Microsoft_Windows_Management_Deployment_IAddPackageOptions<D>::AllowUnsigned(bool value) const
    {
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IAddPackageOptions)->put_AllowUnsigned(value));
    }
    template <typename D> auto consume_Microsoft_Windows_Management_Deployment_IAddPackageOptions<D>::DeveloperMode() const
    {
        bool value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IAddPackageOptions)->get_DeveloperMode(&value));
        return value;
    }
    template <typename D> auto consume_Microsoft_Windows_Management_Deployment_IAddPackageOptions<D>::DeveloperMode(bool value) const
    {
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IAddPackageOptions)->put_DeveloperMode(value));
    }
    template <typename D> auto consume_Microsoft_Windows_Management_Deployment_IAddPackageOptions<D>::ForceAppShutdown() const
    {
        bool value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IAddPackageOptions)->get_ForceAppShutdown(&value));
        return value;
    }
    template <typename D> auto consume_Microsoft_Windows_Management_Deployment_IAddPackageOptions<D>::ForceAppShutdown(bool value) const
    {
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IAddPackageOptions)->put_ForceAppShutdown(value));
    }
    template <typename D> auto consume_Microsoft_Windows_Management_Deployment_IAddPackageOptions<D>::ForceTargetAppShutdown() const
    {
        bool value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IAddPackageOptions)->get_ForceTargetAppShutdown(&value));
        return value;
    }
    template <typename D> auto consume_Microsoft_Windows_Management_Deployment_IAddPackageOptions<D>::ForceTargetAppShutdown(bool value) const
    {
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IAddPackageOptions)->put_ForceTargetAppShutdown(value));
    }
    template <typename D> auto consume_Microsoft_Windows_Management_Deployment_IAddPackageOptions<D>::ForceUpdateFromAnyVersion() const
    {
        bool value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IAddPackageOptions)->get_ForceUpdateFromAnyVersion(&value));
        return value;
    }
    template <typename D> auto consume_Microsoft_Windows_Management_Deployment_IAddPackageOptions<D>::ForceUpdateFromAnyVersion(bool value) const
    {
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IAddPackageOptions)->put_ForceUpdateFromAnyVersion(value));
    }
    template <typename D> auto consume_Microsoft_Windows_Management_Deployment_IAddPackageOptions<D>::InstallAllResources() const
    {
        bool value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IAddPackageOptions)->get_InstallAllResources(&value));
        return value;
    }
    template <typename D> auto consume_Microsoft_Windows_Management_Deployment_IAddPackageOptions<D>::InstallAllResources(bool value) const
    {
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IAddPackageOptions)->put_InstallAllResources(value));
    }
    template <typename D> auto consume_Microsoft_Windows_Management_Deployment_IAddPackageOptions<D>::RequiredContentGroupOnly() const
    {
        bool value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IAddPackageOptions)->get_RequiredContentGroupOnly(&value));
        return value;
    }
    template <typename D> auto consume_Microsoft_Windows_Management_Deployment_IAddPackageOptions<D>::RequiredContentGroupOnly(bool value) const
    {
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IAddPackageOptions)->put_RequiredContentGroupOnly(value));
    }
    template <typename D> auto consume_Microsoft_Windows_Management_Deployment_IAddPackageOptions<D>::RetainFilesOnFailure() const
    {
        bool value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IAddPackageOptions)->get_RetainFilesOnFailure(&value));
        return value;
    }
    template <typename D> auto consume_Microsoft_Windows_Management_Deployment_IAddPackageOptions<D>::RetainFilesOnFailure(bool value) const
    {
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IAddPackageOptions)->put_RetainFilesOnFailure(value));
    }
    template <typename D> auto consume_Microsoft_Windows_Management_Deployment_IAddPackageOptions<D>::StageInPlace() const
    {
        bool value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IAddPackageOptions)->get_StageInPlace(&value));
        return value;
    }
    template <typename D> auto consume_Microsoft_Windows_Management_Deployment_IAddPackageOptions<D>::StageInPlace(bool value) const
    {
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IAddPackageOptions)->put_StageInPlace(value));
    }
    template <typename D> auto consume_Microsoft_Windows_Management_Deployment_IAddPackageOptions<D>::DeferRegistrationWhenPackagesAreInUse() const
    {
        bool value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IAddPackageOptions)->get_DeferRegistrationWhenPackagesAreInUse(&value));
        return value;
    }
    template <typename D> auto consume_Microsoft_Windows_Management_Deployment_IAddPackageOptions<D>::DeferRegistrationWhenPackagesAreInUse(bool value) const
    {
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IAddPackageOptions)->put_DeferRegistrationWhenPackagesAreInUse(value));
    }
    template <typename D> auto consume_Microsoft_Windows_Management_Deployment_IAddPackageOptions<D>::IsExpectedDigestsSupported() const
    {
        bool value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IAddPackageOptions)->get_IsExpectedDigestsSupported(&value));
        return value;
    }
    template <typename D> auto consume_Microsoft_Windows_Management_Deployment_IAddPackageOptions<D>::ExpectedDigests() const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IAddPackageOptions)->get_ExpectedDigests(&value));
        return winrt::Windows::Foundation::Collections::IMap<winrt::Windows::Foundation::Uri, hstring>{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Windows_Management_Deployment_IAddPackageOptions<D>::IsLimitToExistingPackagesSupported() const
    {
        bool value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IAddPackageOptions)->get_IsLimitToExistingPackagesSupported(&value));
        return value;
    }
    template <typename D> auto consume_Microsoft_Windows_Management_Deployment_IAddPackageOptions<D>::LimitToExistingPackages() const
    {
        bool value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IAddPackageOptions)->get_LimitToExistingPackages(&value));
        return value;
    }
    template <typename D> auto consume_Microsoft_Windows_Management_Deployment_IAddPackageOptions<D>::LimitToExistingPackages(bool value) const
    {
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IAddPackageOptions)->put_LimitToExistingPackages(value));
    }
    template <typename D> auto consume_Microsoft_Windows_Management_Deployment_IEnsureReadyOptions<D>::AddPackageOptions() const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IEnsureReadyOptions)->get_AddPackageOptions(&value));
        return winrt::Microsoft::Windows::Management::Deployment::AddPackageOptions{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Windows_Management_Deployment_IPackageDeploymentManager<D>::IsPackageReady(param::hstring const& package) const
    {
        bool result{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IPackageDeploymentManager)->IsPackageReady(*(void**)(&package), &result));
        return result;
    }
    template <typename D> auto consume_Microsoft_Windows_Management_Deployment_IPackageDeploymentManager<D>::IsPackageReadyByUri(winrt::Windows::Foundation::Uri const& packageUri) const
    {
        bool result{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IPackageDeploymentManager)->IsPackageReadyByUri(*(void**)(&packageUri), &result));
        return result;
    }
    template <typename D> auto consume_Microsoft_Windows_Management_Deployment_IPackageDeploymentManager<D>::IsPackageSetReady(winrt::Microsoft::Windows::Management::Deployment::PackageSet const& packageSet) const
    {
        bool result{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IPackageDeploymentManager)->IsPackageSetReady(*(void**)(&packageSet), &result));
        return result;
    }
    template <typename D> auto consume_Microsoft_Windows_Management_Deployment_IPackageDeploymentManager<D>::EnsurePackageReadyAsync(param::hstring const& package, winrt::Microsoft::Windows::Management::Deployment::EnsureReadyOptions const& options) const
    {
        void* operation{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IPackageDeploymentManager)->EnsurePackageReadyAsync(*(void**)(&package), *(void**)(&options), &operation));
        return winrt::Windows::Foundation::IAsyncOperationWithProgress<winrt::Microsoft::Windows::Management::Deployment::PackageDeploymentResult, winrt::Microsoft::Windows::Management::Deployment::PackageDeploymentProgress>{ operation, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Windows_Management_Deployment_IPackageDeploymentManager<D>::EnsurePackageReadyByUriAsync(winrt::Windows::Foundation::Uri const& packageUri, winrt::Microsoft::Windows::Management::Deployment::EnsureReadyOptions const& options) const
    {
        void* operation{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IPackageDeploymentManager)->EnsurePackageReadyByUriAsync(*(void**)(&packageUri), *(void**)(&options), &operation));
        return winrt::Windows::Foundation::IAsyncOperationWithProgress<winrt::Microsoft::Windows::Management::Deployment::PackageDeploymentResult, winrt::Microsoft::Windows::Management::Deployment::PackageDeploymentProgress>{ operation, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Windows_Management_Deployment_IPackageDeploymentManager<D>::EnsurePackageSetReadyAsync(winrt::Microsoft::Windows::Management::Deployment::PackageSet const& packageSet, winrt::Microsoft::Windows::Management::Deployment::EnsureReadyOptions const& options) const
    {
        void* operation{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IPackageDeploymentManager)->EnsurePackageSetReadyAsync(*(void**)(&packageSet), *(void**)(&options), &operation));
        return winrt::Windows::Foundation::IAsyncOperationWithProgress<winrt::Microsoft::Windows::Management::Deployment::PackageDeploymentResult, winrt::Microsoft::Windows::Management::Deployment::PackageDeploymentProgress>{ operation, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Windows_Management_Deployment_IPackageDeploymentManager<D>::AddPackageAsync(param::hstring const& package, winrt::Microsoft::Windows::Management::Deployment::AddPackageOptions const& options) const
    {
        void* operation{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IPackageDeploymentManager)->AddPackageAsync(*(void**)(&package), *(void**)(&options), &operation));
        return winrt::Windows::Foundation::IAsyncOperationWithProgress<winrt::Microsoft::Windows::Management::Deployment::PackageDeploymentResult, winrt::Microsoft::Windows::Management::Deployment::PackageDeploymentProgress>{ operation, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Windows_Management_Deployment_IPackageDeploymentManager<D>::AddPackageByUriAsync(winrt::Windows::Foundation::Uri const& packageUri, winrt::Microsoft::Windows::Management::Deployment::AddPackageOptions const& options) const
    {
        void* operation{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IPackageDeploymentManager)->AddPackageByUriAsync(*(void**)(&packageUri), *(void**)(&options), &operation));
        return winrt::Windows::Foundation::IAsyncOperationWithProgress<winrt::Microsoft::Windows::Management::Deployment::PackageDeploymentResult, winrt::Microsoft::Windows::Management::Deployment::PackageDeploymentProgress>{ operation, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Windows_Management_Deployment_IPackageDeploymentManager<D>::AddPackageSetAsync(winrt::Microsoft::Windows::Management::Deployment::PackageSet const& packageSet, winrt::Microsoft::Windows::Management::Deployment::AddPackageOptions const& options) const
    {
        void* operation{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IPackageDeploymentManager)->AddPackageSetAsync(*(void**)(&packageSet), *(void**)(&options), &operation));
        return winrt::Windows::Foundation::IAsyncOperationWithProgress<winrt::Microsoft::Windows::Management::Deployment::PackageDeploymentResult, winrt::Microsoft::Windows::Management::Deployment::PackageDeploymentProgress>{ operation, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Windows_Management_Deployment_IPackageDeploymentManager<D>::StagePackageAsync(param::hstring const& package, winrt::Microsoft::Windows::Management::Deployment::StagePackageOptions const& options) const
    {
        void* operation{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IPackageDeploymentManager)->StagePackageAsync(*(void**)(&package), *(void**)(&options), &operation));
        return winrt::Windows::Foundation::IAsyncOperationWithProgress<winrt::Microsoft::Windows::Management::Deployment::PackageDeploymentResult, winrt::Microsoft::Windows::Management::Deployment::PackageDeploymentProgress>{ operation, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Windows_Management_Deployment_IPackageDeploymentManager<D>::StagePackageByUriAsync(winrt::Windows::Foundation::Uri const& packageUri, winrt::Microsoft::Windows::Management::Deployment::StagePackageOptions const& options) const
    {
        void* operation{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IPackageDeploymentManager)->StagePackageByUriAsync(*(void**)(&packageUri), *(void**)(&options), &operation));
        return winrt::Windows::Foundation::IAsyncOperationWithProgress<winrt::Microsoft::Windows::Management::Deployment::PackageDeploymentResult, winrt::Microsoft::Windows::Management::Deployment::PackageDeploymentProgress>{ operation, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Windows_Management_Deployment_IPackageDeploymentManager<D>::StagePackageSetAsync(winrt::Microsoft::Windows::Management::Deployment::PackageSet const& packageSet, winrt::Microsoft::Windows::Management::Deployment::StagePackageOptions const& options) const
    {
        void* operation{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IPackageDeploymentManager)->StagePackageSetAsync(*(void**)(&packageSet), *(void**)(&options), &operation));
        return winrt::Windows::Foundation::IAsyncOperationWithProgress<winrt::Microsoft::Windows::Management::Deployment::PackageDeploymentResult, winrt::Microsoft::Windows::Management::Deployment::PackageDeploymentProgress>{ operation, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Windows_Management_Deployment_IPackageDeploymentManager<D>::RegisterPackageAsync(param::hstring const& package, winrt::Microsoft::Windows::Management::Deployment::RegisterPackageOptions const& options) const
    {
        void* operation{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IPackageDeploymentManager)->RegisterPackageAsync(*(void**)(&package), *(void**)(&options), &operation));
        return winrt::Windows::Foundation::IAsyncOperationWithProgress<winrt::Microsoft::Windows::Management::Deployment::PackageDeploymentResult, winrt::Microsoft::Windows::Management::Deployment::PackageDeploymentProgress>{ operation, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Windows_Management_Deployment_IPackageDeploymentManager<D>::RegisterPackageByUriAsync(winrt::Windows::Foundation::Uri const& packageUri, winrt::Microsoft::Windows::Management::Deployment::RegisterPackageOptions const& options) const
    {
        void* operation{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IPackageDeploymentManager)->RegisterPackageByUriAsync(*(void**)(&packageUri), *(void**)(&options), &operation));
        return winrt::Windows::Foundation::IAsyncOperationWithProgress<winrt::Microsoft::Windows::Management::Deployment::PackageDeploymentResult, winrt::Microsoft::Windows::Management::Deployment::PackageDeploymentProgress>{ operation, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Windows_Management_Deployment_IPackageDeploymentManager<D>::RegisterPackageSetAsync(winrt::Microsoft::Windows::Management::Deployment::PackageSet const& packageSet, winrt::Microsoft::Windows::Management::Deployment::RegisterPackageOptions const& options) const
    {
        void* operation{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IPackageDeploymentManager)->RegisterPackageSetAsync(*(void**)(&packageSet), *(void**)(&options), &operation));
        return winrt::Windows::Foundation::IAsyncOperationWithProgress<winrt::Microsoft::Windows::Management::Deployment::PackageDeploymentResult, winrt::Microsoft::Windows::Management::Deployment::PackageDeploymentProgress>{ operation, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Windows_Management_Deployment_IPackageDeploymentManager<D>::RemovePackageAsync(param::hstring const& package, winrt::Microsoft::Windows::Management::Deployment::RemovePackageOptions const& options) const
    {
        void* operation{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IPackageDeploymentManager)->RemovePackageAsync(*(void**)(&package), *(void**)(&options), &operation));
        return winrt::Windows::Foundation::IAsyncOperationWithProgress<winrt::Microsoft::Windows::Management::Deployment::PackageDeploymentResult, winrt::Microsoft::Windows::Management::Deployment::PackageDeploymentProgress>{ operation, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Windows_Management_Deployment_IPackageDeploymentManager<D>::RemovePackageByFullNameAsync(param::hstring const& packageFullName, winrt::Microsoft::Windows::Management::Deployment::RemovePackageOptions const& options) const
    {
        void* operation{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IPackageDeploymentManager)->RemovePackageByFullNameAsync(*(void**)(&packageFullName), *(void**)(&options), &operation));
        return winrt::Windows::Foundation::IAsyncOperationWithProgress<winrt::Microsoft::Windows::Management::Deployment::PackageDeploymentResult, winrt::Microsoft::Windows::Management::Deployment::PackageDeploymentProgress>{ operation, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Windows_Management_Deployment_IPackageDeploymentManager<D>::RemovePackageByFamilyNameAsync(param::hstring const& packageFamilyName, winrt::Microsoft::Windows::Management::Deployment::RemovePackageOptions const& options) const
    {
        void* operation{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IPackageDeploymentManager)->RemovePackageByFamilyNameAsync(*(void**)(&packageFamilyName), *(void**)(&options), &operation));
        return winrt::Windows::Foundation::IAsyncOperationWithProgress<winrt::Microsoft::Windows::Management::Deployment::PackageDeploymentResult, winrt::Microsoft::Windows::Management::Deployment::PackageDeploymentProgress>{ operation, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Windows_Management_Deployment_IPackageDeploymentManager<D>::RemovePackageByUriAsync(winrt::Windows::Foundation::Uri const& packageUri, winrt::Microsoft::Windows::Management::Deployment::RemovePackageOptions const& options) const
    {
        void* operation{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IPackageDeploymentManager)->RemovePackageByUriAsync(*(void**)(&packageUri), *(void**)(&options), &operation));
        return winrt::Windows::Foundation::IAsyncOperationWithProgress<winrt::Microsoft::Windows::Management::Deployment::PackageDeploymentResult, winrt::Microsoft::Windows::Management::Deployment::PackageDeploymentProgress>{ operation, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Windows_Management_Deployment_IPackageDeploymentManager<D>::RemovePackageSetAsync(winrt::Microsoft::Windows::Management::Deployment::PackageSet const& packageSet, winrt::Microsoft::Windows::Management::Deployment::RemovePackageOptions const& options) const
    {
        void* operation{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IPackageDeploymentManager)->RemovePackageSetAsync(*(void**)(&packageSet), *(void**)(&options), &operation));
        return winrt::Windows::Foundation::IAsyncOperationWithProgress<winrt::Microsoft::Windows::Management::Deployment::PackageDeploymentResult, winrt::Microsoft::Windows::Management::Deployment::PackageDeploymentProgress>{ operation, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Windows_Management_Deployment_IPackageDeploymentManager<D>::ResetPackageAsync(param::hstring const& package) const
    {
        void* operation{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IPackageDeploymentManager)->ResetPackageAsync(*(void**)(&package), &operation));
        return winrt::Windows::Foundation::IAsyncOperationWithProgress<winrt::Microsoft::Windows::Management::Deployment::PackageDeploymentResult, winrt::Microsoft::Windows::Management::Deployment::PackageDeploymentProgress>{ operation, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Windows_Management_Deployment_IPackageDeploymentManager<D>::ResetPackageByUriAsync(winrt::Windows::Foundation::Uri const& packageUri) const
    {
        void* operation{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IPackageDeploymentManager)->ResetPackageByUriAsync(*(void**)(&packageUri), &operation));
        return winrt::Windows::Foundation::IAsyncOperationWithProgress<winrt::Microsoft::Windows::Management::Deployment::PackageDeploymentResult, winrt::Microsoft::Windows::Management::Deployment::PackageDeploymentProgress>{ operation, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Windows_Management_Deployment_IPackageDeploymentManager<D>::ResetPackageSetAsync(winrt::Microsoft::Windows::Management::Deployment::PackageSet const& packageSet) const
    {
        void* operation{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IPackageDeploymentManager)->ResetPackageSetAsync(*(void**)(&packageSet), &operation));
        return winrt::Windows::Foundation::IAsyncOperationWithProgress<winrt::Microsoft::Windows::Management::Deployment::PackageDeploymentResult, winrt::Microsoft::Windows::Management::Deployment::PackageDeploymentProgress>{ operation, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Windows_Management_Deployment_IPackageDeploymentManager<D>::RepairPackageAsync(param::hstring const& package) const
    {
        void* operation{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IPackageDeploymentManager)->RepairPackageAsync(*(void**)(&package), &operation));
        return winrt::Windows::Foundation::IAsyncOperationWithProgress<winrt::Microsoft::Windows::Management::Deployment::PackageDeploymentResult, winrt::Microsoft::Windows::Management::Deployment::PackageDeploymentProgress>{ operation, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Windows_Management_Deployment_IPackageDeploymentManager<D>::RepairPackageByUriAsync(winrt::Windows::Foundation::Uri const& packageUri) const
    {
        void* operation{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IPackageDeploymentManager)->RepairPackageByUriAsync(*(void**)(&packageUri), &operation));
        return winrt::Windows::Foundation::IAsyncOperationWithProgress<winrt::Microsoft::Windows::Management::Deployment::PackageDeploymentResult, winrt::Microsoft::Windows::Management::Deployment::PackageDeploymentProgress>{ operation, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Windows_Management_Deployment_IPackageDeploymentManager<D>::RepairPackageSetAsync(winrt::Microsoft::Windows::Management::Deployment::PackageSet const& packageSet) const
    {
        void* operation{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IPackageDeploymentManager)->RepairPackageSetAsync(*(void**)(&packageSet), &operation));
        return winrt::Windows::Foundation::IAsyncOperationWithProgress<winrt::Microsoft::Windows::Management::Deployment::PackageDeploymentResult, winrt::Microsoft::Windows::Management::Deployment::PackageDeploymentProgress>{ operation, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Windows_Management_Deployment_IPackageDeploymentManager<D>::ProvisionPackageAsync(param::hstring const& package, winrt::Microsoft::Windows::Management::Deployment::ProvisionPackageOptions const& options) const
    {
        void* operation{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IPackageDeploymentManager)->ProvisionPackageAsync(*(void**)(&package), *(void**)(&options), &operation));
        return winrt::Windows::Foundation::IAsyncOperationWithProgress<winrt::Microsoft::Windows::Management::Deployment::PackageDeploymentResult, winrt::Microsoft::Windows::Management::Deployment::PackageDeploymentProgress>{ operation, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Windows_Management_Deployment_IPackageDeploymentManager<D>::ProvisionPackageByUriAsync(winrt::Windows::Foundation::Uri const& packageUri, winrt::Microsoft::Windows::Management::Deployment::ProvisionPackageOptions const& options) const
    {
        void* operation{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IPackageDeploymentManager)->ProvisionPackageByUriAsync(*(void**)(&packageUri), *(void**)(&options), &operation));
        return winrt::Windows::Foundation::IAsyncOperationWithProgress<winrt::Microsoft::Windows::Management::Deployment::PackageDeploymentResult, winrt::Microsoft::Windows::Management::Deployment::PackageDeploymentProgress>{ operation, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Windows_Management_Deployment_IPackageDeploymentManager<D>::ProvisionPackageSetAsync(winrt::Microsoft::Windows::Management::Deployment::PackageSet const& packageSet, winrt::Microsoft::Windows::Management::Deployment::ProvisionPackageOptions const& options) const
    {
        void* operation{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IPackageDeploymentManager)->ProvisionPackageSetAsync(*(void**)(&packageSet), *(void**)(&options), &operation));
        return winrt::Windows::Foundation::IAsyncOperationWithProgress<winrt::Microsoft::Windows::Management::Deployment::PackageDeploymentResult, winrt::Microsoft::Windows::Management::Deployment::PackageDeploymentProgress>{ operation, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Windows_Management_Deployment_IPackageDeploymentManager<D>::DeprovisionPackageAsync(param::hstring const& package) const
    {
        void* operation{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IPackageDeploymentManager)->DeprovisionPackageAsync(*(void**)(&package), &operation));
        return winrt::Windows::Foundation::IAsyncOperationWithProgress<winrt::Microsoft::Windows::Management::Deployment::PackageDeploymentResult, winrt::Microsoft::Windows::Management::Deployment::PackageDeploymentProgress>{ operation, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Windows_Management_Deployment_IPackageDeploymentManager<D>::DeprovisionPackageByUriAsync(winrt::Windows::Foundation::Uri const& packageUri) const
    {
        void* operation{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IPackageDeploymentManager)->DeprovisionPackageByUriAsync(*(void**)(&packageUri), &operation));
        return winrt::Windows::Foundation::IAsyncOperationWithProgress<winrt::Microsoft::Windows::Management::Deployment::PackageDeploymentResult, winrt::Microsoft::Windows::Management::Deployment::PackageDeploymentProgress>{ operation, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Windows_Management_Deployment_IPackageDeploymentManager<D>::DeprovisionPackageSetAsync(winrt::Microsoft::Windows::Management::Deployment::PackageSet const& packageSet) const
    {
        void* operation{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IPackageDeploymentManager)->DeprovisionPackageSetAsync(*(void**)(&packageSet), &operation));
        return winrt::Windows::Foundation::IAsyncOperationWithProgress<winrt::Microsoft::Windows::Management::Deployment::PackageDeploymentResult, winrt::Microsoft::Windows::Management::Deployment::PackageDeploymentProgress>{ operation, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Windows_Management_Deployment_IPackageDeploymentManager<D>::IsPackageRegistrationPending(param::hstring const& packageFamilyName) const
    {
        bool result{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IPackageDeploymentManager)->IsPackageRegistrationPending(*(void**)(&packageFamilyName), &result));
        return result;
    }
    template <typename D> auto consume_Microsoft_Windows_Management_Deployment_IPackageDeploymentManager<D>::IsPackageRegistrationPendingForUser(param::hstring const& userSecurityId, param::hstring const& packageFamilyName) const
    {
        bool result{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IPackageDeploymentManager)->IsPackageRegistrationPendingForUser(*(void**)(&userSecurityId), *(void**)(&packageFamilyName), &result));
        return result;
    }
    template <typename D> auto consume_Microsoft_Windows_Management_Deployment_IPackageDeploymentManagerStatics<D>::GetDefault() const
    {
        void* result{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IPackageDeploymentManagerStatics)->GetDefault(&result));
        return winrt::Microsoft::Windows::Management::Deployment::PackageDeploymentManager{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Windows_Management_Deployment_IPackageDeploymentResult<D>::Status() const
    {
        winrt::Microsoft::Windows::Management::Deployment::PackageDeploymentStatus value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IPackageDeploymentResult)->get_Status(reinterpret_cast<int32_t*>(&value)));
        return value;
    }
    template <typename D> auto consume_Microsoft_Windows_Management_Deployment_IPackageDeploymentResult<D>::Error() const
    {
        winrt::hresult value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IPackageDeploymentResult)->get_Error(put_abi(value)));
        return value;
    }
    template <typename D> auto consume_Microsoft_Windows_Management_Deployment_IPackageDeploymentResult<D>::ExtendedError() const
    {
        winrt::hresult value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IPackageDeploymentResult)->get_ExtendedError(put_abi(value)));
        return value;
    }
    template <typename D> auto consume_Microsoft_Windows_Management_Deployment_IPackageDeploymentResult<D>::ErrorText() const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IPackageDeploymentResult)->get_ErrorText(&value));
        return hstring{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Windows_Management_Deployment_IPackageDeploymentResult<D>::ActivityId() const
    {
        winrt::guid value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IPackageDeploymentResult)->get_ActivityId(put_abi(value)));
        return value;
    }
    template <typename D> auto consume_Microsoft_Windows_Management_Deployment_IPackageRuntimeManager<D>::AddPackageSet(winrt::Microsoft::Windows::Management::Deployment::PackageSet const& packageSet) const
    {
        void* result{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IPackageRuntimeManager)->AddPackageSet(*(void**)(&packageSet), &result));
        return winrt::Microsoft::Windows::Management::Deployment::PackageSetRuntimeDisposition{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Windows_Management_Deployment_IPackageRuntimeManager<D>::AddPackageSet(winrt::Microsoft::Windows::Management::Deployment::PackageSet const& packageSet, winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::CreatePackageDependencyOptions const& createOptions, winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::AddPackageDependencyOptions const& addOptions) const
    {
        void* result{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IPackageRuntimeManager)->AddPackageSetWithOptions(*(void**)(&packageSet), *(void**)(&createOptions), *(void**)(&addOptions), &result));
        return winrt::Microsoft::Windows::Management::Deployment::PackageSetRuntimeDisposition{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Windows_Management_Deployment_IPackageRuntimeManager<D>::RemovePackageSet(winrt::Microsoft::Windows::Management::Deployment::PackageSetRuntimeDisposition const& packageSetRuntimeDisposition) const
    {
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IPackageRuntimeManager)->RemovePackageSet(*(void**)(&packageSetRuntimeDisposition)));
    }
    template <typename D> auto consume_Microsoft_Windows_Management_Deployment_IPackageRuntimeManagerStatics<D>::GetDefault() const
    {
        void* result{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IPackageRuntimeManagerStatics)->GetDefault(&result));
        return winrt::Microsoft::Windows::Management::Deployment::PackageRuntimeManager{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Windows_Management_Deployment_IPackageSet<D>::Id() const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IPackageSet)->get_Id(&value));
        return hstring{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Windows_Management_Deployment_IPackageSet<D>::Id(param::hstring const& value) const
    {
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IPackageSet)->put_Id(*(void**)(&value)));
    }
    template <typename D> auto consume_Microsoft_Windows_Management_Deployment_IPackageSet<D>::PackageUri() const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IPackageSet)->get_PackageUri(&value));
        return winrt::Windows::Foundation::Uri{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Windows_Management_Deployment_IPackageSet<D>::PackageUri(winrt::Windows::Foundation::Uri const& value) const
    {
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IPackageSet)->put_PackageUri(*(void**)(&value)));
    }
    template <typename D> auto consume_Microsoft_Windows_Management_Deployment_IPackageSet<D>::Items() const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IPackageSet)->get_Items(&value));
        return winrt::Windows::Foundation::Collections::IVector<winrt::Microsoft::Windows::Management::Deployment::PackageSetItem>{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Windows_Management_Deployment_IPackageSetItem<D>::Id() const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IPackageSetItem)->get_Id(&value));
        return hstring{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Windows_Management_Deployment_IPackageSetItem<D>::Id(param::hstring const& value) const
    {
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IPackageSetItem)->put_Id(*(void**)(&value)));
    }
    template <typename D> auto consume_Microsoft_Windows_Management_Deployment_IPackageSetItem<D>::PackageFamilyName() const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IPackageSetItem)->get_PackageFamilyName(&value));
        return hstring{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Windows_Management_Deployment_IPackageSetItem<D>::PackageFamilyName(param::hstring const& value) const
    {
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IPackageSetItem)->put_PackageFamilyName(*(void**)(&value)));
    }
    template <typename D> auto consume_Microsoft_Windows_Management_Deployment_IPackageSetItem<D>::MinVersion() const
    {
        winrt::Windows::ApplicationModel::PackageVersion value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IPackageSetItem)->get_MinVersion(put_abi(value)));
        return value;
    }
    template <typename D> auto consume_Microsoft_Windows_Management_Deployment_IPackageSetItem<D>::MinVersion(winrt::Windows::ApplicationModel::PackageVersion const& value) const
    {
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IPackageSetItem)->put_MinVersion(impl::bind_in(value)));
    }
    template <typename D> auto consume_Microsoft_Windows_Management_Deployment_IPackageSetItem<D>::ProcessorArchitectureFilter() const
    {
        winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::PackageDependencyProcessorArchitectures value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IPackageSetItem)->get_ProcessorArchitectureFilter(reinterpret_cast<uint32_t*>(&value)));
        return value;
    }
    template <typename D> auto consume_Microsoft_Windows_Management_Deployment_IPackageSetItem<D>::ProcessorArchitectureFilter(winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::PackageDependencyProcessorArchitectures const& value) const
    {
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IPackageSetItem)->put_ProcessorArchitectureFilter(static_cast<uint32_t>(value)));
    }
    template <typename D> auto consume_Microsoft_Windows_Management_Deployment_IPackageSetItem<D>::PackageUri() const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IPackageSetItem)->get_PackageUri(&value));
        return winrt::Windows::Foundation::Uri{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Windows_Management_Deployment_IPackageSetItem<D>::PackageUri(winrt::Windows::Foundation::Uri const& value) const
    {
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IPackageSetItem)->put_PackageUri(*(void**)(&value)));
    }
    template <typename D> auto consume_Microsoft_Windows_Management_Deployment_IPackageSetItemRuntimeDisposition<D>::PackageSetItemId() const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IPackageSetItemRuntimeDisposition)->get_PackageSetItemId(&value));
        return hstring{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Windows_Management_Deployment_IPackageSetItemRuntimeDisposition<D>::PackageFullName() const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IPackageSetItemRuntimeDisposition)->get_PackageFullName(&value));
        return hstring{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Windows_Management_Deployment_IPackageSetItemRuntimeDisposition<D>::PackageDependencyId() const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IPackageSetItemRuntimeDisposition)->get_PackageDependencyId(&value));
        return hstring{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Windows_Management_Deployment_IPackageSetItemRuntimeDisposition<D>::PackageDependencyContextId() const
    {
        winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::PackageDependencyContextId value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IPackageSetItemRuntimeDisposition)->get_PackageDependencyContextId(put_abi(value)));
        return value;
    }
    template <typename D> auto consume_Microsoft_Windows_Management_Deployment_IPackageSetRuntimeDisposition<D>::PackageSetId() const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IPackageSetRuntimeDisposition)->get_PackageSetId(&value));
        return hstring{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Windows_Management_Deployment_IPackageSetRuntimeDisposition<D>::PackageSetId(param::hstring const& value) const
    {
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IPackageSetRuntimeDisposition)->put_PackageSetId(*(void**)(&value)));
    }
    template <typename D> auto consume_Microsoft_Windows_Management_Deployment_IPackageSetRuntimeDisposition<D>::PackageSetItemRuntimeDispositions() const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IPackageSetRuntimeDisposition)->get_PackageSetItemRuntimeDispositions(&value));
        return winrt::Windows::Foundation::Collections::IVector<winrt::Microsoft::Windows::Management::Deployment::PackageSetItemRuntimeDisposition>{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Windows_Management_Deployment_IPackageVolume<D>::IsSystemVolume() const
    {
        bool value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IPackageVolume)->get_IsSystemVolume(&value));
        return value;
    }
    template <typename D> auto consume_Microsoft_Windows_Management_Deployment_IPackageVolume<D>::MountPoint() const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IPackageVolume)->get_MountPoint(&value));
        return hstring{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Windows_Management_Deployment_IPackageVolume<D>::Name() const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IPackageVolume)->get_Name(&value));
        return hstring{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Windows_Management_Deployment_IPackageVolume<D>::PackageStorePath() const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IPackageVolume)->get_PackageStorePath(&value));
        return hstring{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Windows_Management_Deployment_IPackageVolume<D>::SupportsHardLinks() const
    {
        bool value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IPackageVolume)->get_SupportsHardLinks(&value));
        return value;
    }
    template <typename D> auto consume_Microsoft_Windows_Management_Deployment_IPackageVolume<D>::IsFullTrustPackageSupported() const
    {
        bool value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IPackageVolume)->get_IsFullTrustPackageSupported(&value));
        return value;
    }
    template <typename D> auto consume_Microsoft_Windows_Management_Deployment_IPackageVolume<D>::IsAppxInstallSupported() const
    {
        bool value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IPackageVolume)->get_IsAppxInstallSupported(&value));
        return value;
    }
    template <typename D> auto consume_Microsoft_Windows_Management_Deployment_IPackageVolume<D>::IsRepairNeeded() const
    {
        bool result{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IPackageVolume)->IsRepairNeeded(&result));
        return result;
    }
    template <typename D> auto consume_Microsoft_Windows_Management_Deployment_IPackageVolume<D>::Repair() const
    {
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IPackageVolume)->Repair());
    }
    template <typename D> auto consume_Microsoft_Windows_Management_Deployment_IPackageVolumeStatics<D>::FindPackageVolumes() const
    {
        void* result{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IPackageVolumeStatics)->FindPackageVolumes(&result));
        return winrt::Windows::Foundation::Collections::IVector<winrt::Microsoft::Windows::Management::Deployment::PackageVolume>{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Windows_Management_Deployment_IPackageVolumeStatics<D>::FindPackageVolumeByPath(param::hstring const& packageStorePath) const
    {
        void* result{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IPackageVolumeStatics)->FindPackageVolumeByPath(*(void**)(&packageStorePath), &result));
        return winrt::Microsoft::Windows::Management::Deployment::PackageVolume{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Windows_Management_Deployment_IPackageVolumeStatics<D>::FindPackageVolumeByName(param::hstring const& name) const
    {
        void* result{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IPackageVolumeStatics)->FindPackageVolumeByName(*(void**)(&name), &result));
        return winrt::Microsoft::Windows::Management::Deployment::PackageVolume{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Windows_Management_Deployment_IProvisionPackageOptions<D>::IsOptionalPackageFamilyNamesSupported() const
    {
        bool value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IProvisionPackageOptions)->get_IsOptionalPackageFamilyNamesSupported(&value));
        return value;
    }
    template <typename D> auto consume_Microsoft_Windows_Management_Deployment_IProvisionPackageOptions<D>::OptionalPackageFamilyNames() const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IProvisionPackageOptions)->get_OptionalPackageFamilyNames(&value));
        return winrt::Windows::Foundation::Collections::IVector<hstring>{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Windows_Management_Deployment_IProvisionPackageOptions<D>::IsProjectionOrderPackageFamilyNamesSupported() const
    {
        bool value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IProvisionPackageOptions)->get_IsProjectionOrderPackageFamilyNamesSupported(&value));
        return value;
    }
    template <typename D> auto consume_Microsoft_Windows_Management_Deployment_IProvisionPackageOptions<D>::ProjectionOrderPackageFamilyNames() const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IProvisionPackageOptions)->get_ProjectionOrderPackageFamilyNames(&value));
        return winrt::Windows::Foundation::Collections::IVector<hstring>{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Windows_Management_Deployment_IRegisterPackageOptions<D>::AppDataVolume() const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IRegisterPackageOptions)->get_AppDataVolume(&value));
        return winrt::Microsoft::Windows::Management::Deployment::PackageVolume{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Windows_Management_Deployment_IRegisterPackageOptions<D>::AppDataVolume(winrt::Microsoft::Windows::Management::Deployment::PackageVolume const& value) const
    {
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IRegisterPackageOptions)->put_AppDataVolume(*(void**)(&value)));
    }
    template <typename D> auto consume_Microsoft_Windows_Management_Deployment_IRegisterPackageOptions<D>::DependencyPackageFamilyNames() const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IRegisterPackageOptions)->get_DependencyPackageFamilyNames(&value));
        return winrt::Windows::Foundation::Collections::IVector<hstring>{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Windows_Management_Deployment_IRegisterPackageOptions<D>::DependencyPackageUris() const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IRegisterPackageOptions)->get_DependencyPackageUris(&value));
        return winrt::Windows::Foundation::Collections::IVector<winrt::Windows::Foundation::Uri>{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Windows_Management_Deployment_IRegisterPackageOptions<D>::OptionalPackageFamilyNames() const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IRegisterPackageOptions)->get_OptionalPackageFamilyNames(&value));
        return winrt::Windows::Foundation::Collections::IVector<hstring>{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Windows_Management_Deployment_IRegisterPackageOptions<D>::ExternalLocationUri() const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IRegisterPackageOptions)->get_ExternalLocationUri(&value));
        return winrt::Windows::Foundation::Uri{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Windows_Management_Deployment_IRegisterPackageOptions<D>::ExternalLocationUri(winrt::Windows::Foundation::Uri const& value) const
    {
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IRegisterPackageOptions)->put_ExternalLocationUri(*(void**)(&value)));
    }
    template <typename D> auto consume_Microsoft_Windows_Management_Deployment_IRegisterPackageOptions<D>::AllowUnsigned() const
    {
        bool value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IRegisterPackageOptions)->get_AllowUnsigned(&value));
        return value;
    }
    template <typename D> auto consume_Microsoft_Windows_Management_Deployment_IRegisterPackageOptions<D>::AllowUnsigned(bool value) const
    {
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IRegisterPackageOptions)->put_AllowUnsigned(value));
    }
    template <typename D> auto consume_Microsoft_Windows_Management_Deployment_IRegisterPackageOptions<D>::DeveloperMode() const
    {
        bool value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IRegisterPackageOptions)->get_DeveloperMode(&value));
        return value;
    }
    template <typename D> auto consume_Microsoft_Windows_Management_Deployment_IRegisterPackageOptions<D>::DeveloperMode(bool value) const
    {
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IRegisterPackageOptions)->put_DeveloperMode(value));
    }
    template <typename D> auto consume_Microsoft_Windows_Management_Deployment_IRegisterPackageOptions<D>::ForceAppShutdown() const
    {
        bool value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IRegisterPackageOptions)->get_ForceAppShutdown(&value));
        return value;
    }
    template <typename D> auto consume_Microsoft_Windows_Management_Deployment_IRegisterPackageOptions<D>::ForceAppShutdown(bool value) const
    {
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IRegisterPackageOptions)->put_ForceAppShutdown(value));
    }
    template <typename D> auto consume_Microsoft_Windows_Management_Deployment_IRegisterPackageOptions<D>::ForceTargetAppShutdown() const
    {
        bool value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IRegisterPackageOptions)->get_ForceTargetAppShutdown(&value));
        return value;
    }
    template <typename D> auto consume_Microsoft_Windows_Management_Deployment_IRegisterPackageOptions<D>::ForceTargetAppShutdown(bool value) const
    {
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IRegisterPackageOptions)->put_ForceTargetAppShutdown(value));
    }
    template <typename D> auto consume_Microsoft_Windows_Management_Deployment_IRegisterPackageOptions<D>::ForceUpdateFromAnyVersion() const
    {
        bool value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IRegisterPackageOptions)->get_ForceUpdateFromAnyVersion(&value));
        return value;
    }
    template <typename D> auto consume_Microsoft_Windows_Management_Deployment_IRegisterPackageOptions<D>::ForceUpdateFromAnyVersion(bool value) const
    {
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IRegisterPackageOptions)->put_ForceUpdateFromAnyVersion(value));
    }
    template <typename D> auto consume_Microsoft_Windows_Management_Deployment_IRegisterPackageOptions<D>::InstallAllResources() const
    {
        bool value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IRegisterPackageOptions)->get_InstallAllResources(&value));
        return value;
    }
    template <typename D> auto consume_Microsoft_Windows_Management_Deployment_IRegisterPackageOptions<D>::InstallAllResources(bool value) const
    {
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IRegisterPackageOptions)->put_InstallAllResources(value));
    }
    template <typename D> auto consume_Microsoft_Windows_Management_Deployment_IRegisterPackageOptions<D>::StageInPlace() const
    {
        bool value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IRegisterPackageOptions)->get_StageInPlace(&value));
        return value;
    }
    template <typename D> auto consume_Microsoft_Windows_Management_Deployment_IRegisterPackageOptions<D>::StageInPlace(bool value) const
    {
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IRegisterPackageOptions)->put_StageInPlace(value));
    }
    template <typename D> auto consume_Microsoft_Windows_Management_Deployment_IRegisterPackageOptions<D>::DeferRegistrationWhenPackagesAreInUse() const
    {
        bool value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IRegisterPackageOptions)->get_DeferRegistrationWhenPackagesAreInUse(&value));
        return value;
    }
    template <typename D> auto consume_Microsoft_Windows_Management_Deployment_IRegisterPackageOptions<D>::DeferRegistrationWhenPackagesAreInUse(bool value) const
    {
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IRegisterPackageOptions)->put_DeferRegistrationWhenPackagesAreInUse(value));
    }
    template <typename D> auto consume_Microsoft_Windows_Management_Deployment_IRegisterPackageOptions<D>::IsExpectedDigestsSupported() const
    {
        bool value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IRegisterPackageOptions)->get_IsExpectedDigestsSupported(&value));
        return value;
    }
    template <typename D> auto consume_Microsoft_Windows_Management_Deployment_IRegisterPackageOptions<D>::ExpectedDigests() const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IRegisterPackageOptions)->get_ExpectedDigests(&value));
        return winrt::Windows::Foundation::Collections::IMap<winrt::Windows::Foundation::Uri, hstring>{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Windows_Management_Deployment_IRemovePackageOptions<D>::FailIfNotFound() const
    {
        bool value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IRemovePackageOptions)->get_FailIfNotFound(&value));
        return value;
    }
    template <typename D> auto consume_Microsoft_Windows_Management_Deployment_IRemovePackageOptions<D>::FailIfNotFound(bool value) const
    {
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IRemovePackageOptions)->put_FailIfNotFound(value));
    }
    template <typename D> auto consume_Microsoft_Windows_Management_Deployment_IRemovePackageOptions<D>::PreserveApplicationData() const
    {
        bool value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IRemovePackageOptions)->get_PreserveApplicationData(&value));
        return value;
    }
    template <typename D> auto consume_Microsoft_Windows_Management_Deployment_IRemovePackageOptions<D>::PreserveApplicationData(bool value) const
    {
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IRemovePackageOptions)->put_PreserveApplicationData(value));
    }
    template <typename D> auto consume_Microsoft_Windows_Management_Deployment_IRemovePackageOptions<D>::PreserveRoamableApplicationData() const
    {
        bool value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IRemovePackageOptions)->get_PreserveRoamableApplicationData(&value));
        return value;
    }
    template <typename D> auto consume_Microsoft_Windows_Management_Deployment_IRemovePackageOptions<D>::PreserveRoamableApplicationData(bool value) const
    {
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IRemovePackageOptions)->put_PreserveRoamableApplicationData(value));
    }
    template <typename D> auto consume_Microsoft_Windows_Management_Deployment_IRemovePackageOptions<D>::RemoveForAllUsers() const
    {
        bool value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IRemovePackageOptions)->get_RemoveForAllUsers(&value));
        return value;
    }
    template <typename D> auto consume_Microsoft_Windows_Management_Deployment_IRemovePackageOptions<D>::RemoveForAllUsers(bool value) const
    {
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IRemovePackageOptions)->put_RemoveForAllUsers(value));
    }
    template <typename D> auto consume_Microsoft_Windows_Management_Deployment_IStagePackageOptions<D>::TargetVolume() const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IStagePackageOptions)->get_TargetVolume(&value));
        return winrt::Microsoft::Windows::Management::Deployment::PackageVolume{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Windows_Management_Deployment_IStagePackageOptions<D>::TargetVolume(winrt::Microsoft::Windows::Management::Deployment::PackageVolume const& value) const
    {
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IStagePackageOptions)->put_TargetVolume(*(void**)(&value)));
    }
    template <typename D> auto consume_Microsoft_Windows_Management_Deployment_IStagePackageOptions<D>::DependencyPackageUris() const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IStagePackageOptions)->get_DependencyPackageUris(&value));
        return winrt::Windows::Foundation::Collections::IVector<winrt::Windows::Foundation::Uri>{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Windows_Management_Deployment_IStagePackageOptions<D>::OptionalPackageFamilyNames() const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IStagePackageOptions)->get_OptionalPackageFamilyNames(&value));
        return winrt::Windows::Foundation::Collections::IVector<hstring>{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Windows_Management_Deployment_IStagePackageOptions<D>::OptionalPackageUris() const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IStagePackageOptions)->get_OptionalPackageUris(&value));
        return winrt::Windows::Foundation::Collections::IVector<winrt::Windows::Foundation::Uri>{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Windows_Management_Deployment_IStagePackageOptions<D>::RelatedPackageUris() const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IStagePackageOptions)->get_RelatedPackageUris(&value));
        return winrt::Windows::Foundation::Collections::IVector<winrt::Windows::Foundation::Uri>{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Windows_Management_Deployment_IStagePackageOptions<D>::ExternalLocationUri() const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IStagePackageOptions)->get_ExternalLocationUri(&value));
        return winrt::Windows::Foundation::Uri{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Windows_Management_Deployment_IStagePackageOptions<D>::ExternalLocationUri(winrt::Windows::Foundation::Uri const& value) const
    {
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IStagePackageOptions)->put_ExternalLocationUri(*(void**)(&value)));
    }
    template <typename D> auto consume_Microsoft_Windows_Management_Deployment_IStagePackageOptions<D>::StubPackageOption() const
    {
        winrt::Microsoft::Windows::Management::Deployment::StubPackageOption value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IStagePackageOptions)->get_StubPackageOption(reinterpret_cast<int32_t*>(&value)));
        return value;
    }
    template <typename D> auto consume_Microsoft_Windows_Management_Deployment_IStagePackageOptions<D>::StubPackageOption(winrt::Microsoft::Windows::Management::Deployment::StubPackageOption const& value) const
    {
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IStagePackageOptions)->put_StubPackageOption(static_cast<int32_t>(value)));
    }
    template <typename D> auto consume_Microsoft_Windows_Management_Deployment_IStagePackageOptions<D>::DeveloperMode() const
    {
        bool value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IStagePackageOptions)->get_DeveloperMode(&value));
        return value;
    }
    template <typename D> auto consume_Microsoft_Windows_Management_Deployment_IStagePackageOptions<D>::DeveloperMode(bool value) const
    {
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IStagePackageOptions)->put_DeveloperMode(value));
    }
    template <typename D> auto consume_Microsoft_Windows_Management_Deployment_IStagePackageOptions<D>::ForceUpdateFromAnyVersion() const
    {
        bool value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IStagePackageOptions)->get_ForceUpdateFromAnyVersion(&value));
        return value;
    }
    template <typename D> auto consume_Microsoft_Windows_Management_Deployment_IStagePackageOptions<D>::ForceUpdateFromAnyVersion(bool value) const
    {
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IStagePackageOptions)->put_ForceUpdateFromAnyVersion(value));
    }
    template <typename D> auto consume_Microsoft_Windows_Management_Deployment_IStagePackageOptions<D>::InstallAllResources() const
    {
        bool value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IStagePackageOptions)->get_InstallAllResources(&value));
        return value;
    }
    template <typename D> auto consume_Microsoft_Windows_Management_Deployment_IStagePackageOptions<D>::InstallAllResources(bool value) const
    {
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IStagePackageOptions)->put_InstallAllResources(value));
    }
    template <typename D> auto consume_Microsoft_Windows_Management_Deployment_IStagePackageOptions<D>::RequiredContentGroupOnly() const
    {
        bool value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IStagePackageOptions)->get_RequiredContentGroupOnly(&value));
        return value;
    }
    template <typename D> auto consume_Microsoft_Windows_Management_Deployment_IStagePackageOptions<D>::RequiredContentGroupOnly(bool value) const
    {
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IStagePackageOptions)->put_RequiredContentGroupOnly(value));
    }
    template <typename D> auto consume_Microsoft_Windows_Management_Deployment_IStagePackageOptions<D>::StageInPlace() const
    {
        bool value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IStagePackageOptions)->get_StageInPlace(&value));
        return value;
    }
    template <typename D> auto consume_Microsoft_Windows_Management_Deployment_IStagePackageOptions<D>::StageInPlace(bool value) const
    {
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IStagePackageOptions)->put_StageInPlace(value));
    }
    template <typename D> auto consume_Microsoft_Windows_Management_Deployment_IStagePackageOptions<D>::AllowUnsigned() const
    {
        bool value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IStagePackageOptions)->get_AllowUnsigned(&value));
        return value;
    }
    template <typename D> auto consume_Microsoft_Windows_Management_Deployment_IStagePackageOptions<D>::AllowUnsigned(bool value) const
    {
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IStagePackageOptions)->put_AllowUnsigned(value));
    }
    template <typename D> auto consume_Microsoft_Windows_Management_Deployment_IStagePackageOptions<D>::IsExpectedDigestsSupported() const
    {
        bool value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IStagePackageOptions)->get_IsExpectedDigestsSupported(&value));
        return value;
    }
    template <typename D> auto consume_Microsoft_Windows_Management_Deployment_IStagePackageOptions<D>::ExpectedDigests() const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::Management::Deployment::IStagePackageOptions)->get_ExpectedDigests(&value));
        return winrt::Windows::Foundation::Collections::IMap<winrt::Windows::Foundation::Uri, hstring>{ value, take_ownership_from_abi };
    }
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::Windows::Management::Deployment::IAddPackageOptions> : produce_base<D, winrt::Microsoft::Windows::Management::Deployment::IAddPackageOptions>
    {
        int32_t __stdcall get_TargetVolume(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::Windows::Management::Deployment::PackageVolume>(this->shim().TargetVolume());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_TargetVolume(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().TargetVolume(*reinterpret_cast<winrt::Microsoft::Windows::Management::Deployment::PackageVolume const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_DependencyPackageUris(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::Collections::IVector<winrt::Windows::Foundation::Uri>>(this->shim().DependencyPackageUris());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_OptionalPackageFamilyNames(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::Collections::IVector<hstring>>(this->shim().OptionalPackageFamilyNames());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_OptionalPackageUris(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::Collections::IVector<winrt::Windows::Foundation::Uri>>(this->shim().OptionalPackageUris());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_RelatedPackageUris(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::Collections::IVector<winrt::Windows::Foundation::Uri>>(this->shim().RelatedPackageUris());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_ExternalLocationUri(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::Uri>(this->shim().ExternalLocationUri());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_ExternalLocationUri(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().ExternalLocationUri(*reinterpret_cast<winrt::Windows::Foundation::Uri const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_StubPackageOption(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::Windows::Management::Deployment::StubPackageOption>(this->shim().StubPackageOption());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_StubPackageOption(int32_t value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().StubPackageOption(*reinterpret_cast<winrt::Microsoft::Windows::Management::Deployment::StubPackageOption const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_AllowUnsigned(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().AllowUnsigned());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_AllowUnsigned(bool value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().AllowUnsigned(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_DeveloperMode(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().DeveloperMode());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_DeveloperMode(bool value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().DeveloperMode(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_ForceAppShutdown(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().ForceAppShutdown());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_ForceAppShutdown(bool value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().ForceAppShutdown(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_ForceTargetAppShutdown(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().ForceTargetAppShutdown());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_ForceTargetAppShutdown(bool value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().ForceTargetAppShutdown(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_ForceUpdateFromAnyVersion(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().ForceUpdateFromAnyVersion());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_ForceUpdateFromAnyVersion(bool value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().ForceUpdateFromAnyVersion(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_InstallAllResources(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().InstallAllResources());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_InstallAllResources(bool value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().InstallAllResources(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_RequiredContentGroupOnly(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().RequiredContentGroupOnly());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_RequiredContentGroupOnly(bool value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().RequiredContentGroupOnly(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_RetainFilesOnFailure(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().RetainFilesOnFailure());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_RetainFilesOnFailure(bool value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().RetainFilesOnFailure(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_StageInPlace(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().StageInPlace());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_StageInPlace(bool value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().StageInPlace(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_DeferRegistrationWhenPackagesAreInUse(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().DeferRegistrationWhenPackagesAreInUse());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_DeferRegistrationWhenPackagesAreInUse(bool value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().DeferRegistrationWhenPackagesAreInUse(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_IsExpectedDigestsSupported(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().IsExpectedDigestsSupported());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_ExpectedDigests(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::Collections::IMap<winrt::Windows::Foundation::Uri, hstring>>(this->shim().ExpectedDigests());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_IsLimitToExistingPackagesSupported(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().IsLimitToExistingPackagesSupported());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_LimitToExistingPackages(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().LimitToExistingPackages());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_LimitToExistingPackages(bool value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().LimitToExistingPackages(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::Windows::Management::Deployment::IEnsureReadyOptions> : produce_base<D, winrt::Microsoft::Windows::Management::Deployment::IEnsureReadyOptions>
    {
        int32_t __stdcall get_AddPackageOptions(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::Windows::Management::Deployment::AddPackageOptions>(this->shim().AddPackageOptions());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::Windows::Management::Deployment::IPackageDeploymentManager> : produce_base<D, winrt::Microsoft::Windows::Management::Deployment::IPackageDeploymentManager>
    {
        int32_t __stdcall IsPackageReady(void* package, bool* result) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *result = detach_from<bool>(this->shim().IsPackageReady(*reinterpret_cast<hstring const*>(&package)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall IsPackageReadyByUri(void* packageUri, bool* result) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *result = detach_from<bool>(this->shim().IsPackageReadyByUri(*reinterpret_cast<winrt::Windows::Foundation::Uri const*>(&packageUri)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall IsPackageSetReady(void* packageSet, bool* result) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *result = detach_from<bool>(this->shim().IsPackageSetReady(*reinterpret_cast<winrt::Microsoft::Windows::Management::Deployment::PackageSet const*>(&packageSet)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall EnsurePackageReadyAsync(void* package, void* options, void** operation) noexcept final try
        {
            clear_abi(operation);
            typename D::abi_guard guard(this->shim());
            *operation = detach_from<winrt::Windows::Foundation::IAsyncOperationWithProgress<winrt::Microsoft::Windows::Management::Deployment::PackageDeploymentResult, winrt::Microsoft::Windows::Management::Deployment::PackageDeploymentProgress>>(this->shim().EnsurePackageReadyAsync(*reinterpret_cast<hstring const*>(&package), *reinterpret_cast<winrt::Microsoft::Windows::Management::Deployment::EnsureReadyOptions const*>(&options)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall EnsurePackageReadyByUriAsync(void* packageUri, void* options, void** operation) noexcept final try
        {
            clear_abi(operation);
            typename D::abi_guard guard(this->shim());
            *operation = detach_from<winrt::Windows::Foundation::IAsyncOperationWithProgress<winrt::Microsoft::Windows::Management::Deployment::PackageDeploymentResult, winrt::Microsoft::Windows::Management::Deployment::PackageDeploymentProgress>>(this->shim().EnsurePackageReadyByUriAsync(*reinterpret_cast<winrt::Windows::Foundation::Uri const*>(&packageUri), *reinterpret_cast<winrt::Microsoft::Windows::Management::Deployment::EnsureReadyOptions const*>(&options)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall EnsurePackageSetReadyAsync(void* packageSet, void* options, void** operation) noexcept final try
        {
            clear_abi(operation);
            typename D::abi_guard guard(this->shim());
            *operation = detach_from<winrt::Windows::Foundation::IAsyncOperationWithProgress<winrt::Microsoft::Windows::Management::Deployment::PackageDeploymentResult, winrt::Microsoft::Windows::Management::Deployment::PackageDeploymentProgress>>(this->shim().EnsurePackageSetReadyAsync(*reinterpret_cast<winrt::Microsoft::Windows::Management::Deployment::PackageSet const*>(&packageSet), *reinterpret_cast<winrt::Microsoft::Windows::Management::Deployment::EnsureReadyOptions const*>(&options)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall AddPackageAsync(void* package, void* options, void** operation) noexcept final try
        {
            clear_abi(operation);
            typename D::abi_guard guard(this->shim());
            *operation = detach_from<winrt::Windows::Foundation::IAsyncOperationWithProgress<winrt::Microsoft::Windows::Management::Deployment::PackageDeploymentResult, winrt::Microsoft::Windows::Management::Deployment::PackageDeploymentProgress>>(this->shim().AddPackageAsync(*reinterpret_cast<hstring const*>(&package), *reinterpret_cast<winrt::Microsoft::Windows::Management::Deployment::AddPackageOptions const*>(&options)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall AddPackageByUriAsync(void* packageUri, void* options, void** operation) noexcept final try
        {
            clear_abi(operation);
            typename D::abi_guard guard(this->shim());
            *operation = detach_from<winrt::Windows::Foundation::IAsyncOperationWithProgress<winrt::Microsoft::Windows::Management::Deployment::PackageDeploymentResult, winrt::Microsoft::Windows::Management::Deployment::PackageDeploymentProgress>>(this->shim().AddPackageByUriAsync(*reinterpret_cast<winrt::Windows::Foundation::Uri const*>(&packageUri), *reinterpret_cast<winrt::Microsoft::Windows::Management::Deployment::AddPackageOptions const*>(&options)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall AddPackageSetAsync(void* packageSet, void* options, void** operation) noexcept final try
        {
            clear_abi(operation);
            typename D::abi_guard guard(this->shim());
            *operation = detach_from<winrt::Windows::Foundation::IAsyncOperationWithProgress<winrt::Microsoft::Windows::Management::Deployment::PackageDeploymentResult, winrt::Microsoft::Windows::Management::Deployment::PackageDeploymentProgress>>(this->shim().AddPackageSetAsync(*reinterpret_cast<winrt::Microsoft::Windows::Management::Deployment::PackageSet const*>(&packageSet), *reinterpret_cast<winrt::Microsoft::Windows::Management::Deployment::AddPackageOptions const*>(&options)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall StagePackageAsync(void* package, void* options, void** operation) noexcept final try
        {
            clear_abi(operation);
            typename D::abi_guard guard(this->shim());
            *operation = detach_from<winrt::Windows::Foundation::IAsyncOperationWithProgress<winrt::Microsoft::Windows::Management::Deployment::PackageDeploymentResult, winrt::Microsoft::Windows::Management::Deployment::PackageDeploymentProgress>>(this->shim().StagePackageAsync(*reinterpret_cast<hstring const*>(&package), *reinterpret_cast<winrt::Microsoft::Windows::Management::Deployment::StagePackageOptions const*>(&options)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall StagePackageByUriAsync(void* packageUri, void* options, void** operation) noexcept final try
        {
            clear_abi(operation);
            typename D::abi_guard guard(this->shim());
            *operation = detach_from<winrt::Windows::Foundation::IAsyncOperationWithProgress<winrt::Microsoft::Windows::Management::Deployment::PackageDeploymentResult, winrt::Microsoft::Windows::Management::Deployment::PackageDeploymentProgress>>(this->shim().StagePackageByUriAsync(*reinterpret_cast<winrt::Windows::Foundation::Uri const*>(&packageUri), *reinterpret_cast<winrt::Microsoft::Windows::Management::Deployment::StagePackageOptions const*>(&options)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall StagePackageSetAsync(void* packageSet, void* options, void** operation) noexcept final try
        {
            clear_abi(operation);
            typename D::abi_guard guard(this->shim());
            *operation = detach_from<winrt::Windows::Foundation::IAsyncOperationWithProgress<winrt::Microsoft::Windows::Management::Deployment::PackageDeploymentResult, winrt::Microsoft::Windows::Management::Deployment::PackageDeploymentProgress>>(this->shim().StagePackageSetAsync(*reinterpret_cast<winrt::Microsoft::Windows::Management::Deployment::PackageSet const*>(&packageSet), *reinterpret_cast<winrt::Microsoft::Windows::Management::Deployment::StagePackageOptions const*>(&options)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall RegisterPackageAsync(void* package, void* options, void** operation) noexcept final try
        {
            clear_abi(operation);
            typename D::abi_guard guard(this->shim());
            *operation = detach_from<winrt::Windows::Foundation::IAsyncOperationWithProgress<winrt::Microsoft::Windows::Management::Deployment::PackageDeploymentResult, winrt::Microsoft::Windows::Management::Deployment::PackageDeploymentProgress>>(this->shim().RegisterPackageAsync(*reinterpret_cast<hstring const*>(&package), *reinterpret_cast<winrt::Microsoft::Windows::Management::Deployment::RegisterPackageOptions const*>(&options)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall RegisterPackageByUriAsync(void* packageUri, void* options, void** operation) noexcept final try
        {
            clear_abi(operation);
            typename D::abi_guard guard(this->shim());
            *operation = detach_from<winrt::Windows::Foundation::IAsyncOperationWithProgress<winrt::Microsoft::Windows::Management::Deployment::PackageDeploymentResult, winrt::Microsoft::Windows::Management::Deployment::PackageDeploymentProgress>>(this->shim().RegisterPackageByUriAsync(*reinterpret_cast<winrt::Windows::Foundation::Uri const*>(&packageUri), *reinterpret_cast<winrt::Microsoft::Windows::Management::Deployment::RegisterPackageOptions const*>(&options)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall RegisterPackageSetAsync(void* packageSet, void* options, void** operation) noexcept final try
        {
            clear_abi(operation);
            typename D::abi_guard guard(this->shim());
            *operation = detach_from<winrt::Windows::Foundation::IAsyncOperationWithProgress<winrt::Microsoft::Windows::Management::Deployment::PackageDeploymentResult, winrt::Microsoft::Windows::Management::Deployment::PackageDeploymentProgress>>(this->shim().RegisterPackageSetAsync(*reinterpret_cast<winrt::Microsoft::Windows::Management::Deployment::PackageSet const*>(&packageSet), *reinterpret_cast<winrt::Microsoft::Windows::Management::Deployment::RegisterPackageOptions const*>(&options)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall RemovePackageAsync(void* package, void* options, void** operation) noexcept final try
        {
            clear_abi(operation);
            typename D::abi_guard guard(this->shim());
            *operation = detach_from<winrt::Windows::Foundation::IAsyncOperationWithProgress<winrt::Microsoft::Windows::Management::Deployment::PackageDeploymentResult, winrt::Microsoft::Windows::Management::Deployment::PackageDeploymentProgress>>(this->shim().RemovePackageAsync(*reinterpret_cast<hstring const*>(&package), *reinterpret_cast<winrt::Microsoft::Windows::Management::Deployment::RemovePackageOptions const*>(&options)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall RemovePackageByFullNameAsync(void* packageFullName, void* options, void** operation) noexcept final try
        {
            clear_abi(operation);
            typename D::abi_guard guard(this->shim());
            *operation = detach_from<winrt::Windows::Foundation::IAsyncOperationWithProgress<winrt::Microsoft::Windows::Management::Deployment::PackageDeploymentResult, winrt::Microsoft::Windows::Management::Deployment::PackageDeploymentProgress>>(this->shim().RemovePackageByFullNameAsync(*reinterpret_cast<hstring const*>(&packageFullName), *reinterpret_cast<winrt::Microsoft::Windows::Management::Deployment::RemovePackageOptions const*>(&options)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall RemovePackageByFamilyNameAsync(void* packageFamilyName, void* options, void** operation) noexcept final try
        {
            clear_abi(operation);
            typename D::abi_guard guard(this->shim());
            *operation = detach_from<winrt::Windows::Foundation::IAsyncOperationWithProgress<winrt::Microsoft::Windows::Management::Deployment::PackageDeploymentResult, winrt::Microsoft::Windows::Management::Deployment::PackageDeploymentProgress>>(this->shim().RemovePackageByFamilyNameAsync(*reinterpret_cast<hstring const*>(&packageFamilyName), *reinterpret_cast<winrt::Microsoft::Windows::Management::Deployment::RemovePackageOptions const*>(&options)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall RemovePackageByUriAsync(void* packageUri, void* options, void** operation) noexcept final try
        {
            clear_abi(operation);
            typename D::abi_guard guard(this->shim());
            *operation = detach_from<winrt::Windows::Foundation::IAsyncOperationWithProgress<winrt::Microsoft::Windows::Management::Deployment::PackageDeploymentResult, winrt::Microsoft::Windows::Management::Deployment::PackageDeploymentProgress>>(this->shim().RemovePackageByUriAsync(*reinterpret_cast<winrt::Windows::Foundation::Uri const*>(&packageUri), *reinterpret_cast<winrt::Microsoft::Windows::Management::Deployment::RemovePackageOptions const*>(&options)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall RemovePackageSetAsync(void* packageSet, void* options, void** operation) noexcept final try
        {
            clear_abi(operation);
            typename D::abi_guard guard(this->shim());
            *operation = detach_from<winrt::Windows::Foundation::IAsyncOperationWithProgress<winrt::Microsoft::Windows::Management::Deployment::PackageDeploymentResult, winrt::Microsoft::Windows::Management::Deployment::PackageDeploymentProgress>>(this->shim().RemovePackageSetAsync(*reinterpret_cast<winrt::Microsoft::Windows::Management::Deployment::PackageSet const*>(&packageSet), *reinterpret_cast<winrt::Microsoft::Windows::Management::Deployment::RemovePackageOptions const*>(&options)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall ResetPackageAsync(void* package, void** operation) noexcept final try
        {
            clear_abi(operation);
            typename D::abi_guard guard(this->shim());
            *operation = detach_from<winrt::Windows::Foundation::IAsyncOperationWithProgress<winrt::Microsoft::Windows::Management::Deployment::PackageDeploymentResult, winrt::Microsoft::Windows::Management::Deployment::PackageDeploymentProgress>>(this->shim().ResetPackageAsync(*reinterpret_cast<hstring const*>(&package)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall ResetPackageByUriAsync(void* packageUri, void** operation) noexcept final try
        {
            clear_abi(operation);
            typename D::abi_guard guard(this->shim());
            *operation = detach_from<winrt::Windows::Foundation::IAsyncOperationWithProgress<winrt::Microsoft::Windows::Management::Deployment::PackageDeploymentResult, winrt::Microsoft::Windows::Management::Deployment::PackageDeploymentProgress>>(this->shim().ResetPackageByUriAsync(*reinterpret_cast<winrt::Windows::Foundation::Uri const*>(&packageUri)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall ResetPackageSetAsync(void* packageSet, void** operation) noexcept final try
        {
            clear_abi(operation);
            typename D::abi_guard guard(this->shim());
            *operation = detach_from<winrt::Windows::Foundation::IAsyncOperationWithProgress<winrt::Microsoft::Windows::Management::Deployment::PackageDeploymentResult, winrt::Microsoft::Windows::Management::Deployment::PackageDeploymentProgress>>(this->shim().ResetPackageSetAsync(*reinterpret_cast<winrt::Microsoft::Windows::Management::Deployment::PackageSet const*>(&packageSet)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall RepairPackageAsync(void* package, void** operation) noexcept final try
        {
            clear_abi(operation);
            typename D::abi_guard guard(this->shim());
            *operation = detach_from<winrt::Windows::Foundation::IAsyncOperationWithProgress<winrt::Microsoft::Windows::Management::Deployment::PackageDeploymentResult, winrt::Microsoft::Windows::Management::Deployment::PackageDeploymentProgress>>(this->shim().RepairPackageAsync(*reinterpret_cast<hstring const*>(&package)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall RepairPackageByUriAsync(void* packageUri, void** operation) noexcept final try
        {
            clear_abi(operation);
            typename D::abi_guard guard(this->shim());
            *operation = detach_from<winrt::Windows::Foundation::IAsyncOperationWithProgress<winrt::Microsoft::Windows::Management::Deployment::PackageDeploymentResult, winrt::Microsoft::Windows::Management::Deployment::PackageDeploymentProgress>>(this->shim().RepairPackageByUriAsync(*reinterpret_cast<winrt::Windows::Foundation::Uri const*>(&packageUri)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall RepairPackageSetAsync(void* packageSet, void** operation) noexcept final try
        {
            clear_abi(operation);
            typename D::abi_guard guard(this->shim());
            *operation = detach_from<winrt::Windows::Foundation::IAsyncOperationWithProgress<winrt::Microsoft::Windows::Management::Deployment::PackageDeploymentResult, winrt::Microsoft::Windows::Management::Deployment::PackageDeploymentProgress>>(this->shim().RepairPackageSetAsync(*reinterpret_cast<winrt::Microsoft::Windows::Management::Deployment::PackageSet const*>(&packageSet)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall ProvisionPackageAsync(void* package, void* options, void** operation) noexcept final try
        {
            clear_abi(operation);
            typename D::abi_guard guard(this->shim());
            *operation = detach_from<winrt::Windows::Foundation::IAsyncOperationWithProgress<winrt::Microsoft::Windows::Management::Deployment::PackageDeploymentResult, winrt::Microsoft::Windows::Management::Deployment::PackageDeploymentProgress>>(this->shim().ProvisionPackageAsync(*reinterpret_cast<hstring const*>(&package), *reinterpret_cast<winrt::Microsoft::Windows::Management::Deployment::ProvisionPackageOptions const*>(&options)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall ProvisionPackageByUriAsync(void* packageUri, void* options, void** operation) noexcept final try
        {
            clear_abi(operation);
            typename D::abi_guard guard(this->shim());
            *operation = detach_from<winrt::Windows::Foundation::IAsyncOperationWithProgress<winrt::Microsoft::Windows::Management::Deployment::PackageDeploymentResult, winrt::Microsoft::Windows::Management::Deployment::PackageDeploymentProgress>>(this->shim().ProvisionPackageByUriAsync(*reinterpret_cast<winrt::Windows::Foundation::Uri const*>(&packageUri), *reinterpret_cast<winrt::Microsoft::Windows::Management::Deployment::ProvisionPackageOptions const*>(&options)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall ProvisionPackageSetAsync(void* packageSet, void* options, void** operation) noexcept final try
        {
            clear_abi(operation);
            typename D::abi_guard guard(this->shim());
            *operation = detach_from<winrt::Windows::Foundation::IAsyncOperationWithProgress<winrt::Microsoft::Windows::Management::Deployment::PackageDeploymentResult, winrt::Microsoft::Windows::Management::Deployment::PackageDeploymentProgress>>(this->shim().ProvisionPackageSetAsync(*reinterpret_cast<winrt::Microsoft::Windows::Management::Deployment::PackageSet const*>(&packageSet), *reinterpret_cast<winrt::Microsoft::Windows::Management::Deployment::ProvisionPackageOptions const*>(&options)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall DeprovisionPackageAsync(void* package, void** operation) noexcept final try
        {
            clear_abi(operation);
            typename D::abi_guard guard(this->shim());
            *operation = detach_from<winrt::Windows::Foundation::IAsyncOperationWithProgress<winrt::Microsoft::Windows::Management::Deployment::PackageDeploymentResult, winrt::Microsoft::Windows::Management::Deployment::PackageDeploymentProgress>>(this->shim().DeprovisionPackageAsync(*reinterpret_cast<hstring const*>(&package)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall DeprovisionPackageByUriAsync(void* packageUri, void** operation) noexcept final try
        {
            clear_abi(operation);
            typename D::abi_guard guard(this->shim());
            *operation = detach_from<winrt::Windows::Foundation::IAsyncOperationWithProgress<winrt::Microsoft::Windows::Management::Deployment::PackageDeploymentResult, winrt::Microsoft::Windows::Management::Deployment::PackageDeploymentProgress>>(this->shim().DeprovisionPackageByUriAsync(*reinterpret_cast<winrt::Windows::Foundation::Uri const*>(&packageUri)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall DeprovisionPackageSetAsync(void* packageSet, void** operation) noexcept final try
        {
            clear_abi(operation);
            typename D::abi_guard guard(this->shim());
            *operation = detach_from<winrt::Windows::Foundation::IAsyncOperationWithProgress<winrt::Microsoft::Windows::Management::Deployment::PackageDeploymentResult, winrt::Microsoft::Windows::Management::Deployment::PackageDeploymentProgress>>(this->shim().DeprovisionPackageSetAsync(*reinterpret_cast<winrt::Microsoft::Windows::Management::Deployment::PackageSet const*>(&packageSet)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall IsPackageRegistrationPending(void* packageFamilyName, bool* result) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *result = detach_from<bool>(this->shim().IsPackageRegistrationPending(*reinterpret_cast<hstring const*>(&packageFamilyName)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall IsPackageRegistrationPendingForUser(void* userSecurityId, void* packageFamilyName, bool* result) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *result = detach_from<bool>(this->shim().IsPackageRegistrationPendingForUser(*reinterpret_cast<hstring const*>(&userSecurityId), *reinterpret_cast<hstring const*>(&packageFamilyName)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::Windows::Management::Deployment::IPackageDeploymentManagerStatics> : produce_base<D, winrt::Microsoft::Windows::Management::Deployment::IPackageDeploymentManagerStatics>
    {
        int32_t __stdcall GetDefault(void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Microsoft::Windows::Management::Deployment::PackageDeploymentManager>(this->shim().GetDefault());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::Windows::Management::Deployment::IPackageDeploymentResult> : produce_base<D, winrt::Microsoft::Windows::Management::Deployment::IPackageDeploymentResult>
    {
        int32_t __stdcall get_Status(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::Windows::Management::Deployment::PackageDeploymentStatus>(this->shim().Status());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Error(winrt::hresult* value) noexcept final try
        {
            zero_abi<winrt::hresult>(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::hresult>(this->shim().Error());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_ExtendedError(winrt::hresult* value) noexcept final try
        {
            zero_abi<winrt::hresult>(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::hresult>(this->shim().ExtendedError());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_ErrorText(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<hstring>(this->shim().ErrorText());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_ActivityId(winrt::guid* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::guid>(this->shim().ActivityId());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::Windows::Management::Deployment::IPackageRuntimeManager> : produce_base<D, winrt::Microsoft::Windows::Management::Deployment::IPackageRuntimeManager>
    {
        int32_t __stdcall AddPackageSet(void* packageSet, void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Microsoft::Windows::Management::Deployment::PackageSetRuntimeDisposition>(this->shim().AddPackageSet(*reinterpret_cast<winrt::Microsoft::Windows::Management::Deployment::PackageSet const*>(&packageSet)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall AddPackageSetWithOptions(void* packageSet, void* createOptions, void* addOptions, void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Microsoft::Windows::Management::Deployment::PackageSetRuntimeDisposition>(this->shim().AddPackageSet(*reinterpret_cast<winrt::Microsoft::Windows::Management::Deployment::PackageSet const*>(&packageSet), *reinterpret_cast<winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::CreatePackageDependencyOptions const*>(&createOptions), *reinterpret_cast<winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::AddPackageDependencyOptions const*>(&addOptions)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall RemovePackageSet(void* packageSetRuntimeDisposition) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().RemovePackageSet(*reinterpret_cast<winrt::Microsoft::Windows::Management::Deployment::PackageSetRuntimeDisposition const*>(&packageSetRuntimeDisposition));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::Windows::Management::Deployment::IPackageRuntimeManagerStatics> : produce_base<D, winrt::Microsoft::Windows::Management::Deployment::IPackageRuntimeManagerStatics>
    {
        int32_t __stdcall GetDefault(void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Microsoft::Windows::Management::Deployment::PackageRuntimeManager>(this->shim().GetDefault());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::Windows::Management::Deployment::IPackageSet> : produce_base<D, winrt::Microsoft::Windows::Management::Deployment::IPackageSet>
    {
        int32_t __stdcall get_Id(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<hstring>(this->shim().Id());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_Id(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Id(*reinterpret_cast<hstring const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_PackageUri(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::Uri>(this->shim().PackageUri());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_PackageUri(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().PackageUri(*reinterpret_cast<winrt::Windows::Foundation::Uri const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Items(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::Collections::IVector<winrt::Microsoft::Windows::Management::Deployment::PackageSetItem>>(this->shim().Items());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::Windows::Management::Deployment::IPackageSetItem> : produce_base<D, winrt::Microsoft::Windows::Management::Deployment::IPackageSetItem>
    {
        int32_t __stdcall get_Id(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<hstring>(this->shim().Id());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_Id(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Id(*reinterpret_cast<hstring const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_PackageFamilyName(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<hstring>(this->shim().PackageFamilyName());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_PackageFamilyName(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().PackageFamilyName(*reinterpret_cast<hstring const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_MinVersion(struct struct_Windows_ApplicationModel_PackageVersion* value) noexcept final try
        {
            zero_abi<winrt::Windows::ApplicationModel::PackageVersion>(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::ApplicationModel::PackageVersion>(this->shim().MinVersion());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_MinVersion(struct struct_Windows_ApplicationModel_PackageVersion value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().MinVersion(*reinterpret_cast<winrt::Windows::ApplicationModel::PackageVersion const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_ProcessorArchitectureFilter(uint32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::PackageDependencyProcessorArchitectures>(this->shim().ProcessorArchitectureFilter());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_ProcessorArchitectureFilter(uint32_t value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().ProcessorArchitectureFilter(*reinterpret_cast<winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::PackageDependencyProcessorArchitectures const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_PackageUri(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::Uri>(this->shim().PackageUri());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_PackageUri(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().PackageUri(*reinterpret_cast<winrt::Windows::Foundation::Uri const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::Windows::Management::Deployment::IPackageSetItemRuntimeDisposition> : produce_base<D, winrt::Microsoft::Windows::Management::Deployment::IPackageSetItemRuntimeDisposition>
    {
        int32_t __stdcall get_PackageSetItemId(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<hstring>(this->shim().PackageSetItemId());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_PackageFullName(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<hstring>(this->shim().PackageFullName());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_PackageDependencyId(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<hstring>(this->shim().PackageDependencyId());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_PackageDependencyContextId(struct struct_Microsoft_Windows_ApplicationModel_DynamicDependency_PackageDependencyContextId* value) noexcept final try
        {
            zero_abi<winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::PackageDependencyContextId>(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::PackageDependencyContextId>(this->shim().PackageDependencyContextId());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::Windows::Management::Deployment::IPackageSetRuntimeDisposition> : produce_base<D, winrt::Microsoft::Windows::Management::Deployment::IPackageSetRuntimeDisposition>
    {
        int32_t __stdcall get_PackageSetId(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<hstring>(this->shim().PackageSetId());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_PackageSetId(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().PackageSetId(*reinterpret_cast<hstring const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_PackageSetItemRuntimeDispositions(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::Collections::IVector<winrt::Microsoft::Windows::Management::Deployment::PackageSetItemRuntimeDisposition>>(this->shim().PackageSetItemRuntimeDispositions());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::Windows::Management::Deployment::IPackageVolume> : produce_base<D, winrt::Microsoft::Windows::Management::Deployment::IPackageVolume>
    {
        int32_t __stdcall get_IsSystemVolume(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().IsSystemVolume());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_MountPoint(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<hstring>(this->shim().MountPoint());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Name(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<hstring>(this->shim().Name());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_PackageStorePath(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<hstring>(this->shim().PackageStorePath());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_SupportsHardLinks(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().SupportsHardLinks());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_IsFullTrustPackageSupported(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().IsFullTrustPackageSupported());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_IsAppxInstallSupported(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().IsAppxInstallSupported());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall IsRepairNeeded(bool* result) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *result = detach_from<bool>(this->shim().IsRepairNeeded());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall Repair() noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Repair();
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::Windows::Management::Deployment::IPackageVolumeStatics> : produce_base<D, winrt::Microsoft::Windows::Management::Deployment::IPackageVolumeStatics>
    {
        int32_t __stdcall FindPackageVolumes(void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Windows::Foundation::Collections::IVector<winrt::Microsoft::Windows::Management::Deployment::PackageVolume>>(this->shim().FindPackageVolumes());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall FindPackageVolumeByPath(void* packageStorePath, void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Microsoft::Windows::Management::Deployment::PackageVolume>(this->shim().FindPackageVolumeByPath(*reinterpret_cast<hstring const*>(&packageStorePath)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall FindPackageVolumeByName(void* name, void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Microsoft::Windows::Management::Deployment::PackageVolume>(this->shim().FindPackageVolumeByName(*reinterpret_cast<hstring const*>(&name)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::Windows::Management::Deployment::IProvisionPackageOptions> : produce_base<D, winrt::Microsoft::Windows::Management::Deployment::IProvisionPackageOptions>
    {
        int32_t __stdcall get_IsOptionalPackageFamilyNamesSupported(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().IsOptionalPackageFamilyNamesSupported());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_OptionalPackageFamilyNames(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::Collections::IVector<hstring>>(this->shim().OptionalPackageFamilyNames());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_IsProjectionOrderPackageFamilyNamesSupported(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().IsProjectionOrderPackageFamilyNamesSupported());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_ProjectionOrderPackageFamilyNames(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::Collections::IVector<hstring>>(this->shim().ProjectionOrderPackageFamilyNames());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::Windows::Management::Deployment::IRegisterPackageOptions> : produce_base<D, winrt::Microsoft::Windows::Management::Deployment::IRegisterPackageOptions>
    {
        int32_t __stdcall get_AppDataVolume(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::Windows::Management::Deployment::PackageVolume>(this->shim().AppDataVolume());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_AppDataVolume(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().AppDataVolume(*reinterpret_cast<winrt::Microsoft::Windows::Management::Deployment::PackageVolume const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_DependencyPackageFamilyNames(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::Collections::IVector<hstring>>(this->shim().DependencyPackageFamilyNames());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_DependencyPackageUris(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::Collections::IVector<winrt::Windows::Foundation::Uri>>(this->shim().DependencyPackageUris());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_OptionalPackageFamilyNames(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::Collections::IVector<hstring>>(this->shim().OptionalPackageFamilyNames());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_ExternalLocationUri(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::Uri>(this->shim().ExternalLocationUri());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_ExternalLocationUri(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().ExternalLocationUri(*reinterpret_cast<winrt::Windows::Foundation::Uri const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_AllowUnsigned(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().AllowUnsigned());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_AllowUnsigned(bool value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().AllowUnsigned(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_DeveloperMode(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().DeveloperMode());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_DeveloperMode(bool value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().DeveloperMode(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_ForceAppShutdown(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().ForceAppShutdown());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_ForceAppShutdown(bool value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().ForceAppShutdown(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_ForceTargetAppShutdown(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().ForceTargetAppShutdown());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_ForceTargetAppShutdown(bool value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().ForceTargetAppShutdown(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_ForceUpdateFromAnyVersion(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().ForceUpdateFromAnyVersion());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_ForceUpdateFromAnyVersion(bool value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().ForceUpdateFromAnyVersion(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_InstallAllResources(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().InstallAllResources());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_InstallAllResources(bool value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().InstallAllResources(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_StageInPlace(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().StageInPlace());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_StageInPlace(bool value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().StageInPlace(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_DeferRegistrationWhenPackagesAreInUse(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().DeferRegistrationWhenPackagesAreInUse());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_DeferRegistrationWhenPackagesAreInUse(bool value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().DeferRegistrationWhenPackagesAreInUse(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_IsExpectedDigestsSupported(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().IsExpectedDigestsSupported());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_ExpectedDigests(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::Collections::IMap<winrt::Windows::Foundation::Uri, hstring>>(this->shim().ExpectedDigests());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::Windows::Management::Deployment::IRemovePackageOptions> : produce_base<D, winrt::Microsoft::Windows::Management::Deployment::IRemovePackageOptions>
    {
        int32_t __stdcall get_FailIfNotFound(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().FailIfNotFound());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_FailIfNotFound(bool value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().FailIfNotFound(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_PreserveApplicationData(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().PreserveApplicationData());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_PreserveApplicationData(bool value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().PreserveApplicationData(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_PreserveRoamableApplicationData(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().PreserveRoamableApplicationData());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_PreserveRoamableApplicationData(bool value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().PreserveRoamableApplicationData(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_RemoveForAllUsers(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().RemoveForAllUsers());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_RemoveForAllUsers(bool value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().RemoveForAllUsers(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::Windows::Management::Deployment::IStagePackageOptions> : produce_base<D, winrt::Microsoft::Windows::Management::Deployment::IStagePackageOptions>
    {
        int32_t __stdcall get_TargetVolume(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::Windows::Management::Deployment::PackageVolume>(this->shim().TargetVolume());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_TargetVolume(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().TargetVolume(*reinterpret_cast<winrt::Microsoft::Windows::Management::Deployment::PackageVolume const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_DependencyPackageUris(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::Collections::IVector<winrt::Windows::Foundation::Uri>>(this->shim().DependencyPackageUris());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_OptionalPackageFamilyNames(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::Collections::IVector<hstring>>(this->shim().OptionalPackageFamilyNames());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_OptionalPackageUris(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::Collections::IVector<winrt::Windows::Foundation::Uri>>(this->shim().OptionalPackageUris());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_RelatedPackageUris(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::Collections::IVector<winrt::Windows::Foundation::Uri>>(this->shim().RelatedPackageUris());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_ExternalLocationUri(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::Uri>(this->shim().ExternalLocationUri());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_ExternalLocationUri(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().ExternalLocationUri(*reinterpret_cast<winrt::Windows::Foundation::Uri const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_StubPackageOption(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::Windows::Management::Deployment::StubPackageOption>(this->shim().StubPackageOption());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_StubPackageOption(int32_t value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().StubPackageOption(*reinterpret_cast<winrt::Microsoft::Windows::Management::Deployment::StubPackageOption const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_DeveloperMode(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().DeveloperMode());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_DeveloperMode(bool value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().DeveloperMode(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_ForceUpdateFromAnyVersion(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().ForceUpdateFromAnyVersion());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_ForceUpdateFromAnyVersion(bool value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().ForceUpdateFromAnyVersion(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_InstallAllResources(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().InstallAllResources());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_InstallAllResources(bool value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().InstallAllResources(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_RequiredContentGroupOnly(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().RequiredContentGroupOnly());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_RequiredContentGroupOnly(bool value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().RequiredContentGroupOnly(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_StageInPlace(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().StageInPlace());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_StageInPlace(bool value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().StageInPlace(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_AllowUnsigned(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().AllowUnsigned());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_AllowUnsigned(bool value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().AllowUnsigned(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_IsExpectedDigestsSupported(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().IsExpectedDigestsSupported());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_ExpectedDigests(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::Collections::IMap<winrt::Windows::Foundation::Uri, hstring>>(this->shim().ExpectedDigests());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
}
WINRT_EXPORT namespace winrt::Microsoft::Windows::Management::Deployment
{
    inline AddPackageOptions::AddPackageOptions() :
        AddPackageOptions(impl::call_factory_cast<AddPackageOptions(*)(winrt::Windows::Foundation::IActivationFactory const&), AddPackageOptions>([](winrt::Windows::Foundation::IActivationFactory const& f) { return f.template ActivateInstance<AddPackageOptions>(); }))
    {
    }
    inline EnsureReadyOptions::EnsureReadyOptions() :
        EnsureReadyOptions(impl::call_factory_cast<EnsureReadyOptions(*)(winrt::Windows::Foundation::IActivationFactory const&), EnsureReadyOptions>([](winrt::Windows::Foundation::IActivationFactory const& f) { return f.template ActivateInstance<EnsureReadyOptions>(); }))
    {
    }
    inline auto PackageDeploymentManager::GetDefault()
    {
        return impl::call_factory_cast<winrt::Microsoft::Windows::Management::Deployment::PackageDeploymentManager(*)(IPackageDeploymentManagerStatics const&), PackageDeploymentManager, IPackageDeploymentManagerStatics>([](IPackageDeploymentManagerStatics const& f) { return f.GetDefault(); });
    }
    inline auto PackageRuntimeManager::GetDefault()
    {
        return impl::call_factory_cast<winrt::Microsoft::Windows::Management::Deployment::PackageRuntimeManager(*)(IPackageRuntimeManagerStatics const&), PackageRuntimeManager, IPackageRuntimeManagerStatics>([](IPackageRuntimeManagerStatics const& f) { return f.GetDefault(); });
    }
    inline PackageSet::PackageSet() :
        PackageSet(impl::call_factory_cast<PackageSet(*)(winrt::Windows::Foundation::IActivationFactory const&), PackageSet>([](winrt::Windows::Foundation::IActivationFactory const& f) { return f.template ActivateInstance<PackageSet>(); }))
    {
    }
    inline PackageSetItem::PackageSetItem() :
        PackageSetItem(impl::call_factory_cast<PackageSetItem(*)(winrt::Windows::Foundation::IActivationFactory const&), PackageSetItem>([](winrt::Windows::Foundation::IActivationFactory const& f) { return f.template ActivateInstance<PackageSetItem>(); }))
    {
    }
    inline PackageSetItemRuntimeDisposition::PackageSetItemRuntimeDisposition() :
        PackageSetItemRuntimeDisposition(impl::call_factory_cast<PackageSetItemRuntimeDisposition(*)(winrt::Windows::Foundation::IActivationFactory const&), PackageSetItemRuntimeDisposition>([](winrt::Windows::Foundation::IActivationFactory const& f) { return f.template ActivateInstance<PackageSetItemRuntimeDisposition>(); }))
    {
    }
    inline PackageSetRuntimeDisposition::PackageSetRuntimeDisposition() :
        PackageSetRuntimeDisposition(impl::call_factory_cast<PackageSetRuntimeDisposition(*)(winrt::Windows::Foundation::IActivationFactory const&), PackageSetRuntimeDisposition>([](winrt::Windows::Foundation::IActivationFactory const& f) { return f.template ActivateInstance<PackageSetRuntimeDisposition>(); }))
    {
    }
    inline auto PackageVolume::FindPackageVolumes()
    {
        return impl::call_factory_cast<winrt::Windows::Foundation::Collections::IVector<winrt::Microsoft::Windows::Management::Deployment::PackageVolume>(*)(IPackageVolumeStatics const&), PackageVolume, IPackageVolumeStatics>([](IPackageVolumeStatics const& f) { return f.FindPackageVolumes(); });
    }
    inline auto PackageVolume::FindPackageVolumeByPath(param::hstring const& packageStorePath)
    {
        return impl::call_factory<PackageVolume, IPackageVolumeStatics>([&](IPackageVolumeStatics const& f) { return f.FindPackageVolumeByPath(packageStorePath); });
    }
    inline auto PackageVolume::FindPackageVolumeByName(param::hstring const& name)
    {
        return impl::call_factory<PackageVolume, IPackageVolumeStatics>([&](IPackageVolumeStatics const& f) { return f.FindPackageVolumeByName(name); });
    }
    inline ProvisionPackageOptions::ProvisionPackageOptions() :
        ProvisionPackageOptions(impl::call_factory_cast<ProvisionPackageOptions(*)(winrt::Windows::Foundation::IActivationFactory const&), ProvisionPackageOptions>([](winrt::Windows::Foundation::IActivationFactory const& f) { return f.template ActivateInstance<ProvisionPackageOptions>(); }))
    {
    }
    inline RegisterPackageOptions::RegisterPackageOptions() :
        RegisterPackageOptions(impl::call_factory_cast<RegisterPackageOptions(*)(winrt::Windows::Foundation::IActivationFactory const&), RegisterPackageOptions>([](winrt::Windows::Foundation::IActivationFactory const& f) { return f.template ActivateInstance<RegisterPackageOptions>(); }))
    {
    }
    inline RemovePackageOptions::RemovePackageOptions() :
        RemovePackageOptions(impl::call_factory_cast<RemovePackageOptions(*)(winrt::Windows::Foundation::IActivationFactory const&), RemovePackageOptions>([](winrt::Windows::Foundation::IActivationFactory const& f) { return f.template ActivateInstance<RemovePackageOptions>(); }))
    {
    }
    inline StagePackageOptions::StagePackageOptions() :
        StagePackageOptions(impl::call_factory_cast<StagePackageOptions(*)(winrt::Windows::Foundation::IActivationFactory const&), StagePackageOptions>([](winrt::Windows::Foundation::IActivationFactory const& f) { return f.template ActivateInstance<StagePackageOptions>(); }))
    {
    }
}
namespace std
{
#ifndef WINRT_LEAN_AND_MEAN
    template<> struct hash<winrt::Microsoft::Windows::Management::Deployment::IAddPackageOptions> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Windows::Management::Deployment::IEnsureReadyOptions> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Windows::Management::Deployment::IPackageDeploymentManager> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Windows::Management::Deployment::IPackageDeploymentManagerStatics> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Windows::Management::Deployment::IPackageDeploymentResult> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Windows::Management::Deployment::IPackageRuntimeManager> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Windows::Management::Deployment::IPackageRuntimeManagerStatics> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Windows::Management::Deployment::IPackageSet> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Windows::Management::Deployment::IPackageSetItem> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Windows::Management::Deployment::IPackageSetItemRuntimeDisposition> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Windows::Management::Deployment::IPackageSetRuntimeDisposition> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Windows::Management::Deployment::IPackageVolume> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Windows::Management::Deployment::IPackageVolumeStatics> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Windows::Management::Deployment::IProvisionPackageOptions> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Windows::Management::Deployment::IRegisterPackageOptions> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Windows::Management::Deployment::IRemovePackageOptions> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Windows::Management::Deployment::IStagePackageOptions> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Windows::Management::Deployment::AddPackageOptions> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Windows::Management::Deployment::EnsureReadyOptions> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Windows::Management::Deployment::PackageDeploymentManager> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Windows::Management::Deployment::PackageDeploymentResult> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Windows::Management::Deployment::PackageRuntimeManager> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Windows::Management::Deployment::PackageSet> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Windows::Management::Deployment::PackageSetItem> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Windows::Management::Deployment::PackageSetItemRuntimeDisposition> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Windows::Management::Deployment::PackageSetRuntimeDisposition> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Windows::Management::Deployment::PackageVolume> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Windows::Management::Deployment::ProvisionPackageOptions> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Windows::Management::Deployment::RegisterPackageOptions> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Windows::Management::Deployment::RemovePackageOptions> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Windows::Management::Deployment::StagePackageOptions> : winrt::impl::hash_base {};
#endif
#ifdef __cpp_lib_format
#endif
}
#endif
