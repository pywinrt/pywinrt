// WARNING: Please don't edit this file. It was generated by C++/WinRT v2.0.250303.1

#pragma once
#ifndef WINRT_Microsoft_UI_Input_DragDrop_H
#define WINRT_Microsoft_UI_Input_DragDrop_H
#include "winrt/base.h"
static_assert(winrt::check_version(CPPWINRT_VERSION, "2.0.250303.1"), "Mismatched C++/WinRT headers.");
#define CPPWINRT_VERSION "2.0.250303.1"
#include "winrt/Microsoft.UI.Input.h"
#include "winrt/impl/Microsoft.UI.Content.2.h"
#include "winrt/impl/Microsoft.UI.Input.2.h"
#include "winrt/impl/Windows.ApplicationModel.DataTransfer.2.h"
#include "winrt/impl/Windows.Foundation.2.h"
#include "winrt/impl/Windows.Graphics.Imaging.2.h"
#include "winrt/impl/Microsoft.UI.Input.DragDrop.2.h"
namespace winrt::impl
{
    template <typename D> auto consume_Microsoft_UI_Input_DragDrop_IDragDropManager<D>::AreConcurrentOperationsEnabled() const
    {
        bool value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::DragDrop::IDragDropManager>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::DragDrop::IDragDropManager, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::DragDrop::IDragDropManager>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_AreConcurrentOperationsEnabled(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::DragDrop::IDragDropManager>**)this;
            check_hresult(_winrt_abi_type->get_AreConcurrentOperationsEnabled(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Input_DragDrop_IDragDropManager<D>::AreConcurrentOperationsEnabled(bool value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::DragDrop::IDragDropManager>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::DragDrop::IDragDropManager, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::DragDrop::IDragDropManager>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_AreConcurrentOperationsEnabled(value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::DragDrop::IDragDropManager>**)this;
            check_hresult(_winrt_abi_type->put_AreConcurrentOperationsEnabled(value));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Input_DragDrop_IDragDropManager<D>::TargetRequested(winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Input::DragDrop::DragDropManager, winrt::Microsoft::UI::Input::DragDrop::DropOperationTargetRequestedEventArgs> const& handler) const
    {
        winrt::event_token token{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::DragDrop::IDragDropManager>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::DragDrop::IDragDropManager, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::DragDrop::IDragDropManager>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->add_TargetRequested(*(void**)(&handler), put_abi(token)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::DragDrop::IDragDropManager>**)this;
            check_hresult(_winrt_abi_type->add_TargetRequested(*(void**)(&handler), put_abi(token)));
        }
        return token;
    }
    template <typename D> auto consume_Microsoft_UI_Input_DragDrop_IDragDropManager<D>::TargetRequested(auto_revoke_t, winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Input::DragDrop::DragDropManager, winrt::Microsoft::UI::Input::DragDrop::DropOperationTargetRequestedEventArgs> const& handler) const
    {
        return impl::make_event_revoker<D, TargetRequested_revoker>(this, TargetRequested(handler));
    }
    template <typename D> auto consume_Microsoft_UI_Input_DragDrop_IDragDropManager<D>::TargetRequested(winrt::event_token const& token) const noexcept
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::DragDrop::IDragDropManager>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::DragDrop::IDragDropManager, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::DragDrop::IDragDropManager>**)&_winrt_casted_result;
            _winrt_abi_type->remove_TargetRequested(impl::bind_in(token));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::DragDrop::IDragDropManager>**)this;
            _winrt_abi_type->remove_TargetRequested(impl::bind_in(token));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Input_DragDrop_IDragDropManagerStatics<D>::GetForIsland(winrt::Microsoft::UI::Content::ContentIsland const& content) const
    {
        void* result{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::DragDrop::IDragDropManagerStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::DragDrop::IDragDropManagerStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::DragDrop::IDragDropManagerStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->GetForIsland(*(void**)(&content), &result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::DragDrop::IDragDropManagerStatics>**)this;
            check_hresult(_winrt_abi_type->GetForIsland(*(void**)(&content), &result));
        }
        return winrt::Microsoft::UI::Input::DragDrop::DragDropManager{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Input_DragDrop_IDragInfo<D>::AllowedOperations() const
    {
        winrt::Windows::ApplicationModel::DataTransfer::DataPackageOperation value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::DragDrop::IDragInfo>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::DragDrop::IDragInfo, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::DragDrop::IDragInfo>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_AllowedOperations(reinterpret_cast<uint32_t*>(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::DragDrop::IDragInfo>**)this;
            check_hresult(_winrt_abi_type->get_AllowedOperations(reinterpret_cast<uint32_t*>(&value)));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Input_DragDrop_IDragInfo<D>::Data() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::DragDrop::IDragInfo>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::DragDrop::IDragInfo, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::DragDrop::IDragInfo>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Data(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::DragDrop::IDragInfo>**)this;
            check_hresult(_winrt_abi_type->get_Data(&value));
        }
        return winrt::Windows::ApplicationModel::DataTransfer::DataPackageView{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Input_DragDrop_IDragInfo<D>::Modifiers() const
    {
        winrt::Microsoft::UI::Input::DragDrop::DragDropModifiers value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::DragDrop::IDragInfo>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::DragDrop::IDragInfo, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::DragDrop::IDragInfo>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Modifiers(reinterpret_cast<uint32_t*>(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::DragDrop::IDragInfo>**)this;
            check_hresult(_winrt_abi_type->get_Modifiers(reinterpret_cast<uint32_t*>(&value)));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Input_DragDrop_IDragInfo<D>::Position() const
    {
        winrt::Windows::Foundation::Point value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::DragDrop::IDragInfo>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::DragDrop::IDragInfo, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::DragDrop::IDragInfo>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Position(put_abi(value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::DragDrop::IDragInfo>**)this;
            check_hresult(_winrt_abi_type->get_Position(put_abi(value)));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Input_DragDrop_IDragOperation<D>::AllowedOperations() const
    {
        winrt::Windows::ApplicationModel::DataTransfer::DataPackageOperation value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::DragDrop::IDragOperation>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::DragDrop::IDragOperation, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::DragDrop::IDragOperation>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_AllowedOperations(reinterpret_cast<uint32_t*>(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::DragDrop::IDragOperation>**)this;
            check_hresult(_winrt_abi_type->get_AllowedOperations(reinterpret_cast<uint32_t*>(&value)));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Input_DragDrop_IDragOperation<D>::AllowedOperations(winrt::Windows::ApplicationModel::DataTransfer::DataPackageOperation const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::DragDrop::IDragOperation>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::DragDrop::IDragOperation, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::DragDrop::IDragOperation>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_AllowedOperations(static_cast<uint32_t>(value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::DragDrop::IDragOperation>**)this;
            check_hresult(_winrt_abi_type->put_AllowedOperations(static_cast<uint32_t>(value)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Input_DragDrop_IDragOperation<D>::Data() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::DragDrop::IDragOperation>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::DragDrop::IDragOperation, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::DragDrop::IDragOperation>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Data(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::DragDrop::IDragOperation>**)this;
            check_hresult(_winrt_abi_type->get_Data(&value));
        }
        return winrt::Windows::ApplicationModel::DataTransfer::DataPackage{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Input_DragDrop_IDragOperation<D>::DragUIContentMode() const
    {
        winrt::Microsoft::UI::Input::DragDrop::DragUIContentMode value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::DragDrop::IDragOperation>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::DragDrop::IDragOperation, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::DragDrop::IDragOperation>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_DragUIContentMode(reinterpret_cast<int32_t*>(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::DragDrop::IDragOperation>**)this;
            check_hresult(_winrt_abi_type->get_DragUIContentMode(reinterpret_cast<int32_t*>(&value)));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Input_DragDrop_IDragOperation<D>::DragUIContentMode(winrt::Microsoft::UI::Input::DragDrop::DragUIContentMode const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::DragDrop::IDragOperation>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::DragDrop::IDragOperation, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::DragDrop::IDragOperation>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_DragUIContentMode(static_cast<int32_t>(value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::DragDrop::IDragOperation>**)this;
            check_hresult(_winrt_abi_type->put_DragUIContentMode(static_cast<int32_t>(value)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Input_DragDrop_IDragOperation<D>::SetDragUIContentFromSoftwareBitmap(winrt::Windows::Graphics::Imaging::SoftwareBitmap const& bitmap) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::DragDrop::IDragOperation>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::DragDrop::IDragOperation, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::DragDrop::IDragOperation>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->SetDragUIContentFromSoftwareBitmap(*(void**)(&bitmap)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::DragDrop::IDragOperation>**)this;
            check_hresult(_winrt_abi_type->SetDragUIContentFromSoftwareBitmap(*(void**)(&bitmap)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Input_DragDrop_IDragOperation<D>::SetDragUIContentFromSoftwareBitmap(winrt::Windows::Graphics::Imaging::SoftwareBitmap const& bitmap, winrt::Windows::Foundation::Point const& anchorPoint) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::DragDrop::IDragOperation>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::DragDrop::IDragOperation, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::DragDrop::IDragOperation>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->SetDragUIContentFromSoftwareBitmap2(*(void**)(&bitmap), impl::bind_in(anchorPoint)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::DragDrop::IDragOperation>**)this;
            check_hresult(_winrt_abi_type->SetDragUIContentFromSoftwareBitmap2(*(void**)(&bitmap), impl::bind_in(anchorPoint)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Input_DragDrop_IDragOperation<D>::StartAsync(winrt::Microsoft::UI::Input::DragDrop::DragDropManager const& initialTarget, winrt::Microsoft::UI::Input::PointerPoint const& initialPointerPoint) const
    {
        void* operation{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::DragDrop::IDragOperation>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::DragDrop::IDragOperation, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::DragDrop::IDragOperation>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->StartAsync(*(void**)(&initialTarget), *(void**)(&initialPointerPoint), &operation));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::DragDrop::IDragOperation>**)this;
            check_hresult(_winrt_abi_type->StartAsync(*(void**)(&initialTarget), *(void**)(&initialPointerPoint), &operation));
        }
        return winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::ApplicationModel::DataTransfer::DataPackageOperation>{ operation, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Input_DragDrop_IDragUIOverride<D>::Caption() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::DragDrop::IDragUIOverride>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::DragDrop::IDragUIOverride, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::DragDrop::IDragUIOverride>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Caption(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::DragDrop::IDragUIOverride>**)this;
            check_hresult(_winrt_abi_type->get_Caption(&value));
        }
        return hstring{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Input_DragDrop_IDragUIOverride<D>::Caption(param::hstring const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::DragDrop::IDragUIOverride>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::DragDrop::IDragUIOverride, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::DragDrop::IDragUIOverride>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_Caption(*(void**)(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::DragDrop::IDragUIOverride>**)this;
            check_hresult(_winrt_abi_type->put_Caption(*(void**)(&value)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Input_DragDrop_IDragUIOverride<D>::IsCaptionVisible() const
    {
        bool value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::DragDrop::IDragUIOverride>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::DragDrop::IDragUIOverride, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::DragDrop::IDragUIOverride>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_IsCaptionVisible(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::DragDrop::IDragUIOverride>**)this;
            check_hresult(_winrt_abi_type->get_IsCaptionVisible(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Input_DragDrop_IDragUIOverride<D>::IsCaptionVisible(bool value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::DragDrop::IDragUIOverride>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::DragDrop::IDragUIOverride, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::DragDrop::IDragUIOverride>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_IsCaptionVisible(value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::DragDrop::IDragUIOverride>**)this;
            check_hresult(_winrt_abi_type->put_IsCaptionVisible(value));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Input_DragDrop_IDragUIOverride<D>::IsContentVisible() const
    {
        bool value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::DragDrop::IDragUIOverride>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::DragDrop::IDragUIOverride, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::DragDrop::IDragUIOverride>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_IsContentVisible(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::DragDrop::IDragUIOverride>**)this;
            check_hresult(_winrt_abi_type->get_IsContentVisible(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Input_DragDrop_IDragUIOverride<D>::IsContentVisible(bool value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::DragDrop::IDragUIOverride>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::DragDrop::IDragUIOverride, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::DragDrop::IDragUIOverride>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_IsContentVisible(value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::DragDrop::IDragUIOverride>**)this;
            check_hresult(_winrt_abi_type->put_IsContentVisible(value));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Input_DragDrop_IDragUIOverride<D>::IsGlyphVisible() const
    {
        bool value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::DragDrop::IDragUIOverride>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::DragDrop::IDragUIOverride, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::DragDrop::IDragUIOverride>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_IsGlyphVisible(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::DragDrop::IDragUIOverride>**)this;
            check_hresult(_winrt_abi_type->get_IsGlyphVisible(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_UI_Input_DragDrop_IDragUIOverride<D>::IsGlyphVisible(bool value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::DragDrop::IDragUIOverride>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::DragDrop::IDragUIOverride, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::DragDrop::IDragUIOverride>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_IsGlyphVisible(value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::DragDrop::IDragUIOverride>**)this;
            check_hresult(_winrt_abi_type->put_IsGlyphVisible(value));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Input_DragDrop_IDragUIOverride<D>::Clear() const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::DragDrop::IDragUIOverride>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::DragDrop::IDragUIOverride, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::DragDrop::IDragUIOverride>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->Clear());
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::DragDrop::IDragUIOverride>**)this;
            check_hresult(_winrt_abi_type->Clear());
        }
    }
    template <typename D> auto consume_Microsoft_UI_Input_DragDrop_IDragUIOverride<D>::SetContentFromSoftwareBitmap(winrt::Windows::Graphics::Imaging::SoftwareBitmap const& bitmap) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::DragDrop::IDragUIOverride>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::DragDrop::IDragUIOverride, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::DragDrop::IDragUIOverride>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->SetContentFromSoftwareBitmap(*(void**)(&bitmap)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::DragDrop::IDragUIOverride>**)this;
            check_hresult(_winrt_abi_type->SetContentFromSoftwareBitmap(*(void**)(&bitmap)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Input_DragDrop_IDragUIOverride<D>::SetContentFromSoftwareBitmap(winrt::Windows::Graphics::Imaging::SoftwareBitmap const& bitmap, winrt::Windows::Foundation::Point const& anchorPoint) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::DragDrop::IDragUIOverride>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::DragDrop::IDragUIOverride, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::DragDrop::IDragUIOverride>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->SetContentFromSoftwareBitmap2(*(void**)(&bitmap), impl::bind_in(anchorPoint)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::DragDrop::IDragUIOverride>**)this;
            check_hresult(_winrt_abi_type->SetContentFromSoftwareBitmap2(*(void**)(&bitmap), impl::bind_in(anchorPoint)));
        }
    }
    template <typename D> auto consume_Microsoft_UI_Input_DragDrop_IDropOperationTarget<D>::DropAsync(winrt::Microsoft::UI::Input::DragDrop::DragInfo const& dragInfo) const
    {
        void* operation{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::DragDrop::IDropOperationTarget>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::DragDrop::IDropOperationTarget, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::DragDrop::IDropOperationTarget>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->DropAsync(*(void**)(&dragInfo), &operation));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::DragDrop::IDropOperationTarget>**)this;
            check_hresult(_winrt_abi_type->DropAsync(*(void**)(&dragInfo), &operation));
        }
        return winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::ApplicationModel::DataTransfer::DataPackageOperation>{ operation, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Input_DragDrop_IDropOperationTarget<D>::EnterAsync(winrt::Microsoft::UI::Input::DragDrop::DragInfo const& dragInfo, winrt::Microsoft::UI::Input::DragDrop::DragUIOverride const& dragUIOverride) const
    {
        void* operation{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::DragDrop::IDropOperationTarget>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::DragDrop::IDropOperationTarget, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::DragDrop::IDropOperationTarget>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->EnterAsync(*(void**)(&dragInfo), *(void**)(&dragUIOverride), &operation));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::DragDrop::IDropOperationTarget>**)this;
            check_hresult(_winrt_abi_type->EnterAsync(*(void**)(&dragInfo), *(void**)(&dragUIOverride), &operation));
        }
        return winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::ApplicationModel::DataTransfer::DataPackageOperation>{ operation, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Input_DragDrop_IDropOperationTarget<D>::LeaveAsync(winrt::Microsoft::UI::Input::DragDrop::DragInfo const& dragInfo) const
    {
        void* operation{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::DragDrop::IDropOperationTarget>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::DragDrop::IDropOperationTarget, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::DragDrop::IDropOperationTarget>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->LeaveAsync(*(void**)(&dragInfo), &operation));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::DragDrop::IDropOperationTarget>**)this;
            check_hresult(_winrt_abi_type->LeaveAsync(*(void**)(&dragInfo), &operation));
        }
        return winrt::Windows::Foundation::IAsyncAction{ operation, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Input_DragDrop_IDropOperationTarget<D>::OverAsync(winrt::Microsoft::UI::Input::DragDrop::DragInfo const& dragInfo, winrt::Microsoft::UI::Input::DragDrop::DragUIOverride const& dragUIOverride) const
    {
        void* operation{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::DragDrop::IDropOperationTarget>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::DragDrop::IDropOperationTarget, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::DragDrop::IDropOperationTarget>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->OverAsync(*(void**)(&dragInfo), *(void**)(&dragUIOverride), &operation));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::DragDrop::IDropOperationTarget>**)this;
            check_hresult(_winrt_abi_type->OverAsync(*(void**)(&dragInfo), *(void**)(&dragUIOverride), &operation));
        }
        return winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::ApplicationModel::DataTransfer::DataPackageOperation>{ operation, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_UI_Input_DragDrop_IDropOperationTargetRequestedEventArgs<D>::SetTarget(winrt::Microsoft::UI::Input::DragDrop::IDropOperationTarget const& target) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::UI::Input::DragDrop::IDropOperationTargetRequestedEventArgs>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::UI::Input::DragDrop::IDropOperationTargetRequestedEventArgs, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::DragDrop::IDropOperationTargetRequestedEventArgs>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->SetTarget(*(void**)(&target)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::UI::Input::DragDrop::IDropOperationTargetRequestedEventArgs>**)this;
            check_hresult(_winrt_abi_type->SetTarget(*(void**)(&target)));
        }
    }
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Input::DragDrop::IDragDropManager> : produce_base<D, winrt::Microsoft::UI::Input::DragDrop::IDragDropManager>
    {
        int32_t __stdcall get_AreConcurrentOperationsEnabled(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().AreConcurrentOperationsEnabled());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_AreConcurrentOperationsEnabled(bool value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().AreConcurrentOperationsEnabled(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall add_TargetRequested(void* handler, winrt::event_token* token) noexcept final try
        {
            zero_abi<winrt::event_token>(token);
            typename D::abi_guard guard(this->shim());
            *token = detach_from<winrt::event_token>(this->shim().TargetRequested(*reinterpret_cast<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Input::DragDrop::DragDropManager, winrt::Microsoft::UI::Input::DragDrop::DropOperationTargetRequestedEventArgs> const*>(&handler)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall remove_TargetRequested(winrt::event_token token) noexcept final
        {
            typename D::abi_guard guard(this->shim());
            this->shim().TargetRequested(*reinterpret_cast<winrt::event_token const*>(&token));
            return 0;
        }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Input::DragDrop::IDragDropManagerStatics> : produce_base<D, winrt::Microsoft::UI::Input::DragDrop::IDragDropManagerStatics>
    {
        int32_t __stdcall GetForIsland(void* content, void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Microsoft::UI::Input::DragDrop::DragDropManager>(this->shim().GetForIsland(*reinterpret_cast<winrt::Microsoft::UI::Content::ContentIsland const*>(&content)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Input::DragDrop::IDragInfo> : produce_base<D, winrt::Microsoft::UI::Input::DragDrop::IDragInfo>
    {
        int32_t __stdcall get_AllowedOperations(uint32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::ApplicationModel::DataTransfer::DataPackageOperation>(this->shim().AllowedOperations());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Data(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::ApplicationModel::DataTransfer::DataPackageView>(this->shim().Data());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Modifiers(uint32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::UI::Input::DragDrop::DragDropModifiers>(this->shim().Modifiers());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Position(winrt::Windows::Foundation::Point* value) noexcept final try
        {
            zero_abi<winrt::Windows::Foundation::Point>(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::Point>(this->shim().Position());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Input::DragDrop::IDragOperation> : produce_base<D, winrt::Microsoft::UI::Input::DragDrop::IDragOperation>
    {
        int32_t __stdcall get_AllowedOperations(uint32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::ApplicationModel::DataTransfer::DataPackageOperation>(this->shim().AllowedOperations());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_AllowedOperations(uint32_t value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().AllowedOperations(*reinterpret_cast<winrt::Windows::ApplicationModel::DataTransfer::DataPackageOperation const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Data(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::ApplicationModel::DataTransfer::DataPackage>(this->shim().Data());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_DragUIContentMode(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::UI::Input::DragDrop::DragUIContentMode>(this->shim().DragUIContentMode());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_DragUIContentMode(int32_t value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().DragUIContentMode(*reinterpret_cast<winrt::Microsoft::UI::Input::DragDrop::DragUIContentMode const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall SetDragUIContentFromSoftwareBitmap(void* bitmap) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().SetDragUIContentFromSoftwareBitmap(*reinterpret_cast<winrt::Windows::Graphics::Imaging::SoftwareBitmap const*>(&bitmap));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall SetDragUIContentFromSoftwareBitmap2(void* bitmap, winrt::Windows::Foundation::Point anchorPoint) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().SetDragUIContentFromSoftwareBitmap(*reinterpret_cast<winrt::Windows::Graphics::Imaging::SoftwareBitmap const*>(&bitmap), *reinterpret_cast<winrt::Windows::Foundation::Point const*>(&anchorPoint));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall StartAsync(void* initialTarget, void* initialPointerPoint, void** operation) noexcept final try
        {
            clear_abi(operation);
            typename D::abi_guard guard(this->shim());
            *operation = detach_from<winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::ApplicationModel::DataTransfer::DataPackageOperation>>(this->shim().StartAsync(*reinterpret_cast<winrt::Microsoft::UI::Input::DragDrop::DragDropManager const*>(&initialTarget), *reinterpret_cast<winrt::Microsoft::UI::Input::PointerPoint const*>(&initialPointerPoint)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Input::DragDrop::IDragUIOverride> : produce_base<D, winrt::Microsoft::UI::Input::DragDrop::IDragUIOverride>
    {
        int32_t __stdcall get_Caption(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<hstring>(this->shim().Caption());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_Caption(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Caption(*reinterpret_cast<hstring const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_IsCaptionVisible(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().IsCaptionVisible());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_IsCaptionVisible(bool value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().IsCaptionVisible(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_IsContentVisible(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().IsContentVisible());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_IsContentVisible(bool value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().IsContentVisible(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_IsGlyphVisible(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().IsGlyphVisible());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_IsGlyphVisible(bool value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().IsGlyphVisible(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall Clear() noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Clear();
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall SetContentFromSoftwareBitmap(void* bitmap) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().SetContentFromSoftwareBitmap(*reinterpret_cast<winrt::Windows::Graphics::Imaging::SoftwareBitmap const*>(&bitmap));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall SetContentFromSoftwareBitmap2(void* bitmap, winrt::Windows::Foundation::Point anchorPoint) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().SetContentFromSoftwareBitmap(*reinterpret_cast<winrt::Windows::Graphics::Imaging::SoftwareBitmap const*>(&bitmap), *reinterpret_cast<winrt::Windows::Foundation::Point const*>(&anchorPoint));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Input::DragDrop::IDropOperationTarget> : produce_base<D, winrt::Microsoft::UI::Input::DragDrop::IDropOperationTarget>
    {
        int32_t __stdcall DropAsync(void* dragInfo, void** operation) noexcept final try
        {
            clear_abi(operation);
            typename D::abi_guard guard(this->shim());
            *operation = detach_from<winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::ApplicationModel::DataTransfer::DataPackageOperation>>(this->shim().DropAsync(*reinterpret_cast<winrt::Microsoft::UI::Input::DragDrop::DragInfo const*>(&dragInfo)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall EnterAsync(void* dragInfo, void* dragUIOverride, void** operation) noexcept final try
        {
            clear_abi(operation);
            typename D::abi_guard guard(this->shim());
            *operation = detach_from<winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::ApplicationModel::DataTransfer::DataPackageOperation>>(this->shim().EnterAsync(*reinterpret_cast<winrt::Microsoft::UI::Input::DragDrop::DragInfo const*>(&dragInfo), *reinterpret_cast<winrt::Microsoft::UI::Input::DragDrop::DragUIOverride const*>(&dragUIOverride)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall LeaveAsync(void* dragInfo, void** operation) noexcept final try
        {
            clear_abi(operation);
            typename D::abi_guard guard(this->shim());
            *operation = detach_from<winrt::Windows::Foundation::IAsyncAction>(this->shim().LeaveAsync(*reinterpret_cast<winrt::Microsoft::UI::Input::DragDrop::DragInfo const*>(&dragInfo)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall OverAsync(void* dragInfo, void* dragUIOverride, void** operation) noexcept final try
        {
            clear_abi(operation);
            typename D::abi_guard guard(this->shim());
            *operation = detach_from<winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::ApplicationModel::DataTransfer::DataPackageOperation>>(this->shim().OverAsync(*reinterpret_cast<winrt::Microsoft::UI::Input::DragDrop::DragInfo const*>(&dragInfo), *reinterpret_cast<winrt::Microsoft::UI::Input::DragDrop::DragUIOverride const*>(&dragUIOverride)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::UI::Input::DragDrop::IDropOperationTargetRequestedEventArgs> : produce_base<D, winrt::Microsoft::UI::Input::DragDrop::IDropOperationTargetRequestedEventArgs>
    {
        int32_t __stdcall SetTarget(void* target) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().SetTarget(*reinterpret_cast<winrt::Microsoft::UI::Input::DragDrop::IDropOperationTarget const*>(&target));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
}
WINRT_EXPORT namespace winrt::Microsoft::UI::Input::DragDrop
{
    constexpr auto operator|(DragDropModifiers const left, DragDropModifiers const right) noexcept
    {
        return static_cast<DragDropModifiers>(impl::to_underlying_type(left) | impl::to_underlying_type(right));
    }
    constexpr auto operator|=(DragDropModifiers& left, DragDropModifiers const right) noexcept
    {
        left = left | right;
        return left;
    }
    constexpr auto operator&(DragDropModifiers const left, DragDropModifiers const right) noexcept
    {
        return static_cast<DragDropModifiers>(impl::to_underlying_type(left) & impl::to_underlying_type(right));
    }
    constexpr auto operator&=(DragDropModifiers& left, DragDropModifiers const right) noexcept
    {
        left = left & right;
        return left;
    }
    constexpr auto operator~(DragDropModifiers const value) noexcept
    {
        return static_cast<DragDropModifiers>(~impl::to_underlying_type(value));
    }
    constexpr auto operator^(DragDropModifiers const left, DragDropModifiers const right) noexcept
    {
        return static_cast<DragDropModifiers>(impl::to_underlying_type(left) ^ impl::to_underlying_type(right));
    }
    constexpr auto operator^=(DragDropModifiers& left, DragDropModifiers const right) noexcept
    {
        left = left ^ right;
        return left;
    }
    inline auto DragDropManager::GetForIsland(winrt::Microsoft::UI::Content::ContentIsland const& content)
    {
        return impl::call_factory<DragDropManager, IDragDropManagerStatics>([&](IDragDropManagerStatics const& f) { return f.GetForIsland(content); });
    }
    inline DragOperation::DragOperation() :
        DragOperation(impl::call_factory_cast<DragOperation(*)(winrt::Windows::Foundation::IActivationFactory const&), DragOperation>([](winrt::Windows::Foundation::IActivationFactory const& f) { return f.template ActivateInstance<DragOperation>(); }))
    {
    }
}
namespace std
{
#ifndef WINRT_LEAN_AND_MEAN
    template<> struct hash<winrt::Microsoft::UI::Input::DragDrop::IDragDropManager> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Input::DragDrop::IDragDropManagerStatics> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Input::DragDrop::IDragInfo> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Input::DragDrop::IDragOperation> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Input::DragDrop::IDragUIOverride> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Input::DragDrop::IDropOperationTarget> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Input::DragDrop::IDropOperationTargetRequestedEventArgs> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Input::DragDrop::DragDropManager> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Input::DragDrop::DragInfo> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Input::DragDrop::DragOperation> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Input::DragDrop::DragUIOverride> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::UI::Input::DragDrop::DropOperationTargetRequestedEventArgs> : winrt::impl::hash_base {};
#endif
#ifdef __cpp_lib_format
#endif
}
#endif
