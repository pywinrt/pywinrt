// WARNING: Please don't edit this file. It was generated by Python/WinRT v0.0.0

#include "py.Windows.Devices.Sms.h"


namespace py::cpp::Windows::Devices::Sms
{
    // ----- DeleteSmsMessageOperation class --------------------

    static PyObject* _new_DeleteSmsMessageOperation(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Sms::DeleteSmsMessageOperation>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Sms::DeleteSmsMessageOperation>::type_name);
        return nullptr;
    }

    static void _dealloc_DeleteSmsMessageOperation(py::wrapper::Windows::Devices::Sms::DeleteSmsMessageOperation* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* DeleteSmsMessageOperation_Cancel(py::wrapper::Windows::Devices::Sms::DeleteSmsMessageOperation* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sms.DeleteSmsMessageOperation", L"Cancel", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Cancel();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DeleteSmsMessageOperation_Close(py::wrapper::Windows::Devices::Sms::DeleteSmsMessageOperation* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sms.DeleteSmsMessageOperation", L"Close", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DeleteSmsMessageOperation_GetResults(py::wrapper::Windows::Devices::Sms::DeleteSmsMessageOperation* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sms.DeleteSmsMessageOperation", L"GetResults", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.GetResults();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DeleteSmsMessageOperation_get_ErrorCode(py::wrapper::Windows::Devices::Sms::DeleteSmsMessageOperation* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.DeleteSmsMessageOperation", L"ErrorCode"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ErrorCode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DeleteSmsMessageOperation_get_Id(py::wrapper::Windows::Devices::Sms::DeleteSmsMessageOperation* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.DeleteSmsMessageOperation", L"Id"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DeleteSmsMessageOperation_get_Status(py::wrapper::Windows::Devices::Sms::DeleteSmsMessageOperation* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.DeleteSmsMessageOperation", L"Status"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DeleteSmsMessageOperation_get_Completed(py::wrapper::Windows::Devices::Sms::DeleteSmsMessageOperation* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.DeleteSmsMessageOperation", L"Completed"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Completed());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DeleteSmsMessageOperation_put_Completed(py::wrapper::Windows::Devices::Sms::DeleteSmsMessageOperation* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.DeleteSmsMessageOperation", L"Completed"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::AsyncActionCompletedHandler>(arg);

            self->obj.Completed(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_DeleteSmsMessageOperation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Sms::DeleteSmsMessageOperation>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_DeleteSmsMessageOperation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sms::DeleteSmsMessageOperation>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _await_DeleteSmsMessageOperation(py::wrapper::Windows::Devices::Sms::DeleteSmsMessageOperation* self) noexcept
    {
        return py::dunder_await(self->obj);
    }

    static PyMethodDef _methods_DeleteSmsMessageOperation[] = {
        { "cancel", reinterpret_cast<PyCFunction>(DeleteSmsMessageOperation_Cancel), METH_VARARGS, nullptr },
        { "close", reinterpret_cast<PyCFunction>(DeleteSmsMessageOperation_Close), METH_VARARGS, nullptr },
        { "get_results", reinterpret_cast<PyCFunction>(DeleteSmsMessageOperation_GetResults), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_DeleteSmsMessageOperation, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DeleteSmsMessageOperation), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DeleteSmsMessageOperation[] = {
        { "error_code", reinterpret_cast<getter>(DeleteSmsMessageOperation_get_ErrorCode), nullptr, nullptr, nullptr },
        { "id", reinterpret_cast<getter>(DeleteSmsMessageOperation_get_Id), nullptr, nullptr, nullptr },
        { "status", reinterpret_cast<getter>(DeleteSmsMessageOperation_get_Status), nullptr, nullptr, nullptr },
        { "completed", reinterpret_cast<getter>(DeleteSmsMessageOperation_get_Completed), reinterpret_cast<setter>(DeleteSmsMessageOperation_put_Completed), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_DeleteSmsMessageOperation[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_DeleteSmsMessageOperation) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_DeleteSmsMessageOperation) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_DeleteSmsMessageOperation) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_DeleteSmsMessageOperation) },
        { Py_am_await, reinterpret_cast<void*>(_await_DeleteSmsMessageOperation) },
        { },
    };

    static PyType_Spec type_spec_DeleteSmsMessageOperation =
    {
        "winrt._winrt_windows_devices_sms.DeleteSmsMessageOperation",
        sizeof(py::wrapper::Windows::Devices::Sms::DeleteSmsMessageOperation),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DeleteSmsMessageOperation
    };

    // ----- DeleteSmsMessagesOperation class --------------------

    static PyObject* _new_DeleteSmsMessagesOperation(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Sms::DeleteSmsMessagesOperation>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Sms::DeleteSmsMessagesOperation>::type_name);
        return nullptr;
    }

    static void _dealloc_DeleteSmsMessagesOperation(py::wrapper::Windows::Devices::Sms::DeleteSmsMessagesOperation* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* DeleteSmsMessagesOperation_Cancel(py::wrapper::Windows::Devices::Sms::DeleteSmsMessagesOperation* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sms.DeleteSmsMessagesOperation", L"Cancel", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Cancel();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DeleteSmsMessagesOperation_Close(py::wrapper::Windows::Devices::Sms::DeleteSmsMessagesOperation* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sms.DeleteSmsMessagesOperation", L"Close", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DeleteSmsMessagesOperation_GetResults(py::wrapper::Windows::Devices::Sms::DeleteSmsMessagesOperation* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sms.DeleteSmsMessagesOperation", L"GetResults", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.GetResults();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DeleteSmsMessagesOperation_get_ErrorCode(py::wrapper::Windows::Devices::Sms::DeleteSmsMessagesOperation* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.DeleteSmsMessagesOperation", L"ErrorCode"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ErrorCode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DeleteSmsMessagesOperation_get_Id(py::wrapper::Windows::Devices::Sms::DeleteSmsMessagesOperation* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.DeleteSmsMessagesOperation", L"Id"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DeleteSmsMessagesOperation_get_Status(py::wrapper::Windows::Devices::Sms::DeleteSmsMessagesOperation* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.DeleteSmsMessagesOperation", L"Status"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DeleteSmsMessagesOperation_get_Completed(py::wrapper::Windows::Devices::Sms::DeleteSmsMessagesOperation* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.DeleteSmsMessagesOperation", L"Completed"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Completed());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DeleteSmsMessagesOperation_put_Completed(py::wrapper::Windows::Devices::Sms::DeleteSmsMessagesOperation* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.DeleteSmsMessagesOperation", L"Completed"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::AsyncActionCompletedHandler>(arg);

            self->obj.Completed(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_DeleteSmsMessagesOperation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Sms::DeleteSmsMessagesOperation>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_DeleteSmsMessagesOperation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sms::DeleteSmsMessagesOperation>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _await_DeleteSmsMessagesOperation(py::wrapper::Windows::Devices::Sms::DeleteSmsMessagesOperation* self) noexcept
    {
        return py::dunder_await(self->obj);
    }

    static PyMethodDef _methods_DeleteSmsMessagesOperation[] = {
        { "cancel", reinterpret_cast<PyCFunction>(DeleteSmsMessagesOperation_Cancel), METH_VARARGS, nullptr },
        { "close", reinterpret_cast<PyCFunction>(DeleteSmsMessagesOperation_Close), METH_VARARGS, nullptr },
        { "get_results", reinterpret_cast<PyCFunction>(DeleteSmsMessagesOperation_GetResults), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_DeleteSmsMessagesOperation, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DeleteSmsMessagesOperation), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DeleteSmsMessagesOperation[] = {
        { "error_code", reinterpret_cast<getter>(DeleteSmsMessagesOperation_get_ErrorCode), nullptr, nullptr, nullptr },
        { "id", reinterpret_cast<getter>(DeleteSmsMessagesOperation_get_Id), nullptr, nullptr, nullptr },
        { "status", reinterpret_cast<getter>(DeleteSmsMessagesOperation_get_Status), nullptr, nullptr, nullptr },
        { "completed", reinterpret_cast<getter>(DeleteSmsMessagesOperation_get_Completed), reinterpret_cast<setter>(DeleteSmsMessagesOperation_put_Completed), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_DeleteSmsMessagesOperation[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_DeleteSmsMessagesOperation) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_DeleteSmsMessagesOperation) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_DeleteSmsMessagesOperation) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_DeleteSmsMessagesOperation) },
        { Py_am_await, reinterpret_cast<void*>(_await_DeleteSmsMessagesOperation) },
        { },
    };

    static PyType_Spec type_spec_DeleteSmsMessagesOperation =
    {
        "winrt._winrt_windows_devices_sms.DeleteSmsMessagesOperation",
        sizeof(py::wrapper::Windows::Devices::Sms::DeleteSmsMessagesOperation),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DeleteSmsMessagesOperation
    };

    // ----- GetSmsDeviceOperation class --------------------

    static PyObject* _new_GetSmsDeviceOperation(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Sms::GetSmsDeviceOperation>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Sms::GetSmsDeviceOperation>::type_name);
        return nullptr;
    }

    static void _dealloc_GetSmsDeviceOperation(py::wrapper::Windows::Devices::Sms::GetSmsDeviceOperation* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* GetSmsDeviceOperation_Cancel(py::wrapper::Windows::Devices::Sms::GetSmsDeviceOperation* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sms.GetSmsDeviceOperation", L"Cancel", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Cancel();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GetSmsDeviceOperation_Close(py::wrapper::Windows::Devices::Sms::GetSmsDeviceOperation* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sms.GetSmsDeviceOperation", L"Close", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GetSmsDeviceOperation_GetResults(py::wrapper::Windows::Devices::Sms::GetSmsDeviceOperation* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sms.GetSmsDeviceOperation", L"GetResults", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetResults());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GetSmsDeviceOperation_get_ErrorCode(py::wrapper::Windows::Devices::Sms::GetSmsDeviceOperation* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.GetSmsDeviceOperation", L"ErrorCode"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ErrorCode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GetSmsDeviceOperation_get_Id(py::wrapper::Windows::Devices::Sms::GetSmsDeviceOperation* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.GetSmsDeviceOperation", L"Id"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GetSmsDeviceOperation_get_Status(py::wrapper::Windows::Devices::Sms::GetSmsDeviceOperation* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.GetSmsDeviceOperation", L"Status"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GetSmsDeviceOperation_get_Completed(py::wrapper::Windows::Devices::Sms::GetSmsDeviceOperation* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.GetSmsDeviceOperation", L"Completed"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Completed());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GetSmsDeviceOperation_put_Completed(py::wrapper::Windows::Devices::Sms::GetSmsDeviceOperation* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.GetSmsDeviceOperation", L"Completed"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::AsyncOperationCompletedHandler<winrt::Windows::Devices::Sms::SmsDevice>>(arg);

            self->obj.Completed(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_GetSmsDeviceOperation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Sms::GetSmsDeviceOperation>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_GetSmsDeviceOperation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sms::GetSmsDeviceOperation>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _await_GetSmsDeviceOperation(py::wrapper::Windows::Devices::Sms::GetSmsDeviceOperation* self) noexcept
    {
        return py::dunder_await(self->obj);
    }

    static PyMethodDef _methods_GetSmsDeviceOperation[] = {
        { "cancel", reinterpret_cast<PyCFunction>(GetSmsDeviceOperation_Cancel), METH_VARARGS, nullptr },
        { "close", reinterpret_cast<PyCFunction>(GetSmsDeviceOperation_Close), METH_VARARGS, nullptr },
        { "get_results", reinterpret_cast<PyCFunction>(GetSmsDeviceOperation_GetResults), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_GetSmsDeviceOperation, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_GetSmsDeviceOperation), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_GetSmsDeviceOperation[] = {
        { "error_code", reinterpret_cast<getter>(GetSmsDeviceOperation_get_ErrorCode), nullptr, nullptr, nullptr },
        { "id", reinterpret_cast<getter>(GetSmsDeviceOperation_get_Id), nullptr, nullptr, nullptr },
        { "status", reinterpret_cast<getter>(GetSmsDeviceOperation_get_Status), nullptr, nullptr, nullptr },
        { "completed", reinterpret_cast<getter>(GetSmsDeviceOperation_get_Completed), reinterpret_cast<setter>(GetSmsDeviceOperation_put_Completed), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_GetSmsDeviceOperation[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_GetSmsDeviceOperation) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_GetSmsDeviceOperation) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_GetSmsDeviceOperation) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_GetSmsDeviceOperation) },
        { Py_am_await, reinterpret_cast<void*>(_await_GetSmsDeviceOperation) },
        { },
    };

    static PyType_Spec type_spec_GetSmsDeviceOperation =
    {
        "winrt._winrt_windows_devices_sms.GetSmsDeviceOperation",
        sizeof(py::wrapper::Windows::Devices::Sms::GetSmsDeviceOperation),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_GetSmsDeviceOperation
    };

    // ----- GetSmsMessageOperation class --------------------

    static PyObject* _new_GetSmsMessageOperation(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Sms::GetSmsMessageOperation>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Sms::GetSmsMessageOperation>::type_name);
        return nullptr;
    }

    static void _dealloc_GetSmsMessageOperation(py::wrapper::Windows::Devices::Sms::GetSmsMessageOperation* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* GetSmsMessageOperation_Cancel(py::wrapper::Windows::Devices::Sms::GetSmsMessageOperation* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sms.GetSmsMessageOperation", L"Cancel", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Cancel();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GetSmsMessageOperation_Close(py::wrapper::Windows::Devices::Sms::GetSmsMessageOperation* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sms.GetSmsMessageOperation", L"Close", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GetSmsMessageOperation_GetResults(py::wrapper::Windows::Devices::Sms::GetSmsMessageOperation* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sms.GetSmsMessageOperation", L"GetResults", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetResults());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GetSmsMessageOperation_get_ErrorCode(py::wrapper::Windows::Devices::Sms::GetSmsMessageOperation* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.GetSmsMessageOperation", L"ErrorCode"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ErrorCode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GetSmsMessageOperation_get_Id(py::wrapper::Windows::Devices::Sms::GetSmsMessageOperation* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.GetSmsMessageOperation", L"Id"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GetSmsMessageOperation_get_Status(py::wrapper::Windows::Devices::Sms::GetSmsMessageOperation* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.GetSmsMessageOperation", L"Status"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GetSmsMessageOperation_get_Completed(py::wrapper::Windows::Devices::Sms::GetSmsMessageOperation* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.GetSmsMessageOperation", L"Completed"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Completed());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GetSmsMessageOperation_put_Completed(py::wrapper::Windows::Devices::Sms::GetSmsMessageOperation* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.GetSmsMessageOperation", L"Completed"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::AsyncOperationCompletedHandler<winrt::Windows::Devices::Sms::ISmsMessage>>(arg);

            self->obj.Completed(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_GetSmsMessageOperation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Sms::GetSmsMessageOperation>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_GetSmsMessageOperation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sms::GetSmsMessageOperation>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _await_GetSmsMessageOperation(py::wrapper::Windows::Devices::Sms::GetSmsMessageOperation* self) noexcept
    {
        return py::dunder_await(self->obj);
    }

    static PyMethodDef _methods_GetSmsMessageOperation[] = {
        { "cancel", reinterpret_cast<PyCFunction>(GetSmsMessageOperation_Cancel), METH_VARARGS, nullptr },
        { "close", reinterpret_cast<PyCFunction>(GetSmsMessageOperation_Close), METH_VARARGS, nullptr },
        { "get_results", reinterpret_cast<PyCFunction>(GetSmsMessageOperation_GetResults), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_GetSmsMessageOperation, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_GetSmsMessageOperation), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_GetSmsMessageOperation[] = {
        { "error_code", reinterpret_cast<getter>(GetSmsMessageOperation_get_ErrorCode), nullptr, nullptr, nullptr },
        { "id", reinterpret_cast<getter>(GetSmsMessageOperation_get_Id), nullptr, nullptr, nullptr },
        { "status", reinterpret_cast<getter>(GetSmsMessageOperation_get_Status), nullptr, nullptr, nullptr },
        { "completed", reinterpret_cast<getter>(GetSmsMessageOperation_get_Completed), reinterpret_cast<setter>(GetSmsMessageOperation_put_Completed), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_GetSmsMessageOperation[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_GetSmsMessageOperation) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_GetSmsMessageOperation) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_GetSmsMessageOperation) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_GetSmsMessageOperation) },
        { Py_am_await, reinterpret_cast<void*>(_await_GetSmsMessageOperation) },
        { },
    };

    static PyType_Spec type_spec_GetSmsMessageOperation =
    {
        "winrt._winrt_windows_devices_sms.GetSmsMessageOperation",
        sizeof(py::wrapper::Windows::Devices::Sms::GetSmsMessageOperation),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_GetSmsMessageOperation
    };

    // ----- GetSmsMessagesOperation class --------------------

    static PyObject* _new_GetSmsMessagesOperation(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Sms::GetSmsMessagesOperation>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Sms::GetSmsMessagesOperation>::type_name);
        return nullptr;
    }

    static void _dealloc_GetSmsMessagesOperation(py::wrapper::Windows::Devices::Sms::GetSmsMessagesOperation* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* GetSmsMessagesOperation_Cancel(py::wrapper::Windows::Devices::Sms::GetSmsMessagesOperation* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sms.GetSmsMessagesOperation", L"Cancel", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Cancel();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GetSmsMessagesOperation_Close(py::wrapper::Windows::Devices::Sms::GetSmsMessagesOperation* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sms.GetSmsMessagesOperation", L"Close", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GetSmsMessagesOperation_GetResults(py::wrapper::Windows::Devices::Sms::GetSmsMessagesOperation* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sms.GetSmsMessagesOperation", L"GetResults", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetResults());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GetSmsMessagesOperation_get_ErrorCode(py::wrapper::Windows::Devices::Sms::GetSmsMessagesOperation* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.GetSmsMessagesOperation", L"ErrorCode"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ErrorCode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GetSmsMessagesOperation_get_Id(py::wrapper::Windows::Devices::Sms::GetSmsMessagesOperation* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.GetSmsMessagesOperation", L"Id"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GetSmsMessagesOperation_get_Status(py::wrapper::Windows::Devices::Sms::GetSmsMessagesOperation* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.GetSmsMessagesOperation", L"Status"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GetSmsMessagesOperation_get_Progress(py::wrapper::Windows::Devices::Sms::GetSmsMessagesOperation* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.GetSmsMessagesOperation", L"Progress"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Progress());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GetSmsMessagesOperation_put_Progress(py::wrapper::Windows::Devices::Sms::GetSmsMessagesOperation* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.GetSmsMessagesOperation", L"Progress"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::AsyncOperationProgressHandler<winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::Devices::Sms::ISmsMessage>, int32_t>>(arg);

            self->obj.Progress(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* GetSmsMessagesOperation_get_Completed(py::wrapper::Windows::Devices::Sms::GetSmsMessagesOperation* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.GetSmsMessagesOperation", L"Completed"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Completed());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GetSmsMessagesOperation_put_Completed(py::wrapper::Windows::Devices::Sms::GetSmsMessagesOperation* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.GetSmsMessagesOperation", L"Completed"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::AsyncOperationWithProgressCompletedHandler<winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::Devices::Sms::ISmsMessage>, int32_t>>(arg);

            self->obj.Completed(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_GetSmsMessagesOperation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Sms::GetSmsMessagesOperation>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_GetSmsMessagesOperation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sms::GetSmsMessagesOperation>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _await_GetSmsMessagesOperation(py::wrapper::Windows::Devices::Sms::GetSmsMessagesOperation* self) noexcept
    {
        return py::dunder_await(self->obj);
    }

    static PyMethodDef _methods_GetSmsMessagesOperation[] = {
        { "cancel", reinterpret_cast<PyCFunction>(GetSmsMessagesOperation_Cancel), METH_VARARGS, nullptr },
        { "close", reinterpret_cast<PyCFunction>(GetSmsMessagesOperation_Close), METH_VARARGS, nullptr },
        { "get_results", reinterpret_cast<PyCFunction>(GetSmsMessagesOperation_GetResults), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_GetSmsMessagesOperation, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_GetSmsMessagesOperation), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_GetSmsMessagesOperation[] = {
        { "error_code", reinterpret_cast<getter>(GetSmsMessagesOperation_get_ErrorCode), nullptr, nullptr, nullptr },
        { "id", reinterpret_cast<getter>(GetSmsMessagesOperation_get_Id), nullptr, nullptr, nullptr },
        { "status", reinterpret_cast<getter>(GetSmsMessagesOperation_get_Status), nullptr, nullptr, nullptr },
        { "progress", reinterpret_cast<getter>(GetSmsMessagesOperation_get_Progress), reinterpret_cast<setter>(GetSmsMessagesOperation_put_Progress), nullptr, nullptr },
        { "completed", reinterpret_cast<getter>(GetSmsMessagesOperation_get_Completed), reinterpret_cast<setter>(GetSmsMessagesOperation_put_Completed), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_GetSmsMessagesOperation[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_GetSmsMessagesOperation) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_GetSmsMessagesOperation) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_GetSmsMessagesOperation) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_GetSmsMessagesOperation) },
        { Py_am_await, reinterpret_cast<void*>(_await_GetSmsMessagesOperation) },
        { },
    };

    static PyType_Spec type_spec_GetSmsMessagesOperation =
    {
        "winrt._winrt_windows_devices_sms.GetSmsMessagesOperation",
        sizeof(py::wrapper::Windows::Devices::Sms::GetSmsMessagesOperation),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_GetSmsMessagesOperation
    };

    // ----- SendSmsMessageOperation class --------------------

    static PyObject* _new_SendSmsMessageOperation(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Sms::SendSmsMessageOperation>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Sms::SendSmsMessageOperation>::type_name);
        return nullptr;
    }

    static void _dealloc_SendSmsMessageOperation(py::wrapper::Windows::Devices::Sms::SendSmsMessageOperation* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SendSmsMessageOperation_Cancel(py::wrapper::Windows::Devices::Sms::SendSmsMessageOperation* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sms.SendSmsMessageOperation", L"Cancel", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Cancel();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SendSmsMessageOperation_Close(py::wrapper::Windows::Devices::Sms::SendSmsMessageOperation* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sms.SendSmsMessageOperation", L"Close", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SendSmsMessageOperation_GetResults(py::wrapper::Windows::Devices::Sms::SendSmsMessageOperation* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sms.SendSmsMessageOperation", L"GetResults", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.GetResults();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SendSmsMessageOperation_get_ErrorCode(py::wrapper::Windows::Devices::Sms::SendSmsMessageOperation* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SendSmsMessageOperation", L"ErrorCode"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ErrorCode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SendSmsMessageOperation_get_Id(py::wrapper::Windows::Devices::Sms::SendSmsMessageOperation* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SendSmsMessageOperation", L"Id"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SendSmsMessageOperation_get_Status(py::wrapper::Windows::Devices::Sms::SendSmsMessageOperation* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SendSmsMessageOperation", L"Status"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SendSmsMessageOperation_get_Completed(py::wrapper::Windows::Devices::Sms::SendSmsMessageOperation* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SendSmsMessageOperation", L"Completed"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Completed());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SendSmsMessageOperation_put_Completed(py::wrapper::Windows::Devices::Sms::SendSmsMessageOperation* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SendSmsMessageOperation", L"Completed"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::AsyncActionCompletedHandler>(arg);

            self->obj.Completed(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_SendSmsMessageOperation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Sms::SendSmsMessageOperation>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SendSmsMessageOperation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sms::SendSmsMessageOperation>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _await_SendSmsMessageOperation(py::wrapper::Windows::Devices::Sms::SendSmsMessageOperation* self) noexcept
    {
        return py::dunder_await(self->obj);
    }

    static PyMethodDef _methods_SendSmsMessageOperation[] = {
        { "cancel", reinterpret_cast<PyCFunction>(SendSmsMessageOperation_Cancel), METH_VARARGS, nullptr },
        { "close", reinterpret_cast<PyCFunction>(SendSmsMessageOperation_Close), METH_VARARGS, nullptr },
        { "get_results", reinterpret_cast<PyCFunction>(SendSmsMessageOperation_GetResults), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_SendSmsMessageOperation, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SendSmsMessageOperation), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SendSmsMessageOperation[] = {
        { "error_code", reinterpret_cast<getter>(SendSmsMessageOperation_get_ErrorCode), nullptr, nullptr, nullptr },
        { "id", reinterpret_cast<getter>(SendSmsMessageOperation_get_Id), nullptr, nullptr, nullptr },
        { "status", reinterpret_cast<getter>(SendSmsMessageOperation_get_Status), nullptr, nullptr, nullptr },
        { "completed", reinterpret_cast<getter>(SendSmsMessageOperation_get_Completed), reinterpret_cast<setter>(SendSmsMessageOperation_put_Completed), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SendSmsMessageOperation[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SendSmsMessageOperation) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SendSmsMessageOperation) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SendSmsMessageOperation) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SendSmsMessageOperation) },
        { Py_am_await, reinterpret_cast<void*>(_await_SendSmsMessageOperation) },
        { },
    };

    static PyType_Spec type_spec_SendSmsMessageOperation =
    {
        "winrt._winrt_windows_devices_sms.SendSmsMessageOperation",
        sizeof(py::wrapper::Windows::Devices::Sms::SendSmsMessageOperation),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SendSmsMessageOperation
    };

    // ----- SmsAppMessage class --------------------

    static PyObject* _new_SmsAppMessage(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Devices::Sms::SmsAppMessage instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_SmsAppMessage(py::wrapper::Windows::Devices::Sms::SmsAppMessage* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SmsAppMessage_get_ProtocolId(py::wrapper::Windows::Devices::Sms::SmsAppMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsAppMessage", L"ProtocolId"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ProtocolId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SmsAppMessage_put_ProtocolId(py::wrapper::Windows::Devices::Sms::SmsAppMessage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsAppMessage", L"ProtocolId"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.ProtocolId(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SmsAppMessage_get_PortNumber(py::wrapper::Windows::Devices::Sms::SmsAppMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsAppMessage", L"PortNumber"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PortNumber());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SmsAppMessage_put_PortNumber(py::wrapper::Windows::Devices::Sms::SmsAppMessage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsAppMessage", L"PortNumber"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.PortNumber(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SmsAppMessage_get_IsDeliveryNotificationEnabled(py::wrapper::Windows::Devices::Sms::SmsAppMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsAppMessage", L"IsDeliveryNotificationEnabled"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsDeliveryNotificationEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SmsAppMessage_put_IsDeliveryNotificationEnabled(py::wrapper::Windows::Devices::Sms::SmsAppMessage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsAppMessage", L"IsDeliveryNotificationEnabled"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsDeliveryNotificationEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SmsAppMessage_get_RetryAttemptCount(py::wrapper::Windows::Devices::Sms::SmsAppMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsAppMessage", L"RetryAttemptCount"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.RetryAttemptCount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SmsAppMessage_put_RetryAttemptCount(py::wrapper::Windows::Devices::Sms::SmsAppMessage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsAppMessage", L"RetryAttemptCount"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.RetryAttemptCount(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SmsAppMessage_get_Encoding(py::wrapper::Windows::Devices::Sms::SmsAppMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsAppMessage", L"Encoding"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Encoding());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SmsAppMessage_put_Encoding(py::wrapper::Windows::Devices::Sms::SmsAppMessage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsAppMessage", L"Encoding"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Devices::Sms::SmsEncoding>(arg);

            self->obj.Encoding(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SmsAppMessage_get_Body(py::wrapper::Windows::Devices::Sms::SmsAppMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsAppMessage", L"Body"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Body());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SmsAppMessage_put_Body(py::wrapper::Windows::Devices::Sms::SmsAppMessage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsAppMessage", L"Body"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Body(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SmsAppMessage_get_CallbackNumber(py::wrapper::Windows::Devices::Sms::SmsAppMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsAppMessage", L"CallbackNumber"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CallbackNumber());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SmsAppMessage_put_CallbackNumber(py::wrapper::Windows::Devices::Sms::SmsAppMessage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsAppMessage", L"CallbackNumber"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.CallbackNumber(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SmsAppMessage_get_BinaryBody(py::wrapper::Windows::Devices::Sms::SmsAppMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsAppMessage", L"BinaryBody"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.BinaryBody());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SmsAppMessage_put_BinaryBody(py::wrapper::Windows::Devices::Sms::SmsAppMessage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsAppMessage", L"BinaryBody"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(arg);

            self->obj.BinaryBody(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SmsAppMessage_get_To(py::wrapper::Windows::Devices::Sms::SmsAppMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsAppMessage", L"To"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.To());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SmsAppMessage_put_To(py::wrapper::Windows::Devices::Sms::SmsAppMessage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsAppMessage", L"To"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.To(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SmsAppMessage_get_TeleserviceId(py::wrapper::Windows::Devices::Sms::SmsAppMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsAppMessage", L"TeleserviceId"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.TeleserviceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SmsAppMessage_put_TeleserviceId(py::wrapper::Windows::Devices::Sms::SmsAppMessage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsAppMessage", L"TeleserviceId"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.TeleserviceId(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SmsAppMessage_get_From(py::wrapper::Windows::Devices::Sms::SmsAppMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsAppMessage", L"From"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.From());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsAppMessage_get_Timestamp(py::wrapper::Windows::Devices::Sms::SmsAppMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsAppMessage", L"Timestamp"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Timestamp());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsAppMessage_get_CellularClass(py::wrapper::Windows::Devices::Sms::SmsAppMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsAppMessage", L"CellularClass"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CellularClass());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsAppMessage_get_DeviceId(py::wrapper::Windows::Devices::Sms::SmsAppMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsAppMessage", L"DeviceId"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DeviceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsAppMessage_get_MessageClass(py::wrapper::Windows::Devices::Sms::SmsAppMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsAppMessage", L"MessageClass"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.MessageClass());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsAppMessage_get_MessageType(py::wrapper::Windows::Devices::Sms::SmsAppMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsAppMessage", L"MessageType"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.MessageType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsAppMessage_get_SimIccId(py::wrapper::Windows::Devices::Sms::SmsAppMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsAppMessage", L"SimIccId"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SimIccId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SmsAppMessage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Sms::SmsAppMessage>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SmsAppMessage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sms::SmsAppMessage>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SmsAppMessage[] = {
        { "_assign_array_", _assign_array_SmsAppMessage, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SmsAppMessage), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SmsAppMessage[] = {
        { "protocol_id", reinterpret_cast<getter>(SmsAppMessage_get_ProtocolId), reinterpret_cast<setter>(SmsAppMessage_put_ProtocolId), nullptr, nullptr },
        { "port_number", reinterpret_cast<getter>(SmsAppMessage_get_PortNumber), reinterpret_cast<setter>(SmsAppMessage_put_PortNumber), nullptr, nullptr },
        { "is_delivery_notification_enabled", reinterpret_cast<getter>(SmsAppMessage_get_IsDeliveryNotificationEnabled), reinterpret_cast<setter>(SmsAppMessage_put_IsDeliveryNotificationEnabled), nullptr, nullptr },
        { "retry_attempt_count", reinterpret_cast<getter>(SmsAppMessage_get_RetryAttemptCount), reinterpret_cast<setter>(SmsAppMessage_put_RetryAttemptCount), nullptr, nullptr },
        { "encoding", reinterpret_cast<getter>(SmsAppMessage_get_Encoding), reinterpret_cast<setter>(SmsAppMessage_put_Encoding), nullptr, nullptr },
        { "body", reinterpret_cast<getter>(SmsAppMessage_get_Body), reinterpret_cast<setter>(SmsAppMessage_put_Body), nullptr, nullptr },
        { "callback_number", reinterpret_cast<getter>(SmsAppMessage_get_CallbackNumber), reinterpret_cast<setter>(SmsAppMessage_put_CallbackNumber), nullptr, nullptr },
        { "binary_body", reinterpret_cast<getter>(SmsAppMessage_get_BinaryBody), reinterpret_cast<setter>(SmsAppMessage_put_BinaryBody), nullptr, nullptr },
        { "to", reinterpret_cast<getter>(SmsAppMessage_get_To), reinterpret_cast<setter>(SmsAppMessage_put_To), nullptr, nullptr },
        { "teleservice_id", reinterpret_cast<getter>(SmsAppMessage_get_TeleserviceId), reinterpret_cast<setter>(SmsAppMessage_put_TeleserviceId), nullptr, nullptr },
        { "from_", reinterpret_cast<getter>(SmsAppMessage_get_From), nullptr, nullptr, nullptr },
        { "timestamp", reinterpret_cast<getter>(SmsAppMessage_get_Timestamp), nullptr, nullptr, nullptr },
        { "cellular_class", reinterpret_cast<getter>(SmsAppMessage_get_CellularClass), nullptr, nullptr, nullptr },
        { "device_id", reinterpret_cast<getter>(SmsAppMessage_get_DeviceId), nullptr, nullptr, nullptr },
        { "message_class", reinterpret_cast<getter>(SmsAppMessage_get_MessageClass), nullptr, nullptr, nullptr },
        { "message_type", reinterpret_cast<getter>(SmsAppMessage_get_MessageType), nullptr, nullptr, nullptr },
        { "sim_icc_id", reinterpret_cast<getter>(SmsAppMessage_get_SimIccId), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SmsAppMessage[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SmsAppMessage) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SmsAppMessage) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SmsAppMessage) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SmsAppMessage) },
        { },
    };

    static PyType_Spec type_spec_SmsAppMessage =
    {
        "winrt._winrt_windows_devices_sms.SmsAppMessage",
        sizeof(py::wrapper::Windows::Devices::Sms::SmsAppMessage),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SmsAppMessage
    };

    // ----- SmsBinaryMessage class --------------------

    static PyObject* _new_SmsBinaryMessage(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Devices::Sms::SmsBinaryMessage instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_SmsBinaryMessage(py::wrapper::Windows::Devices::Sms::SmsBinaryMessage* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SmsBinaryMessage_GetData(py::wrapper::Windows::Devices::Sms::SmsBinaryMessage* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sms.SmsBinaryMessage", L"GetData", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetData());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SmsBinaryMessage_SetData(py::wrapper::Windows::Devices::Sms::SmsBinaryMessage* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sms.SmsBinaryMessage", L"SetData", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<py::pybuf_view<uint8_t, false>>(args, 0);

                self->obj.SetData(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SmsBinaryMessage_get_Format(py::wrapper::Windows::Devices::Sms::SmsBinaryMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsBinaryMessage", L"Format"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Format());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SmsBinaryMessage_put_Format(py::wrapper::Windows::Devices::Sms::SmsBinaryMessage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsBinaryMessage", L"Format"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Devices::Sms::SmsDataFormat>(arg);

            self->obj.Format(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SmsBinaryMessage_get_Id(py::wrapper::Windows::Devices::Sms::SmsBinaryMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsBinaryMessage", L"Id"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsBinaryMessage_get_MessageClass(py::wrapper::Windows::Devices::Sms::SmsBinaryMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsBinaryMessage", L"MessageClass"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.MessageClass());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SmsBinaryMessage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Sms::SmsBinaryMessage>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SmsBinaryMessage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sms::SmsBinaryMessage>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SmsBinaryMessage[] = {
        { "get_data", reinterpret_cast<PyCFunction>(SmsBinaryMessage_GetData), METH_VARARGS, nullptr },
        { "set_data", reinterpret_cast<PyCFunction>(SmsBinaryMessage_SetData), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_SmsBinaryMessage, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SmsBinaryMessage), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SmsBinaryMessage[] = {
        { "format", reinterpret_cast<getter>(SmsBinaryMessage_get_Format), reinterpret_cast<setter>(SmsBinaryMessage_put_Format), nullptr, nullptr },
        { "id", reinterpret_cast<getter>(SmsBinaryMessage_get_Id), nullptr, nullptr, nullptr },
        { "message_class", reinterpret_cast<getter>(SmsBinaryMessage_get_MessageClass), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SmsBinaryMessage[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SmsBinaryMessage) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SmsBinaryMessage) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SmsBinaryMessage) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SmsBinaryMessage) },
        { },
    };

    static PyType_Spec type_spec_SmsBinaryMessage =
    {
        "winrt._winrt_windows_devices_sms.SmsBinaryMessage",
        sizeof(py::wrapper::Windows::Devices::Sms::SmsBinaryMessage),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SmsBinaryMessage
    };

    // ----- SmsBroadcastMessage class --------------------

    static PyObject* _new_SmsBroadcastMessage(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Sms::SmsBroadcastMessage>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Sms::SmsBroadcastMessage>::type_name);
        return nullptr;
    }

    static void _dealloc_SmsBroadcastMessage(py::wrapper::Windows::Devices::Sms::SmsBroadcastMessage* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SmsBroadcastMessage_get_Body(py::wrapper::Windows::Devices::Sms::SmsBroadcastMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsBroadcastMessage", L"Body"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Body());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsBroadcastMessage_get_BroadcastType(py::wrapper::Windows::Devices::Sms::SmsBroadcastMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsBroadcastMessage", L"BroadcastType"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.BroadcastType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsBroadcastMessage_get_Channel(py::wrapper::Windows::Devices::Sms::SmsBroadcastMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsBroadcastMessage", L"Channel"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Channel());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsBroadcastMessage_get_GeographicalScope(py::wrapper::Windows::Devices::Sms::SmsBroadcastMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsBroadcastMessage", L"GeographicalScope"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.GeographicalScope());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsBroadcastMessage_get_IsEmergencyAlert(py::wrapper::Windows::Devices::Sms::SmsBroadcastMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsBroadcastMessage", L"IsEmergencyAlert"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsEmergencyAlert());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsBroadcastMessage_get_IsUserPopupRequested(py::wrapper::Windows::Devices::Sms::SmsBroadcastMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsBroadcastMessage", L"IsUserPopupRequested"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsUserPopupRequested());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsBroadcastMessage_get_MessageCode(py::wrapper::Windows::Devices::Sms::SmsBroadcastMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsBroadcastMessage", L"MessageCode"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.MessageCode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsBroadcastMessage_get_Timestamp(py::wrapper::Windows::Devices::Sms::SmsBroadcastMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsBroadcastMessage", L"Timestamp"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Timestamp());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsBroadcastMessage_get_To(py::wrapper::Windows::Devices::Sms::SmsBroadcastMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsBroadcastMessage", L"To"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.To());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsBroadcastMessage_get_UpdateNumber(py::wrapper::Windows::Devices::Sms::SmsBroadcastMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsBroadcastMessage", L"UpdateNumber"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.UpdateNumber());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsBroadcastMessage_get_CellularClass(py::wrapper::Windows::Devices::Sms::SmsBroadcastMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsBroadcastMessage", L"CellularClass"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CellularClass());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsBroadcastMessage_get_DeviceId(py::wrapper::Windows::Devices::Sms::SmsBroadcastMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsBroadcastMessage", L"DeviceId"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DeviceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsBroadcastMessage_get_MessageClass(py::wrapper::Windows::Devices::Sms::SmsBroadcastMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsBroadcastMessage", L"MessageClass"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.MessageClass());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsBroadcastMessage_get_MessageType(py::wrapper::Windows::Devices::Sms::SmsBroadcastMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsBroadcastMessage", L"MessageType"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.MessageType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsBroadcastMessage_get_SimIccId(py::wrapper::Windows::Devices::Sms::SmsBroadcastMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsBroadcastMessage", L"SimIccId"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SimIccId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SmsBroadcastMessage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Sms::SmsBroadcastMessage>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SmsBroadcastMessage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sms::SmsBroadcastMessage>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SmsBroadcastMessage[] = {
        { "_assign_array_", _assign_array_SmsBroadcastMessage, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SmsBroadcastMessage), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SmsBroadcastMessage[] = {
        { "body", reinterpret_cast<getter>(SmsBroadcastMessage_get_Body), nullptr, nullptr, nullptr },
        { "broadcast_type", reinterpret_cast<getter>(SmsBroadcastMessage_get_BroadcastType), nullptr, nullptr, nullptr },
        { "channel", reinterpret_cast<getter>(SmsBroadcastMessage_get_Channel), nullptr, nullptr, nullptr },
        { "geographical_scope", reinterpret_cast<getter>(SmsBroadcastMessage_get_GeographicalScope), nullptr, nullptr, nullptr },
        { "is_emergency_alert", reinterpret_cast<getter>(SmsBroadcastMessage_get_IsEmergencyAlert), nullptr, nullptr, nullptr },
        { "is_user_popup_requested", reinterpret_cast<getter>(SmsBroadcastMessage_get_IsUserPopupRequested), nullptr, nullptr, nullptr },
        { "message_code", reinterpret_cast<getter>(SmsBroadcastMessage_get_MessageCode), nullptr, nullptr, nullptr },
        { "timestamp", reinterpret_cast<getter>(SmsBroadcastMessage_get_Timestamp), nullptr, nullptr, nullptr },
        { "to", reinterpret_cast<getter>(SmsBroadcastMessage_get_To), nullptr, nullptr, nullptr },
        { "update_number", reinterpret_cast<getter>(SmsBroadcastMessage_get_UpdateNumber), nullptr, nullptr, nullptr },
        { "cellular_class", reinterpret_cast<getter>(SmsBroadcastMessage_get_CellularClass), nullptr, nullptr, nullptr },
        { "device_id", reinterpret_cast<getter>(SmsBroadcastMessage_get_DeviceId), nullptr, nullptr, nullptr },
        { "message_class", reinterpret_cast<getter>(SmsBroadcastMessage_get_MessageClass), nullptr, nullptr, nullptr },
        { "message_type", reinterpret_cast<getter>(SmsBroadcastMessage_get_MessageType), nullptr, nullptr, nullptr },
        { "sim_icc_id", reinterpret_cast<getter>(SmsBroadcastMessage_get_SimIccId), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SmsBroadcastMessage[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SmsBroadcastMessage) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SmsBroadcastMessage) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SmsBroadcastMessage) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SmsBroadcastMessage) },
        { },
    };

    static PyType_Spec type_spec_SmsBroadcastMessage =
    {
        "winrt._winrt_windows_devices_sms.SmsBroadcastMessage",
        sizeof(py::wrapper::Windows::Devices::Sms::SmsBroadcastMessage),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SmsBroadcastMessage
    };

    // ----- SmsDevice class --------------------

    static PyObject* _new_SmsDevice(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Sms::SmsDevice>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Sms::SmsDevice>::type_name);
        return nullptr;
    }

    static void _dealloc_SmsDevice(py::wrapper::Windows::Devices::Sms::SmsDevice* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SmsDevice_CalculateLength(py::wrapper::Windows::Devices::Sms::SmsDevice* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sms.SmsDevice", L"CalculateLength", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Devices::Sms::SmsTextMessage>(args, 0);

                return py::convert(self->obj.CalculateLength(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SmsDevice_FromIdAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sms.SmsDevice", L"FromIdAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Devices::Sms::SmsDevice::FromIdAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SmsDevice_FromNetworkAccountIdAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sms.SmsDevice", L"FromNetworkAccountIdAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Devices::Sms::SmsDevice::FromNetworkAccountIdAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SmsDevice_GetDefaultAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sms.SmsDevice", L"GetDefaultAsync", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(winrt::Windows::Devices::Sms::SmsDevice::GetDefaultAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SmsDevice_GetDeviceSelector(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sms.SmsDevice", L"GetDeviceSelector", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(winrt::Windows::Devices::Sms::SmsDevice::GetDeviceSelector());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SmsDevice_SendMessageAsync(py::wrapper::Windows::Devices::Sms::SmsDevice* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sms.SmsDevice", L"SendMessageAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Devices::Sms::ISmsMessage>(args, 0);

                return py::convert(self->obj.SendMessageAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SmsDevice_get_AccountPhoneNumber(py::wrapper::Windows::Devices::Sms::SmsDevice* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsDevice", L"AccountPhoneNumber"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.AccountPhoneNumber());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsDevice_get_CellularClass(py::wrapper::Windows::Devices::Sms::SmsDevice* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsDevice", L"CellularClass"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CellularClass());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsDevice_get_DeviceStatus(py::wrapper::Windows::Devices::Sms::SmsDevice* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsDevice", L"DeviceStatus"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DeviceStatus());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsDevice_get_MessageStore(py::wrapper::Windows::Devices::Sms::SmsDevice* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsDevice", L"MessageStore"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.MessageStore());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsDevice_add_SmsDeviceStatusChanged(py::wrapper::Windows::Devices::Sms::SmsDevice* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Sms.SmsDevice", L"SmsDeviceStatusChanged"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Devices::Sms::SmsDeviceStatusChangedEventHandler>(arg);

            return py::convert(self->obj.SmsDeviceStatusChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsDevice_remove_SmsDeviceStatusChanged(py::wrapper::Windows::Devices::Sms::SmsDevice* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Sms.SmsDevice", L"SmsDeviceStatusChanged"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.SmsDeviceStatusChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsDevice_add_SmsMessageReceived(py::wrapper::Windows::Devices::Sms::SmsDevice* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Sms.SmsDevice", L"SmsMessageReceived"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Devices::Sms::SmsMessageReceivedEventHandler>(arg);

            return py::convert(self->obj.SmsMessageReceived(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsDevice_remove_SmsMessageReceived(py::wrapper::Windows::Devices::Sms::SmsDevice* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Sms.SmsDevice", L"SmsMessageReceived"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.SmsMessageReceived(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SmsDevice(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Sms::SmsDevice>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SmsDevice(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sms::SmsDevice>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SmsDevice[] = {
        { "calculate_length", reinterpret_cast<PyCFunction>(SmsDevice_CalculateLength), METH_VARARGS, nullptr },
        { "send_message_async", reinterpret_cast<PyCFunction>(SmsDevice_SendMessageAsync), METH_VARARGS, nullptr },
        { "add_sms_device_status_changed", reinterpret_cast<PyCFunction>(SmsDevice_add_SmsDeviceStatusChanged), METH_O, nullptr },
        { "remove_sms_device_status_changed", reinterpret_cast<PyCFunction>(SmsDevice_remove_SmsDeviceStatusChanged), METH_O, nullptr },
        { "add_sms_message_received", reinterpret_cast<PyCFunction>(SmsDevice_add_SmsMessageReceived), METH_O, nullptr },
        { "remove_sms_message_received", reinterpret_cast<PyCFunction>(SmsDevice_remove_SmsMessageReceived), METH_O, nullptr },
        { "_assign_array_", _assign_array_SmsDevice, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SmsDevice), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SmsDevice[] = {
        { "account_phone_number", reinterpret_cast<getter>(SmsDevice_get_AccountPhoneNumber), nullptr, nullptr, nullptr },
        { "cellular_class", reinterpret_cast<getter>(SmsDevice_get_CellularClass), nullptr, nullptr, nullptr },
        { "device_status", reinterpret_cast<getter>(SmsDevice_get_DeviceStatus), nullptr, nullptr, nullptr },
        { "message_store", reinterpret_cast<getter>(SmsDevice_get_MessageStore), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SmsDevice[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SmsDevice) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SmsDevice) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SmsDevice) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SmsDevice) },
        { },
    };

    static PyType_Spec type_spec_SmsDevice =
    {
        "winrt._winrt_windows_devices_sms.SmsDevice",
        sizeof(py::wrapper::Windows::Devices::Sms::SmsDevice),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SmsDevice
    };

    static PyGetSetDef getset_SmsDevice_Static[] = {
        { }
    };

    static PyMethodDef methods_SmsDevice_Static[] = {
        { "from_id_async", reinterpret_cast<PyCFunction>(SmsDevice_FromIdAsync), METH_VARARGS, nullptr },
        { "from_network_account_id_async", reinterpret_cast<PyCFunction>(SmsDevice_FromNetworkAccountIdAsync), METH_VARARGS, nullptr },
        { "get_default_async", reinterpret_cast<PyCFunction>(SmsDevice_GetDefaultAsync), METH_VARARGS, nullptr },
        { "get_device_selector", reinterpret_cast<PyCFunction>(SmsDevice_GetDeviceSelector), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_SmsDevice_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_SmsDevice_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_SmsDevice_Static) },
        { }
    };

    static PyType_Spec type_spec_SmsDevice_Static =
    {
        "winrt._winrt_windows_devices_sms.SmsDevice_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_SmsDevice_Static
    };

    // ----- SmsDevice2 class --------------------

    static PyObject* _new_SmsDevice2(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Sms::SmsDevice2>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Sms::SmsDevice2>::type_name);
        return nullptr;
    }

    static void _dealloc_SmsDevice2(py::wrapper::Windows::Devices::Sms::SmsDevice2* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SmsDevice2_CalculateLength(py::wrapper::Windows::Devices::Sms::SmsDevice2* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sms.SmsDevice2", L"CalculateLength", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Devices::Sms::ISmsMessageBase>(args, 0);

                return py::convert(self->obj.CalculateLength(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SmsDevice2_FromId(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sms.SmsDevice2", L"FromId", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Devices::Sms::SmsDevice2::FromId(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SmsDevice2_FromParentId(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sms.SmsDevice2", L"FromParentId", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Devices::Sms::SmsDevice2::FromParentId(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SmsDevice2_GetDefault(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sms.SmsDevice2", L"GetDefault", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(winrt::Windows::Devices::Sms::SmsDevice2::GetDefault());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SmsDevice2_GetDeviceSelector(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sms.SmsDevice2", L"GetDeviceSelector", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(winrt::Windows::Devices::Sms::SmsDevice2::GetDeviceSelector());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SmsDevice2_SendMessageAndGetResultAsync(py::wrapper::Windows::Devices::Sms::SmsDevice2* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sms.SmsDevice2", L"SendMessageAndGetResultAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Devices::Sms::ISmsMessageBase>(args, 0);

                return py::convert(self->obj.SendMessageAndGetResultAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SmsDevice2_get_SmscAddress(py::wrapper::Windows::Devices::Sms::SmsDevice2* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsDevice2", L"SmscAddress"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SmscAddress());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SmsDevice2_put_SmscAddress(py::wrapper::Windows::Devices::Sms::SmsDevice2* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsDevice2", L"SmscAddress"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.SmscAddress(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SmsDevice2_get_AccountPhoneNumber(py::wrapper::Windows::Devices::Sms::SmsDevice2* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsDevice2", L"AccountPhoneNumber"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.AccountPhoneNumber());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsDevice2_get_CellularClass(py::wrapper::Windows::Devices::Sms::SmsDevice2* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsDevice2", L"CellularClass"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CellularClass());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsDevice2_get_DeviceId(py::wrapper::Windows::Devices::Sms::SmsDevice2* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsDevice2", L"DeviceId"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DeviceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsDevice2_get_DeviceStatus(py::wrapper::Windows::Devices::Sms::SmsDevice2* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsDevice2", L"DeviceStatus"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DeviceStatus());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsDevice2_get_ParentDeviceId(py::wrapper::Windows::Devices::Sms::SmsDevice2* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsDevice2", L"ParentDeviceId"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ParentDeviceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsDevice2_add_DeviceStatusChanged(py::wrapper::Windows::Devices::Sms::SmsDevice2* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Sms.SmsDevice2", L"DeviceStatusChanged"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Sms::SmsDevice2, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.DeviceStatusChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsDevice2_remove_DeviceStatusChanged(py::wrapper::Windows::Devices::Sms::SmsDevice2* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Sms.SmsDevice2", L"DeviceStatusChanged"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.DeviceStatusChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SmsDevice2(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Sms::SmsDevice2>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SmsDevice2(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sms::SmsDevice2>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SmsDevice2[] = {
        { "calculate_length", reinterpret_cast<PyCFunction>(SmsDevice2_CalculateLength), METH_VARARGS, nullptr },
        { "send_message_and_get_result_async", reinterpret_cast<PyCFunction>(SmsDevice2_SendMessageAndGetResultAsync), METH_VARARGS, nullptr },
        { "add_device_status_changed", reinterpret_cast<PyCFunction>(SmsDevice2_add_DeviceStatusChanged), METH_O, nullptr },
        { "remove_device_status_changed", reinterpret_cast<PyCFunction>(SmsDevice2_remove_DeviceStatusChanged), METH_O, nullptr },
        { "_assign_array_", _assign_array_SmsDevice2, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SmsDevice2), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SmsDevice2[] = {
        { "smsc_address", reinterpret_cast<getter>(SmsDevice2_get_SmscAddress), reinterpret_cast<setter>(SmsDevice2_put_SmscAddress), nullptr, nullptr },
        { "account_phone_number", reinterpret_cast<getter>(SmsDevice2_get_AccountPhoneNumber), nullptr, nullptr, nullptr },
        { "cellular_class", reinterpret_cast<getter>(SmsDevice2_get_CellularClass), nullptr, nullptr, nullptr },
        { "device_id", reinterpret_cast<getter>(SmsDevice2_get_DeviceId), nullptr, nullptr, nullptr },
        { "device_status", reinterpret_cast<getter>(SmsDevice2_get_DeviceStatus), nullptr, nullptr, nullptr },
        { "parent_device_id", reinterpret_cast<getter>(SmsDevice2_get_ParentDeviceId), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SmsDevice2[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SmsDevice2) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SmsDevice2) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SmsDevice2) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SmsDevice2) },
        { },
    };

    static PyType_Spec type_spec_SmsDevice2 =
    {
        "winrt._winrt_windows_devices_sms.SmsDevice2",
        sizeof(py::wrapper::Windows::Devices::Sms::SmsDevice2),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SmsDevice2
    };

    static PyGetSetDef getset_SmsDevice2_Static[] = {
        { }
    };

    static PyMethodDef methods_SmsDevice2_Static[] = {
        { "from_id", reinterpret_cast<PyCFunction>(SmsDevice2_FromId), METH_VARARGS, nullptr },
        { "from_parent_id", reinterpret_cast<PyCFunction>(SmsDevice2_FromParentId), METH_VARARGS, nullptr },
        { "get_default", reinterpret_cast<PyCFunction>(SmsDevice2_GetDefault), METH_VARARGS, nullptr },
        { "get_device_selector", reinterpret_cast<PyCFunction>(SmsDevice2_GetDeviceSelector), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_SmsDevice2_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_SmsDevice2_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_SmsDevice2_Static) },
        { }
    };

    static PyType_Spec type_spec_SmsDevice2_Static =
    {
        "winrt._winrt_windows_devices_sms.SmsDevice2_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_SmsDevice2_Static
    };

    // ----- SmsDeviceMessageStore class --------------------

    static PyObject* _new_SmsDeviceMessageStore(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Sms::SmsDeviceMessageStore>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Sms::SmsDeviceMessageStore>::type_name);
        return nullptr;
    }

    static void _dealloc_SmsDeviceMessageStore(py::wrapper::Windows::Devices::Sms::SmsDeviceMessageStore* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SmsDeviceMessageStore_DeleteMessageAsync(py::wrapper::Windows::Devices::Sms::SmsDeviceMessageStore* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sms.SmsDeviceMessageStore", L"DeleteMessageAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint32_t>(args, 0);

                return py::convert(self->obj.DeleteMessageAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SmsDeviceMessageStore_DeleteMessagesAsync(py::wrapper::Windows::Devices::Sms::SmsDeviceMessageStore* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sms.SmsDeviceMessageStore", L"DeleteMessagesAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Devices::Sms::SmsMessageFilter>(args, 0);

                return py::convert(self->obj.DeleteMessagesAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SmsDeviceMessageStore_GetMessageAsync(py::wrapper::Windows::Devices::Sms::SmsDeviceMessageStore* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sms.SmsDeviceMessageStore", L"GetMessageAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint32_t>(args, 0);

                return py::convert(self->obj.GetMessageAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SmsDeviceMessageStore_GetMessagesAsync(py::wrapper::Windows::Devices::Sms::SmsDeviceMessageStore* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sms.SmsDeviceMessageStore", L"GetMessagesAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Devices::Sms::SmsMessageFilter>(args, 0);

                return py::convert(self->obj.GetMessagesAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SmsDeviceMessageStore_get_MaxMessages(py::wrapper::Windows::Devices::Sms::SmsDeviceMessageStore* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsDeviceMessageStore", L"MaxMessages"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.MaxMessages());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SmsDeviceMessageStore(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Sms::SmsDeviceMessageStore>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SmsDeviceMessageStore(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sms::SmsDeviceMessageStore>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SmsDeviceMessageStore[] = {
        { "delete_message_async", reinterpret_cast<PyCFunction>(SmsDeviceMessageStore_DeleteMessageAsync), METH_VARARGS, nullptr },
        { "delete_messages_async", reinterpret_cast<PyCFunction>(SmsDeviceMessageStore_DeleteMessagesAsync), METH_VARARGS, nullptr },
        { "get_message_async", reinterpret_cast<PyCFunction>(SmsDeviceMessageStore_GetMessageAsync), METH_VARARGS, nullptr },
        { "get_messages_async", reinterpret_cast<PyCFunction>(SmsDeviceMessageStore_GetMessagesAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_SmsDeviceMessageStore, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SmsDeviceMessageStore), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SmsDeviceMessageStore[] = {
        { "max_messages", reinterpret_cast<getter>(SmsDeviceMessageStore_get_MaxMessages), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SmsDeviceMessageStore[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SmsDeviceMessageStore) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SmsDeviceMessageStore) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SmsDeviceMessageStore) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SmsDeviceMessageStore) },
        { },
    };

    static PyType_Spec type_spec_SmsDeviceMessageStore =
    {
        "winrt._winrt_windows_devices_sms.SmsDeviceMessageStore",
        sizeof(py::wrapper::Windows::Devices::Sms::SmsDeviceMessageStore),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SmsDeviceMessageStore
    };

    // ----- SmsFilterRule class --------------------

    static PyObject* _new_SmsFilterRule(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Sms::SmsMessageType>(args, 0);

                winrt::Windows::Devices::Sms::SmsFilterRule instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_SmsFilterRule(py::wrapper::Windows::Devices::Sms::SmsFilterRule* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SmsFilterRule_get_CellularClass(py::wrapper::Windows::Devices::Sms::SmsFilterRule* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsFilterRule", L"CellularClass"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CellularClass());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SmsFilterRule_put_CellularClass(py::wrapper::Windows::Devices::Sms::SmsFilterRule* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsFilterRule", L"CellularClass"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Devices::Sms::CellularClass>(arg);

            self->obj.CellularClass(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SmsFilterRule_get_BroadcastChannels(py::wrapper::Windows::Devices::Sms::SmsFilterRule* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsFilterRule", L"BroadcastChannels"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.BroadcastChannels());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsFilterRule_get_BroadcastTypes(py::wrapper::Windows::Devices::Sms::SmsFilterRule* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsFilterRule", L"BroadcastTypes"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.BroadcastTypes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsFilterRule_get_DeviceIds(py::wrapper::Windows::Devices::Sms::SmsFilterRule* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsFilterRule", L"DeviceIds"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DeviceIds());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsFilterRule_get_ImsiPrefixes(py::wrapper::Windows::Devices::Sms::SmsFilterRule* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsFilterRule", L"ImsiPrefixes"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ImsiPrefixes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsFilterRule_get_MessageType(py::wrapper::Windows::Devices::Sms::SmsFilterRule* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsFilterRule", L"MessageType"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.MessageType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsFilterRule_get_PortNumbers(py::wrapper::Windows::Devices::Sms::SmsFilterRule* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsFilterRule", L"PortNumbers"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PortNumbers());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsFilterRule_get_ProtocolIds(py::wrapper::Windows::Devices::Sms::SmsFilterRule* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsFilterRule", L"ProtocolIds"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ProtocolIds());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsFilterRule_get_SenderNumbers(py::wrapper::Windows::Devices::Sms::SmsFilterRule* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsFilterRule", L"SenderNumbers"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SenderNumbers());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsFilterRule_get_TeleserviceIds(py::wrapper::Windows::Devices::Sms::SmsFilterRule* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsFilterRule", L"TeleserviceIds"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.TeleserviceIds());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsFilterRule_get_TextMessagePrefixes(py::wrapper::Windows::Devices::Sms::SmsFilterRule* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsFilterRule", L"TextMessagePrefixes"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.TextMessagePrefixes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsFilterRule_get_WapApplicationIds(py::wrapper::Windows::Devices::Sms::SmsFilterRule* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsFilterRule", L"WapApplicationIds"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.WapApplicationIds());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsFilterRule_get_WapContentTypes(py::wrapper::Windows::Devices::Sms::SmsFilterRule* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsFilterRule", L"WapContentTypes"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.WapContentTypes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SmsFilterRule(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Sms::SmsFilterRule>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SmsFilterRule(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sms::SmsFilterRule>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SmsFilterRule[] = {
        { "_assign_array_", _assign_array_SmsFilterRule, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SmsFilterRule), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SmsFilterRule[] = {
        { "cellular_class", reinterpret_cast<getter>(SmsFilterRule_get_CellularClass), reinterpret_cast<setter>(SmsFilterRule_put_CellularClass), nullptr, nullptr },
        { "broadcast_channels", reinterpret_cast<getter>(SmsFilterRule_get_BroadcastChannels), nullptr, nullptr, nullptr },
        { "broadcast_types", reinterpret_cast<getter>(SmsFilterRule_get_BroadcastTypes), nullptr, nullptr, nullptr },
        { "device_ids", reinterpret_cast<getter>(SmsFilterRule_get_DeviceIds), nullptr, nullptr, nullptr },
        { "imsi_prefixes", reinterpret_cast<getter>(SmsFilterRule_get_ImsiPrefixes), nullptr, nullptr, nullptr },
        { "message_type", reinterpret_cast<getter>(SmsFilterRule_get_MessageType), nullptr, nullptr, nullptr },
        { "port_numbers", reinterpret_cast<getter>(SmsFilterRule_get_PortNumbers), nullptr, nullptr, nullptr },
        { "protocol_ids", reinterpret_cast<getter>(SmsFilterRule_get_ProtocolIds), nullptr, nullptr, nullptr },
        { "sender_numbers", reinterpret_cast<getter>(SmsFilterRule_get_SenderNumbers), nullptr, nullptr, nullptr },
        { "teleservice_ids", reinterpret_cast<getter>(SmsFilterRule_get_TeleserviceIds), nullptr, nullptr, nullptr },
        { "text_message_prefixes", reinterpret_cast<getter>(SmsFilterRule_get_TextMessagePrefixes), nullptr, nullptr, nullptr },
        { "wap_application_ids", reinterpret_cast<getter>(SmsFilterRule_get_WapApplicationIds), nullptr, nullptr, nullptr },
        { "wap_content_types", reinterpret_cast<getter>(SmsFilterRule_get_WapContentTypes), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SmsFilterRule[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SmsFilterRule) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SmsFilterRule) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SmsFilterRule) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SmsFilterRule) },
        { },
    };

    static PyType_Spec type_spec_SmsFilterRule =
    {
        "winrt._winrt_windows_devices_sms.SmsFilterRule",
        sizeof(py::wrapper::Windows::Devices::Sms::SmsFilterRule),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SmsFilterRule
    };

    // ----- SmsFilterRules class --------------------

    static PyObject* _new_SmsFilterRules(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Sms::SmsFilterActionType>(args, 0);

                winrt::Windows::Devices::Sms::SmsFilterRules instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_SmsFilterRules(py::wrapper::Windows::Devices::Sms::SmsFilterRules* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SmsFilterRules_get_ActionType(py::wrapper::Windows::Devices::Sms::SmsFilterRules* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsFilterRules", L"ActionType"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ActionType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsFilterRules_get_Rules(py::wrapper::Windows::Devices::Sms::SmsFilterRules* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsFilterRules", L"Rules"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Rules());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SmsFilterRules(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Sms::SmsFilterRules>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SmsFilterRules(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sms::SmsFilterRules>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SmsFilterRules[] = {
        { "_assign_array_", _assign_array_SmsFilterRules, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SmsFilterRules), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SmsFilterRules[] = {
        { "action_type", reinterpret_cast<getter>(SmsFilterRules_get_ActionType), nullptr, nullptr, nullptr },
        { "rules", reinterpret_cast<getter>(SmsFilterRules_get_Rules), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SmsFilterRules[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SmsFilterRules) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SmsFilterRules) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SmsFilterRules) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SmsFilterRules) },
        { },
    };

    static PyType_Spec type_spec_SmsFilterRules =
    {
        "winrt._winrt_windows_devices_sms.SmsFilterRules",
        sizeof(py::wrapper::Windows::Devices::Sms::SmsFilterRules),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SmsFilterRules
    };

    // ----- SmsMessageReceivedEventArgs class --------------------

    static PyObject* _new_SmsMessageReceivedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Sms::SmsMessageReceivedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Sms::SmsMessageReceivedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_SmsMessageReceivedEventArgs(py::wrapper::Windows::Devices::Sms::SmsMessageReceivedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SmsMessageReceivedEventArgs_get_BinaryMessage(py::wrapper::Windows::Devices::Sms::SmsMessageReceivedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsMessageReceivedEventArgs", L"BinaryMessage"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.BinaryMessage());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsMessageReceivedEventArgs_get_TextMessage(py::wrapper::Windows::Devices::Sms::SmsMessageReceivedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsMessageReceivedEventArgs", L"TextMessage"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.TextMessage());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SmsMessageReceivedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Sms::SmsMessageReceivedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SmsMessageReceivedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sms::SmsMessageReceivedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SmsMessageReceivedEventArgs[] = {
        { "_assign_array_", _assign_array_SmsMessageReceivedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SmsMessageReceivedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SmsMessageReceivedEventArgs[] = {
        { "binary_message", reinterpret_cast<getter>(SmsMessageReceivedEventArgs_get_BinaryMessage), nullptr, nullptr, nullptr },
        { "text_message", reinterpret_cast<getter>(SmsMessageReceivedEventArgs_get_TextMessage), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SmsMessageReceivedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SmsMessageReceivedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SmsMessageReceivedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SmsMessageReceivedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SmsMessageReceivedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_SmsMessageReceivedEventArgs =
    {
        "winrt._winrt_windows_devices_sms.SmsMessageReceivedEventArgs",
        sizeof(py::wrapper::Windows::Devices::Sms::SmsMessageReceivedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SmsMessageReceivedEventArgs
    };

    // ----- SmsMessageReceivedTriggerDetails class --------------------

    static PyObject* _new_SmsMessageReceivedTriggerDetails(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Sms::SmsMessageReceivedTriggerDetails>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Sms::SmsMessageReceivedTriggerDetails>::type_name);
        return nullptr;
    }

    static void _dealloc_SmsMessageReceivedTriggerDetails(py::wrapper::Windows::Devices::Sms::SmsMessageReceivedTriggerDetails* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SmsMessageReceivedTriggerDetails_Accept(py::wrapper::Windows::Devices::Sms::SmsMessageReceivedTriggerDetails* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sms.SmsMessageReceivedTriggerDetails", L"Accept", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Accept();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SmsMessageReceivedTriggerDetails_Drop(py::wrapper::Windows::Devices::Sms::SmsMessageReceivedTriggerDetails* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sms.SmsMessageReceivedTriggerDetails", L"Drop", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Drop();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SmsMessageReceivedTriggerDetails_get_AppMessage(py::wrapper::Windows::Devices::Sms::SmsMessageReceivedTriggerDetails* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsMessageReceivedTriggerDetails", L"AppMessage"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.AppMessage());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsMessageReceivedTriggerDetails_get_BroadcastMessage(py::wrapper::Windows::Devices::Sms::SmsMessageReceivedTriggerDetails* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsMessageReceivedTriggerDetails", L"BroadcastMessage"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.BroadcastMessage());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsMessageReceivedTriggerDetails_get_MessageType(py::wrapper::Windows::Devices::Sms::SmsMessageReceivedTriggerDetails* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsMessageReceivedTriggerDetails", L"MessageType"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.MessageType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsMessageReceivedTriggerDetails_get_StatusMessage(py::wrapper::Windows::Devices::Sms::SmsMessageReceivedTriggerDetails* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsMessageReceivedTriggerDetails", L"StatusMessage"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.StatusMessage());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsMessageReceivedTriggerDetails_get_TextMessage(py::wrapper::Windows::Devices::Sms::SmsMessageReceivedTriggerDetails* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsMessageReceivedTriggerDetails", L"TextMessage"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.TextMessage());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsMessageReceivedTriggerDetails_get_VoicemailMessage(py::wrapper::Windows::Devices::Sms::SmsMessageReceivedTriggerDetails* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsMessageReceivedTriggerDetails", L"VoicemailMessage"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.VoicemailMessage());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsMessageReceivedTriggerDetails_get_WapMessage(py::wrapper::Windows::Devices::Sms::SmsMessageReceivedTriggerDetails* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsMessageReceivedTriggerDetails", L"WapMessage"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.WapMessage());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SmsMessageReceivedTriggerDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Sms::SmsMessageReceivedTriggerDetails>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SmsMessageReceivedTriggerDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sms::SmsMessageReceivedTriggerDetails>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SmsMessageReceivedTriggerDetails[] = {
        { "accept", reinterpret_cast<PyCFunction>(SmsMessageReceivedTriggerDetails_Accept), METH_VARARGS, nullptr },
        { "drop", reinterpret_cast<PyCFunction>(SmsMessageReceivedTriggerDetails_Drop), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_SmsMessageReceivedTriggerDetails, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SmsMessageReceivedTriggerDetails), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SmsMessageReceivedTriggerDetails[] = {
        { "app_message", reinterpret_cast<getter>(SmsMessageReceivedTriggerDetails_get_AppMessage), nullptr, nullptr, nullptr },
        { "broadcast_message", reinterpret_cast<getter>(SmsMessageReceivedTriggerDetails_get_BroadcastMessage), nullptr, nullptr, nullptr },
        { "message_type", reinterpret_cast<getter>(SmsMessageReceivedTriggerDetails_get_MessageType), nullptr, nullptr, nullptr },
        { "status_message", reinterpret_cast<getter>(SmsMessageReceivedTriggerDetails_get_StatusMessage), nullptr, nullptr, nullptr },
        { "text_message", reinterpret_cast<getter>(SmsMessageReceivedTriggerDetails_get_TextMessage), nullptr, nullptr, nullptr },
        { "voicemail_message", reinterpret_cast<getter>(SmsMessageReceivedTriggerDetails_get_VoicemailMessage), nullptr, nullptr, nullptr },
        { "wap_message", reinterpret_cast<getter>(SmsMessageReceivedTriggerDetails_get_WapMessage), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SmsMessageReceivedTriggerDetails[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SmsMessageReceivedTriggerDetails) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SmsMessageReceivedTriggerDetails) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SmsMessageReceivedTriggerDetails) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SmsMessageReceivedTriggerDetails) },
        { },
    };

    static PyType_Spec type_spec_SmsMessageReceivedTriggerDetails =
    {
        "winrt._winrt_windows_devices_sms.SmsMessageReceivedTriggerDetails",
        sizeof(py::wrapper::Windows::Devices::Sms::SmsMessageReceivedTriggerDetails),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SmsMessageReceivedTriggerDetails
    };

    // ----- SmsMessageRegistration class --------------------

    static PyObject* _new_SmsMessageRegistration(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Sms::SmsMessageRegistration>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Sms::SmsMessageRegistration>::type_name);
        return nullptr;
    }

    static void _dealloc_SmsMessageRegistration(py::wrapper::Windows::Devices::Sms::SmsMessageRegistration* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SmsMessageRegistration_Register(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sms.SmsMessageRegistration", L"Register", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Devices::Sms::SmsFilterRules>(args, 1);

                return py::convert(winrt::Windows::Devices::Sms::SmsMessageRegistration::Register(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SmsMessageRegistration_Unregister(py::wrapper::Windows::Devices::Sms::SmsMessageRegistration* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sms.SmsMessageRegistration", L"Unregister", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Unregister();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SmsMessageRegistration_get_Id(py::wrapper::Windows::Devices::Sms::SmsMessageRegistration* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsMessageRegistration", L"Id"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsMessageRegistration_get_AllRegistrations(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsMessageRegistration", L"AllRegistrations"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::Sms::SmsMessageRegistration::AllRegistrations());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsMessageRegistration_add_MessageReceived(py::wrapper::Windows::Devices::Sms::SmsMessageRegistration* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Sms.SmsMessageRegistration", L"MessageReceived"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Sms::SmsMessageRegistration, winrt::Windows::Devices::Sms::SmsMessageReceivedTriggerDetails>>(arg);

            return py::convert(self->obj.MessageReceived(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsMessageRegistration_remove_MessageReceived(py::wrapper::Windows::Devices::Sms::SmsMessageRegistration* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Sms.SmsMessageRegistration", L"MessageReceived"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.MessageReceived(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SmsMessageRegistration(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Sms::SmsMessageRegistration>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SmsMessageRegistration(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sms::SmsMessageRegistration>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SmsMessageRegistration[] = {
        { "unregister", reinterpret_cast<PyCFunction>(SmsMessageRegistration_Unregister), METH_VARARGS, nullptr },
        { "add_message_received", reinterpret_cast<PyCFunction>(SmsMessageRegistration_add_MessageReceived), METH_O, nullptr },
        { "remove_message_received", reinterpret_cast<PyCFunction>(SmsMessageRegistration_remove_MessageReceived), METH_O, nullptr },
        { "_assign_array_", _assign_array_SmsMessageRegistration, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SmsMessageRegistration), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SmsMessageRegistration[] = {
        { "id", reinterpret_cast<getter>(SmsMessageRegistration_get_Id), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SmsMessageRegistration[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SmsMessageRegistration) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SmsMessageRegistration) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SmsMessageRegistration) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SmsMessageRegistration) },
        { },
    };

    static PyType_Spec type_spec_SmsMessageRegistration =
    {
        "winrt._winrt_windows_devices_sms.SmsMessageRegistration",
        sizeof(py::wrapper::Windows::Devices::Sms::SmsMessageRegistration),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SmsMessageRegistration
    };

    static PyGetSetDef getset_SmsMessageRegistration_Static[] = {
        { "all_registrations", reinterpret_cast<getter>(SmsMessageRegistration_get_AllRegistrations), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_SmsMessageRegistration_Static[] = {
        { "register", reinterpret_cast<PyCFunction>(SmsMessageRegistration_Register), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_SmsMessageRegistration_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_SmsMessageRegistration_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_SmsMessageRegistration_Static) },
        { }
    };

    static PyType_Spec type_spec_SmsMessageRegistration_Static =
    {
        "winrt._winrt_windows_devices_sms.SmsMessageRegistration_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_SmsMessageRegistration_Static
    };

    // ----- SmsReceivedEventDetails class --------------------

    static PyObject* _new_SmsReceivedEventDetails(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Sms::SmsReceivedEventDetails>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Sms::SmsReceivedEventDetails>::type_name);
        return nullptr;
    }

    static void _dealloc_SmsReceivedEventDetails(py::wrapper::Windows::Devices::Sms::SmsReceivedEventDetails* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SmsReceivedEventDetails_get_DeviceId(py::wrapper::Windows::Devices::Sms::SmsReceivedEventDetails* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsReceivedEventDetails", L"DeviceId"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DeviceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsReceivedEventDetails_get_MessageIndex(py::wrapper::Windows::Devices::Sms::SmsReceivedEventDetails* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsReceivedEventDetails", L"MessageIndex"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.MessageIndex());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsReceivedEventDetails_get_BinaryMessage(py::wrapper::Windows::Devices::Sms::SmsReceivedEventDetails* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsReceivedEventDetails", L"BinaryMessage"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.BinaryMessage());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsReceivedEventDetails_get_MessageClass(py::wrapper::Windows::Devices::Sms::SmsReceivedEventDetails* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsReceivedEventDetails", L"MessageClass"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.MessageClass());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SmsReceivedEventDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Sms::SmsReceivedEventDetails>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SmsReceivedEventDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sms::SmsReceivedEventDetails>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SmsReceivedEventDetails[] = {
        { "_assign_array_", _assign_array_SmsReceivedEventDetails, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SmsReceivedEventDetails), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SmsReceivedEventDetails[] = {
        { "device_id", reinterpret_cast<getter>(SmsReceivedEventDetails_get_DeviceId), nullptr, nullptr, nullptr },
        { "message_index", reinterpret_cast<getter>(SmsReceivedEventDetails_get_MessageIndex), nullptr, nullptr, nullptr },
        { "binary_message", reinterpret_cast<getter>(SmsReceivedEventDetails_get_BinaryMessage), nullptr, nullptr, nullptr },
        { "message_class", reinterpret_cast<getter>(SmsReceivedEventDetails_get_MessageClass), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SmsReceivedEventDetails[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SmsReceivedEventDetails) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SmsReceivedEventDetails) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SmsReceivedEventDetails) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SmsReceivedEventDetails) },
        { },
    };

    static PyType_Spec type_spec_SmsReceivedEventDetails =
    {
        "winrt._winrt_windows_devices_sms.SmsReceivedEventDetails",
        sizeof(py::wrapper::Windows::Devices::Sms::SmsReceivedEventDetails),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SmsReceivedEventDetails
    };

    // ----- SmsSendMessageResult class --------------------

    static PyObject* _new_SmsSendMessageResult(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Sms::SmsSendMessageResult>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Sms::SmsSendMessageResult>::type_name);
        return nullptr;
    }

    static void _dealloc_SmsSendMessageResult(py::wrapper::Windows::Devices::Sms::SmsSendMessageResult* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SmsSendMessageResult_get_CellularClass(py::wrapper::Windows::Devices::Sms::SmsSendMessageResult* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsSendMessageResult", L"CellularClass"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CellularClass());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsSendMessageResult_get_IsErrorTransient(py::wrapper::Windows::Devices::Sms::SmsSendMessageResult* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsSendMessageResult", L"IsErrorTransient"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsErrorTransient());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsSendMessageResult_get_IsSuccessful(py::wrapper::Windows::Devices::Sms::SmsSendMessageResult* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsSendMessageResult", L"IsSuccessful"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsSuccessful());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsSendMessageResult_get_MessageReferenceNumbers(py::wrapper::Windows::Devices::Sms::SmsSendMessageResult* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsSendMessageResult", L"MessageReferenceNumbers"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.MessageReferenceNumbers());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsSendMessageResult_get_ModemErrorCode(py::wrapper::Windows::Devices::Sms::SmsSendMessageResult* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsSendMessageResult", L"ModemErrorCode"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ModemErrorCode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsSendMessageResult_get_NetworkCauseCode(py::wrapper::Windows::Devices::Sms::SmsSendMessageResult* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsSendMessageResult", L"NetworkCauseCode"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.NetworkCauseCode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsSendMessageResult_get_TransportFailureCause(py::wrapper::Windows::Devices::Sms::SmsSendMessageResult* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsSendMessageResult", L"TransportFailureCause"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.TransportFailureCause());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SmsSendMessageResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Sms::SmsSendMessageResult>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SmsSendMessageResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sms::SmsSendMessageResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SmsSendMessageResult[] = {
        { "_assign_array_", _assign_array_SmsSendMessageResult, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SmsSendMessageResult), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SmsSendMessageResult[] = {
        { "cellular_class", reinterpret_cast<getter>(SmsSendMessageResult_get_CellularClass), nullptr, nullptr, nullptr },
        { "is_error_transient", reinterpret_cast<getter>(SmsSendMessageResult_get_IsErrorTransient), nullptr, nullptr, nullptr },
        { "is_successful", reinterpret_cast<getter>(SmsSendMessageResult_get_IsSuccessful), nullptr, nullptr, nullptr },
        { "message_reference_numbers", reinterpret_cast<getter>(SmsSendMessageResult_get_MessageReferenceNumbers), nullptr, nullptr, nullptr },
        { "modem_error_code", reinterpret_cast<getter>(SmsSendMessageResult_get_ModemErrorCode), nullptr, nullptr, nullptr },
        { "network_cause_code", reinterpret_cast<getter>(SmsSendMessageResult_get_NetworkCauseCode), nullptr, nullptr, nullptr },
        { "transport_failure_cause", reinterpret_cast<getter>(SmsSendMessageResult_get_TransportFailureCause), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SmsSendMessageResult[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SmsSendMessageResult) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SmsSendMessageResult) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SmsSendMessageResult) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SmsSendMessageResult) },
        { },
    };

    static PyType_Spec type_spec_SmsSendMessageResult =
    {
        "winrt._winrt_windows_devices_sms.SmsSendMessageResult",
        sizeof(py::wrapper::Windows::Devices::Sms::SmsSendMessageResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SmsSendMessageResult
    };

    // ----- SmsStatusMessage class --------------------

    static PyObject* _new_SmsStatusMessage(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Sms::SmsStatusMessage>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Sms::SmsStatusMessage>::type_name);
        return nullptr;
    }

    static void _dealloc_SmsStatusMessage(py::wrapper::Windows::Devices::Sms::SmsStatusMessage* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SmsStatusMessage_get_CellularClass(py::wrapper::Windows::Devices::Sms::SmsStatusMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsStatusMessage", L"CellularClass"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CellularClass());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsStatusMessage_get_DeviceId(py::wrapper::Windows::Devices::Sms::SmsStatusMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsStatusMessage", L"DeviceId"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DeviceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsStatusMessage_get_MessageClass(py::wrapper::Windows::Devices::Sms::SmsStatusMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsStatusMessage", L"MessageClass"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.MessageClass());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsStatusMessage_get_MessageType(py::wrapper::Windows::Devices::Sms::SmsStatusMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsStatusMessage", L"MessageType"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.MessageType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsStatusMessage_get_SimIccId(py::wrapper::Windows::Devices::Sms::SmsStatusMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsStatusMessage", L"SimIccId"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SimIccId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsStatusMessage_get_Status(py::wrapper::Windows::Devices::Sms::SmsStatusMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsStatusMessage", L"Status"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsStatusMessage_get_Body(py::wrapper::Windows::Devices::Sms::SmsStatusMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsStatusMessage", L"Body"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Body());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsStatusMessage_get_DischargeTime(py::wrapper::Windows::Devices::Sms::SmsStatusMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsStatusMessage", L"DischargeTime"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DischargeTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsStatusMessage_get_From(py::wrapper::Windows::Devices::Sms::SmsStatusMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsStatusMessage", L"From"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.From());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsStatusMessage_get_MessageReferenceNumber(py::wrapper::Windows::Devices::Sms::SmsStatusMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsStatusMessage", L"MessageReferenceNumber"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.MessageReferenceNumber());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsStatusMessage_get_ServiceCenterTimestamp(py::wrapper::Windows::Devices::Sms::SmsStatusMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsStatusMessage", L"ServiceCenterTimestamp"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ServiceCenterTimestamp());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsStatusMessage_get_To(py::wrapper::Windows::Devices::Sms::SmsStatusMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsStatusMessage", L"To"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.To());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SmsStatusMessage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Sms::SmsStatusMessage>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SmsStatusMessage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sms::SmsStatusMessage>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SmsStatusMessage[] = {
        { "_assign_array_", _assign_array_SmsStatusMessage, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SmsStatusMessage), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SmsStatusMessage[] = {
        { "cellular_class", reinterpret_cast<getter>(SmsStatusMessage_get_CellularClass), nullptr, nullptr, nullptr },
        { "device_id", reinterpret_cast<getter>(SmsStatusMessage_get_DeviceId), nullptr, nullptr, nullptr },
        { "message_class", reinterpret_cast<getter>(SmsStatusMessage_get_MessageClass), nullptr, nullptr, nullptr },
        { "message_type", reinterpret_cast<getter>(SmsStatusMessage_get_MessageType), nullptr, nullptr, nullptr },
        { "sim_icc_id", reinterpret_cast<getter>(SmsStatusMessage_get_SimIccId), nullptr, nullptr, nullptr },
        { "status", reinterpret_cast<getter>(SmsStatusMessage_get_Status), nullptr, nullptr, nullptr },
        { "body", reinterpret_cast<getter>(SmsStatusMessage_get_Body), nullptr, nullptr, nullptr },
        { "discharge_time", reinterpret_cast<getter>(SmsStatusMessage_get_DischargeTime), nullptr, nullptr, nullptr },
        { "from_", reinterpret_cast<getter>(SmsStatusMessage_get_From), nullptr, nullptr, nullptr },
        { "message_reference_number", reinterpret_cast<getter>(SmsStatusMessage_get_MessageReferenceNumber), nullptr, nullptr, nullptr },
        { "service_center_timestamp", reinterpret_cast<getter>(SmsStatusMessage_get_ServiceCenterTimestamp), nullptr, nullptr, nullptr },
        { "to", reinterpret_cast<getter>(SmsStatusMessage_get_To), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SmsStatusMessage[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SmsStatusMessage) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SmsStatusMessage) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SmsStatusMessage) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SmsStatusMessage) },
        { },
    };

    static PyType_Spec type_spec_SmsStatusMessage =
    {
        "winrt._winrt_windows_devices_sms.SmsStatusMessage",
        sizeof(py::wrapper::Windows::Devices::Sms::SmsStatusMessage),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SmsStatusMessage
    };

    // ----- SmsTextMessage class --------------------

    static PyObject* _new_SmsTextMessage(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Devices::Sms::SmsTextMessage instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_SmsTextMessage(py::wrapper::Windows::Devices::Sms::SmsTextMessage* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SmsTextMessage_FromBinaryData(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sms.SmsTextMessage", L"FromBinaryData", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Devices::Sms::SmsDataFormat>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<uint8_t, false>>(args, 1);

                return py::convert(winrt::Windows::Devices::Sms::SmsTextMessage::FromBinaryData(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SmsTextMessage_FromBinaryMessage(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sms.SmsTextMessage", L"FromBinaryMessage", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Devices::Sms::SmsBinaryMessage>(args, 0);

                return py::convert(winrt::Windows::Devices::Sms::SmsTextMessage::FromBinaryMessage(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SmsTextMessage_ToBinaryMessages(py::wrapper::Windows::Devices::Sms::SmsTextMessage* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sms.SmsTextMessage", L"ToBinaryMessages", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Devices::Sms::SmsDataFormat>(args, 0);

                return py::convert(self->obj.ToBinaryMessages(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SmsTextMessage_get_Id(py::wrapper::Windows::Devices::Sms::SmsTextMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsTextMessage", L"Id"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsTextMessage_get_MessageClass(py::wrapper::Windows::Devices::Sms::SmsTextMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsTextMessage", L"MessageClass"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.MessageClass());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsTextMessage_get_To(py::wrapper::Windows::Devices::Sms::SmsTextMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsTextMessage", L"To"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.To());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SmsTextMessage_put_To(py::wrapper::Windows::Devices::Sms::SmsTextMessage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsTextMessage", L"To"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.To(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SmsTextMessage_get_From(py::wrapper::Windows::Devices::Sms::SmsTextMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsTextMessage", L"From"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.From());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SmsTextMessage_put_From(py::wrapper::Windows::Devices::Sms::SmsTextMessage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsTextMessage", L"From"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.From(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SmsTextMessage_get_Encoding(py::wrapper::Windows::Devices::Sms::SmsTextMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsTextMessage", L"Encoding"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Encoding());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SmsTextMessage_put_Encoding(py::wrapper::Windows::Devices::Sms::SmsTextMessage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsTextMessage", L"Encoding"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Devices::Sms::SmsEncoding>(arg);

            self->obj.Encoding(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SmsTextMessage_get_Body(py::wrapper::Windows::Devices::Sms::SmsTextMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsTextMessage", L"Body"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Body());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SmsTextMessage_put_Body(py::wrapper::Windows::Devices::Sms::SmsTextMessage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsTextMessage", L"Body"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Body(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SmsTextMessage_get_PartCount(py::wrapper::Windows::Devices::Sms::SmsTextMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsTextMessage", L"PartCount"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PartCount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsTextMessage_get_PartNumber(py::wrapper::Windows::Devices::Sms::SmsTextMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsTextMessage", L"PartNumber"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PartNumber());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsTextMessage_get_PartReferenceId(py::wrapper::Windows::Devices::Sms::SmsTextMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsTextMessage", L"PartReferenceId"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PartReferenceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsTextMessage_get_Timestamp(py::wrapper::Windows::Devices::Sms::SmsTextMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsTextMessage", L"Timestamp"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Timestamp());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SmsTextMessage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Sms::SmsTextMessage>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SmsTextMessage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sms::SmsTextMessage>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SmsTextMessage[] = {
        { "to_binary_messages", reinterpret_cast<PyCFunction>(SmsTextMessage_ToBinaryMessages), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_SmsTextMessage, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SmsTextMessage), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SmsTextMessage[] = {
        { "id", reinterpret_cast<getter>(SmsTextMessage_get_Id), nullptr, nullptr, nullptr },
        { "message_class", reinterpret_cast<getter>(SmsTextMessage_get_MessageClass), nullptr, nullptr, nullptr },
        { "to", reinterpret_cast<getter>(SmsTextMessage_get_To), reinterpret_cast<setter>(SmsTextMessage_put_To), nullptr, nullptr },
        { "from_", reinterpret_cast<getter>(SmsTextMessage_get_From), reinterpret_cast<setter>(SmsTextMessage_put_From), nullptr, nullptr },
        { "encoding", reinterpret_cast<getter>(SmsTextMessage_get_Encoding), reinterpret_cast<setter>(SmsTextMessage_put_Encoding), nullptr, nullptr },
        { "body", reinterpret_cast<getter>(SmsTextMessage_get_Body), reinterpret_cast<setter>(SmsTextMessage_put_Body), nullptr, nullptr },
        { "part_count", reinterpret_cast<getter>(SmsTextMessage_get_PartCount), nullptr, nullptr, nullptr },
        { "part_number", reinterpret_cast<getter>(SmsTextMessage_get_PartNumber), nullptr, nullptr, nullptr },
        { "part_reference_id", reinterpret_cast<getter>(SmsTextMessage_get_PartReferenceId), nullptr, nullptr, nullptr },
        { "timestamp", reinterpret_cast<getter>(SmsTextMessage_get_Timestamp), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SmsTextMessage[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SmsTextMessage) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SmsTextMessage) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SmsTextMessage) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SmsTextMessage) },
        { },
    };

    static PyType_Spec type_spec_SmsTextMessage =
    {
        "winrt._winrt_windows_devices_sms.SmsTextMessage",
        sizeof(py::wrapper::Windows::Devices::Sms::SmsTextMessage),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SmsTextMessage
    };

    static PyGetSetDef getset_SmsTextMessage_Static[] = {
        { }
    };

    static PyMethodDef methods_SmsTextMessage_Static[] = {
        { "from_binary_data", reinterpret_cast<PyCFunction>(SmsTextMessage_FromBinaryData), METH_VARARGS, nullptr },
        { "from_binary_message", reinterpret_cast<PyCFunction>(SmsTextMessage_FromBinaryMessage), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_SmsTextMessage_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_SmsTextMessage_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_SmsTextMessage_Static) },
        { }
    };

    static PyType_Spec type_spec_SmsTextMessage_Static =
    {
        "winrt._winrt_windows_devices_sms.SmsTextMessage_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_SmsTextMessage_Static
    };

    // ----- SmsTextMessage2 class --------------------

    static PyObject* _new_SmsTextMessage2(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Devices::Sms::SmsTextMessage2 instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_SmsTextMessage2(py::wrapper::Windows::Devices::Sms::SmsTextMessage2* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SmsTextMessage2_get_MessageType(py::wrapper::Windows::Devices::Sms::SmsTextMessage2* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsTextMessage2", L"MessageType"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.MessageType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsTextMessage2_get_DeviceId(py::wrapper::Windows::Devices::Sms::SmsTextMessage2* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsTextMessage2", L"DeviceId"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DeviceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsTextMessage2_get_CellularClass(py::wrapper::Windows::Devices::Sms::SmsTextMessage2* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsTextMessage2", L"CellularClass"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CellularClass());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsTextMessage2_get_MessageClass(py::wrapper::Windows::Devices::Sms::SmsTextMessage2* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsTextMessage2", L"MessageClass"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.MessageClass());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsTextMessage2_get_SimIccId(py::wrapper::Windows::Devices::Sms::SmsTextMessage2* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsTextMessage2", L"SimIccId"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SimIccId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsTextMessage2_get_RetryAttemptCount(py::wrapper::Windows::Devices::Sms::SmsTextMessage2* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsTextMessage2", L"RetryAttemptCount"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.RetryAttemptCount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SmsTextMessage2_put_RetryAttemptCount(py::wrapper::Windows::Devices::Sms::SmsTextMessage2* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsTextMessage2", L"RetryAttemptCount"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.RetryAttemptCount(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SmsTextMessage2_get_To(py::wrapper::Windows::Devices::Sms::SmsTextMessage2* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsTextMessage2", L"To"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.To());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SmsTextMessage2_put_To(py::wrapper::Windows::Devices::Sms::SmsTextMessage2* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsTextMessage2", L"To"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.To(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SmsTextMessage2_get_IsDeliveryNotificationEnabled(py::wrapper::Windows::Devices::Sms::SmsTextMessage2* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsTextMessage2", L"IsDeliveryNotificationEnabled"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsDeliveryNotificationEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SmsTextMessage2_put_IsDeliveryNotificationEnabled(py::wrapper::Windows::Devices::Sms::SmsTextMessage2* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsTextMessage2", L"IsDeliveryNotificationEnabled"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsDeliveryNotificationEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SmsTextMessage2_get_Encoding(py::wrapper::Windows::Devices::Sms::SmsTextMessage2* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsTextMessage2", L"Encoding"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Encoding());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SmsTextMessage2_put_Encoding(py::wrapper::Windows::Devices::Sms::SmsTextMessage2* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsTextMessage2", L"Encoding"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Devices::Sms::SmsEncoding>(arg);

            self->obj.Encoding(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SmsTextMessage2_get_CallbackNumber(py::wrapper::Windows::Devices::Sms::SmsTextMessage2* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsTextMessage2", L"CallbackNumber"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CallbackNumber());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SmsTextMessage2_put_CallbackNumber(py::wrapper::Windows::Devices::Sms::SmsTextMessage2* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsTextMessage2", L"CallbackNumber"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.CallbackNumber(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SmsTextMessage2_get_Body(py::wrapper::Windows::Devices::Sms::SmsTextMessage2* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsTextMessage2", L"Body"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Body());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SmsTextMessage2_put_Body(py::wrapper::Windows::Devices::Sms::SmsTextMessage2* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsTextMessage2", L"Body"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Body(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SmsTextMessage2_get_ProtocolId(py::wrapper::Windows::Devices::Sms::SmsTextMessage2* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsTextMessage2", L"ProtocolId"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ProtocolId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsTextMessage2_get_From(py::wrapper::Windows::Devices::Sms::SmsTextMessage2* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsTextMessage2", L"From"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.From());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsTextMessage2_get_Timestamp(py::wrapper::Windows::Devices::Sms::SmsTextMessage2* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsTextMessage2", L"Timestamp"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Timestamp());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsTextMessage2_get_TeleserviceId(py::wrapper::Windows::Devices::Sms::SmsTextMessage2* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsTextMessage2", L"TeleserviceId"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.TeleserviceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SmsTextMessage2(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Sms::SmsTextMessage2>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SmsTextMessage2(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sms::SmsTextMessage2>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SmsTextMessage2[] = {
        { "_assign_array_", _assign_array_SmsTextMessage2, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SmsTextMessage2), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SmsTextMessage2[] = {
        { "message_type", reinterpret_cast<getter>(SmsTextMessage2_get_MessageType), nullptr, nullptr, nullptr },
        { "device_id", reinterpret_cast<getter>(SmsTextMessage2_get_DeviceId), nullptr, nullptr, nullptr },
        { "cellular_class", reinterpret_cast<getter>(SmsTextMessage2_get_CellularClass), nullptr, nullptr, nullptr },
        { "message_class", reinterpret_cast<getter>(SmsTextMessage2_get_MessageClass), nullptr, nullptr, nullptr },
        { "sim_icc_id", reinterpret_cast<getter>(SmsTextMessage2_get_SimIccId), nullptr, nullptr, nullptr },
        { "retry_attempt_count", reinterpret_cast<getter>(SmsTextMessage2_get_RetryAttemptCount), reinterpret_cast<setter>(SmsTextMessage2_put_RetryAttemptCount), nullptr, nullptr },
        { "to", reinterpret_cast<getter>(SmsTextMessage2_get_To), reinterpret_cast<setter>(SmsTextMessage2_put_To), nullptr, nullptr },
        { "is_delivery_notification_enabled", reinterpret_cast<getter>(SmsTextMessage2_get_IsDeliveryNotificationEnabled), reinterpret_cast<setter>(SmsTextMessage2_put_IsDeliveryNotificationEnabled), nullptr, nullptr },
        { "encoding", reinterpret_cast<getter>(SmsTextMessage2_get_Encoding), reinterpret_cast<setter>(SmsTextMessage2_put_Encoding), nullptr, nullptr },
        { "callback_number", reinterpret_cast<getter>(SmsTextMessage2_get_CallbackNumber), reinterpret_cast<setter>(SmsTextMessage2_put_CallbackNumber), nullptr, nullptr },
        { "body", reinterpret_cast<getter>(SmsTextMessage2_get_Body), reinterpret_cast<setter>(SmsTextMessage2_put_Body), nullptr, nullptr },
        { "protocol_id", reinterpret_cast<getter>(SmsTextMessage2_get_ProtocolId), nullptr, nullptr, nullptr },
        { "from_", reinterpret_cast<getter>(SmsTextMessage2_get_From), nullptr, nullptr, nullptr },
        { "timestamp", reinterpret_cast<getter>(SmsTextMessage2_get_Timestamp), nullptr, nullptr, nullptr },
        { "teleservice_id", reinterpret_cast<getter>(SmsTextMessage2_get_TeleserviceId), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SmsTextMessage2[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SmsTextMessage2) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SmsTextMessage2) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SmsTextMessage2) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SmsTextMessage2) },
        { },
    };

    static PyType_Spec type_spec_SmsTextMessage2 =
    {
        "winrt._winrt_windows_devices_sms.SmsTextMessage2",
        sizeof(py::wrapper::Windows::Devices::Sms::SmsTextMessage2),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SmsTextMessage2
    };

    // ----- SmsVoicemailMessage class --------------------

    static PyObject* _new_SmsVoicemailMessage(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Sms::SmsVoicemailMessage>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Sms::SmsVoicemailMessage>::type_name);
        return nullptr;
    }

    static void _dealloc_SmsVoicemailMessage(py::wrapper::Windows::Devices::Sms::SmsVoicemailMessage* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SmsVoicemailMessage_get_CellularClass(py::wrapper::Windows::Devices::Sms::SmsVoicemailMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsVoicemailMessage", L"CellularClass"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CellularClass());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsVoicemailMessage_get_DeviceId(py::wrapper::Windows::Devices::Sms::SmsVoicemailMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsVoicemailMessage", L"DeviceId"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DeviceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsVoicemailMessage_get_MessageClass(py::wrapper::Windows::Devices::Sms::SmsVoicemailMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsVoicemailMessage", L"MessageClass"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.MessageClass());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsVoicemailMessage_get_MessageType(py::wrapper::Windows::Devices::Sms::SmsVoicemailMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsVoicemailMessage", L"MessageType"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.MessageType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsVoicemailMessage_get_SimIccId(py::wrapper::Windows::Devices::Sms::SmsVoicemailMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsVoicemailMessage", L"SimIccId"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SimIccId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsVoicemailMessage_get_Body(py::wrapper::Windows::Devices::Sms::SmsVoicemailMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsVoicemailMessage", L"Body"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Body());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsVoicemailMessage_get_MessageCount(py::wrapper::Windows::Devices::Sms::SmsVoicemailMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsVoicemailMessage", L"MessageCount"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.MessageCount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsVoicemailMessage_get_Timestamp(py::wrapper::Windows::Devices::Sms::SmsVoicemailMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsVoicemailMessage", L"Timestamp"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Timestamp());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsVoicemailMessage_get_To(py::wrapper::Windows::Devices::Sms::SmsVoicemailMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsVoicemailMessage", L"To"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.To());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SmsVoicemailMessage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Sms::SmsVoicemailMessage>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SmsVoicemailMessage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sms::SmsVoicemailMessage>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SmsVoicemailMessage[] = {
        { "_assign_array_", _assign_array_SmsVoicemailMessage, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SmsVoicemailMessage), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SmsVoicemailMessage[] = {
        { "cellular_class", reinterpret_cast<getter>(SmsVoicemailMessage_get_CellularClass), nullptr, nullptr, nullptr },
        { "device_id", reinterpret_cast<getter>(SmsVoicemailMessage_get_DeviceId), nullptr, nullptr, nullptr },
        { "message_class", reinterpret_cast<getter>(SmsVoicemailMessage_get_MessageClass), nullptr, nullptr, nullptr },
        { "message_type", reinterpret_cast<getter>(SmsVoicemailMessage_get_MessageType), nullptr, nullptr, nullptr },
        { "sim_icc_id", reinterpret_cast<getter>(SmsVoicemailMessage_get_SimIccId), nullptr, nullptr, nullptr },
        { "body", reinterpret_cast<getter>(SmsVoicemailMessage_get_Body), nullptr, nullptr, nullptr },
        { "message_count", reinterpret_cast<getter>(SmsVoicemailMessage_get_MessageCount), nullptr, nullptr, nullptr },
        { "timestamp", reinterpret_cast<getter>(SmsVoicemailMessage_get_Timestamp), nullptr, nullptr, nullptr },
        { "to", reinterpret_cast<getter>(SmsVoicemailMessage_get_To), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SmsVoicemailMessage[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SmsVoicemailMessage) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SmsVoicemailMessage) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SmsVoicemailMessage) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SmsVoicemailMessage) },
        { },
    };

    static PyType_Spec type_spec_SmsVoicemailMessage =
    {
        "winrt._winrt_windows_devices_sms.SmsVoicemailMessage",
        sizeof(py::wrapper::Windows::Devices::Sms::SmsVoicemailMessage),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SmsVoicemailMessage
    };

    // ----- SmsWapMessage class --------------------

    static PyObject* _new_SmsWapMessage(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Sms::SmsWapMessage>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Sms::SmsWapMessage>::type_name);
        return nullptr;
    }

    static void _dealloc_SmsWapMessage(py::wrapper::Windows::Devices::Sms::SmsWapMessage* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SmsWapMessage_get_CellularClass(py::wrapper::Windows::Devices::Sms::SmsWapMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsWapMessage", L"CellularClass"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CellularClass());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsWapMessage_get_DeviceId(py::wrapper::Windows::Devices::Sms::SmsWapMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsWapMessage", L"DeviceId"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DeviceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsWapMessage_get_MessageClass(py::wrapper::Windows::Devices::Sms::SmsWapMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsWapMessage", L"MessageClass"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.MessageClass());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsWapMessage_get_MessageType(py::wrapper::Windows::Devices::Sms::SmsWapMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsWapMessage", L"MessageType"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.MessageType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsWapMessage_get_SimIccId(py::wrapper::Windows::Devices::Sms::SmsWapMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsWapMessage", L"SimIccId"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SimIccId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsWapMessage_get_Timestamp(py::wrapper::Windows::Devices::Sms::SmsWapMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsWapMessage", L"Timestamp"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Timestamp());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsWapMessage_get_ApplicationId(py::wrapper::Windows::Devices::Sms::SmsWapMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsWapMessage", L"ApplicationId"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ApplicationId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsWapMessage_get_BinaryBody(py::wrapper::Windows::Devices::Sms::SmsWapMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsWapMessage", L"BinaryBody"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.BinaryBody());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsWapMessage_get_ContentType(py::wrapper::Windows::Devices::Sms::SmsWapMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsWapMessage", L"ContentType"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ContentType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsWapMessage_get_From(py::wrapper::Windows::Devices::Sms::SmsWapMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsWapMessage", L"From"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.From());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsWapMessage_get_Headers(py::wrapper::Windows::Devices::Sms::SmsWapMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsWapMessage", L"Headers"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Headers());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsWapMessage_get_To(py::wrapper::Windows::Devices::Sms::SmsWapMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsWapMessage", L"To"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.To());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SmsWapMessage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Sms::SmsWapMessage>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SmsWapMessage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sms::SmsWapMessage>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SmsWapMessage[] = {
        { "_assign_array_", _assign_array_SmsWapMessage, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SmsWapMessage), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SmsWapMessage[] = {
        { "cellular_class", reinterpret_cast<getter>(SmsWapMessage_get_CellularClass), nullptr, nullptr, nullptr },
        { "device_id", reinterpret_cast<getter>(SmsWapMessage_get_DeviceId), nullptr, nullptr, nullptr },
        { "message_class", reinterpret_cast<getter>(SmsWapMessage_get_MessageClass), nullptr, nullptr, nullptr },
        { "message_type", reinterpret_cast<getter>(SmsWapMessage_get_MessageType), nullptr, nullptr, nullptr },
        { "sim_icc_id", reinterpret_cast<getter>(SmsWapMessage_get_SimIccId), nullptr, nullptr, nullptr },
        { "timestamp", reinterpret_cast<getter>(SmsWapMessage_get_Timestamp), nullptr, nullptr, nullptr },
        { "application_id", reinterpret_cast<getter>(SmsWapMessage_get_ApplicationId), nullptr, nullptr, nullptr },
        { "binary_body", reinterpret_cast<getter>(SmsWapMessage_get_BinaryBody), nullptr, nullptr, nullptr },
        { "content_type", reinterpret_cast<getter>(SmsWapMessage_get_ContentType), nullptr, nullptr, nullptr },
        { "from_", reinterpret_cast<getter>(SmsWapMessage_get_From), nullptr, nullptr, nullptr },
        { "headers", reinterpret_cast<getter>(SmsWapMessage_get_Headers), nullptr, nullptr, nullptr },
        { "to", reinterpret_cast<getter>(SmsWapMessage_get_To), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SmsWapMessage[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SmsWapMessage) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SmsWapMessage) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SmsWapMessage) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SmsWapMessage) },
        { },
    };

    static PyType_Spec type_spec_SmsWapMessage =
    {
        "winrt._winrt_windows_devices_sms.SmsWapMessage",
        sizeof(py::wrapper::Windows::Devices::Sms::SmsWapMessage),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SmsWapMessage
    };

    // ----- ISmsBinaryMessage interface --------------------

    static PyObject* _new_ISmsBinaryMessage(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Sms::ISmsBinaryMessage>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Sms::ISmsBinaryMessage>::type_name);
        return nullptr;
    }

    static void _dealloc_ISmsBinaryMessage(py::wrapper::Windows::Devices::Sms::ISmsBinaryMessage* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ISmsBinaryMessage_GetData(py::wrapper::Windows::Devices::Sms::ISmsBinaryMessage* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sms.ISmsBinaryMessage", L"GetData", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetData());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ISmsBinaryMessage_SetData(py::wrapper::Windows::Devices::Sms::ISmsBinaryMessage* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sms.ISmsBinaryMessage", L"SetData", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<py::pybuf_view<uint8_t, false>>(args, 0);

                self->obj.SetData(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ISmsBinaryMessage_get_Format(py::wrapper::Windows::Devices::Sms::ISmsBinaryMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.ISmsBinaryMessage", L"Format"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Format());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ISmsBinaryMessage_put_Format(py::wrapper::Windows::Devices::Sms::ISmsBinaryMessage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.ISmsBinaryMessage", L"Format"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Devices::Sms::SmsDataFormat>(arg);

            self->obj.Format(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ISmsBinaryMessage_get_Id(py::wrapper::Windows::Devices::Sms::ISmsBinaryMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.ISmsMessage", L"Id"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ISmsBinaryMessage_get_MessageClass(py::wrapper::Windows::Devices::Sms::ISmsBinaryMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.ISmsMessage", L"MessageClass"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.MessageClass());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ISmsBinaryMessage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Sms::ISmsBinaryMessage>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ISmsBinaryMessage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sms::ISmsBinaryMessage>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ISmsBinaryMessage[] = {
        { "get_data", reinterpret_cast<PyCFunction>(ISmsBinaryMessage_GetData), METH_VARARGS, nullptr },
        { "set_data", reinterpret_cast<PyCFunction>(ISmsBinaryMessage_SetData), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_ISmsBinaryMessage, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ISmsBinaryMessage), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ISmsBinaryMessage[] = {
        { "format", reinterpret_cast<getter>(ISmsBinaryMessage_get_Format), reinterpret_cast<setter>(ISmsBinaryMessage_put_Format), nullptr, nullptr },
        { "id", reinterpret_cast<getter>(ISmsBinaryMessage_get_Id), nullptr, nullptr, nullptr },
        { "message_class", reinterpret_cast<getter>(ISmsBinaryMessage_get_MessageClass), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ISmsBinaryMessage[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ISmsBinaryMessage) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ISmsBinaryMessage) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ISmsBinaryMessage) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ISmsBinaryMessage) },
        { },
    };

    static PyType_Spec type_spec_ISmsBinaryMessage =
    {
        "winrt._winrt_windows_devices_sms.ISmsBinaryMessage",
        sizeof(py::wrapper::Windows::Devices::Sms::ISmsBinaryMessage),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ISmsBinaryMessage
    };

    // ----- ISmsDevice interface --------------------

    static PyObject* _new_ISmsDevice(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Sms::ISmsDevice>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Sms::ISmsDevice>::type_name);
        return nullptr;
    }

    static void _dealloc_ISmsDevice(py::wrapper::Windows::Devices::Sms::ISmsDevice* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ISmsDevice_CalculateLength(py::wrapper::Windows::Devices::Sms::ISmsDevice* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sms.ISmsDevice", L"CalculateLength", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Devices::Sms::SmsTextMessage>(args, 0);

                return py::convert(self->obj.CalculateLength(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ISmsDevice_SendMessageAsync(py::wrapper::Windows::Devices::Sms::ISmsDevice* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sms.ISmsDevice", L"SendMessageAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Devices::Sms::ISmsMessage>(args, 0);

                return py::convert(self->obj.SendMessageAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ISmsDevice_get_AccountPhoneNumber(py::wrapper::Windows::Devices::Sms::ISmsDevice* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.ISmsDevice", L"AccountPhoneNumber"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.AccountPhoneNumber());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ISmsDevice_get_CellularClass(py::wrapper::Windows::Devices::Sms::ISmsDevice* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.ISmsDevice", L"CellularClass"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CellularClass());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ISmsDevice_get_DeviceStatus(py::wrapper::Windows::Devices::Sms::ISmsDevice* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.ISmsDevice", L"DeviceStatus"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DeviceStatus());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ISmsDevice_get_MessageStore(py::wrapper::Windows::Devices::Sms::ISmsDevice* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.ISmsDevice", L"MessageStore"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.MessageStore());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ISmsDevice_add_SmsDeviceStatusChanged(py::wrapper::Windows::Devices::Sms::ISmsDevice* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Sms.ISmsDevice", L"SmsDeviceStatusChanged"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Devices::Sms::SmsDeviceStatusChangedEventHandler>(arg);

            return py::convert(self->obj.SmsDeviceStatusChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ISmsDevice_remove_SmsDeviceStatusChanged(py::wrapper::Windows::Devices::Sms::ISmsDevice* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Sms.ISmsDevice", L"SmsDeviceStatusChanged"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.SmsDeviceStatusChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ISmsDevice_add_SmsMessageReceived(py::wrapper::Windows::Devices::Sms::ISmsDevice* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Sms.ISmsDevice", L"SmsMessageReceived"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Devices::Sms::SmsMessageReceivedEventHandler>(arg);

            return py::convert(self->obj.SmsMessageReceived(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ISmsDevice_remove_SmsMessageReceived(py::wrapper::Windows::Devices::Sms::ISmsDevice* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Sms.ISmsDevice", L"SmsMessageReceived"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.SmsMessageReceived(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ISmsDevice(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Sms::ISmsDevice>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ISmsDevice(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sms::ISmsDevice>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ISmsDevice[] = {
        { "calculate_length", reinterpret_cast<PyCFunction>(ISmsDevice_CalculateLength), METH_VARARGS, nullptr },
        { "send_message_async", reinterpret_cast<PyCFunction>(ISmsDevice_SendMessageAsync), METH_VARARGS, nullptr },
        { "add_sms_device_status_changed", reinterpret_cast<PyCFunction>(ISmsDevice_add_SmsDeviceStatusChanged), METH_O, nullptr },
        { "remove_sms_device_status_changed", reinterpret_cast<PyCFunction>(ISmsDevice_remove_SmsDeviceStatusChanged), METH_O, nullptr },
        { "add_sms_message_received", reinterpret_cast<PyCFunction>(ISmsDevice_add_SmsMessageReceived), METH_O, nullptr },
        { "remove_sms_message_received", reinterpret_cast<PyCFunction>(ISmsDevice_remove_SmsMessageReceived), METH_O, nullptr },
        { "_assign_array_", _assign_array_ISmsDevice, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ISmsDevice), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ISmsDevice[] = {
        { "account_phone_number", reinterpret_cast<getter>(ISmsDevice_get_AccountPhoneNumber), nullptr, nullptr, nullptr },
        { "cellular_class", reinterpret_cast<getter>(ISmsDevice_get_CellularClass), nullptr, nullptr, nullptr },
        { "device_status", reinterpret_cast<getter>(ISmsDevice_get_DeviceStatus), nullptr, nullptr, nullptr },
        { "message_store", reinterpret_cast<getter>(ISmsDevice_get_MessageStore), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ISmsDevice[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ISmsDevice) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ISmsDevice) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ISmsDevice) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ISmsDevice) },
        { },
    };

    static PyType_Spec type_spec_ISmsDevice =
    {
        "winrt._winrt_windows_devices_sms.ISmsDevice",
        sizeof(py::wrapper::Windows::Devices::Sms::ISmsDevice),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ISmsDevice
    };

    // ----- ISmsMessage interface --------------------

    static PyObject* _new_ISmsMessage(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Sms::ISmsMessage>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Sms::ISmsMessage>::type_name);
        return nullptr;
    }

    static void _dealloc_ISmsMessage(py::wrapper::Windows::Devices::Sms::ISmsMessage* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ISmsMessage_get_Id(py::wrapper::Windows::Devices::Sms::ISmsMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.ISmsMessage", L"Id"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ISmsMessage_get_MessageClass(py::wrapper::Windows::Devices::Sms::ISmsMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.ISmsMessage", L"MessageClass"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.MessageClass());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ISmsMessage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Sms::ISmsMessage>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ISmsMessage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sms::ISmsMessage>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ISmsMessage[] = {
        { "_assign_array_", _assign_array_ISmsMessage, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ISmsMessage), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ISmsMessage[] = {
        { "id", reinterpret_cast<getter>(ISmsMessage_get_Id), nullptr, nullptr, nullptr },
        { "message_class", reinterpret_cast<getter>(ISmsMessage_get_MessageClass), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ISmsMessage[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ISmsMessage) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ISmsMessage) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ISmsMessage) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ISmsMessage) },
        { },
    };

    static PyType_Spec type_spec_ISmsMessage =
    {
        "winrt._winrt_windows_devices_sms.ISmsMessage",
        sizeof(py::wrapper::Windows::Devices::Sms::ISmsMessage),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ISmsMessage
    };

    // ----- ISmsMessageBase interface --------------------

    static PyObject* _new_ISmsMessageBase(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Sms::ISmsMessageBase>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Sms::ISmsMessageBase>::type_name);
        return nullptr;
    }

    static void _dealloc_ISmsMessageBase(py::wrapper::Windows::Devices::Sms::ISmsMessageBase* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ISmsMessageBase_get_CellularClass(py::wrapper::Windows::Devices::Sms::ISmsMessageBase* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.ISmsMessageBase", L"CellularClass"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CellularClass());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ISmsMessageBase_get_DeviceId(py::wrapper::Windows::Devices::Sms::ISmsMessageBase* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.ISmsMessageBase", L"DeviceId"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DeviceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ISmsMessageBase_get_MessageClass(py::wrapper::Windows::Devices::Sms::ISmsMessageBase* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.ISmsMessageBase", L"MessageClass"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.MessageClass());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ISmsMessageBase_get_MessageType(py::wrapper::Windows::Devices::Sms::ISmsMessageBase* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.ISmsMessageBase", L"MessageType"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.MessageType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ISmsMessageBase_get_SimIccId(py::wrapper::Windows::Devices::Sms::ISmsMessageBase* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.ISmsMessageBase", L"SimIccId"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SimIccId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ISmsMessageBase(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Sms::ISmsMessageBase>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ISmsMessageBase(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sms::ISmsMessageBase>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ISmsMessageBase[] = {
        { "_assign_array_", _assign_array_ISmsMessageBase, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ISmsMessageBase), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ISmsMessageBase[] = {
        { "cellular_class", reinterpret_cast<getter>(ISmsMessageBase_get_CellularClass), nullptr, nullptr, nullptr },
        { "device_id", reinterpret_cast<getter>(ISmsMessageBase_get_DeviceId), nullptr, nullptr, nullptr },
        { "message_class", reinterpret_cast<getter>(ISmsMessageBase_get_MessageClass), nullptr, nullptr, nullptr },
        { "message_type", reinterpret_cast<getter>(ISmsMessageBase_get_MessageType), nullptr, nullptr, nullptr },
        { "sim_icc_id", reinterpret_cast<getter>(ISmsMessageBase_get_SimIccId), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ISmsMessageBase[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ISmsMessageBase) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ISmsMessageBase) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ISmsMessageBase) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ISmsMessageBase) },
        { },
    };

    static PyType_Spec type_spec_ISmsMessageBase =
    {
        "winrt._winrt_windows_devices_sms.ISmsMessageBase",
        sizeof(py::wrapper::Windows::Devices::Sms::ISmsMessageBase),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ISmsMessageBase
    };

    // ----- ISmsTextMessage interface --------------------

    static PyObject* _new_ISmsTextMessage(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Sms::ISmsTextMessage>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Sms::ISmsTextMessage>::type_name);
        return nullptr;
    }

    static void _dealloc_ISmsTextMessage(py::wrapper::Windows::Devices::Sms::ISmsTextMessage* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ISmsTextMessage_ToBinaryMessages(py::wrapper::Windows::Devices::Sms::ISmsTextMessage* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sms.ISmsTextMessage", L"ToBinaryMessages", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Devices::Sms::SmsDataFormat>(args, 0);

                return py::convert(self->obj.ToBinaryMessages(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ISmsTextMessage_get_Body(py::wrapper::Windows::Devices::Sms::ISmsTextMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.ISmsTextMessage", L"Body"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Body());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ISmsTextMessage_put_Body(py::wrapper::Windows::Devices::Sms::ISmsTextMessage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.ISmsTextMessage", L"Body"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Body(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ISmsTextMessage_get_Encoding(py::wrapper::Windows::Devices::Sms::ISmsTextMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.ISmsTextMessage", L"Encoding"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Encoding());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ISmsTextMessage_put_Encoding(py::wrapper::Windows::Devices::Sms::ISmsTextMessage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.ISmsTextMessage", L"Encoding"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Devices::Sms::SmsEncoding>(arg);

            self->obj.Encoding(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ISmsTextMessage_get_From(py::wrapper::Windows::Devices::Sms::ISmsTextMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.ISmsTextMessage", L"From"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.From());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ISmsTextMessage_put_From(py::wrapper::Windows::Devices::Sms::ISmsTextMessage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.ISmsTextMessage", L"From"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.From(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ISmsTextMessage_get_PartCount(py::wrapper::Windows::Devices::Sms::ISmsTextMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.ISmsTextMessage", L"PartCount"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PartCount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ISmsTextMessage_get_PartNumber(py::wrapper::Windows::Devices::Sms::ISmsTextMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.ISmsTextMessage", L"PartNumber"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PartNumber());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ISmsTextMessage_get_PartReferenceId(py::wrapper::Windows::Devices::Sms::ISmsTextMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.ISmsTextMessage", L"PartReferenceId"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PartReferenceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ISmsTextMessage_get_Timestamp(py::wrapper::Windows::Devices::Sms::ISmsTextMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.ISmsTextMessage", L"Timestamp"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Timestamp());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ISmsTextMessage_get_To(py::wrapper::Windows::Devices::Sms::ISmsTextMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.ISmsTextMessage", L"To"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.To());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ISmsTextMessage_put_To(py::wrapper::Windows::Devices::Sms::ISmsTextMessage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.ISmsTextMessage", L"To"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.To(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ISmsTextMessage_get_Id(py::wrapper::Windows::Devices::Sms::ISmsTextMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.ISmsMessage", L"Id"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ISmsTextMessage_get_MessageClass(py::wrapper::Windows::Devices::Sms::ISmsTextMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.ISmsMessage", L"MessageClass"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.MessageClass());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ISmsTextMessage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Sms::ISmsTextMessage>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ISmsTextMessage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sms::ISmsTextMessage>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ISmsTextMessage[] = {
        { "to_binary_messages", reinterpret_cast<PyCFunction>(ISmsTextMessage_ToBinaryMessages), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_ISmsTextMessage, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ISmsTextMessage), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ISmsTextMessage[] = {
        { "body", reinterpret_cast<getter>(ISmsTextMessage_get_Body), reinterpret_cast<setter>(ISmsTextMessage_put_Body), nullptr, nullptr },
        { "encoding", reinterpret_cast<getter>(ISmsTextMessage_get_Encoding), reinterpret_cast<setter>(ISmsTextMessage_put_Encoding), nullptr, nullptr },
        { "from_", reinterpret_cast<getter>(ISmsTextMessage_get_From), reinterpret_cast<setter>(ISmsTextMessage_put_From), nullptr, nullptr },
        { "part_count", reinterpret_cast<getter>(ISmsTextMessage_get_PartCount), nullptr, nullptr, nullptr },
        { "part_number", reinterpret_cast<getter>(ISmsTextMessage_get_PartNumber), nullptr, nullptr, nullptr },
        { "part_reference_id", reinterpret_cast<getter>(ISmsTextMessage_get_PartReferenceId), nullptr, nullptr, nullptr },
        { "timestamp", reinterpret_cast<getter>(ISmsTextMessage_get_Timestamp), nullptr, nullptr, nullptr },
        { "to", reinterpret_cast<getter>(ISmsTextMessage_get_To), reinterpret_cast<setter>(ISmsTextMessage_put_To), nullptr, nullptr },
        { "id", reinterpret_cast<getter>(ISmsTextMessage_get_Id), nullptr, nullptr, nullptr },
        { "message_class", reinterpret_cast<getter>(ISmsTextMessage_get_MessageClass), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ISmsTextMessage[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ISmsTextMessage) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ISmsTextMessage) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ISmsTextMessage) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ISmsTextMessage) },
        { },
    };

    static PyType_Spec type_spec_ISmsTextMessage =
    {
        "winrt._winrt_windows_devices_sms.ISmsTextMessage",
        sizeof(py::wrapper::Windows::Devices::Sms::ISmsTextMessage),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ISmsTextMessage
    };

    // ----- SmsEncodedLength struct --------------------

    winrt_struct_wrapper<winrt::Windows::Devices::Sms::SmsEncodedLength>* _new_SmsEncodedLength(PyTypeObject* subclass, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        auto self = reinterpret_cast<winrt_struct_wrapper<winrt::Windows::Devices::Sms::SmsEncodedLength>*>(subclass->tp_alloc(subclass, 0));

        if (!self)
        {
            return nullptr;
        }

        std::construct_at(&self->obj);

        return self;
    }

    int _init_SmsEncodedLength(winrt_struct_wrapper<winrt::Windows::Devices::Sms::SmsEncodedLength>* self, PyObject* args, PyObject* kwds) noexcept
    {
        auto tuple_size = PyTuple_Size(args);

        if ((tuple_size == 0) && (kwds == nullptr))
        {
            self->obj = {};
            return 0;
        }

        uint32_t _SegmentCount{};
        uint32_t _CharacterCountLastSegment{};
        uint32_t _CharactersPerSegment{};
        uint32_t _ByteCountLastSegment{};
        uint32_t _BytesPerSegment{};

        static const char* kwlist[] = {"segment_count", "character_count_last_segment", "characters_per_segment", "byte_count_last_segment", "bytes_per_segment", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "IIIII", const_cast<char**>(kwlist), &_SegmentCount, &_CharacterCountLastSegment, &_CharactersPerSegment, &_ByteCountLastSegment, &_BytesPerSegment))
        {
            return -1;
        }

        try
        {
            self->obj = {_SegmentCount, _CharacterCountLastSegment, _CharactersPerSegment, _ByteCountLastSegment, _BytesPerSegment};
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static void _dealloc_SmsEncodedLength(py::wrapper::Windows::Devices::Sms::SmsEncodedLength* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_SmsEncodedLength(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Sms::SmsEncodedLength>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyMethodDef _methods_SmsEncodedLength[] = {
        { "_assign_array_", _assign_array_SmsEncodedLength, METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyObject* SmsEncodedLength_get_SegmentCount(py::wrapper::Windows::Devices::Sms::SmsEncodedLength* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SegmentCount);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SmsEncodedLength_set_SegmentCount(py::wrapper::Windows::Devices::Sms::SmsEncodedLength* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.SegmentCount = py::converter<uint32_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SmsEncodedLength_get_CharacterCountLastSegment(py::wrapper::Windows::Devices::Sms::SmsEncodedLength* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CharacterCountLastSegment);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SmsEncodedLength_set_CharacterCountLastSegment(py::wrapper::Windows::Devices::Sms::SmsEncodedLength* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.CharacterCountLastSegment = py::converter<uint32_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SmsEncodedLength_get_CharactersPerSegment(py::wrapper::Windows::Devices::Sms::SmsEncodedLength* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CharactersPerSegment);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SmsEncodedLength_set_CharactersPerSegment(py::wrapper::Windows::Devices::Sms::SmsEncodedLength* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.CharactersPerSegment = py::converter<uint32_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SmsEncodedLength_get_ByteCountLastSegment(py::wrapper::Windows::Devices::Sms::SmsEncodedLength* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ByteCountLastSegment);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SmsEncodedLength_set_ByteCountLastSegment(py::wrapper::Windows::Devices::Sms::SmsEncodedLength* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.ByteCountLastSegment = py::converter<uint32_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SmsEncodedLength_get_BytesPerSegment(py::wrapper::Windows::Devices::Sms::SmsEncodedLength* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.BytesPerSegment);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SmsEncodedLength_set_BytesPerSegment(py::wrapper::Windows::Devices::Sms::SmsEncodedLength* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.BytesPerSegment = py::converter<uint32_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyGetSetDef _getset_SmsEncodedLength[] = {
        { "segment_count", reinterpret_cast<getter>(SmsEncodedLength_get_SegmentCount), reinterpret_cast<setter>(SmsEncodedLength_set_SegmentCount), nullptr, nullptr },
        { "character_count_last_segment", reinterpret_cast<getter>(SmsEncodedLength_get_CharacterCountLastSegment), reinterpret_cast<setter>(SmsEncodedLength_set_CharacterCountLastSegment), nullptr, nullptr },
        { "characters_per_segment", reinterpret_cast<getter>(SmsEncodedLength_get_CharactersPerSegment), reinterpret_cast<setter>(SmsEncodedLength_set_CharactersPerSegment), nullptr, nullptr },
        { "byte_count_last_segment", reinterpret_cast<getter>(SmsEncodedLength_get_ByteCountLastSegment), reinterpret_cast<setter>(SmsEncodedLength_set_ByteCountLastSegment), nullptr, nullptr },
        { "bytes_per_segment", reinterpret_cast<getter>(SmsEncodedLength_get_BytesPerSegment), reinterpret_cast<setter>(SmsEncodedLength_set_BytesPerSegment), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SmsEncodedLength[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SmsEncodedLength) },
        { Py_tp_init, reinterpret_cast<void*>(_init_SmsEncodedLength) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SmsEncodedLength) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SmsEncodedLength) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SmsEncodedLength) },
        { },
    };

    static PyType_Spec type_spec_SmsEncodedLength =
    {
        "winrt._winrt_windows_devices_sms.SmsEncodedLength",
        sizeof(py::wrapper::Windows::Devices::Sms::SmsEncodedLength),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SmsEncodedLength
    };

    // ----- Windows.Devices.Sms Initialization --------------------
    PyDoc_STRVAR(module_doc, "Windows::Devices::Sms");


    static PyModuleDef module_def
        = {PyModuleDef_HEAD_INIT,
           "_winrt_windows_devices_sms",
           module_doc,
           0,
           nullptr,
           nullptr,
           nullptr,
           nullptr,
           nullptr};

} // py::cpp::Windows::Devices::Sms

PyMODINIT_FUNC PyInit__winrt_windows_devices_sms(void) noexcept
{
    using namespace py::cpp::Windows::Devices::Sms;

    if (py::import_winrt_runtime() == -1)
    {
        return nullptr;
    }

    py::pyobj_handle module{PyModule_Create(&module_def)};

    if (!module)
    {
        return nullptr;
    }

    auto object_type = py::get_object_type();
    if (!object_type)
    {
        return nullptr;
    }

    py::pyobj_handle object_bases{PyTuple_Pack(1, object_type)};

    if (!object_bases)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_DeleteSmsMessageOperation, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_DeleteSmsMessagesOperation, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_GetSmsDeviceOperation, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_GetSmsMessageOperation, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_GetSmsMessagesOperation, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_SendSmsMessageOperation, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_SmsAppMessage, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_SmsBinaryMessage, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_SmsBroadcastMessage, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_SmsDevice_Static{PyType_FromSpec(&type_spec_SmsDevice_Static)};
    if (!type_SmsDevice_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_SmsDevice, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_SmsDevice_Static.get())) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_SmsDevice2_Static{PyType_FromSpec(&type_spec_SmsDevice2_Static)};
    if (!type_SmsDevice2_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_SmsDevice2, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_SmsDevice2_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_SmsDeviceMessageStore, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_SmsFilterRule, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_SmsFilterRules, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_SmsMessageReceivedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_SmsMessageReceivedTriggerDetails, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_SmsMessageRegistration_Static{PyType_FromSpec(&type_spec_SmsMessageRegistration_Static)};
    if (!type_SmsMessageRegistration_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_SmsMessageRegistration, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_SmsMessageRegistration_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_SmsReceivedEventDetails, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_SmsSendMessageResult, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_SmsStatusMessage, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_SmsTextMessage_Static{PyType_FromSpec(&type_spec_SmsTextMessage_Static)};
    if (!type_SmsTextMessage_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_SmsTextMessage, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_SmsTextMessage_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_SmsTextMessage2, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_SmsVoicemailMessage, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_SmsWapMessage, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ISmsBinaryMessage, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ISmsDevice, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ISmsMessage, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ISmsMessageBase, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ISmsTextMessage, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_SmsEncodedLength, nullptr, nullptr) == -1)
    {
        return nullptr;
    }


    return module.detach();
}
