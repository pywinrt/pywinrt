// WARNING: Please don't edit this file. It was generated by Python/WinRT v0.0.0

#include "py.Windows.Devices.Sms.h"

namespace py::cpp::Windows::Devices::Sms
{
    // ----- DeleteSmsMessageOperation class --------------------

    static PyObject* _new_DeleteSmsMessageOperation(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Sms::DeleteSmsMessageOperation>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Sms::DeleteSmsMessageOperation>::type_name);
        return nullptr;
    }

    static void _dealloc_DeleteSmsMessageOperation(py::wrapper::Windows::Devices::Sms::DeleteSmsMessageOperation* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* DeleteSmsMessageOperation_Cancel(py::wrapper::Windows::Devices::Sms::DeleteSmsMessageOperation* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sms.DeleteSmsMessageOperation", L"Cancel", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.Cancel();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DeleteSmsMessageOperation_Close(py::wrapper::Windows::Devices::Sms::DeleteSmsMessageOperation* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sms.DeleteSmsMessageOperation", L"Close", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.Close();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DeleteSmsMessageOperation_GetResults(py::wrapper::Windows::Devices::Sms::DeleteSmsMessageOperation* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sms.DeleteSmsMessageOperation", L"GetResults", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.GetResults();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DeleteSmsMessageOperation_get_ErrorCode(py::wrapper::Windows::Devices::Sms::DeleteSmsMessageOperation* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.DeleteSmsMessageOperation", L"ErrorCode");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ErrorCode();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DeleteSmsMessageOperation_get_Id(py::wrapper::Windows::Devices::Sms::DeleteSmsMessageOperation* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.DeleteSmsMessageOperation", L"Id");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Id();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DeleteSmsMessageOperation_get_Status(py::wrapper::Windows::Devices::Sms::DeleteSmsMessageOperation* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.DeleteSmsMessageOperation", L"Status");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Status();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DeleteSmsMessageOperation_get_Completed(py::wrapper::Windows::Devices::Sms::DeleteSmsMessageOperation* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.DeleteSmsMessageOperation", L"Completed");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Completed();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DeleteSmsMessageOperation_put_Completed(py::wrapper::Windows::Devices::Sms::DeleteSmsMessageOperation* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.DeleteSmsMessageOperation", L"Completed");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::AsyncActionCompletedHandler>(arg);

            {
                auto _gil = release_gil();
                self->obj.Completed(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_DeleteSmsMessageOperation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Sms::DeleteSmsMessageOperation>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_DeleteSmsMessageOperation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sms::DeleteSmsMessageOperation>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _await_DeleteSmsMessageOperation(py::wrapper::Windows::Devices::Sms::DeleteSmsMessageOperation* self) noexcept
    {
        return py::dunder_await(self->obj);
    }

    static PyMethodDef _methods_DeleteSmsMessageOperation[] = {
        { "cancel", reinterpret_cast<PyCFunction>(DeleteSmsMessageOperation_Cancel), METH_VARARGS, nullptr },
        { "close", reinterpret_cast<PyCFunction>(DeleteSmsMessageOperation_Close), METH_VARARGS, nullptr },
        { "get_results", reinterpret_cast<PyCFunction>(DeleteSmsMessageOperation_GetResults), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_DeleteSmsMessageOperation, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DeleteSmsMessageOperation), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_DeleteSmsMessageOperation[] = {
        { "error_code", reinterpret_cast<getter>(DeleteSmsMessageOperation_get_ErrorCode), nullptr, nullptr, nullptr },
        { "id", reinterpret_cast<getter>(DeleteSmsMessageOperation_get_Id), nullptr, nullptr, nullptr },
        { "status", reinterpret_cast<getter>(DeleteSmsMessageOperation_get_Status), nullptr, nullptr, nullptr },
        { "completed", reinterpret_cast<getter>(DeleteSmsMessageOperation_get_Completed), reinterpret_cast<setter>(DeleteSmsMessageOperation_put_Completed), nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_DeleteSmsMessageOperation[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_DeleteSmsMessageOperation) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_DeleteSmsMessageOperation) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_DeleteSmsMessageOperation) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_DeleteSmsMessageOperation) },
        { Py_am_await, reinterpret_cast<void*>(_await_DeleteSmsMessageOperation) },
        { }};

    static PyType_Spec type_spec_DeleteSmsMessageOperation = {
        "winrt._winrt_windows_devices_sms.DeleteSmsMessageOperation",
        sizeof(py::wrapper::Windows::Devices::Sms::DeleteSmsMessageOperation),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DeleteSmsMessageOperation};

    // ----- DeleteSmsMessagesOperation class --------------------

    static PyObject* _new_DeleteSmsMessagesOperation(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Sms::DeleteSmsMessagesOperation>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Sms::DeleteSmsMessagesOperation>::type_name);
        return nullptr;
    }

    static void _dealloc_DeleteSmsMessagesOperation(py::wrapper::Windows::Devices::Sms::DeleteSmsMessagesOperation* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* DeleteSmsMessagesOperation_Cancel(py::wrapper::Windows::Devices::Sms::DeleteSmsMessagesOperation* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sms.DeleteSmsMessagesOperation", L"Cancel", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.Cancel();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DeleteSmsMessagesOperation_Close(py::wrapper::Windows::Devices::Sms::DeleteSmsMessagesOperation* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sms.DeleteSmsMessagesOperation", L"Close", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.Close();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DeleteSmsMessagesOperation_GetResults(py::wrapper::Windows::Devices::Sms::DeleteSmsMessagesOperation* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sms.DeleteSmsMessagesOperation", L"GetResults", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.GetResults();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DeleteSmsMessagesOperation_get_ErrorCode(py::wrapper::Windows::Devices::Sms::DeleteSmsMessagesOperation* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.DeleteSmsMessagesOperation", L"ErrorCode");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ErrorCode();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DeleteSmsMessagesOperation_get_Id(py::wrapper::Windows::Devices::Sms::DeleteSmsMessagesOperation* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.DeleteSmsMessagesOperation", L"Id");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Id();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DeleteSmsMessagesOperation_get_Status(py::wrapper::Windows::Devices::Sms::DeleteSmsMessagesOperation* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.DeleteSmsMessagesOperation", L"Status");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Status();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DeleteSmsMessagesOperation_get_Completed(py::wrapper::Windows::Devices::Sms::DeleteSmsMessagesOperation* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.DeleteSmsMessagesOperation", L"Completed");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Completed();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DeleteSmsMessagesOperation_put_Completed(py::wrapper::Windows::Devices::Sms::DeleteSmsMessagesOperation* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.DeleteSmsMessagesOperation", L"Completed");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::AsyncActionCompletedHandler>(arg);

            {
                auto _gil = release_gil();
                self->obj.Completed(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_DeleteSmsMessagesOperation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Sms::DeleteSmsMessagesOperation>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_DeleteSmsMessagesOperation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sms::DeleteSmsMessagesOperation>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _await_DeleteSmsMessagesOperation(py::wrapper::Windows::Devices::Sms::DeleteSmsMessagesOperation* self) noexcept
    {
        return py::dunder_await(self->obj);
    }

    static PyMethodDef _methods_DeleteSmsMessagesOperation[] = {
        { "cancel", reinterpret_cast<PyCFunction>(DeleteSmsMessagesOperation_Cancel), METH_VARARGS, nullptr },
        { "close", reinterpret_cast<PyCFunction>(DeleteSmsMessagesOperation_Close), METH_VARARGS, nullptr },
        { "get_results", reinterpret_cast<PyCFunction>(DeleteSmsMessagesOperation_GetResults), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_DeleteSmsMessagesOperation, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DeleteSmsMessagesOperation), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_DeleteSmsMessagesOperation[] = {
        { "error_code", reinterpret_cast<getter>(DeleteSmsMessagesOperation_get_ErrorCode), nullptr, nullptr, nullptr },
        { "id", reinterpret_cast<getter>(DeleteSmsMessagesOperation_get_Id), nullptr, nullptr, nullptr },
        { "status", reinterpret_cast<getter>(DeleteSmsMessagesOperation_get_Status), nullptr, nullptr, nullptr },
        { "completed", reinterpret_cast<getter>(DeleteSmsMessagesOperation_get_Completed), reinterpret_cast<setter>(DeleteSmsMessagesOperation_put_Completed), nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_DeleteSmsMessagesOperation[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_DeleteSmsMessagesOperation) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_DeleteSmsMessagesOperation) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_DeleteSmsMessagesOperation) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_DeleteSmsMessagesOperation) },
        { Py_am_await, reinterpret_cast<void*>(_await_DeleteSmsMessagesOperation) },
        { }};

    static PyType_Spec type_spec_DeleteSmsMessagesOperation = {
        "winrt._winrt_windows_devices_sms.DeleteSmsMessagesOperation",
        sizeof(py::wrapper::Windows::Devices::Sms::DeleteSmsMessagesOperation),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DeleteSmsMessagesOperation};

    // ----- GetSmsDeviceOperation class --------------------

    static PyObject* _new_GetSmsDeviceOperation(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Sms::GetSmsDeviceOperation>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Sms::GetSmsDeviceOperation>::type_name);
        return nullptr;
    }

    static void _dealloc_GetSmsDeviceOperation(py::wrapper::Windows::Devices::Sms::GetSmsDeviceOperation* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* GetSmsDeviceOperation_Cancel(py::wrapper::Windows::Devices::Sms::GetSmsDeviceOperation* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sms.GetSmsDeviceOperation", L"Cancel", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.Cancel();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GetSmsDeviceOperation_Close(py::wrapper::Windows::Devices::Sms::GetSmsDeviceOperation* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sms.GetSmsDeviceOperation", L"Close", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.Close();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GetSmsDeviceOperation_GetResults(py::wrapper::Windows::Devices::Sms::GetSmsDeviceOperation* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sms.GetSmsDeviceOperation", L"GetResults", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetResults();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GetSmsDeviceOperation_get_ErrorCode(py::wrapper::Windows::Devices::Sms::GetSmsDeviceOperation* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.GetSmsDeviceOperation", L"ErrorCode");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ErrorCode();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GetSmsDeviceOperation_get_Id(py::wrapper::Windows::Devices::Sms::GetSmsDeviceOperation* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.GetSmsDeviceOperation", L"Id");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Id();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GetSmsDeviceOperation_get_Status(py::wrapper::Windows::Devices::Sms::GetSmsDeviceOperation* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.GetSmsDeviceOperation", L"Status");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Status();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GetSmsDeviceOperation_get_Completed(py::wrapper::Windows::Devices::Sms::GetSmsDeviceOperation* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.GetSmsDeviceOperation", L"Completed");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Completed();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GetSmsDeviceOperation_put_Completed(py::wrapper::Windows::Devices::Sms::GetSmsDeviceOperation* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.GetSmsDeviceOperation", L"Completed");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::AsyncOperationCompletedHandler<winrt::Windows::Devices::Sms::SmsDevice>>(arg);

            {
                auto _gil = release_gil();
                self->obj.Completed(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_GetSmsDeviceOperation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Sms::GetSmsDeviceOperation>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_GetSmsDeviceOperation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sms::GetSmsDeviceOperation>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _await_GetSmsDeviceOperation(py::wrapper::Windows::Devices::Sms::GetSmsDeviceOperation* self) noexcept
    {
        return py::dunder_await(self->obj);
    }

    static PyMethodDef _methods_GetSmsDeviceOperation[] = {
        { "cancel", reinterpret_cast<PyCFunction>(GetSmsDeviceOperation_Cancel), METH_VARARGS, nullptr },
        { "close", reinterpret_cast<PyCFunction>(GetSmsDeviceOperation_Close), METH_VARARGS, nullptr },
        { "get_results", reinterpret_cast<PyCFunction>(GetSmsDeviceOperation_GetResults), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_GetSmsDeviceOperation, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_GetSmsDeviceOperation), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_GetSmsDeviceOperation[] = {
        { "error_code", reinterpret_cast<getter>(GetSmsDeviceOperation_get_ErrorCode), nullptr, nullptr, nullptr },
        { "id", reinterpret_cast<getter>(GetSmsDeviceOperation_get_Id), nullptr, nullptr, nullptr },
        { "status", reinterpret_cast<getter>(GetSmsDeviceOperation_get_Status), nullptr, nullptr, nullptr },
        { "completed", reinterpret_cast<getter>(GetSmsDeviceOperation_get_Completed), reinterpret_cast<setter>(GetSmsDeviceOperation_put_Completed), nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_GetSmsDeviceOperation[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_GetSmsDeviceOperation) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_GetSmsDeviceOperation) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_GetSmsDeviceOperation) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_GetSmsDeviceOperation) },
        { Py_am_await, reinterpret_cast<void*>(_await_GetSmsDeviceOperation) },
        { }};

    static PyType_Spec type_spec_GetSmsDeviceOperation = {
        "winrt._winrt_windows_devices_sms.GetSmsDeviceOperation",
        sizeof(py::wrapper::Windows::Devices::Sms::GetSmsDeviceOperation),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_GetSmsDeviceOperation};

    // ----- GetSmsMessageOperation class --------------------

    static PyObject* _new_GetSmsMessageOperation(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Sms::GetSmsMessageOperation>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Sms::GetSmsMessageOperation>::type_name);
        return nullptr;
    }

    static void _dealloc_GetSmsMessageOperation(py::wrapper::Windows::Devices::Sms::GetSmsMessageOperation* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* GetSmsMessageOperation_Cancel(py::wrapper::Windows::Devices::Sms::GetSmsMessageOperation* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sms.GetSmsMessageOperation", L"Cancel", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.Cancel();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GetSmsMessageOperation_Close(py::wrapper::Windows::Devices::Sms::GetSmsMessageOperation* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sms.GetSmsMessageOperation", L"Close", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.Close();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GetSmsMessageOperation_GetResults(py::wrapper::Windows::Devices::Sms::GetSmsMessageOperation* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sms.GetSmsMessageOperation", L"GetResults", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetResults();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GetSmsMessageOperation_get_ErrorCode(py::wrapper::Windows::Devices::Sms::GetSmsMessageOperation* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.GetSmsMessageOperation", L"ErrorCode");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ErrorCode();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GetSmsMessageOperation_get_Id(py::wrapper::Windows::Devices::Sms::GetSmsMessageOperation* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.GetSmsMessageOperation", L"Id");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Id();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GetSmsMessageOperation_get_Status(py::wrapper::Windows::Devices::Sms::GetSmsMessageOperation* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.GetSmsMessageOperation", L"Status");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Status();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GetSmsMessageOperation_get_Completed(py::wrapper::Windows::Devices::Sms::GetSmsMessageOperation* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.GetSmsMessageOperation", L"Completed");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Completed();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GetSmsMessageOperation_put_Completed(py::wrapper::Windows::Devices::Sms::GetSmsMessageOperation* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.GetSmsMessageOperation", L"Completed");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::AsyncOperationCompletedHandler<winrt::Windows::Devices::Sms::ISmsMessage>>(arg);

            {
                auto _gil = release_gil();
                self->obj.Completed(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_GetSmsMessageOperation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Sms::GetSmsMessageOperation>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_GetSmsMessageOperation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sms::GetSmsMessageOperation>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _await_GetSmsMessageOperation(py::wrapper::Windows::Devices::Sms::GetSmsMessageOperation* self) noexcept
    {
        return py::dunder_await(self->obj);
    }

    static PyMethodDef _methods_GetSmsMessageOperation[] = {
        { "cancel", reinterpret_cast<PyCFunction>(GetSmsMessageOperation_Cancel), METH_VARARGS, nullptr },
        { "close", reinterpret_cast<PyCFunction>(GetSmsMessageOperation_Close), METH_VARARGS, nullptr },
        { "get_results", reinterpret_cast<PyCFunction>(GetSmsMessageOperation_GetResults), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_GetSmsMessageOperation, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_GetSmsMessageOperation), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_GetSmsMessageOperation[] = {
        { "error_code", reinterpret_cast<getter>(GetSmsMessageOperation_get_ErrorCode), nullptr, nullptr, nullptr },
        { "id", reinterpret_cast<getter>(GetSmsMessageOperation_get_Id), nullptr, nullptr, nullptr },
        { "status", reinterpret_cast<getter>(GetSmsMessageOperation_get_Status), nullptr, nullptr, nullptr },
        { "completed", reinterpret_cast<getter>(GetSmsMessageOperation_get_Completed), reinterpret_cast<setter>(GetSmsMessageOperation_put_Completed), nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_GetSmsMessageOperation[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_GetSmsMessageOperation) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_GetSmsMessageOperation) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_GetSmsMessageOperation) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_GetSmsMessageOperation) },
        { Py_am_await, reinterpret_cast<void*>(_await_GetSmsMessageOperation) },
        { }};

    static PyType_Spec type_spec_GetSmsMessageOperation = {
        "winrt._winrt_windows_devices_sms.GetSmsMessageOperation",
        sizeof(py::wrapper::Windows::Devices::Sms::GetSmsMessageOperation),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_GetSmsMessageOperation};

    // ----- GetSmsMessagesOperation class --------------------

    static PyObject* _new_GetSmsMessagesOperation(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Sms::GetSmsMessagesOperation>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Sms::GetSmsMessagesOperation>::type_name);
        return nullptr;
    }

    static void _dealloc_GetSmsMessagesOperation(py::wrapper::Windows::Devices::Sms::GetSmsMessagesOperation* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* GetSmsMessagesOperation_Cancel(py::wrapper::Windows::Devices::Sms::GetSmsMessagesOperation* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sms.GetSmsMessagesOperation", L"Cancel", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.Cancel();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GetSmsMessagesOperation_Close(py::wrapper::Windows::Devices::Sms::GetSmsMessagesOperation* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sms.GetSmsMessagesOperation", L"Close", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.Close();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GetSmsMessagesOperation_GetResults(py::wrapper::Windows::Devices::Sms::GetSmsMessagesOperation* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sms.GetSmsMessagesOperation", L"GetResults", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetResults();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GetSmsMessagesOperation_get_ErrorCode(py::wrapper::Windows::Devices::Sms::GetSmsMessagesOperation* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.GetSmsMessagesOperation", L"ErrorCode");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ErrorCode();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GetSmsMessagesOperation_get_Id(py::wrapper::Windows::Devices::Sms::GetSmsMessagesOperation* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.GetSmsMessagesOperation", L"Id");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Id();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GetSmsMessagesOperation_get_Status(py::wrapper::Windows::Devices::Sms::GetSmsMessagesOperation* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.GetSmsMessagesOperation", L"Status");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Status();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GetSmsMessagesOperation_get_Progress(py::wrapper::Windows::Devices::Sms::GetSmsMessagesOperation* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.GetSmsMessagesOperation", L"Progress");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Progress();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GetSmsMessagesOperation_put_Progress(py::wrapper::Windows::Devices::Sms::GetSmsMessagesOperation* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.GetSmsMessagesOperation", L"Progress");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::AsyncOperationProgressHandler<winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::Devices::Sms::ISmsMessage>, int32_t>>(arg);

            {
                auto _gil = release_gil();
                self->obj.Progress(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* GetSmsMessagesOperation_get_Completed(py::wrapper::Windows::Devices::Sms::GetSmsMessagesOperation* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.GetSmsMessagesOperation", L"Completed");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Completed();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GetSmsMessagesOperation_put_Completed(py::wrapper::Windows::Devices::Sms::GetSmsMessagesOperation* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.GetSmsMessagesOperation", L"Completed");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::AsyncOperationWithProgressCompletedHandler<winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::Devices::Sms::ISmsMessage>, int32_t>>(arg);

            {
                auto _gil = release_gil();
                self->obj.Completed(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_GetSmsMessagesOperation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Sms::GetSmsMessagesOperation>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_GetSmsMessagesOperation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sms::GetSmsMessagesOperation>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _await_GetSmsMessagesOperation(py::wrapper::Windows::Devices::Sms::GetSmsMessagesOperation* self) noexcept
    {
        return py::dunder_await(self->obj);
    }

    static PyMethodDef _methods_GetSmsMessagesOperation[] = {
        { "cancel", reinterpret_cast<PyCFunction>(GetSmsMessagesOperation_Cancel), METH_VARARGS, nullptr },
        { "close", reinterpret_cast<PyCFunction>(GetSmsMessagesOperation_Close), METH_VARARGS, nullptr },
        { "get_results", reinterpret_cast<PyCFunction>(GetSmsMessagesOperation_GetResults), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_GetSmsMessagesOperation, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_GetSmsMessagesOperation), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_GetSmsMessagesOperation[] = {
        { "error_code", reinterpret_cast<getter>(GetSmsMessagesOperation_get_ErrorCode), nullptr, nullptr, nullptr },
        { "id", reinterpret_cast<getter>(GetSmsMessagesOperation_get_Id), nullptr, nullptr, nullptr },
        { "status", reinterpret_cast<getter>(GetSmsMessagesOperation_get_Status), nullptr, nullptr, nullptr },
        { "progress", reinterpret_cast<getter>(GetSmsMessagesOperation_get_Progress), reinterpret_cast<setter>(GetSmsMessagesOperation_put_Progress), nullptr, nullptr },
        { "completed", reinterpret_cast<getter>(GetSmsMessagesOperation_get_Completed), reinterpret_cast<setter>(GetSmsMessagesOperation_put_Completed), nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_GetSmsMessagesOperation[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_GetSmsMessagesOperation) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_GetSmsMessagesOperation) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_GetSmsMessagesOperation) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_GetSmsMessagesOperation) },
        { Py_am_await, reinterpret_cast<void*>(_await_GetSmsMessagesOperation) },
        { }};

    static PyType_Spec type_spec_GetSmsMessagesOperation = {
        "winrt._winrt_windows_devices_sms.GetSmsMessagesOperation",
        sizeof(py::wrapper::Windows::Devices::Sms::GetSmsMessagesOperation),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_GetSmsMessagesOperation};

    // ----- SendSmsMessageOperation class --------------------

    static PyObject* _new_SendSmsMessageOperation(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Sms::SendSmsMessageOperation>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Sms::SendSmsMessageOperation>::type_name);
        return nullptr;
    }

    static void _dealloc_SendSmsMessageOperation(py::wrapper::Windows::Devices::Sms::SendSmsMessageOperation* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SendSmsMessageOperation_Cancel(py::wrapper::Windows::Devices::Sms::SendSmsMessageOperation* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sms.SendSmsMessageOperation", L"Cancel", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.Cancel();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SendSmsMessageOperation_Close(py::wrapper::Windows::Devices::Sms::SendSmsMessageOperation* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sms.SendSmsMessageOperation", L"Close", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.Close();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SendSmsMessageOperation_GetResults(py::wrapper::Windows::Devices::Sms::SendSmsMessageOperation* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sms.SendSmsMessageOperation", L"GetResults", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.GetResults();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SendSmsMessageOperation_get_ErrorCode(py::wrapper::Windows::Devices::Sms::SendSmsMessageOperation* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SendSmsMessageOperation", L"ErrorCode");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ErrorCode();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SendSmsMessageOperation_get_Id(py::wrapper::Windows::Devices::Sms::SendSmsMessageOperation* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SendSmsMessageOperation", L"Id");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Id();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SendSmsMessageOperation_get_Status(py::wrapper::Windows::Devices::Sms::SendSmsMessageOperation* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SendSmsMessageOperation", L"Status");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Status();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SendSmsMessageOperation_get_Completed(py::wrapper::Windows::Devices::Sms::SendSmsMessageOperation* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SendSmsMessageOperation", L"Completed");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Completed();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SendSmsMessageOperation_put_Completed(py::wrapper::Windows::Devices::Sms::SendSmsMessageOperation* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SendSmsMessageOperation", L"Completed");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::AsyncActionCompletedHandler>(arg);

            {
                auto _gil = release_gil();
                self->obj.Completed(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_SendSmsMessageOperation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Sms::SendSmsMessageOperation>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SendSmsMessageOperation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sms::SendSmsMessageOperation>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _await_SendSmsMessageOperation(py::wrapper::Windows::Devices::Sms::SendSmsMessageOperation* self) noexcept
    {
        return py::dunder_await(self->obj);
    }

    static PyMethodDef _methods_SendSmsMessageOperation[] = {
        { "cancel", reinterpret_cast<PyCFunction>(SendSmsMessageOperation_Cancel), METH_VARARGS, nullptr },
        { "close", reinterpret_cast<PyCFunction>(SendSmsMessageOperation_Close), METH_VARARGS, nullptr },
        { "get_results", reinterpret_cast<PyCFunction>(SendSmsMessageOperation_GetResults), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_SendSmsMessageOperation, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SendSmsMessageOperation), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_SendSmsMessageOperation[] = {
        { "error_code", reinterpret_cast<getter>(SendSmsMessageOperation_get_ErrorCode), nullptr, nullptr, nullptr },
        { "id", reinterpret_cast<getter>(SendSmsMessageOperation_get_Id), nullptr, nullptr, nullptr },
        { "status", reinterpret_cast<getter>(SendSmsMessageOperation_get_Status), nullptr, nullptr, nullptr },
        { "completed", reinterpret_cast<getter>(SendSmsMessageOperation_get_Completed), reinterpret_cast<setter>(SendSmsMessageOperation_put_Completed), nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_SendSmsMessageOperation[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_SendSmsMessageOperation) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SendSmsMessageOperation) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SendSmsMessageOperation) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SendSmsMessageOperation) },
        { Py_am_await, reinterpret_cast<void*>(_await_SendSmsMessageOperation) },
        { }};

    static PyType_Spec type_spec_SendSmsMessageOperation = {
        "winrt._winrt_windows_devices_sms.SendSmsMessageOperation",
        sizeof(py::wrapper::Windows::Devices::Sms::SendSmsMessageOperation),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SendSmsMessageOperation};

    // ----- SmsAppMessage class --------------------

    static PyObject* _new_SmsAppMessage(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Devices::Sms::SmsAppMessage instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_SmsAppMessage(py::wrapper::Windows::Devices::Sms::SmsAppMessage* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SmsAppMessage_get_ProtocolId(py::wrapper::Windows::Devices::Sms::SmsAppMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsAppMessage", L"ProtocolId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ProtocolId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SmsAppMessage_put_ProtocolId(py::wrapper::Windows::Devices::Sms::SmsAppMessage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsAppMessage", L"ProtocolId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<int32_t>(arg);

            {
                auto _gil = release_gil();
                self->obj.ProtocolId(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SmsAppMessage_get_PortNumber(py::wrapper::Windows::Devices::Sms::SmsAppMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsAppMessage", L"PortNumber");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PortNumber();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SmsAppMessage_put_PortNumber(py::wrapper::Windows::Devices::Sms::SmsAppMessage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsAppMessage", L"PortNumber");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<int32_t>(arg);

            {
                auto _gil = release_gil();
                self->obj.PortNumber(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SmsAppMessage_get_IsDeliveryNotificationEnabled(py::wrapper::Windows::Devices::Sms::SmsAppMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsAppMessage", L"IsDeliveryNotificationEnabled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsDeliveryNotificationEnabled();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SmsAppMessage_put_IsDeliveryNotificationEnabled(py::wrapper::Windows::Devices::Sms::SmsAppMessage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsAppMessage", L"IsDeliveryNotificationEnabled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.IsDeliveryNotificationEnabled(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SmsAppMessage_get_RetryAttemptCount(py::wrapper::Windows::Devices::Sms::SmsAppMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsAppMessage", L"RetryAttemptCount");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.RetryAttemptCount();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SmsAppMessage_put_RetryAttemptCount(py::wrapper::Windows::Devices::Sms::SmsAppMessage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsAppMessage", L"RetryAttemptCount");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<int32_t>(arg);

            {
                auto _gil = release_gil();
                self->obj.RetryAttemptCount(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SmsAppMessage_get_Encoding(py::wrapper::Windows::Devices::Sms::SmsAppMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsAppMessage", L"Encoding");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Encoding();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SmsAppMessage_put_Encoding(py::wrapper::Windows::Devices::Sms::SmsAppMessage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsAppMessage", L"Encoding");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Devices::Sms::SmsEncoding>(arg);

            {
                auto _gil = release_gil();
                self->obj.Encoding(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SmsAppMessage_get_Body(py::wrapper::Windows::Devices::Sms::SmsAppMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsAppMessage", L"Body");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Body();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SmsAppMessage_put_Body(py::wrapper::Windows::Devices::Sms::SmsAppMessage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsAppMessage", L"Body");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            {
                auto _gil = release_gil();
                self->obj.Body(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SmsAppMessage_get_CallbackNumber(py::wrapper::Windows::Devices::Sms::SmsAppMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsAppMessage", L"CallbackNumber");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.CallbackNumber();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SmsAppMessage_put_CallbackNumber(py::wrapper::Windows::Devices::Sms::SmsAppMessage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsAppMessage", L"CallbackNumber");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            {
                auto _gil = release_gil();
                self->obj.CallbackNumber(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SmsAppMessage_get_BinaryBody(py::wrapper::Windows::Devices::Sms::SmsAppMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsAppMessage", L"BinaryBody");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.BinaryBody();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SmsAppMessage_put_BinaryBody(py::wrapper::Windows::Devices::Sms::SmsAppMessage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsAppMessage", L"BinaryBody");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(arg);

            {
                auto _gil = release_gil();
                self->obj.BinaryBody(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SmsAppMessage_get_To(py::wrapper::Windows::Devices::Sms::SmsAppMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsAppMessage", L"To");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.To();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SmsAppMessage_put_To(py::wrapper::Windows::Devices::Sms::SmsAppMessage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsAppMessage", L"To");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            {
                auto _gil = release_gil();
                self->obj.To(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SmsAppMessage_get_TeleserviceId(py::wrapper::Windows::Devices::Sms::SmsAppMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsAppMessage", L"TeleserviceId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.TeleserviceId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SmsAppMessage_put_TeleserviceId(py::wrapper::Windows::Devices::Sms::SmsAppMessage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsAppMessage", L"TeleserviceId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<int32_t>(arg);

            {
                auto _gil = release_gil();
                self->obj.TeleserviceId(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SmsAppMessage_get_From(py::wrapper::Windows::Devices::Sms::SmsAppMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsAppMessage", L"From");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.From();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsAppMessage_get_Timestamp(py::wrapper::Windows::Devices::Sms::SmsAppMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsAppMessage", L"Timestamp");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Timestamp();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsAppMessage_get_CellularClass(py::wrapper::Windows::Devices::Sms::SmsAppMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsAppMessage", L"CellularClass");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.CellularClass();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsAppMessage_get_DeviceId(py::wrapper::Windows::Devices::Sms::SmsAppMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsAppMessage", L"DeviceId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.DeviceId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsAppMessage_get_MessageClass(py::wrapper::Windows::Devices::Sms::SmsAppMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsAppMessage", L"MessageClass");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.MessageClass();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsAppMessage_get_MessageType(py::wrapper::Windows::Devices::Sms::SmsAppMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsAppMessage", L"MessageType");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.MessageType();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsAppMessage_get_SimIccId(py::wrapper::Windows::Devices::Sms::SmsAppMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsAppMessage", L"SimIccId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SimIccId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SmsAppMessage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Sms::SmsAppMessage>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SmsAppMessage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sms::SmsAppMessage>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SmsAppMessage[] = {
        { "_assign_array_", _assign_array_SmsAppMessage, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SmsAppMessage), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_SmsAppMessage[] = {
        { "protocol_id", reinterpret_cast<getter>(SmsAppMessage_get_ProtocolId), reinterpret_cast<setter>(SmsAppMessage_put_ProtocolId), nullptr, nullptr },
        { "port_number", reinterpret_cast<getter>(SmsAppMessage_get_PortNumber), reinterpret_cast<setter>(SmsAppMessage_put_PortNumber), nullptr, nullptr },
        { "is_delivery_notification_enabled", reinterpret_cast<getter>(SmsAppMessage_get_IsDeliveryNotificationEnabled), reinterpret_cast<setter>(SmsAppMessage_put_IsDeliveryNotificationEnabled), nullptr, nullptr },
        { "retry_attempt_count", reinterpret_cast<getter>(SmsAppMessage_get_RetryAttemptCount), reinterpret_cast<setter>(SmsAppMessage_put_RetryAttemptCount), nullptr, nullptr },
        { "encoding", reinterpret_cast<getter>(SmsAppMessage_get_Encoding), reinterpret_cast<setter>(SmsAppMessage_put_Encoding), nullptr, nullptr },
        { "body", reinterpret_cast<getter>(SmsAppMessage_get_Body), reinterpret_cast<setter>(SmsAppMessage_put_Body), nullptr, nullptr },
        { "callback_number", reinterpret_cast<getter>(SmsAppMessage_get_CallbackNumber), reinterpret_cast<setter>(SmsAppMessage_put_CallbackNumber), nullptr, nullptr },
        { "binary_body", reinterpret_cast<getter>(SmsAppMessage_get_BinaryBody), reinterpret_cast<setter>(SmsAppMessage_put_BinaryBody), nullptr, nullptr },
        { "to", reinterpret_cast<getter>(SmsAppMessage_get_To), reinterpret_cast<setter>(SmsAppMessage_put_To), nullptr, nullptr },
        { "teleservice_id", reinterpret_cast<getter>(SmsAppMessage_get_TeleserviceId), reinterpret_cast<setter>(SmsAppMessage_put_TeleserviceId), nullptr, nullptr },
        { "from_", reinterpret_cast<getter>(SmsAppMessage_get_From), nullptr, nullptr, nullptr },
        { "timestamp", reinterpret_cast<getter>(SmsAppMessage_get_Timestamp), nullptr, nullptr, nullptr },
        { "cellular_class", reinterpret_cast<getter>(SmsAppMessage_get_CellularClass), nullptr, nullptr, nullptr },
        { "device_id", reinterpret_cast<getter>(SmsAppMessage_get_DeviceId), nullptr, nullptr, nullptr },
        { "message_class", reinterpret_cast<getter>(SmsAppMessage_get_MessageClass), nullptr, nullptr, nullptr },
        { "message_type", reinterpret_cast<getter>(SmsAppMessage_get_MessageType), nullptr, nullptr, nullptr },
        { "sim_icc_id", reinterpret_cast<getter>(SmsAppMessage_get_SimIccId), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_SmsAppMessage[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_SmsAppMessage) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SmsAppMessage) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SmsAppMessage) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SmsAppMessage) },
        { }};

    static PyType_Spec type_spec_SmsAppMessage = {
        "winrt._winrt_windows_devices_sms.SmsAppMessage",
        sizeof(py::wrapper::Windows::Devices::Sms::SmsAppMessage),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SmsAppMessage};

    // ----- SmsBinaryMessage class --------------------

    static PyObject* _new_SmsBinaryMessage(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Devices::Sms::SmsBinaryMessage instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_SmsBinaryMessage(py::wrapper::Windows::Devices::Sms::SmsBinaryMessage* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SmsBinaryMessage_GetData(py::wrapper::Windows::Devices::Sms::SmsBinaryMessage* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sms.SmsBinaryMessage", L"GetData", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetData();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SmsBinaryMessage_SetData(py::wrapper::Windows::Devices::Sms::SmsBinaryMessage* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sms.SmsBinaryMessage", L"SetData", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<py::pybuf_view<uint8_t, false>>(args, 0);

                {
                    auto _gil = release_gil();
                    self->obj.SetData(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SmsBinaryMessage_get_Format(py::wrapper::Windows::Devices::Sms::SmsBinaryMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsBinaryMessage", L"Format");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Format();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SmsBinaryMessage_put_Format(py::wrapper::Windows::Devices::Sms::SmsBinaryMessage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsBinaryMessage", L"Format");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Devices::Sms::SmsDataFormat>(arg);

            {
                auto _gil = release_gil();
                self->obj.Format(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SmsBinaryMessage_get_Id(py::wrapper::Windows::Devices::Sms::SmsBinaryMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsBinaryMessage", L"Id");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Id();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsBinaryMessage_get_MessageClass(py::wrapper::Windows::Devices::Sms::SmsBinaryMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsBinaryMessage", L"MessageClass");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.MessageClass();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SmsBinaryMessage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Sms::SmsBinaryMessage>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SmsBinaryMessage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sms::SmsBinaryMessage>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SmsBinaryMessage[] = {
        { "get_data", reinterpret_cast<PyCFunction>(SmsBinaryMessage_GetData), METH_VARARGS, nullptr },
        { "set_data", reinterpret_cast<PyCFunction>(SmsBinaryMessage_SetData), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_SmsBinaryMessage, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SmsBinaryMessage), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_SmsBinaryMessage[] = {
        { "format", reinterpret_cast<getter>(SmsBinaryMessage_get_Format), reinterpret_cast<setter>(SmsBinaryMessage_put_Format), nullptr, nullptr },
        { "id", reinterpret_cast<getter>(SmsBinaryMessage_get_Id), nullptr, nullptr, nullptr },
        { "message_class", reinterpret_cast<getter>(SmsBinaryMessage_get_MessageClass), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_SmsBinaryMessage[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_SmsBinaryMessage) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SmsBinaryMessage) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SmsBinaryMessage) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SmsBinaryMessage) },
        { }};

    static PyType_Spec type_spec_SmsBinaryMessage = {
        "winrt._winrt_windows_devices_sms.SmsBinaryMessage",
        sizeof(py::wrapper::Windows::Devices::Sms::SmsBinaryMessage),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SmsBinaryMessage};

    // ----- SmsBroadcastMessage class --------------------

    static PyObject* _new_SmsBroadcastMessage(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Sms::SmsBroadcastMessage>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Sms::SmsBroadcastMessage>::type_name);
        return nullptr;
    }

    static void _dealloc_SmsBroadcastMessage(py::wrapper::Windows::Devices::Sms::SmsBroadcastMessage* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SmsBroadcastMessage_get_Body(py::wrapper::Windows::Devices::Sms::SmsBroadcastMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsBroadcastMessage", L"Body");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Body();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsBroadcastMessage_get_BroadcastType(py::wrapper::Windows::Devices::Sms::SmsBroadcastMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsBroadcastMessage", L"BroadcastType");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.BroadcastType();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsBroadcastMessage_get_Channel(py::wrapper::Windows::Devices::Sms::SmsBroadcastMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsBroadcastMessage", L"Channel");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Channel();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsBroadcastMessage_get_GeographicalScope(py::wrapper::Windows::Devices::Sms::SmsBroadcastMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsBroadcastMessage", L"GeographicalScope");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.GeographicalScope();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsBroadcastMessage_get_IsEmergencyAlert(py::wrapper::Windows::Devices::Sms::SmsBroadcastMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsBroadcastMessage", L"IsEmergencyAlert");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsEmergencyAlert();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsBroadcastMessage_get_IsUserPopupRequested(py::wrapper::Windows::Devices::Sms::SmsBroadcastMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsBroadcastMessage", L"IsUserPopupRequested");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsUserPopupRequested();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsBroadcastMessage_get_MessageCode(py::wrapper::Windows::Devices::Sms::SmsBroadcastMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsBroadcastMessage", L"MessageCode");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.MessageCode();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsBroadcastMessage_get_Timestamp(py::wrapper::Windows::Devices::Sms::SmsBroadcastMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsBroadcastMessage", L"Timestamp");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Timestamp();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsBroadcastMessage_get_To(py::wrapper::Windows::Devices::Sms::SmsBroadcastMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsBroadcastMessage", L"To");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.To();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsBroadcastMessage_get_UpdateNumber(py::wrapper::Windows::Devices::Sms::SmsBroadcastMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsBroadcastMessage", L"UpdateNumber");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.UpdateNumber();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsBroadcastMessage_get_CellularClass(py::wrapper::Windows::Devices::Sms::SmsBroadcastMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsBroadcastMessage", L"CellularClass");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.CellularClass();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsBroadcastMessage_get_DeviceId(py::wrapper::Windows::Devices::Sms::SmsBroadcastMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsBroadcastMessage", L"DeviceId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.DeviceId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsBroadcastMessage_get_MessageClass(py::wrapper::Windows::Devices::Sms::SmsBroadcastMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsBroadcastMessage", L"MessageClass");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.MessageClass();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsBroadcastMessage_get_MessageType(py::wrapper::Windows::Devices::Sms::SmsBroadcastMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsBroadcastMessage", L"MessageType");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.MessageType();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsBroadcastMessage_get_SimIccId(py::wrapper::Windows::Devices::Sms::SmsBroadcastMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsBroadcastMessage", L"SimIccId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SimIccId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SmsBroadcastMessage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Sms::SmsBroadcastMessage>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SmsBroadcastMessage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sms::SmsBroadcastMessage>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SmsBroadcastMessage[] = {
        { "_assign_array_", _assign_array_SmsBroadcastMessage, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SmsBroadcastMessage), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_SmsBroadcastMessage[] = {
        { "body", reinterpret_cast<getter>(SmsBroadcastMessage_get_Body), nullptr, nullptr, nullptr },
        { "broadcast_type", reinterpret_cast<getter>(SmsBroadcastMessage_get_BroadcastType), nullptr, nullptr, nullptr },
        { "channel", reinterpret_cast<getter>(SmsBroadcastMessage_get_Channel), nullptr, nullptr, nullptr },
        { "geographical_scope", reinterpret_cast<getter>(SmsBroadcastMessage_get_GeographicalScope), nullptr, nullptr, nullptr },
        { "is_emergency_alert", reinterpret_cast<getter>(SmsBroadcastMessage_get_IsEmergencyAlert), nullptr, nullptr, nullptr },
        { "is_user_popup_requested", reinterpret_cast<getter>(SmsBroadcastMessage_get_IsUserPopupRequested), nullptr, nullptr, nullptr },
        { "message_code", reinterpret_cast<getter>(SmsBroadcastMessage_get_MessageCode), nullptr, nullptr, nullptr },
        { "timestamp", reinterpret_cast<getter>(SmsBroadcastMessage_get_Timestamp), nullptr, nullptr, nullptr },
        { "to", reinterpret_cast<getter>(SmsBroadcastMessage_get_To), nullptr, nullptr, nullptr },
        { "update_number", reinterpret_cast<getter>(SmsBroadcastMessage_get_UpdateNumber), nullptr, nullptr, nullptr },
        { "cellular_class", reinterpret_cast<getter>(SmsBroadcastMessage_get_CellularClass), nullptr, nullptr, nullptr },
        { "device_id", reinterpret_cast<getter>(SmsBroadcastMessage_get_DeviceId), nullptr, nullptr, nullptr },
        { "message_class", reinterpret_cast<getter>(SmsBroadcastMessage_get_MessageClass), nullptr, nullptr, nullptr },
        { "message_type", reinterpret_cast<getter>(SmsBroadcastMessage_get_MessageType), nullptr, nullptr, nullptr },
        { "sim_icc_id", reinterpret_cast<getter>(SmsBroadcastMessage_get_SimIccId), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_SmsBroadcastMessage[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_SmsBroadcastMessage) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SmsBroadcastMessage) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SmsBroadcastMessage) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SmsBroadcastMessage) },
        { }};

    static PyType_Spec type_spec_SmsBroadcastMessage = {
        "winrt._winrt_windows_devices_sms.SmsBroadcastMessage",
        sizeof(py::wrapper::Windows::Devices::Sms::SmsBroadcastMessage),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SmsBroadcastMessage};

    // ----- SmsDevice class --------------------

    static PyObject* _new_SmsDevice(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Sms::SmsDevice>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Sms::SmsDevice>::type_name);
        return nullptr;
    }

    static void _dealloc_SmsDevice(py::wrapper::Windows::Devices::Sms::SmsDevice* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SmsDevice_CalculateLength(py::wrapper::Windows::Devices::Sms::SmsDevice* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sms.SmsDevice", L"CalculateLength", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Devices::Sms::SmsTextMessage>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.CalculateLength(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SmsDevice_FromIdAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sms.SmsDevice", L"FromIdAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::Devices::Sms::SmsDevice::FromIdAsync(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SmsDevice_FromNetworkAccountIdAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sms.SmsDevice", L"FromNetworkAccountIdAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::Devices::Sms::SmsDevice::FromNetworkAccountIdAsync(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SmsDevice_GetDefaultAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sms.SmsDevice", L"GetDefaultAsync", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::Devices::Sms::SmsDevice::GetDefaultAsync();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SmsDevice_GetDeviceSelector(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sms.SmsDevice", L"GetDeviceSelector", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::Devices::Sms::SmsDevice::GetDeviceSelector();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SmsDevice_SendMessageAsync(py::wrapper::Windows::Devices::Sms::SmsDevice* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sms.SmsDevice", L"SendMessageAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Devices::Sms::ISmsMessage>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.SendMessageAsync(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SmsDevice_get_AccountPhoneNumber(py::wrapper::Windows::Devices::Sms::SmsDevice* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsDevice", L"AccountPhoneNumber");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.AccountPhoneNumber();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsDevice_get_CellularClass(py::wrapper::Windows::Devices::Sms::SmsDevice* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsDevice", L"CellularClass");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.CellularClass();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsDevice_get_DeviceStatus(py::wrapper::Windows::Devices::Sms::SmsDevice* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsDevice", L"DeviceStatus");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.DeviceStatus();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsDevice_get_MessageStore(py::wrapper::Windows::Devices::Sms::SmsDevice* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsDevice", L"MessageStore");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.MessageStore();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsDevice_add_SmsDeviceStatusChanged(py::wrapper::Windows::Devices::Sms::SmsDevice* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Sms.SmsDevice", L"SmsDeviceStatusChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Devices::Sms::SmsDeviceStatusChangedEventHandler>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SmsDeviceStatusChanged(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsDevice_remove_SmsDeviceStatusChanged(py::wrapper::Windows::Devices::Sms::SmsDevice* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Sms.SmsDevice", L"SmsDeviceStatusChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.SmsDeviceStatusChanged(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsDevice_add_SmsMessageReceived(py::wrapper::Windows::Devices::Sms::SmsDevice* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Sms.SmsDevice", L"SmsMessageReceived");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Devices::Sms::SmsMessageReceivedEventHandler>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SmsMessageReceived(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsDevice_remove_SmsMessageReceived(py::wrapper::Windows::Devices::Sms::SmsDevice* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Sms.SmsDevice", L"SmsMessageReceived");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.SmsMessageReceived(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SmsDevice(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Sms::SmsDevice>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SmsDevice(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sms::SmsDevice>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SmsDevice[] = {
        { "calculate_length", reinterpret_cast<PyCFunction>(SmsDevice_CalculateLength), METH_VARARGS, nullptr },
        { "send_message_async", reinterpret_cast<PyCFunction>(SmsDevice_SendMessageAsync), METH_VARARGS, nullptr },
        { "add_sms_device_status_changed", reinterpret_cast<PyCFunction>(SmsDevice_add_SmsDeviceStatusChanged), METH_O, nullptr },
        { "remove_sms_device_status_changed", reinterpret_cast<PyCFunction>(SmsDevice_remove_SmsDeviceStatusChanged), METH_O, nullptr },
        { "add_sms_message_received", reinterpret_cast<PyCFunction>(SmsDevice_add_SmsMessageReceived), METH_O, nullptr },
        { "remove_sms_message_received", reinterpret_cast<PyCFunction>(SmsDevice_remove_SmsMessageReceived), METH_O, nullptr },
        { "_assign_array_", _assign_array_SmsDevice, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SmsDevice), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_SmsDevice[] = {
        { "account_phone_number", reinterpret_cast<getter>(SmsDevice_get_AccountPhoneNumber), nullptr, nullptr, nullptr },
        { "cellular_class", reinterpret_cast<getter>(SmsDevice_get_CellularClass), nullptr, nullptr, nullptr },
        { "device_status", reinterpret_cast<getter>(SmsDevice_get_DeviceStatus), nullptr, nullptr, nullptr },
        { "message_store", reinterpret_cast<getter>(SmsDevice_get_MessageStore), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_SmsDevice[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_SmsDevice) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SmsDevice) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SmsDevice) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SmsDevice) },
        { }};

    static PyType_Spec type_spec_SmsDevice = {
        "winrt._winrt_windows_devices_sms.SmsDevice",
        sizeof(py::wrapper::Windows::Devices::Sms::SmsDevice),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SmsDevice};

    static PyGetSetDef getset_SmsDevice_Static[] = {
        { }};

    static PyMethodDef methods_SmsDevice_Static[] = {
        { "from_id_async", reinterpret_cast<PyCFunction>(SmsDevice_FromIdAsync), METH_VARARGS, nullptr },
        { "from_network_account_id_async", reinterpret_cast<PyCFunction>(SmsDevice_FromNetworkAccountIdAsync), METH_VARARGS, nullptr },
        { "get_default_async", reinterpret_cast<PyCFunction>(SmsDevice_GetDefaultAsync), METH_VARARGS, nullptr },
        { "get_device_selector", reinterpret_cast<PyCFunction>(SmsDevice_GetDeviceSelector), METH_VARARGS, nullptr },
        { }};

    static PyType_Slot type_slots_SmsDevice_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_SmsDevice_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_SmsDevice_Static) },
        { }
    };

    static PyType_Spec type_spec_SmsDevice_Static = {
        "winrt._winrt_windows_devices_sms.SmsDevice_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_SmsDevice_Static};

    // ----- SmsDevice2 class --------------------

    static PyObject* _new_SmsDevice2(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Sms::SmsDevice2>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Sms::SmsDevice2>::type_name);
        return nullptr;
    }

    static void _dealloc_SmsDevice2(py::wrapper::Windows::Devices::Sms::SmsDevice2* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SmsDevice2_CalculateLength(py::wrapper::Windows::Devices::Sms::SmsDevice2* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sms.SmsDevice2", L"CalculateLength", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Devices::Sms::ISmsMessageBase>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.CalculateLength(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SmsDevice2_FromId(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sms.SmsDevice2", L"FromId", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::Devices::Sms::SmsDevice2::FromId(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SmsDevice2_FromParentId(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sms.SmsDevice2", L"FromParentId", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::Devices::Sms::SmsDevice2::FromParentId(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SmsDevice2_GetDefault(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sms.SmsDevice2", L"GetDefault", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::Devices::Sms::SmsDevice2::GetDefault();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SmsDevice2_GetDeviceSelector(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sms.SmsDevice2", L"GetDeviceSelector", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::Devices::Sms::SmsDevice2::GetDeviceSelector();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SmsDevice2_SendMessageAndGetResultAsync(py::wrapper::Windows::Devices::Sms::SmsDevice2* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sms.SmsDevice2", L"SendMessageAndGetResultAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Devices::Sms::ISmsMessageBase>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.SendMessageAndGetResultAsync(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SmsDevice2_get_SmscAddress(py::wrapper::Windows::Devices::Sms::SmsDevice2* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsDevice2", L"SmscAddress");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SmscAddress();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SmsDevice2_put_SmscAddress(py::wrapper::Windows::Devices::Sms::SmsDevice2* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsDevice2", L"SmscAddress");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            {
                auto _gil = release_gil();
                self->obj.SmscAddress(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SmsDevice2_get_AccountPhoneNumber(py::wrapper::Windows::Devices::Sms::SmsDevice2* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsDevice2", L"AccountPhoneNumber");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.AccountPhoneNumber();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsDevice2_get_CellularClass(py::wrapper::Windows::Devices::Sms::SmsDevice2* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsDevice2", L"CellularClass");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.CellularClass();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsDevice2_get_DeviceId(py::wrapper::Windows::Devices::Sms::SmsDevice2* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsDevice2", L"DeviceId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.DeviceId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsDevice2_get_DeviceStatus(py::wrapper::Windows::Devices::Sms::SmsDevice2* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsDevice2", L"DeviceStatus");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.DeviceStatus();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsDevice2_get_ParentDeviceId(py::wrapper::Windows::Devices::Sms::SmsDevice2* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsDevice2", L"ParentDeviceId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ParentDeviceId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsDevice2_add_DeviceStatusChanged(py::wrapper::Windows::Devices::Sms::SmsDevice2* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Sms.SmsDevice2", L"DeviceStatusChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Sms::SmsDevice2, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.DeviceStatusChanged(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsDevice2_remove_DeviceStatusChanged(py::wrapper::Windows::Devices::Sms::SmsDevice2* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Sms.SmsDevice2", L"DeviceStatusChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.DeviceStatusChanged(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SmsDevice2(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Sms::SmsDevice2>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SmsDevice2(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sms::SmsDevice2>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SmsDevice2[] = {
        { "calculate_length", reinterpret_cast<PyCFunction>(SmsDevice2_CalculateLength), METH_VARARGS, nullptr },
        { "send_message_and_get_result_async", reinterpret_cast<PyCFunction>(SmsDevice2_SendMessageAndGetResultAsync), METH_VARARGS, nullptr },
        { "add_device_status_changed", reinterpret_cast<PyCFunction>(SmsDevice2_add_DeviceStatusChanged), METH_O, nullptr },
        { "remove_device_status_changed", reinterpret_cast<PyCFunction>(SmsDevice2_remove_DeviceStatusChanged), METH_O, nullptr },
        { "_assign_array_", _assign_array_SmsDevice2, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SmsDevice2), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_SmsDevice2[] = {
        { "smsc_address", reinterpret_cast<getter>(SmsDevice2_get_SmscAddress), reinterpret_cast<setter>(SmsDevice2_put_SmscAddress), nullptr, nullptr },
        { "account_phone_number", reinterpret_cast<getter>(SmsDevice2_get_AccountPhoneNumber), nullptr, nullptr, nullptr },
        { "cellular_class", reinterpret_cast<getter>(SmsDevice2_get_CellularClass), nullptr, nullptr, nullptr },
        { "device_id", reinterpret_cast<getter>(SmsDevice2_get_DeviceId), nullptr, nullptr, nullptr },
        { "device_status", reinterpret_cast<getter>(SmsDevice2_get_DeviceStatus), nullptr, nullptr, nullptr },
        { "parent_device_id", reinterpret_cast<getter>(SmsDevice2_get_ParentDeviceId), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_SmsDevice2[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_SmsDevice2) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SmsDevice2) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SmsDevice2) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SmsDevice2) },
        { }};

    static PyType_Spec type_spec_SmsDevice2 = {
        "winrt._winrt_windows_devices_sms.SmsDevice2",
        sizeof(py::wrapper::Windows::Devices::Sms::SmsDevice2),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SmsDevice2};

    static PyGetSetDef getset_SmsDevice2_Static[] = {
        { }};

    static PyMethodDef methods_SmsDevice2_Static[] = {
        { "from_id", reinterpret_cast<PyCFunction>(SmsDevice2_FromId), METH_VARARGS, nullptr },
        { "from_parent_id", reinterpret_cast<PyCFunction>(SmsDevice2_FromParentId), METH_VARARGS, nullptr },
        { "get_default", reinterpret_cast<PyCFunction>(SmsDevice2_GetDefault), METH_VARARGS, nullptr },
        { "get_device_selector", reinterpret_cast<PyCFunction>(SmsDevice2_GetDeviceSelector), METH_VARARGS, nullptr },
        { }};

    static PyType_Slot type_slots_SmsDevice2_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_SmsDevice2_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_SmsDevice2_Static) },
        { }
    };

    static PyType_Spec type_spec_SmsDevice2_Static = {
        "winrt._winrt_windows_devices_sms.SmsDevice2_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_SmsDevice2_Static};

    // ----- SmsDeviceMessageStore class --------------------

    static PyObject* _new_SmsDeviceMessageStore(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Sms::SmsDeviceMessageStore>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Sms::SmsDeviceMessageStore>::type_name);
        return nullptr;
    }

    static void _dealloc_SmsDeviceMessageStore(py::wrapper::Windows::Devices::Sms::SmsDeviceMessageStore* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SmsDeviceMessageStore_DeleteMessageAsync(py::wrapper::Windows::Devices::Sms::SmsDeviceMessageStore* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sms.SmsDeviceMessageStore", L"DeleteMessageAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint32_t>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.DeleteMessageAsync(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SmsDeviceMessageStore_DeleteMessagesAsync(py::wrapper::Windows::Devices::Sms::SmsDeviceMessageStore* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sms.SmsDeviceMessageStore", L"DeleteMessagesAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Devices::Sms::SmsMessageFilter>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.DeleteMessagesAsync(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SmsDeviceMessageStore_GetMessageAsync(py::wrapper::Windows::Devices::Sms::SmsDeviceMessageStore* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sms.SmsDeviceMessageStore", L"GetMessageAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint32_t>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetMessageAsync(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SmsDeviceMessageStore_GetMessagesAsync(py::wrapper::Windows::Devices::Sms::SmsDeviceMessageStore* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sms.SmsDeviceMessageStore", L"GetMessagesAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Devices::Sms::SmsMessageFilter>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetMessagesAsync(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SmsDeviceMessageStore_get_MaxMessages(py::wrapper::Windows::Devices::Sms::SmsDeviceMessageStore* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsDeviceMessageStore", L"MaxMessages");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.MaxMessages();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SmsDeviceMessageStore(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Sms::SmsDeviceMessageStore>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SmsDeviceMessageStore(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sms::SmsDeviceMessageStore>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SmsDeviceMessageStore[] = {
        { "delete_message_async", reinterpret_cast<PyCFunction>(SmsDeviceMessageStore_DeleteMessageAsync), METH_VARARGS, nullptr },
        { "delete_messages_async", reinterpret_cast<PyCFunction>(SmsDeviceMessageStore_DeleteMessagesAsync), METH_VARARGS, nullptr },
        { "get_message_async", reinterpret_cast<PyCFunction>(SmsDeviceMessageStore_GetMessageAsync), METH_VARARGS, nullptr },
        { "get_messages_async", reinterpret_cast<PyCFunction>(SmsDeviceMessageStore_GetMessagesAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_SmsDeviceMessageStore, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SmsDeviceMessageStore), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_SmsDeviceMessageStore[] = {
        { "max_messages", reinterpret_cast<getter>(SmsDeviceMessageStore_get_MaxMessages), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_SmsDeviceMessageStore[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_SmsDeviceMessageStore) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SmsDeviceMessageStore) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SmsDeviceMessageStore) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SmsDeviceMessageStore) },
        { }};

    static PyType_Spec type_spec_SmsDeviceMessageStore = {
        "winrt._winrt_windows_devices_sms.SmsDeviceMessageStore",
        sizeof(py::wrapper::Windows::Devices::Sms::SmsDeviceMessageStore),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SmsDeviceMessageStore};

    // ----- SmsFilterRule class --------------------

    static PyObject* _new_SmsFilterRule(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Sms::SmsMessageType>(args, 0);

                winrt::Windows::Devices::Sms::SmsFilterRule instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_SmsFilterRule(py::wrapper::Windows::Devices::Sms::SmsFilterRule* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SmsFilterRule_get_CellularClass(py::wrapper::Windows::Devices::Sms::SmsFilterRule* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsFilterRule", L"CellularClass");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.CellularClass();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SmsFilterRule_put_CellularClass(py::wrapper::Windows::Devices::Sms::SmsFilterRule* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsFilterRule", L"CellularClass");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Devices::Sms::CellularClass>(arg);

            {
                auto _gil = release_gil();
                self->obj.CellularClass(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SmsFilterRule_get_BroadcastChannels(py::wrapper::Windows::Devices::Sms::SmsFilterRule* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsFilterRule", L"BroadcastChannels");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.BroadcastChannels();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsFilterRule_get_BroadcastTypes(py::wrapper::Windows::Devices::Sms::SmsFilterRule* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsFilterRule", L"BroadcastTypes");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.BroadcastTypes();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsFilterRule_get_DeviceIds(py::wrapper::Windows::Devices::Sms::SmsFilterRule* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsFilterRule", L"DeviceIds");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.DeviceIds();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsFilterRule_get_ImsiPrefixes(py::wrapper::Windows::Devices::Sms::SmsFilterRule* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsFilterRule", L"ImsiPrefixes");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ImsiPrefixes();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsFilterRule_get_MessageType(py::wrapper::Windows::Devices::Sms::SmsFilterRule* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsFilterRule", L"MessageType");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.MessageType();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsFilterRule_get_PortNumbers(py::wrapper::Windows::Devices::Sms::SmsFilterRule* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsFilterRule", L"PortNumbers");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PortNumbers();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsFilterRule_get_ProtocolIds(py::wrapper::Windows::Devices::Sms::SmsFilterRule* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsFilterRule", L"ProtocolIds");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ProtocolIds();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsFilterRule_get_SenderNumbers(py::wrapper::Windows::Devices::Sms::SmsFilterRule* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsFilterRule", L"SenderNumbers");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SenderNumbers();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsFilterRule_get_TeleserviceIds(py::wrapper::Windows::Devices::Sms::SmsFilterRule* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsFilterRule", L"TeleserviceIds");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.TeleserviceIds();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsFilterRule_get_TextMessagePrefixes(py::wrapper::Windows::Devices::Sms::SmsFilterRule* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsFilterRule", L"TextMessagePrefixes");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.TextMessagePrefixes();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsFilterRule_get_WapApplicationIds(py::wrapper::Windows::Devices::Sms::SmsFilterRule* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsFilterRule", L"WapApplicationIds");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.WapApplicationIds();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsFilterRule_get_WapContentTypes(py::wrapper::Windows::Devices::Sms::SmsFilterRule* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsFilterRule", L"WapContentTypes");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.WapContentTypes();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SmsFilterRule(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Sms::SmsFilterRule>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SmsFilterRule(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sms::SmsFilterRule>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SmsFilterRule[] = {
        { "_assign_array_", _assign_array_SmsFilterRule, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SmsFilterRule), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_SmsFilterRule[] = {
        { "cellular_class", reinterpret_cast<getter>(SmsFilterRule_get_CellularClass), reinterpret_cast<setter>(SmsFilterRule_put_CellularClass), nullptr, nullptr },
        { "broadcast_channels", reinterpret_cast<getter>(SmsFilterRule_get_BroadcastChannels), nullptr, nullptr, nullptr },
        { "broadcast_types", reinterpret_cast<getter>(SmsFilterRule_get_BroadcastTypes), nullptr, nullptr, nullptr },
        { "device_ids", reinterpret_cast<getter>(SmsFilterRule_get_DeviceIds), nullptr, nullptr, nullptr },
        { "imsi_prefixes", reinterpret_cast<getter>(SmsFilterRule_get_ImsiPrefixes), nullptr, nullptr, nullptr },
        { "message_type", reinterpret_cast<getter>(SmsFilterRule_get_MessageType), nullptr, nullptr, nullptr },
        { "port_numbers", reinterpret_cast<getter>(SmsFilterRule_get_PortNumbers), nullptr, nullptr, nullptr },
        { "protocol_ids", reinterpret_cast<getter>(SmsFilterRule_get_ProtocolIds), nullptr, nullptr, nullptr },
        { "sender_numbers", reinterpret_cast<getter>(SmsFilterRule_get_SenderNumbers), nullptr, nullptr, nullptr },
        { "teleservice_ids", reinterpret_cast<getter>(SmsFilterRule_get_TeleserviceIds), nullptr, nullptr, nullptr },
        { "text_message_prefixes", reinterpret_cast<getter>(SmsFilterRule_get_TextMessagePrefixes), nullptr, nullptr, nullptr },
        { "wap_application_ids", reinterpret_cast<getter>(SmsFilterRule_get_WapApplicationIds), nullptr, nullptr, nullptr },
        { "wap_content_types", reinterpret_cast<getter>(SmsFilterRule_get_WapContentTypes), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_SmsFilterRule[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_SmsFilterRule) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SmsFilterRule) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SmsFilterRule) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SmsFilterRule) },
        { }};

    static PyType_Spec type_spec_SmsFilterRule = {
        "winrt._winrt_windows_devices_sms.SmsFilterRule",
        sizeof(py::wrapper::Windows::Devices::Sms::SmsFilterRule),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SmsFilterRule};

    // ----- SmsFilterRules class --------------------

    static PyObject* _new_SmsFilterRules(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Sms::SmsFilterActionType>(args, 0);

                winrt::Windows::Devices::Sms::SmsFilterRules instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_SmsFilterRules(py::wrapper::Windows::Devices::Sms::SmsFilterRules* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SmsFilterRules_get_ActionType(py::wrapper::Windows::Devices::Sms::SmsFilterRules* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsFilterRules", L"ActionType");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ActionType();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsFilterRules_get_Rules(py::wrapper::Windows::Devices::Sms::SmsFilterRules* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsFilterRules", L"Rules");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Rules();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SmsFilterRules(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Sms::SmsFilterRules>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SmsFilterRules(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sms::SmsFilterRules>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SmsFilterRules[] = {
        { "_assign_array_", _assign_array_SmsFilterRules, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SmsFilterRules), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_SmsFilterRules[] = {
        { "action_type", reinterpret_cast<getter>(SmsFilterRules_get_ActionType), nullptr, nullptr, nullptr },
        { "rules", reinterpret_cast<getter>(SmsFilterRules_get_Rules), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_SmsFilterRules[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_SmsFilterRules) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SmsFilterRules) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SmsFilterRules) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SmsFilterRules) },
        { }};

    static PyType_Spec type_spec_SmsFilterRules = {
        "winrt._winrt_windows_devices_sms.SmsFilterRules",
        sizeof(py::wrapper::Windows::Devices::Sms::SmsFilterRules),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SmsFilterRules};

    // ----- SmsMessageReceivedEventArgs class --------------------

    static PyObject* _new_SmsMessageReceivedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Sms::SmsMessageReceivedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Sms::SmsMessageReceivedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_SmsMessageReceivedEventArgs(py::wrapper::Windows::Devices::Sms::SmsMessageReceivedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SmsMessageReceivedEventArgs_get_BinaryMessage(py::wrapper::Windows::Devices::Sms::SmsMessageReceivedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsMessageReceivedEventArgs", L"BinaryMessage");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.BinaryMessage();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsMessageReceivedEventArgs_get_TextMessage(py::wrapper::Windows::Devices::Sms::SmsMessageReceivedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsMessageReceivedEventArgs", L"TextMessage");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.TextMessage();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SmsMessageReceivedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Sms::SmsMessageReceivedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SmsMessageReceivedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sms::SmsMessageReceivedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SmsMessageReceivedEventArgs[] = {
        { "_assign_array_", _assign_array_SmsMessageReceivedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SmsMessageReceivedEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_SmsMessageReceivedEventArgs[] = {
        { "binary_message", reinterpret_cast<getter>(SmsMessageReceivedEventArgs_get_BinaryMessage), nullptr, nullptr, nullptr },
        { "text_message", reinterpret_cast<getter>(SmsMessageReceivedEventArgs_get_TextMessage), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_SmsMessageReceivedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_SmsMessageReceivedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SmsMessageReceivedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SmsMessageReceivedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SmsMessageReceivedEventArgs) },
        { }};

    static PyType_Spec type_spec_SmsMessageReceivedEventArgs = {
        "winrt._winrt_windows_devices_sms.SmsMessageReceivedEventArgs",
        sizeof(py::wrapper::Windows::Devices::Sms::SmsMessageReceivedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SmsMessageReceivedEventArgs};

    // ----- SmsMessageReceivedTriggerDetails class --------------------

    static PyObject* _new_SmsMessageReceivedTriggerDetails(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Sms::SmsMessageReceivedTriggerDetails>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Sms::SmsMessageReceivedTriggerDetails>::type_name);
        return nullptr;
    }

    static void _dealloc_SmsMessageReceivedTriggerDetails(py::wrapper::Windows::Devices::Sms::SmsMessageReceivedTriggerDetails* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SmsMessageReceivedTriggerDetails_Accept(py::wrapper::Windows::Devices::Sms::SmsMessageReceivedTriggerDetails* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sms.SmsMessageReceivedTriggerDetails", L"Accept", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.Accept();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SmsMessageReceivedTriggerDetails_Drop(py::wrapper::Windows::Devices::Sms::SmsMessageReceivedTriggerDetails* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sms.SmsMessageReceivedTriggerDetails", L"Drop", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.Drop();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SmsMessageReceivedTriggerDetails_get_AppMessage(py::wrapper::Windows::Devices::Sms::SmsMessageReceivedTriggerDetails* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsMessageReceivedTriggerDetails", L"AppMessage");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.AppMessage();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsMessageReceivedTriggerDetails_get_BroadcastMessage(py::wrapper::Windows::Devices::Sms::SmsMessageReceivedTriggerDetails* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsMessageReceivedTriggerDetails", L"BroadcastMessage");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.BroadcastMessage();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsMessageReceivedTriggerDetails_get_MessageType(py::wrapper::Windows::Devices::Sms::SmsMessageReceivedTriggerDetails* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsMessageReceivedTriggerDetails", L"MessageType");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.MessageType();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsMessageReceivedTriggerDetails_get_StatusMessage(py::wrapper::Windows::Devices::Sms::SmsMessageReceivedTriggerDetails* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsMessageReceivedTriggerDetails", L"StatusMessage");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.StatusMessage();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsMessageReceivedTriggerDetails_get_TextMessage(py::wrapper::Windows::Devices::Sms::SmsMessageReceivedTriggerDetails* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsMessageReceivedTriggerDetails", L"TextMessage");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.TextMessage();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsMessageReceivedTriggerDetails_get_VoicemailMessage(py::wrapper::Windows::Devices::Sms::SmsMessageReceivedTriggerDetails* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsMessageReceivedTriggerDetails", L"VoicemailMessage");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.VoicemailMessage();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsMessageReceivedTriggerDetails_get_WapMessage(py::wrapper::Windows::Devices::Sms::SmsMessageReceivedTriggerDetails* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsMessageReceivedTriggerDetails", L"WapMessage");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.WapMessage();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SmsMessageReceivedTriggerDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Sms::SmsMessageReceivedTriggerDetails>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SmsMessageReceivedTriggerDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sms::SmsMessageReceivedTriggerDetails>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SmsMessageReceivedTriggerDetails[] = {
        { "accept", reinterpret_cast<PyCFunction>(SmsMessageReceivedTriggerDetails_Accept), METH_VARARGS, nullptr },
        { "drop", reinterpret_cast<PyCFunction>(SmsMessageReceivedTriggerDetails_Drop), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_SmsMessageReceivedTriggerDetails, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SmsMessageReceivedTriggerDetails), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_SmsMessageReceivedTriggerDetails[] = {
        { "app_message", reinterpret_cast<getter>(SmsMessageReceivedTriggerDetails_get_AppMessage), nullptr, nullptr, nullptr },
        { "broadcast_message", reinterpret_cast<getter>(SmsMessageReceivedTriggerDetails_get_BroadcastMessage), nullptr, nullptr, nullptr },
        { "message_type", reinterpret_cast<getter>(SmsMessageReceivedTriggerDetails_get_MessageType), nullptr, nullptr, nullptr },
        { "status_message", reinterpret_cast<getter>(SmsMessageReceivedTriggerDetails_get_StatusMessage), nullptr, nullptr, nullptr },
        { "text_message", reinterpret_cast<getter>(SmsMessageReceivedTriggerDetails_get_TextMessage), nullptr, nullptr, nullptr },
        { "voicemail_message", reinterpret_cast<getter>(SmsMessageReceivedTriggerDetails_get_VoicemailMessage), nullptr, nullptr, nullptr },
        { "wap_message", reinterpret_cast<getter>(SmsMessageReceivedTriggerDetails_get_WapMessage), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_SmsMessageReceivedTriggerDetails[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_SmsMessageReceivedTriggerDetails) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SmsMessageReceivedTriggerDetails) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SmsMessageReceivedTriggerDetails) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SmsMessageReceivedTriggerDetails) },
        { }};

    static PyType_Spec type_spec_SmsMessageReceivedTriggerDetails = {
        "winrt._winrt_windows_devices_sms.SmsMessageReceivedTriggerDetails",
        sizeof(py::wrapper::Windows::Devices::Sms::SmsMessageReceivedTriggerDetails),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SmsMessageReceivedTriggerDetails};

    // ----- SmsMessageRegistration class --------------------

    static PyObject* _new_SmsMessageRegistration(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Sms::SmsMessageRegistration>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Sms::SmsMessageRegistration>::type_name);
        return nullptr;
    }

    static void _dealloc_SmsMessageRegistration(py::wrapper::Windows::Devices::Sms::SmsMessageRegistration* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SmsMessageRegistration_Register(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sms.SmsMessageRegistration", L"Register", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Devices::Sms::SmsFilterRules>(args, 1);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::Devices::Sms::SmsMessageRegistration::Register(param0, param1);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SmsMessageRegistration_Unregister(py::wrapper::Windows::Devices::Sms::SmsMessageRegistration* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sms.SmsMessageRegistration", L"Unregister", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.Unregister();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SmsMessageRegistration_get_Id(py::wrapper::Windows::Devices::Sms::SmsMessageRegistration* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsMessageRegistration", L"Id");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Id();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsMessageRegistration_get_AllRegistrations(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsMessageRegistration", L"AllRegistrations");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::Devices::Sms::SmsMessageRegistration::AllRegistrations();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsMessageRegistration_add_MessageReceived(py::wrapper::Windows::Devices::Sms::SmsMessageRegistration* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Sms.SmsMessageRegistration", L"MessageReceived");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Sms::SmsMessageRegistration, winrt::Windows::Devices::Sms::SmsMessageReceivedTriggerDetails>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.MessageReceived(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsMessageRegistration_remove_MessageReceived(py::wrapper::Windows::Devices::Sms::SmsMessageRegistration* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Sms.SmsMessageRegistration", L"MessageReceived");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.MessageReceived(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SmsMessageRegistration(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Sms::SmsMessageRegistration>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SmsMessageRegistration(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sms::SmsMessageRegistration>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SmsMessageRegistration[] = {
        { "unregister", reinterpret_cast<PyCFunction>(SmsMessageRegistration_Unregister), METH_VARARGS, nullptr },
        { "add_message_received", reinterpret_cast<PyCFunction>(SmsMessageRegistration_add_MessageReceived), METH_O, nullptr },
        { "remove_message_received", reinterpret_cast<PyCFunction>(SmsMessageRegistration_remove_MessageReceived), METH_O, nullptr },
        { "_assign_array_", _assign_array_SmsMessageRegistration, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SmsMessageRegistration), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_SmsMessageRegistration[] = {
        { "id", reinterpret_cast<getter>(SmsMessageRegistration_get_Id), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_SmsMessageRegistration[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_SmsMessageRegistration) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SmsMessageRegistration) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SmsMessageRegistration) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SmsMessageRegistration) },
        { }};

    static PyType_Spec type_spec_SmsMessageRegistration = {
        "winrt._winrt_windows_devices_sms.SmsMessageRegistration",
        sizeof(py::wrapper::Windows::Devices::Sms::SmsMessageRegistration),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SmsMessageRegistration};

    static PyGetSetDef getset_SmsMessageRegistration_Static[] = {
        { "all_registrations", reinterpret_cast<getter>(SmsMessageRegistration_get_AllRegistrations), nullptr, nullptr, nullptr },
        { }};

    static PyMethodDef methods_SmsMessageRegistration_Static[] = {
        { "register", reinterpret_cast<PyCFunction>(SmsMessageRegistration_Register), METH_VARARGS, nullptr },
        { }};

    static PyType_Slot type_slots_SmsMessageRegistration_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_SmsMessageRegistration_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_SmsMessageRegistration_Static) },
        { }
    };

    static PyType_Spec type_spec_SmsMessageRegistration_Static = {
        "winrt._winrt_windows_devices_sms.SmsMessageRegistration_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_SmsMessageRegistration_Static};

    // ----- SmsReceivedEventDetails class --------------------

    static PyObject* _new_SmsReceivedEventDetails(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Sms::SmsReceivedEventDetails>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Sms::SmsReceivedEventDetails>::type_name);
        return nullptr;
    }

    static void _dealloc_SmsReceivedEventDetails(py::wrapper::Windows::Devices::Sms::SmsReceivedEventDetails* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SmsReceivedEventDetails_get_DeviceId(py::wrapper::Windows::Devices::Sms::SmsReceivedEventDetails* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsReceivedEventDetails", L"DeviceId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.DeviceId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsReceivedEventDetails_get_MessageIndex(py::wrapper::Windows::Devices::Sms::SmsReceivedEventDetails* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsReceivedEventDetails", L"MessageIndex");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.MessageIndex();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsReceivedEventDetails_get_BinaryMessage(py::wrapper::Windows::Devices::Sms::SmsReceivedEventDetails* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsReceivedEventDetails", L"BinaryMessage");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.BinaryMessage();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsReceivedEventDetails_get_MessageClass(py::wrapper::Windows::Devices::Sms::SmsReceivedEventDetails* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsReceivedEventDetails", L"MessageClass");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.MessageClass();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SmsReceivedEventDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Sms::SmsReceivedEventDetails>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SmsReceivedEventDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sms::SmsReceivedEventDetails>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SmsReceivedEventDetails[] = {
        { "_assign_array_", _assign_array_SmsReceivedEventDetails, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SmsReceivedEventDetails), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_SmsReceivedEventDetails[] = {
        { "device_id", reinterpret_cast<getter>(SmsReceivedEventDetails_get_DeviceId), nullptr, nullptr, nullptr },
        { "message_index", reinterpret_cast<getter>(SmsReceivedEventDetails_get_MessageIndex), nullptr, nullptr, nullptr },
        { "binary_message", reinterpret_cast<getter>(SmsReceivedEventDetails_get_BinaryMessage), nullptr, nullptr, nullptr },
        { "message_class", reinterpret_cast<getter>(SmsReceivedEventDetails_get_MessageClass), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_SmsReceivedEventDetails[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_SmsReceivedEventDetails) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SmsReceivedEventDetails) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SmsReceivedEventDetails) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SmsReceivedEventDetails) },
        { }};

    static PyType_Spec type_spec_SmsReceivedEventDetails = {
        "winrt._winrt_windows_devices_sms.SmsReceivedEventDetails",
        sizeof(py::wrapper::Windows::Devices::Sms::SmsReceivedEventDetails),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SmsReceivedEventDetails};

    // ----- SmsSendMessageResult class --------------------

    static PyObject* _new_SmsSendMessageResult(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Sms::SmsSendMessageResult>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Sms::SmsSendMessageResult>::type_name);
        return nullptr;
    }

    static void _dealloc_SmsSendMessageResult(py::wrapper::Windows::Devices::Sms::SmsSendMessageResult* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SmsSendMessageResult_get_CellularClass(py::wrapper::Windows::Devices::Sms::SmsSendMessageResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsSendMessageResult", L"CellularClass");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.CellularClass();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsSendMessageResult_get_IsErrorTransient(py::wrapper::Windows::Devices::Sms::SmsSendMessageResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsSendMessageResult", L"IsErrorTransient");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsErrorTransient();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsSendMessageResult_get_IsSuccessful(py::wrapper::Windows::Devices::Sms::SmsSendMessageResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsSendMessageResult", L"IsSuccessful");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsSuccessful();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsSendMessageResult_get_MessageReferenceNumbers(py::wrapper::Windows::Devices::Sms::SmsSendMessageResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsSendMessageResult", L"MessageReferenceNumbers");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.MessageReferenceNumbers();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsSendMessageResult_get_ModemErrorCode(py::wrapper::Windows::Devices::Sms::SmsSendMessageResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsSendMessageResult", L"ModemErrorCode");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ModemErrorCode();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsSendMessageResult_get_NetworkCauseCode(py::wrapper::Windows::Devices::Sms::SmsSendMessageResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsSendMessageResult", L"NetworkCauseCode");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.NetworkCauseCode();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsSendMessageResult_get_TransportFailureCause(py::wrapper::Windows::Devices::Sms::SmsSendMessageResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsSendMessageResult", L"TransportFailureCause");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.TransportFailureCause();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SmsSendMessageResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Sms::SmsSendMessageResult>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SmsSendMessageResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sms::SmsSendMessageResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SmsSendMessageResult[] = {
        { "_assign_array_", _assign_array_SmsSendMessageResult, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SmsSendMessageResult), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_SmsSendMessageResult[] = {
        { "cellular_class", reinterpret_cast<getter>(SmsSendMessageResult_get_CellularClass), nullptr, nullptr, nullptr },
        { "is_error_transient", reinterpret_cast<getter>(SmsSendMessageResult_get_IsErrorTransient), nullptr, nullptr, nullptr },
        { "is_successful", reinterpret_cast<getter>(SmsSendMessageResult_get_IsSuccessful), nullptr, nullptr, nullptr },
        { "message_reference_numbers", reinterpret_cast<getter>(SmsSendMessageResult_get_MessageReferenceNumbers), nullptr, nullptr, nullptr },
        { "modem_error_code", reinterpret_cast<getter>(SmsSendMessageResult_get_ModemErrorCode), nullptr, nullptr, nullptr },
        { "network_cause_code", reinterpret_cast<getter>(SmsSendMessageResult_get_NetworkCauseCode), nullptr, nullptr, nullptr },
        { "transport_failure_cause", reinterpret_cast<getter>(SmsSendMessageResult_get_TransportFailureCause), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_SmsSendMessageResult[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_SmsSendMessageResult) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SmsSendMessageResult) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SmsSendMessageResult) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SmsSendMessageResult) },
        { }};

    static PyType_Spec type_spec_SmsSendMessageResult = {
        "winrt._winrt_windows_devices_sms.SmsSendMessageResult",
        sizeof(py::wrapper::Windows::Devices::Sms::SmsSendMessageResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SmsSendMessageResult};

    // ----- SmsStatusMessage class --------------------

    static PyObject* _new_SmsStatusMessage(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Sms::SmsStatusMessage>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Sms::SmsStatusMessage>::type_name);
        return nullptr;
    }

    static void _dealloc_SmsStatusMessage(py::wrapper::Windows::Devices::Sms::SmsStatusMessage* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SmsStatusMessage_get_CellularClass(py::wrapper::Windows::Devices::Sms::SmsStatusMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsStatusMessage", L"CellularClass");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.CellularClass();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsStatusMessage_get_DeviceId(py::wrapper::Windows::Devices::Sms::SmsStatusMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsStatusMessage", L"DeviceId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.DeviceId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsStatusMessage_get_MessageClass(py::wrapper::Windows::Devices::Sms::SmsStatusMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsStatusMessage", L"MessageClass");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.MessageClass();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsStatusMessage_get_MessageType(py::wrapper::Windows::Devices::Sms::SmsStatusMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsStatusMessage", L"MessageType");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.MessageType();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsStatusMessage_get_SimIccId(py::wrapper::Windows::Devices::Sms::SmsStatusMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsStatusMessage", L"SimIccId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SimIccId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsStatusMessage_get_Status(py::wrapper::Windows::Devices::Sms::SmsStatusMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsStatusMessage", L"Status");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Status();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsStatusMessage_get_Body(py::wrapper::Windows::Devices::Sms::SmsStatusMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsStatusMessage", L"Body");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Body();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsStatusMessage_get_DischargeTime(py::wrapper::Windows::Devices::Sms::SmsStatusMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsStatusMessage", L"DischargeTime");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.DischargeTime();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsStatusMessage_get_From(py::wrapper::Windows::Devices::Sms::SmsStatusMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsStatusMessage", L"From");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.From();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsStatusMessage_get_MessageReferenceNumber(py::wrapper::Windows::Devices::Sms::SmsStatusMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsStatusMessage", L"MessageReferenceNumber");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.MessageReferenceNumber();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsStatusMessage_get_ServiceCenterTimestamp(py::wrapper::Windows::Devices::Sms::SmsStatusMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsStatusMessage", L"ServiceCenterTimestamp");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ServiceCenterTimestamp();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsStatusMessage_get_To(py::wrapper::Windows::Devices::Sms::SmsStatusMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsStatusMessage", L"To");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.To();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SmsStatusMessage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Sms::SmsStatusMessage>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SmsStatusMessage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sms::SmsStatusMessage>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SmsStatusMessage[] = {
        { "_assign_array_", _assign_array_SmsStatusMessage, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SmsStatusMessage), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_SmsStatusMessage[] = {
        { "cellular_class", reinterpret_cast<getter>(SmsStatusMessage_get_CellularClass), nullptr, nullptr, nullptr },
        { "device_id", reinterpret_cast<getter>(SmsStatusMessage_get_DeviceId), nullptr, nullptr, nullptr },
        { "message_class", reinterpret_cast<getter>(SmsStatusMessage_get_MessageClass), nullptr, nullptr, nullptr },
        { "message_type", reinterpret_cast<getter>(SmsStatusMessage_get_MessageType), nullptr, nullptr, nullptr },
        { "sim_icc_id", reinterpret_cast<getter>(SmsStatusMessage_get_SimIccId), nullptr, nullptr, nullptr },
        { "status", reinterpret_cast<getter>(SmsStatusMessage_get_Status), nullptr, nullptr, nullptr },
        { "body", reinterpret_cast<getter>(SmsStatusMessage_get_Body), nullptr, nullptr, nullptr },
        { "discharge_time", reinterpret_cast<getter>(SmsStatusMessage_get_DischargeTime), nullptr, nullptr, nullptr },
        { "from_", reinterpret_cast<getter>(SmsStatusMessage_get_From), nullptr, nullptr, nullptr },
        { "message_reference_number", reinterpret_cast<getter>(SmsStatusMessage_get_MessageReferenceNumber), nullptr, nullptr, nullptr },
        { "service_center_timestamp", reinterpret_cast<getter>(SmsStatusMessage_get_ServiceCenterTimestamp), nullptr, nullptr, nullptr },
        { "to", reinterpret_cast<getter>(SmsStatusMessage_get_To), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_SmsStatusMessage[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_SmsStatusMessage) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SmsStatusMessage) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SmsStatusMessage) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SmsStatusMessage) },
        { }};

    static PyType_Spec type_spec_SmsStatusMessage = {
        "winrt._winrt_windows_devices_sms.SmsStatusMessage",
        sizeof(py::wrapper::Windows::Devices::Sms::SmsStatusMessage),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SmsStatusMessage};

    // ----- SmsTextMessage class --------------------

    static PyObject* _new_SmsTextMessage(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Devices::Sms::SmsTextMessage instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_SmsTextMessage(py::wrapper::Windows::Devices::Sms::SmsTextMessage* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SmsTextMessage_FromBinaryData(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sms.SmsTextMessage", L"FromBinaryData", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Devices::Sms::SmsDataFormat>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<uint8_t, false>>(args, 1);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::Devices::Sms::SmsTextMessage::FromBinaryData(param0, param1);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SmsTextMessage_FromBinaryMessage(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sms.SmsTextMessage", L"FromBinaryMessage", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Devices::Sms::SmsBinaryMessage>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::Devices::Sms::SmsTextMessage::FromBinaryMessage(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SmsTextMessage_ToBinaryMessages(py::wrapper::Windows::Devices::Sms::SmsTextMessage* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sms.SmsTextMessage", L"ToBinaryMessages", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Devices::Sms::SmsDataFormat>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.ToBinaryMessages(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SmsTextMessage_get_Id(py::wrapper::Windows::Devices::Sms::SmsTextMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsTextMessage", L"Id");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Id();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsTextMessage_get_MessageClass(py::wrapper::Windows::Devices::Sms::SmsTextMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsTextMessage", L"MessageClass");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.MessageClass();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsTextMessage_get_To(py::wrapper::Windows::Devices::Sms::SmsTextMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsTextMessage", L"To");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.To();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SmsTextMessage_put_To(py::wrapper::Windows::Devices::Sms::SmsTextMessage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsTextMessage", L"To");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            {
                auto _gil = release_gil();
                self->obj.To(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SmsTextMessage_get_From(py::wrapper::Windows::Devices::Sms::SmsTextMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsTextMessage", L"From");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.From();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SmsTextMessage_put_From(py::wrapper::Windows::Devices::Sms::SmsTextMessage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsTextMessage", L"From");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            {
                auto _gil = release_gil();
                self->obj.From(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SmsTextMessage_get_Encoding(py::wrapper::Windows::Devices::Sms::SmsTextMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsTextMessage", L"Encoding");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Encoding();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SmsTextMessage_put_Encoding(py::wrapper::Windows::Devices::Sms::SmsTextMessage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsTextMessage", L"Encoding");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Devices::Sms::SmsEncoding>(arg);

            {
                auto _gil = release_gil();
                self->obj.Encoding(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SmsTextMessage_get_Body(py::wrapper::Windows::Devices::Sms::SmsTextMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsTextMessage", L"Body");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Body();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SmsTextMessage_put_Body(py::wrapper::Windows::Devices::Sms::SmsTextMessage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsTextMessage", L"Body");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            {
                auto _gil = release_gil();
                self->obj.Body(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SmsTextMessage_get_PartCount(py::wrapper::Windows::Devices::Sms::SmsTextMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsTextMessage", L"PartCount");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PartCount();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsTextMessage_get_PartNumber(py::wrapper::Windows::Devices::Sms::SmsTextMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsTextMessage", L"PartNumber");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PartNumber();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsTextMessage_get_PartReferenceId(py::wrapper::Windows::Devices::Sms::SmsTextMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsTextMessage", L"PartReferenceId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PartReferenceId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsTextMessage_get_Timestamp(py::wrapper::Windows::Devices::Sms::SmsTextMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsTextMessage", L"Timestamp");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Timestamp();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SmsTextMessage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Sms::SmsTextMessage>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SmsTextMessage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sms::SmsTextMessage>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SmsTextMessage[] = {
        { "to_binary_messages", reinterpret_cast<PyCFunction>(SmsTextMessage_ToBinaryMessages), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_SmsTextMessage, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SmsTextMessage), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_SmsTextMessage[] = {
        { "id", reinterpret_cast<getter>(SmsTextMessage_get_Id), nullptr, nullptr, nullptr },
        { "message_class", reinterpret_cast<getter>(SmsTextMessage_get_MessageClass), nullptr, nullptr, nullptr },
        { "to", reinterpret_cast<getter>(SmsTextMessage_get_To), reinterpret_cast<setter>(SmsTextMessage_put_To), nullptr, nullptr },
        { "from_", reinterpret_cast<getter>(SmsTextMessage_get_From), reinterpret_cast<setter>(SmsTextMessage_put_From), nullptr, nullptr },
        { "encoding", reinterpret_cast<getter>(SmsTextMessage_get_Encoding), reinterpret_cast<setter>(SmsTextMessage_put_Encoding), nullptr, nullptr },
        { "body", reinterpret_cast<getter>(SmsTextMessage_get_Body), reinterpret_cast<setter>(SmsTextMessage_put_Body), nullptr, nullptr },
        { "part_count", reinterpret_cast<getter>(SmsTextMessage_get_PartCount), nullptr, nullptr, nullptr },
        { "part_number", reinterpret_cast<getter>(SmsTextMessage_get_PartNumber), nullptr, nullptr, nullptr },
        { "part_reference_id", reinterpret_cast<getter>(SmsTextMessage_get_PartReferenceId), nullptr, nullptr, nullptr },
        { "timestamp", reinterpret_cast<getter>(SmsTextMessage_get_Timestamp), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_SmsTextMessage[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_SmsTextMessage) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SmsTextMessage) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SmsTextMessage) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SmsTextMessage) },
        { }};

    static PyType_Spec type_spec_SmsTextMessage = {
        "winrt._winrt_windows_devices_sms.SmsTextMessage",
        sizeof(py::wrapper::Windows::Devices::Sms::SmsTextMessage),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SmsTextMessage};

    static PyGetSetDef getset_SmsTextMessage_Static[] = {
        { }};

    static PyMethodDef methods_SmsTextMessage_Static[] = {
        { "from_binary_data", reinterpret_cast<PyCFunction>(SmsTextMessage_FromBinaryData), METH_VARARGS, nullptr },
        { "from_binary_message", reinterpret_cast<PyCFunction>(SmsTextMessage_FromBinaryMessage), METH_VARARGS, nullptr },
        { }};

    static PyType_Slot type_slots_SmsTextMessage_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_SmsTextMessage_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_SmsTextMessage_Static) },
        { }
    };

    static PyType_Spec type_spec_SmsTextMessage_Static = {
        "winrt._winrt_windows_devices_sms.SmsTextMessage_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_SmsTextMessage_Static};

    // ----- SmsTextMessage2 class --------------------

    static PyObject* _new_SmsTextMessage2(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Devices::Sms::SmsTextMessage2 instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_SmsTextMessage2(py::wrapper::Windows::Devices::Sms::SmsTextMessage2* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SmsTextMessage2_get_MessageType(py::wrapper::Windows::Devices::Sms::SmsTextMessage2* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsTextMessage2", L"MessageType");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.MessageType();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsTextMessage2_get_DeviceId(py::wrapper::Windows::Devices::Sms::SmsTextMessage2* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsTextMessage2", L"DeviceId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.DeviceId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsTextMessage2_get_CellularClass(py::wrapper::Windows::Devices::Sms::SmsTextMessage2* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsTextMessage2", L"CellularClass");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.CellularClass();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsTextMessage2_get_MessageClass(py::wrapper::Windows::Devices::Sms::SmsTextMessage2* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsTextMessage2", L"MessageClass");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.MessageClass();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsTextMessage2_get_SimIccId(py::wrapper::Windows::Devices::Sms::SmsTextMessage2* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsTextMessage2", L"SimIccId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SimIccId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsTextMessage2_get_RetryAttemptCount(py::wrapper::Windows::Devices::Sms::SmsTextMessage2* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsTextMessage2", L"RetryAttemptCount");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.RetryAttemptCount();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SmsTextMessage2_put_RetryAttemptCount(py::wrapper::Windows::Devices::Sms::SmsTextMessage2* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsTextMessage2", L"RetryAttemptCount");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<int32_t>(arg);

            {
                auto _gil = release_gil();
                self->obj.RetryAttemptCount(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SmsTextMessage2_get_To(py::wrapper::Windows::Devices::Sms::SmsTextMessage2* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsTextMessage2", L"To");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.To();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SmsTextMessage2_put_To(py::wrapper::Windows::Devices::Sms::SmsTextMessage2* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsTextMessage2", L"To");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            {
                auto _gil = release_gil();
                self->obj.To(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SmsTextMessage2_get_IsDeliveryNotificationEnabled(py::wrapper::Windows::Devices::Sms::SmsTextMessage2* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsTextMessage2", L"IsDeliveryNotificationEnabled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsDeliveryNotificationEnabled();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SmsTextMessage2_put_IsDeliveryNotificationEnabled(py::wrapper::Windows::Devices::Sms::SmsTextMessage2* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsTextMessage2", L"IsDeliveryNotificationEnabled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.IsDeliveryNotificationEnabled(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SmsTextMessage2_get_Encoding(py::wrapper::Windows::Devices::Sms::SmsTextMessage2* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsTextMessage2", L"Encoding");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Encoding();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SmsTextMessage2_put_Encoding(py::wrapper::Windows::Devices::Sms::SmsTextMessage2* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsTextMessage2", L"Encoding");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Devices::Sms::SmsEncoding>(arg);

            {
                auto _gil = release_gil();
                self->obj.Encoding(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SmsTextMessage2_get_CallbackNumber(py::wrapper::Windows::Devices::Sms::SmsTextMessage2* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsTextMessage2", L"CallbackNumber");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.CallbackNumber();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SmsTextMessage2_put_CallbackNumber(py::wrapper::Windows::Devices::Sms::SmsTextMessage2* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsTextMessage2", L"CallbackNumber");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            {
                auto _gil = release_gil();
                self->obj.CallbackNumber(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SmsTextMessage2_get_Body(py::wrapper::Windows::Devices::Sms::SmsTextMessage2* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsTextMessage2", L"Body");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Body();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SmsTextMessage2_put_Body(py::wrapper::Windows::Devices::Sms::SmsTextMessage2* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsTextMessage2", L"Body");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            {
                auto _gil = release_gil();
                self->obj.Body(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SmsTextMessage2_get_ProtocolId(py::wrapper::Windows::Devices::Sms::SmsTextMessage2* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsTextMessage2", L"ProtocolId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ProtocolId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsTextMessage2_get_From(py::wrapper::Windows::Devices::Sms::SmsTextMessage2* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsTextMessage2", L"From");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.From();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsTextMessage2_get_Timestamp(py::wrapper::Windows::Devices::Sms::SmsTextMessage2* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsTextMessage2", L"Timestamp");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Timestamp();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsTextMessage2_get_TeleserviceId(py::wrapper::Windows::Devices::Sms::SmsTextMessage2* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsTextMessage2", L"TeleserviceId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.TeleserviceId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SmsTextMessage2(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Sms::SmsTextMessage2>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SmsTextMessage2(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sms::SmsTextMessage2>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SmsTextMessage2[] = {
        { "_assign_array_", _assign_array_SmsTextMessage2, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SmsTextMessage2), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_SmsTextMessage2[] = {
        { "message_type", reinterpret_cast<getter>(SmsTextMessage2_get_MessageType), nullptr, nullptr, nullptr },
        { "device_id", reinterpret_cast<getter>(SmsTextMessage2_get_DeviceId), nullptr, nullptr, nullptr },
        { "cellular_class", reinterpret_cast<getter>(SmsTextMessage2_get_CellularClass), nullptr, nullptr, nullptr },
        { "message_class", reinterpret_cast<getter>(SmsTextMessage2_get_MessageClass), nullptr, nullptr, nullptr },
        { "sim_icc_id", reinterpret_cast<getter>(SmsTextMessage2_get_SimIccId), nullptr, nullptr, nullptr },
        { "retry_attempt_count", reinterpret_cast<getter>(SmsTextMessage2_get_RetryAttemptCount), reinterpret_cast<setter>(SmsTextMessage2_put_RetryAttemptCount), nullptr, nullptr },
        { "to", reinterpret_cast<getter>(SmsTextMessage2_get_To), reinterpret_cast<setter>(SmsTextMessage2_put_To), nullptr, nullptr },
        { "is_delivery_notification_enabled", reinterpret_cast<getter>(SmsTextMessage2_get_IsDeliveryNotificationEnabled), reinterpret_cast<setter>(SmsTextMessage2_put_IsDeliveryNotificationEnabled), nullptr, nullptr },
        { "encoding", reinterpret_cast<getter>(SmsTextMessage2_get_Encoding), reinterpret_cast<setter>(SmsTextMessage2_put_Encoding), nullptr, nullptr },
        { "callback_number", reinterpret_cast<getter>(SmsTextMessage2_get_CallbackNumber), reinterpret_cast<setter>(SmsTextMessage2_put_CallbackNumber), nullptr, nullptr },
        { "body", reinterpret_cast<getter>(SmsTextMessage2_get_Body), reinterpret_cast<setter>(SmsTextMessage2_put_Body), nullptr, nullptr },
        { "protocol_id", reinterpret_cast<getter>(SmsTextMessage2_get_ProtocolId), nullptr, nullptr, nullptr },
        { "from_", reinterpret_cast<getter>(SmsTextMessage2_get_From), nullptr, nullptr, nullptr },
        { "timestamp", reinterpret_cast<getter>(SmsTextMessage2_get_Timestamp), nullptr, nullptr, nullptr },
        { "teleservice_id", reinterpret_cast<getter>(SmsTextMessage2_get_TeleserviceId), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_SmsTextMessage2[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_SmsTextMessage2) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SmsTextMessage2) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SmsTextMessage2) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SmsTextMessage2) },
        { }};

    static PyType_Spec type_spec_SmsTextMessage2 = {
        "winrt._winrt_windows_devices_sms.SmsTextMessage2",
        sizeof(py::wrapper::Windows::Devices::Sms::SmsTextMessage2),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SmsTextMessage2};

    // ----- SmsVoicemailMessage class --------------------

    static PyObject* _new_SmsVoicemailMessage(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Sms::SmsVoicemailMessage>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Sms::SmsVoicemailMessage>::type_name);
        return nullptr;
    }

    static void _dealloc_SmsVoicemailMessage(py::wrapper::Windows::Devices::Sms::SmsVoicemailMessage* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SmsVoicemailMessage_get_CellularClass(py::wrapper::Windows::Devices::Sms::SmsVoicemailMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsVoicemailMessage", L"CellularClass");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.CellularClass();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsVoicemailMessage_get_DeviceId(py::wrapper::Windows::Devices::Sms::SmsVoicemailMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsVoicemailMessage", L"DeviceId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.DeviceId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsVoicemailMessage_get_MessageClass(py::wrapper::Windows::Devices::Sms::SmsVoicemailMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsVoicemailMessage", L"MessageClass");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.MessageClass();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsVoicemailMessage_get_MessageType(py::wrapper::Windows::Devices::Sms::SmsVoicemailMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsVoicemailMessage", L"MessageType");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.MessageType();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsVoicemailMessage_get_SimIccId(py::wrapper::Windows::Devices::Sms::SmsVoicemailMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsVoicemailMessage", L"SimIccId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SimIccId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsVoicemailMessage_get_Body(py::wrapper::Windows::Devices::Sms::SmsVoicemailMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsVoicemailMessage", L"Body");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Body();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsVoicemailMessage_get_MessageCount(py::wrapper::Windows::Devices::Sms::SmsVoicemailMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsVoicemailMessage", L"MessageCount");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.MessageCount();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsVoicemailMessage_get_Timestamp(py::wrapper::Windows::Devices::Sms::SmsVoicemailMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsVoicemailMessage", L"Timestamp");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Timestamp();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsVoicemailMessage_get_To(py::wrapper::Windows::Devices::Sms::SmsVoicemailMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsVoicemailMessage", L"To");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.To();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SmsVoicemailMessage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Sms::SmsVoicemailMessage>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SmsVoicemailMessage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sms::SmsVoicemailMessage>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SmsVoicemailMessage[] = {
        { "_assign_array_", _assign_array_SmsVoicemailMessage, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SmsVoicemailMessage), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_SmsVoicemailMessage[] = {
        { "cellular_class", reinterpret_cast<getter>(SmsVoicemailMessage_get_CellularClass), nullptr, nullptr, nullptr },
        { "device_id", reinterpret_cast<getter>(SmsVoicemailMessage_get_DeviceId), nullptr, nullptr, nullptr },
        { "message_class", reinterpret_cast<getter>(SmsVoicemailMessage_get_MessageClass), nullptr, nullptr, nullptr },
        { "message_type", reinterpret_cast<getter>(SmsVoicemailMessage_get_MessageType), nullptr, nullptr, nullptr },
        { "sim_icc_id", reinterpret_cast<getter>(SmsVoicemailMessage_get_SimIccId), nullptr, nullptr, nullptr },
        { "body", reinterpret_cast<getter>(SmsVoicemailMessage_get_Body), nullptr, nullptr, nullptr },
        { "message_count", reinterpret_cast<getter>(SmsVoicemailMessage_get_MessageCount), nullptr, nullptr, nullptr },
        { "timestamp", reinterpret_cast<getter>(SmsVoicemailMessage_get_Timestamp), nullptr, nullptr, nullptr },
        { "to", reinterpret_cast<getter>(SmsVoicemailMessage_get_To), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_SmsVoicemailMessage[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_SmsVoicemailMessage) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SmsVoicemailMessage) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SmsVoicemailMessage) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SmsVoicemailMessage) },
        { }};

    static PyType_Spec type_spec_SmsVoicemailMessage = {
        "winrt._winrt_windows_devices_sms.SmsVoicemailMessage",
        sizeof(py::wrapper::Windows::Devices::Sms::SmsVoicemailMessage),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SmsVoicemailMessage};

    // ----- SmsWapMessage class --------------------

    static PyObject* _new_SmsWapMessage(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Sms::SmsWapMessage>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Sms::SmsWapMessage>::type_name);
        return nullptr;
    }

    static void _dealloc_SmsWapMessage(py::wrapper::Windows::Devices::Sms::SmsWapMessage* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SmsWapMessage_get_CellularClass(py::wrapper::Windows::Devices::Sms::SmsWapMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsWapMessage", L"CellularClass");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.CellularClass();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsWapMessage_get_DeviceId(py::wrapper::Windows::Devices::Sms::SmsWapMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsWapMessage", L"DeviceId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.DeviceId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsWapMessage_get_MessageClass(py::wrapper::Windows::Devices::Sms::SmsWapMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsWapMessage", L"MessageClass");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.MessageClass();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsWapMessage_get_MessageType(py::wrapper::Windows::Devices::Sms::SmsWapMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsWapMessage", L"MessageType");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.MessageType();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsWapMessage_get_SimIccId(py::wrapper::Windows::Devices::Sms::SmsWapMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsWapMessage", L"SimIccId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SimIccId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsWapMessage_get_Timestamp(py::wrapper::Windows::Devices::Sms::SmsWapMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsWapMessage", L"Timestamp");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Timestamp();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsWapMessage_get_ApplicationId(py::wrapper::Windows::Devices::Sms::SmsWapMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsWapMessage", L"ApplicationId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ApplicationId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsWapMessage_get_BinaryBody(py::wrapper::Windows::Devices::Sms::SmsWapMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsWapMessage", L"BinaryBody");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.BinaryBody();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsWapMessage_get_ContentType(py::wrapper::Windows::Devices::Sms::SmsWapMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsWapMessage", L"ContentType");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ContentType();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsWapMessage_get_From(py::wrapper::Windows::Devices::Sms::SmsWapMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsWapMessage", L"From");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.From();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsWapMessage_get_Headers(py::wrapper::Windows::Devices::Sms::SmsWapMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsWapMessage", L"Headers");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Headers();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsWapMessage_get_To(py::wrapper::Windows::Devices::Sms::SmsWapMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.SmsWapMessage", L"To");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.To();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SmsWapMessage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Sms::SmsWapMessage>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SmsWapMessage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sms::SmsWapMessage>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SmsWapMessage[] = {
        { "_assign_array_", _assign_array_SmsWapMessage, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SmsWapMessage), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_SmsWapMessage[] = {
        { "cellular_class", reinterpret_cast<getter>(SmsWapMessage_get_CellularClass), nullptr, nullptr, nullptr },
        { "device_id", reinterpret_cast<getter>(SmsWapMessage_get_DeviceId), nullptr, nullptr, nullptr },
        { "message_class", reinterpret_cast<getter>(SmsWapMessage_get_MessageClass), nullptr, nullptr, nullptr },
        { "message_type", reinterpret_cast<getter>(SmsWapMessage_get_MessageType), nullptr, nullptr, nullptr },
        { "sim_icc_id", reinterpret_cast<getter>(SmsWapMessage_get_SimIccId), nullptr, nullptr, nullptr },
        { "timestamp", reinterpret_cast<getter>(SmsWapMessage_get_Timestamp), nullptr, nullptr, nullptr },
        { "application_id", reinterpret_cast<getter>(SmsWapMessage_get_ApplicationId), nullptr, nullptr, nullptr },
        { "binary_body", reinterpret_cast<getter>(SmsWapMessage_get_BinaryBody), nullptr, nullptr, nullptr },
        { "content_type", reinterpret_cast<getter>(SmsWapMessage_get_ContentType), nullptr, nullptr, nullptr },
        { "from_", reinterpret_cast<getter>(SmsWapMessage_get_From), nullptr, nullptr, nullptr },
        { "headers", reinterpret_cast<getter>(SmsWapMessage_get_Headers), nullptr, nullptr, nullptr },
        { "to", reinterpret_cast<getter>(SmsWapMessage_get_To), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_SmsWapMessage[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_SmsWapMessage) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SmsWapMessage) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SmsWapMessage) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SmsWapMessage) },
        { }};

    static PyType_Spec type_spec_SmsWapMessage = {
        "winrt._winrt_windows_devices_sms.SmsWapMessage",
        sizeof(py::wrapper::Windows::Devices::Sms::SmsWapMessage),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SmsWapMessage};

    // ----- ISmsBinaryMessage interface --------------------

    static PyObject* _new_ISmsBinaryMessage(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Sms::ISmsBinaryMessage>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Sms::ISmsBinaryMessage>::type_name);
        return nullptr;
    }

    static void _dealloc_ISmsBinaryMessage(py::wrapper::Windows::Devices::Sms::ISmsBinaryMessage* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ISmsBinaryMessage_GetData(py::wrapper::Windows::Devices::Sms::ISmsBinaryMessage* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sms.ISmsBinaryMessage", L"GetData", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetData();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ISmsBinaryMessage_SetData(py::wrapper::Windows::Devices::Sms::ISmsBinaryMessage* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sms.ISmsBinaryMessage", L"SetData", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<py::pybuf_view<uint8_t, false>>(args, 0);

                {
                    auto _gil = release_gil();
                    self->obj.SetData(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ISmsBinaryMessage_get_Format(py::wrapper::Windows::Devices::Sms::ISmsBinaryMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.ISmsBinaryMessage", L"Format");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Format();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ISmsBinaryMessage_put_Format(py::wrapper::Windows::Devices::Sms::ISmsBinaryMessage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.ISmsBinaryMessage", L"Format");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Devices::Sms::SmsDataFormat>(arg);

            {
                auto _gil = release_gil();
                self->obj.Format(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ISmsBinaryMessage_get_Id(py::wrapper::Windows::Devices::Sms::ISmsBinaryMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.ISmsMessage", L"Id");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Id();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ISmsBinaryMessage_get_MessageClass(py::wrapper::Windows::Devices::Sms::ISmsBinaryMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.ISmsMessage", L"MessageClass");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.MessageClass();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ISmsBinaryMessage[] = {
        { "get_data", reinterpret_cast<PyCFunction>(ISmsBinaryMessage_GetData), METH_VARARGS, nullptr },
        { "set_data", reinterpret_cast<PyCFunction>(ISmsBinaryMessage_SetData), METH_VARARGS, nullptr },
        { }};

    static PyGetSetDef _getset_ISmsBinaryMessage[] = {
        { "format", reinterpret_cast<getter>(ISmsBinaryMessage_get_Format), reinterpret_cast<setter>(ISmsBinaryMessage_put_Format), nullptr, nullptr },
        { "id", reinterpret_cast<getter>(ISmsBinaryMessage_get_Id), nullptr, nullptr, nullptr },
        { "message_class", reinterpret_cast<getter>(ISmsBinaryMessage_get_MessageClass), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_ISmsBinaryMessage[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ISmsBinaryMessage) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ISmsBinaryMessage) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ISmsBinaryMessage) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ISmsBinaryMessage) },
        { }};

    static PyType_Spec type_spec_ISmsBinaryMessage = {
        "winrt._winrt_windows_devices_sms._ISmsBinaryMessage",
        sizeof(py::wrapper::Windows::Devices::Sms::ISmsBinaryMessage),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ISmsBinaryMessage};

    struct ImplementsISmsBinaryMessage : py::ImplementsInterfaceT<ImplementsISmsBinaryMessage, winrt::Windows::Devices::Sms::ISmsBinaryMessage>
    {
        ImplementsISmsBinaryMessage() = delete;
        ImplementsISmsBinaryMessage(PyObject* py_obj, winrt::impl::inspectable_abi* runtime_class) : py::ImplementsInterfaceT<ImplementsISmsBinaryMessage, winrt::Windows::Devices::Sms::ISmsBinaryMessage>(py_obj, runtime_class)
        {
        }

        auto GetData()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "get_data")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallNoArgs(method.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                auto return_buf = py::convert_to<py::pybuf_view<uint8_t, false>>(return_value.get());
                return winrt::com_array<uint8_t>{return_buf.begin(), return_buf.end()};
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto SetData(winrt::array_view<uint8_t const> param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "set_data")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallOneArg(method.get(), py_param0.get())};
                if (!return_value)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto Format()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "format")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Devices::Sms::SmsDataFormat>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        void Format(winrt::Windows::Devices::Sms::SmsDataFormat param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{py::convert(param0)};
                if (!value)
                {
                    throw python_exception();
                }

                if (PyObject_SetAttrString(self.get(), "format", value.get()) == -1)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto Id()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "id")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<uint32_t>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto MessageClass()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "message_class")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Devices::Sms::SmsMessageClass>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }
    };

    static PyObject* _assign_array_ISmsBinaryMessage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Sms::ISmsBinaryMessage>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ISmsBinaryMessage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sms::ISmsBinaryMessage>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _guid_ImplementsISmsBinaryMessage(PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::guid_of<winrt::Windows::Devices::Sms::ISmsBinaryMessage>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _make_ImplementsISmsBinaryMessage(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            PyObject* py_obj;
            winrt::impl::inspectable_abi* runtime_class;

            if (!PyArg_ParseTuple(args, "On", &py_obj, &runtime_class))
            {
                return nullptr;
            }

            auto iface{std::make_unique<ImplementsISmsBinaryMessage>(py_obj, runtime_class)};

            return PyLong_FromVoidPtr(iface.release());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef methods_ImplementsISmsBinaryMessage[] = {
        { "_assign_array_", _assign_array_ISmsBinaryMessage, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ISmsBinaryMessage), METH_O | METH_STATIC, nullptr },
        { "_guid_", reinterpret_cast<PyCFunction>(_guid_ImplementsISmsBinaryMessage), METH_NOARGS | METH_STATIC, nullptr },
        { "_make_", reinterpret_cast<PyCFunction>(_make_ImplementsISmsBinaryMessage), METH_VARARGS | METH_STATIC, nullptr },
        { }};

    static PyType_Slot type_slots_ImplementsISmsBinaryMessage[] = {
        { Py_tp_methods, reinterpret_cast<void*>(methods_ImplementsISmsBinaryMessage) },
        { }};

    static PyType_Spec type_spec_ImplementsISmsBinaryMessage = {
        "winrt._winrt_windows_devices_sms.ISmsBinaryMessage",
        0,
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_ImplementsISmsBinaryMessage};

    // ----- ISmsDevice interface --------------------

    static PyObject* _new_ISmsDevice(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Sms::ISmsDevice>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Sms::ISmsDevice>::type_name);
        return nullptr;
    }

    static void _dealloc_ISmsDevice(py::wrapper::Windows::Devices::Sms::ISmsDevice* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ISmsDevice_CalculateLength(py::wrapper::Windows::Devices::Sms::ISmsDevice* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sms.ISmsDevice", L"CalculateLength", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Devices::Sms::SmsTextMessage>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.CalculateLength(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ISmsDevice_SendMessageAsync(py::wrapper::Windows::Devices::Sms::ISmsDevice* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sms.ISmsDevice", L"SendMessageAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Devices::Sms::ISmsMessage>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.SendMessageAsync(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ISmsDevice_get_AccountPhoneNumber(py::wrapper::Windows::Devices::Sms::ISmsDevice* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.ISmsDevice", L"AccountPhoneNumber");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.AccountPhoneNumber();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ISmsDevice_get_CellularClass(py::wrapper::Windows::Devices::Sms::ISmsDevice* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.ISmsDevice", L"CellularClass");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.CellularClass();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ISmsDevice_get_DeviceStatus(py::wrapper::Windows::Devices::Sms::ISmsDevice* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.ISmsDevice", L"DeviceStatus");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.DeviceStatus();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ISmsDevice_get_MessageStore(py::wrapper::Windows::Devices::Sms::ISmsDevice* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.ISmsDevice", L"MessageStore");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.MessageStore();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ISmsDevice_add_SmsDeviceStatusChanged(py::wrapper::Windows::Devices::Sms::ISmsDevice* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Sms.ISmsDevice", L"SmsDeviceStatusChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Devices::Sms::SmsDeviceStatusChangedEventHandler>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SmsDeviceStatusChanged(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ISmsDevice_remove_SmsDeviceStatusChanged(py::wrapper::Windows::Devices::Sms::ISmsDevice* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Sms.ISmsDevice", L"SmsDeviceStatusChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.SmsDeviceStatusChanged(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ISmsDevice_add_SmsMessageReceived(py::wrapper::Windows::Devices::Sms::ISmsDevice* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Sms.ISmsDevice", L"SmsMessageReceived");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Devices::Sms::SmsMessageReceivedEventHandler>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SmsMessageReceived(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ISmsDevice_remove_SmsMessageReceived(py::wrapper::Windows::Devices::Sms::ISmsDevice* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Sms.ISmsDevice", L"SmsMessageReceived");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.SmsMessageReceived(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ISmsDevice[] = {
        { "calculate_length", reinterpret_cast<PyCFunction>(ISmsDevice_CalculateLength), METH_VARARGS, nullptr },
        { "send_message_async", reinterpret_cast<PyCFunction>(ISmsDevice_SendMessageAsync), METH_VARARGS, nullptr },
        { "add_sms_device_status_changed", reinterpret_cast<PyCFunction>(ISmsDevice_add_SmsDeviceStatusChanged), METH_O, nullptr },
        { "remove_sms_device_status_changed", reinterpret_cast<PyCFunction>(ISmsDevice_remove_SmsDeviceStatusChanged), METH_O, nullptr },
        { "add_sms_message_received", reinterpret_cast<PyCFunction>(ISmsDevice_add_SmsMessageReceived), METH_O, nullptr },
        { "remove_sms_message_received", reinterpret_cast<PyCFunction>(ISmsDevice_remove_SmsMessageReceived), METH_O, nullptr },
        { }};

    static PyGetSetDef _getset_ISmsDevice[] = {
        { "account_phone_number", reinterpret_cast<getter>(ISmsDevice_get_AccountPhoneNumber), nullptr, nullptr, nullptr },
        { "cellular_class", reinterpret_cast<getter>(ISmsDevice_get_CellularClass), nullptr, nullptr, nullptr },
        { "device_status", reinterpret_cast<getter>(ISmsDevice_get_DeviceStatus), nullptr, nullptr, nullptr },
        { "message_store", reinterpret_cast<getter>(ISmsDevice_get_MessageStore), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_ISmsDevice[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ISmsDevice) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ISmsDevice) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ISmsDevice) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ISmsDevice) },
        { }};

    static PyType_Spec type_spec_ISmsDevice = {
        "winrt._winrt_windows_devices_sms._ISmsDevice",
        sizeof(py::wrapper::Windows::Devices::Sms::ISmsDevice),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ISmsDevice};

    struct ImplementsISmsDevice : py::ImplementsInterfaceT<ImplementsISmsDevice, winrt::Windows::Devices::Sms::ISmsDevice>
    {
        ImplementsISmsDevice() = delete;
        ImplementsISmsDevice(PyObject* py_obj, winrt::impl::inspectable_abi* runtime_class) : py::ImplementsInterfaceT<ImplementsISmsDevice, winrt::Windows::Devices::Sms::ISmsDevice>(py_obj, runtime_class)
        {
        }

        auto CalculateLength(winrt::Windows::Devices::Sms::SmsTextMessage const& param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "calculate_length")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallOneArg(method.get(), py_param0.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Devices::Sms::SmsEncodedLength>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto SendMessageAsync(winrt::Windows::Devices::Sms::ISmsMessage const& param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "send_message_async")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallOneArg(method.get(), py_param0.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Devices::Sms::SendSmsMessageOperation>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto AccountPhoneNumber()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "account_phone_number")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::hstring>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto CellularClass()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "cellular_class")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Devices::Sms::CellularClass>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto DeviceStatus()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "device_status")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Devices::Sms::SmsDeviceStatus>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto MessageStore()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "message_store")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Devices::Sms::SmsDeviceMessageStore>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto SmsDeviceStatusChanged(winrt::Windows::Devices::Sms::SmsDeviceStatusChangedEventHandler const& param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "add_sms_device_status_changed")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallOneArg(method.get(), py_param0.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::event_token>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto SmsDeviceStatusChanged(winrt::event_token param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "remove_sms_device_status_changed")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallOneArg(method.get(), py_param0.get())};
                if (!return_value)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto SmsMessageReceived(winrt::Windows::Devices::Sms::SmsMessageReceivedEventHandler const& param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "add_sms_message_received")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallOneArg(method.get(), py_param0.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::event_token>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto SmsMessageReceived(winrt::event_token param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "remove_sms_message_received")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallOneArg(method.get(), py_param0.get())};
                if (!return_value)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }
    };

    static PyObject* _assign_array_ISmsDevice(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Sms::ISmsDevice>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ISmsDevice(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sms::ISmsDevice>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _guid_ImplementsISmsDevice(PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::guid_of<winrt::Windows::Devices::Sms::ISmsDevice>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _make_ImplementsISmsDevice(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            PyObject* py_obj;
            winrt::impl::inspectable_abi* runtime_class;

            if (!PyArg_ParseTuple(args, "On", &py_obj, &runtime_class))
            {
                return nullptr;
            }

            auto iface{std::make_unique<ImplementsISmsDevice>(py_obj, runtime_class)};

            return PyLong_FromVoidPtr(iface.release());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef methods_ImplementsISmsDevice[] = {
        { "_assign_array_", _assign_array_ISmsDevice, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ISmsDevice), METH_O | METH_STATIC, nullptr },
        { "_guid_", reinterpret_cast<PyCFunction>(_guid_ImplementsISmsDevice), METH_NOARGS | METH_STATIC, nullptr },
        { "_make_", reinterpret_cast<PyCFunction>(_make_ImplementsISmsDevice), METH_VARARGS | METH_STATIC, nullptr },
        { }};

    static PyType_Slot type_slots_ImplementsISmsDevice[] = {
        { Py_tp_methods, reinterpret_cast<void*>(methods_ImplementsISmsDevice) },
        { }};

    static PyType_Spec type_spec_ImplementsISmsDevice = {
        "winrt._winrt_windows_devices_sms.ISmsDevice",
        0,
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_ImplementsISmsDevice};

    // ----- ISmsMessage interface --------------------

    static PyObject* _new_ISmsMessage(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Sms::ISmsMessage>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Sms::ISmsMessage>::type_name);
        return nullptr;
    }

    static void _dealloc_ISmsMessage(py::wrapper::Windows::Devices::Sms::ISmsMessage* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ISmsMessage_get_Id(py::wrapper::Windows::Devices::Sms::ISmsMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.ISmsMessage", L"Id");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Id();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ISmsMessage_get_MessageClass(py::wrapper::Windows::Devices::Sms::ISmsMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.ISmsMessage", L"MessageClass");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.MessageClass();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ISmsMessage[] = {
        { }};

    static PyGetSetDef _getset_ISmsMessage[] = {
        { "id", reinterpret_cast<getter>(ISmsMessage_get_Id), nullptr, nullptr, nullptr },
        { "message_class", reinterpret_cast<getter>(ISmsMessage_get_MessageClass), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_ISmsMessage[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ISmsMessage) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ISmsMessage) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ISmsMessage) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ISmsMessage) },
        { }};

    static PyType_Spec type_spec_ISmsMessage = {
        "winrt._winrt_windows_devices_sms._ISmsMessage",
        sizeof(py::wrapper::Windows::Devices::Sms::ISmsMessage),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ISmsMessage};

    struct ImplementsISmsMessage : py::ImplementsInterfaceT<ImplementsISmsMessage, winrt::Windows::Devices::Sms::ISmsMessage>
    {
        ImplementsISmsMessage() = delete;
        ImplementsISmsMessage(PyObject* py_obj, winrt::impl::inspectable_abi* runtime_class) : py::ImplementsInterfaceT<ImplementsISmsMessage, winrt::Windows::Devices::Sms::ISmsMessage>(py_obj, runtime_class)
        {
        }

        auto Id()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "id")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<uint32_t>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto MessageClass()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "message_class")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Devices::Sms::SmsMessageClass>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }
    };

    static PyObject* _assign_array_ISmsMessage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Sms::ISmsMessage>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ISmsMessage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sms::ISmsMessage>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _guid_ImplementsISmsMessage(PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::guid_of<winrt::Windows::Devices::Sms::ISmsMessage>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _make_ImplementsISmsMessage(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            PyObject* py_obj;
            winrt::impl::inspectable_abi* runtime_class;

            if (!PyArg_ParseTuple(args, "On", &py_obj, &runtime_class))
            {
                return nullptr;
            }

            auto iface{std::make_unique<ImplementsISmsMessage>(py_obj, runtime_class)};

            return PyLong_FromVoidPtr(iface.release());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef methods_ImplementsISmsMessage[] = {
        { "_assign_array_", _assign_array_ISmsMessage, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ISmsMessage), METH_O | METH_STATIC, nullptr },
        { "_guid_", reinterpret_cast<PyCFunction>(_guid_ImplementsISmsMessage), METH_NOARGS | METH_STATIC, nullptr },
        { "_make_", reinterpret_cast<PyCFunction>(_make_ImplementsISmsMessage), METH_VARARGS | METH_STATIC, nullptr },
        { }};

    static PyType_Slot type_slots_ImplementsISmsMessage[] = {
        { Py_tp_methods, reinterpret_cast<void*>(methods_ImplementsISmsMessage) },
        { }};

    static PyType_Spec type_spec_ImplementsISmsMessage = {
        "winrt._winrt_windows_devices_sms.ISmsMessage",
        0,
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_ImplementsISmsMessage};

    // ----- ISmsMessageBase interface --------------------

    static PyObject* _new_ISmsMessageBase(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Sms::ISmsMessageBase>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Sms::ISmsMessageBase>::type_name);
        return nullptr;
    }

    static void _dealloc_ISmsMessageBase(py::wrapper::Windows::Devices::Sms::ISmsMessageBase* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ISmsMessageBase_get_CellularClass(py::wrapper::Windows::Devices::Sms::ISmsMessageBase* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.ISmsMessageBase", L"CellularClass");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.CellularClass();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ISmsMessageBase_get_DeviceId(py::wrapper::Windows::Devices::Sms::ISmsMessageBase* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.ISmsMessageBase", L"DeviceId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.DeviceId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ISmsMessageBase_get_MessageClass(py::wrapper::Windows::Devices::Sms::ISmsMessageBase* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.ISmsMessageBase", L"MessageClass");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.MessageClass();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ISmsMessageBase_get_MessageType(py::wrapper::Windows::Devices::Sms::ISmsMessageBase* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.ISmsMessageBase", L"MessageType");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.MessageType();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ISmsMessageBase_get_SimIccId(py::wrapper::Windows::Devices::Sms::ISmsMessageBase* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.ISmsMessageBase", L"SimIccId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SimIccId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ISmsMessageBase[] = {
        { }};

    static PyGetSetDef _getset_ISmsMessageBase[] = {
        { "cellular_class", reinterpret_cast<getter>(ISmsMessageBase_get_CellularClass), nullptr, nullptr, nullptr },
        { "device_id", reinterpret_cast<getter>(ISmsMessageBase_get_DeviceId), nullptr, nullptr, nullptr },
        { "message_class", reinterpret_cast<getter>(ISmsMessageBase_get_MessageClass), nullptr, nullptr, nullptr },
        { "message_type", reinterpret_cast<getter>(ISmsMessageBase_get_MessageType), nullptr, nullptr, nullptr },
        { "sim_icc_id", reinterpret_cast<getter>(ISmsMessageBase_get_SimIccId), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_ISmsMessageBase[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ISmsMessageBase) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ISmsMessageBase) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ISmsMessageBase) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ISmsMessageBase) },
        { }};

    static PyType_Spec type_spec_ISmsMessageBase = {
        "winrt._winrt_windows_devices_sms._ISmsMessageBase",
        sizeof(py::wrapper::Windows::Devices::Sms::ISmsMessageBase),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ISmsMessageBase};

    struct ImplementsISmsMessageBase : py::ImplementsInterfaceT<ImplementsISmsMessageBase, winrt::Windows::Devices::Sms::ISmsMessageBase>
    {
        ImplementsISmsMessageBase() = delete;
        ImplementsISmsMessageBase(PyObject* py_obj, winrt::impl::inspectable_abi* runtime_class) : py::ImplementsInterfaceT<ImplementsISmsMessageBase, winrt::Windows::Devices::Sms::ISmsMessageBase>(py_obj, runtime_class)
        {
        }

        auto CellularClass()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "cellular_class")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Devices::Sms::CellularClass>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto DeviceId()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "device_id")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::hstring>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto MessageClass()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "message_class")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Devices::Sms::SmsMessageClass>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto MessageType()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "message_type")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Devices::Sms::SmsMessageType>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto SimIccId()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "sim_icc_id")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::hstring>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }
    };

    static PyObject* _assign_array_ISmsMessageBase(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Sms::ISmsMessageBase>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ISmsMessageBase(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sms::ISmsMessageBase>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _guid_ImplementsISmsMessageBase(PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::guid_of<winrt::Windows::Devices::Sms::ISmsMessageBase>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _make_ImplementsISmsMessageBase(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            PyObject* py_obj;
            winrt::impl::inspectable_abi* runtime_class;

            if (!PyArg_ParseTuple(args, "On", &py_obj, &runtime_class))
            {
                return nullptr;
            }

            auto iface{std::make_unique<ImplementsISmsMessageBase>(py_obj, runtime_class)};

            return PyLong_FromVoidPtr(iface.release());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef methods_ImplementsISmsMessageBase[] = {
        { "_assign_array_", _assign_array_ISmsMessageBase, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ISmsMessageBase), METH_O | METH_STATIC, nullptr },
        { "_guid_", reinterpret_cast<PyCFunction>(_guid_ImplementsISmsMessageBase), METH_NOARGS | METH_STATIC, nullptr },
        { "_make_", reinterpret_cast<PyCFunction>(_make_ImplementsISmsMessageBase), METH_VARARGS | METH_STATIC, nullptr },
        { }};

    static PyType_Slot type_slots_ImplementsISmsMessageBase[] = {
        { Py_tp_methods, reinterpret_cast<void*>(methods_ImplementsISmsMessageBase) },
        { }};

    static PyType_Spec type_spec_ImplementsISmsMessageBase = {
        "winrt._winrt_windows_devices_sms.ISmsMessageBase",
        0,
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_ImplementsISmsMessageBase};

    // ----- ISmsTextMessage interface --------------------

    static PyObject* _new_ISmsTextMessage(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Sms::ISmsTextMessage>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Sms::ISmsTextMessage>::type_name);
        return nullptr;
    }

    static void _dealloc_ISmsTextMessage(py::wrapper::Windows::Devices::Sms::ISmsTextMessage* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ISmsTextMessage_ToBinaryMessages(py::wrapper::Windows::Devices::Sms::ISmsTextMessage* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Sms.ISmsTextMessage", L"ToBinaryMessages", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Devices::Sms::SmsDataFormat>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.ToBinaryMessages(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ISmsTextMessage_get_Body(py::wrapper::Windows::Devices::Sms::ISmsTextMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.ISmsTextMessage", L"Body");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Body();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ISmsTextMessage_put_Body(py::wrapper::Windows::Devices::Sms::ISmsTextMessage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.ISmsTextMessage", L"Body");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            {
                auto _gil = release_gil();
                self->obj.Body(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ISmsTextMessage_get_Encoding(py::wrapper::Windows::Devices::Sms::ISmsTextMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.ISmsTextMessage", L"Encoding");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Encoding();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ISmsTextMessage_put_Encoding(py::wrapper::Windows::Devices::Sms::ISmsTextMessage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.ISmsTextMessage", L"Encoding");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Devices::Sms::SmsEncoding>(arg);

            {
                auto _gil = release_gil();
                self->obj.Encoding(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ISmsTextMessage_get_From(py::wrapper::Windows::Devices::Sms::ISmsTextMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.ISmsTextMessage", L"From");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.From();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ISmsTextMessage_put_From(py::wrapper::Windows::Devices::Sms::ISmsTextMessage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.ISmsTextMessage", L"From");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            {
                auto _gil = release_gil();
                self->obj.From(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ISmsTextMessage_get_PartCount(py::wrapper::Windows::Devices::Sms::ISmsTextMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.ISmsTextMessage", L"PartCount");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PartCount();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ISmsTextMessage_get_PartNumber(py::wrapper::Windows::Devices::Sms::ISmsTextMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.ISmsTextMessage", L"PartNumber");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PartNumber();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ISmsTextMessage_get_PartReferenceId(py::wrapper::Windows::Devices::Sms::ISmsTextMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.ISmsTextMessage", L"PartReferenceId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PartReferenceId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ISmsTextMessage_get_Timestamp(py::wrapper::Windows::Devices::Sms::ISmsTextMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.ISmsTextMessage", L"Timestamp");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Timestamp();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ISmsTextMessage_get_To(py::wrapper::Windows::Devices::Sms::ISmsTextMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.ISmsTextMessage", L"To");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.To();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ISmsTextMessage_put_To(py::wrapper::Windows::Devices::Sms::ISmsTextMessage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.ISmsTextMessage", L"To");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            {
                auto _gil = release_gil();
                self->obj.To(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ISmsTextMessage_get_Id(py::wrapper::Windows::Devices::Sms::ISmsTextMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.ISmsMessage", L"Id");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Id();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ISmsTextMessage_get_MessageClass(py::wrapper::Windows::Devices::Sms::ISmsTextMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Sms.ISmsMessage", L"MessageClass");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.MessageClass();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ISmsTextMessage[] = {
        { "to_binary_messages", reinterpret_cast<PyCFunction>(ISmsTextMessage_ToBinaryMessages), METH_VARARGS, nullptr },
        { }};

    static PyGetSetDef _getset_ISmsTextMessage[] = {
        { "body", reinterpret_cast<getter>(ISmsTextMessage_get_Body), reinterpret_cast<setter>(ISmsTextMessage_put_Body), nullptr, nullptr },
        { "encoding", reinterpret_cast<getter>(ISmsTextMessage_get_Encoding), reinterpret_cast<setter>(ISmsTextMessage_put_Encoding), nullptr, nullptr },
        { "from_", reinterpret_cast<getter>(ISmsTextMessage_get_From), reinterpret_cast<setter>(ISmsTextMessage_put_From), nullptr, nullptr },
        { "part_count", reinterpret_cast<getter>(ISmsTextMessage_get_PartCount), nullptr, nullptr, nullptr },
        { "part_number", reinterpret_cast<getter>(ISmsTextMessage_get_PartNumber), nullptr, nullptr, nullptr },
        { "part_reference_id", reinterpret_cast<getter>(ISmsTextMessage_get_PartReferenceId), nullptr, nullptr, nullptr },
        { "timestamp", reinterpret_cast<getter>(ISmsTextMessage_get_Timestamp), nullptr, nullptr, nullptr },
        { "to", reinterpret_cast<getter>(ISmsTextMessage_get_To), reinterpret_cast<setter>(ISmsTextMessage_put_To), nullptr, nullptr },
        { "id", reinterpret_cast<getter>(ISmsTextMessage_get_Id), nullptr, nullptr, nullptr },
        { "message_class", reinterpret_cast<getter>(ISmsTextMessage_get_MessageClass), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_ISmsTextMessage[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ISmsTextMessage) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ISmsTextMessage) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ISmsTextMessage) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ISmsTextMessage) },
        { }};

    static PyType_Spec type_spec_ISmsTextMessage = {
        "winrt._winrt_windows_devices_sms._ISmsTextMessage",
        sizeof(py::wrapper::Windows::Devices::Sms::ISmsTextMessage),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ISmsTextMessage};

    struct ImplementsISmsTextMessage : py::ImplementsInterfaceT<ImplementsISmsTextMessage, winrt::Windows::Devices::Sms::ISmsTextMessage>
    {
        ImplementsISmsTextMessage() = delete;
        ImplementsISmsTextMessage(PyObject* py_obj, winrt::impl::inspectable_abi* runtime_class) : py::ImplementsInterfaceT<ImplementsISmsTextMessage, winrt::Windows::Devices::Sms::ISmsTextMessage>(py_obj, runtime_class)
        {
        }

        auto ToBinaryMessages(winrt::Windows::Devices::Sms::SmsDataFormat param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "to_binary_messages")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallOneArg(method.get(), py_param0.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::Devices::Sms::ISmsBinaryMessage>>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto Body()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "body")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::hstring>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        void Body(winrt::hstring const& param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{py::convert(param0)};
                if (!value)
                {
                    throw python_exception();
                }

                if (PyObject_SetAttrString(self.get(), "body", value.get()) == -1)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto Encoding()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "encoding")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Devices::Sms::SmsEncoding>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        void Encoding(winrt::Windows::Devices::Sms::SmsEncoding param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{py::convert(param0)};
                if (!value)
                {
                    throw python_exception();
                }

                if (PyObject_SetAttrString(self.get(), "encoding", value.get()) == -1)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto From()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "from_")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::hstring>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        void From(winrt::hstring const& param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{py::convert(param0)};
                if (!value)
                {
                    throw python_exception();
                }

                if (PyObject_SetAttrString(self.get(), "from_", value.get()) == -1)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto PartCount()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "part_count")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<uint32_t>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto PartNumber()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "part_number")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<uint32_t>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto PartReferenceId()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "part_reference_id")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<uint32_t>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto Timestamp()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "timestamp")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Foundation::DateTime>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto To()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "to")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::hstring>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        void To(winrt::hstring const& param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{py::convert(param0)};
                if (!value)
                {
                    throw python_exception();
                }

                if (PyObject_SetAttrString(self.get(), "to", value.get()) == -1)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto Id()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "id")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<uint32_t>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto MessageClass()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "message_class")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Devices::Sms::SmsMessageClass>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }
    };

    static PyObject* _assign_array_ISmsTextMessage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Sms::ISmsTextMessage>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ISmsTextMessage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sms::ISmsTextMessage>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _guid_ImplementsISmsTextMessage(PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::guid_of<winrt::Windows::Devices::Sms::ISmsTextMessage>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _make_ImplementsISmsTextMessage(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            PyObject* py_obj;
            winrt::impl::inspectable_abi* runtime_class;

            if (!PyArg_ParseTuple(args, "On", &py_obj, &runtime_class))
            {
                return nullptr;
            }

            auto iface{std::make_unique<ImplementsISmsTextMessage>(py_obj, runtime_class)};

            return PyLong_FromVoidPtr(iface.release());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef methods_ImplementsISmsTextMessage[] = {
        { "_assign_array_", _assign_array_ISmsTextMessage, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ISmsTextMessage), METH_O | METH_STATIC, nullptr },
        { "_guid_", reinterpret_cast<PyCFunction>(_guid_ImplementsISmsTextMessage), METH_NOARGS | METH_STATIC, nullptr },
        { "_make_", reinterpret_cast<PyCFunction>(_make_ImplementsISmsTextMessage), METH_VARARGS | METH_STATIC, nullptr },
        { }};

    static PyType_Slot type_slots_ImplementsISmsTextMessage[] = {
        { Py_tp_methods, reinterpret_cast<void*>(methods_ImplementsISmsTextMessage) },
        { }};

    static PyType_Spec type_spec_ImplementsISmsTextMessage = {
        "winrt._winrt_windows_devices_sms.ISmsTextMessage",
        0,
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_ImplementsISmsTextMessage};

    // ----- SmsEncodedLength struct --------------------

    winrt::Windows::Devices::Sms::SmsEncodedLength SmsEncodedLength_from_tuple(PyObject* tuple)
    {
        if (PyTuple_GET_SIZE(tuple) != 5)
        {
            PyErr_SetString(PyExc_TypeError, "Incorrect number of fields");
            throw python_exception();
        }

        winrt::Windows::Devices::Sms::SmsEncodedLength result{};

        result.SegmentCount = py::convert_to<uint32_t>(tuple, 0);
        result.CharacterCountLastSegment = py::convert_to<uint32_t>(tuple, 1);
        result.CharactersPerSegment = py::convert_to<uint32_t>(tuple, 2);
        result.ByteCountLastSegment = py::convert_to<uint32_t>(tuple, 3);
        result.BytesPerSegment = py::convert_to<uint32_t>(tuple, 4);

        return result;
    }

    PyObject* _new_SmsEncodedLength(PyTypeObject* subclass, PyObject* args, PyObject* kwds) noexcept
    {
        pyobj_handle self_obj{(subclass->tp_alloc(subclass, 0))};
        if (!self_obj)
        {
            return nullptr;
        }

        auto self = reinterpret_cast<winrt_struct_wrapper<winrt::Windows::Devices::Sms::SmsEncodedLength>*>(self_obj.get());
        std::construct_at(&self->obj);

        auto tuple_size = PyTuple_Size(args);
        if ((tuple_size == 0) && (!kwds))
        {
            return self_obj.detach();
        }

        uint32_t _SegmentCount{};
        uint32_t _CharacterCountLastSegment{};
        uint32_t _CharactersPerSegment{};
        uint32_t _ByteCountLastSegment{};
        uint32_t _BytesPerSegment{};

        static const char* kwlist[] = {"segment_count", "character_count_last_segment", "characters_per_segment", "byte_count_last_segment", "bytes_per_segment", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "|IIIII", const_cast<char**>(kwlist), &_SegmentCount, &_CharacterCountLastSegment, &_CharactersPerSegment, &_ByteCountLastSegment, &_BytesPerSegment))
        {
            return nullptr;
        }

        try
        {
            self->obj.SegmentCount = _SegmentCount;
            self->obj.CharacterCountLastSegment = _CharacterCountLastSegment;
            self->obj.CharactersPerSegment = _CharactersPerSegment;
            self->obj.ByteCountLastSegment = _ByteCountLastSegment;
            self->obj.BytesPerSegment = _BytesPerSegment;

            return self_obj.detach();
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static void _dealloc_SmsEncodedLength(py::wrapper::Windows::Devices::Sms::SmsEncodedLength* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_SmsEncodedLength(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Sms::SmsEncodedLength>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    PyObject* _replace_SmsEncodedLength(py::wrapper::Windows::Devices::Sms::SmsEncodedLength* self, PyObject* args, PyObject* kwds) noexcept
    {
        try
        {
            uint32_t _SegmentCount{self->obj.SegmentCount};
            uint32_t _CharacterCountLastSegment{self->obj.CharacterCountLastSegment};
            uint32_t _CharactersPerSegment{self->obj.CharactersPerSegment};
            uint32_t _ByteCountLastSegment{self->obj.ByteCountLastSegment};
            uint32_t _BytesPerSegment{self->obj.BytesPerSegment};

            static const char* kwlist[] = {"segment_count", "character_count_last_segment", "characters_per_segment", "byte_count_last_segment", "bytes_per_segment", nullptr};
            if (!PyArg_ParseTupleAndKeywords(args, kwds, "|$IIIII", const_cast<char**>(kwlist), &_SegmentCount, &_CharacterCountLastSegment, &_CharactersPerSegment, &_ByteCountLastSegment, &_BytesPerSegment))
            {
                return nullptr;
            }

            auto copy = self->obj;
            copy.SegmentCount = _SegmentCount;
            copy.CharacterCountLastSegment = _CharacterCountLastSegment;
            copy.CharactersPerSegment = _CharactersPerSegment;
            copy.ByteCountLastSegment = _ByteCountLastSegment;
            copy.BytesPerSegment = _BytesPerSegment;

            return convert(copy);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SmsEncodedLength[] = {
        { "_assign_array_", _assign_array_SmsEncodedLength, METH_O | METH_STATIC, nullptr },
        { "__replace__", reinterpret_cast<PyCFunction>(_replace_SmsEncodedLength), METH_VARARGS | METH_KEYWORDS, nullptr },
        { }};

    static PyObject* SmsEncodedLength_get_SegmentCount(py::wrapper::Windows::Devices::Sms::SmsEncodedLength* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SegmentCount);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsEncodedLength_get_CharacterCountLastSegment(py::wrapper::Windows::Devices::Sms::SmsEncodedLength* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CharacterCountLastSegment);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsEncodedLength_get_CharactersPerSegment(py::wrapper::Windows::Devices::Sms::SmsEncodedLength* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CharactersPerSegment);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsEncodedLength_get_ByteCountLastSegment(py::wrapper::Windows::Devices::Sms::SmsEncodedLength* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ByteCountLastSegment);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsEncodedLength_get_BytesPerSegment(py::wrapper::Windows::Devices::Sms::SmsEncodedLength* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.BytesPerSegment);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyGetSetDef _getset_SmsEncodedLength[] = {
        { "segment_count", reinterpret_cast<getter>(SmsEncodedLength_get_SegmentCount), nullptr, nullptr, nullptr },
        { "character_count_last_segment", reinterpret_cast<getter>(SmsEncodedLength_get_CharacterCountLastSegment), nullptr, nullptr, nullptr },
        { "characters_per_segment", reinterpret_cast<getter>(SmsEncodedLength_get_CharactersPerSegment), nullptr, nullptr, nullptr },
        { "byte_count_last_segment", reinterpret_cast<getter>(SmsEncodedLength_get_ByteCountLastSegment), nullptr, nullptr, nullptr },
        { "bytes_per_segment", reinterpret_cast<getter>(SmsEncodedLength_get_BytesPerSegment), nullptr, nullptr, nullptr },
        { }};

    static PyObject* _richcompare_SmsEncodedLength(py::wrapper::Windows::Devices::Sms::SmsEncodedLength* self, PyObject* other, int op) noexcept
    {
        try
        {
            auto _other = py::convert_to<winrt::Windows::Devices::Sms::SmsEncodedLength>(other);

            if (op == Py_EQ)
            {
                if (self->obj == _other)
                {
                    Py_RETURN_TRUE;
                }

                Py_RETURN_FALSE;
            }

            if (op == Py_NE)
            {
                if (self->obj != _other)
                {
                    Py_RETURN_TRUE;
                }

                Py_RETURN_FALSE;
            }

            Py_RETURN_NOTIMPLEMENTED;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _repr_SmsEncodedLength(PyObject* self) noexcept
    {
        py::pyobj_handle SegmentCount{PyObject_GetAttrString(self, "segment_count")};
        if (!SegmentCount)
        {
            return nullptr;
        }

        py::pyobj_handle CharacterCountLastSegment{PyObject_GetAttrString(self, "character_count_last_segment")};
        if (!CharacterCountLastSegment)
        {
            return nullptr;
        }

        py::pyobj_handle CharactersPerSegment{PyObject_GetAttrString(self, "characters_per_segment")};
        if (!CharactersPerSegment)
        {
            return nullptr;
        }

        py::pyobj_handle ByteCountLastSegment{PyObject_GetAttrString(self, "byte_count_last_segment")};
        if (!ByteCountLastSegment)
        {
            return nullptr;
        }

        py::pyobj_handle BytesPerSegment{PyObject_GetAttrString(self, "bytes_per_segment")};
        if (!BytesPerSegment)
        {
            return nullptr;
        }

        return PyUnicode_FromFormat("SmsEncodedLength(segment_count=%R, character_count_last_segment=%R, characters_per_segment=%R, byte_count_last_segment=%R, bytes_per_segment=%R)", SegmentCount.get(), CharacterCountLastSegment.get(), CharactersPerSegment.get(), ByteCountLastSegment.get(), BytesPerSegment.get());
    }

    static PyType_Slot _type_slots_SmsEncodedLength[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_SmsEncodedLength) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SmsEncodedLength) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SmsEncodedLength) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SmsEncodedLength) },
        { Py_tp_richcompare, reinterpret_cast<void*>(_richcompare_SmsEncodedLength) },
        { Py_tp_repr, reinterpret_cast<void*>(_repr_SmsEncodedLength) },
        { }};

    static PyType_Spec type_spec_SmsEncodedLength = {
        "winrt._winrt_windows_devices_sms.SmsEncodedLength",
        sizeof(py::wrapper::Windows::Devices::Sms::SmsEncodedLength),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SmsEncodedLength};

    // ----- Windows.Devices.Sms Initialization --------------------

    PyDoc_STRVAR(module_doc, "Windows.Devices.Sms");

    static PyModuleDef module_def = {
        PyModuleDef_HEAD_INIT,
        "_winrt_windows_devices_sms",
        module_doc,
        0,
        nullptr,
        nullptr,
        nullptr,
        nullptr,
        nullptr};
} // py::cpp::Windows::Devices::Sms

PyMODINIT_FUNC PyInit__winrt_windows_devices_sms(void) noexcept
{
    using namespace py::cpp::Windows::Devices::Sms;

    if (py::import_winrt_runtime() == -1)
    {
        return nullptr;
    }

    py::pyobj_handle module{PyModule_Create(&module_def)};

    if (!module)
    {
        return nullptr;
    }

    auto inspectable_meta_type = py::get_inspectable_meta_type();
    if (!inspectable_meta_type)
    {
        return nullptr;
    }

    auto object_type = py::get_object_type();
    if (!object_type)
    {
        return nullptr;
    }

    py::pyobj_handle object_bases{PyTuple_Pack(1, object_type)};

    if (!object_bases)
    {
        return nullptr;
    }

    py::pytype_handle DeleteSmsMessageOperation_type{py::register_python_type(module.get(), &type_spec_DeleteSmsMessageOperation, object_bases.get(), inspectable_meta_type)};
    if (!DeleteSmsMessageOperation_type)
    {
        return nullptr;
    }

    py::pytype_handle DeleteSmsMessagesOperation_type{py::register_python_type(module.get(), &type_spec_DeleteSmsMessagesOperation, object_bases.get(), inspectable_meta_type)};
    if (!DeleteSmsMessagesOperation_type)
    {
        return nullptr;
    }

    py::pytype_handle GetSmsDeviceOperation_type{py::register_python_type(module.get(), &type_spec_GetSmsDeviceOperation, object_bases.get(), inspectable_meta_type)};
    if (!GetSmsDeviceOperation_type)
    {
        return nullptr;
    }

    py::pytype_handle GetSmsMessageOperation_type{py::register_python_type(module.get(), &type_spec_GetSmsMessageOperation, object_bases.get(), inspectable_meta_type)};
    if (!GetSmsMessageOperation_type)
    {
        return nullptr;
    }

    py::pytype_handle GetSmsMessagesOperation_type{py::register_python_type(module.get(), &type_spec_GetSmsMessagesOperation, object_bases.get(), inspectable_meta_type)};
    if (!GetSmsMessagesOperation_type)
    {
        return nullptr;
    }

    py::pytype_handle SendSmsMessageOperation_type{py::register_python_type(module.get(), &type_spec_SendSmsMessageOperation, object_bases.get(), inspectable_meta_type)};
    if (!SendSmsMessageOperation_type)
    {
        return nullptr;
    }

    py::pytype_handle SmsAppMessage_type{py::register_python_type(module.get(), &type_spec_SmsAppMessage, object_bases.get(), inspectable_meta_type)};
    if (!SmsAppMessage_type)
    {
        return nullptr;
    }

    py::pytype_handle SmsBinaryMessage_type{py::register_python_type(module.get(), &type_spec_SmsBinaryMessage, object_bases.get(), inspectable_meta_type)};
    if (!SmsBinaryMessage_type)
    {
        return nullptr;
    }

    py::pytype_handle SmsBroadcastMessage_type{py::register_python_type(module.get(), &type_spec_SmsBroadcastMessage, object_bases.get(), inspectable_meta_type)};
    if (!SmsBroadcastMessage_type)
    {
        return nullptr;
    }

    py::pyobj_handle SmsDevice_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(inspectable_meta_type))};
    if (!SmsDevice_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_SmsDevice_Static{PyType_FromSpecWithBases(&type_spec_SmsDevice_Static, SmsDevice_Static_bases.get())};
    if (!type_SmsDevice_Static)
    {
        return nullptr;
    }

    py::pytype_handle SmsDevice_type{py::register_python_type(module.get(), &type_spec_SmsDevice, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_SmsDevice_Static.get()))};
    if (!SmsDevice_type)
    {
        return nullptr;
    }

    py::pyobj_handle SmsDevice2_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(inspectable_meta_type))};
    if (!SmsDevice2_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_SmsDevice2_Static{PyType_FromSpecWithBases(&type_spec_SmsDevice2_Static, SmsDevice2_Static_bases.get())};
    if (!type_SmsDevice2_Static)
    {
        return nullptr;
    }

    py::pytype_handle SmsDevice2_type{py::register_python_type(module.get(), &type_spec_SmsDevice2, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_SmsDevice2_Static.get()))};
    if (!SmsDevice2_type)
    {
        return nullptr;
    }

    py::pytype_handle SmsDeviceMessageStore_type{py::register_python_type(module.get(), &type_spec_SmsDeviceMessageStore, object_bases.get(), inspectable_meta_type)};
    if (!SmsDeviceMessageStore_type)
    {
        return nullptr;
    }

    py::pytype_handle SmsFilterRule_type{py::register_python_type(module.get(), &type_spec_SmsFilterRule, object_bases.get(), inspectable_meta_type)};
    if (!SmsFilterRule_type)
    {
        return nullptr;
    }

    py::pytype_handle SmsFilterRules_type{py::register_python_type(module.get(), &type_spec_SmsFilterRules, object_bases.get(), inspectable_meta_type)};
    if (!SmsFilterRules_type)
    {
        return nullptr;
    }

    py::pytype_handle SmsMessageReceivedEventArgs_type{py::register_python_type(module.get(), &type_spec_SmsMessageReceivedEventArgs, object_bases.get(), inspectable_meta_type)};
    if (!SmsMessageReceivedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle SmsMessageReceivedTriggerDetails_type{py::register_python_type(module.get(), &type_spec_SmsMessageReceivedTriggerDetails, object_bases.get(), inspectable_meta_type)};
    if (!SmsMessageReceivedTriggerDetails_type)
    {
        return nullptr;
    }

    py::pyobj_handle SmsMessageRegistration_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(inspectable_meta_type))};
    if (!SmsMessageRegistration_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_SmsMessageRegistration_Static{PyType_FromSpecWithBases(&type_spec_SmsMessageRegistration_Static, SmsMessageRegistration_Static_bases.get())};
    if (!type_SmsMessageRegistration_Static)
    {
        return nullptr;
    }

    py::pytype_handle SmsMessageRegistration_type{py::register_python_type(module.get(), &type_spec_SmsMessageRegistration, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_SmsMessageRegistration_Static.get()))};
    if (!SmsMessageRegistration_type)
    {
        return nullptr;
    }

    py::pytype_handle SmsReceivedEventDetails_type{py::register_python_type(module.get(), &type_spec_SmsReceivedEventDetails, object_bases.get(), inspectable_meta_type)};
    if (!SmsReceivedEventDetails_type)
    {
        return nullptr;
    }

    py::pytype_handle SmsSendMessageResult_type{py::register_python_type(module.get(), &type_spec_SmsSendMessageResult, object_bases.get(), inspectable_meta_type)};
    if (!SmsSendMessageResult_type)
    {
        return nullptr;
    }

    py::pytype_handle SmsStatusMessage_type{py::register_python_type(module.get(), &type_spec_SmsStatusMessage, object_bases.get(), inspectable_meta_type)};
    if (!SmsStatusMessage_type)
    {
        return nullptr;
    }

    py::pyobj_handle SmsTextMessage_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(inspectable_meta_type))};
    if (!SmsTextMessage_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_SmsTextMessage_Static{PyType_FromSpecWithBases(&type_spec_SmsTextMessage_Static, SmsTextMessage_Static_bases.get())};
    if (!type_SmsTextMessage_Static)
    {
        return nullptr;
    }

    py::pytype_handle SmsTextMessage_type{py::register_python_type(module.get(), &type_spec_SmsTextMessage, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_SmsTextMessage_Static.get()))};
    if (!SmsTextMessage_type)
    {
        return nullptr;
    }

    py::pytype_handle SmsTextMessage2_type{py::register_python_type(module.get(), &type_spec_SmsTextMessage2, object_bases.get(), inspectable_meta_type)};
    if (!SmsTextMessage2_type)
    {
        return nullptr;
    }

    py::pytype_handle SmsVoicemailMessage_type{py::register_python_type(module.get(), &type_spec_SmsVoicemailMessage, object_bases.get(), inspectable_meta_type)};
    if (!SmsVoicemailMessage_type)
    {
        return nullptr;
    }

    py::pytype_handle SmsWapMessage_type{py::register_python_type(module.get(), &type_spec_SmsWapMessage, object_bases.get(), inspectable_meta_type)};
    if (!SmsWapMessage_type)
    {
        return nullptr;
    }

    py::pytype_handle ISmsBinaryMessage_type{py::register_python_type(module.get(), &type_spec_ISmsBinaryMessage, object_bases.get(), nullptr)};
    if (!ISmsBinaryMessage_type)
    {
        return nullptr;
    }

    py::pytype_handle ImplementsISmsBinaryMessage_type{py::register_python_type(module.get(), &type_spec_ImplementsISmsBinaryMessage, nullptr, inspectable_meta_type)};
    if (!ImplementsISmsBinaryMessage_type)
    {
        return nullptr;
    }

    if (PyModule_AddType(module.get(), ImplementsISmsBinaryMessage_type.get()) == -1)
    {
        return nullptr;
    }

    py::pytype_handle ISmsDevice_type{py::register_python_type(module.get(), &type_spec_ISmsDevice, object_bases.get(), nullptr)};
    if (!ISmsDevice_type)
    {
        return nullptr;
    }

    py::pytype_handle ImplementsISmsDevice_type{py::register_python_type(module.get(), &type_spec_ImplementsISmsDevice, nullptr, inspectable_meta_type)};
    if (!ImplementsISmsDevice_type)
    {
        return nullptr;
    }

    if (PyModule_AddType(module.get(), ImplementsISmsDevice_type.get()) == -1)
    {
        return nullptr;
    }

    py::pytype_handle ISmsMessage_type{py::register_python_type(module.get(), &type_spec_ISmsMessage, object_bases.get(), nullptr)};
    if (!ISmsMessage_type)
    {
        return nullptr;
    }

    py::pytype_handle ImplementsISmsMessage_type{py::register_python_type(module.get(), &type_spec_ImplementsISmsMessage, nullptr, inspectable_meta_type)};
    if (!ImplementsISmsMessage_type)
    {
        return nullptr;
    }

    if (PyModule_AddType(module.get(), ImplementsISmsMessage_type.get()) == -1)
    {
        return nullptr;
    }

    py::pytype_handle ISmsMessageBase_type{py::register_python_type(module.get(), &type_spec_ISmsMessageBase, object_bases.get(), nullptr)};
    if (!ISmsMessageBase_type)
    {
        return nullptr;
    }

    py::pytype_handle ImplementsISmsMessageBase_type{py::register_python_type(module.get(), &type_spec_ImplementsISmsMessageBase, nullptr, inspectable_meta_type)};
    if (!ImplementsISmsMessageBase_type)
    {
        return nullptr;
    }

    if (PyModule_AddType(module.get(), ImplementsISmsMessageBase_type.get()) == -1)
    {
        return nullptr;
    }

    py::pytype_handle ISmsTextMessage_type{py::register_python_type(module.get(), &type_spec_ISmsTextMessage, object_bases.get(), nullptr)};
    if (!ISmsTextMessage_type)
    {
        return nullptr;
    }

    py::pytype_handle ImplementsISmsTextMessage_type{py::register_python_type(module.get(), &type_spec_ImplementsISmsTextMessage, nullptr, inspectable_meta_type)};
    if (!ImplementsISmsTextMessage_type)
    {
        return nullptr;
    }

    if (PyModule_AddType(module.get(), ImplementsISmsTextMessage_type.get()) == -1)
    {
        return nullptr;
    }

    py::pytype_handle SmsEncodedLength_type{py::register_python_type(module.get(), &type_spec_SmsEncodedLength, nullptr, nullptr)};
    if (!SmsEncodedLength_type)
    {
        return nullptr;
    }

    py::pyobj_handle SmsEncodedLength_from_tuple_capsule{PyCapsule_New(reinterpret_cast<void*>(SmsEncodedLength_from_tuple),"winrt._winrt_windows_devices_sms.SmsEncodedLength_from_tuple", nullptr)};
    if (!SmsEncodedLength_from_tuple_capsule)
    {
        return nullptr;
    }

    if (PyModule_AddObjectRef(module.get(), "SmsEncodedLength_from_tuple", SmsEncodedLength_from_tuple_capsule.get()) == -1)
    {
        return nullptr;
    }

    return module.detach();
}
