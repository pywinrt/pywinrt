// WARNING: Please don't edit this file. It was generated by Python/WinRT v0.0.0

#include "pybase.h"
#include "py.Windows.System.RemoteSystems.h"


namespace py::cpp::Windows::System::RemoteSystems
{
    // ----- KnownRemoteSystemCapabilities class --------------------
    static constexpr const char* const type_name_KnownRemoteSystemCapabilities = "KnownRemoteSystemCapabilities";

    static PyObject* _new_KnownRemoteSystemCapabilities(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_KnownRemoteSystemCapabilities);
        return nullptr;
    }

    static PyObject* KnownRemoteSystemCapabilities_get_AppService(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.RemoteSystems.KnownRemoteSystemCapabilities", L"AppService"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::System::RemoteSystems::KnownRemoteSystemCapabilities::AppService());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownRemoteSystemCapabilities_get_LaunchUri(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.RemoteSystems.KnownRemoteSystemCapabilities", L"LaunchUri"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::System::RemoteSystems::KnownRemoteSystemCapabilities::LaunchUri());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownRemoteSystemCapabilities_get_RemoteSession(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.RemoteSystems.KnownRemoteSystemCapabilities", L"RemoteSession"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::System::RemoteSystems::KnownRemoteSystemCapabilities::RemoteSession());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownRemoteSystemCapabilities_get_SpatialEntity(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.RemoteSystems.KnownRemoteSystemCapabilities", L"SpatialEntity"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::System::RemoteSystems::KnownRemoteSystemCapabilities::SpatialEntity());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_KnownRemoteSystemCapabilities[] = {
        { }
    };

    static PyGetSetDef _getset_KnownRemoteSystemCapabilities[] = {
        { }
    };

    static PyType_Slot _type_slots_KnownRemoteSystemCapabilities[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_KnownRemoteSystemCapabilities) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_KnownRemoteSystemCapabilities) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_KnownRemoteSystemCapabilities) },
        { },
    };

    static PyType_Spec type_spec_KnownRemoteSystemCapabilities =
    {
        "_winrt_Windows_System_RemoteSystems.KnownRemoteSystemCapabilities",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_KnownRemoteSystemCapabilities
    };

    static PyGetSetDef getset_KnownRemoteSystemCapabilities_Meta[] = {
        { "app_service", reinterpret_cast<getter>(KnownRemoteSystemCapabilities_get_AppService), nullptr, nullptr, nullptr },
        { "launch_uri", reinterpret_cast<getter>(KnownRemoteSystemCapabilities_get_LaunchUri), nullptr, nullptr, nullptr },
        { "remote_session", reinterpret_cast<getter>(KnownRemoteSystemCapabilities_get_RemoteSession), nullptr, nullptr, nullptr },
        { "spatial_entity", reinterpret_cast<getter>(KnownRemoteSystemCapabilities_get_SpatialEntity), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot type_slots_KnownRemoteSystemCapabilities_Meta[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_KnownRemoteSystemCapabilities_Meta) },
        { }
    };

    static PyType_Spec type_spec_KnownRemoteSystemCapabilities_Meta =
    {
        "_winrt_Windows_System_RemoteSystems.KnownRemoteSystemCapabilities_Meta",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_KnownRemoteSystemCapabilities_Meta
    };

    // ----- RemoteSystem class --------------------
    static constexpr const char* const type_name_RemoteSystem = "RemoteSystem";

    static PyObject* _new_RemoteSystem(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_RemoteSystem);
        return nullptr;
    }

    static void _dealloc_RemoteSystem(py::wrapper::Windows::System::RemoteSystems::RemoteSystem* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* RemoteSystem_CreateWatcher(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.RemoteSystems.RemoteSystem", L"CreateWatcher", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::System::RemoteSystems::RemoteSystem::CreateWatcher());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.RemoteSystems.RemoteSystem", L"CreateWatcher", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::System::RemoteSystems::IRemoteSystemFilter>>(args, 0);

                return py::convert(winrt::Windows::System::RemoteSystems::RemoteSystem::CreateWatcher(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RemoteSystem_CreateWatcherForUser(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.RemoteSystems.RemoteSystem", L"CreateWatcherForUser", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::System::User>(args, 0);

                return py::convert(winrt::Windows::System::RemoteSystems::RemoteSystem::CreateWatcherForUser(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.RemoteSystems.RemoteSystem", L"CreateWatcherForUser", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::System::User>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::System::RemoteSystems::IRemoteSystemFilter>>(args, 1);

                return py::convert(winrt::Windows::System::RemoteSystems::RemoteSystem::CreateWatcherForUser(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RemoteSystem_FindByHostNameAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.RemoteSystems.RemoteSystem", L"FindByHostNameAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Networking::HostName>(args, 0);

                return py::convert(winrt::Windows::System::RemoteSystems::RemoteSystem::FindByHostNameAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RemoteSystem_GetCapabilitySupportedAsync(py::wrapper::Windows::System::RemoteSystems::RemoteSystem* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.RemoteSystems.RemoteSystem", L"GetCapabilitySupportedAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.GetCapabilitySupportedAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RemoteSystem_IsAuthorizationKindEnabled(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.RemoteSystems.RemoteSystem", L"IsAuthorizationKindEnabled", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::System::RemoteSystems::RemoteSystemAuthorizationKind>(args, 0);

                return py::convert(winrt::Windows::System::RemoteSystems::RemoteSystem::IsAuthorizationKindEnabled(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RemoteSystem_RequestAccessAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.RemoteSystems.RemoteSystem", L"RequestAccessAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::System::RemoteSystems::RemoteSystem::RequestAccessAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RemoteSystem_get_DisplayName(py::wrapper::Windows::System::RemoteSystems::RemoteSystem* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.RemoteSystems.RemoteSystem", L"DisplayName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DisplayName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RemoteSystem_get_Id(py::wrapper::Windows::System::RemoteSystems::RemoteSystem* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.RemoteSystems.RemoteSystem", L"Id"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RemoteSystem_get_IsAvailableByProximity(py::wrapper::Windows::System::RemoteSystems::RemoteSystem* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.RemoteSystems.RemoteSystem", L"IsAvailableByProximity"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsAvailableByProximity());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RemoteSystem_get_Kind(py::wrapper::Windows::System::RemoteSystems::RemoteSystem* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.RemoteSystems.RemoteSystem", L"Kind"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RemoteSystem_get_Status(py::wrapper::Windows::System::RemoteSystems::RemoteSystem* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.RemoteSystems.RemoteSystem", L"Status"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RemoteSystem_get_IsAvailableBySpatialProximity(py::wrapper::Windows::System::RemoteSystems::RemoteSystem* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.RemoteSystems.RemoteSystem", L"IsAvailableBySpatialProximity"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsAvailableBySpatialProximity());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RemoteSystem_get_ManufacturerDisplayName(py::wrapper::Windows::System::RemoteSystems::RemoteSystem* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.RemoteSystems.RemoteSystem", L"ManufacturerDisplayName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ManufacturerDisplayName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RemoteSystem_get_ModelDisplayName(py::wrapper::Windows::System::RemoteSystems::RemoteSystem* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.RemoteSystems.RemoteSystem", L"ModelDisplayName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ModelDisplayName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RemoteSystem_get_Platform(py::wrapper::Windows::System::RemoteSystems::RemoteSystem* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.RemoteSystems.RemoteSystem", L"Platform"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Platform());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RemoteSystem_get_Apps(py::wrapper::Windows::System::RemoteSystems::RemoteSystem* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.RemoteSystems.RemoteSystem", L"Apps"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Apps());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RemoteSystem_get_User(py::wrapper::Windows::System::RemoteSystems::RemoteSystem* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.RemoteSystems.RemoteSystem", L"User"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.User());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_RemoteSystem(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::System::RemoteSystems::RemoteSystem>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_RemoteSystem(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::RemoteSystems::RemoteSystem>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RemoteSystem[] = {
        { "create_watcher", reinterpret_cast<PyCFunction>(RemoteSystem_CreateWatcher), METH_VARARGS | METH_STATIC, nullptr },
        { "create_watcher_for_user", reinterpret_cast<PyCFunction>(RemoteSystem_CreateWatcherForUser), METH_VARARGS | METH_STATIC, nullptr },
        { "find_by_host_name_async", reinterpret_cast<PyCFunction>(RemoteSystem_FindByHostNameAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "get_capability_supported_async", reinterpret_cast<PyCFunction>(RemoteSystem_GetCapabilitySupportedAsync), METH_VARARGS, nullptr },
        { "is_authorization_kind_enabled", reinterpret_cast<PyCFunction>(RemoteSystem_IsAuthorizationKindEnabled), METH_VARARGS | METH_STATIC, nullptr },
        { "request_access_async", reinterpret_cast<PyCFunction>(RemoteSystem_RequestAccessAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "_assign_array_", _assign_array_RemoteSystem, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_RemoteSystem), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_RemoteSystem[] = {
        { "display_name", reinterpret_cast<getter>(RemoteSystem_get_DisplayName), nullptr, nullptr, nullptr },
        { "id", reinterpret_cast<getter>(RemoteSystem_get_Id), nullptr, nullptr, nullptr },
        { "is_available_by_proximity", reinterpret_cast<getter>(RemoteSystem_get_IsAvailableByProximity), nullptr, nullptr, nullptr },
        { "kind", reinterpret_cast<getter>(RemoteSystem_get_Kind), nullptr, nullptr, nullptr },
        { "status", reinterpret_cast<getter>(RemoteSystem_get_Status), nullptr, nullptr, nullptr },
        { "is_available_by_spatial_proximity", reinterpret_cast<getter>(RemoteSystem_get_IsAvailableBySpatialProximity), nullptr, nullptr, nullptr },
        { "manufacturer_display_name", reinterpret_cast<getter>(RemoteSystem_get_ManufacturerDisplayName), nullptr, nullptr, nullptr },
        { "model_display_name", reinterpret_cast<getter>(RemoteSystem_get_ModelDisplayName), nullptr, nullptr, nullptr },
        { "platform", reinterpret_cast<getter>(RemoteSystem_get_Platform), nullptr, nullptr, nullptr },
        { "apps", reinterpret_cast<getter>(RemoteSystem_get_Apps), nullptr, nullptr, nullptr },
        { "user", reinterpret_cast<getter>(RemoteSystem_get_User), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_RemoteSystem[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_RemoteSystem) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_RemoteSystem) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_RemoteSystem) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_RemoteSystem) },
        { },
    };

    static PyType_Spec type_spec_RemoteSystem =
    {
        "_winrt_Windows_System_RemoteSystems.RemoteSystem",
        sizeof(py::wrapper::Windows::System::RemoteSystems::RemoteSystem),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RemoteSystem
    };

    // ----- RemoteSystemAddedEventArgs class --------------------
    static constexpr const char* const type_name_RemoteSystemAddedEventArgs = "RemoteSystemAddedEventArgs";

    static PyObject* _new_RemoteSystemAddedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_RemoteSystemAddedEventArgs);
        return nullptr;
    }

    static void _dealloc_RemoteSystemAddedEventArgs(py::wrapper::Windows::System::RemoteSystems::RemoteSystemAddedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* RemoteSystemAddedEventArgs_get_RemoteSystem(py::wrapper::Windows::System::RemoteSystems::RemoteSystemAddedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.RemoteSystems.RemoteSystemAddedEventArgs", L"RemoteSystem"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RemoteSystem());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_RemoteSystemAddedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::System::RemoteSystems::RemoteSystemAddedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_RemoteSystemAddedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::RemoteSystems::RemoteSystemAddedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RemoteSystemAddedEventArgs[] = {
        { "_assign_array_", _assign_array_RemoteSystemAddedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_RemoteSystemAddedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_RemoteSystemAddedEventArgs[] = {
        { "remote_system", reinterpret_cast<getter>(RemoteSystemAddedEventArgs_get_RemoteSystem), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_RemoteSystemAddedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_RemoteSystemAddedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_RemoteSystemAddedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_RemoteSystemAddedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_RemoteSystemAddedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_RemoteSystemAddedEventArgs =
    {
        "_winrt_Windows_System_RemoteSystems.RemoteSystemAddedEventArgs",
        sizeof(py::wrapper::Windows::System::RemoteSystems::RemoteSystemAddedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RemoteSystemAddedEventArgs
    };

    // ----- RemoteSystemApp class --------------------
    static constexpr const char* const type_name_RemoteSystemApp = "RemoteSystemApp";

    static PyObject* _new_RemoteSystemApp(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_RemoteSystemApp);
        return nullptr;
    }

    static void _dealloc_RemoteSystemApp(py::wrapper::Windows::System::RemoteSystems::RemoteSystemApp* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* RemoteSystemApp_get_Attributes(py::wrapper::Windows::System::RemoteSystems::RemoteSystemApp* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.RemoteSystems.RemoteSystemApp", L"Attributes"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Attributes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RemoteSystemApp_get_DisplayName(py::wrapper::Windows::System::RemoteSystems::RemoteSystemApp* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.RemoteSystems.RemoteSystemApp", L"DisplayName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DisplayName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RemoteSystemApp_get_Id(py::wrapper::Windows::System::RemoteSystems::RemoteSystemApp* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.RemoteSystems.RemoteSystemApp", L"Id"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RemoteSystemApp_get_IsAvailableByProximity(py::wrapper::Windows::System::RemoteSystems::RemoteSystemApp* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.RemoteSystems.RemoteSystemApp", L"IsAvailableByProximity"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsAvailableByProximity());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RemoteSystemApp_get_IsAvailableBySpatialProximity(py::wrapper::Windows::System::RemoteSystems::RemoteSystemApp* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.RemoteSystems.RemoteSystemApp", L"IsAvailableBySpatialProximity"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsAvailableBySpatialProximity());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RemoteSystemApp_get_ConnectionToken(py::wrapper::Windows::System::RemoteSystems::RemoteSystemApp* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.RemoteSystems.RemoteSystemApp", L"ConnectionToken"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ConnectionToken());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RemoteSystemApp_get_User(py::wrapper::Windows::System::RemoteSystems::RemoteSystemApp* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.RemoteSystems.RemoteSystemApp", L"User"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.User());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_RemoteSystemApp(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::System::RemoteSystems::RemoteSystemApp>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_RemoteSystemApp(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::RemoteSystems::RemoteSystemApp>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RemoteSystemApp[] = {
        { "_assign_array_", _assign_array_RemoteSystemApp, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_RemoteSystemApp), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_RemoteSystemApp[] = {
        { "attributes", reinterpret_cast<getter>(RemoteSystemApp_get_Attributes), nullptr, nullptr, nullptr },
        { "display_name", reinterpret_cast<getter>(RemoteSystemApp_get_DisplayName), nullptr, nullptr, nullptr },
        { "id", reinterpret_cast<getter>(RemoteSystemApp_get_Id), nullptr, nullptr, nullptr },
        { "is_available_by_proximity", reinterpret_cast<getter>(RemoteSystemApp_get_IsAvailableByProximity), nullptr, nullptr, nullptr },
        { "is_available_by_spatial_proximity", reinterpret_cast<getter>(RemoteSystemApp_get_IsAvailableBySpatialProximity), nullptr, nullptr, nullptr },
        { "connection_token", reinterpret_cast<getter>(RemoteSystemApp_get_ConnectionToken), nullptr, nullptr, nullptr },
        { "user", reinterpret_cast<getter>(RemoteSystemApp_get_User), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_RemoteSystemApp[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_RemoteSystemApp) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_RemoteSystemApp) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_RemoteSystemApp) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_RemoteSystemApp) },
        { },
    };

    static PyType_Spec type_spec_RemoteSystemApp =
    {
        "_winrt_Windows_System_RemoteSystems.RemoteSystemApp",
        sizeof(py::wrapper::Windows::System::RemoteSystems::RemoteSystemApp),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RemoteSystemApp
    };

    // ----- RemoteSystemAppRegistration class --------------------
    static constexpr const char* const type_name_RemoteSystemAppRegistration = "RemoteSystemAppRegistration";

    static PyObject* _new_RemoteSystemAppRegistration(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_RemoteSystemAppRegistration);
        return nullptr;
    }

    static void _dealloc_RemoteSystemAppRegistration(py::wrapper::Windows::System::RemoteSystems::RemoteSystemAppRegistration* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* RemoteSystemAppRegistration_GetDefault(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.RemoteSystems.RemoteSystemAppRegistration", L"GetDefault", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::System::RemoteSystems::RemoteSystemAppRegistration::GetDefault());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RemoteSystemAppRegistration_GetForUser(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.RemoteSystems.RemoteSystemAppRegistration", L"GetForUser", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::System::User>(args, 0);

                return py::convert(winrt::Windows::System::RemoteSystems::RemoteSystemAppRegistration::GetForUser(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RemoteSystemAppRegistration_SaveAsync(py::wrapper::Windows::System::RemoteSystems::RemoteSystemAppRegistration* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.RemoteSystems.RemoteSystemAppRegistration", L"SaveAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.SaveAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RemoteSystemAppRegistration_get_Attributes(py::wrapper::Windows::System::RemoteSystems::RemoteSystemAppRegistration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.RemoteSystems.RemoteSystemAppRegistration", L"Attributes"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Attributes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RemoteSystemAppRegistration_get_User(py::wrapper::Windows::System::RemoteSystems::RemoteSystemAppRegistration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.RemoteSystems.RemoteSystemAppRegistration", L"User"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.User());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_RemoteSystemAppRegistration(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::System::RemoteSystems::RemoteSystemAppRegistration>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_RemoteSystemAppRegistration(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::RemoteSystems::RemoteSystemAppRegistration>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RemoteSystemAppRegistration[] = {
        { "get_default", reinterpret_cast<PyCFunction>(RemoteSystemAppRegistration_GetDefault), METH_VARARGS | METH_STATIC, nullptr },
        { "get_for_user", reinterpret_cast<PyCFunction>(RemoteSystemAppRegistration_GetForUser), METH_VARARGS | METH_STATIC, nullptr },
        { "save_async", reinterpret_cast<PyCFunction>(RemoteSystemAppRegistration_SaveAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_RemoteSystemAppRegistration, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_RemoteSystemAppRegistration), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_RemoteSystemAppRegistration[] = {
        { "attributes", reinterpret_cast<getter>(RemoteSystemAppRegistration_get_Attributes), nullptr, nullptr, nullptr },
        { "user", reinterpret_cast<getter>(RemoteSystemAppRegistration_get_User), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_RemoteSystemAppRegistration[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_RemoteSystemAppRegistration) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_RemoteSystemAppRegistration) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_RemoteSystemAppRegistration) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_RemoteSystemAppRegistration) },
        { },
    };

    static PyType_Spec type_spec_RemoteSystemAppRegistration =
    {
        "_winrt_Windows_System_RemoteSystems.RemoteSystemAppRegistration",
        sizeof(py::wrapper::Windows::System::RemoteSystems::RemoteSystemAppRegistration),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RemoteSystemAppRegistration
    };

    // ----- RemoteSystemAuthorizationKindFilter class --------------------
    static constexpr const char* const type_name_RemoteSystemAuthorizationKindFilter = "RemoteSystemAuthorizationKindFilter";

    static PyObject* _new_RemoteSystemAuthorizationKindFilter(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::System::RemoteSystems::RemoteSystemAuthorizationKind>(args, 0);

                winrt::Windows::System::RemoteSystems::RemoteSystemAuthorizationKindFilter instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_RemoteSystemAuthorizationKindFilter(py::wrapper::Windows::System::RemoteSystems::RemoteSystemAuthorizationKindFilter* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* RemoteSystemAuthorizationKindFilter_get_RemoteSystemAuthorizationKind(py::wrapper::Windows::System::RemoteSystems::RemoteSystemAuthorizationKindFilter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.RemoteSystems.RemoteSystemAuthorizationKindFilter", L"RemoteSystemAuthorizationKind"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RemoteSystemAuthorizationKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_RemoteSystemAuthorizationKindFilter(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::System::RemoteSystems::RemoteSystemAuthorizationKindFilter>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_RemoteSystemAuthorizationKindFilter(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::RemoteSystems::RemoteSystemAuthorizationKindFilter>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RemoteSystemAuthorizationKindFilter[] = {
        { "_assign_array_", _assign_array_RemoteSystemAuthorizationKindFilter, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_RemoteSystemAuthorizationKindFilter), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_RemoteSystemAuthorizationKindFilter[] = {
        { "remote_system_authorization_kind", reinterpret_cast<getter>(RemoteSystemAuthorizationKindFilter_get_RemoteSystemAuthorizationKind), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_RemoteSystemAuthorizationKindFilter[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_RemoteSystemAuthorizationKindFilter) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_RemoteSystemAuthorizationKindFilter) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_RemoteSystemAuthorizationKindFilter) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_RemoteSystemAuthorizationKindFilter) },
        { },
    };

    static PyType_Spec type_spec_RemoteSystemAuthorizationKindFilter =
    {
        "_winrt_Windows_System_RemoteSystems.RemoteSystemAuthorizationKindFilter",
        sizeof(py::wrapper::Windows::System::RemoteSystems::RemoteSystemAuthorizationKindFilter),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RemoteSystemAuthorizationKindFilter
    };

    // ----- RemoteSystemConnectionInfo class --------------------
    static constexpr const char* const type_name_RemoteSystemConnectionInfo = "RemoteSystemConnectionInfo";

    static PyObject* _new_RemoteSystemConnectionInfo(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_RemoteSystemConnectionInfo);
        return nullptr;
    }

    static void _dealloc_RemoteSystemConnectionInfo(py::wrapper::Windows::System::RemoteSystems::RemoteSystemConnectionInfo* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* RemoteSystemConnectionInfo_TryCreateFromAppServiceConnection(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.RemoteSystems.RemoteSystemConnectionInfo", L"TryCreateFromAppServiceConnection", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::AppService::AppServiceConnection>(args, 0);

                return py::convert(winrt::Windows::System::RemoteSystems::RemoteSystemConnectionInfo::TryCreateFromAppServiceConnection(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RemoteSystemConnectionInfo_get_IsProximal(py::wrapper::Windows::System::RemoteSystems::RemoteSystemConnectionInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.RemoteSystems.RemoteSystemConnectionInfo", L"IsProximal"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsProximal());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_RemoteSystemConnectionInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::System::RemoteSystems::RemoteSystemConnectionInfo>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_RemoteSystemConnectionInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::RemoteSystems::RemoteSystemConnectionInfo>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RemoteSystemConnectionInfo[] = {
        { "try_create_from_app_service_connection", reinterpret_cast<PyCFunction>(RemoteSystemConnectionInfo_TryCreateFromAppServiceConnection), METH_VARARGS | METH_STATIC, nullptr },
        { "_assign_array_", _assign_array_RemoteSystemConnectionInfo, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_RemoteSystemConnectionInfo), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_RemoteSystemConnectionInfo[] = {
        { "is_proximal", reinterpret_cast<getter>(RemoteSystemConnectionInfo_get_IsProximal), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_RemoteSystemConnectionInfo[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_RemoteSystemConnectionInfo) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_RemoteSystemConnectionInfo) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_RemoteSystemConnectionInfo) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_RemoteSystemConnectionInfo) },
        { },
    };

    static PyType_Spec type_spec_RemoteSystemConnectionInfo =
    {
        "_winrt_Windows_System_RemoteSystems.RemoteSystemConnectionInfo",
        sizeof(py::wrapper::Windows::System::RemoteSystems::RemoteSystemConnectionInfo),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RemoteSystemConnectionInfo
    };

    // ----- RemoteSystemConnectionRequest class --------------------
    static constexpr const char* const type_name_RemoteSystemConnectionRequest = "RemoteSystemConnectionRequest";

    static PyObject* _new_RemoteSystemConnectionRequest(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::System::RemoteSystems::RemoteSystem>(args, 0);

                winrt::Windows::System::RemoteSystems::RemoteSystemConnectionRequest instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_RemoteSystemConnectionRequest(py::wrapper::Windows::System::RemoteSystems::RemoteSystemConnectionRequest* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* RemoteSystemConnectionRequest_CreateForApp(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.RemoteSystems.RemoteSystemConnectionRequest", L"CreateForApp", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::System::RemoteSystems::RemoteSystemApp>(args, 0);

                return py::convert(winrt::Windows::System::RemoteSystems::RemoteSystemConnectionRequest::CreateForApp(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RemoteSystemConnectionRequest_CreateFromConnectionToken(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.RemoteSystems.RemoteSystemConnectionRequest", L"CreateFromConnectionToken", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::System::RemoteSystems::RemoteSystemConnectionRequest::CreateFromConnectionToken(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RemoteSystemConnectionRequest_CreateFromConnectionTokenForUser(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.RemoteSystems.RemoteSystemConnectionRequest", L"CreateFromConnectionTokenForUser", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::System::User>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(winrt::Windows::System::RemoteSystems::RemoteSystemConnectionRequest::CreateFromConnectionTokenForUser(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RemoteSystemConnectionRequest_get_RemoteSystem(py::wrapper::Windows::System::RemoteSystems::RemoteSystemConnectionRequest* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.RemoteSystems.RemoteSystemConnectionRequest", L"RemoteSystem"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RemoteSystem());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RemoteSystemConnectionRequest_get_RemoteSystemApp(py::wrapper::Windows::System::RemoteSystems::RemoteSystemConnectionRequest* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.RemoteSystems.RemoteSystemConnectionRequest", L"RemoteSystemApp"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RemoteSystemApp());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RemoteSystemConnectionRequest_get_ConnectionToken(py::wrapper::Windows::System::RemoteSystems::RemoteSystemConnectionRequest* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.RemoteSystems.RemoteSystemConnectionRequest", L"ConnectionToken"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ConnectionToken());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_RemoteSystemConnectionRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::System::RemoteSystems::RemoteSystemConnectionRequest>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_RemoteSystemConnectionRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::RemoteSystems::RemoteSystemConnectionRequest>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RemoteSystemConnectionRequest[] = {
        { "create_for_app", reinterpret_cast<PyCFunction>(RemoteSystemConnectionRequest_CreateForApp), METH_VARARGS | METH_STATIC, nullptr },
        { "create_from_connection_token", reinterpret_cast<PyCFunction>(RemoteSystemConnectionRequest_CreateFromConnectionToken), METH_VARARGS | METH_STATIC, nullptr },
        { "create_from_connection_token_for_user", reinterpret_cast<PyCFunction>(RemoteSystemConnectionRequest_CreateFromConnectionTokenForUser), METH_VARARGS | METH_STATIC, nullptr },
        { "_assign_array_", _assign_array_RemoteSystemConnectionRequest, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_RemoteSystemConnectionRequest), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_RemoteSystemConnectionRequest[] = {
        { "remote_system", reinterpret_cast<getter>(RemoteSystemConnectionRequest_get_RemoteSystem), nullptr, nullptr, nullptr },
        { "remote_system_app", reinterpret_cast<getter>(RemoteSystemConnectionRequest_get_RemoteSystemApp), nullptr, nullptr, nullptr },
        { "connection_token", reinterpret_cast<getter>(RemoteSystemConnectionRequest_get_ConnectionToken), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_RemoteSystemConnectionRequest[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_RemoteSystemConnectionRequest) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_RemoteSystemConnectionRequest) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_RemoteSystemConnectionRequest) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_RemoteSystemConnectionRequest) },
        { },
    };

    static PyType_Spec type_spec_RemoteSystemConnectionRequest =
    {
        "_winrt_Windows_System_RemoteSystems.RemoteSystemConnectionRequest",
        sizeof(py::wrapper::Windows::System::RemoteSystems::RemoteSystemConnectionRequest),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RemoteSystemConnectionRequest
    };

    // ----- RemoteSystemDiscoveryTypeFilter class --------------------
    static constexpr const char* const type_name_RemoteSystemDiscoveryTypeFilter = "RemoteSystemDiscoveryTypeFilter";

    static PyObject* _new_RemoteSystemDiscoveryTypeFilter(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::System::RemoteSystems::RemoteSystemDiscoveryType>(args, 0);

                winrt::Windows::System::RemoteSystems::RemoteSystemDiscoveryTypeFilter instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_RemoteSystemDiscoveryTypeFilter(py::wrapper::Windows::System::RemoteSystems::RemoteSystemDiscoveryTypeFilter* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* RemoteSystemDiscoveryTypeFilter_get_RemoteSystemDiscoveryType(py::wrapper::Windows::System::RemoteSystems::RemoteSystemDiscoveryTypeFilter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.RemoteSystems.RemoteSystemDiscoveryTypeFilter", L"RemoteSystemDiscoveryType"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RemoteSystemDiscoveryType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_RemoteSystemDiscoveryTypeFilter(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::System::RemoteSystems::RemoteSystemDiscoveryTypeFilter>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_RemoteSystemDiscoveryTypeFilter(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::RemoteSystems::RemoteSystemDiscoveryTypeFilter>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RemoteSystemDiscoveryTypeFilter[] = {
        { "_assign_array_", _assign_array_RemoteSystemDiscoveryTypeFilter, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_RemoteSystemDiscoveryTypeFilter), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_RemoteSystemDiscoveryTypeFilter[] = {
        { "remote_system_discovery_type", reinterpret_cast<getter>(RemoteSystemDiscoveryTypeFilter_get_RemoteSystemDiscoveryType), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_RemoteSystemDiscoveryTypeFilter[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_RemoteSystemDiscoveryTypeFilter) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_RemoteSystemDiscoveryTypeFilter) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_RemoteSystemDiscoveryTypeFilter) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_RemoteSystemDiscoveryTypeFilter) },
        { },
    };

    static PyType_Spec type_spec_RemoteSystemDiscoveryTypeFilter =
    {
        "_winrt_Windows_System_RemoteSystems.RemoteSystemDiscoveryTypeFilter",
        sizeof(py::wrapper::Windows::System::RemoteSystems::RemoteSystemDiscoveryTypeFilter),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RemoteSystemDiscoveryTypeFilter
    };

    // ----- RemoteSystemEnumerationCompletedEventArgs class --------------------
    static constexpr const char* const type_name_RemoteSystemEnumerationCompletedEventArgs = "RemoteSystemEnumerationCompletedEventArgs";

    static PyObject* _new_RemoteSystemEnumerationCompletedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_RemoteSystemEnumerationCompletedEventArgs);
        return nullptr;
    }

    static void _dealloc_RemoteSystemEnumerationCompletedEventArgs(py::wrapper::Windows::System::RemoteSystems::RemoteSystemEnumerationCompletedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_RemoteSystemEnumerationCompletedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::System::RemoteSystems::RemoteSystemEnumerationCompletedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_RemoteSystemEnumerationCompletedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::RemoteSystems::RemoteSystemEnumerationCompletedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RemoteSystemEnumerationCompletedEventArgs[] = {
        { "_assign_array_", _assign_array_RemoteSystemEnumerationCompletedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_RemoteSystemEnumerationCompletedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_RemoteSystemEnumerationCompletedEventArgs[] = {
        { }
    };

    static PyType_Slot _type_slots_RemoteSystemEnumerationCompletedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_RemoteSystemEnumerationCompletedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_RemoteSystemEnumerationCompletedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_RemoteSystemEnumerationCompletedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_RemoteSystemEnumerationCompletedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_RemoteSystemEnumerationCompletedEventArgs =
    {
        "_winrt_Windows_System_RemoteSystems.RemoteSystemEnumerationCompletedEventArgs",
        sizeof(py::wrapper::Windows::System::RemoteSystems::RemoteSystemEnumerationCompletedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RemoteSystemEnumerationCompletedEventArgs
    };

    // ----- RemoteSystemKindFilter class --------------------
    static constexpr const char* const type_name_RemoteSystemKindFilter = "RemoteSystemKindFilter";

    static PyObject* _new_RemoteSystemKindFilter(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 0);

                winrt::Windows::System::RemoteSystems::RemoteSystemKindFilter instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_RemoteSystemKindFilter(py::wrapper::Windows::System::RemoteSystems::RemoteSystemKindFilter* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* RemoteSystemKindFilter_get_RemoteSystemKinds(py::wrapper::Windows::System::RemoteSystems::RemoteSystemKindFilter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.RemoteSystems.RemoteSystemKindFilter", L"RemoteSystemKinds"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RemoteSystemKinds());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_RemoteSystemKindFilter(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::System::RemoteSystems::RemoteSystemKindFilter>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_RemoteSystemKindFilter(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::RemoteSystems::RemoteSystemKindFilter>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RemoteSystemKindFilter[] = {
        { "_assign_array_", _assign_array_RemoteSystemKindFilter, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_RemoteSystemKindFilter), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_RemoteSystemKindFilter[] = {
        { "remote_system_kinds", reinterpret_cast<getter>(RemoteSystemKindFilter_get_RemoteSystemKinds), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_RemoteSystemKindFilter[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_RemoteSystemKindFilter) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_RemoteSystemKindFilter) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_RemoteSystemKindFilter) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_RemoteSystemKindFilter) },
        { },
    };

    static PyType_Spec type_spec_RemoteSystemKindFilter =
    {
        "_winrt_Windows_System_RemoteSystems.RemoteSystemKindFilter",
        sizeof(py::wrapper::Windows::System::RemoteSystems::RemoteSystemKindFilter),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RemoteSystemKindFilter
    };

    // ----- RemoteSystemKinds class --------------------
    static constexpr const char* const type_name_RemoteSystemKinds = "RemoteSystemKinds";

    static PyObject* _new_RemoteSystemKinds(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_RemoteSystemKinds);
        return nullptr;
    }

    static PyObject* RemoteSystemKinds_get_Desktop(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.RemoteSystems.RemoteSystemKinds", L"Desktop"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::System::RemoteSystems::RemoteSystemKinds::Desktop());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RemoteSystemKinds_get_Holographic(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.RemoteSystems.RemoteSystemKinds", L"Holographic"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::System::RemoteSystems::RemoteSystemKinds::Holographic());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RemoteSystemKinds_get_Hub(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.RemoteSystems.RemoteSystemKinds", L"Hub"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::System::RemoteSystems::RemoteSystemKinds::Hub());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RemoteSystemKinds_get_Phone(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.RemoteSystems.RemoteSystemKinds", L"Phone"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::System::RemoteSystems::RemoteSystemKinds::Phone());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RemoteSystemKinds_get_Xbox(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.RemoteSystems.RemoteSystemKinds", L"Xbox"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::System::RemoteSystems::RemoteSystemKinds::Xbox());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RemoteSystemKinds_get_Iot(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.RemoteSystems.RemoteSystemKinds", L"Iot"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::System::RemoteSystems::RemoteSystemKinds::Iot());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RemoteSystemKinds_get_Laptop(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.RemoteSystems.RemoteSystemKinds", L"Laptop"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::System::RemoteSystems::RemoteSystemKinds::Laptop());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RemoteSystemKinds_get_Tablet(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.RemoteSystems.RemoteSystemKinds", L"Tablet"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::System::RemoteSystems::RemoteSystemKinds::Tablet());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RemoteSystemKinds[] = {
        { }
    };

    static PyGetSetDef _getset_RemoteSystemKinds[] = {
        { }
    };

    static PyType_Slot _type_slots_RemoteSystemKinds[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_RemoteSystemKinds) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_RemoteSystemKinds) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_RemoteSystemKinds) },
        { },
    };

    static PyType_Spec type_spec_RemoteSystemKinds =
    {
        "_winrt_Windows_System_RemoteSystems.RemoteSystemKinds",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RemoteSystemKinds
    };

    static PyGetSetDef getset_RemoteSystemKinds_Meta[] = {
        { "desktop", reinterpret_cast<getter>(RemoteSystemKinds_get_Desktop), nullptr, nullptr, nullptr },
        { "holographic", reinterpret_cast<getter>(RemoteSystemKinds_get_Holographic), nullptr, nullptr, nullptr },
        { "hub", reinterpret_cast<getter>(RemoteSystemKinds_get_Hub), nullptr, nullptr, nullptr },
        { "phone", reinterpret_cast<getter>(RemoteSystemKinds_get_Phone), nullptr, nullptr, nullptr },
        { "xbox", reinterpret_cast<getter>(RemoteSystemKinds_get_Xbox), nullptr, nullptr, nullptr },
        { "iot", reinterpret_cast<getter>(RemoteSystemKinds_get_Iot), nullptr, nullptr, nullptr },
        { "laptop", reinterpret_cast<getter>(RemoteSystemKinds_get_Laptop), nullptr, nullptr, nullptr },
        { "tablet", reinterpret_cast<getter>(RemoteSystemKinds_get_Tablet), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot type_slots_RemoteSystemKinds_Meta[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_RemoteSystemKinds_Meta) },
        { }
    };

    static PyType_Spec type_spec_RemoteSystemKinds_Meta =
    {
        "_winrt_Windows_System_RemoteSystems.RemoteSystemKinds_Meta",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_RemoteSystemKinds_Meta
    };

    // ----- RemoteSystemRemovedEventArgs class --------------------
    static constexpr const char* const type_name_RemoteSystemRemovedEventArgs = "RemoteSystemRemovedEventArgs";

    static PyObject* _new_RemoteSystemRemovedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_RemoteSystemRemovedEventArgs);
        return nullptr;
    }

    static void _dealloc_RemoteSystemRemovedEventArgs(py::wrapper::Windows::System::RemoteSystems::RemoteSystemRemovedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* RemoteSystemRemovedEventArgs_get_RemoteSystemId(py::wrapper::Windows::System::RemoteSystems::RemoteSystemRemovedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.RemoteSystems.RemoteSystemRemovedEventArgs", L"RemoteSystemId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RemoteSystemId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_RemoteSystemRemovedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::System::RemoteSystems::RemoteSystemRemovedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_RemoteSystemRemovedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::RemoteSystems::RemoteSystemRemovedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RemoteSystemRemovedEventArgs[] = {
        { "_assign_array_", _assign_array_RemoteSystemRemovedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_RemoteSystemRemovedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_RemoteSystemRemovedEventArgs[] = {
        { "remote_system_id", reinterpret_cast<getter>(RemoteSystemRemovedEventArgs_get_RemoteSystemId), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_RemoteSystemRemovedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_RemoteSystemRemovedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_RemoteSystemRemovedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_RemoteSystemRemovedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_RemoteSystemRemovedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_RemoteSystemRemovedEventArgs =
    {
        "_winrt_Windows_System_RemoteSystems.RemoteSystemRemovedEventArgs",
        sizeof(py::wrapper::Windows::System::RemoteSystems::RemoteSystemRemovedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RemoteSystemRemovedEventArgs
    };

    // ----- RemoteSystemSession class --------------------
    static constexpr const char* const type_name_RemoteSystemSession = "RemoteSystemSession";

    static PyObject* _new_RemoteSystemSession(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_RemoteSystemSession);
        return nullptr;
    }

    static void _dealloc_RemoteSystemSession(py::wrapper::Windows::System::RemoteSystems::RemoteSystemSession* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* RemoteSystemSession_Close(py::wrapper::Windows::System::RemoteSystems::RemoteSystemSession* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.RemoteSystems.RemoteSystemSession", L"Close", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RemoteSystemSession_CreateParticipantWatcher(py::wrapper::Windows::System::RemoteSystems::RemoteSystemSession* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.RemoteSystems.RemoteSystemSession", L"CreateParticipantWatcher", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.CreateParticipantWatcher());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RemoteSystemSession_CreateWatcher(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.RemoteSystems.RemoteSystemSession", L"CreateWatcher", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::System::RemoteSystems::RemoteSystemSession::CreateWatcher());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RemoteSystemSession_SendInvitationAsync(py::wrapper::Windows::System::RemoteSystems::RemoteSystemSession* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.RemoteSystems.RemoteSystemSession", L"SendInvitationAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::System::RemoteSystems::RemoteSystem>(args, 0);

                return py::convert(self->obj.SendInvitationAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RemoteSystemSession_get_ControllerDisplayName(py::wrapper::Windows::System::RemoteSystems::RemoteSystemSession* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.RemoteSystems.RemoteSystemSession", L"ControllerDisplayName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ControllerDisplayName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RemoteSystemSession_get_DisplayName(py::wrapper::Windows::System::RemoteSystems::RemoteSystemSession* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.RemoteSystems.RemoteSystemSession", L"DisplayName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DisplayName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RemoteSystemSession_get_Id(py::wrapper::Windows::System::RemoteSystems::RemoteSystemSession* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.RemoteSystems.RemoteSystemSession", L"Id"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RemoteSystemSession_add_Disconnected(py::wrapper::Windows::System::RemoteSystems::RemoteSystemSession* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.System.RemoteSystems.RemoteSystemSession", L"Disconnected"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::System::RemoteSystems::RemoteSystemSession, winrt::Windows::System::RemoteSystems::RemoteSystemSessionDisconnectedEventArgs>>(arg);

            return py::convert(self->obj.Disconnected(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RemoteSystemSession_remove_Disconnected(py::wrapper::Windows::System::RemoteSystems::RemoteSystemSession* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.System.RemoteSystems.RemoteSystemSession", L"Disconnected"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Disconnected(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_RemoteSystemSession(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::System::RemoteSystems::RemoteSystemSession>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_RemoteSystemSession(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::RemoteSystems::RemoteSystemSession>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_RemoteSystemSession(py::wrapper::Windows::System::RemoteSystems::RemoteSystemSession* self) noexcept
    {
        Py_INCREF(self);
        return reinterpret_cast<PyObject*>(self);
    }

    static PyObject* _exit_RemoteSystemSession(py::wrapper::Windows::System::RemoteSystems::RemoteSystemSession* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RemoteSystemSession[] = {
        { "close", reinterpret_cast<PyCFunction>(RemoteSystemSession_Close), METH_VARARGS, nullptr },
        { "create_participant_watcher", reinterpret_cast<PyCFunction>(RemoteSystemSession_CreateParticipantWatcher), METH_VARARGS, nullptr },
        { "create_watcher", reinterpret_cast<PyCFunction>(RemoteSystemSession_CreateWatcher), METH_VARARGS | METH_STATIC, nullptr },
        { "send_invitation_async", reinterpret_cast<PyCFunction>(RemoteSystemSession_SendInvitationAsync), METH_VARARGS, nullptr },
        { "add_disconnected", reinterpret_cast<PyCFunction>(RemoteSystemSession_add_Disconnected), METH_O, nullptr },
        { "remove_disconnected", reinterpret_cast<PyCFunction>(RemoteSystemSession_remove_Disconnected), METH_O, nullptr },
        { "_assign_array_", _assign_array_RemoteSystemSession, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_RemoteSystemSession), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_RemoteSystemSession), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_RemoteSystemSession), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_RemoteSystemSession[] = {
        { "controller_display_name", reinterpret_cast<getter>(RemoteSystemSession_get_ControllerDisplayName), nullptr, nullptr, nullptr },
        { "display_name", reinterpret_cast<getter>(RemoteSystemSession_get_DisplayName), nullptr, nullptr, nullptr },
        { "id", reinterpret_cast<getter>(RemoteSystemSession_get_Id), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_RemoteSystemSession[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_RemoteSystemSession) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_RemoteSystemSession) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_RemoteSystemSession) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_RemoteSystemSession) },
        { },
    };

    static PyType_Spec type_spec_RemoteSystemSession =
    {
        "_winrt_Windows_System_RemoteSystems.RemoteSystemSession",
        sizeof(py::wrapper::Windows::System::RemoteSystems::RemoteSystemSession),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RemoteSystemSession
    };

    // ----- RemoteSystemSessionAddedEventArgs class --------------------
    static constexpr const char* const type_name_RemoteSystemSessionAddedEventArgs = "RemoteSystemSessionAddedEventArgs";

    static PyObject* _new_RemoteSystemSessionAddedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_RemoteSystemSessionAddedEventArgs);
        return nullptr;
    }

    static void _dealloc_RemoteSystemSessionAddedEventArgs(py::wrapper::Windows::System::RemoteSystems::RemoteSystemSessionAddedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* RemoteSystemSessionAddedEventArgs_get_SessionInfo(py::wrapper::Windows::System::RemoteSystems::RemoteSystemSessionAddedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.RemoteSystems.RemoteSystemSessionAddedEventArgs", L"SessionInfo"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SessionInfo());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_RemoteSystemSessionAddedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::System::RemoteSystems::RemoteSystemSessionAddedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_RemoteSystemSessionAddedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::RemoteSystems::RemoteSystemSessionAddedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RemoteSystemSessionAddedEventArgs[] = {
        { "_assign_array_", _assign_array_RemoteSystemSessionAddedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_RemoteSystemSessionAddedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_RemoteSystemSessionAddedEventArgs[] = {
        { "session_info", reinterpret_cast<getter>(RemoteSystemSessionAddedEventArgs_get_SessionInfo), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_RemoteSystemSessionAddedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_RemoteSystemSessionAddedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_RemoteSystemSessionAddedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_RemoteSystemSessionAddedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_RemoteSystemSessionAddedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_RemoteSystemSessionAddedEventArgs =
    {
        "_winrt_Windows_System_RemoteSystems.RemoteSystemSessionAddedEventArgs",
        sizeof(py::wrapper::Windows::System::RemoteSystems::RemoteSystemSessionAddedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RemoteSystemSessionAddedEventArgs
    };

    // ----- RemoteSystemSessionController class --------------------
    static constexpr const char* const type_name_RemoteSystemSessionController = "RemoteSystemSessionController";

    static PyObject* _new_RemoteSystemSessionController(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                winrt::Windows::System::RemoteSystems::RemoteSystemSessionController instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::System::RemoteSystems::RemoteSystemSessionOptions>(args, 1);

                winrt::Windows::System::RemoteSystems::RemoteSystemSessionController instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_RemoteSystemSessionController(py::wrapper::Windows::System::RemoteSystems::RemoteSystemSessionController* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* RemoteSystemSessionController_CreateSessionAsync(py::wrapper::Windows::System::RemoteSystems::RemoteSystemSessionController* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.RemoteSystems.RemoteSystemSessionController", L"CreateSessionAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.CreateSessionAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RemoteSystemSessionController_RemoveParticipantAsync(py::wrapper::Windows::System::RemoteSystems::RemoteSystemSessionController* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.RemoteSystems.RemoteSystemSessionController", L"RemoveParticipantAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::System::RemoteSystems::RemoteSystemSessionParticipant>(args, 0);

                return py::convert(self->obj.RemoveParticipantAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RemoteSystemSessionController_add_JoinRequested(py::wrapper::Windows::System::RemoteSystems::RemoteSystemSessionController* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.System.RemoteSystems.RemoteSystemSessionController", L"JoinRequested"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::System::RemoteSystems::RemoteSystemSessionController, winrt::Windows::System::RemoteSystems::RemoteSystemSessionJoinRequestedEventArgs>>(arg);

            return py::convert(self->obj.JoinRequested(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RemoteSystemSessionController_remove_JoinRequested(py::wrapper::Windows::System::RemoteSystems::RemoteSystemSessionController* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.System.RemoteSystems.RemoteSystemSessionController", L"JoinRequested"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.JoinRequested(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_RemoteSystemSessionController(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::System::RemoteSystems::RemoteSystemSessionController>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_RemoteSystemSessionController(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::RemoteSystems::RemoteSystemSessionController>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RemoteSystemSessionController[] = {
        { "create_session_async", reinterpret_cast<PyCFunction>(RemoteSystemSessionController_CreateSessionAsync), METH_VARARGS, nullptr },
        { "remove_participant_async", reinterpret_cast<PyCFunction>(RemoteSystemSessionController_RemoveParticipantAsync), METH_VARARGS, nullptr },
        { "add_join_requested", reinterpret_cast<PyCFunction>(RemoteSystemSessionController_add_JoinRequested), METH_O, nullptr },
        { "remove_join_requested", reinterpret_cast<PyCFunction>(RemoteSystemSessionController_remove_JoinRequested), METH_O, nullptr },
        { "_assign_array_", _assign_array_RemoteSystemSessionController, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_RemoteSystemSessionController), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_RemoteSystemSessionController[] = {
        { }
    };

    static PyType_Slot _type_slots_RemoteSystemSessionController[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_RemoteSystemSessionController) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_RemoteSystemSessionController) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_RemoteSystemSessionController) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_RemoteSystemSessionController) },
        { },
    };

    static PyType_Spec type_spec_RemoteSystemSessionController =
    {
        "_winrt_Windows_System_RemoteSystems.RemoteSystemSessionController",
        sizeof(py::wrapper::Windows::System::RemoteSystems::RemoteSystemSessionController),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RemoteSystemSessionController
    };

    // ----- RemoteSystemSessionCreationResult class --------------------
    static constexpr const char* const type_name_RemoteSystemSessionCreationResult = "RemoteSystemSessionCreationResult";

    static PyObject* _new_RemoteSystemSessionCreationResult(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_RemoteSystemSessionCreationResult);
        return nullptr;
    }

    static void _dealloc_RemoteSystemSessionCreationResult(py::wrapper::Windows::System::RemoteSystems::RemoteSystemSessionCreationResult* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* RemoteSystemSessionCreationResult_get_Session(py::wrapper::Windows::System::RemoteSystems::RemoteSystemSessionCreationResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.RemoteSystems.RemoteSystemSessionCreationResult", L"Session"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Session());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RemoteSystemSessionCreationResult_get_Status(py::wrapper::Windows::System::RemoteSystems::RemoteSystemSessionCreationResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.RemoteSystems.RemoteSystemSessionCreationResult", L"Status"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_RemoteSystemSessionCreationResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::System::RemoteSystems::RemoteSystemSessionCreationResult>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_RemoteSystemSessionCreationResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::RemoteSystems::RemoteSystemSessionCreationResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RemoteSystemSessionCreationResult[] = {
        { "_assign_array_", _assign_array_RemoteSystemSessionCreationResult, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_RemoteSystemSessionCreationResult), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_RemoteSystemSessionCreationResult[] = {
        { "session", reinterpret_cast<getter>(RemoteSystemSessionCreationResult_get_Session), nullptr, nullptr, nullptr },
        { "status", reinterpret_cast<getter>(RemoteSystemSessionCreationResult_get_Status), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_RemoteSystemSessionCreationResult[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_RemoteSystemSessionCreationResult) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_RemoteSystemSessionCreationResult) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_RemoteSystemSessionCreationResult) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_RemoteSystemSessionCreationResult) },
        { },
    };

    static PyType_Spec type_spec_RemoteSystemSessionCreationResult =
    {
        "_winrt_Windows_System_RemoteSystems.RemoteSystemSessionCreationResult",
        sizeof(py::wrapper::Windows::System::RemoteSystems::RemoteSystemSessionCreationResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RemoteSystemSessionCreationResult
    };

    // ----- RemoteSystemSessionDisconnectedEventArgs class --------------------
    static constexpr const char* const type_name_RemoteSystemSessionDisconnectedEventArgs = "RemoteSystemSessionDisconnectedEventArgs";

    static PyObject* _new_RemoteSystemSessionDisconnectedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_RemoteSystemSessionDisconnectedEventArgs);
        return nullptr;
    }

    static void _dealloc_RemoteSystemSessionDisconnectedEventArgs(py::wrapper::Windows::System::RemoteSystems::RemoteSystemSessionDisconnectedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* RemoteSystemSessionDisconnectedEventArgs_get_Reason(py::wrapper::Windows::System::RemoteSystems::RemoteSystemSessionDisconnectedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.RemoteSystems.RemoteSystemSessionDisconnectedEventArgs", L"Reason"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Reason());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_RemoteSystemSessionDisconnectedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::System::RemoteSystems::RemoteSystemSessionDisconnectedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_RemoteSystemSessionDisconnectedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::RemoteSystems::RemoteSystemSessionDisconnectedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RemoteSystemSessionDisconnectedEventArgs[] = {
        { "_assign_array_", _assign_array_RemoteSystemSessionDisconnectedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_RemoteSystemSessionDisconnectedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_RemoteSystemSessionDisconnectedEventArgs[] = {
        { "reason", reinterpret_cast<getter>(RemoteSystemSessionDisconnectedEventArgs_get_Reason), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_RemoteSystemSessionDisconnectedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_RemoteSystemSessionDisconnectedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_RemoteSystemSessionDisconnectedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_RemoteSystemSessionDisconnectedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_RemoteSystemSessionDisconnectedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_RemoteSystemSessionDisconnectedEventArgs =
    {
        "_winrt_Windows_System_RemoteSystems.RemoteSystemSessionDisconnectedEventArgs",
        sizeof(py::wrapper::Windows::System::RemoteSystems::RemoteSystemSessionDisconnectedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RemoteSystemSessionDisconnectedEventArgs
    };

    // ----- RemoteSystemSessionInfo class --------------------
    static constexpr const char* const type_name_RemoteSystemSessionInfo = "RemoteSystemSessionInfo";

    static PyObject* _new_RemoteSystemSessionInfo(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_RemoteSystemSessionInfo);
        return nullptr;
    }

    static void _dealloc_RemoteSystemSessionInfo(py::wrapper::Windows::System::RemoteSystems::RemoteSystemSessionInfo* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* RemoteSystemSessionInfo_JoinAsync(py::wrapper::Windows::System::RemoteSystems::RemoteSystemSessionInfo* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.RemoteSystems.RemoteSystemSessionInfo", L"JoinAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.JoinAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RemoteSystemSessionInfo_get_ControllerDisplayName(py::wrapper::Windows::System::RemoteSystems::RemoteSystemSessionInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.RemoteSystems.RemoteSystemSessionInfo", L"ControllerDisplayName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ControllerDisplayName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RemoteSystemSessionInfo_get_DisplayName(py::wrapper::Windows::System::RemoteSystems::RemoteSystemSessionInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.RemoteSystems.RemoteSystemSessionInfo", L"DisplayName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DisplayName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_RemoteSystemSessionInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::System::RemoteSystems::RemoteSystemSessionInfo>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_RemoteSystemSessionInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::RemoteSystems::RemoteSystemSessionInfo>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RemoteSystemSessionInfo[] = {
        { "join_async", reinterpret_cast<PyCFunction>(RemoteSystemSessionInfo_JoinAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_RemoteSystemSessionInfo, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_RemoteSystemSessionInfo), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_RemoteSystemSessionInfo[] = {
        { "controller_display_name", reinterpret_cast<getter>(RemoteSystemSessionInfo_get_ControllerDisplayName), nullptr, nullptr, nullptr },
        { "display_name", reinterpret_cast<getter>(RemoteSystemSessionInfo_get_DisplayName), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_RemoteSystemSessionInfo[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_RemoteSystemSessionInfo) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_RemoteSystemSessionInfo) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_RemoteSystemSessionInfo) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_RemoteSystemSessionInfo) },
        { },
    };

    static PyType_Spec type_spec_RemoteSystemSessionInfo =
    {
        "_winrt_Windows_System_RemoteSystems.RemoteSystemSessionInfo",
        sizeof(py::wrapper::Windows::System::RemoteSystems::RemoteSystemSessionInfo),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RemoteSystemSessionInfo
    };

    // ----- RemoteSystemSessionInvitation class --------------------
    static constexpr const char* const type_name_RemoteSystemSessionInvitation = "RemoteSystemSessionInvitation";

    static PyObject* _new_RemoteSystemSessionInvitation(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_RemoteSystemSessionInvitation);
        return nullptr;
    }

    static void _dealloc_RemoteSystemSessionInvitation(py::wrapper::Windows::System::RemoteSystems::RemoteSystemSessionInvitation* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* RemoteSystemSessionInvitation_get_Sender(py::wrapper::Windows::System::RemoteSystems::RemoteSystemSessionInvitation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.RemoteSystems.RemoteSystemSessionInvitation", L"Sender"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Sender());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RemoteSystemSessionInvitation_get_SessionInfo(py::wrapper::Windows::System::RemoteSystems::RemoteSystemSessionInvitation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.RemoteSystems.RemoteSystemSessionInvitation", L"SessionInfo"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SessionInfo());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_RemoteSystemSessionInvitation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::System::RemoteSystems::RemoteSystemSessionInvitation>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_RemoteSystemSessionInvitation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::RemoteSystems::RemoteSystemSessionInvitation>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RemoteSystemSessionInvitation[] = {
        { "_assign_array_", _assign_array_RemoteSystemSessionInvitation, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_RemoteSystemSessionInvitation), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_RemoteSystemSessionInvitation[] = {
        { "sender", reinterpret_cast<getter>(RemoteSystemSessionInvitation_get_Sender), nullptr, nullptr, nullptr },
        { "session_info", reinterpret_cast<getter>(RemoteSystemSessionInvitation_get_SessionInfo), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_RemoteSystemSessionInvitation[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_RemoteSystemSessionInvitation) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_RemoteSystemSessionInvitation) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_RemoteSystemSessionInvitation) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_RemoteSystemSessionInvitation) },
        { },
    };

    static PyType_Spec type_spec_RemoteSystemSessionInvitation =
    {
        "_winrt_Windows_System_RemoteSystems.RemoteSystemSessionInvitation",
        sizeof(py::wrapper::Windows::System::RemoteSystems::RemoteSystemSessionInvitation),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RemoteSystemSessionInvitation
    };

    // ----- RemoteSystemSessionInvitationListener class --------------------
    static constexpr const char* const type_name_RemoteSystemSessionInvitationListener = "RemoteSystemSessionInvitationListener";

    static PyObject* _new_RemoteSystemSessionInvitationListener(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::System::RemoteSystems::RemoteSystemSessionInvitationListener instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_RemoteSystemSessionInvitationListener(py::wrapper::Windows::System::RemoteSystems::RemoteSystemSessionInvitationListener* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* RemoteSystemSessionInvitationListener_add_InvitationReceived(py::wrapper::Windows::System::RemoteSystems::RemoteSystemSessionInvitationListener* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.System.RemoteSystems.RemoteSystemSessionInvitationListener", L"InvitationReceived"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::System::RemoteSystems::RemoteSystemSessionInvitationListener, winrt::Windows::System::RemoteSystems::RemoteSystemSessionInvitationReceivedEventArgs>>(arg);

            return py::convert(self->obj.InvitationReceived(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RemoteSystemSessionInvitationListener_remove_InvitationReceived(py::wrapper::Windows::System::RemoteSystems::RemoteSystemSessionInvitationListener* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.System.RemoteSystems.RemoteSystemSessionInvitationListener", L"InvitationReceived"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.InvitationReceived(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_RemoteSystemSessionInvitationListener(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::System::RemoteSystems::RemoteSystemSessionInvitationListener>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_RemoteSystemSessionInvitationListener(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::RemoteSystems::RemoteSystemSessionInvitationListener>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RemoteSystemSessionInvitationListener[] = {
        { "add_invitation_received", reinterpret_cast<PyCFunction>(RemoteSystemSessionInvitationListener_add_InvitationReceived), METH_O, nullptr },
        { "remove_invitation_received", reinterpret_cast<PyCFunction>(RemoteSystemSessionInvitationListener_remove_InvitationReceived), METH_O, nullptr },
        { "_assign_array_", _assign_array_RemoteSystemSessionInvitationListener, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_RemoteSystemSessionInvitationListener), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_RemoteSystemSessionInvitationListener[] = {
        { }
    };

    static PyType_Slot _type_slots_RemoteSystemSessionInvitationListener[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_RemoteSystemSessionInvitationListener) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_RemoteSystemSessionInvitationListener) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_RemoteSystemSessionInvitationListener) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_RemoteSystemSessionInvitationListener) },
        { },
    };

    static PyType_Spec type_spec_RemoteSystemSessionInvitationListener =
    {
        "_winrt_Windows_System_RemoteSystems.RemoteSystemSessionInvitationListener",
        sizeof(py::wrapper::Windows::System::RemoteSystems::RemoteSystemSessionInvitationListener),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RemoteSystemSessionInvitationListener
    };

    // ----- RemoteSystemSessionInvitationReceivedEventArgs class --------------------
    static constexpr const char* const type_name_RemoteSystemSessionInvitationReceivedEventArgs = "RemoteSystemSessionInvitationReceivedEventArgs";

    static PyObject* _new_RemoteSystemSessionInvitationReceivedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_RemoteSystemSessionInvitationReceivedEventArgs);
        return nullptr;
    }

    static void _dealloc_RemoteSystemSessionInvitationReceivedEventArgs(py::wrapper::Windows::System::RemoteSystems::RemoteSystemSessionInvitationReceivedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* RemoteSystemSessionInvitationReceivedEventArgs_get_Invitation(py::wrapper::Windows::System::RemoteSystems::RemoteSystemSessionInvitationReceivedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.RemoteSystems.RemoteSystemSessionInvitationReceivedEventArgs", L"Invitation"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Invitation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_RemoteSystemSessionInvitationReceivedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::System::RemoteSystems::RemoteSystemSessionInvitationReceivedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_RemoteSystemSessionInvitationReceivedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::RemoteSystems::RemoteSystemSessionInvitationReceivedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RemoteSystemSessionInvitationReceivedEventArgs[] = {
        { "_assign_array_", _assign_array_RemoteSystemSessionInvitationReceivedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_RemoteSystemSessionInvitationReceivedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_RemoteSystemSessionInvitationReceivedEventArgs[] = {
        { "invitation", reinterpret_cast<getter>(RemoteSystemSessionInvitationReceivedEventArgs_get_Invitation), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_RemoteSystemSessionInvitationReceivedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_RemoteSystemSessionInvitationReceivedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_RemoteSystemSessionInvitationReceivedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_RemoteSystemSessionInvitationReceivedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_RemoteSystemSessionInvitationReceivedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_RemoteSystemSessionInvitationReceivedEventArgs =
    {
        "_winrt_Windows_System_RemoteSystems.RemoteSystemSessionInvitationReceivedEventArgs",
        sizeof(py::wrapper::Windows::System::RemoteSystems::RemoteSystemSessionInvitationReceivedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RemoteSystemSessionInvitationReceivedEventArgs
    };

    // ----- RemoteSystemSessionJoinRequest class --------------------
    static constexpr const char* const type_name_RemoteSystemSessionJoinRequest = "RemoteSystemSessionJoinRequest";

    static PyObject* _new_RemoteSystemSessionJoinRequest(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_RemoteSystemSessionJoinRequest);
        return nullptr;
    }

    static void _dealloc_RemoteSystemSessionJoinRequest(py::wrapper::Windows::System::RemoteSystems::RemoteSystemSessionJoinRequest* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* RemoteSystemSessionJoinRequest_Accept(py::wrapper::Windows::System::RemoteSystems::RemoteSystemSessionJoinRequest* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.RemoteSystems.RemoteSystemSessionJoinRequest", L"Accept", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Accept();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RemoteSystemSessionJoinRequest_get_Participant(py::wrapper::Windows::System::RemoteSystems::RemoteSystemSessionJoinRequest* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.RemoteSystems.RemoteSystemSessionJoinRequest", L"Participant"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Participant());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_RemoteSystemSessionJoinRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::System::RemoteSystems::RemoteSystemSessionJoinRequest>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_RemoteSystemSessionJoinRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::RemoteSystems::RemoteSystemSessionJoinRequest>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RemoteSystemSessionJoinRequest[] = {
        { "accept", reinterpret_cast<PyCFunction>(RemoteSystemSessionJoinRequest_Accept), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_RemoteSystemSessionJoinRequest, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_RemoteSystemSessionJoinRequest), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_RemoteSystemSessionJoinRequest[] = {
        { "participant", reinterpret_cast<getter>(RemoteSystemSessionJoinRequest_get_Participant), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_RemoteSystemSessionJoinRequest[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_RemoteSystemSessionJoinRequest) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_RemoteSystemSessionJoinRequest) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_RemoteSystemSessionJoinRequest) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_RemoteSystemSessionJoinRequest) },
        { },
    };

    static PyType_Spec type_spec_RemoteSystemSessionJoinRequest =
    {
        "_winrt_Windows_System_RemoteSystems.RemoteSystemSessionJoinRequest",
        sizeof(py::wrapper::Windows::System::RemoteSystems::RemoteSystemSessionJoinRequest),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RemoteSystemSessionJoinRequest
    };

    // ----- RemoteSystemSessionJoinRequestedEventArgs class --------------------
    static constexpr const char* const type_name_RemoteSystemSessionJoinRequestedEventArgs = "RemoteSystemSessionJoinRequestedEventArgs";

    static PyObject* _new_RemoteSystemSessionJoinRequestedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_RemoteSystemSessionJoinRequestedEventArgs);
        return nullptr;
    }

    static void _dealloc_RemoteSystemSessionJoinRequestedEventArgs(py::wrapper::Windows::System::RemoteSystems::RemoteSystemSessionJoinRequestedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* RemoteSystemSessionJoinRequestedEventArgs_GetDeferral(py::wrapper::Windows::System::RemoteSystems::RemoteSystemSessionJoinRequestedEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.RemoteSystems.RemoteSystemSessionJoinRequestedEventArgs", L"GetDeferral", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RemoteSystemSessionJoinRequestedEventArgs_get_JoinRequest(py::wrapper::Windows::System::RemoteSystems::RemoteSystemSessionJoinRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.RemoteSystems.RemoteSystemSessionJoinRequestedEventArgs", L"JoinRequest"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.JoinRequest());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_RemoteSystemSessionJoinRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::System::RemoteSystems::RemoteSystemSessionJoinRequestedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_RemoteSystemSessionJoinRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::RemoteSystems::RemoteSystemSessionJoinRequestedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RemoteSystemSessionJoinRequestedEventArgs[] = {
        { "get_deferral", reinterpret_cast<PyCFunction>(RemoteSystemSessionJoinRequestedEventArgs_GetDeferral), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_RemoteSystemSessionJoinRequestedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_RemoteSystemSessionJoinRequestedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_RemoteSystemSessionJoinRequestedEventArgs[] = {
        { "join_request", reinterpret_cast<getter>(RemoteSystemSessionJoinRequestedEventArgs_get_JoinRequest), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_RemoteSystemSessionJoinRequestedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_RemoteSystemSessionJoinRequestedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_RemoteSystemSessionJoinRequestedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_RemoteSystemSessionJoinRequestedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_RemoteSystemSessionJoinRequestedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_RemoteSystemSessionJoinRequestedEventArgs =
    {
        "_winrt_Windows_System_RemoteSystems.RemoteSystemSessionJoinRequestedEventArgs",
        sizeof(py::wrapper::Windows::System::RemoteSystems::RemoteSystemSessionJoinRequestedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RemoteSystemSessionJoinRequestedEventArgs
    };

    // ----- RemoteSystemSessionJoinResult class --------------------
    static constexpr const char* const type_name_RemoteSystemSessionJoinResult = "RemoteSystemSessionJoinResult";

    static PyObject* _new_RemoteSystemSessionJoinResult(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_RemoteSystemSessionJoinResult);
        return nullptr;
    }

    static void _dealloc_RemoteSystemSessionJoinResult(py::wrapper::Windows::System::RemoteSystems::RemoteSystemSessionJoinResult* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* RemoteSystemSessionJoinResult_get_Session(py::wrapper::Windows::System::RemoteSystems::RemoteSystemSessionJoinResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.RemoteSystems.RemoteSystemSessionJoinResult", L"Session"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Session());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RemoteSystemSessionJoinResult_get_Status(py::wrapper::Windows::System::RemoteSystems::RemoteSystemSessionJoinResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.RemoteSystems.RemoteSystemSessionJoinResult", L"Status"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_RemoteSystemSessionJoinResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::System::RemoteSystems::RemoteSystemSessionJoinResult>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_RemoteSystemSessionJoinResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::RemoteSystems::RemoteSystemSessionJoinResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RemoteSystemSessionJoinResult[] = {
        { "_assign_array_", _assign_array_RemoteSystemSessionJoinResult, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_RemoteSystemSessionJoinResult), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_RemoteSystemSessionJoinResult[] = {
        { "session", reinterpret_cast<getter>(RemoteSystemSessionJoinResult_get_Session), nullptr, nullptr, nullptr },
        { "status", reinterpret_cast<getter>(RemoteSystemSessionJoinResult_get_Status), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_RemoteSystemSessionJoinResult[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_RemoteSystemSessionJoinResult) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_RemoteSystemSessionJoinResult) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_RemoteSystemSessionJoinResult) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_RemoteSystemSessionJoinResult) },
        { },
    };

    static PyType_Spec type_spec_RemoteSystemSessionJoinResult =
    {
        "_winrt_Windows_System_RemoteSystems.RemoteSystemSessionJoinResult",
        sizeof(py::wrapper::Windows::System::RemoteSystems::RemoteSystemSessionJoinResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RemoteSystemSessionJoinResult
    };

    // ----- RemoteSystemSessionMessageChannel class --------------------
    static constexpr const char* const type_name_RemoteSystemSessionMessageChannel = "RemoteSystemSessionMessageChannel";

    static PyObject* _new_RemoteSystemSessionMessageChannel(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::System::RemoteSystems::RemoteSystemSession>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                winrt::Windows::System::RemoteSystems::RemoteSystemSessionMessageChannel instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::System::RemoteSystems::RemoteSystemSession>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::System::RemoteSystems::RemoteSystemSessionMessageChannelReliability>(args, 2);

                winrt::Windows::System::RemoteSystems::RemoteSystemSessionMessageChannel instance{ param0, param1, param2 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_RemoteSystemSessionMessageChannel(py::wrapper::Windows::System::RemoteSystems::RemoteSystemSessionMessageChannel* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* RemoteSystemSessionMessageChannel_BroadcastValueSetAsync(py::wrapper::Windows::System::RemoteSystems::RemoteSystemSessionMessageChannel* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.RemoteSystems.RemoteSystemSessionMessageChannel", L"BroadcastValueSetAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::ValueSet>(args, 0);

                return py::convert(self->obj.BroadcastValueSetAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RemoteSystemSessionMessageChannel_SendValueSetAsync(py::wrapper::Windows::System::RemoteSystems::RemoteSystemSessionMessageChannel* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.RemoteSystems.RemoteSystemSessionMessageChannel", L"SendValueSetAsync", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::ValueSet>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::System::RemoteSystems::RemoteSystemSessionParticipant>(args, 1);

                return py::convert(self->obj.SendValueSetAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RemoteSystemSessionMessageChannel_SendValueSetToParticipantsAsync(py::wrapper::Windows::System::RemoteSystems::RemoteSystemSessionMessageChannel* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.RemoteSystems.RemoteSystemSessionMessageChannel", L"SendValueSetToParticipantsAsync", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::ValueSet>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::System::RemoteSystems::RemoteSystemSessionParticipant>>(args, 1);

                return py::convert(self->obj.SendValueSetToParticipantsAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RemoteSystemSessionMessageChannel_get_Session(py::wrapper::Windows::System::RemoteSystems::RemoteSystemSessionMessageChannel* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.RemoteSystems.RemoteSystemSessionMessageChannel", L"Session"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Session());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RemoteSystemSessionMessageChannel_add_ValueSetReceived(py::wrapper::Windows::System::RemoteSystems::RemoteSystemSessionMessageChannel* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.System.RemoteSystems.RemoteSystemSessionMessageChannel", L"ValueSetReceived"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::System::RemoteSystems::RemoteSystemSessionMessageChannel, winrt::Windows::System::RemoteSystems::RemoteSystemSessionValueSetReceivedEventArgs>>(arg);

            return py::convert(self->obj.ValueSetReceived(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RemoteSystemSessionMessageChannel_remove_ValueSetReceived(py::wrapper::Windows::System::RemoteSystems::RemoteSystemSessionMessageChannel* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.System.RemoteSystems.RemoteSystemSessionMessageChannel", L"ValueSetReceived"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ValueSetReceived(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_RemoteSystemSessionMessageChannel(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::System::RemoteSystems::RemoteSystemSessionMessageChannel>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_RemoteSystemSessionMessageChannel(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::RemoteSystems::RemoteSystemSessionMessageChannel>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RemoteSystemSessionMessageChannel[] = {
        { "broadcast_value_set_async", reinterpret_cast<PyCFunction>(RemoteSystemSessionMessageChannel_BroadcastValueSetAsync), METH_VARARGS, nullptr },
        { "send_value_set_async", reinterpret_cast<PyCFunction>(RemoteSystemSessionMessageChannel_SendValueSetAsync), METH_VARARGS, nullptr },
        { "send_value_set_to_participants_async", reinterpret_cast<PyCFunction>(RemoteSystemSessionMessageChannel_SendValueSetToParticipantsAsync), METH_VARARGS, nullptr },
        { "add_value_set_received", reinterpret_cast<PyCFunction>(RemoteSystemSessionMessageChannel_add_ValueSetReceived), METH_O, nullptr },
        { "remove_value_set_received", reinterpret_cast<PyCFunction>(RemoteSystemSessionMessageChannel_remove_ValueSetReceived), METH_O, nullptr },
        { "_assign_array_", _assign_array_RemoteSystemSessionMessageChannel, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_RemoteSystemSessionMessageChannel), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_RemoteSystemSessionMessageChannel[] = {
        { "session", reinterpret_cast<getter>(RemoteSystemSessionMessageChannel_get_Session), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_RemoteSystemSessionMessageChannel[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_RemoteSystemSessionMessageChannel) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_RemoteSystemSessionMessageChannel) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_RemoteSystemSessionMessageChannel) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_RemoteSystemSessionMessageChannel) },
        { },
    };

    static PyType_Spec type_spec_RemoteSystemSessionMessageChannel =
    {
        "_winrt_Windows_System_RemoteSystems.RemoteSystemSessionMessageChannel",
        sizeof(py::wrapper::Windows::System::RemoteSystems::RemoteSystemSessionMessageChannel),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RemoteSystemSessionMessageChannel
    };

    // ----- RemoteSystemSessionOptions class --------------------
    static constexpr const char* const type_name_RemoteSystemSessionOptions = "RemoteSystemSessionOptions";

    static PyObject* _new_RemoteSystemSessionOptions(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::System::RemoteSystems::RemoteSystemSessionOptions instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_RemoteSystemSessionOptions(py::wrapper::Windows::System::RemoteSystems::RemoteSystemSessionOptions* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* RemoteSystemSessionOptions_get_IsInviteOnly(py::wrapper::Windows::System::RemoteSystems::RemoteSystemSessionOptions* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.RemoteSystems.RemoteSystemSessionOptions", L"IsInviteOnly"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsInviteOnly());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RemoteSystemSessionOptions_put_IsInviteOnly(py::wrapper::Windows::System::RemoteSystems::RemoteSystemSessionOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.RemoteSystems.RemoteSystemSessionOptions", L"IsInviteOnly"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsInviteOnly(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_RemoteSystemSessionOptions(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::System::RemoteSystems::RemoteSystemSessionOptions>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_RemoteSystemSessionOptions(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::RemoteSystems::RemoteSystemSessionOptions>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RemoteSystemSessionOptions[] = {
        { "_assign_array_", _assign_array_RemoteSystemSessionOptions, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_RemoteSystemSessionOptions), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_RemoteSystemSessionOptions[] = {
        { "is_invite_only", reinterpret_cast<getter>(RemoteSystemSessionOptions_get_IsInviteOnly), reinterpret_cast<setter>(RemoteSystemSessionOptions_put_IsInviteOnly), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_RemoteSystemSessionOptions[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_RemoteSystemSessionOptions) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_RemoteSystemSessionOptions) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_RemoteSystemSessionOptions) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_RemoteSystemSessionOptions) },
        { },
    };

    static PyType_Spec type_spec_RemoteSystemSessionOptions =
    {
        "_winrt_Windows_System_RemoteSystems.RemoteSystemSessionOptions",
        sizeof(py::wrapper::Windows::System::RemoteSystems::RemoteSystemSessionOptions),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RemoteSystemSessionOptions
    };

    // ----- RemoteSystemSessionParticipant class --------------------
    static constexpr const char* const type_name_RemoteSystemSessionParticipant = "RemoteSystemSessionParticipant";

    static PyObject* _new_RemoteSystemSessionParticipant(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_RemoteSystemSessionParticipant);
        return nullptr;
    }

    static void _dealloc_RemoteSystemSessionParticipant(py::wrapper::Windows::System::RemoteSystems::RemoteSystemSessionParticipant* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* RemoteSystemSessionParticipant_GetHostNames(py::wrapper::Windows::System::RemoteSystems::RemoteSystemSessionParticipant* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.RemoteSystems.RemoteSystemSessionParticipant", L"GetHostNames", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetHostNames());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RemoteSystemSessionParticipant_get_RemoteSystem(py::wrapper::Windows::System::RemoteSystems::RemoteSystemSessionParticipant* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.RemoteSystems.RemoteSystemSessionParticipant", L"RemoteSystem"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RemoteSystem());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_RemoteSystemSessionParticipant(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::System::RemoteSystems::RemoteSystemSessionParticipant>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_RemoteSystemSessionParticipant(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::RemoteSystems::RemoteSystemSessionParticipant>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RemoteSystemSessionParticipant[] = {
        { "get_host_names", reinterpret_cast<PyCFunction>(RemoteSystemSessionParticipant_GetHostNames), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_RemoteSystemSessionParticipant, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_RemoteSystemSessionParticipant), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_RemoteSystemSessionParticipant[] = {
        { "remote_system", reinterpret_cast<getter>(RemoteSystemSessionParticipant_get_RemoteSystem), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_RemoteSystemSessionParticipant[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_RemoteSystemSessionParticipant) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_RemoteSystemSessionParticipant) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_RemoteSystemSessionParticipant) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_RemoteSystemSessionParticipant) },
        { },
    };

    static PyType_Spec type_spec_RemoteSystemSessionParticipant =
    {
        "_winrt_Windows_System_RemoteSystems.RemoteSystemSessionParticipant",
        sizeof(py::wrapper::Windows::System::RemoteSystems::RemoteSystemSessionParticipant),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RemoteSystemSessionParticipant
    };

    // ----- RemoteSystemSessionParticipantAddedEventArgs class --------------------
    static constexpr const char* const type_name_RemoteSystemSessionParticipantAddedEventArgs = "RemoteSystemSessionParticipantAddedEventArgs";

    static PyObject* _new_RemoteSystemSessionParticipantAddedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_RemoteSystemSessionParticipantAddedEventArgs);
        return nullptr;
    }

    static void _dealloc_RemoteSystemSessionParticipantAddedEventArgs(py::wrapper::Windows::System::RemoteSystems::RemoteSystemSessionParticipantAddedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* RemoteSystemSessionParticipantAddedEventArgs_get_Participant(py::wrapper::Windows::System::RemoteSystems::RemoteSystemSessionParticipantAddedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.RemoteSystems.RemoteSystemSessionParticipantAddedEventArgs", L"Participant"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Participant());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_RemoteSystemSessionParticipantAddedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::System::RemoteSystems::RemoteSystemSessionParticipantAddedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_RemoteSystemSessionParticipantAddedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::RemoteSystems::RemoteSystemSessionParticipantAddedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RemoteSystemSessionParticipantAddedEventArgs[] = {
        { "_assign_array_", _assign_array_RemoteSystemSessionParticipantAddedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_RemoteSystemSessionParticipantAddedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_RemoteSystemSessionParticipantAddedEventArgs[] = {
        { "participant", reinterpret_cast<getter>(RemoteSystemSessionParticipantAddedEventArgs_get_Participant), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_RemoteSystemSessionParticipantAddedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_RemoteSystemSessionParticipantAddedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_RemoteSystemSessionParticipantAddedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_RemoteSystemSessionParticipantAddedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_RemoteSystemSessionParticipantAddedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_RemoteSystemSessionParticipantAddedEventArgs =
    {
        "_winrt_Windows_System_RemoteSystems.RemoteSystemSessionParticipantAddedEventArgs",
        sizeof(py::wrapper::Windows::System::RemoteSystems::RemoteSystemSessionParticipantAddedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RemoteSystemSessionParticipantAddedEventArgs
    };

    // ----- RemoteSystemSessionParticipantRemovedEventArgs class --------------------
    static constexpr const char* const type_name_RemoteSystemSessionParticipantRemovedEventArgs = "RemoteSystemSessionParticipantRemovedEventArgs";

    static PyObject* _new_RemoteSystemSessionParticipantRemovedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_RemoteSystemSessionParticipantRemovedEventArgs);
        return nullptr;
    }

    static void _dealloc_RemoteSystemSessionParticipantRemovedEventArgs(py::wrapper::Windows::System::RemoteSystems::RemoteSystemSessionParticipantRemovedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* RemoteSystemSessionParticipantRemovedEventArgs_get_Participant(py::wrapper::Windows::System::RemoteSystems::RemoteSystemSessionParticipantRemovedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.RemoteSystems.RemoteSystemSessionParticipantRemovedEventArgs", L"Participant"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Participant());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_RemoteSystemSessionParticipantRemovedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::System::RemoteSystems::RemoteSystemSessionParticipantRemovedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_RemoteSystemSessionParticipantRemovedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::RemoteSystems::RemoteSystemSessionParticipantRemovedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RemoteSystemSessionParticipantRemovedEventArgs[] = {
        { "_assign_array_", _assign_array_RemoteSystemSessionParticipantRemovedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_RemoteSystemSessionParticipantRemovedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_RemoteSystemSessionParticipantRemovedEventArgs[] = {
        { "participant", reinterpret_cast<getter>(RemoteSystemSessionParticipantRemovedEventArgs_get_Participant), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_RemoteSystemSessionParticipantRemovedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_RemoteSystemSessionParticipantRemovedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_RemoteSystemSessionParticipantRemovedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_RemoteSystemSessionParticipantRemovedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_RemoteSystemSessionParticipantRemovedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_RemoteSystemSessionParticipantRemovedEventArgs =
    {
        "_winrt_Windows_System_RemoteSystems.RemoteSystemSessionParticipantRemovedEventArgs",
        sizeof(py::wrapper::Windows::System::RemoteSystems::RemoteSystemSessionParticipantRemovedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RemoteSystemSessionParticipantRemovedEventArgs
    };

    // ----- RemoteSystemSessionParticipantWatcher class --------------------
    static constexpr const char* const type_name_RemoteSystemSessionParticipantWatcher = "RemoteSystemSessionParticipantWatcher";

    static PyObject* _new_RemoteSystemSessionParticipantWatcher(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_RemoteSystemSessionParticipantWatcher);
        return nullptr;
    }

    static void _dealloc_RemoteSystemSessionParticipantWatcher(py::wrapper::Windows::System::RemoteSystems::RemoteSystemSessionParticipantWatcher* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* RemoteSystemSessionParticipantWatcher_Start(py::wrapper::Windows::System::RemoteSystems::RemoteSystemSessionParticipantWatcher* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.RemoteSystems.RemoteSystemSessionParticipantWatcher", L"Start", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Start();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RemoteSystemSessionParticipantWatcher_Stop(py::wrapper::Windows::System::RemoteSystems::RemoteSystemSessionParticipantWatcher* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.RemoteSystems.RemoteSystemSessionParticipantWatcher", L"Stop", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Stop();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RemoteSystemSessionParticipantWatcher_get_Status(py::wrapper::Windows::System::RemoteSystems::RemoteSystemSessionParticipantWatcher* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.RemoteSystems.RemoteSystemSessionParticipantWatcher", L"Status"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RemoteSystemSessionParticipantWatcher_add_Added(py::wrapper::Windows::System::RemoteSystems::RemoteSystemSessionParticipantWatcher* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.System.RemoteSystems.RemoteSystemSessionParticipantWatcher", L"Added"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::System::RemoteSystems::RemoteSystemSessionParticipantWatcher, winrt::Windows::System::RemoteSystems::RemoteSystemSessionParticipantAddedEventArgs>>(arg);

            return py::convert(self->obj.Added(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RemoteSystemSessionParticipantWatcher_remove_Added(py::wrapper::Windows::System::RemoteSystems::RemoteSystemSessionParticipantWatcher* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.System.RemoteSystems.RemoteSystemSessionParticipantWatcher", L"Added"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Added(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RemoteSystemSessionParticipantWatcher_add_EnumerationCompleted(py::wrapper::Windows::System::RemoteSystems::RemoteSystemSessionParticipantWatcher* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.System.RemoteSystems.RemoteSystemSessionParticipantWatcher", L"EnumerationCompleted"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::System::RemoteSystems::RemoteSystemSessionParticipantWatcher, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.EnumerationCompleted(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RemoteSystemSessionParticipantWatcher_remove_EnumerationCompleted(py::wrapper::Windows::System::RemoteSystems::RemoteSystemSessionParticipantWatcher* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.System.RemoteSystems.RemoteSystemSessionParticipantWatcher", L"EnumerationCompleted"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.EnumerationCompleted(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RemoteSystemSessionParticipantWatcher_add_Removed(py::wrapper::Windows::System::RemoteSystems::RemoteSystemSessionParticipantWatcher* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.System.RemoteSystems.RemoteSystemSessionParticipantWatcher", L"Removed"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::System::RemoteSystems::RemoteSystemSessionParticipantWatcher, winrt::Windows::System::RemoteSystems::RemoteSystemSessionParticipantRemovedEventArgs>>(arg);

            return py::convert(self->obj.Removed(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RemoteSystemSessionParticipantWatcher_remove_Removed(py::wrapper::Windows::System::RemoteSystems::RemoteSystemSessionParticipantWatcher* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.System.RemoteSystems.RemoteSystemSessionParticipantWatcher", L"Removed"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Removed(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_RemoteSystemSessionParticipantWatcher(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::System::RemoteSystems::RemoteSystemSessionParticipantWatcher>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_RemoteSystemSessionParticipantWatcher(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::RemoteSystems::RemoteSystemSessionParticipantWatcher>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RemoteSystemSessionParticipantWatcher[] = {
        { "start", reinterpret_cast<PyCFunction>(RemoteSystemSessionParticipantWatcher_Start), METH_VARARGS, nullptr },
        { "stop", reinterpret_cast<PyCFunction>(RemoteSystemSessionParticipantWatcher_Stop), METH_VARARGS, nullptr },
        { "add_added", reinterpret_cast<PyCFunction>(RemoteSystemSessionParticipantWatcher_add_Added), METH_O, nullptr },
        { "remove_added", reinterpret_cast<PyCFunction>(RemoteSystemSessionParticipantWatcher_remove_Added), METH_O, nullptr },
        { "add_enumeration_completed", reinterpret_cast<PyCFunction>(RemoteSystemSessionParticipantWatcher_add_EnumerationCompleted), METH_O, nullptr },
        { "remove_enumeration_completed", reinterpret_cast<PyCFunction>(RemoteSystemSessionParticipantWatcher_remove_EnumerationCompleted), METH_O, nullptr },
        { "add_removed", reinterpret_cast<PyCFunction>(RemoteSystemSessionParticipantWatcher_add_Removed), METH_O, nullptr },
        { "remove_removed", reinterpret_cast<PyCFunction>(RemoteSystemSessionParticipantWatcher_remove_Removed), METH_O, nullptr },
        { "_assign_array_", _assign_array_RemoteSystemSessionParticipantWatcher, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_RemoteSystemSessionParticipantWatcher), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_RemoteSystemSessionParticipantWatcher[] = {
        { "status", reinterpret_cast<getter>(RemoteSystemSessionParticipantWatcher_get_Status), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_RemoteSystemSessionParticipantWatcher[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_RemoteSystemSessionParticipantWatcher) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_RemoteSystemSessionParticipantWatcher) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_RemoteSystemSessionParticipantWatcher) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_RemoteSystemSessionParticipantWatcher) },
        { },
    };

    static PyType_Spec type_spec_RemoteSystemSessionParticipantWatcher =
    {
        "_winrt_Windows_System_RemoteSystems.RemoteSystemSessionParticipantWatcher",
        sizeof(py::wrapper::Windows::System::RemoteSystems::RemoteSystemSessionParticipantWatcher),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RemoteSystemSessionParticipantWatcher
    };

    // ----- RemoteSystemSessionRemovedEventArgs class --------------------
    static constexpr const char* const type_name_RemoteSystemSessionRemovedEventArgs = "RemoteSystemSessionRemovedEventArgs";

    static PyObject* _new_RemoteSystemSessionRemovedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_RemoteSystemSessionRemovedEventArgs);
        return nullptr;
    }

    static void _dealloc_RemoteSystemSessionRemovedEventArgs(py::wrapper::Windows::System::RemoteSystems::RemoteSystemSessionRemovedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* RemoteSystemSessionRemovedEventArgs_get_SessionInfo(py::wrapper::Windows::System::RemoteSystems::RemoteSystemSessionRemovedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.RemoteSystems.RemoteSystemSessionRemovedEventArgs", L"SessionInfo"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SessionInfo());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_RemoteSystemSessionRemovedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::System::RemoteSystems::RemoteSystemSessionRemovedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_RemoteSystemSessionRemovedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::RemoteSystems::RemoteSystemSessionRemovedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RemoteSystemSessionRemovedEventArgs[] = {
        { "_assign_array_", _assign_array_RemoteSystemSessionRemovedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_RemoteSystemSessionRemovedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_RemoteSystemSessionRemovedEventArgs[] = {
        { "session_info", reinterpret_cast<getter>(RemoteSystemSessionRemovedEventArgs_get_SessionInfo), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_RemoteSystemSessionRemovedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_RemoteSystemSessionRemovedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_RemoteSystemSessionRemovedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_RemoteSystemSessionRemovedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_RemoteSystemSessionRemovedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_RemoteSystemSessionRemovedEventArgs =
    {
        "_winrt_Windows_System_RemoteSystems.RemoteSystemSessionRemovedEventArgs",
        sizeof(py::wrapper::Windows::System::RemoteSystems::RemoteSystemSessionRemovedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RemoteSystemSessionRemovedEventArgs
    };

    // ----- RemoteSystemSessionUpdatedEventArgs class --------------------
    static constexpr const char* const type_name_RemoteSystemSessionUpdatedEventArgs = "RemoteSystemSessionUpdatedEventArgs";

    static PyObject* _new_RemoteSystemSessionUpdatedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_RemoteSystemSessionUpdatedEventArgs);
        return nullptr;
    }

    static void _dealloc_RemoteSystemSessionUpdatedEventArgs(py::wrapper::Windows::System::RemoteSystems::RemoteSystemSessionUpdatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* RemoteSystemSessionUpdatedEventArgs_get_SessionInfo(py::wrapper::Windows::System::RemoteSystems::RemoteSystemSessionUpdatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.RemoteSystems.RemoteSystemSessionUpdatedEventArgs", L"SessionInfo"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SessionInfo());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_RemoteSystemSessionUpdatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::System::RemoteSystems::RemoteSystemSessionUpdatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_RemoteSystemSessionUpdatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::RemoteSystems::RemoteSystemSessionUpdatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RemoteSystemSessionUpdatedEventArgs[] = {
        { "_assign_array_", _assign_array_RemoteSystemSessionUpdatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_RemoteSystemSessionUpdatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_RemoteSystemSessionUpdatedEventArgs[] = {
        { "session_info", reinterpret_cast<getter>(RemoteSystemSessionUpdatedEventArgs_get_SessionInfo), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_RemoteSystemSessionUpdatedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_RemoteSystemSessionUpdatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_RemoteSystemSessionUpdatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_RemoteSystemSessionUpdatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_RemoteSystemSessionUpdatedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_RemoteSystemSessionUpdatedEventArgs =
    {
        "_winrt_Windows_System_RemoteSystems.RemoteSystemSessionUpdatedEventArgs",
        sizeof(py::wrapper::Windows::System::RemoteSystems::RemoteSystemSessionUpdatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RemoteSystemSessionUpdatedEventArgs
    };

    // ----- RemoteSystemSessionValueSetReceivedEventArgs class --------------------
    static constexpr const char* const type_name_RemoteSystemSessionValueSetReceivedEventArgs = "RemoteSystemSessionValueSetReceivedEventArgs";

    static PyObject* _new_RemoteSystemSessionValueSetReceivedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_RemoteSystemSessionValueSetReceivedEventArgs);
        return nullptr;
    }

    static void _dealloc_RemoteSystemSessionValueSetReceivedEventArgs(py::wrapper::Windows::System::RemoteSystems::RemoteSystemSessionValueSetReceivedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* RemoteSystemSessionValueSetReceivedEventArgs_get_Message(py::wrapper::Windows::System::RemoteSystems::RemoteSystemSessionValueSetReceivedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.RemoteSystems.RemoteSystemSessionValueSetReceivedEventArgs", L"Message"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Message());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RemoteSystemSessionValueSetReceivedEventArgs_get_Sender(py::wrapper::Windows::System::RemoteSystems::RemoteSystemSessionValueSetReceivedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.RemoteSystems.RemoteSystemSessionValueSetReceivedEventArgs", L"Sender"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Sender());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_RemoteSystemSessionValueSetReceivedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::System::RemoteSystems::RemoteSystemSessionValueSetReceivedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_RemoteSystemSessionValueSetReceivedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::RemoteSystems::RemoteSystemSessionValueSetReceivedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RemoteSystemSessionValueSetReceivedEventArgs[] = {
        { "_assign_array_", _assign_array_RemoteSystemSessionValueSetReceivedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_RemoteSystemSessionValueSetReceivedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_RemoteSystemSessionValueSetReceivedEventArgs[] = {
        { "message", reinterpret_cast<getter>(RemoteSystemSessionValueSetReceivedEventArgs_get_Message), nullptr, nullptr, nullptr },
        { "sender", reinterpret_cast<getter>(RemoteSystemSessionValueSetReceivedEventArgs_get_Sender), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_RemoteSystemSessionValueSetReceivedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_RemoteSystemSessionValueSetReceivedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_RemoteSystemSessionValueSetReceivedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_RemoteSystemSessionValueSetReceivedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_RemoteSystemSessionValueSetReceivedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_RemoteSystemSessionValueSetReceivedEventArgs =
    {
        "_winrt_Windows_System_RemoteSystems.RemoteSystemSessionValueSetReceivedEventArgs",
        sizeof(py::wrapper::Windows::System::RemoteSystems::RemoteSystemSessionValueSetReceivedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RemoteSystemSessionValueSetReceivedEventArgs
    };

    // ----- RemoteSystemSessionWatcher class --------------------
    static constexpr const char* const type_name_RemoteSystemSessionWatcher = "RemoteSystemSessionWatcher";

    static PyObject* _new_RemoteSystemSessionWatcher(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_RemoteSystemSessionWatcher);
        return nullptr;
    }

    static void _dealloc_RemoteSystemSessionWatcher(py::wrapper::Windows::System::RemoteSystems::RemoteSystemSessionWatcher* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* RemoteSystemSessionWatcher_Start(py::wrapper::Windows::System::RemoteSystems::RemoteSystemSessionWatcher* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.RemoteSystems.RemoteSystemSessionWatcher", L"Start", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Start();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RemoteSystemSessionWatcher_Stop(py::wrapper::Windows::System::RemoteSystems::RemoteSystemSessionWatcher* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.RemoteSystems.RemoteSystemSessionWatcher", L"Stop", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Stop();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RemoteSystemSessionWatcher_get_Status(py::wrapper::Windows::System::RemoteSystems::RemoteSystemSessionWatcher* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.RemoteSystems.RemoteSystemSessionWatcher", L"Status"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RemoteSystemSessionWatcher_add_Added(py::wrapper::Windows::System::RemoteSystems::RemoteSystemSessionWatcher* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.System.RemoteSystems.RemoteSystemSessionWatcher", L"Added"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::System::RemoteSystems::RemoteSystemSessionWatcher, winrt::Windows::System::RemoteSystems::RemoteSystemSessionAddedEventArgs>>(arg);

            return py::convert(self->obj.Added(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RemoteSystemSessionWatcher_remove_Added(py::wrapper::Windows::System::RemoteSystems::RemoteSystemSessionWatcher* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.System.RemoteSystems.RemoteSystemSessionWatcher", L"Added"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Added(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RemoteSystemSessionWatcher_add_Removed(py::wrapper::Windows::System::RemoteSystems::RemoteSystemSessionWatcher* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.System.RemoteSystems.RemoteSystemSessionWatcher", L"Removed"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::System::RemoteSystems::RemoteSystemSessionWatcher, winrt::Windows::System::RemoteSystems::RemoteSystemSessionRemovedEventArgs>>(arg);

            return py::convert(self->obj.Removed(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RemoteSystemSessionWatcher_remove_Removed(py::wrapper::Windows::System::RemoteSystems::RemoteSystemSessionWatcher* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.System.RemoteSystems.RemoteSystemSessionWatcher", L"Removed"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Removed(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RemoteSystemSessionWatcher_add_Updated(py::wrapper::Windows::System::RemoteSystems::RemoteSystemSessionWatcher* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.System.RemoteSystems.RemoteSystemSessionWatcher", L"Updated"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::System::RemoteSystems::RemoteSystemSessionWatcher, winrt::Windows::System::RemoteSystems::RemoteSystemSessionUpdatedEventArgs>>(arg);

            return py::convert(self->obj.Updated(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RemoteSystemSessionWatcher_remove_Updated(py::wrapper::Windows::System::RemoteSystems::RemoteSystemSessionWatcher* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.System.RemoteSystems.RemoteSystemSessionWatcher", L"Updated"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Updated(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_RemoteSystemSessionWatcher(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::System::RemoteSystems::RemoteSystemSessionWatcher>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_RemoteSystemSessionWatcher(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::RemoteSystems::RemoteSystemSessionWatcher>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RemoteSystemSessionWatcher[] = {
        { "start", reinterpret_cast<PyCFunction>(RemoteSystemSessionWatcher_Start), METH_VARARGS, nullptr },
        { "stop", reinterpret_cast<PyCFunction>(RemoteSystemSessionWatcher_Stop), METH_VARARGS, nullptr },
        { "add_added", reinterpret_cast<PyCFunction>(RemoteSystemSessionWatcher_add_Added), METH_O, nullptr },
        { "remove_added", reinterpret_cast<PyCFunction>(RemoteSystemSessionWatcher_remove_Added), METH_O, nullptr },
        { "add_removed", reinterpret_cast<PyCFunction>(RemoteSystemSessionWatcher_add_Removed), METH_O, nullptr },
        { "remove_removed", reinterpret_cast<PyCFunction>(RemoteSystemSessionWatcher_remove_Removed), METH_O, nullptr },
        { "add_updated", reinterpret_cast<PyCFunction>(RemoteSystemSessionWatcher_add_Updated), METH_O, nullptr },
        { "remove_updated", reinterpret_cast<PyCFunction>(RemoteSystemSessionWatcher_remove_Updated), METH_O, nullptr },
        { "_assign_array_", _assign_array_RemoteSystemSessionWatcher, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_RemoteSystemSessionWatcher), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_RemoteSystemSessionWatcher[] = {
        { "status", reinterpret_cast<getter>(RemoteSystemSessionWatcher_get_Status), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_RemoteSystemSessionWatcher[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_RemoteSystemSessionWatcher) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_RemoteSystemSessionWatcher) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_RemoteSystemSessionWatcher) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_RemoteSystemSessionWatcher) },
        { },
    };

    static PyType_Spec type_spec_RemoteSystemSessionWatcher =
    {
        "_winrt_Windows_System_RemoteSystems.RemoteSystemSessionWatcher",
        sizeof(py::wrapper::Windows::System::RemoteSystems::RemoteSystemSessionWatcher),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RemoteSystemSessionWatcher
    };

    // ----- RemoteSystemStatusTypeFilter class --------------------
    static constexpr const char* const type_name_RemoteSystemStatusTypeFilter = "RemoteSystemStatusTypeFilter";

    static PyObject* _new_RemoteSystemStatusTypeFilter(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::System::RemoteSystems::RemoteSystemStatusType>(args, 0);

                winrt::Windows::System::RemoteSystems::RemoteSystemStatusTypeFilter instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_RemoteSystemStatusTypeFilter(py::wrapper::Windows::System::RemoteSystems::RemoteSystemStatusTypeFilter* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* RemoteSystemStatusTypeFilter_get_RemoteSystemStatusType(py::wrapper::Windows::System::RemoteSystems::RemoteSystemStatusTypeFilter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.RemoteSystems.RemoteSystemStatusTypeFilter", L"RemoteSystemStatusType"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RemoteSystemStatusType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_RemoteSystemStatusTypeFilter(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::System::RemoteSystems::RemoteSystemStatusTypeFilter>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_RemoteSystemStatusTypeFilter(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::RemoteSystems::RemoteSystemStatusTypeFilter>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RemoteSystemStatusTypeFilter[] = {
        { "_assign_array_", _assign_array_RemoteSystemStatusTypeFilter, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_RemoteSystemStatusTypeFilter), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_RemoteSystemStatusTypeFilter[] = {
        { "remote_system_status_type", reinterpret_cast<getter>(RemoteSystemStatusTypeFilter_get_RemoteSystemStatusType), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_RemoteSystemStatusTypeFilter[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_RemoteSystemStatusTypeFilter) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_RemoteSystemStatusTypeFilter) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_RemoteSystemStatusTypeFilter) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_RemoteSystemStatusTypeFilter) },
        { },
    };

    static PyType_Spec type_spec_RemoteSystemStatusTypeFilter =
    {
        "_winrt_Windows_System_RemoteSystems.RemoteSystemStatusTypeFilter",
        sizeof(py::wrapper::Windows::System::RemoteSystems::RemoteSystemStatusTypeFilter),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RemoteSystemStatusTypeFilter
    };

    // ----- RemoteSystemUpdatedEventArgs class --------------------
    static constexpr const char* const type_name_RemoteSystemUpdatedEventArgs = "RemoteSystemUpdatedEventArgs";

    static PyObject* _new_RemoteSystemUpdatedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_RemoteSystemUpdatedEventArgs);
        return nullptr;
    }

    static void _dealloc_RemoteSystemUpdatedEventArgs(py::wrapper::Windows::System::RemoteSystems::RemoteSystemUpdatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* RemoteSystemUpdatedEventArgs_get_RemoteSystem(py::wrapper::Windows::System::RemoteSystems::RemoteSystemUpdatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.RemoteSystems.RemoteSystemUpdatedEventArgs", L"RemoteSystem"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RemoteSystem());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_RemoteSystemUpdatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::System::RemoteSystems::RemoteSystemUpdatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_RemoteSystemUpdatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::RemoteSystems::RemoteSystemUpdatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RemoteSystemUpdatedEventArgs[] = {
        { "_assign_array_", _assign_array_RemoteSystemUpdatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_RemoteSystemUpdatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_RemoteSystemUpdatedEventArgs[] = {
        { "remote_system", reinterpret_cast<getter>(RemoteSystemUpdatedEventArgs_get_RemoteSystem), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_RemoteSystemUpdatedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_RemoteSystemUpdatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_RemoteSystemUpdatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_RemoteSystemUpdatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_RemoteSystemUpdatedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_RemoteSystemUpdatedEventArgs =
    {
        "_winrt_Windows_System_RemoteSystems.RemoteSystemUpdatedEventArgs",
        sizeof(py::wrapper::Windows::System::RemoteSystems::RemoteSystemUpdatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RemoteSystemUpdatedEventArgs
    };

    // ----- RemoteSystemWatcher class --------------------
    static constexpr const char* const type_name_RemoteSystemWatcher = "RemoteSystemWatcher";

    static PyObject* _new_RemoteSystemWatcher(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_RemoteSystemWatcher);
        return nullptr;
    }

    static void _dealloc_RemoteSystemWatcher(py::wrapper::Windows::System::RemoteSystems::RemoteSystemWatcher* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* RemoteSystemWatcher_Start(py::wrapper::Windows::System::RemoteSystems::RemoteSystemWatcher* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.RemoteSystems.RemoteSystemWatcher", L"Start", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Start();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RemoteSystemWatcher_Stop(py::wrapper::Windows::System::RemoteSystems::RemoteSystemWatcher* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.RemoteSystems.RemoteSystemWatcher", L"Stop", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Stop();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RemoteSystemWatcher_get_User(py::wrapper::Windows::System::RemoteSystems::RemoteSystemWatcher* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.RemoteSystems.RemoteSystemWatcher", L"User"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.User());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RemoteSystemWatcher_add_RemoteSystemAdded(py::wrapper::Windows::System::RemoteSystems::RemoteSystemWatcher* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.System.RemoteSystems.RemoteSystemWatcher", L"RemoteSystemAdded"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::System::RemoteSystems::RemoteSystemWatcher, winrt::Windows::System::RemoteSystems::RemoteSystemAddedEventArgs>>(arg);

            return py::convert(self->obj.RemoteSystemAdded(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RemoteSystemWatcher_remove_RemoteSystemAdded(py::wrapper::Windows::System::RemoteSystems::RemoteSystemWatcher* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.System.RemoteSystems.RemoteSystemWatcher", L"RemoteSystemAdded"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.RemoteSystemAdded(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RemoteSystemWatcher_add_RemoteSystemRemoved(py::wrapper::Windows::System::RemoteSystems::RemoteSystemWatcher* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.System.RemoteSystems.RemoteSystemWatcher", L"RemoteSystemRemoved"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::System::RemoteSystems::RemoteSystemWatcher, winrt::Windows::System::RemoteSystems::RemoteSystemRemovedEventArgs>>(arg);

            return py::convert(self->obj.RemoteSystemRemoved(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RemoteSystemWatcher_remove_RemoteSystemRemoved(py::wrapper::Windows::System::RemoteSystems::RemoteSystemWatcher* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.System.RemoteSystems.RemoteSystemWatcher", L"RemoteSystemRemoved"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.RemoteSystemRemoved(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RemoteSystemWatcher_add_RemoteSystemUpdated(py::wrapper::Windows::System::RemoteSystems::RemoteSystemWatcher* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.System.RemoteSystems.RemoteSystemWatcher", L"RemoteSystemUpdated"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::System::RemoteSystems::RemoteSystemWatcher, winrt::Windows::System::RemoteSystems::RemoteSystemUpdatedEventArgs>>(arg);

            return py::convert(self->obj.RemoteSystemUpdated(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RemoteSystemWatcher_remove_RemoteSystemUpdated(py::wrapper::Windows::System::RemoteSystems::RemoteSystemWatcher* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.System.RemoteSystems.RemoteSystemWatcher", L"RemoteSystemUpdated"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.RemoteSystemUpdated(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RemoteSystemWatcher_add_EnumerationCompleted(py::wrapper::Windows::System::RemoteSystems::RemoteSystemWatcher* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.System.RemoteSystems.RemoteSystemWatcher", L"EnumerationCompleted"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::System::RemoteSystems::RemoteSystemWatcher, winrt::Windows::System::RemoteSystems::RemoteSystemEnumerationCompletedEventArgs>>(arg);

            return py::convert(self->obj.EnumerationCompleted(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RemoteSystemWatcher_remove_EnumerationCompleted(py::wrapper::Windows::System::RemoteSystems::RemoteSystemWatcher* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.System.RemoteSystems.RemoteSystemWatcher", L"EnumerationCompleted"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.EnumerationCompleted(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RemoteSystemWatcher_add_ErrorOccurred(py::wrapper::Windows::System::RemoteSystems::RemoteSystemWatcher* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.System.RemoteSystems.RemoteSystemWatcher", L"ErrorOccurred"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::System::RemoteSystems::RemoteSystemWatcher, winrt::Windows::System::RemoteSystems::RemoteSystemWatcherErrorOccurredEventArgs>>(arg);

            return py::convert(self->obj.ErrorOccurred(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RemoteSystemWatcher_remove_ErrorOccurred(py::wrapper::Windows::System::RemoteSystems::RemoteSystemWatcher* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.System.RemoteSystems.RemoteSystemWatcher", L"ErrorOccurred"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ErrorOccurred(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_RemoteSystemWatcher(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::System::RemoteSystems::RemoteSystemWatcher>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_RemoteSystemWatcher(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::RemoteSystems::RemoteSystemWatcher>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RemoteSystemWatcher[] = {
        { "start", reinterpret_cast<PyCFunction>(RemoteSystemWatcher_Start), METH_VARARGS, nullptr },
        { "stop", reinterpret_cast<PyCFunction>(RemoteSystemWatcher_Stop), METH_VARARGS, nullptr },
        { "add_remote_system_added", reinterpret_cast<PyCFunction>(RemoteSystemWatcher_add_RemoteSystemAdded), METH_O, nullptr },
        { "remove_remote_system_added", reinterpret_cast<PyCFunction>(RemoteSystemWatcher_remove_RemoteSystemAdded), METH_O, nullptr },
        { "add_remote_system_removed", reinterpret_cast<PyCFunction>(RemoteSystemWatcher_add_RemoteSystemRemoved), METH_O, nullptr },
        { "remove_remote_system_removed", reinterpret_cast<PyCFunction>(RemoteSystemWatcher_remove_RemoteSystemRemoved), METH_O, nullptr },
        { "add_remote_system_updated", reinterpret_cast<PyCFunction>(RemoteSystemWatcher_add_RemoteSystemUpdated), METH_O, nullptr },
        { "remove_remote_system_updated", reinterpret_cast<PyCFunction>(RemoteSystemWatcher_remove_RemoteSystemUpdated), METH_O, nullptr },
        { "add_enumeration_completed", reinterpret_cast<PyCFunction>(RemoteSystemWatcher_add_EnumerationCompleted), METH_O, nullptr },
        { "remove_enumeration_completed", reinterpret_cast<PyCFunction>(RemoteSystemWatcher_remove_EnumerationCompleted), METH_O, nullptr },
        { "add_error_occurred", reinterpret_cast<PyCFunction>(RemoteSystemWatcher_add_ErrorOccurred), METH_O, nullptr },
        { "remove_error_occurred", reinterpret_cast<PyCFunction>(RemoteSystemWatcher_remove_ErrorOccurred), METH_O, nullptr },
        { "_assign_array_", _assign_array_RemoteSystemWatcher, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_RemoteSystemWatcher), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_RemoteSystemWatcher[] = {
        { "user", reinterpret_cast<getter>(RemoteSystemWatcher_get_User), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_RemoteSystemWatcher[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_RemoteSystemWatcher) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_RemoteSystemWatcher) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_RemoteSystemWatcher) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_RemoteSystemWatcher) },
        { },
    };

    static PyType_Spec type_spec_RemoteSystemWatcher =
    {
        "_winrt_Windows_System_RemoteSystems.RemoteSystemWatcher",
        sizeof(py::wrapper::Windows::System::RemoteSystems::RemoteSystemWatcher),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RemoteSystemWatcher
    };

    // ----- RemoteSystemWatcherErrorOccurredEventArgs class --------------------
    static constexpr const char* const type_name_RemoteSystemWatcherErrorOccurredEventArgs = "RemoteSystemWatcherErrorOccurredEventArgs";

    static PyObject* _new_RemoteSystemWatcherErrorOccurredEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_RemoteSystemWatcherErrorOccurredEventArgs);
        return nullptr;
    }

    static void _dealloc_RemoteSystemWatcherErrorOccurredEventArgs(py::wrapper::Windows::System::RemoteSystems::RemoteSystemWatcherErrorOccurredEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* RemoteSystemWatcherErrorOccurredEventArgs_get_Error(py::wrapper::Windows::System::RemoteSystems::RemoteSystemWatcherErrorOccurredEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.RemoteSystems.RemoteSystemWatcherErrorOccurredEventArgs", L"Error"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Error());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_RemoteSystemWatcherErrorOccurredEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::System::RemoteSystems::RemoteSystemWatcherErrorOccurredEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_RemoteSystemWatcherErrorOccurredEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::RemoteSystems::RemoteSystemWatcherErrorOccurredEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RemoteSystemWatcherErrorOccurredEventArgs[] = {
        { "_assign_array_", _assign_array_RemoteSystemWatcherErrorOccurredEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_RemoteSystemWatcherErrorOccurredEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_RemoteSystemWatcherErrorOccurredEventArgs[] = {
        { "error", reinterpret_cast<getter>(RemoteSystemWatcherErrorOccurredEventArgs_get_Error), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_RemoteSystemWatcherErrorOccurredEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_RemoteSystemWatcherErrorOccurredEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_RemoteSystemWatcherErrorOccurredEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_RemoteSystemWatcherErrorOccurredEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_RemoteSystemWatcherErrorOccurredEventArgs) },
        { },
    };

    static PyType_Spec type_spec_RemoteSystemWatcherErrorOccurredEventArgs =
    {
        "_winrt_Windows_System_RemoteSystems.RemoteSystemWatcherErrorOccurredEventArgs",
        sizeof(py::wrapper::Windows::System::RemoteSystems::RemoteSystemWatcherErrorOccurredEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RemoteSystemWatcherErrorOccurredEventArgs
    };

    // ----- RemoteSystemWebAccountFilter class --------------------
    static constexpr const char* const type_name_RemoteSystemWebAccountFilter = "RemoteSystemWebAccountFilter";

    static PyObject* _new_RemoteSystemWebAccountFilter(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Security::Credentials::WebAccount>(args, 0);

                winrt::Windows::System::RemoteSystems::RemoteSystemWebAccountFilter instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_RemoteSystemWebAccountFilter(py::wrapper::Windows::System::RemoteSystems::RemoteSystemWebAccountFilter* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* RemoteSystemWebAccountFilter_get_Account(py::wrapper::Windows::System::RemoteSystems::RemoteSystemWebAccountFilter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.RemoteSystems.RemoteSystemWebAccountFilter", L"Account"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Account());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_RemoteSystemWebAccountFilter(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::System::RemoteSystems::RemoteSystemWebAccountFilter>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_RemoteSystemWebAccountFilter(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::RemoteSystems::RemoteSystemWebAccountFilter>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RemoteSystemWebAccountFilter[] = {
        { "_assign_array_", _assign_array_RemoteSystemWebAccountFilter, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_RemoteSystemWebAccountFilter), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_RemoteSystemWebAccountFilter[] = {
        { "account", reinterpret_cast<getter>(RemoteSystemWebAccountFilter_get_Account), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_RemoteSystemWebAccountFilter[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_RemoteSystemWebAccountFilter) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_RemoteSystemWebAccountFilter) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_RemoteSystemWebAccountFilter) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_RemoteSystemWebAccountFilter) },
        { },
    };

    static PyType_Spec type_spec_RemoteSystemWebAccountFilter =
    {
        "_winrt_Windows_System_RemoteSystems.RemoteSystemWebAccountFilter",
        sizeof(py::wrapper::Windows::System::RemoteSystems::RemoteSystemWebAccountFilter),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RemoteSystemWebAccountFilter
    };

    // ----- IRemoteSystemFilter interface --------------------
    static constexpr const char* const type_name_IRemoteSystemFilter = "IRemoteSystemFilter";

    static PyObject* _new_IRemoteSystemFilter(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */) noexcept
    {
        py::set_invalid_activation_error(type_name_IRemoteSystemFilter);
        return nullptr;
    }

    static void _dealloc_IRemoteSystemFilter(py::wrapper::Windows::System::RemoteSystems::IRemoteSystemFilter* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_IRemoteSystemFilter(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::System::RemoteSystems::IRemoteSystemFilter>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IRemoteSystemFilter(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::RemoteSystems::IRemoteSystemFilter>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IRemoteSystemFilter[] = {
        { "_assign_array_", _assign_array_IRemoteSystemFilter, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IRemoteSystemFilter), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IRemoteSystemFilter[] = {
        { }
    };

    static PyType_Slot _type_slots_IRemoteSystemFilter[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_IRemoteSystemFilter) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IRemoteSystemFilter) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IRemoteSystemFilter) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IRemoteSystemFilter) },
        { },
    };

    static PyType_Spec type_spec_IRemoteSystemFilter =
    {
        "_winrt_Windows_System_RemoteSystems.IRemoteSystemFilter",
        sizeof(py::wrapper::Windows::System::RemoteSystems::IRemoteSystemFilter),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IRemoteSystemFilter
    };

    // ----- Windows.System.RemoteSystems Initialization --------------------
    PyDoc_STRVAR(module_doc, "Windows::System::RemoteSystems");


    static PyModuleDef module_def
        = {PyModuleDef_HEAD_INIT,
           "_winrt_Windows_System_RemoteSystems",
           module_doc,
           0,
           nullptr,
           nullptr,
           nullptr,
           nullptr,
           nullptr};

} // py::cpp::Windows::System::RemoteSystems

PyMODINIT_FUNC PyInit__winrt_Windows_System_RemoteSystems(void) noexcept
{
    using namespace py::cpp::Windows::System::RemoteSystems;

    py::pyobj_handle module{PyModule_Create(&module_def)};

    if (!module)
    {
        return nullptr;
    }

    auto object_type = py::get_object_type();
    if (!object_type)
    {
        return nullptr;
    }

    py::pyobj_handle object_bases{PyTuple_Pack(1, object_type)};

    if (!object_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_KnownRemoteSystemCapabilities_Meta{PyType_FromSpec(&type_spec_KnownRemoteSystemCapabilities_Meta)};
    if (!type_KnownRemoteSystemCapabilities_Meta)
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_KnownRemoteSystemCapabilities, &type_spec_KnownRemoteSystemCapabilities, nullptr, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_KnownRemoteSystemCapabilities_Meta.get())) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_KnownRemoteSystemCapabilities, &type_spec_KnownRemoteSystemCapabilities, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_KnownRemoteSystemCapabilities_Meta.get())) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_RemoteSystem, &type_spec_RemoteSystem, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_RemoteSystem, &type_spec_RemoteSystem, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_RemoteSystemAddedEventArgs, &type_spec_RemoteSystemAddedEventArgs, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_RemoteSystemAddedEventArgs, &type_spec_RemoteSystemAddedEventArgs, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_RemoteSystemApp, &type_spec_RemoteSystemApp, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_RemoteSystemApp, &type_spec_RemoteSystemApp, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_RemoteSystemAppRegistration, &type_spec_RemoteSystemAppRegistration, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_RemoteSystemAppRegistration, &type_spec_RemoteSystemAppRegistration, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_RemoteSystemAuthorizationKindFilter, &type_spec_RemoteSystemAuthorizationKindFilter, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_RemoteSystemAuthorizationKindFilter, &type_spec_RemoteSystemAuthorizationKindFilter, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_RemoteSystemConnectionInfo, &type_spec_RemoteSystemConnectionInfo, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_RemoteSystemConnectionInfo, &type_spec_RemoteSystemConnectionInfo, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_RemoteSystemConnectionRequest, &type_spec_RemoteSystemConnectionRequest, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_RemoteSystemConnectionRequest, &type_spec_RemoteSystemConnectionRequest, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_RemoteSystemDiscoveryTypeFilter, &type_spec_RemoteSystemDiscoveryTypeFilter, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_RemoteSystemDiscoveryTypeFilter, &type_spec_RemoteSystemDiscoveryTypeFilter, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_RemoteSystemEnumerationCompletedEventArgs, &type_spec_RemoteSystemEnumerationCompletedEventArgs, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_RemoteSystemEnumerationCompletedEventArgs, &type_spec_RemoteSystemEnumerationCompletedEventArgs, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_RemoteSystemKindFilter, &type_spec_RemoteSystemKindFilter, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_RemoteSystemKindFilter, &type_spec_RemoteSystemKindFilter, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    py::pyobj_handle type_RemoteSystemKinds_Meta{PyType_FromSpec(&type_spec_RemoteSystemKinds_Meta)};
    if (!type_RemoteSystemKinds_Meta)
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_RemoteSystemKinds, &type_spec_RemoteSystemKinds, nullptr, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_RemoteSystemKinds_Meta.get())) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_RemoteSystemKinds, &type_spec_RemoteSystemKinds, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_RemoteSystemKinds_Meta.get())) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_RemoteSystemRemovedEventArgs, &type_spec_RemoteSystemRemovedEventArgs, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_RemoteSystemRemovedEventArgs, &type_spec_RemoteSystemRemovedEventArgs, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_RemoteSystemSession, &type_spec_RemoteSystemSession, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_RemoteSystemSession, &type_spec_RemoteSystemSession, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_RemoteSystemSessionAddedEventArgs, &type_spec_RemoteSystemSessionAddedEventArgs, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_RemoteSystemSessionAddedEventArgs, &type_spec_RemoteSystemSessionAddedEventArgs, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_RemoteSystemSessionController, &type_spec_RemoteSystemSessionController, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_RemoteSystemSessionController, &type_spec_RemoteSystemSessionController, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_RemoteSystemSessionCreationResult, &type_spec_RemoteSystemSessionCreationResult, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_RemoteSystemSessionCreationResult, &type_spec_RemoteSystemSessionCreationResult, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_RemoteSystemSessionDisconnectedEventArgs, &type_spec_RemoteSystemSessionDisconnectedEventArgs, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_RemoteSystemSessionDisconnectedEventArgs, &type_spec_RemoteSystemSessionDisconnectedEventArgs, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_RemoteSystemSessionInfo, &type_spec_RemoteSystemSessionInfo, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_RemoteSystemSessionInfo, &type_spec_RemoteSystemSessionInfo, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_RemoteSystemSessionInvitation, &type_spec_RemoteSystemSessionInvitation, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_RemoteSystemSessionInvitation, &type_spec_RemoteSystemSessionInvitation, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_RemoteSystemSessionInvitationListener, &type_spec_RemoteSystemSessionInvitationListener, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_RemoteSystemSessionInvitationListener, &type_spec_RemoteSystemSessionInvitationListener, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_RemoteSystemSessionInvitationReceivedEventArgs, &type_spec_RemoteSystemSessionInvitationReceivedEventArgs, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_RemoteSystemSessionInvitationReceivedEventArgs, &type_spec_RemoteSystemSessionInvitationReceivedEventArgs, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_RemoteSystemSessionJoinRequest, &type_spec_RemoteSystemSessionJoinRequest, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_RemoteSystemSessionJoinRequest, &type_spec_RemoteSystemSessionJoinRequest, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_RemoteSystemSessionJoinRequestedEventArgs, &type_spec_RemoteSystemSessionJoinRequestedEventArgs, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_RemoteSystemSessionJoinRequestedEventArgs, &type_spec_RemoteSystemSessionJoinRequestedEventArgs, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_RemoteSystemSessionJoinResult, &type_spec_RemoteSystemSessionJoinResult, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_RemoteSystemSessionJoinResult, &type_spec_RemoteSystemSessionJoinResult, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_RemoteSystemSessionMessageChannel, &type_spec_RemoteSystemSessionMessageChannel, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_RemoteSystemSessionMessageChannel, &type_spec_RemoteSystemSessionMessageChannel, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_RemoteSystemSessionOptions, &type_spec_RemoteSystemSessionOptions, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_RemoteSystemSessionOptions, &type_spec_RemoteSystemSessionOptions, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_RemoteSystemSessionParticipant, &type_spec_RemoteSystemSessionParticipant, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_RemoteSystemSessionParticipant, &type_spec_RemoteSystemSessionParticipant, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_RemoteSystemSessionParticipantAddedEventArgs, &type_spec_RemoteSystemSessionParticipantAddedEventArgs, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_RemoteSystemSessionParticipantAddedEventArgs, &type_spec_RemoteSystemSessionParticipantAddedEventArgs, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_RemoteSystemSessionParticipantRemovedEventArgs, &type_spec_RemoteSystemSessionParticipantRemovedEventArgs, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_RemoteSystemSessionParticipantRemovedEventArgs, &type_spec_RemoteSystemSessionParticipantRemovedEventArgs, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_RemoteSystemSessionParticipantWatcher, &type_spec_RemoteSystemSessionParticipantWatcher, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_RemoteSystemSessionParticipantWatcher, &type_spec_RemoteSystemSessionParticipantWatcher, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_RemoteSystemSessionRemovedEventArgs, &type_spec_RemoteSystemSessionRemovedEventArgs, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_RemoteSystemSessionRemovedEventArgs, &type_spec_RemoteSystemSessionRemovedEventArgs, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_RemoteSystemSessionUpdatedEventArgs, &type_spec_RemoteSystemSessionUpdatedEventArgs, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_RemoteSystemSessionUpdatedEventArgs, &type_spec_RemoteSystemSessionUpdatedEventArgs, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_RemoteSystemSessionValueSetReceivedEventArgs, &type_spec_RemoteSystemSessionValueSetReceivedEventArgs, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_RemoteSystemSessionValueSetReceivedEventArgs, &type_spec_RemoteSystemSessionValueSetReceivedEventArgs, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_RemoteSystemSessionWatcher, &type_spec_RemoteSystemSessionWatcher, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_RemoteSystemSessionWatcher, &type_spec_RemoteSystemSessionWatcher, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_RemoteSystemStatusTypeFilter, &type_spec_RemoteSystemStatusTypeFilter, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_RemoteSystemStatusTypeFilter, &type_spec_RemoteSystemStatusTypeFilter, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_RemoteSystemUpdatedEventArgs, &type_spec_RemoteSystemUpdatedEventArgs, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_RemoteSystemUpdatedEventArgs, &type_spec_RemoteSystemUpdatedEventArgs, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_RemoteSystemWatcher, &type_spec_RemoteSystemWatcher, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_RemoteSystemWatcher, &type_spec_RemoteSystemWatcher, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_RemoteSystemWatcherErrorOccurredEventArgs, &type_spec_RemoteSystemWatcherErrorOccurredEventArgs, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_RemoteSystemWatcherErrorOccurredEventArgs, &type_spec_RemoteSystemWatcherErrorOccurredEventArgs, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_RemoteSystemWebAccountFilter, &type_spec_RemoteSystemWebAccountFilter, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_RemoteSystemWebAccountFilter, &type_spec_RemoteSystemWebAccountFilter, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_IRemoteSystemFilter, &type_spec_IRemoteSystemFilter, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_IRemoteSystemFilter, &type_spec_IRemoteSystemFilter, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }


    return module.detach();
}
