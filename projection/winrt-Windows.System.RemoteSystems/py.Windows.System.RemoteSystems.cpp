// WARNING: Please don't edit this file. It was generated by Python/WinRT v0.0.0

#include "py.Windows.System.RemoteSystems.h"

namespace py::cpp::Windows::System::RemoteSystems
{
    // ----- KnownRemoteSystemCapabilities class --------------------

    static PyObject* _new_KnownRemoteSystemCapabilities(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::System::RemoteSystems::KnownRemoteSystemCapabilities>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::System::RemoteSystems::KnownRemoteSystemCapabilities>::type_name);
        return nullptr;
    }

    static PyObject* KnownRemoteSystemCapabilities_get_AppService(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.RemoteSystems.KnownRemoteSystemCapabilities", L"AppService");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::System::RemoteSystems::KnownRemoteSystemCapabilities::AppService());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownRemoteSystemCapabilities_get_LaunchUri(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.RemoteSystems.KnownRemoteSystemCapabilities", L"LaunchUri");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::System::RemoteSystems::KnownRemoteSystemCapabilities::LaunchUri());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownRemoteSystemCapabilities_get_RemoteSession(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.RemoteSystems.KnownRemoteSystemCapabilities", L"RemoteSession");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::System::RemoteSystems::KnownRemoteSystemCapabilities::RemoteSession());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownRemoteSystemCapabilities_get_SpatialEntity(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.RemoteSystems.KnownRemoteSystemCapabilities", L"SpatialEntity");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::System::RemoteSystems::KnownRemoteSystemCapabilities::SpatialEntity());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_KnownRemoteSystemCapabilities[] = {
        { }
    };

    static PyGetSetDef _getset_KnownRemoteSystemCapabilities[] = {
        { }
    };

    static PyType_Slot _type_slots_KnownRemoteSystemCapabilities[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_KnownRemoteSystemCapabilities) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_KnownRemoteSystemCapabilities) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_KnownRemoteSystemCapabilities) },
        { }
    };

    static PyType_Spec type_spec_KnownRemoteSystemCapabilities = {
        "winrt._winrt_windows_system_remotesystems.KnownRemoteSystemCapabilities",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_KnownRemoteSystemCapabilities};

    static PyGetSetDef getset_KnownRemoteSystemCapabilities_Static[] = {
        { "app_service", reinterpret_cast<getter>(KnownRemoteSystemCapabilities_get_AppService), nullptr, nullptr, nullptr },
        { "launch_uri", reinterpret_cast<getter>(KnownRemoteSystemCapabilities_get_LaunchUri), nullptr, nullptr, nullptr },
        { "remote_session", reinterpret_cast<getter>(KnownRemoteSystemCapabilities_get_RemoteSession), nullptr, nullptr, nullptr },
        { "spatial_entity", reinterpret_cast<getter>(KnownRemoteSystemCapabilities_get_SpatialEntity), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_KnownRemoteSystemCapabilities_Static[] = {
        { }
    };

    static PyType_Slot type_slots_KnownRemoteSystemCapabilities_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_KnownRemoteSystemCapabilities_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_KnownRemoteSystemCapabilities_Static) },
        { }
    };

    static PyType_Spec type_spec_KnownRemoteSystemCapabilities_Static =
    {
        "winrt._winrt_windows_system_remotesystems.KnownRemoteSystemCapabilities_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_KnownRemoteSystemCapabilities_Static
    };

    // ----- RemoteSystem class --------------------

    static PyObject* _new_RemoteSystem(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::System::RemoteSystems::RemoteSystem>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::System::RemoteSystems::RemoteSystem>::type_name);
        return nullptr;
    }

    static void _dealloc_RemoteSystem(py::wrapper::Windows::System::RemoteSystems::RemoteSystem* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* RemoteSystem_CreateWatcher(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.RemoteSystems.RemoteSystem", L"CreateWatcher", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(winrt::Windows::System::RemoteSystems::RemoteSystem::CreateWatcher());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.RemoteSystems.RemoteSystem", L"CreateWatcher", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::System::RemoteSystems::IRemoteSystemFilter>>(args, 0);

                return py::convert(winrt::Windows::System::RemoteSystems::RemoteSystem::CreateWatcher(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RemoteSystem_CreateWatcherForUser(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.RemoteSystems.RemoteSystem", L"CreateWatcherForUser", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::System::User>(args, 0);

                return py::convert(winrt::Windows::System::RemoteSystems::RemoteSystem::CreateWatcherForUser(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.RemoteSystems.RemoteSystem", L"CreateWatcherForUser", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::System::User>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::System::RemoteSystems::IRemoteSystemFilter>>(args, 1);

                return py::convert(winrt::Windows::System::RemoteSystems::RemoteSystem::CreateWatcherForUser(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RemoteSystem_FindByHostNameAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.RemoteSystems.RemoteSystem", L"FindByHostNameAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Networking::HostName>(args, 0);

                return py::convert(winrt::Windows::System::RemoteSystems::RemoteSystem::FindByHostNameAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RemoteSystem_GetCapabilitySupportedAsync(py::wrapper::Windows::System::RemoteSystems::RemoteSystem* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.RemoteSystems.RemoteSystem", L"GetCapabilitySupportedAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.GetCapabilitySupportedAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RemoteSystem_IsAuthorizationKindEnabled(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.RemoteSystems.RemoteSystem", L"IsAuthorizationKindEnabled", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::System::RemoteSystems::RemoteSystemAuthorizationKind>(args, 0);

                return py::convert(winrt::Windows::System::RemoteSystems::RemoteSystem::IsAuthorizationKindEnabled(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RemoteSystem_RequestAccessAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.RemoteSystems.RemoteSystem", L"RequestAccessAsync", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(winrt::Windows::System::RemoteSystems::RemoteSystem::RequestAccessAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RemoteSystem_get_DisplayName(py::wrapper::Windows::System::RemoteSystems::RemoteSystem* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.RemoteSystems.RemoteSystem", L"DisplayName");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DisplayName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RemoteSystem_get_Id(py::wrapper::Windows::System::RemoteSystems::RemoteSystem* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.RemoteSystems.RemoteSystem", L"Id");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RemoteSystem_get_IsAvailableByProximity(py::wrapper::Windows::System::RemoteSystems::RemoteSystem* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.RemoteSystems.RemoteSystem", L"IsAvailableByProximity");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsAvailableByProximity());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RemoteSystem_get_Kind(py::wrapper::Windows::System::RemoteSystems::RemoteSystem* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.RemoteSystems.RemoteSystem", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RemoteSystem_get_Status(py::wrapper::Windows::System::RemoteSystems::RemoteSystem* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.RemoteSystems.RemoteSystem", L"Status");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RemoteSystem_get_IsAvailableBySpatialProximity(py::wrapper::Windows::System::RemoteSystems::RemoteSystem* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.RemoteSystems.RemoteSystem", L"IsAvailableBySpatialProximity");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsAvailableBySpatialProximity());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RemoteSystem_get_ManufacturerDisplayName(py::wrapper::Windows::System::RemoteSystems::RemoteSystem* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.RemoteSystems.RemoteSystem", L"ManufacturerDisplayName");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ManufacturerDisplayName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RemoteSystem_get_ModelDisplayName(py::wrapper::Windows::System::RemoteSystems::RemoteSystem* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.RemoteSystems.RemoteSystem", L"ModelDisplayName");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ModelDisplayName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RemoteSystem_get_Platform(py::wrapper::Windows::System::RemoteSystems::RemoteSystem* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.RemoteSystems.RemoteSystem", L"Platform");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Platform());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RemoteSystem_get_Apps(py::wrapper::Windows::System::RemoteSystems::RemoteSystem* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.RemoteSystems.RemoteSystem", L"Apps");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Apps());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RemoteSystem_get_User(py::wrapper::Windows::System::RemoteSystems::RemoteSystem* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.RemoteSystems.RemoteSystem", L"User");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.User());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_RemoteSystem(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::System::RemoteSystems::RemoteSystem>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_RemoteSystem(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::RemoteSystems::RemoteSystem>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RemoteSystem[] = {
        { "get_capability_supported_async", reinterpret_cast<PyCFunction>(RemoteSystem_GetCapabilitySupportedAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_RemoteSystem, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_RemoteSystem), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_RemoteSystem[] = {
        { "display_name", reinterpret_cast<getter>(RemoteSystem_get_DisplayName), nullptr, nullptr, nullptr },
        { "id", reinterpret_cast<getter>(RemoteSystem_get_Id), nullptr, nullptr, nullptr },
        { "is_available_by_proximity", reinterpret_cast<getter>(RemoteSystem_get_IsAvailableByProximity), nullptr, nullptr, nullptr },
        { "kind", reinterpret_cast<getter>(RemoteSystem_get_Kind), nullptr, nullptr, nullptr },
        { "status", reinterpret_cast<getter>(RemoteSystem_get_Status), nullptr, nullptr, nullptr },
        { "is_available_by_spatial_proximity", reinterpret_cast<getter>(RemoteSystem_get_IsAvailableBySpatialProximity), nullptr, nullptr, nullptr },
        { "manufacturer_display_name", reinterpret_cast<getter>(RemoteSystem_get_ManufacturerDisplayName), nullptr, nullptr, nullptr },
        { "model_display_name", reinterpret_cast<getter>(RemoteSystem_get_ModelDisplayName), nullptr, nullptr, nullptr },
        { "platform", reinterpret_cast<getter>(RemoteSystem_get_Platform), nullptr, nullptr, nullptr },
        { "apps", reinterpret_cast<getter>(RemoteSystem_get_Apps), nullptr, nullptr, nullptr },
        { "user", reinterpret_cast<getter>(RemoteSystem_get_User), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_RemoteSystem[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_RemoteSystem) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_RemoteSystem) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_RemoteSystem) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_RemoteSystem) },
        { }
    };

    static PyType_Spec type_spec_RemoteSystem = {
        "winrt._winrt_windows_system_remotesystems.RemoteSystem",
        sizeof(py::wrapper::Windows::System::RemoteSystems::RemoteSystem),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RemoteSystem};

    static PyGetSetDef getset_RemoteSystem_Static[] = {
        { }
    };

    static PyMethodDef methods_RemoteSystem_Static[] = {
        { "create_watcher", reinterpret_cast<PyCFunction>(RemoteSystem_CreateWatcher), METH_VARARGS, nullptr },
        { "create_watcher_for_user", reinterpret_cast<PyCFunction>(RemoteSystem_CreateWatcherForUser), METH_VARARGS, nullptr },
        { "find_by_host_name_async", reinterpret_cast<PyCFunction>(RemoteSystem_FindByHostNameAsync), METH_VARARGS, nullptr },
        { "is_authorization_kind_enabled", reinterpret_cast<PyCFunction>(RemoteSystem_IsAuthorizationKindEnabled), METH_VARARGS, nullptr },
        { "request_access_async", reinterpret_cast<PyCFunction>(RemoteSystem_RequestAccessAsync), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_RemoteSystem_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_RemoteSystem_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_RemoteSystem_Static) },
        { }
    };

    static PyType_Spec type_spec_RemoteSystem_Static =
    {
        "winrt._winrt_windows_system_remotesystems.RemoteSystem_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_RemoteSystem_Static
    };

    // ----- RemoteSystemAddedEventArgs class --------------------

    static PyObject* _new_RemoteSystemAddedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::System::RemoteSystems::RemoteSystemAddedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::System::RemoteSystems::RemoteSystemAddedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_RemoteSystemAddedEventArgs(py::wrapper::Windows::System::RemoteSystems::RemoteSystemAddedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* RemoteSystemAddedEventArgs_get_RemoteSystem(py::wrapper::Windows::System::RemoteSystems::RemoteSystemAddedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.RemoteSystems.RemoteSystemAddedEventArgs", L"RemoteSystem");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.RemoteSystem());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_RemoteSystemAddedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::System::RemoteSystems::RemoteSystemAddedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_RemoteSystemAddedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::RemoteSystems::RemoteSystemAddedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RemoteSystemAddedEventArgs[] = {
        { "_assign_array_", _assign_array_RemoteSystemAddedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_RemoteSystemAddedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_RemoteSystemAddedEventArgs[] = {
        { "remote_system", reinterpret_cast<getter>(RemoteSystemAddedEventArgs_get_RemoteSystem), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_RemoteSystemAddedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_RemoteSystemAddedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_RemoteSystemAddedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_RemoteSystemAddedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_RemoteSystemAddedEventArgs) },
        { }
    };

    static PyType_Spec type_spec_RemoteSystemAddedEventArgs = {
        "winrt._winrt_windows_system_remotesystems.RemoteSystemAddedEventArgs",
        sizeof(py::wrapper::Windows::System::RemoteSystems::RemoteSystemAddedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RemoteSystemAddedEventArgs};

    // ----- RemoteSystemApp class --------------------

    static PyObject* _new_RemoteSystemApp(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::System::RemoteSystems::RemoteSystemApp>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::System::RemoteSystems::RemoteSystemApp>::type_name);
        return nullptr;
    }

    static void _dealloc_RemoteSystemApp(py::wrapper::Windows::System::RemoteSystems::RemoteSystemApp* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* RemoteSystemApp_get_Attributes(py::wrapper::Windows::System::RemoteSystems::RemoteSystemApp* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.RemoteSystems.RemoteSystemApp", L"Attributes");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Attributes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RemoteSystemApp_get_DisplayName(py::wrapper::Windows::System::RemoteSystems::RemoteSystemApp* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.RemoteSystems.RemoteSystemApp", L"DisplayName");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DisplayName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RemoteSystemApp_get_Id(py::wrapper::Windows::System::RemoteSystems::RemoteSystemApp* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.RemoteSystems.RemoteSystemApp", L"Id");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RemoteSystemApp_get_IsAvailableByProximity(py::wrapper::Windows::System::RemoteSystems::RemoteSystemApp* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.RemoteSystems.RemoteSystemApp", L"IsAvailableByProximity");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsAvailableByProximity());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RemoteSystemApp_get_IsAvailableBySpatialProximity(py::wrapper::Windows::System::RemoteSystems::RemoteSystemApp* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.RemoteSystems.RemoteSystemApp", L"IsAvailableBySpatialProximity");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsAvailableBySpatialProximity());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RemoteSystemApp_get_ConnectionToken(py::wrapper::Windows::System::RemoteSystems::RemoteSystemApp* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.RemoteSystems.RemoteSystemApp", L"ConnectionToken");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ConnectionToken());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RemoteSystemApp_get_User(py::wrapper::Windows::System::RemoteSystems::RemoteSystemApp* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.RemoteSystems.RemoteSystemApp", L"User");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.User());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_RemoteSystemApp(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::System::RemoteSystems::RemoteSystemApp>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_RemoteSystemApp(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::RemoteSystems::RemoteSystemApp>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RemoteSystemApp[] = {
        { "_assign_array_", _assign_array_RemoteSystemApp, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_RemoteSystemApp), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_RemoteSystemApp[] = {
        { "attributes", reinterpret_cast<getter>(RemoteSystemApp_get_Attributes), nullptr, nullptr, nullptr },
        { "display_name", reinterpret_cast<getter>(RemoteSystemApp_get_DisplayName), nullptr, nullptr, nullptr },
        { "id", reinterpret_cast<getter>(RemoteSystemApp_get_Id), nullptr, nullptr, nullptr },
        { "is_available_by_proximity", reinterpret_cast<getter>(RemoteSystemApp_get_IsAvailableByProximity), nullptr, nullptr, nullptr },
        { "is_available_by_spatial_proximity", reinterpret_cast<getter>(RemoteSystemApp_get_IsAvailableBySpatialProximity), nullptr, nullptr, nullptr },
        { "connection_token", reinterpret_cast<getter>(RemoteSystemApp_get_ConnectionToken), nullptr, nullptr, nullptr },
        { "user", reinterpret_cast<getter>(RemoteSystemApp_get_User), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_RemoteSystemApp[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_RemoteSystemApp) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_RemoteSystemApp) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_RemoteSystemApp) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_RemoteSystemApp) },
        { }
    };

    static PyType_Spec type_spec_RemoteSystemApp = {
        "winrt._winrt_windows_system_remotesystems.RemoteSystemApp",
        sizeof(py::wrapper::Windows::System::RemoteSystems::RemoteSystemApp),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RemoteSystemApp};

    // ----- RemoteSystemAppRegistration class --------------------

    static PyObject* _new_RemoteSystemAppRegistration(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::System::RemoteSystems::RemoteSystemAppRegistration>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::System::RemoteSystems::RemoteSystemAppRegistration>::type_name);
        return nullptr;
    }

    static void _dealloc_RemoteSystemAppRegistration(py::wrapper::Windows::System::RemoteSystems::RemoteSystemAppRegistration* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* RemoteSystemAppRegistration_GetDefault(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.RemoteSystems.RemoteSystemAppRegistration", L"GetDefault", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(winrt::Windows::System::RemoteSystems::RemoteSystemAppRegistration::GetDefault());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RemoteSystemAppRegistration_GetForUser(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.RemoteSystems.RemoteSystemAppRegistration", L"GetForUser", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::System::User>(args, 0);

                return py::convert(winrt::Windows::System::RemoteSystems::RemoteSystemAppRegistration::GetForUser(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RemoteSystemAppRegistration_SaveAsync(py::wrapper::Windows::System::RemoteSystems::RemoteSystemAppRegistration* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.RemoteSystems.RemoteSystemAppRegistration", L"SaveAsync", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.SaveAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RemoteSystemAppRegistration_get_Attributes(py::wrapper::Windows::System::RemoteSystems::RemoteSystemAppRegistration* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.RemoteSystems.RemoteSystemAppRegistration", L"Attributes");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Attributes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RemoteSystemAppRegistration_get_User(py::wrapper::Windows::System::RemoteSystems::RemoteSystemAppRegistration* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.RemoteSystems.RemoteSystemAppRegistration", L"User");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.User());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_RemoteSystemAppRegistration(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::System::RemoteSystems::RemoteSystemAppRegistration>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_RemoteSystemAppRegistration(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::RemoteSystems::RemoteSystemAppRegistration>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RemoteSystemAppRegistration[] = {
        { "save_async", reinterpret_cast<PyCFunction>(RemoteSystemAppRegistration_SaveAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_RemoteSystemAppRegistration, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_RemoteSystemAppRegistration), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_RemoteSystemAppRegistration[] = {
        { "attributes", reinterpret_cast<getter>(RemoteSystemAppRegistration_get_Attributes), nullptr, nullptr, nullptr },
        { "user", reinterpret_cast<getter>(RemoteSystemAppRegistration_get_User), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_RemoteSystemAppRegistration[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_RemoteSystemAppRegistration) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_RemoteSystemAppRegistration) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_RemoteSystemAppRegistration) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_RemoteSystemAppRegistration) },
        { }
    };

    static PyType_Spec type_spec_RemoteSystemAppRegistration = {
        "winrt._winrt_windows_system_remotesystems.RemoteSystemAppRegistration",
        sizeof(py::wrapper::Windows::System::RemoteSystems::RemoteSystemAppRegistration),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RemoteSystemAppRegistration};

    static PyGetSetDef getset_RemoteSystemAppRegistration_Static[] = {
        { }
    };

    static PyMethodDef methods_RemoteSystemAppRegistration_Static[] = {
        { "get_default", reinterpret_cast<PyCFunction>(RemoteSystemAppRegistration_GetDefault), METH_VARARGS, nullptr },
        { "get_for_user", reinterpret_cast<PyCFunction>(RemoteSystemAppRegistration_GetForUser), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_RemoteSystemAppRegistration_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_RemoteSystemAppRegistration_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_RemoteSystemAppRegistration_Static) },
        { }
    };

    static PyType_Spec type_spec_RemoteSystemAppRegistration_Static =
    {
        "winrt._winrt_windows_system_remotesystems.RemoteSystemAppRegistration_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_RemoteSystemAppRegistration_Static
    };

    // ----- RemoteSystemAuthorizationKindFilter class --------------------

    static PyObject* _new_RemoteSystemAuthorizationKindFilter(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::System::RemoteSystems::RemoteSystemAuthorizationKind>(args, 0);

                winrt::Windows::System::RemoteSystems::RemoteSystemAuthorizationKindFilter instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_RemoteSystemAuthorizationKindFilter(py::wrapper::Windows::System::RemoteSystems::RemoteSystemAuthorizationKindFilter* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* RemoteSystemAuthorizationKindFilter_get_RemoteSystemAuthorizationKind(py::wrapper::Windows::System::RemoteSystems::RemoteSystemAuthorizationKindFilter* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.RemoteSystems.RemoteSystemAuthorizationKindFilter", L"RemoteSystemAuthorizationKind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.RemoteSystemAuthorizationKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_RemoteSystemAuthorizationKindFilter(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::System::RemoteSystems::RemoteSystemAuthorizationKindFilter>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_RemoteSystemAuthorizationKindFilter(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::RemoteSystems::RemoteSystemAuthorizationKindFilter>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RemoteSystemAuthorizationKindFilter[] = {
        { "_assign_array_", _assign_array_RemoteSystemAuthorizationKindFilter, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_RemoteSystemAuthorizationKindFilter), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_RemoteSystemAuthorizationKindFilter[] = {
        { "remote_system_authorization_kind", reinterpret_cast<getter>(RemoteSystemAuthorizationKindFilter_get_RemoteSystemAuthorizationKind), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_RemoteSystemAuthorizationKindFilter[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_RemoteSystemAuthorizationKindFilter) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_RemoteSystemAuthorizationKindFilter) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_RemoteSystemAuthorizationKindFilter) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_RemoteSystemAuthorizationKindFilter) },
        { }
    };

    static PyType_Spec type_spec_RemoteSystemAuthorizationKindFilter = {
        "winrt._winrt_windows_system_remotesystems.RemoteSystemAuthorizationKindFilter",
        sizeof(py::wrapper::Windows::System::RemoteSystems::RemoteSystemAuthorizationKindFilter),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RemoteSystemAuthorizationKindFilter};

    // ----- RemoteSystemConnectionInfo class --------------------

    static PyObject* _new_RemoteSystemConnectionInfo(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::System::RemoteSystems::RemoteSystemConnectionInfo>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::System::RemoteSystems::RemoteSystemConnectionInfo>::type_name);
        return nullptr;
    }

    static void _dealloc_RemoteSystemConnectionInfo(py::wrapper::Windows::System::RemoteSystems::RemoteSystemConnectionInfo* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* RemoteSystemConnectionInfo_TryCreateFromAppServiceConnection(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.RemoteSystems.RemoteSystemConnectionInfo", L"TryCreateFromAppServiceConnection", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::AppService::AppServiceConnection>(args, 0);

                return py::convert(winrt::Windows::System::RemoteSystems::RemoteSystemConnectionInfo::TryCreateFromAppServiceConnection(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RemoteSystemConnectionInfo_get_IsProximal(py::wrapper::Windows::System::RemoteSystems::RemoteSystemConnectionInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.RemoteSystems.RemoteSystemConnectionInfo", L"IsProximal");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsProximal());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_RemoteSystemConnectionInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::System::RemoteSystems::RemoteSystemConnectionInfo>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_RemoteSystemConnectionInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::RemoteSystems::RemoteSystemConnectionInfo>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RemoteSystemConnectionInfo[] = {
        { "_assign_array_", _assign_array_RemoteSystemConnectionInfo, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_RemoteSystemConnectionInfo), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_RemoteSystemConnectionInfo[] = {
        { "is_proximal", reinterpret_cast<getter>(RemoteSystemConnectionInfo_get_IsProximal), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_RemoteSystemConnectionInfo[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_RemoteSystemConnectionInfo) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_RemoteSystemConnectionInfo) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_RemoteSystemConnectionInfo) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_RemoteSystemConnectionInfo) },
        { }
    };

    static PyType_Spec type_spec_RemoteSystemConnectionInfo = {
        "winrt._winrt_windows_system_remotesystems.RemoteSystemConnectionInfo",
        sizeof(py::wrapper::Windows::System::RemoteSystems::RemoteSystemConnectionInfo),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RemoteSystemConnectionInfo};

    static PyGetSetDef getset_RemoteSystemConnectionInfo_Static[] = {
        { }
    };

    static PyMethodDef methods_RemoteSystemConnectionInfo_Static[] = {
        { "try_create_from_app_service_connection", reinterpret_cast<PyCFunction>(RemoteSystemConnectionInfo_TryCreateFromAppServiceConnection), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_RemoteSystemConnectionInfo_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_RemoteSystemConnectionInfo_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_RemoteSystemConnectionInfo_Static) },
        { }
    };

    static PyType_Spec type_spec_RemoteSystemConnectionInfo_Static =
    {
        "winrt._winrt_windows_system_remotesystems.RemoteSystemConnectionInfo_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_RemoteSystemConnectionInfo_Static
    };

    // ----- RemoteSystemConnectionRequest class --------------------

    static PyObject* _new_RemoteSystemConnectionRequest(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::System::RemoteSystems::RemoteSystem>(args, 0);

                winrt::Windows::System::RemoteSystems::RemoteSystemConnectionRequest instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_RemoteSystemConnectionRequest(py::wrapper::Windows::System::RemoteSystems::RemoteSystemConnectionRequest* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* RemoteSystemConnectionRequest_CreateForApp(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.RemoteSystems.RemoteSystemConnectionRequest", L"CreateForApp", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::System::RemoteSystems::RemoteSystemApp>(args, 0);

                return py::convert(winrt::Windows::System::RemoteSystems::RemoteSystemConnectionRequest::CreateForApp(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RemoteSystemConnectionRequest_CreateFromConnectionToken(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.RemoteSystems.RemoteSystemConnectionRequest", L"CreateFromConnectionToken", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::System::RemoteSystems::RemoteSystemConnectionRequest::CreateFromConnectionToken(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RemoteSystemConnectionRequest_CreateFromConnectionTokenForUser(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.RemoteSystems.RemoteSystemConnectionRequest", L"CreateFromConnectionTokenForUser", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::System::User>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(winrt::Windows::System::RemoteSystems::RemoteSystemConnectionRequest::CreateFromConnectionTokenForUser(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RemoteSystemConnectionRequest_get_RemoteSystem(py::wrapper::Windows::System::RemoteSystems::RemoteSystemConnectionRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.RemoteSystems.RemoteSystemConnectionRequest", L"RemoteSystem");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.RemoteSystem());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RemoteSystemConnectionRequest_get_RemoteSystemApp(py::wrapper::Windows::System::RemoteSystems::RemoteSystemConnectionRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.RemoteSystems.RemoteSystemConnectionRequest", L"RemoteSystemApp");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.RemoteSystemApp());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RemoteSystemConnectionRequest_get_ConnectionToken(py::wrapper::Windows::System::RemoteSystems::RemoteSystemConnectionRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.RemoteSystems.RemoteSystemConnectionRequest", L"ConnectionToken");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ConnectionToken());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_RemoteSystemConnectionRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::System::RemoteSystems::RemoteSystemConnectionRequest>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_RemoteSystemConnectionRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::RemoteSystems::RemoteSystemConnectionRequest>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RemoteSystemConnectionRequest[] = {
        { "_assign_array_", _assign_array_RemoteSystemConnectionRequest, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_RemoteSystemConnectionRequest), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_RemoteSystemConnectionRequest[] = {
        { "remote_system", reinterpret_cast<getter>(RemoteSystemConnectionRequest_get_RemoteSystem), nullptr, nullptr, nullptr },
        { "remote_system_app", reinterpret_cast<getter>(RemoteSystemConnectionRequest_get_RemoteSystemApp), nullptr, nullptr, nullptr },
        { "connection_token", reinterpret_cast<getter>(RemoteSystemConnectionRequest_get_ConnectionToken), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_RemoteSystemConnectionRequest[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_RemoteSystemConnectionRequest) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_RemoteSystemConnectionRequest) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_RemoteSystemConnectionRequest) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_RemoteSystemConnectionRequest) },
        { }
    };

    static PyType_Spec type_spec_RemoteSystemConnectionRequest = {
        "winrt._winrt_windows_system_remotesystems.RemoteSystemConnectionRequest",
        sizeof(py::wrapper::Windows::System::RemoteSystems::RemoteSystemConnectionRequest),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RemoteSystemConnectionRequest};

    static PyGetSetDef getset_RemoteSystemConnectionRequest_Static[] = {
        { }
    };

    static PyMethodDef methods_RemoteSystemConnectionRequest_Static[] = {
        { "create_for_app", reinterpret_cast<PyCFunction>(RemoteSystemConnectionRequest_CreateForApp), METH_VARARGS, nullptr },
        { "create_from_connection_token", reinterpret_cast<PyCFunction>(RemoteSystemConnectionRequest_CreateFromConnectionToken), METH_VARARGS, nullptr },
        { "create_from_connection_token_for_user", reinterpret_cast<PyCFunction>(RemoteSystemConnectionRequest_CreateFromConnectionTokenForUser), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_RemoteSystemConnectionRequest_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_RemoteSystemConnectionRequest_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_RemoteSystemConnectionRequest_Static) },
        { }
    };

    static PyType_Spec type_spec_RemoteSystemConnectionRequest_Static =
    {
        "winrt._winrt_windows_system_remotesystems.RemoteSystemConnectionRequest_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_RemoteSystemConnectionRequest_Static
    };

    // ----- RemoteSystemDiscoveryTypeFilter class --------------------

    static PyObject* _new_RemoteSystemDiscoveryTypeFilter(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::System::RemoteSystems::RemoteSystemDiscoveryType>(args, 0);

                winrt::Windows::System::RemoteSystems::RemoteSystemDiscoveryTypeFilter instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_RemoteSystemDiscoveryTypeFilter(py::wrapper::Windows::System::RemoteSystems::RemoteSystemDiscoveryTypeFilter* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* RemoteSystemDiscoveryTypeFilter_get_RemoteSystemDiscoveryType(py::wrapper::Windows::System::RemoteSystems::RemoteSystemDiscoveryTypeFilter* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.RemoteSystems.RemoteSystemDiscoveryTypeFilter", L"RemoteSystemDiscoveryType");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.RemoteSystemDiscoveryType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_RemoteSystemDiscoveryTypeFilter(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::System::RemoteSystems::RemoteSystemDiscoveryTypeFilter>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_RemoteSystemDiscoveryTypeFilter(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::RemoteSystems::RemoteSystemDiscoveryTypeFilter>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RemoteSystemDiscoveryTypeFilter[] = {
        { "_assign_array_", _assign_array_RemoteSystemDiscoveryTypeFilter, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_RemoteSystemDiscoveryTypeFilter), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_RemoteSystemDiscoveryTypeFilter[] = {
        { "remote_system_discovery_type", reinterpret_cast<getter>(RemoteSystemDiscoveryTypeFilter_get_RemoteSystemDiscoveryType), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_RemoteSystemDiscoveryTypeFilter[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_RemoteSystemDiscoveryTypeFilter) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_RemoteSystemDiscoveryTypeFilter) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_RemoteSystemDiscoveryTypeFilter) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_RemoteSystemDiscoveryTypeFilter) },
        { }
    };

    static PyType_Spec type_spec_RemoteSystemDiscoveryTypeFilter = {
        "winrt._winrt_windows_system_remotesystems.RemoteSystemDiscoveryTypeFilter",
        sizeof(py::wrapper::Windows::System::RemoteSystems::RemoteSystemDiscoveryTypeFilter),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RemoteSystemDiscoveryTypeFilter};

    // ----- RemoteSystemEnumerationCompletedEventArgs class --------------------

    static PyObject* _new_RemoteSystemEnumerationCompletedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::System::RemoteSystems::RemoteSystemEnumerationCompletedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::System::RemoteSystems::RemoteSystemEnumerationCompletedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_RemoteSystemEnumerationCompletedEventArgs(py::wrapper::Windows::System::RemoteSystems::RemoteSystemEnumerationCompletedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_RemoteSystemEnumerationCompletedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::System::RemoteSystems::RemoteSystemEnumerationCompletedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_RemoteSystemEnumerationCompletedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::RemoteSystems::RemoteSystemEnumerationCompletedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RemoteSystemEnumerationCompletedEventArgs[] = {
        { "_assign_array_", _assign_array_RemoteSystemEnumerationCompletedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_RemoteSystemEnumerationCompletedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_RemoteSystemEnumerationCompletedEventArgs[] = {
        { }
    };

    static PyType_Slot _type_slots_RemoteSystemEnumerationCompletedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_RemoteSystemEnumerationCompletedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_RemoteSystemEnumerationCompletedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_RemoteSystemEnumerationCompletedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_RemoteSystemEnumerationCompletedEventArgs) },
        { }
    };

    static PyType_Spec type_spec_RemoteSystemEnumerationCompletedEventArgs = {
        "winrt._winrt_windows_system_remotesystems.RemoteSystemEnumerationCompletedEventArgs",
        sizeof(py::wrapper::Windows::System::RemoteSystems::RemoteSystemEnumerationCompletedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RemoteSystemEnumerationCompletedEventArgs};

    // ----- RemoteSystemKindFilter class --------------------

    static PyObject* _new_RemoteSystemKindFilter(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 0);

                winrt::Windows::System::RemoteSystems::RemoteSystemKindFilter instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_RemoteSystemKindFilter(py::wrapper::Windows::System::RemoteSystems::RemoteSystemKindFilter* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* RemoteSystemKindFilter_get_RemoteSystemKinds(py::wrapper::Windows::System::RemoteSystems::RemoteSystemKindFilter* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.RemoteSystems.RemoteSystemKindFilter", L"RemoteSystemKinds");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.RemoteSystemKinds());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_RemoteSystemKindFilter(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::System::RemoteSystems::RemoteSystemKindFilter>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_RemoteSystemKindFilter(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::RemoteSystems::RemoteSystemKindFilter>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RemoteSystemKindFilter[] = {
        { "_assign_array_", _assign_array_RemoteSystemKindFilter, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_RemoteSystemKindFilter), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_RemoteSystemKindFilter[] = {
        { "remote_system_kinds", reinterpret_cast<getter>(RemoteSystemKindFilter_get_RemoteSystemKinds), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_RemoteSystemKindFilter[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_RemoteSystemKindFilter) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_RemoteSystemKindFilter) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_RemoteSystemKindFilter) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_RemoteSystemKindFilter) },
        { }
    };

    static PyType_Spec type_spec_RemoteSystemKindFilter = {
        "winrt._winrt_windows_system_remotesystems.RemoteSystemKindFilter",
        sizeof(py::wrapper::Windows::System::RemoteSystems::RemoteSystemKindFilter),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RemoteSystemKindFilter};

    // ----- RemoteSystemKinds class --------------------

    static PyObject* _new_RemoteSystemKinds(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::System::RemoteSystems::RemoteSystemKinds>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::System::RemoteSystems::RemoteSystemKinds>::type_name);
        return nullptr;
    }

    static PyObject* RemoteSystemKinds_get_Desktop(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.RemoteSystems.RemoteSystemKinds", L"Desktop");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::System::RemoteSystems::RemoteSystemKinds::Desktop());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RemoteSystemKinds_get_Holographic(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.RemoteSystems.RemoteSystemKinds", L"Holographic");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::System::RemoteSystems::RemoteSystemKinds::Holographic());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RemoteSystemKinds_get_Hub(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.RemoteSystems.RemoteSystemKinds", L"Hub");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::System::RemoteSystems::RemoteSystemKinds::Hub());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RemoteSystemKinds_get_Phone(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.RemoteSystems.RemoteSystemKinds", L"Phone");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::System::RemoteSystems::RemoteSystemKinds::Phone());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RemoteSystemKinds_get_Xbox(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.RemoteSystems.RemoteSystemKinds", L"Xbox");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::System::RemoteSystems::RemoteSystemKinds::Xbox());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RemoteSystemKinds_get_Iot(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.RemoteSystems.RemoteSystemKinds", L"Iot");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::System::RemoteSystems::RemoteSystemKinds::Iot());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RemoteSystemKinds_get_Laptop(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.RemoteSystems.RemoteSystemKinds", L"Laptop");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::System::RemoteSystems::RemoteSystemKinds::Laptop());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RemoteSystemKinds_get_Tablet(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.RemoteSystems.RemoteSystemKinds", L"Tablet");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::System::RemoteSystems::RemoteSystemKinds::Tablet());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RemoteSystemKinds[] = {
        { }
    };

    static PyGetSetDef _getset_RemoteSystemKinds[] = {
        { }
    };

    static PyType_Slot _type_slots_RemoteSystemKinds[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_RemoteSystemKinds) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_RemoteSystemKinds) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_RemoteSystemKinds) },
        { }
    };

    static PyType_Spec type_spec_RemoteSystemKinds = {
        "winrt._winrt_windows_system_remotesystems.RemoteSystemKinds",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RemoteSystemKinds};

    static PyGetSetDef getset_RemoteSystemKinds_Static[] = {
        { "desktop", reinterpret_cast<getter>(RemoteSystemKinds_get_Desktop), nullptr, nullptr, nullptr },
        { "holographic", reinterpret_cast<getter>(RemoteSystemKinds_get_Holographic), nullptr, nullptr, nullptr },
        { "hub", reinterpret_cast<getter>(RemoteSystemKinds_get_Hub), nullptr, nullptr, nullptr },
        { "phone", reinterpret_cast<getter>(RemoteSystemKinds_get_Phone), nullptr, nullptr, nullptr },
        { "xbox", reinterpret_cast<getter>(RemoteSystemKinds_get_Xbox), nullptr, nullptr, nullptr },
        { "iot", reinterpret_cast<getter>(RemoteSystemKinds_get_Iot), nullptr, nullptr, nullptr },
        { "laptop", reinterpret_cast<getter>(RemoteSystemKinds_get_Laptop), nullptr, nullptr, nullptr },
        { "tablet", reinterpret_cast<getter>(RemoteSystemKinds_get_Tablet), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_RemoteSystemKinds_Static[] = {
        { }
    };

    static PyType_Slot type_slots_RemoteSystemKinds_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_RemoteSystemKinds_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_RemoteSystemKinds_Static) },
        { }
    };

    static PyType_Spec type_spec_RemoteSystemKinds_Static =
    {
        "winrt._winrt_windows_system_remotesystems.RemoteSystemKinds_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_RemoteSystemKinds_Static
    };

    // ----- RemoteSystemRemovedEventArgs class --------------------

    static PyObject* _new_RemoteSystemRemovedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::System::RemoteSystems::RemoteSystemRemovedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::System::RemoteSystems::RemoteSystemRemovedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_RemoteSystemRemovedEventArgs(py::wrapper::Windows::System::RemoteSystems::RemoteSystemRemovedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* RemoteSystemRemovedEventArgs_get_RemoteSystemId(py::wrapper::Windows::System::RemoteSystems::RemoteSystemRemovedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.RemoteSystems.RemoteSystemRemovedEventArgs", L"RemoteSystemId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.RemoteSystemId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_RemoteSystemRemovedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::System::RemoteSystems::RemoteSystemRemovedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_RemoteSystemRemovedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::RemoteSystems::RemoteSystemRemovedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RemoteSystemRemovedEventArgs[] = {
        { "_assign_array_", _assign_array_RemoteSystemRemovedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_RemoteSystemRemovedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_RemoteSystemRemovedEventArgs[] = {
        { "remote_system_id", reinterpret_cast<getter>(RemoteSystemRemovedEventArgs_get_RemoteSystemId), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_RemoteSystemRemovedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_RemoteSystemRemovedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_RemoteSystemRemovedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_RemoteSystemRemovedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_RemoteSystemRemovedEventArgs) },
        { }
    };

    static PyType_Spec type_spec_RemoteSystemRemovedEventArgs = {
        "winrt._winrt_windows_system_remotesystems.RemoteSystemRemovedEventArgs",
        sizeof(py::wrapper::Windows::System::RemoteSystems::RemoteSystemRemovedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RemoteSystemRemovedEventArgs};

    // ----- RemoteSystemSession class --------------------

    static PyObject* _new_RemoteSystemSession(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::System::RemoteSystems::RemoteSystemSession>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::System::RemoteSystems::RemoteSystemSession>::type_name);
        return nullptr;
    }

    static void _dealloc_RemoteSystemSession(py::wrapper::Windows::System::RemoteSystems::RemoteSystemSession* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* RemoteSystemSession_Close(py::wrapper::Windows::System::RemoteSystems::RemoteSystemSession* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.RemoteSystems.RemoteSystemSession", L"Close", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RemoteSystemSession_CreateParticipantWatcher(py::wrapper::Windows::System::RemoteSystems::RemoteSystemSession* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.RemoteSystems.RemoteSystemSession", L"CreateParticipantWatcher", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.CreateParticipantWatcher());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RemoteSystemSession_CreateWatcher(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.RemoteSystems.RemoteSystemSession", L"CreateWatcher", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(winrt::Windows::System::RemoteSystems::RemoteSystemSession::CreateWatcher());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RemoteSystemSession_SendInvitationAsync(py::wrapper::Windows::System::RemoteSystems::RemoteSystemSession* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.RemoteSystems.RemoteSystemSession", L"SendInvitationAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::System::RemoteSystems::RemoteSystem>(args, 0);

                return py::convert(self->obj.SendInvitationAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RemoteSystemSession_get_ControllerDisplayName(py::wrapper::Windows::System::RemoteSystems::RemoteSystemSession* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.RemoteSystems.RemoteSystemSession", L"ControllerDisplayName");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ControllerDisplayName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RemoteSystemSession_get_DisplayName(py::wrapper::Windows::System::RemoteSystems::RemoteSystemSession* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.RemoteSystems.RemoteSystemSession", L"DisplayName");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DisplayName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RemoteSystemSession_get_Id(py::wrapper::Windows::System::RemoteSystems::RemoteSystemSession* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.RemoteSystems.RemoteSystemSession", L"Id");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RemoteSystemSession_add_Disconnected(py::wrapper::Windows::System::RemoteSystems::RemoteSystemSession* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.System.RemoteSystems.RemoteSystemSession", L"Disconnected");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::System::RemoteSystems::RemoteSystemSession, winrt::Windows::System::RemoteSystems::RemoteSystemSessionDisconnectedEventArgs>>(arg);

            return py::convert(self->obj.Disconnected(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RemoteSystemSession_remove_Disconnected(py::wrapper::Windows::System::RemoteSystems::RemoteSystemSession* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.System.RemoteSystems.RemoteSystemSession", L"Disconnected");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Disconnected(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_RemoteSystemSession(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::System::RemoteSystems::RemoteSystemSession>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_RemoteSystemSession(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::RemoteSystems::RemoteSystemSession>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_RemoteSystemSession(py::wrapper::Windows::System::RemoteSystems::RemoteSystemSession* self, PyObject* /*unused*/) noexcept
    {
        return Py_NewRef(self);
    }

    static PyObject* _exit_RemoteSystemSession(py::wrapper::Windows::System::RemoteSystems::RemoteSystemSession* self, PyObject* /*unused*/) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RemoteSystemSession[] = {
        { "close", reinterpret_cast<PyCFunction>(RemoteSystemSession_Close), METH_VARARGS, nullptr },
        { "create_participant_watcher", reinterpret_cast<PyCFunction>(RemoteSystemSession_CreateParticipantWatcher), METH_VARARGS, nullptr },
        { "send_invitation_async", reinterpret_cast<PyCFunction>(RemoteSystemSession_SendInvitationAsync), METH_VARARGS, nullptr },
        { "add_disconnected", reinterpret_cast<PyCFunction>(RemoteSystemSession_add_Disconnected), METH_O, nullptr },
        { "remove_disconnected", reinterpret_cast<PyCFunction>(RemoteSystemSession_remove_Disconnected), METH_O, nullptr },
        { "_assign_array_", _assign_array_RemoteSystemSession, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_RemoteSystemSession), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_RemoteSystemSession), METH_NOARGS, nullptr },
        { "__exit__", reinterpret_cast<PyCFunction>(_exit_RemoteSystemSession), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_RemoteSystemSession[] = {
        { "controller_display_name", reinterpret_cast<getter>(RemoteSystemSession_get_ControllerDisplayName), nullptr, nullptr, nullptr },
        { "display_name", reinterpret_cast<getter>(RemoteSystemSession_get_DisplayName), nullptr, nullptr, nullptr },
        { "id", reinterpret_cast<getter>(RemoteSystemSession_get_Id), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_RemoteSystemSession[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_RemoteSystemSession) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_RemoteSystemSession) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_RemoteSystemSession) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_RemoteSystemSession) },
        { }
    };

    static PyType_Spec type_spec_RemoteSystemSession = {
        "winrt._winrt_windows_system_remotesystems.RemoteSystemSession",
        sizeof(py::wrapper::Windows::System::RemoteSystems::RemoteSystemSession),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RemoteSystemSession};

    static PyGetSetDef getset_RemoteSystemSession_Static[] = {
        { }
    };

    static PyMethodDef methods_RemoteSystemSession_Static[] = {
        { "create_watcher", reinterpret_cast<PyCFunction>(RemoteSystemSession_CreateWatcher), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_RemoteSystemSession_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_RemoteSystemSession_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_RemoteSystemSession_Static) },
        { }
    };

    static PyType_Spec type_spec_RemoteSystemSession_Static =
    {
        "winrt._winrt_windows_system_remotesystems.RemoteSystemSession_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_RemoteSystemSession_Static
    };

    // ----- RemoteSystemSessionAddedEventArgs class --------------------

    static PyObject* _new_RemoteSystemSessionAddedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::System::RemoteSystems::RemoteSystemSessionAddedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::System::RemoteSystems::RemoteSystemSessionAddedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_RemoteSystemSessionAddedEventArgs(py::wrapper::Windows::System::RemoteSystems::RemoteSystemSessionAddedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* RemoteSystemSessionAddedEventArgs_get_SessionInfo(py::wrapper::Windows::System::RemoteSystems::RemoteSystemSessionAddedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.RemoteSystems.RemoteSystemSessionAddedEventArgs", L"SessionInfo");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SessionInfo());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_RemoteSystemSessionAddedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::System::RemoteSystems::RemoteSystemSessionAddedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_RemoteSystemSessionAddedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::RemoteSystems::RemoteSystemSessionAddedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RemoteSystemSessionAddedEventArgs[] = {
        { "_assign_array_", _assign_array_RemoteSystemSessionAddedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_RemoteSystemSessionAddedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_RemoteSystemSessionAddedEventArgs[] = {
        { "session_info", reinterpret_cast<getter>(RemoteSystemSessionAddedEventArgs_get_SessionInfo), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_RemoteSystemSessionAddedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_RemoteSystemSessionAddedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_RemoteSystemSessionAddedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_RemoteSystemSessionAddedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_RemoteSystemSessionAddedEventArgs) },
        { }
    };

    static PyType_Spec type_spec_RemoteSystemSessionAddedEventArgs = {
        "winrt._winrt_windows_system_remotesystems.RemoteSystemSessionAddedEventArgs",
        sizeof(py::wrapper::Windows::System::RemoteSystems::RemoteSystemSessionAddedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RemoteSystemSessionAddedEventArgs};

    // ----- RemoteSystemSessionController class --------------------

    static PyObject* _new_RemoteSystemSessionController(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                winrt::Windows::System::RemoteSystems::RemoteSystemSessionController instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::System::RemoteSystems::RemoteSystemSessionOptions>(args, 1);

                winrt::Windows::System::RemoteSystems::RemoteSystemSessionController instance{param0, param1};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_RemoteSystemSessionController(py::wrapper::Windows::System::RemoteSystems::RemoteSystemSessionController* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* RemoteSystemSessionController_CreateSessionAsync(py::wrapper::Windows::System::RemoteSystems::RemoteSystemSessionController* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.RemoteSystems.RemoteSystemSessionController", L"CreateSessionAsync", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.CreateSessionAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RemoteSystemSessionController_RemoveParticipantAsync(py::wrapper::Windows::System::RemoteSystems::RemoteSystemSessionController* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.RemoteSystems.RemoteSystemSessionController", L"RemoveParticipantAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::System::RemoteSystems::RemoteSystemSessionParticipant>(args, 0);

                return py::convert(self->obj.RemoveParticipantAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RemoteSystemSessionController_add_JoinRequested(py::wrapper::Windows::System::RemoteSystems::RemoteSystemSessionController* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.System.RemoteSystems.RemoteSystemSessionController", L"JoinRequested");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::System::RemoteSystems::RemoteSystemSessionController, winrt::Windows::System::RemoteSystems::RemoteSystemSessionJoinRequestedEventArgs>>(arg);

            return py::convert(self->obj.JoinRequested(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RemoteSystemSessionController_remove_JoinRequested(py::wrapper::Windows::System::RemoteSystems::RemoteSystemSessionController* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.System.RemoteSystems.RemoteSystemSessionController", L"JoinRequested");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.JoinRequested(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_RemoteSystemSessionController(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::System::RemoteSystems::RemoteSystemSessionController>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_RemoteSystemSessionController(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::RemoteSystems::RemoteSystemSessionController>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RemoteSystemSessionController[] = {
        { "create_session_async", reinterpret_cast<PyCFunction>(RemoteSystemSessionController_CreateSessionAsync), METH_VARARGS, nullptr },
        { "remove_participant_async", reinterpret_cast<PyCFunction>(RemoteSystemSessionController_RemoveParticipantAsync), METH_VARARGS, nullptr },
        { "add_join_requested", reinterpret_cast<PyCFunction>(RemoteSystemSessionController_add_JoinRequested), METH_O, nullptr },
        { "remove_join_requested", reinterpret_cast<PyCFunction>(RemoteSystemSessionController_remove_JoinRequested), METH_O, nullptr },
        { "_assign_array_", _assign_array_RemoteSystemSessionController, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_RemoteSystemSessionController), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_RemoteSystemSessionController[] = {
        { }
    };

    static PyType_Slot _type_slots_RemoteSystemSessionController[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_RemoteSystemSessionController) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_RemoteSystemSessionController) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_RemoteSystemSessionController) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_RemoteSystemSessionController) },
        { }
    };

    static PyType_Spec type_spec_RemoteSystemSessionController = {
        "winrt._winrt_windows_system_remotesystems.RemoteSystemSessionController",
        sizeof(py::wrapper::Windows::System::RemoteSystems::RemoteSystemSessionController),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RemoteSystemSessionController};

    // ----- RemoteSystemSessionCreationResult class --------------------

    static PyObject* _new_RemoteSystemSessionCreationResult(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::System::RemoteSystems::RemoteSystemSessionCreationResult>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::System::RemoteSystems::RemoteSystemSessionCreationResult>::type_name);
        return nullptr;
    }

    static void _dealloc_RemoteSystemSessionCreationResult(py::wrapper::Windows::System::RemoteSystems::RemoteSystemSessionCreationResult* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* RemoteSystemSessionCreationResult_get_Session(py::wrapper::Windows::System::RemoteSystems::RemoteSystemSessionCreationResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.RemoteSystems.RemoteSystemSessionCreationResult", L"Session");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Session());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RemoteSystemSessionCreationResult_get_Status(py::wrapper::Windows::System::RemoteSystems::RemoteSystemSessionCreationResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.RemoteSystems.RemoteSystemSessionCreationResult", L"Status");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_RemoteSystemSessionCreationResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::System::RemoteSystems::RemoteSystemSessionCreationResult>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_RemoteSystemSessionCreationResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::RemoteSystems::RemoteSystemSessionCreationResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RemoteSystemSessionCreationResult[] = {
        { "_assign_array_", _assign_array_RemoteSystemSessionCreationResult, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_RemoteSystemSessionCreationResult), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_RemoteSystemSessionCreationResult[] = {
        { "session", reinterpret_cast<getter>(RemoteSystemSessionCreationResult_get_Session), nullptr, nullptr, nullptr },
        { "status", reinterpret_cast<getter>(RemoteSystemSessionCreationResult_get_Status), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_RemoteSystemSessionCreationResult[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_RemoteSystemSessionCreationResult) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_RemoteSystemSessionCreationResult) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_RemoteSystemSessionCreationResult) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_RemoteSystemSessionCreationResult) },
        { }
    };

    static PyType_Spec type_spec_RemoteSystemSessionCreationResult = {
        "winrt._winrt_windows_system_remotesystems.RemoteSystemSessionCreationResult",
        sizeof(py::wrapper::Windows::System::RemoteSystems::RemoteSystemSessionCreationResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RemoteSystemSessionCreationResult};

    // ----- RemoteSystemSessionDisconnectedEventArgs class --------------------

    static PyObject* _new_RemoteSystemSessionDisconnectedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::System::RemoteSystems::RemoteSystemSessionDisconnectedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::System::RemoteSystems::RemoteSystemSessionDisconnectedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_RemoteSystemSessionDisconnectedEventArgs(py::wrapper::Windows::System::RemoteSystems::RemoteSystemSessionDisconnectedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* RemoteSystemSessionDisconnectedEventArgs_get_Reason(py::wrapper::Windows::System::RemoteSystems::RemoteSystemSessionDisconnectedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.RemoteSystems.RemoteSystemSessionDisconnectedEventArgs", L"Reason");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Reason());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_RemoteSystemSessionDisconnectedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::System::RemoteSystems::RemoteSystemSessionDisconnectedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_RemoteSystemSessionDisconnectedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::RemoteSystems::RemoteSystemSessionDisconnectedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RemoteSystemSessionDisconnectedEventArgs[] = {
        { "_assign_array_", _assign_array_RemoteSystemSessionDisconnectedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_RemoteSystemSessionDisconnectedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_RemoteSystemSessionDisconnectedEventArgs[] = {
        { "reason", reinterpret_cast<getter>(RemoteSystemSessionDisconnectedEventArgs_get_Reason), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_RemoteSystemSessionDisconnectedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_RemoteSystemSessionDisconnectedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_RemoteSystemSessionDisconnectedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_RemoteSystemSessionDisconnectedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_RemoteSystemSessionDisconnectedEventArgs) },
        { }
    };

    static PyType_Spec type_spec_RemoteSystemSessionDisconnectedEventArgs = {
        "winrt._winrt_windows_system_remotesystems.RemoteSystemSessionDisconnectedEventArgs",
        sizeof(py::wrapper::Windows::System::RemoteSystems::RemoteSystemSessionDisconnectedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RemoteSystemSessionDisconnectedEventArgs};

    // ----- RemoteSystemSessionInfo class --------------------

    static PyObject* _new_RemoteSystemSessionInfo(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::System::RemoteSystems::RemoteSystemSessionInfo>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::System::RemoteSystems::RemoteSystemSessionInfo>::type_name);
        return nullptr;
    }

    static void _dealloc_RemoteSystemSessionInfo(py::wrapper::Windows::System::RemoteSystems::RemoteSystemSessionInfo* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* RemoteSystemSessionInfo_JoinAsync(py::wrapper::Windows::System::RemoteSystems::RemoteSystemSessionInfo* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.RemoteSystems.RemoteSystemSessionInfo", L"JoinAsync", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.JoinAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RemoteSystemSessionInfo_get_ControllerDisplayName(py::wrapper::Windows::System::RemoteSystems::RemoteSystemSessionInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.RemoteSystems.RemoteSystemSessionInfo", L"ControllerDisplayName");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ControllerDisplayName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RemoteSystemSessionInfo_get_DisplayName(py::wrapper::Windows::System::RemoteSystems::RemoteSystemSessionInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.RemoteSystems.RemoteSystemSessionInfo", L"DisplayName");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DisplayName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_RemoteSystemSessionInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::System::RemoteSystems::RemoteSystemSessionInfo>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_RemoteSystemSessionInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::RemoteSystems::RemoteSystemSessionInfo>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RemoteSystemSessionInfo[] = {
        { "join_async", reinterpret_cast<PyCFunction>(RemoteSystemSessionInfo_JoinAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_RemoteSystemSessionInfo, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_RemoteSystemSessionInfo), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_RemoteSystemSessionInfo[] = {
        { "controller_display_name", reinterpret_cast<getter>(RemoteSystemSessionInfo_get_ControllerDisplayName), nullptr, nullptr, nullptr },
        { "display_name", reinterpret_cast<getter>(RemoteSystemSessionInfo_get_DisplayName), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_RemoteSystemSessionInfo[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_RemoteSystemSessionInfo) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_RemoteSystemSessionInfo) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_RemoteSystemSessionInfo) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_RemoteSystemSessionInfo) },
        { }
    };

    static PyType_Spec type_spec_RemoteSystemSessionInfo = {
        "winrt._winrt_windows_system_remotesystems.RemoteSystemSessionInfo",
        sizeof(py::wrapper::Windows::System::RemoteSystems::RemoteSystemSessionInfo),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RemoteSystemSessionInfo};

    // ----- RemoteSystemSessionInvitation class --------------------

    static PyObject* _new_RemoteSystemSessionInvitation(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::System::RemoteSystems::RemoteSystemSessionInvitation>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::System::RemoteSystems::RemoteSystemSessionInvitation>::type_name);
        return nullptr;
    }

    static void _dealloc_RemoteSystemSessionInvitation(py::wrapper::Windows::System::RemoteSystems::RemoteSystemSessionInvitation* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* RemoteSystemSessionInvitation_get_Sender(py::wrapper::Windows::System::RemoteSystems::RemoteSystemSessionInvitation* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.RemoteSystems.RemoteSystemSessionInvitation", L"Sender");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Sender());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RemoteSystemSessionInvitation_get_SessionInfo(py::wrapper::Windows::System::RemoteSystems::RemoteSystemSessionInvitation* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.RemoteSystems.RemoteSystemSessionInvitation", L"SessionInfo");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SessionInfo());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_RemoteSystemSessionInvitation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::System::RemoteSystems::RemoteSystemSessionInvitation>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_RemoteSystemSessionInvitation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::RemoteSystems::RemoteSystemSessionInvitation>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RemoteSystemSessionInvitation[] = {
        { "_assign_array_", _assign_array_RemoteSystemSessionInvitation, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_RemoteSystemSessionInvitation), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_RemoteSystemSessionInvitation[] = {
        { "sender", reinterpret_cast<getter>(RemoteSystemSessionInvitation_get_Sender), nullptr, nullptr, nullptr },
        { "session_info", reinterpret_cast<getter>(RemoteSystemSessionInvitation_get_SessionInfo), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_RemoteSystemSessionInvitation[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_RemoteSystemSessionInvitation) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_RemoteSystemSessionInvitation) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_RemoteSystemSessionInvitation) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_RemoteSystemSessionInvitation) },
        { }
    };

    static PyType_Spec type_spec_RemoteSystemSessionInvitation = {
        "winrt._winrt_windows_system_remotesystems.RemoteSystemSessionInvitation",
        sizeof(py::wrapper::Windows::System::RemoteSystems::RemoteSystemSessionInvitation),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RemoteSystemSessionInvitation};

    // ----- RemoteSystemSessionInvitationListener class --------------------

    static PyObject* _new_RemoteSystemSessionInvitationListener(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::System::RemoteSystems::RemoteSystemSessionInvitationListener instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_RemoteSystemSessionInvitationListener(py::wrapper::Windows::System::RemoteSystems::RemoteSystemSessionInvitationListener* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* RemoteSystemSessionInvitationListener_add_InvitationReceived(py::wrapper::Windows::System::RemoteSystems::RemoteSystemSessionInvitationListener* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.System.RemoteSystems.RemoteSystemSessionInvitationListener", L"InvitationReceived");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::System::RemoteSystems::RemoteSystemSessionInvitationListener, winrt::Windows::System::RemoteSystems::RemoteSystemSessionInvitationReceivedEventArgs>>(arg);

            return py::convert(self->obj.InvitationReceived(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RemoteSystemSessionInvitationListener_remove_InvitationReceived(py::wrapper::Windows::System::RemoteSystems::RemoteSystemSessionInvitationListener* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.System.RemoteSystems.RemoteSystemSessionInvitationListener", L"InvitationReceived");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.InvitationReceived(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_RemoteSystemSessionInvitationListener(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::System::RemoteSystems::RemoteSystemSessionInvitationListener>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_RemoteSystemSessionInvitationListener(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::RemoteSystems::RemoteSystemSessionInvitationListener>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RemoteSystemSessionInvitationListener[] = {
        { "add_invitation_received", reinterpret_cast<PyCFunction>(RemoteSystemSessionInvitationListener_add_InvitationReceived), METH_O, nullptr },
        { "remove_invitation_received", reinterpret_cast<PyCFunction>(RemoteSystemSessionInvitationListener_remove_InvitationReceived), METH_O, nullptr },
        { "_assign_array_", _assign_array_RemoteSystemSessionInvitationListener, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_RemoteSystemSessionInvitationListener), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_RemoteSystemSessionInvitationListener[] = {
        { }
    };

    static PyType_Slot _type_slots_RemoteSystemSessionInvitationListener[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_RemoteSystemSessionInvitationListener) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_RemoteSystemSessionInvitationListener) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_RemoteSystemSessionInvitationListener) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_RemoteSystemSessionInvitationListener) },
        { }
    };

    static PyType_Spec type_spec_RemoteSystemSessionInvitationListener = {
        "winrt._winrt_windows_system_remotesystems.RemoteSystemSessionInvitationListener",
        sizeof(py::wrapper::Windows::System::RemoteSystems::RemoteSystemSessionInvitationListener),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RemoteSystemSessionInvitationListener};

    // ----- RemoteSystemSessionInvitationReceivedEventArgs class --------------------

    static PyObject* _new_RemoteSystemSessionInvitationReceivedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::System::RemoteSystems::RemoteSystemSessionInvitationReceivedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::System::RemoteSystems::RemoteSystemSessionInvitationReceivedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_RemoteSystemSessionInvitationReceivedEventArgs(py::wrapper::Windows::System::RemoteSystems::RemoteSystemSessionInvitationReceivedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* RemoteSystemSessionInvitationReceivedEventArgs_get_Invitation(py::wrapper::Windows::System::RemoteSystems::RemoteSystemSessionInvitationReceivedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.RemoteSystems.RemoteSystemSessionInvitationReceivedEventArgs", L"Invitation");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Invitation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_RemoteSystemSessionInvitationReceivedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::System::RemoteSystems::RemoteSystemSessionInvitationReceivedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_RemoteSystemSessionInvitationReceivedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::RemoteSystems::RemoteSystemSessionInvitationReceivedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RemoteSystemSessionInvitationReceivedEventArgs[] = {
        { "_assign_array_", _assign_array_RemoteSystemSessionInvitationReceivedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_RemoteSystemSessionInvitationReceivedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_RemoteSystemSessionInvitationReceivedEventArgs[] = {
        { "invitation", reinterpret_cast<getter>(RemoteSystemSessionInvitationReceivedEventArgs_get_Invitation), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_RemoteSystemSessionInvitationReceivedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_RemoteSystemSessionInvitationReceivedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_RemoteSystemSessionInvitationReceivedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_RemoteSystemSessionInvitationReceivedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_RemoteSystemSessionInvitationReceivedEventArgs) },
        { }
    };

    static PyType_Spec type_spec_RemoteSystemSessionInvitationReceivedEventArgs = {
        "winrt._winrt_windows_system_remotesystems.RemoteSystemSessionInvitationReceivedEventArgs",
        sizeof(py::wrapper::Windows::System::RemoteSystems::RemoteSystemSessionInvitationReceivedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RemoteSystemSessionInvitationReceivedEventArgs};

    // ----- RemoteSystemSessionJoinRequest class --------------------

    static PyObject* _new_RemoteSystemSessionJoinRequest(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::System::RemoteSystems::RemoteSystemSessionJoinRequest>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::System::RemoteSystems::RemoteSystemSessionJoinRequest>::type_name);
        return nullptr;
    }

    static void _dealloc_RemoteSystemSessionJoinRequest(py::wrapper::Windows::System::RemoteSystems::RemoteSystemSessionJoinRequest* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* RemoteSystemSessionJoinRequest_Accept(py::wrapper::Windows::System::RemoteSystems::RemoteSystemSessionJoinRequest* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.RemoteSystems.RemoteSystemSessionJoinRequest", L"Accept", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Accept();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RemoteSystemSessionJoinRequest_get_Participant(py::wrapper::Windows::System::RemoteSystems::RemoteSystemSessionJoinRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.RemoteSystems.RemoteSystemSessionJoinRequest", L"Participant");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Participant());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_RemoteSystemSessionJoinRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::System::RemoteSystems::RemoteSystemSessionJoinRequest>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_RemoteSystemSessionJoinRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::RemoteSystems::RemoteSystemSessionJoinRequest>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RemoteSystemSessionJoinRequest[] = {
        { "accept", reinterpret_cast<PyCFunction>(RemoteSystemSessionJoinRequest_Accept), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_RemoteSystemSessionJoinRequest, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_RemoteSystemSessionJoinRequest), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_RemoteSystemSessionJoinRequest[] = {
        { "participant", reinterpret_cast<getter>(RemoteSystemSessionJoinRequest_get_Participant), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_RemoteSystemSessionJoinRequest[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_RemoteSystemSessionJoinRequest) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_RemoteSystemSessionJoinRequest) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_RemoteSystemSessionJoinRequest) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_RemoteSystemSessionJoinRequest) },
        { }
    };

    static PyType_Spec type_spec_RemoteSystemSessionJoinRequest = {
        "winrt._winrt_windows_system_remotesystems.RemoteSystemSessionJoinRequest",
        sizeof(py::wrapper::Windows::System::RemoteSystems::RemoteSystemSessionJoinRequest),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RemoteSystemSessionJoinRequest};

    // ----- RemoteSystemSessionJoinRequestedEventArgs class --------------------

    static PyObject* _new_RemoteSystemSessionJoinRequestedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::System::RemoteSystems::RemoteSystemSessionJoinRequestedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::System::RemoteSystems::RemoteSystemSessionJoinRequestedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_RemoteSystemSessionJoinRequestedEventArgs(py::wrapper::Windows::System::RemoteSystems::RemoteSystemSessionJoinRequestedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* RemoteSystemSessionJoinRequestedEventArgs_GetDeferral(py::wrapper::Windows::System::RemoteSystems::RemoteSystemSessionJoinRequestedEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.RemoteSystems.RemoteSystemSessionJoinRequestedEventArgs", L"GetDeferral", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RemoteSystemSessionJoinRequestedEventArgs_get_JoinRequest(py::wrapper::Windows::System::RemoteSystems::RemoteSystemSessionJoinRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.RemoteSystems.RemoteSystemSessionJoinRequestedEventArgs", L"JoinRequest");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.JoinRequest());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_RemoteSystemSessionJoinRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::System::RemoteSystems::RemoteSystemSessionJoinRequestedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_RemoteSystemSessionJoinRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::RemoteSystems::RemoteSystemSessionJoinRequestedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RemoteSystemSessionJoinRequestedEventArgs[] = {
        { "get_deferral", reinterpret_cast<PyCFunction>(RemoteSystemSessionJoinRequestedEventArgs_GetDeferral), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_RemoteSystemSessionJoinRequestedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_RemoteSystemSessionJoinRequestedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_RemoteSystemSessionJoinRequestedEventArgs[] = {
        { "join_request", reinterpret_cast<getter>(RemoteSystemSessionJoinRequestedEventArgs_get_JoinRequest), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_RemoteSystemSessionJoinRequestedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_RemoteSystemSessionJoinRequestedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_RemoteSystemSessionJoinRequestedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_RemoteSystemSessionJoinRequestedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_RemoteSystemSessionJoinRequestedEventArgs) },
        { }
    };

    static PyType_Spec type_spec_RemoteSystemSessionJoinRequestedEventArgs = {
        "winrt._winrt_windows_system_remotesystems.RemoteSystemSessionJoinRequestedEventArgs",
        sizeof(py::wrapper::Windows::System::RemoteSystems::RemoteSystemSessionJoinRequestedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RemoteSystemSessionJoinRequestedEventArgs};

    // ----- RemoteSystemSessionJoinResult class --------------------

    static PyObject* _new_RemoteSystemSessionJoinResult(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::System::RemoteSystems::RemoteSystemSessionJoinResult>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::System::RemoteSystems::RemoteSystemSessionJoinResult>::type_name);
        return nullptr;
    }

    static void _dealloc_RemoteSystemSessionJoinResult(py::wrapper::Windows::System::RemoteSystems::RemoteSystemSessionJoinResult* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* RemoteSystemSessionJoinResult_get_Session(py::wrapper::Windows::System::RemoteSystems::RemoteSystemSessionJoinResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.RemoteSystems.RemoteSystemSessionJoinResult", L"Session");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Session());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RemoteSystemSessionJoinResult_get_Status(py::wrapper::Windows::System::RemoteSystems::RemoteSystemSessionJoinResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.RemoteSystems.RemoteSystemSessionJoinResult", L"Status");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_RemoteSystemSessionJoinResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::System::RemoteSystems::RemoteSystemSessionJoinResult>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_RemoteSystemSessionJoinResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::RemoteSystems::RemoteSystemSessionJoinResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RemoteSystemSessionJoinResult[] = {
        { "_assign_array_", _assign_array_RemoteSystemSessionJoinResult, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_RemoteSystemSessionJoinResult), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_RemoteSystemSessionJoinResult[] = {
        { "session", reinterpret_cast<getter>(RemoteSystemSessionJoinResult_get_Session), nullptr, nullptr, nullptr },
        { "status", reinterpret_cast<getter>(RemoteSystemSessionJoinResult_get_Status), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_RemoteSystemSessionJoinResult[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_RemoteSystemSessionJoinResult) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_RemoteSystemSessionJoinResult) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_RemoteSystemSessionJoinResult) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_RemoteSystemSessionJoinResult) },
        { }
    };

    static PyType_Spec type_spec_RemoteSystemSessionJoinResult = {
        "winrt._winrt_windows_system_remotesystems.RemoteSystemSessionJoinResult",
        sizeof(py::wrapper::Windows::System::RemoteSystems::RemoteSystemSessionJoinResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RemoteSystemSessionJoinResult};

    // ----- RemoteSystemSessionMessageChannel class --------------------

    static PyObject* _new_RemoteSystemSessionMessageChannel(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::System::RemoteSystems::RemoteSystemSession>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                winrt::Windows::System::RemoteSystems::RemoteSystemSessionMessageChannel instance{param0, param1};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::System::RemoteSystems::RemoteSystemSession>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::System::RemoteSystems::RemoteSystemSessionMessageChannelReliability>(args, 2);

                winrt::Windows::System::RemoteSystems::RemoteSystemSessionMessageChannel instance{param0, param1, param2};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_RemoteSystemSessionMessageChannel(py::wrapper::Windows::System::RemoteSystems::RemoteSystemSessionMessageChannel* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* RemoteSystemSessionMessageChannel_BroadcastValueSetAsync(py::wrapper::Windows::System::RemoteSystems::RemoteSystemSessionMessageChannel* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.RemoteSystems.RemoteSystemSessionMessageChannel", L"BroadcastValueSetAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::ValueSet>(args, 0);

                return py::convert(self->obj.BroadcastValueSetAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RemoteSystemSessionMessageChannel_SendValueSetAsync(py::wrapper::Windows::System::RemoteSystems::RemoteSystemSessionMessageChannel* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.RemoteSystems.RemoteSystemSessionMessageChannel", L"SendValueSetAsync", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::ValueSet>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::System::RemoteSystems::RemoteSystemSessionParticipant>(args, 1);

                return py::convert(self->obj.SendValueSetAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RemoteSystemSessionMessageChannel_SendValueSetToParticipantsAsync(py::wrapper::Windows::System::RemoteSystems::RemoteSystemSessionMessageChannel* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.RemoteSystems.RemoteSystemSessionMessageChannel", L"SendValueSetToParticipantsAsync", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::ValueSet>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::System::RemoteSystems::RemoteSystemSessionParticipant>>(args, 1);

                return py::convert(self->obj.SendValueSetToParticipantsAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RemoteSystemSessionMessageChannel_get_Session(py::wrapper::Windows::System::RemoteSystems::RemoteSystemSessionMessageChannel* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.RemoteSystems.RemoteSystemSessionMessageChannel", L"Session");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Session());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RemoteSystemSessionMessageChannel_add_ValueSetReceived(py::wrapper::Windows::System::RemoteSystems::RemoteSystemSessionMessageChannel* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.System.RemoteSystems.RemoteSystemSessionMessageChannel", L"ValueSetReceived");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::System::RemoteSystems::RemoteSystemSessionMessageChannel, winrt::Windows::System::RemoteSystems::RemoteSystemSessionValueSetReceivedEventArgs>>(arg);

            return py::convert(self->obj.ValueSetReceived(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RemoteSystemSessionMessageChannel_remove_ValueSetReceived(py::wrapper::Windows::System::RemoteSystems::RemoteSystemSessionMessageChannel* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.System.RemoteSystems.RemoteSystemSessionMessageChannel", L"ValueSetReceived");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ValueSetReceived(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_RemoteSystemSessionMessageChannel(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::System::RemoteSystems::RemoteSystemSessionMessageChannel>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_RemoteSystemSessionMessageChannel(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::RemoteSystems::RemoteSystemSessionMessageChannel>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RemoteSystemSessionMessageChannel[] = {
        { "broadcast_value_set_async", reinterpret_cast<PyCFunction>(RemoteSystemSessionMessageChannel_BroadcastValueSetAsync), METH_VARARGS, nullptr },
        { "send_value_set_async", reinterpret_cast<PyCFunction>(RemoteSystemSessionMessageChannel_SendValueSetAsync), METH_VARARGS, nullptr },
        { "send_value_set_to_participants_async", reinterpret_cast<PyCFunction>(RemoteSystemSessionMessageChannel_SendValueSetToParticipantsAsync), METH_VARARGS, nullptr },
        { "add_value_set_received", reinterpret_cast<PyCFunction>(RemoteSystemSessionMessageChannel_add_ValueSetReceived), METH_O, nullptr },
        { "remove_value_set_received", reinterpret_cast<PyCFunction>(RemoteSystemSessionMessageChannel_remove_ValueSetReceived), METH_O, nullptr },
        { "_assign_array_", _assign_array_RemoteSystemSessionMessageChannel, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_RemoteSystemSessionMessageChannel), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_RemoteSystemSessionMessageChannel[] = {
        { "session", reinterpret_cast<getter>(RemoteSystemSessionMessageChannel_get_Session), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_RemoteSystemSessionMessageChannel[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_RemoteSystemSessionMessageChannel) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_RemoteSystemSessionMessageChannel) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_RemoteSystemSessionMessageChannel) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_RemoteSystemSessionMessageChannel) },
        { }
    };

    static PyType_Spec type_spec_RemoteSystemSessionMessageChannel = {
        "winrt._winrt_windows_system_remotesystems.RemoteSystemSessionMessageChannel",
        sizeof(py::wrapper::Windows::System::RemoteSystems::RemoteSystemSessionMessageChannel),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RemoteSystemSessionMessageChannel};

    // ----- RemoteSystemSessionOptions class --------------------

    static PyObject* _new_RemoteSystemSessionOptions(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::System::RemoteSystems::RemoteSystemSessionOptions instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_RemoteSystemSessionOptions(py::wrapper::Windows::System::RemoteSystems::RemoteSystemSessionOptions* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* RemoteSystemSessionOptions_get_IsInviteOnly(py::wrapper::Windows::System::RemoteSystems::RemoteSystemSessionOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.RemoteSystems.RemoteSystemSessionOptions", L"IsInviteOnly");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsInviteOnly());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RemoteSystemSessionOptions_put_IsInviteOnly(py::wrapper::Windows::System::RemoteSystems::RemoteSystemSessionOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.RemoteSystems.RemoteSystemSessionOptions", L"IsInviteOnly");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsInviteOnly(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_RemoteSystemSessionOptions(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::System::RemoteSystems::RemoteSystemSessionOptions>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_RemoteSystemSessionOptions(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::RemoteSystems::RemoteSystemSessionOptions>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RemoteSystemSessionOptions[] = {
        { "_assign_array_", _assign_array_RemoteSystemSessionOptions, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_RemoteSystemSessionOptions), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_RemoteSystemSessionOptions[] = {
        { "is_invite_only", reinterpret_cast<getter>(RemoteSystemSessionOptions_get_IsInviteOnly), reinterpret_cast<setter>(RemoteSystemSessionOptions_put_IsInviteOnly), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_RemoteSystemSessionOptions[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_RemoteSystemSessionOptions) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_RemoteSystemSessionOptions) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_RemoteSystemSessionOptions) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_RemoteSystemSessionOptions) },
        { }
    };

    static PyType_Spec type_spec_RemoteSystemSessionOptions = {
        "winrt._winrt_windows_system_remotesystems.RemoteSystemSessionOptions",
        sizeof(py::wrapper::Windows::System::RemoteSystems::RemoteSystemSessionOptions),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RemoteSystemSessionOptions};

    // ----- RemoteSystemSessionParticipant class --------------------

    static PyObject* _new_RemoteSystemSessionParticipant(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::System::RemoteSystems::RemoteSystemSessionParticipant>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::System::RemoteSystems::RemoteSystemSessionParticipant>::type_name);
        return nullptr;
    }

    static void _dealloc_RemoteSystemSessionParticipant(py::wrapper::Windows::System::RemoteSystems::RemoteSystemSessionParticipant* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* RemoteSystemSessionParticipant_GetHostNames(py::wrapper::Windows::System::RemoteSystems::RemoteSystemSessionParticipant* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.RemoteSystems.RemoteSystemSessionParticipant", L"GetHostNames", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetHostNames());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RemoteSystemSessionParticipant_get_RemoteSystem(py::wrapper::Windows::System::RemoteSystems::RemoteSystemSessionParticipant* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.RemoteSystems.RemoteSystemSessionParticipant", L"RemoteSystem");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.RemoteSystem());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_RemoteSystemSessionParticipant(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::System::RemoteSystems::RemoteSystemSessionParticipant>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_RemoteSystemSessionParticipant(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::RemoteSystems::RemoteSystemSessionParticipant>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RemoteSystemSessionParticipant[] = {
        { "get_host_names", reinterpret_cast<PyCFunction>(RemoteSystemSessionParticipant_GetHostNames), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_RemoteSystemSessionParticipant, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_RemoteSystemSessionParticipant), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_RemoteSystemSessionParticipant[] = {
        { "remote_system", reinterpret_cast<getter>(RemoteSystemSessionParticipant_get_RemoteSystem), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_RemoteSystemSessionParticipant[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_RemoteSystemSessionParticipant) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_RemoteSystemSessionParticipant) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_RemoteSystemSessionParticipant) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_RemoteSystemSessionParticipant) },
        { }
    };

    static PyType_Spec type_spec_RemoteSystemSessionParticipant = {
        "winrt._winrt_windows_system_remotesystems.RemoteSystemSessionParticipant",
        sizeof(py::wrapper::Windows::System::RemoteSystems::RemoteSystemSessionParticipant),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RemoteSystemSessionParticipant};

    // ----- RemoteSystemSessionParticipantAddedEventArgs class --------------------

    static PyObject* _new_RemoteSystemSessionParticipantAddedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::System::RemoteSystems::RemoteSystemSessionParticipantAddedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::System::RemoteSystems::RemoteSystemSessionParticipantAddedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_RemoteSystemSessionParticipantAddedEventArgs(py::wrapper::Windows::System::RemoteSystems::RemoteSystemSessionParticipantAddedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* RemoteSystemSessionParticipantAddedEventArgs_get_Participant(py::wrapper::Windows::System::RemoteSystems::RemoteSystemSessionParticipantAddedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.RemoteSystems.RemoteSystemSessionParticipantAddedEventArgs", L"Participant");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Participant());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_RemoteSystemSessionParticipantAddedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::System::RemoteSystems::RemoteSystemSessionParticipantAddedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_RemoteSystemSessionParticipantAddedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::RemoteSystems::RemoteSystemSessionParticipantAddedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RemoteSystemSessionParticipantAddedEventArgs[] = {
        { "_assign_array_", _assign_array_RemoteSystemSessionParticipantAddedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_RemoteSystemSessionParticipantAddedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_RemoteSystemSessionParticipantAddedEventArgs[] = {
        { "participant", reinterpret_cast<getter>(RemoteSystemSessionParticipantAddedEventArgs_get_Participant), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_RemoteSystemSessionParticipantAddedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_RemoteSystemSessionParticipantAddedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_RemoteSystemSessionParticipantAddedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_RemoteSystemSessionParticipantAddedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_RemoteSystemSessionParticipantAddedEventArgs) },
        { }
    };

    static PyType_Spec type_spec_RemoteSystemSessionParticipantAddedEventArgs = {
        "winrt._winrt_windows_system_remotesystems.RemoteSystemSessionParticipantAddedEventArgs",
        sizeof(py::wrapper::Windows::System::RemoteSystems::RemoteSystemSessionParticipantAddedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RemoteSystemSessionParticipantAddedEventArgs};

    // ----- RemoteSystemSessionParticipantRemovedEventArgs class --------------------

    static PyObject* _new_RemoteSystemSessionParticipantRemovedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::System::RemoteSystems::RemoteSystemSessionParticipantRemovedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::System::RemoteSystems::RemoteSystemSessionParticipantRemovedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_RemoteSystemSessionParticipantRemovedEventArgs(py::wrapper::Windows::System::RemoteSystems::RemoteSystemSessionParticipantRemovedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* RemoteSystemSessionParticipantRemovedEventArgs_get_Participant(py::wrapper::Windows::System::RemoteSystems::RemoteSystemSessionParticipantRemovedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.RemoteSystems.RemoteSystemSessionParticipantRemovedEventArgs", L"Participant");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Participant());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_RemoteSystemSessionParticipantRemovedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::System::RemoteSystems::RemoteSystemSessionParticipantRemovedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_RemoteSystemSessionParticipantRemovedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::RemoteSystems::RemoteSystemSessionParticipantRemovedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RemoteSystemSessionParticipantRemovedEventArgs[] = {
        { "_assign_array_", _assign_array_RemoteSystemSessionParticipantRemovedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_RemoteSystemSessionParticipantRemovedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_RemoteSystemSessionParticipantRemovedEventArgs[] = {
        { "participant", reinterpret_cast<getter>(RemoteSystemSessionParticipantRemovedEventArgs_get_Participant), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_RemoteSystemSessionParticipantRemovedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_RemoteSystemSessionParticipantRemovedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_RemoteSystemSessionParticipantRemovedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_RemoteSystemSessionParticipantRemovedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_RemoteSystemSessionParticipantRemovedEventArgs) },
        { }
    };

    static PyType_Spec type_spec_RemoteSystemSessionParticipantRemovedEventArgs = {
        "winrt._winrt_windows_system_remotesystems.RemoteSystemSessionParticipantRemovedEventArgs",
        sizeof(py::wrapper::Windows::System::RemoteSystems::RemoteSystemSessionParticipantRemovedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RemoteSystemSessionParticipantRemovedEventArgs};

    // ----- RemoteSystemSessionParticipantWatcher class --------------------

    static PyObject* _new_RemoteSystemSessionParticipantWatcher(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::System::RemoteSystems::RemoteSystemSessionParticipantWatcher>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::System::RemoteSystems::RemoteSystemSessionParticipantWatcher>::type_name);
        return nullptr;
    }

    static void _dealloc_RemoteSystemSessionParticipantWatcher(py::wrapper::Windows::System::RemoteSystems::RemoteSystemSessionParticipantWatcher* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* RemoteSystemSessionParticipantWatcher_Start(py::wrapper::Windows::System::RemoteSystems::RemoteSystemSessionParticipantWatcher* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.RemoteSystems.RemoteSystemSessionParticipantWatcher", L"Start", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Start();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RemoteSystemSessionParticipantWatcher_Stop(py::wrapper::Windows::System::RemoteSystems::RemoteSystemSessionParticipantWatcher* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.RemoteSystems.RemoteSystemSessionParticipantWatcher", L"Stop", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Stop();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RemoteSystemSessionParticipantWatcher_get_Status(py::wrapper::Windows::System::RemoteSystems::RemoteSystemSessionParticipantWatcher* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.RemoteSystems.RemoteSystemSessionParticipantWatcher", L"Status");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RemoteSystemSessionParticipantWatcher_add_Added(py::wrapper::Windows::System::RemoteSystems::RemoteSystemSessionParticipantWatcher* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.System.RemoteSystems.RemoteSystemSessionParticipantWatcher", L"Added");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::System::RemoteSystems::RemoteSystemSessionParticipantWatcher, winrt::Windows::System::RemoteSystems::RemoteSystemSessionParticipantAddedEventArgs>>(arg);

            return py::convert(self->obj.Added(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RemoteSystemSessionParticipantWatcher_remove_Added(py::wrapper::Windows::System::RemoteSystems::RemoteSystemSessionParticipantWatcher* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.System.RemoteSystems.RemoteSystemSessionParticipantWatcher", L"Added");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Added(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RemoteSystemSessionParticipantWatcher_add_EnumerationCompleted(py::wrapper::Windows::System::RemoteSystems::RemoteSystemSessionParticipantWatcher* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.System.RemoteSystems.RemoteSystemSessionParticipantWatcher", L"EnumerationCompleted");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::System::RemoteSystems::RemoteSystemSessionParticipantWatcher, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.EnumerationCompleted(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RemoteSystemSessionParticipantWatcher_remove_EnumerationCompleted(py::wrapper::Windows::System::RemoteSystems::RemoteSystemSessionParticipantWatcher* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.System.RemoteSystems.RemoteSystemSessionParticipantWatcher", L"EnumerationCompleted");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.EnumerationCompleted(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RemoteSystemSessionParticipantWatcher_add_Removed(py::wrapper::Windows::System::RemoteSystems::RemoteSystemSessionParticipantWatcher* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.System.RemoteSystems.RemoteSystemSessionParticipantWatcher", L"Removed");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::System::RemoteSystems::RemoteSystemSessionParticipantWatcher, winrt::Windows::System::RemoteSystems::RemoteSystemSessionParticipantRemovedEventArgs>>(arg);

            return py::convert(self->obj.Removed(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RemoteSystemSessionParticipantWatcher_remove_Removed(py::wrapper::Windows::System::RemoteSystems::RemoteSystemSessionParticipantWatcher* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.System.RemoteSystems.RemoteSystemSessionParticipantWatcher", L"Removed");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Removed(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_RemoteSystemSessionParticipantWatcher(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::System::RemoteSystems::RemoteSystemSessionParticipantWatcher>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_RemoteSystemSessionParticipantWatcher(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::RemoteSystems::RemoteSystemSessionParticipantWatcher>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RemoteSystemSessionParticipantWatcher[] = {
        { "start", reinterpret_cast<PyCFunction>(RemoteSystemSessionParticipantWatcher_Start), METH_VARARGS, nullptr },
        { "stop", reinterpret_cast<PyCFunction>(RemoteSystemSessionParticipantWatcher_Stop), METH_VARARGS, nullptr },
        { "add_added", reinterpret_cast<PyCFunction>(RemoteSystemSessionParticipantWatcher_add_Added), METH_O, nullptr },
        { "remove_added", reinterpret_cast<PyCFunction>(RemoteSystemSessionParticipantWatcher_remove_Added), METH_O, nullptr },
        { "add_enumeration_completed", reinterpret_cast<PyCFunction>(RemoteSystemSessionParticipantWatcher_add_EnumerationCompleted), METH_O, nullptr },
        { "remove_enumeration_completed", reinterpret_cast<PyCFunction>(RemoteSystemSessionParticipantWatcher_remove_EnumerationCompleted), METH_O, nullptr },
        { "add_removed", reinterpret_cast<PyCFunction>(RemoteSystemSessionParticipantWatcher_add_Removed), METH_O, nullptr },
        { "remove_removed", reinterpret_cast<PyCFunction>(RemoteSystemSessionParticipantWatcher_remove_Removed), METH_O, nullptr },
        { "_assign_array_", _assign_array_RemoteSystemSessionParticipantWatcher, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_RemoteSystemSessionParticipantWatcher), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_RemoteSystemSessionParticipantWatcher[] = {
        { "status", reinterpret_cast<getter>(RemoteSystemSessionParticipantWatcher_get_Status), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_RemoteSystemSessionParticipantWatcher[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_RemoteSystemSessionParticipantWatcher) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_RemoteSystemSessionParticipantWatcher) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_RemoteSystemSessionParticipantWatcher) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_RemoteSystemSessionParticipantWatcher) },
        { }
    };

    static PyType_Spec type_spec_RemoteSystemSessionParticipantWatcher = {
        "winrt._winrt_windows_system_remotesystems.RemoteSystemSessionParticipantWatcher",
        sizeof(py::wrapper::Windows::System::RemoteSystems::RemoteSystemSessionParticipantWatcher),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RemoteSystemSessionParticipantWatcher};

    // ----- RemoteSystemSessionRemovedEventArgs class --------------------

    static PyObject* _new_RemoteSystemSessionRemovedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::System::RemoteSystems::RemoteSystemSessionRemovedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::System::RemoteSystems::RemoteSystemSessionRemovedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_RemoteSystemSessionRemovedEventArgs(py::wrapper::Windows::System::RemoteSystems::RemoteSystemSessionRemovedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* RemoteSystemSessionRemovedEventArgs_get_SessionInfo(py::wrapper::Windows::System::RemoteSystems::RemoteSystemSessionRemovedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.RemoteSystems.RemoteSystemSessionRemovedEventArgs", L"SessionInfo");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SessionInfo());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_RemoteSystemSessionRemovedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::System::RemoteSystems::RemoteSystemSessionRemovedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_RemoteSystemSessionRemovedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::RemoteSystems::RemoteSystemSessionRemovedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RemoteSystemSessionRemovedEventArgs[] = {
        { "_assign_array_", _assign_array_RemoteSystemSessionRemovedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_RemoteSystemSessionRemovedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_RemoteSystemSessionRemovedEventArgs[] = {
        { "session_info", reinterpret_cast<getter>(RemoteSystemSessionRemovedEventArgs_get_SessionInfo), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_RemoteSystemSessionRemovedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_RemoteSystemSessionRemovedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_RemoteSystemSessionRemovedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_RemoteSystemSessionRemovedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_RemoteSystemSessionRemovedEventArgs) },
        { }
    };

    static PyType_Spec type_spec_RemoteSystemSessionRemovedEventArgs = {
        "winrt._winrt_windows_system_remotesystems.RemoteSystemSessionRemovedEventArgs",
        sizeof(py::wrapper::Windows::System::RemoteSystems::RemoteSystemSessionRemovedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RemoteSystemSessionRemovedEventArgs};

    // ----- RemoteSystemSessionUpdatedEventArgs class --------------------

    static PyObject* _new_RemoteSystemSessionUpdatedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::System::RemoteSystems::RemoteSystemSessionUpdatedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::System::RemoteSystems::RemoteSystemSessionUpdatedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_RemoteSystemSessionUpdatedEventArgs(py::wrapper::Windows::System::RemoteSystems::RemoteSystemSessionUpdatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* RemoteSystemSessionUpdatedEventArgs_get_SessionInfo(py::wrapper::Windows::System::RemoteSystems::RemoteSystemSessionUpdatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.RemoteSystems.RemoteSystemSessionUpdatedEventArgs", L"SessionInfo");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SessionInfo());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_RemoteSystemSessionUpdatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::System::RemoteSystems::RemoteSystemSessionUpdatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_RemoteSystemSessionUpdatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::RemoteSystems::RemoteSystemSessionUpdatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RemoteSystemSessionUpdatedEventArgs[] = {
        { "_assign_array_", _assign_array_RemoteSystemSessionUpdatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_RemoteSystemSessionUpdatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_RemoteSystemSessionUpdatedEventArgs[] = {
        { "session_info", reinterpret_cast<getter>(RemoteSystemSessionUpdatedEventArgs_get_SessionInfo), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_RemoteSystemSessionUpdatedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_RemoteSystemSessionUpdatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_RemoteSystemSessionUpdatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_RemoteSystemSessionUpdatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_RemoteSystemSessionUpdatedEventArgs) },
        { }
    };

    static PyType_Spec type_spec_RemoteSystemSessionUpdatedEventArgs = {
        "winrt._winrt_windows_system_remotesystems.RemoteSystemSessionUpdatedEventArgs",
        sizeof(py::wrapper::Windows::System::RemoteSystems::RemoteSystemSessionUpdatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RemoteSystemSessionUpdatedEventArgs};

    // ----- RemoteSystemSessionValueSetReceivedEventArgs class --------------------

    static PyObject* _new_RemoteSystemSessionValueSetReceivedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::System::RemoteSystems::RemoteSystemSessionValueSetReceivedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::System::RemoteSystems::RemoteSystemSessionValueSetReceivedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_RemoteSystemSessionValueSetReceivedEventArgs(py::wrapper::Windows::System::RemoteSystems::RemoteSystemSessionValueSetReceivedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* RemoteSystemSessionValueSetReceivedEventArgs_get_Message(py::wrapper::Windows::System::RemoteSystems::RemoteSystemSessionValueSetReceivedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.RemoteSystems.RemoteSystemSessionValueSetReceivedEventArgs", L"Message");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Message());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RemoteSystemSessionValueSetReceivedEventArgs_get_Sender(py::wrapper::Windows::System::RemoteSystems::RemoteSystemSessionValueSetReceivedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.RemoteSystems.RemoteSystemSessionValueSetReceivedEventArgs", L"Sender");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Sender());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_RemoteSystemSessionValueSetReceivedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::System::RemoteSystems::RemoteSystemSessionValueSetReceivedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_RemoteSystemSessionValueSetReceivedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::RemoteSystems::RemoteSystemSessionValueSetReceivedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RemoteSystemSessionValueSetReceivedEventArgs[] = {
        { "_assign_array_", _assign_array_RemoteSystemSessionValueSetReceivedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_RemoteSystemSessionValueSetReceivedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_RemoteSystemSessionValueSetReceivedEventArgs[] = {
        { "message", reinterpret_cast<getter>(RemoteSystemSessionValueSetReceivedEventArgs_get_Message), nullptr, nullptr, nullptr },
        { "sender", reinterpret_cast<getter>(RemoteSystemSessionValueSetReceivedEventArgs_get_Sender), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_RemoteSystemSessionValueSetReceivedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_RemoteSystemSessionValueSetReceivedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_RemoteSystemSessionValueSetReceivedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_RemoteSystemSessionValueSetReceivedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_RemoteSystemSessionValueSetReceivedEventArgs) },
        { }
    };

    static PyType_Spec type_spec_RemoteSystemSessionValueSetReceivedEventArgs = {
        "winrt._winrt_windows_system_remotesystems.RemoteSystemSessionValueSetReceivedEventArgs",
        sizeof(py::wrapper::Windows::System::RemoteSystems::RemoteSystemSessionValueSetReceivedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RemoteSystemSessionValueSetReceivedEventArgs};

    // ----- RemoteSystemSessionWatcher class --------------------

    static PyObject* _new_RemoteSystemSessionWatcher(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::System::RemoteSystems::RemoteSystemSessionWatcher>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::System::RemoteSystems::RemoteSystemSessionWatcher>::type_name);
        return nullptr;
    }

    static void _dealloc_RemoteSystemSessionWatcher(py::wrapper::Windows::System::RemoteSystems::RemoteSystemSessionWatcher* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* RemoteSystemSessionWatcher_Start(py::wrapper::Windows::System::RemoteSystems::RemoteSystemSessionWatcher* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.RemoteSystems.RemoteSystemSessionWatcher", L"Start", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Start();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RemoteSystemSessionWatcher_Stop(py::wrapper::Windows::System::RemoteSystems::RemoteSystemSessionWatcher* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.RemoteSystems.RemoteSystemSessionWatcher", L"Stop", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Stop();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RemoteSystemSessionWatcher_get_Status(py::wrapper::Windows::System::RemoteSystems::RemoteSystemSessionWatcher* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.RemoteSystems.RemoteSystemSessionWatcher", L"Status");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RemoteSystemSessionWatcher_add_Added(py::wrapper::Windows::System::RemoteSystems::RemoteSystemSessionWatcher* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.System.RemoteSystems.RemoteSystemSessionWatcher", L"Added");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::System::RemoteSystems::RemoteSystemSessionWatcher, winrt::Windows::System::RemoteSystems::RemoteSystemSessionAddedEventArgs>>(arg);

            return py::convert(self->obj.Added(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RemoteSystemSessionWatcher_remove_Added(py::wrapper::Windows::System::RemoteSystems::RemoteSystemSessionWatcher* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.System.RemoteSystems.RemoteSystemSessionWatcher", L"Added");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Added(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RemoteSystemSessionWatcher_add_Removed(py::wrapper::Windows::System::RemoteSystems::RemoteSystemSessionWatcher* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.System.RemoteSystems.RemoteSystemSessionWatcher", L"Removed");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::System::RemoteSystems::RemoteSystemSessionWatcher, winrt::Windows::System::RemoteSystems::RemoteSystemSessionRemovedEventArgs>>(arg);

            return py::convert(self->obj.Removed(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RemoteSystemSessionWatcher_remove_Removed(py::wrapper::Windows::System::RemoteSystems::RemoteSystemSessionWatcher* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.System.RemoteSystems.RemoteSystemSessionWatcher", L"Removed");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Removed(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RemoteSystemSessionWatcher_add_Updated(py::wrapper::Windows::System::RemoteSystems::RemoteSystemSessionWatcher* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.System.RemoteSystems.RemoteSystemSessionWatcher", L"Updated");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::System::RemoteSystems::RemoteSystemSessionWatcher, winrt::Windows::System::RemoteSystems::RemoteSystemSessionUpdatedEventArgs>>(arg);

            return py::convert(self->obj.Updated(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RemoteSystemSessionWatcher_remove_Updated(py::wrapper::Windows::System::RemoteSystems::RemoteSystemSessionWatcher* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.System.RemoteSystems.RemoteSystemSessionWatcher", L"Updated");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Updated(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_RemoteSystemSessionWatcher(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::System::RemoteSystems::RemoteSystemSessionWatcher>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_RemoteSystemSessionWatcher(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::RemoteSystems::RemoteSystemSessionWatcher>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RemoteSystemSessionWatcher[] = {
        { "start", reinterpret_cast<PyCFunction>(RemoteSystemSessionWatcher_Start), METH_VARARGS, nullptr },
        { "stop", reinterpret_cast<PyCFunction>(RemoteSystemSessionWatcher_Stop), METH_VARARGS, nullptr },
        { "add_added", reinterpret_cast<PyCFunction>(RemoteSystemSessionWatcher_add_Added), METH_O, nullptr },
        { "remove_added", reinterpret_cast<PyCFunction>(RemoteSystemSessionWatcher_remove_Added), METH_O, nullptr },
        { "add_removed", reinterpret_cast<PyCFunction>(RemoteSystemSessionWatcher_add_Removed), METH_O, nullptr },
        { "remove_removed", reinterpret_cast<PyCFunction>(RemoteSystemSessionWatcher_remove_Removed), METH_O, nullptr },
        { "add_updated", reinterpret_cast<PyCFunction>(RemoteSystemSessionWatcher_add_Updated), METH_O, nullptr },
        { "remove_updated", reinterpret_cast<PyCFunction>(RemoteSystemSessionWatcher_remove_Updated), METH_O, nullptr },
        { "_assign_array_", _assign_array_RemoteSystemSessionWatcher, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_RemoteSystemSessionWatcher), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_RemoteSystemSessionWatcher[] = {
        { "status", reinterpret_cast<getter>(RemoteSystemSessionWatcher_get_Status), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_RemoteSystemSessionWatcher[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_RemoteSystemSessionWatcher) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_RemoteSystemSessionWatcher) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_RemoteSystemSessionWatcher) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_RemoteSystemSessionWatcher) },
        { }
    };

    static PyType_Spec type_spec_RemoteSystemSessionWatcher = {
        "winrt._winrt_windows_system_remotesystems.RemoteSystemSessionWatcher",
        sizeof(py::wrapper::Windows::System::RemoteSystems::RemoteSystemSessionWatcher),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RemoteSystemSessionWatcher};

    // ----- RemoteSystemStatusTypeFilter class --------------------

    static PyObject* _new_RemoteSystemStatusTypeFilter(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::System::RemoteSystems::RemoteSystemStatusType>(args, 0);

                winrt::Windows::System::RemoteSystems::RemoteSystemStatusTypeFilter instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_RemoteSystemStatusTypeFilter(py::wrapper::Windows::System::RemoteSystems::RemoteSystemStatusTypeFilter* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* RemoteSystemStatusTypeFilter_get_RemoteSystemStatusType(py::wrapper::Windows::System::RemoteSystems::RemoteSystemStatusTypeFilter* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.RemoteSystems.RemoteSystemStatusTypeFilter", L"RemoteSystemStatusType");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.RemoteSystemStatusType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_RemoteSystemStatusTypeFilter(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::System::RemoteSystems::RemoteSystemStatusTypeFilter>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_RemoteSystemStatusTypeFilter(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::RemoteSystems::RemoteSystemStatusTypeFilter>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RemoteSystemStatusTypeFilter[] = {
        { "_assign_array_", _assign_array_RemoteSystemStatusTypeFilter, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_RemoteSystemStatusTypeFilter), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_RemoteSystemStatusTypeFilter[] = {
        { "remote_system_status_type", reinterpret_cast<getter>(RemoteSystemStatusTypeFilter_get_RemoteSystemStatusType), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_RemoteSystemStatusTypeFilter[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_RemoteSystemStatusTypeFilter) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_RemoteSystemStatusTypeFilter) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_RemoteSystemStatusTypeFilter) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_RemoteSystemStatusTypeFilter) },
        { }
    };

    static PyType_Spec type_spec_RemoteSystemStatusTypeFilter = {
        "winrt._winrt_windows_system_remotesystems.RemoteSystemStatusTypeFilter",
        sizeof(py::wrapper::Windows::System::RemoteSystems::RemoteSystemStatusTypeFilter),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RemoteSystemStatusTypeFilter};

    // ----- RemoteSystemUpdatedEventArgs class --------------------

    static PyObject* _new_RemoteSystemUpdatedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::System::RemoteSystems::RemoteSystemUpdatedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::System::RemoteSystems::RemoteSystemUpdatedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_RemoteSystemUpdatedEventArgs(py::wrapper::Windows::System::RemoteSystems::RemoteSystemUpdatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* RemoteSystemUpdatedEventArgs_get_RemoteSystem(py::wrapper::Windows::System::RemoteSystems::RemoteSystemUpdatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.RemoteSystems.RemoteSystemUpdatedEventArgs", L"RemoteSystem");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.RemoteSystem());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_RemoteSystemUpdatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::System::RemoteSystems::RemoteSystemUpdatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_RemoteSystemUpdatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::RemoteSystems::RemoteSystemUpdatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RemoteSystemUpdatedEventArgs[] = {
        { "_assign_array_", _assign_array_RemoteSystemUpdatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_RemoteSystemUpdatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_RemoteSystemUpdatedEventArgs[] = {
        { "remote_system", reinterpret_cast<getter>(RemoteSystemUpdatedEventArgs_get_RemoteSystem), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_RemoteSystemUpdatedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_RemoteSystemUpdatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_RemoteSystemUpdatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_RemoteSystemUpdatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_RemoteSystemUpdatedEventArgs) },
        { }
    };

    static PyType_Spec type_spec_RemoteSystemUpdatedEventArgs = {
        "winrt._winrt_windows_system_remotesystems.RemoteSystemUpdatedEventArgs",
        sizeof(py::wrapper::Windows::System::RemoteSystems::RemoteSystemUpdatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RemoteSystemUpdatedEventArgs};

    // ----- RemoteSystemWatcher class --------------------

    static PyObject* _new_RemoteSystemWatcher(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::System::RemoteSystems::RemoteSystemWatcher>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::System::RemoteSystems::RemoteSystemWatcher>::type_name);
        return nullptr;
    }

    static void _dealloc_RemoteSystemWatcher(py::wrapper::Windows::System::RemoteSystems::RemoteSystemWatcher* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* RemoteSystemWatcher_Start(py::wrapper::Windows::System::RemoteSystems::RemoteSystemWatcher* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.RemoteSystems.RemoteSystemWatcher", L"Start", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Start();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RemoteSystemWatcher_Stop(py::wrapper::Windows::System::RemoteSystems::RemoteSystemWatcher* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.RemoteSystems.RemoteSystemWatcher", L"Stop", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Stop();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RemoteSystemWatcher_get_User(py::wrapper::Windows::System::RemoteSystems::RemoteSystemWatcher* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.RemoteSystems.RemoteSystemWatcher", L"User");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.User());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RemoteSystemWatcher_add_RemoteSystemAdded(py::wrapper::Windows::System::RemoteSystems::RemoteSystemWatcher* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.System.RemoteSystems.RemoteSystemWatcher", L"RemoteSystemAdded");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::System::RemoteSystems::RemoteSystemWatcher, winrt::Windows::System::RemoteSystems::RemoteSystemAddedEventArgs>>(arg);

            return py::convert(self->obj.RemoteSystemAdded(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RemoteSystemWatcher_remove_RemoteSystemAdded(py::wrapper::Windows::System::RemoteSystems::RemoteSystemWatcher* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.System.RemoteSystems.RemoteSystemWatcher", L"RemoteSystemAdded");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.RemoteSystemAdded(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RemoteSystemWatcher_add_RemoteSystemRemoved(py::wrapper::Windows::System::RemoteSystems::RemoteSystemWatcher* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.System.RemoteSystems.RemoteSystemWatcher", L"RemoteSystemRemoved");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::System::RemoteSystems::RemoteSystemWatcher, winrt::Windows::System::RemoteSystems::RemoteSystemRemovedEventArgs>>(arg);

            return py::convert(self->obj.RemoteSystemRemoved(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RemoteSystemWatcher_remove_RemoteSystemRemoved(py::wrapper::Windows::System::RemoteSystems::RemoteSystemWatcher* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.System.RemoteSystems.RemoteSystemWatcher", L"RemoteSystemRemoved");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.RemoteSystemRemoved(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RemoteSystemWatcher_add_RemoteSystemUpdated(py::wrapper::Windows::System::RemoteSystems::RemoteSystemWatcher* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.System.RemoteSystems.RemoteSystemWatcher", L"RemoteSystemUpdated");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::System::RemoteSystems::RemoteSystemWatcher, winrt::Windows::System::RemoteSystems::RemoteSystemUpdatedEventArgs>>(arg);

            return py::convert(self->obj.RemoteSystemUpdated(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RemoteSystemWatcher_remove_RemoteSystemUpdated(py::wrapper::Windows::System::RemoteSystems::RemoteSystemWatcher* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.System.RemoteSystems.RemoteSystemWatcher", L"RemoteSystemUpdated");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.RemoteSystemUpdated(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RemoteSystemWatcher_add_EnumerationCompleted(py::wrapper::Windows::System::RemoteSystems::RemoteSystemWatcher* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.System.RemoteSystems.RemoteSystemWatcher", L"EnumerationCompleted");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::System::RemoteSystems::RemoteSystemWatcher, winrt::Windows::System::RemoteSystems::RemoteSystemEnumerationCompletedEventArgs>>(arg);

            return py::convert(self->obj.EnumerationCompleted(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RemoteSystemWatcher_remove_EnumerationCompleted(py::wrapper::Windows::System::RemoteSystems::RemoteSystemWatcher* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.System.RemoteSystems.RemoteSystemWatcher", L"EnumerationCompleted");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.EnumerationCompleted(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RemoteSystemWatcher_add_ErrorOccurred(py::wrapper::Windows::System::RemoteSystems::RemoteSystemWatcher* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.System.RemoteSystems.RemoteSystemWatcher", L"ErrorOccurred");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::System::RemoteSystems::RemoteSystemWatcher, winrt::Windows::System::RemoteSystems::RemoteSystemWatcherErrorOccurredEventArgs>>(arg);

            return py::convert(self->obj.ErrorOccurred(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RemoteSystemWatcher_remove_ErrorOccurred(py::wrapper::Windows::System::RemoteSystems::RemoteSystemWatcher* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.System.RemoteSystems.RemoteSystemWatcher", L"ErrorOccurred");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ErrorOccurred(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_RemoteSystemWatcher(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::System::RemoteSystems::RemoteSystemWatcher>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_RemoteSystemWatcher(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::RemoteSystems::RemoteSystemWatcher>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RemoteSystemWatcher[] = {
        { "start", reinterpret_cast<PyCFunction>(RemoteSystemWatcher_Start), METH_VARARGS, nullptr },
        { "stop", reinterpret_cast<PyCFunction>(RemoteSystemWatcher_Stop), METH_VARARGS, nullptr },
        { "add_remote_system_added", reinterpret_cast<PyCFunction>(RemoteSystemWatcher_add_RemoteSystemAdded), METH_O, nullptr },
        { "remove_remote_system_added", reinterpret_cast<PyCFunction>(RemoteSystemWatcher_remove_RemoteSystemAdded), METH_O, nullptr },
        { "add_remote_system_removed", reinterpret_cast<PyCFunction>(RemoteSystemWatcher_add_RemoteSystemRemoved), METH_O, nullptr },
        { "remove_remote_system_removed", reinterpret_cast<PyCFunction>(RemoteSystemWatcher_remove_RemoteSystemRemoved), METH_O, nullptr },
        { "add_remote_system_updated", reinterpret_cast<PyCFunction>(RemoteSystemWatcher_add_RemoteSystemUpdated), METH_O, nullptr },
        { "remove_remote_system_updated", reinterpret_cast<PyCFunction>(RemoteSystemWatcher_remove_RemoteSystemUpdated), METH_O, nullptr },
        { "add_enumeration_completed", reinterpret_cast<PyCFunction>(RemoteSystemWatcher_add_EnumerationCompleted), METH_O, nullptr },
        { "remove_enumeration_completed", reinterpret_cast<PyCFunction>(RemoteSystemWatcher_remove_EnumerationCompleted), METH_O, nullptr },
        { "add_error_occurred", reinterpret_cast<PyCFunction>(RemoteSystemWatcher_add_ErrorOccurred), METH_O, nullptr },
        { "remove_error_occurred", reinterpret_cast<PyCFunction>(RemoteSystemWatcher_remove_ErrorOccurred), METH_O, nullptr },
        { "_assign_array_", _assign_array_RemoteSystemWatcher, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_RemoteSystemWatcher), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_RemoteSystemWatcher[] = {
        { "user", reinterpret_cast<getter>(RemoteSystemWatcher_get_User), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_RemoteSystemWatcher[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_RemoteSystemWatcher) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_RemoteSystemWatcher) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_RemoteSystemWatcher) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_RemoteSystemWatcher) },
        { }
    };

    static PyType_Spec type_spec_RemoteSystemWatcher = {
        "winrt._winrt_windows_system_remotesystems.RemoteSystemWatcher",
        sizeof(py::wrapper::Windows::System::RemoteSystems::RemoteSystemWatcher),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RemoteSystemWatcher};

    // ----- RemoteSystemWatcherErrorOccurredEventArgs class --------------------

    static PyObject* _new_RemoteSystemWatcherErrorOccurredEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::System::RemoteSystems::RemoteSystemWatcherErrorOccurredEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::System::RemoteSystems::RemoteSystemWatcherErrorOccurredEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_RemoteSystemWatcherErrorOccurredEventArgs(py::wrapper::Windows::System::RemoteSystems::RemoteSystemWatcherErrorOccurredEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* RemoteSystemWatcherErrorOccurredEventArgs_get_Error(py::wrapper::Windows::System::RemoteSystems::RemoteSystemWatcherErrorOccurredEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.RemoteSystems.RemoteSystemWatcherErrorOccurredEventArgs", L"Error");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Error());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_RemoteSystemWatcherErrorOccurredEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::System::RemoteSystems::RemoteSystemWatcherErrorOccurredEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_RemoteSystemWatcherErrorOccurredEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::RemoteSystems::RemoteSystemWatcherErrorOccurredEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RemoteSystemWatcherErrorOccurredEventArgs[] = {
        { "_assign_array_", _assign_array_RemoteSystemWatcherErrorOccurredEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_RemoteSystemWatcherErrorOccurredEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_RemoteSystemWatcherErrorOccurredEventArgs[] = {
        { "error", reinterpret_cast<getter>(RemoteSystemWatcherErrorOccurredEventArgs_get_Error), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_RemoteSystemWatcherErrorOccurredEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_RemoteSystemWatcherErrorOccurredEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_RemoteSystemWatcherErrorOccurredEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_RemoteSystemWatcherErrorOccurredEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_RemoteSystemWatcherErrorOccurredEventArgs) },
        { }
    };

    static PyType_Spec type_spec_RemoteSystemWatcherErrorOccurredEventArgs = {
        "winrt._winrt_windows_system_remotesystems.RemoteSystemWatcherErrorOccurredEventArgs",
        sizeof(py::wrapper::Windows::System::RemoteSystems::RemoteSystemWatcherErrorOccurredEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RemoteSystemWatcherErrorOccurredEventArgs};

    // ----- RemoteSystemWebAccountFilter class --------------------

    static PyObject* _new_RemoteSystemWebAccountFilter(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Security::Credentials::WebAccount>(args, 0);

                winrt::Windows::System::RemoteSystems::RemoteSystemWebAccountFilter instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_RemoteSystemWebAccountFilter(py::wrapper::Windows::System::RemoteSystems::RemoteSystemWebAccountFilter* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* RemoteSystemWebAccountFilter_get_Account(py::wrapper::Windows::System::RemoteSystems::RemoteSystemWebAccountFilter* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.RemoteSystems.RemoteSystemWebAccountFilter", L"Account");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Account());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_RemoteSystemWebAccountFilter(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::System::RemoteSystems::RemoteSystemWebAccountFilter>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_RemoteSystemWebAccountFilter(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::RemoteSystems::RemoteSystemWebAccountFilter>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RemoteSystemWebAccountFilter[] = {
        { "_assign_array_", _assign_array_RemoteSystemWebAccountFilter, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_RemoteSystemWebAccountFilter), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_RemoteSystemWebAccountFilter[] = {
        { "account", reinterpret_cast<getter>(RemoteSystemWebAccountFilter_get_Account), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_RemoteSystemWebAccountFilter[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_RemoteSystemWebAccountFilter) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_RemoteSystemWebAccountFilter) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_RemoteSystemWebAccountFilter) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_RemoteSystemWebAccountFilter) },
        { }
    };

    static PyType_Spec type_spec_RemoteSystemWebAccountFilter = {
        "winrt._winrt_windows_system_remotesystems.RemoteSystemWebAccountFilter",
        sizeof(py::wrapper::Windows::System::RemoteSystems::RemoteSystemWebAccountFilter),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RemoteSystemWebAccountFilter};

    // ----- IRemoteSystemFilter interface --------------------

    static PyObject* _new_IRemoteSystemFilter(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::System::RemoteSystems::IRemoteSystemFilter>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::System::RemoteSystems::IRemoteSystemFilter>::type_name);
        return nullptr;
    }

    static void _dealloc_IRemoteSystemFilter(py::wrapper::Windows::System::RemoteSystems::IRemoteSystemFilter* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_IRemoteSystemFilter(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::System::RemoteSystems::IRemoteSystemFilter>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IRemoteSystemFilter(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::RemoteSystems::IRemoteSystemFilter>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IRemoteSystemFilter[] = {
        { "_assign_array_", _assign_array_IRemoteSystemFilter, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IRemoteSystemFilter), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IRemoteSystemFilter[] = {
        { }
    };

    static PyType_Slot _type_slots_IRemoteSystemFilter[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_IRemoteSystemFilter) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IRemoteSystemFilter) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IRemoteSystemFilter) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IRemoteSystemFilter) },
        { }
    };

    static PyType_Spec type_spec_IRemoteSystemFilter = {
        "winrt._winrt_windows_system_remotesystems.IRemoteSystemFilter",
        sizeof(py::wrapper::Windows::System::RemoteSystems::IRemoteSystemFilter),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IRemoteSystemFilter};

    // ----- Windows.System.RemoteSystems Initialization --------------------

    PyDoc_STRVAR(module_doc, "Windows.System.RemoteSystems");

    static PyModuleDef module_def = {
        PyModuleDef_HEAD_INIT,
        "_winrt_windows_system_remotesystems",
        module_doc,
        0,
        nullptr,
        nullptr,
        nullptr,
        nullptr,
        nullptr};
} // py::cpp::Windows::System::RemoteSystems

PyMODINIT_FUNC PyInit__winrt_windows_system_remotesystems(void) noexcept
{
    using namespace py::cpp::Windows::System::RemoteSystems;

    if (py::import_winrt_runtime() == -1)
    {
        return nullptr;
    }

    py::pyobj_handle module{PyModule_Create(&module_def)};

    if (!module)
    {
        return nullptr;
    }

    auto object_type = py::get_object_type();
    if (!object_type)
    {
        return nullptr;
    }

    py::pyobj_handle object_bases{PyTuple_Pack(1, object_type)};

    if (!object_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_KnownRemoteSystemCapabilities_Static{PyType_FromSpec(&type_spec_KnownRemoteSystemCapabilities_Static)};
    if (!type_KnownRemoteSystemCapabilities_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_KnownRemoteSystemCapabilities, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_KnownRemoteSystemCapabilities_Static.get())) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_RemoteSystem_Static{PyType_FromSpec(&type_spec_RemoteSystem_Static)};
    if (!type_RemoteSystem_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_RemoteSystem, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_RemoteSystem_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_RemoteSystemAddedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_RemoteSystemApp, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_RemoteSystemAppRegistration_Static{PyType_FromSpec(&type_spec_RemoteSystemAppRegistration_Static)};
    if (!type_RemoteSystemAppRegistration_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_RemoteSystemAppRegistration, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_RemoteSystemAppRegistration_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_RemoteSystemAuthorizationKindFilter, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_RemoteSystemConnectionInfo_Static{PyType_FromSpec(&type_spec_RemoteSystemConnectionInfo_Static)};
    if (!type_RemoteSystemConnectionInfo_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_RemoteSystemConnectionInfo, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_RemoteSystemConnectionInfo_Static.get())) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_RemoteSystemConnectionRequest_Static{PyType_FromSpec(&type_spec_RemoteSystemConnectionRequest_Static)};
    if (!type_RemoteSystemConnectionRequest_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_RemoteSystemConnectionRequest, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_RemoteSystemConnectionRequest_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_RemoteSystemDiscoveryTypeFilter, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_RemoteSystemEnumerationCompletedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_RemoteSystemKindFilter, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_RemoteSystemKinds_Static{PyType_FromSpec(&type_spec_RemoteSystemKinds_Static)};
    if (!type_RemoteSystemKinds_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_RemoteSystemKinds, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_RemoteSystemKinds_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_RemoteSystemRemovedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_RemoteSystemSession_Static{PyType_FromSpec(&type_spec_RemoteSystemSession_Static)};
    if (!type_RemoteSystemSession_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_RemoteSystemSession, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_RemoteSystemSession_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_RemoteSystemSessionAddedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_RemoteSystemSessionController, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_RemoteSystemSessionCreationResult, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_RemoteSystemSessionDisconnectedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_RemoteSystemSessionInfo, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_RemoteSystemSessionInvitation, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_RemoteSystemSessionInvitationListener, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_RemoteSystemSessionInvitationReceivedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_RemoteSystemSessionJoinRequest, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_RemoteSystemSessionJoinRequestedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_RemoteSystemSessionJoinResult, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_RemoteSystemSessionMessageChannel, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_RemoteSystemSessionOptions, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_RemoteSystemSessionParticipant, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_RemoteSystemSessionParticipantAddedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_RemoteSystemSessionParticipantRemovedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_RemoteSystemSessionParticipantWatcher, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_RemoteSystemSessionRemovedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_RemoteSystemSessionUpdatedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_RemoteSystemSessionValueSetReceivedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_RemoteSystemSessionWatcher, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_RemoteSystemStatusTypeFilter, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_RemoteSystemUpdatedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_RemoteSystemWatcher, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_RemoteSystemWatcherErrorOccurredEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_RemoteSystemWebAccountFilter, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_IRemoteSystemFilter, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }


    return module.detach();
}
