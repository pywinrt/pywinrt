# WARNING: Please don't edit this file. It was generated by Python/WinRT v2.0.0-beta.2

import datetime
import sys
import types
import typing
import uuid as _uuid
from builtins import property as _property

import winrt._winrt
import winrt.system
import winrt.windows.foundation
import winrt.windows.foundation.collections
import winrt.windows.foundation.numerics
import winrt.windows.perception
import winrt.windows.storage.streams
import winrt.windows.system.remotesystems

from winrt.windows.perception.spatial import SpatialAnchorExportPurpose, SpatialEntityWatcherStatus, SpatialLocatability, SpatialLookDirectionRange, SpatialMovementRange, SpatialPerceptionAccessStatus

Self = typing.TypeVar('Self')

@typing.final
class SpatialBoundingBox:
    center: winrt.windows.foundation.numerics.Vector3
    extents: winrt.windows.foundation.numerics.Vector3
    def __init__(self, center: winrt.windows.foundation.numerics.Vector3, extents: winrt.windows.foundation.numerics.Vector3) -> None: ...

@typing.final
class SpatialBoundingFrustum:
    near: winrt.windows.foundation.numerics.Plane
    far: winrt.windows.foundation.numerics.Plane
    right: winrt.windows.foundation.numerics.Plane
    left: winrt.windows.foundation.numerics.Plane
    top: winrt.windows.foundation.numerics.Plane
    bottom: winrt.windows.foundation.numerics.Plane
    def __init__(self, near: winrt.windows.foundation.numerics.Plane, far: winrt.windows.foundation.numerics.Plane, right: winrt.windows.foundation.numerics.Plane, left: winrt.windows.foundation.numerics.Plane, top: winrt.windows.foundation.numerics.Plane, bottom: winrt.windows.foundation.numerics.Plane) -> None: ...

@typing.final
class SpatialBoundingOrientedBox:
    center: winrt.windows.foundation.numerics.Vector3
    extents: winrt.windows.foundation.numerics.Vector3
    orientation: winrt.windows.foundation.numerics.Quaternion
    def __init__(self, center: winrt.windows.foundation.numerics.Vector3, extents: winrt.windows.foundation.numerics.Vector3, orientation: winrt.windows.foundation.numerics.Quaternion) -> None: ...

@typing.final
class SpatialBoundingSphere:
    center: winrt.windows.foundation.numerics.Vector3
    radius: winrt.system.Single
    def __init__(self, center: winrt.windows.foundation.numerics.Vector3, radius: winrt.system.Single) -> None: ...

@typing.final
class SpatialRay:
    origin: winrt.windows.foundation.numerics.Vector3
    direction: winrt.windows.foundation.numerics.Vector3
    def __init__(self, origin: winrt.windows.foundation.numerics.Vector3, direction: winrt.windows.foundation.numerics.Vector3) -> None: ...

@typing.final
class SpatialAnchor_Static(type):
    @typing.overload
    def try_create_relative_to(cls, coordinate_system: typing.Optional[SpatialCoordinateSystem], /) -> typing.Optional[SpatialAnchor]: ...
    @typing.overload
    def try_create_relative_to(cls, coordinate_system: typing.Optional[SpatialCoordinateSystem], position: winrt.windows.foundation.numerics.Vector3, /) -> typing.Optional[SpatialAnchor]: ...
    @typing.overload
    def try_create_relative_to(cls, coordinate_system: typing.Optional[SpatialCoordinateSystem], position: winrt.windows.foundation.numerics.Vector3, orientation: winrt.windows.foundation.numerics.Quaternion, /) -> typing.Optional[SpatialAnchor]: ...

@typing.final
class SpatialAnchor(winrt.system.Object, metaclass=SpatialAnchor_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> SpatialAnchor: ...
    def add_raw_coordinate_system_adjusted(self, handler: winrt.windows.foundation.TypedEventHandler[SpatialAnchor, SpatialAnchorRawCoordinateSystemAdjustedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_raw_coordinate_system_adjusted(self, cookie: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    @_property
    def coordinate_system(self) -> typing.Optional[SpatialCoordinateSystem]: ...
    @_property
    def raw_coordinate_system(self) -> typing.Optional[SpatialCoordinateSystem]: ...
    @_property
    def removed_by_user(self) -> bool: ...

@typing.final
class SpatialAnchorExportSufficiency(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> SpatialAnchorExportSufficiency: ...
    @_property
    def is_minimally_sufficient(self) -> bool: ...
    @_property
    def recommended_sufficiency_level(self) -> winrt.system.Double: ...
    @_property
    def sufficiency_level(self) -> winrt.system.Double: ...

@typing.final
class SpatialAnchorExporter_Static(type):
    def get_default(cls) -> typing.Optional[SpatialAnchorExporter]: ...
    def request_access_async(cls) -> winrt.windows.foundation.IAsyncOperation[SpatialPerceptionAccessStatus]: ...

@typing.final
class SpatialAnchorExporter(winrt.system.Object, metaclass=SpatialAnchorExporter_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> SpatialAnchorExporter: ...
    def get_anchor_export_sufficiency_async(self, anchor: typing.Optional[SpatialAnchor], purpose: SpatialAnchorExportPurpose, /) -> winrt.windows.foundation.IAsyncOperation[SpatialAnchorExportSufficiency]: ...
    def try_export_anchor_async(self, anchor: typing.Optional[SpatialAnchor], purpose: SpatialAnchorExportPurpose, stream: typing.Optional[winrt.windows.storage.streams.IOutputStream], /) -> winrt.windows.foundation.IAsyncOperation[bool]: ...

@typing.final
class SpatialAnchorManager_Static(type):
    def request_store_async(cls) -> winrt.windows.foundation.IAsyncOperation[SpatialAnchorStore]: ...

@typing.final
class SpatialAnchorManager(winrt.system.Object, metaclass=SpatialAnchorManager_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> SpatialAnchorManager: ...

@typing.final
class SpatialAnchorRawCoordinateSystemAdjustedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> SpatialAnchorRawCoordinateSystemAdjustedEventArgs: ...
    @_property
    def old_raw_coordinate_system_to_new_raw_coordinate_system_transform(self) -> winrt.windows.foundation.numerics.Matrix4x4: ...

@typing.final
class SpatialAnchorStore(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> SpatialAnchorStore: ...
    def clear(self) -> None: ...
    def get_all_saved_anchors(self) -> typing.Optional[winrt.windows.foundation.collections.IMapView[str, SpatialAnchor]]: ...
    def remove(self, id: str, /) -> None: ...
    def try_save(self, id: str, anchor: typing.Optional[SpatialAnchor], /) -> bool: ...

@typing.final
class SpatialAnchorTransferManager_Static(type):
    def request_access_async(cls) -> winrt.windows.foundation.IAsyncOperation[SpatialPerceptionAccessStatus]: ...
    def try_export_anchors_async(cls, anchors: typing.Iterable[winrt.windows.foundation.collections.IKeyValuePair[str, SpatialAnchor]], stream: typing.Optional[winrt.windows.storage.streams.IOutputStream], /) -> winrt.windows.foundation.IAsyncOperation[bool]: ...
    def try_import_anchors_async(cls, stream: typing.Optional[winrt.windows.storage.streams.IInputStream], /) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.foundation.collections.IMapView[str, SpatialAnchor]]: ...

@typing.final
class SpatialAnchorTransferManager(winrt.system.Object, metaclass=SpatialAnchorTransferManager_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> SpatialAnchorTransferManager: ...

@typing.final
class SpatialBoundingVolume_Static(type):
    def from_box(cls, coordinate_system: typing.Optional[SpatialCoordinateSystem], box: SpatialBoundingBox, /) -> typing.Optional[SpatialBoundingVolume]: ...
    def from_frustum(cls, coordinate_system: typing.Optional[SpatialCoordinateSystem], frustum: SpatialBoundingFrustum, /) -> typing.Optional[SpatialBoundingVolume]: ...
    def from_oriented_box(cls, coordinate_system: typing.Optional[SpatialCoordinateSystem], box: SpatialBoundingOrientedBox, /) -> typing.Optional[SpatialBoundingVolume]: ...
    def from_sphere(cls, coordinate_system: typing.Optional[SpatialCoordinateSystem], sphere: SpatialBoundingSphere, /) -> typing.Optional[SpatialBoundingVolume]: ...

@typing.final
class SpatialBoundingVolume(winrt.system.Object, metaclass=SpatialBoundingVolume_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> SpatialBoundingVolume: ...

@typing.final
class SpatialCoordinateSystem(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> SpatialCoordinateSystem: ...
    def try_get_transform_to(self, target: typing.Optional[SpatialCoordinateSystem], /) -> typing.Optional[typing.Optional[winrt.windows.foundation.numerics.Matrix4x4]]: ...

@typing.final
class SpatialEntity(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> SpatialEntity: ...
    @typing.overload
    def __new__(cls: typing.Type[SpatialEntity], spatial_anchor: typing.Optional[SpatialAnchor]) -> SpatialEntity:...
    @typing.overload
    def __new__(cls: typing.Type[SpatialEntity], spatial_anchor: typing.Optional[SpatialAnchor], property_set: typing.Optional[winrt.windows.foundation.collections.ValueSet]) -> SpatialEntity:...
    @_property
    def anchor(self) -> typing.Optional[SpatialAnchor]: ...
    @_property
    def id(self) -> str: ...
    @_property
    def properties(self) -> typing.Optional[winrt.windows.foundation.collections.ValueSet]: ...

@typing.final
class SpatialEntityAddedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> SpatialEntityAddedEventArgs: ...
    @_property
    def entity(self) -> typing.Optional[SpatialEntity]: ...

@typing.final
class SpatialEntityRemovedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> SpatialEntityRemovedEventArgs: ...
    @_property
    def entity(self) -> typing.Optional[SpatialEntity]: ...

@typing.final
class SpatialEntityStore_Static(type):
    def try_get(cls, session: typing.Optional[winrt.windows.system.remotesystems.RemoteSystemSession], /) -> typing.Optional[SpatialEntityStore]: ...
    @_property
    def is_supported(cls) -> bool: ...

@typing.final
class SpatialEntityStore(winrt.system.Object, metaclass=SpatialEntityStore_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> SpatialEntityStore: ...
    def create_entity_watcher(self) -> typing.Optional[SpatialEntityWatcher]: ...
    def remove_async(self, entity: typing.Optional[SpatialEntity], /) -> winrt.windows.foundation.IAsyncAction: ...
    def save_async(self, entity: typing.Optional[SpatialEntity], /) -> winrt.windows.foundation.IAsyncAction: ...

@typing.final
class SpatialEntityUpdatedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> SpatialEntityUpdatedEventArgs: ...
    @_property
    def entity(self) -> typing.Optional[SpatialEntity]: ...

@typing.final
class SpatialEntityWatcher(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> SpatialEntityWatcher: ...
    def start(self) -> None: ...
    def stop(self) -> None: ...
    def add_added(self, handler: winrt.windows.foundation.TypedEventHandler[SpatialEntityWatcher, SpatialEntityAddedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_added(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_enumeration_completed(self, handler: winrt.windows.foundation.TypedEventHandler[SpatialEntityWatcher, winrt.system.Object], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_enumeration_completed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_removed(self, handler: winrt.windows.foundation.TypedEventHandler[SpatialEntityWatcher, SpatialEntityRemovedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_removed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_updated(self, handler: winrt.windows.foundation.TypedEventHandler[SpatialEntityWatcher, SpatialEntityUpdatedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_updated(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    @_property
    def status(self) -> SpatialEntityWatcherStatus: ...

@typing.final
class SpatialLocation(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> SpatialLocation: ...
    @_property
    def absolute_angular_acceleration(self) -> winrt.windows.foundation.numerics.Quaternion: ...
    @_property
    def absolute_angular_velocity(self) -> winrt.windows.foundation.numerics.Quaternion: ...
    @_property
    def absolute_linear_acceleration(self) -> winrt.windows.foundation.numerics.Vector3: ...
    @_property
    def absolute_linear_velocity(self) -> winrt.windows.foundation.numerics.Vector3: ...
    @_property
    def orientation(self) -> winrt.windows.foundation.numerics.Quaternion: ...
    @_property
    def position(self) -> winrt.windows.foundation.numerics.Vector3: ...
    @_property
    def absolute_angular_acceleration_axis_angle(self) -> winrt.windows.foundation.numerics.Vector3: ...
    @_property
    def absolute_angular_velocity_axis_angle(self) -> winrt.windows.foundation.numerics.Vector3: ...

@typing.final
class SpatialLocator_Static(type):
    def get_default(cls) -> typing.Optional[SpatialLocator]: ...

@typing.final
class SpatialLocator(winrt.system.Object, metaclass=SpatialLocator_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> SpatialLocator: ...
    @typing.overload
    def create_attached_frame_of_reference_at_current_heading(self) -> typing.Optional[SpatialLocatorAttachedFrameOfReference]: ...
    @typing.overload
    def create_attached_frame_of_reference_at_current_heading(self, relative_position: winrt.windows.foundation.numerics.Vector3, /) -> typing.Optional[SpatialLocatorAttachedFrameOfReference]: ...
    @typing.overload
    def create_attached_frame_of_reference_at_current_heading(self, relative_position: winrt.windows.foundation.numerics.Vector3, relative_orientation: winrt.windows.foundation.numerics.Quaternion, /) -> typing.Optional[SpatialLocatorAttachedFrameOfReference]: ...
    @typing.overload
    def create_attached_frame_of_reference_at_current_heading(self, relative_position: winrt.windows.foundation.numerics.Vector3, relative_orientation: winrt.windows.foundation.numerics.Quaternion, relative_heading_in_radians: winrt.system.Double, /) -> typing.Optional[SpatialLocatorAttachedFrameOfReference]: ...
    @typing.overload
    def create_stationary_frame_of_reference_at_current_location(self) -> typing.Optional[SpatialStationaryFrameOfReference]: ...
    @typing.overload
    def create_stationary_frame_of_reference_at_current_location(self, relative_position: winrt.windows.foundation.numerics.Vector3, /) -> typing.Optional[SpatialStationaryFrameOfReference]: ...
    @typing.overload
    def create_stationary_frame_of_reference_at_current_location(self, relative_position: winrt.windows.foundation.numerics.Vector3, relative_orientation: winrt.windows.foundation.numerics.Quaternion, /) -> typing.Optional[SpatialStationaryFrameOfReference]: ...
    @typing.overload
    def create_stationary_frame_of_reference_at_current_location(self, relative_position: winrt.windows.foundation.numerics.Vector3, relative_orientation: winrt.windows.foundation.numerics.Quaternion, relative_heading_in_radians: winrt.system.Double, /) -> typing.Optional[SpatialStationaryFrameOfReference]: ...
    def try_locate_at_timestamp(self, timestamp: typing.Optional[winrt.windows.perception.PerceptionTimestamp], coordinate_system: typing.Optional[SpatialCoordinateSystem], /) -> typing.Optional[SpatialLocation]: ...
    def add_locatability_changed(self, handler: winrt.windows.foundation.TypedEventHandler[SpatialLocator, winrt.system.Object], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_locatability_changed(self, cookie: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_positional_tracking_deactivating(self, handler: winrt.windows.foundation.TypedEventHandler[SpatialLocator, SpatialLocatorPositionalTrackingDeactivatingEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_positional_tracking_deactivating(self, cookie: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    @_property
    def locatability(self) -> SpatialLocatability: ...

@typing.final
class SpatialLocatorAttachedFrameOfReference(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> SpatialLocatorAttachedFrameOfReference: ...
    def adjust_heading(self, heading_offset_in_radians: winrt.system.Double, /) -> None: ...
    def get_stationary_coordinate_system_at_timestamp(self, timestamp: typing.Optional[winrt.windows.perception.PerceptionTimestamp], /) -> typing.Optional[SpatialCoordinateSystem]: ...
    def try_get_relative_heading_at_timestamp(self, timestamp: typing.Optional[winrt.windows.perception.PerceptionTimestamp], /) -> typing.Optional[typing.Optional[winrt.system.Double]]: ...
    @_property
    def relative_position(self) -> winrt.windows.foundation.numerics.Vector3: ...
    @relative_position.setter
    def relative_position(self, value: winrt.windows.foundation.numerics.Vector3) -> None: ...
    @_property
    def relative_orientation(self) -> winrt.windows.foundation.numerics.Quaternion: ...
    @relative_orientation.setter
    def relative_orientation(self, value: winrt.windows.foundation.numerics.Quaternion) -> None: ...

@typing.final
class SpatialLocatorPositionalTrackingDeactivatingEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> SpatialLocatorPositionalTrackingDeactivatingEventArgs: ...
    @_property
    def canceled(self) -> bool: ...
    @canceled.setter
    def canceled(self, value: bool) -> None: ...

@typing.final
class SpatialStageFrameOfReference_Static(type):
    def request_new_stage_async(cls) -> winrt.windows.foundation.IAsyncOperation[SpatialStageFrameOfReference]: ...
    def add_current_changed(cls, handler: winrt.windows.foundation.EventHandler[winrt.system.Object], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_current_changed(cls, cookie: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    @_property
    def current(cls) -> typing.Optional[SpatialStageFrameOfReference]: ...

@typing.final
class SpatialStageFrameOfReference(winrt.system.Object, metaclass=SpatialStageFrameOfReference_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> SpatialStageFrameOfReference: ...
    def get_coordinate_system_at_current_location(self, locator: typing.Optional[SpatialLocator], /) -> typing.Optional[SpatialCoordinateSystem]: ...
    def try_get_movement_bounds(self, coordinate_system: typing.Optional[SpatialCoordinateSystem], /) -> winrt.windows.foundation.numerics.Vector3: ...
    @_property
    def coordinate_system(self) -> typing.Optional[SpatialCoordinateSystem]: ...
    @_property
    def look_direction_range(self) -> SpatialLookDirectionRange: ...
    @_property
    def movement_range(self) -> SpatialMovementRange: ...

@typing.final
class SpatialStationaryFrameOfReference(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> SpatialStationaryFrameOfReference: ...
    @_property
    def coordinate_system(self) -> typing.Optional[SpatialCoordinateSystem]: ...

