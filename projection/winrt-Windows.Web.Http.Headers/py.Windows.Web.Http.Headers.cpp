// WARNING: Please don't edit this file. It was generated by Python/WinRT v0.0.0

#include "py.Windows.Web.Http.Headers.h"


namespace py::cpp::Windows::Web::Http::Headers
{
    // ----- HttpCacheDirectiveHeaderValueCollection class --------------------

    static PyObject* _new_HttpCacheDirectiveHeaderValueCollection(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Web::Http::Headers::HttpCacheDirectiveHeaderValueCollection>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Web::Http::Headers::HttpCacheDirectiveHeaderValueCollection>::type_name);
        return nullptr;
    }

    static void _dealloc_HttpCacheDirectiveHeaderValueCollection(py::wrapper::Windows::Web::Http::Headers::HttpCacheDirectiveHeaderValueCollection* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* HttpCacheDirectiveHeaderValueCollection_Append(py::wrapper::Windows::Web::Http::Headers::HttpCacheDirectiveHeaderValueCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpCacheDirectiveHeaderValueCollection", L"Append", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Web::Http::Headers::HttpNameValueHeaderValue>(args, 0);

                self->obj.Append(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpCacheDirectiveHeaderValueCollection_Clear(py::wrapper::Windows::Web::Http::Headers::HttpCacheDirectiveHeaderValueCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpCacheDirectiveHeaderValueCollection", L"Clear", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Clear();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpCacheDirectiveHeaderValueCollection_First(py::wrapper::Windows::Web::Http::Headers::HttpCacheDirectiveHeaderValueCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpCacheDirectiveHeaderValueCollection", L"First", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.First());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpCacheDirectiveHeaderValueCollection_GetAt(py::wrapper::Windows::Web::Http::Headers::HttpCacheDirectiveHeaderValueCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpCacheDirectiveHeaderValueCollection", L"GetAt", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint32_t>(args, 0);

                return py::convert(self->obj.GetAt(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpCacheDirectiveHeaderValueCollection_GetMany(py::wrapper::Windows::Web::Http::Headers::HttpCacheDirectiveHeaderValueCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpCacheDirectiveHeaderValueCollection", L"GetMany", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<winrt::Windows::Web::Http::Headers::HttpNameValueHeaderValue, true>>(args, 1);

                return py::convert(self->obj.GetMany(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpCacheDirectiveHeaderValueCollection_GetView(py::wrapper::Windows::Web::Http::Headers::HttpCacheDirectiveHeaderValueCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpCacheDirectiveHeaderValueCollection", L"GetView", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetView());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpCacheDirectiveHeaderValueCollection_IndexOf(py::wrapper::Windows::Web::Http::Headers::HttpCacheDirectiveHeaderValueCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpCacheDirectiveHeaderValueCollection", L"IndexOf", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Web::Http::Headers::HttpNameValueHeaderValue>(args, 0);
                uint32_t param1 {  };

                auto return_value = self->obj.IndexOf(param0, param1);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out1.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpCacheDirectiveHeaderValueCollection_InsertAt(py::wrapper::Windows::Web::Http::Headers::HttpCacheDirectiveHeaderValueCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpCacheDirectiveHeaderValueCollection", L"InsertAt", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Web::Http::Headers::HttpNameValueHeaderValue>(args, 1);

                self->obj.InsertAt(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpCacheDirectiveHeaderValueCollection_ParseAdd(py::wrapper::Windows::Web::Http::Headers::HttpCacheDirectiveHeaderValueCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpCacheDirectiveHeaderValueCollection", L"ParseAdd", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                self->obj.ParseAdd(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpCacheDirectiveHeaderValueCollection_RemoveAt(py::wrapper::Windows::Web::Http::Headers::HttpCacheDirectiveHeaderValueCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpCacheDirectiveHeaderValueCollection", L"RemoveAt", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint32_t>(args, 0);

                self->obj.RemoveAt(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpCacheDirectiveHeaderValueCollection_RemoveAtEnd(py::wrapper::Windows::Web::Http::Headers::HttpCacheDirectiveHeaderValueCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpCacheDirectiveHeaderValueCollection", L"RemoveAtEnd", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.RemoveAtEnd();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpCacheDirectiveHeaderValueCollection_ReplaceAll(py::wrapper::Windows::Web::Http::Headers::HttpCacheDirectiveHeaderValueCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpCacheDirectiveHeaderValueCollection", L"ReplaceAll", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<py::pybuf_view<winrt::Windows::Web::Http::Headers::HttpNameValueHeaderValue, false>>(args, 0);

                self->obj.ReplaceAll(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpCacheDirectiveHeaderValueCollection_SetAt(py::wrapper::Windows::Web::Http::Headers::HttpCacheDirectiveHeaderValueCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpCacheDirectiveHeaderValueCollection", L"SetAt", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Web::Http::Headers::HttpNameValueHeaderValue>(args, 1);

                self->obj.SetAt(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpCacheDirectiveHeaderValueCollection_ToString(py::wrapper::Windows::Web::Http::Headers::HttpCacheDirectiveHeaderValueCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpCacheDirectiveHeaderValueCollection", L"ToString", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.ToString());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpCacheDirectiveHeaderValueCollection_TryParseAdd(py::wrapper::Windows::Web::Http::Headers::HttpCacheDirectiveHeaderValueCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpCacheDirectiveHeaderValueCollection", L"TryParseAdd", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.TryParseAdd(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpCacheDirectiveHeaderValueCollection_get_Size(py::wrapper::Windows::Web::Http::Headers::HttpCacheDirectiveHeaderValueCollection* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.Headers.HttpCacheDirectiveHeaderValueCollection", L"Size"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HttpCacheDirectiveHeaderValueCollection_get_SharedMaxAge(py::wrapper::Windows::Web::Http::Headers::HttpCacheDirectiveHeaderValueCollection* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.Headers.HttpCacheDirectiveHeaderValueCollection", L"SharedMaxAge"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SharedMaxAge());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int HttpCacheDirectiveHeaderValueCollection_put_SharedMaxAge(py::wrapper::Windows::Web::Http::Headers::HttpCacheDirectiveHeaderValueCollection* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.Headers.HttpCacheDirectiveHeaderValueCollection", L"SharedMaxAge"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::TimeSpan>>(arg);

            self->obj.SharedMaxAge(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* HttpCacheDirectiveHeaderValueCollection_get_MinFresh(py::wrapper::Windows::Web::Http::Headers::HttpCacheDirectiveHeaderValueCollection* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.Headers.HttpCacheDirectiveHeaderValueCollection", L"MinFresh"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.MinFresh());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int HttpCacheDirectiveHeaderValueCollection_put_MinFresh(py::wrapper::Windows::Web::Http::Headers::HttpCacheDirectiveHeaderValueCollection* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.Headers.HttpCacheDirectiveHeaderValueCollection", L"MinFresh"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::TimeSpan>>(arg);

            self->obj.MinFresh(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* HttpCacheDirectiveHeaderValueCollection_get_MaxStale(py::wrapper::Windows::Web::Http::Headers::HttpCacheDirectiveHeaderValueCollection* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.Headers.HttpCacheDirectiveHeaderValueCollection", L"MaxStale"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.MaxStale());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int HttpCacheDirectiveHeaderValueCollection_put_MaxStale(py::wrapper::Windows::Web::Http::Headers::HttpCacheDirectiveHeaderValueCollection* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.Headers.HttpCacheDirectiveHeaderValueCollection", L"MaxStale"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::TimeSpan>>(arg);

            self->obj.MaxStale(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* HttpCacheDirectiveHeaderValueCollection_get_MaxAge(py::wrapper::Windows::Web::Http::Headers::HttpCacheDirectiveHeaderValueCollection* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.Headers.HttpCacheDirectiveHeaderValueCollection", L"MaxAge"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.MaxAge());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int HttpCacheDirectiveHeaderValueCollection_put_MaxAge(py::wrapper::Windows::Web::Http::Headers::HttpCacheDirectiveHeaderValueCollection* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.Headers.HttpCacheDirectiveHeaderValueCollection", L"MaxAge"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::TimeSpan>>(arg);

            self->obj.MaxAge(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_HttpCacheDirectiveHeaderValueCollection(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Web::Http::Headers::HttpCacheDirectiveHeaderValueCollection>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_HttpCacheDirectiveHeaderValueCollection(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Web::Http::Headers::HttpCacheDirectiveHeaderValueCollection>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _str_HttpCacheDirectiveHeaderValueCollection(py::wrapper::Windows::Web::Http::Headers::HttpCacheDirectiveHeaderValueCollection* self) noexcept
    {
        try
        {
            return py::convert(self->obj.ToString());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _iterator_HttpCacheDirectiveHeaderValueCollection(py::wrapper::Windows::Web::Http::Headers::HttpCacheDirectiveHeaderValueCollection* self) noexcept
    {
        try
        {
            return py::convert(self->obj.First());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static Py_ssize_t _seq_length_HttpCacheDirectiveHeaderValueCollection(py::wrapper::Windows::Web::Http::Headers::HttpCacheDirectiveHeaderValueCollection* self) noexcept
    {
        try
        {
            return static_cast<Py_ssize_t>(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _seq_item_HttpCacheDirectiveHeaderValueCollection(py::wrapper::Windows::Web::Http::Headers::HttpCacheDirectiveHeaderValueCollection* self, Py_ssize_t i) noexcept
    {
        try
        {
            return py::convert(self->obj.GetAt(static_cast<uint32_t>(i)));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _seq_subscript_HttpCacheDirectiveHeaderValueCollection(py::wrapper::Windows::Web::Http::Headers::HttpCacheDirectiveHeaderValueCollection* self, PyObject* slice) noexcept
    {
        try
        {
            if (PyIndex_Check(slice))
            {
                pyobj_handle index{PyNumber_Index(slice)};

                if (!index)
                {
                    return nullptr;
                }

                auto i = PyNumber_AsSsize_t(index.get(), PyExc_IndexError);

                if (i == -1 && PyErr_Occurred())
                {
                    return nullptr;
                }

                return _seq_item_HttpCacheDirectiveHeaderValueCollection(self, i);
            }

            if (!PySlice_Check(slice))
            {
                PyErr_Format(
                    PyExc_TypeError,
                    "indicies must be integers, not '%s'",
                    Py_TYPE(slice)->tp_name);
            }

            Py_ssize_t start, stop, step, length;

            if (PySlice_GetIndicesEx(
                    slice, self->obj.Size(), &start, &stop, &step, &length)
                < 0)
            {
                return nullptr;
            }

            if (step != 1)
            {
                PyErr_SetString(PyExc_NotImplementedError, "slices with step other than 1 are not implemented");
                return nullptr;
            }

            winrt::com_array<winrt::Windows::Web::Http::Headers::HttpNameValueHeaderValue> items(static_cast<uint32_t>(length), empty_instance<winrt::Windows::Web::Http::Headers::HttpNameValueHeaderValue>::get());

            auto count = self->obj.GetMany(static_cast<uint32_t>(start), items);

            if (count != static_cast<uint32_t>(length))
            {
                PyErr_Format(PyExc_RuntimeError, "returned count %d did not match requested length %zd", count, length);
                return nullptr;
            }

            return convert(items);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int _seq_assign_HttpCacheDirectiveHeaderValueCollection(py::wrapper::Windows::Web::Http::Headers::HttpCacheDirectiveHeaderValueCollection* self, Py_ssize_t i, PyObject* value) noexcept
    {
        try
        {
            if (!value)
            {
                self->obj.RemoveAt(static_cast<uint32_t>(i));
            }
            else
            {
                self->obj.SetAt(static_cast<uint32_t>(i), py::convert_to<winrt::Windows::Web::Http::Headers::HttpNameValueHeaderValue>(value));
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyMethodDef _methods_HttpCacheDirectiveHeaderValueCollection[] = {
        { "append", reinterpret_cast<PyCFunction>(HttpCacheDirectiveHeaderValueCollection_Append), METH_VARARGS, nullptr },
        { "clear", reinterpret_cast<PyCFunction>(HttpCacheDirectiveHeaderValueCollection_Clear), METH_VARARGS, nullptr },
        { "first", reinterpret_cast<PyCFunction>(HttpCacheDirectiveHeaderValueCollection_First), METH_VARARGS, nullptr },
        { "get_at", reinterpret_cast<PyCFunction>(HttpCacheDirectiveHeaderValueCollection_GetAt), METH_VARARGS, nullptr },
        { "get_many", reinterpret_cast<PyCFunction>(HttpCacheDirectiveHeaderValueCollection_GetMany), METH_VARARGS, nullptr },
        { "get_view", reinterpret_cast<PyCFunction>(HttpCacheDirectiveHeaderValueCollection_GetView), METH_VARARGS, nullptr },
        { "index_of", reinterpret_cast<PyCFunction>(HttpCacheDirectiveHeaderValueCollection_IndexOf), METH_VARARGS, nullptr },
        { "insert_at", reinterpret_cast<PyCFunction>(HttpCacheDirectiveHeaderValueCollection_InsertAt), METH_VARARGS, nullptr },
        { "parse_add", reinterpret_cast<PyCFunction>(HttpCacheDirectiveHeaderValueCollection_ParseAdd), METH_VARARGS, nullptr },
        { "remove_at", reinterpret_cast<PyCFunction>(HttpCacheDirectiveHeaderValueCollection_RemoveAt), METH_VARARGS, nullptr },
        { "remove_at_end", reinterpret_cast<PyCFunction>(HttpCacheDirectiveHeaderValueCollection_RemoveAtEnd), METH_VARARGS, nullptr },
        { "replace_all", reinterpret_cast<PyCFunction>(HttpCacheDirectiveHeaderValueCollection_ReplaceAll), METH_VARARGS, nullptr },
        { "set_at", reinterpret_cast<PyCFunction>(HttpCacheDirectiveHeaderValueCollection_SetAt), METH_VARARGS, nullptr },
        { "to_string", reinterpret_cast<PyCFunction>(HttpCacheDirectiveHeaderValueCollection_ToString), METH_VARARGS, nullptr },
        { "try_parse_add", reinterpret_cast<PyCFunction>(HttpCacheDirectiveHeaderValueCollection_TryParseAdd), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_HttpCacheDirectiveHeaderValueCollection, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_HttpCacheDirectiveHeaderValueCollection), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_HttpCacheDirectiveHeaderValueCollection[] = {
        { "size", reinterpret_cast<getter>(HttpCacheDirectiveHeaderValueCollection_get_Size), nullptr, nullptr, nullptr },
        { "shared_max_age", reinterpret_cast<getter>(HttpCacheDirectiveHeaderValueCollection_get_SharedMaxAge), reinterpret_cast<setter>(HttpCacheDirectiveHeaderValueCollection_put_SharedMaxAge), nullptr, nullptr },
        { "min_fresh", reinterpret_cast<getter>(HttpCacheDirectiveHeaderValueCollection_get_MinFresh), reinterpret_cast<setter>(HttpCacheDirectiveHeaderValueCollection_put_MinFresh), nullptr, nullptr },
        { "max_stale", reinterpret_cast<getter>(HttpCacheDirectiveHeaderValueCollection_get_MaxStale), reinterpret_cast<setter>(HttpCacheDirectiveHeaderValueCollection_put_MaxStale), nullptr, nullptr },
        { "max_age", reinterpret_cast<getter>(HttpCacheDirectiveHeaderValueCollection_get_MaxAge), reinterpret_cast<setter>(HttpCacheDirectiveHeaderValueCollection_put_MaxAge), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_HttpCacheDirectiveHeaderValueCollection[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_HttpCacheDirectiveHeaderValueCollection) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_HttpCacheDirectiveHeaderValueCollection) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_HttpCacheDirectiveHeaderValueCollection) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_HttpCacheDirectiveHeaderValueCollection) },
        { Py_tp_str, reinterpret_cast<void*>(_str_HttpCacheDirectiveHeaderValueCollection) },
        { Py_tp_iter, reinterpret_cast<void*>(_iterator_HttpCacheDirectiveHeaderValueCollection) },
        { Py_sq_length, reinterpret_cast<void*>(_seq_length_HttpCacheDirectiveHeaderValueCollection) },
        { Py_sq_item, reinterpret_cast<void*>(_seq_item_HttpCacheDirectiveHeaderValueCollection) },
        { Py_mp_subscript, reinterpret_cast<void*>(_seq_subscript_HttpCacheDirectiveHeaderValueCollection) },
        { Py_sq_ass_item, reinterpret_cast<void*>(_seq_assign_HttpCacheDirectiveHeaderValueCollection) },
        { },
    };

    static PyType_Spec type_spec_HttpCacheDirectiveHeaderValueCollection =
    {
        "winrt._winrt_windows_web_http_headers.HttpCacheDirectiveHeaderValueCollection",
        sizeof(py::wrapper::Windows::Web::Http::Headers::HttpCacheDirectiveHeaderValueCollection),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_HttpCacheDirectiveHeaderValueCollection
    };

    // ----- HttpChallengeHeaderValue class --------------------

    static PyObject* _new_HttpChallengeHeaderValue(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                winrt::Windows::Web::Http::Headers::HttpChallengeHeaderValue instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                winrt::Windows::Web::Http::Headers::HttpChallengeHeaderValue instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_HttpChallengeHeaderValue(py::wrapper::Windows::Web::Http::Headers::HttpChallengeHeaderValue* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* HttpChallengeHeaderValue_Parse(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpChallengeHeaderValue", L"Parse", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Web::Http::Headers::HttpChallengeHeaderValue::Parse(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpChallengeHeaderValue_ToString(py::wrapper::Windows::Web::Http::Headers::HttpChallengeHeaderValue* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpChallengeHeaderValue", L"ToString", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.ToString());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpChallengeHeaderValue_TryParse(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpChallengeHeaderValue", L"TryParse", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                winrt::Windows::Web::Http::Headers::HttpChallengeHeaderValue param1 { nullptr };

                auto return_value = winrt::Windows::Web::Http::Headers::HttpChallengeHeaderValue::TryParse(param0, param1);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out1.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpChallengeHeaderValue_get_Parameters(py::wrapper::Windows::Web::Http::Headers::HttpChallengeHeaderValue* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.Headers.HttpChallengeHeaderValue", L"Parameters"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Parameters());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HttpChallengeHeaderValue_get_Scheme(py::wrapper::Windows::Web::Http::Headers::HttpChallengeHeaderValue* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.Headers.HttpChallengeHeaderValue", L"Scheme"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Scheme());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HttpChallengeHeaderValue_get_Token(py::wrapper::Windows::Web::Http::Headers::HttpChallengeHeaderValue* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.Headers.HttpChallengeHeaderValue", L"Token"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Token());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_HttpChallengeHeaderValue(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Web::Http::Headers::HttpChallengeHeaderValue>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_HttpChallengeHeaderValue(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Web::Http::Headers::HttpChallengeHeaderValue>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _str_HttpChallengeHeaderValue(py::wrapper::Windows::Web::Http::Headers::HttpChallengeHeaderValue* self) noexcept
    {
        try
        {
            return py::convert(self->obj.ToString());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_HttpChallengeHeaderValue[] = {
        { "to_string", reinterpret_cast<PyCFunction>(HttpChallengeHeaderValue_ToString), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_HttpChallengeHeaderValue, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_HttpChallengeHeaderValue), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_HttpChallengeHeaderValue[] = {
        { "parameters", reinterpret_cast<getter>(HttpChallengeHeaderValue_get_Parameters), nullptr, nullptr, nullptr },
        { "scheme", reinterpret_cast<getter>(HttpChallengeHeaderValue_get_Scheme), nullptr, nullptr, nullptr },
        { "token", reinterpret_cast<getter>(HttpChallengeHeaderValue_get_Token), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_HttpChallengeHeaderValue[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_HttpChallengeHeaderValue) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_HttpChallengeHeaderValue) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_HttpChallengeHeaderValue) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_HttpChallengeHeaderValue) },
        { Py_tp_str, reinterpret_cast<void*>(_str_HttpChallengeHeaderValue) },
        { },
    };

    static PyType_Spec type_spec_HttpChallengeHeaderValue =
    {
        "winrt._winrt_windows_web_http_headers.HttpChallengeHeaderValue",
        sizeof(py::wrapper::Windows::Web::Http::Headers::HttpChallengeHeaderValue),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_HttpChallengeHeaderValue
    };

    static PyGetSetDef getset_HttpChallengeHeaderValue_Static[] = {
        { }
    };

    static PyMethodDef methods_HttpChallengeHeaderValue_Static[] = {
        { "parse", reinterpret_cast<PyCFunction>(HttpChallengeHeaderValue_Parse), METH_VARARGS, nullptr },
        { "try_parse", reinterpret_cast<PyCFunction>(HttpChallengeHeaderValue_TryParse), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_HttpChallengeHeaderValue_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_HttpChallengeHeaderValue_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_HttpChallengeHeaderValue_Static) },
        { }
    };

    static PyType_Spec type_spec_HttpChallengeHeaderValue_Static =
    {
        "winrt._winrt_windows_web_http_headers.HttpChallengeHeaderValue_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_HttpChallengeHeaderValue_Static
    };

    // ----- HttpChallengeHeaderValueCollection class --------------------

    static PyObject* _new_HttpChallengeHeaderValueCollection(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Web::Http::Headers::HttpChallengeHeaderValueCollection>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Web::Http::Headers::HttpChallengeHeaderValueCollection>::type_name);
        return nullptr;
    }

    static void _dealloc_HttpChallengeHeaderValueCollection(py::wrapper::Windows::Web::Http::Headers::HttpChallengeHeaderValueCollection* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* HttpChallengeHeaderValueCollection_Append(py::wrapper::Windows::Web::Http::Headers::HttpChallengeHeaderValueCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpChallengeHeaderValueCollection", L"Append", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Web::Http::Headers::HttpChallengeHeaderValue>(args, 0);

                self->obj.Append(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpChallengeHeaderValueCollection_Clear(py::wrapper::Windows::Web::Http::Headers::HttpChallengeHeaderValueCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpChallengeHeaderValueCollection", L"Clear", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Clear();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpChallengeHeaderValueCollection_First(py::wrapper::Windows::Web::Http::Headers::HttpChallengeHeaderValueCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpChallengeHeaderValueCollection", L"First", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.First());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpChallengeHeaderValueCollection_GetAt(py::wrapper::Windows::Web::Http::Headers::HttpChallengeHeaderValueCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpChallengeHeaderValueCollection", L"GetAt", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint32_t>(args, 0);

                return py::convert(self->obj.GetAt(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpChallengeHeaderValueCollection_GetMany(py::wrapper::Windows::Web::Http::Headers::HttpChallengeHeaderValueCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpChallengeHeaderValueCollection", L"GetMany", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<winrt::Windows::Web::Http::Headers::HttpChallengeHeaderValue, true>>(args, 1);

                return py::convert(self->obj.GetMany(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpChallengeHeaderValueCollection_GetView(py::wrapper::Windows::Web::Http::Headers::HttpChallengeHeaderValueCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpChallengeHeaderValueCollection", L"GetView", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetView());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpChallengeHeaderValueCollection_IndexOf(py::wrapper::Windows::Web::Http::Headers::HttpChallengeHeaderValueCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpChallengeHeaderValueCollection", L"IndexOf", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Web::Http::Headers::HttpChallengeHeaderValue>(args, 0);
                uint32_t param1 {  };

                auto return_value = self->obj.IndexOf(param0, param1);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out1.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpChallengeHeaderValueCollection_InsertAt(py::wrapper::Windows::Web::Http::Headers::HttpChallengeHeaderValueCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpChallengeHeaderValueCollection", L"InsertAt", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Web::Http::Headers::HttpChallengeHeaderValue>(args, 1);

                self->obj.InsertAt(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpChallengeHeaderValueCollection_ParseAdd(py::wrapper::Windows::Web::Http::Headers::HttpChallengeHeaderValueCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpChallengeHeaderValueCollection", L"ParseAdd", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                self->obj.ParseAdd(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpChallengeHeaderValueCollection_RemoveAt(py::wrapper::Windows::Web::Http::Headers::HttpChallengeHeaderValueCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpChallengeHeaderValueCollection", L"RemoveAt", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint32_t>(args, 0);

                self->obj.RemoveAt(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpChallengeHeaderValueCollection_RemoveAtEnd(py::wrapper::Windows::Web::Http::Headers::HttpChallengeHeaderValueCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpChallengeHeaderValueCollection", L"RemoveAtEnd", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.RemoveAtEnd();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpChallengeHeaderValueCollection_ReplaceAll(py::wrapper::Windows::Web::Http::Headers::HttpChallengeHeaderValueCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpChallengeHeaderValueCollection", L"ReplaceAll", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<py::pybuf_view<winrt::Windows::Web::Http::Headers::HttpChallengeHeaderValue, false>>(args, 0);

                self->obj.ReplaceAll(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpChallengeHeaderValueCollection_SetAt(py::wrapper::Windows::Web::Http::Headers::HttpChallengeHeaderValueCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpChallengeHeaderValueCollection", L"SetAt", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Web::Http::Headers::HttpChallengeHeaderValue>(args, 1);

                self->obj.SetAt(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpChallengeHeaderValueCollection_ToString(py::wrapper::Windows::Web::Http::Headers::HttpChallengeHeaderValueCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpChallengeHeaderValueCollection", L"ToString", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.ToString());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpChallengeHeaderValueCollection_TryParseAdd(py::wrapper::Windows::Web::Http::Headers::HttpChallengeHeaderValueCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpChallengeHeaderValueCollection", L"TryParseAdd", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.TryParseAdd(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpChallengeHeaderValueCollection_get_Size(py::wrapper::Windows::Web::Http::Headers::HttpChallengeHeaderValueCollection* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.Headers.HttpChallengeHeaderValueCollection", L"Size"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_HttpChallengeHeaderValueCollection(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Web::Http::Headers::HttpChallengeHeaderValueCollection>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_HttpChallengeHeaderValueCollection(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Web::Http::Headers::HttpChallengeHeaderValueCollection>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _str_HttpChallengeHeaderValueCollection(py::wrapper::Windows::Web::Http::Headers::HttpChallengeHeaderValueCollection* self) noexcept
    {
        try
        {
            return py::convert(self->obj.ToString());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _iterator_HttpChallengeHeaderValueCollection(py::wrapper::Windows::Web::Http::Headers::HttpChallengeHeaderValueCollection* self) noexcept
    {
        try
        {
            return py::convert(self->obj.First());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static Py_ssize_t _seq_length_HttpChallengeHeaderValueCollection(py::wrapper::Windows::Web::Http::Headers::HttpChallengeHeaderValueCollection* self) noexcept
    {
        try
        {
            return static_cast<Py_ssize_t>(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _seq_item_HttpChallengeHeaderValueCollection(py::wrapper::Windows::Web::Http::Headers::HttpChallengeHeaderValueCollection* self, Py_ssize_t i) noexcept
    {
        try
        {
            return py::convert(self->obj.GetAt(static_cast<uint32_t>(i)));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _seq_subscript_HttpChallengeHeaderValueCollection(py::wrapper::Windows::Web::Http::Headers::HttpChallengeHeaderValueCollection* self, PyObject* slice) noexcept
    {
        try
        {
            if (PyIndex_Check(slice))
            {
                pyobj_handle index{PyNumber_Index(slice)};

                if (!index)
                {
                    return nullptr;
                }

                auto i = PyNumber_AsSsize_t(index.get(), PyExc_IndexError);

                if (i == -1 && PyErr_Occurred())
                {
                    return nullptr;
                }

                return _seq_item_HttpChallengeHeaderValueCollection(self, i);
            }

            if (!PySlice_Check(slice))
            {
                PyErr_Format(
                    PyExc_TypeError,
                    "indicies must be integers, not '%s'",
                    Py_TYPE(slice)->tp_name);
            }

            Py_ssize_t start, stop, step, length;

            if (PySlice_GetIndicesEx(
                    slice, self->obj.Size(), &start, &stop, &step, &length)
                < 0)
            {
                return nullptr;
            }

            if (step != 1)
            {
                PyErr_SetString(PyExc_NotImplementedError, "slices with step other than 1 are not implemented");
                return nullptr;
            }

            winrt::com_array<winrt::Windows::Web::Http::Headers::HttpChallengeHeaderValue> items(static_cast<uint32_t>(length), empty_instance<winrt::Windows::Web::Http::Headers::HttpChallengeHeaderValue>::get());

            auto count = self->obj.GetMany(static_cast<uint32_t>(start), items);

            if (count != static_cast<uint32_t>(length))
            {
                PyErr_Format(PyExc_RuntimeError, "returned count %d did not match requested length %zd", count, length);
                return nullptr;
            }

            return convert(items);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int _seq_assign_HttpChallengeHeaderValueCollection(py::wrapper::Windows::Web::Http::Headers::HttpChallengeHeaderValueCollection* self, Py_ssize_t i, PyObject* value) noexcept
    {
        try
        {
            if (!value)
            {
                self->obj.RemoveAt(static_cast<uint32_t>(i));
            }
            else
            {
                self->obj.SetAt(static_cast<uint32_t>(i), py::convert_to<winrt::Windows::Web::Http::Headers::HttpChallengeHeaderValue>(value));
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyMethodDef _methods_HttpChallengeHeaderValueCollection[] = {
        { "append", reinterpret_cast<PyCFunction>(HttpChallengeHeaderValueCollection_Append), METH_VARARGS, nullptr },
        { "clear", reinterpret_cast<PyCFunction>(HttpChallengeHeaderValueCollection_Clear), METH_VARARGS, nullptr },
        { "first", reinterpret_cast<PyCFunction>(HttpChallengeHeaderValueCollection_First), METH_VARARGS, nullptr },
        { "get_at", reinterpret_cast<PyCFunction>(HttpChallengeHeaderValueCollection_GetAt), METH_VARARGS, nullptr },
        { "get_many", reinterpret_cast<PyCFunction>(HttpChallengeHeaderValueCollection_GetMany), METH_VARARGS, nullptr },
        { "get_view", reinterpret_cast<PyCFunction>(HttpChallengeHeaderValueCollection_GetView), METH_VARARGS, nullptr },
        { "index_of", reinterpret_cast<PyCFunction>(HttpChallengeHeaderValueCollection_IndexOf), METH_VARARGS, nullptr },
        { "insert_at", reinterpret_cast<PyCFunction>(HttpChallengeHeaderValueCollection_InsertAt), METH_VARARGS, nullptr },
        { "parse_add", reinterpret_cast<PyCFunction>(HttpChallengeHeaderValueCollection_ParseAdd), METH_VARARGS, nullptr },
        { "remove_at", reinterpret_cast<PyCFunction>(HttpChallengeHeaderValueCollection_RemoveAt), METH_VARARGS, nullptr },
        { "remove_at_end", reinterpret_cast<PyCFunction>(HttpChallengeHeaderValueCollection_RemoveAtEnd), METH_VARARGS, nullptr },
        { "replace_all", reinterpret_cast<PyCFunction>(HttpChallengeHeaderValueCollection_ReplaceAll), METH_VARARGS, nullptr },
        { "set_at", reinterpret_cast<PyCFunction>(HttpChallengeHeaderValueCollection_SetAt), METH_VARARGS, nullptr },
        { "to_string", reinterpret_cast<PyCFunction>(HttpChallengeHeaderValueCollection_ToString), METH_VARARGS, nullptr },
        { "try_parse_add", reinterpret_cast<PyCFunction>(HttpChallengeHeaderValueCollection_TryParseAdd), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_HttpChallengeHeaderValueCollection, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_HttpChallengeHeaderValueCollection), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_HttpChallengeHeaderValueCollection[] = {
        { "size", reinterpret_cast<getter>(HttpChallengeHeaderValueCollection_get_Size), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_HttpChallengeHeaderValueCollection[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_HttpChallengeHeaderValueCollection) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_HttpChallengeHeaderValueCollection) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_HttpChallengeHeaderValueCollection) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_HttpChallengeHeaderValueCollection) },
        { Py_tp_str, reinterpret_cast<void*>(_str_HttpChallengeHeaderValueCollection) },
        { Py_tp_iter, reinterpret_cast<void*>(_iterator_HttpChallengeHeaderValueCollection) },
        { Py_sq_length, reinterpret_cast<void*>(_seq_length_HttpChallengeHeaderValueCollection) },
        { Py_sq_item, reinterpret_cast<void*>(_seq_item_HttpChallengeHeaderValueCollection) },
        { Py_mp_subscript, reinterpret_cast<void*>(_seq_subscript_HttpChallengeHeaderValueCollection) },
        { Py_sq_ass_item, reinterpret_cast<void*>(_seq_assign_HttpChallengeHeaderValueCollection) },
        { },
    };

    static PyType_Spec type_spec_HttpChallengeHeaderValueCollection =
    {
        "winrt._winrt_windows_web_http_headers.HttpChallengeHeaderValueCollection",
        sizeof(py::wrapper::Windows::Web::Http::Headers::HttpChallengeHeaderValueCollection),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_HttpChallengeHeaderValueCollection
    };

    // ----- HttpConnectionOptionHeaderValue class --------------------

    static PyObject* _new_HttpConnectionOptionHeaderValue(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                winrt::Windows::Web::Http::Headers::HttpConnectionOptionHeaderValue instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_HttpConnectionOptionHeaderValue(py::wrapper::Windows::Web::Http::Headers::HttpConnectionOptionHeaderValue* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* HttpConnectionOptionHeaderValue_Parse(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpConnectionOptionHeaderValue", L"Parse", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Web::Http::Headers::HttpConnectionOptionHeaderValue::Parse(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpConnectionOptionHeaderValue_ToString(py::wrapper::Windows::Web::Http::Headers::HttpConnectionOptionHeaderValue* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpConnectionOptionHeaderValue", L"ToString", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.ToString());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpConnectionOptionHeaderValue_TryParse(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpConnectionOptionHeaderValue", L"TryParse", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                winrt::Windows::Web::Http::Headers::HttpConnectionOptionHeaderValue param1 { nullptr };

                auto return_value = winrt::Windows::Web::Http::Headers::HttpConnectionOptionHeaderValue::TryParse(param0, param1);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out1.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpConnectionOptionHeaderValue_get_Token(py::wrapper::Windows::Web::Http::Headers::HttpConnectionOptionHeaderValue* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.Headers.HttpConnectionOptionHeaderValue", L"Token"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Token());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_HttpConnectionOptionHeaderValue(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Web::Http::Headers::HttpConnectionOptionHeaderValue>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_HttpConnectionOptionHeaderValue(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Web::Http::Headers::HttpConnectionOptionHeaderValue>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _str_HttpConnectionOptionHeaderValue(py::wrapper::Windows::Web::Http::Headers::HttpConnectionOptionHeaderValue* self) noexcept
    {
        try
        {
            return py::convert(self->obj.ToString());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_HttpConnectionOptionHeaderValue[] = {
        { "to_string", reinterpret_cast<PyCFunction>(HttpConnectionOptionHeaderValue_ToString), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_HttpConnectionOptionHeaderValue, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_HttpConnectionOptionHeaderValue), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_HttpConnectionOptionHeaderValue[] = {
        { "token", reinterpret_cast<getter>(HttpConnectionOptionHeaderValue_get_Token), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_HttpConnectionOptionHeaderValue[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_HttpConnectionOptionHeaderValue) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_HttpConnectionOptionHeaderValue) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_HttpConnectionOptionHeaderValue) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_HttpConnectionOptionHeaderValue) },
        { Py_tp_str, reinterpret_cast<void*>(_str_HttpConnectionOptionHeaderValue) },
        { },
    };

    static PyType_Spec type_spec_HttpConnectionOptionHeaderValue =
    {
        "winrt._winrt_windows_web_http_headers.HttpConnectionOptionHeaderValue",
        sizeof(py::wrapper::Windows::Web::Http::Headers::HttpConnectionOptionHeaderValue),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_HttpConnectionOptionHeaderValue
    };

    static PyGetSetDef getset_HttpConnectionOptionHeaderValue_Static[] = {
        { }
    };

    static PyMethodDef methods_HttpConnectionOptionHeaderValue_Static[] = {
        { "parse", reinterpret_cast<PyCFunction>(HttpConnectionOptionHeaderValue_Parse), METH_VARARGS, nullptr },
        { "try_parse", reinterpret_cast<PyCFunction>(HttpConnectionOptionHeaderValue_TryParse), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_HttpConnectionOptionHeaderValue_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_HttpConnectionOptionHeaderValue_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_HttpConnectionOptionHeaderValue_Static) },
        { }
    };

    static PyType_Spec type_spec_HttpConnectionOptionHeaderValue_Static =
    {
        "winrt._winrt_windows_web_http_headers.HttpConnectionOptionHeaderValue_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_HttpConnectionOptionHeaderValue_Static
    };

    // ----- HttpConnectionOptionHeaderValueCollection class --------------------

    static PyObject* _new_HttpConnectionOptionHeaderValueCollection(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Web::Http::Headers::HttpConnectionOptionHeaderValueCollection>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Web::Http::Headers::HttpConnectionOptionHeaderValueCollection>::type_name);
        return nullptr;
    }

    static void _dealloc_HttpConnectionOptionHeaderValueCollection(py::wrapper::Windows::Web::Http::Headers::HttpConnectionOptionHeaderValueCollection* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* HttpConnectionOptionHeaderValueCollection_Append(py::wrapper::Windows::Web::Http::Headers::HttpConnectionOptionHeaderValueCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpConnectionOptionHeaderValueCollection", L"Append", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Web::Http::Headers::HttpConnectionOptionHeaderValue>(args, 0);

                self->obj.Append(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpConnectionOptionHeaderValueCollection_Clear(py::wrapper::Windows::Web::Http::Headers::HttpConnectionOptionHeaderValueCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpConnectionOptionHeaderValueCollection", L"Clear", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Clear();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpConnectionOptionHeaderValueCollection_First(py::wrapper::Windows::Web::Http::Headers::HttpConnectionOptionHeaderValueCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpConnectionOptionHeaderValueCollection", L"First", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.First());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpConnectionOptionHeaderValueCollection_GetAt(py::wrapper::Windows::Web::Http::Headers::HttpConnectionOptionHeaderValueCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpConnectionOptionHeaderValueCollection", L"GetAt", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint32_t>(args, 0);

                return py::convert(self->obj.GetAt(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpConnectionOptionHeaderValueCollection_GetMany(py::wrapper::Windows::Web::Http::Headers::HttpConnectionOptionHeaderValueCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpConnectionOptionHeaderValueCollection", L"GetMany", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<winrt::Windows::Web::Http::Headers::HttpConnectionOptionHeaderValue, true>>(args, 1);

                return py::convert(self->obj.GetMany(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpConnectionOptionHeaderValueCollection_GetView(py::wrapper::Windows::Web::Http::Headers::HttpConnectionOptionHeaderValueCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpConnectionOptionHeaderValueCollection", L"GetView", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetView());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpConnectionOptionHeaderValueCollection_IndexOf(py::wrapper::Windows::Web::Http::Headers::HttpConnectionOptionHeaderValueCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpConnectionOptionHeaderValueCollection", L"IndexOf", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Web::Http::Headers::HttpConnectionOptionHeaderValue>(args, 0);
                uint32_t param1 {  };

                auto return_value = self->obj.IndexOf(param0, param1);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out1.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpConnectionOptionHeaderValueCollection_InsertAt(py::wrapper::Windows::Web::Http::Headers::HttpConnectionOptionHeaderValueCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpConnectionOptionHeaderValueCollection", L"InsertAt", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Web::Http::Headers::HttpConnectionOptionHeaderValue>(args, 1);

                self->obj.InsertAt(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpConnectionOptionHeaderValueCollection_ParseAdd(py::wrapper::Windows::Web::Http::Headers::HttpConnectionOptionHeaderValueCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpConnectionOptionHeaderValueCollection", L"ParseAdd", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                self->obj.ParseAdd(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpConnectionOptionHeaderValueCollection_RemoveAt(py::wrapper::Windows::Web::Http::Headers::HttpConnectionOptionHeaderValueCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpConnectionOptionHeaderValueCollection", L"RemoveAt", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint32_t>(args, 0);

                self->obj.RemoveAt(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpConnectionOptionHeaderValueCollection_RemoveAtEnd(py::wrapper::Windows::Web::Http::Headers::HttpConnectionOptionHeaderValueCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpConnectionOptionHeaderValueCollection", L"RemoveAtEnd", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.RemoveAtEnd();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpConnectionOptionHeaderValueCollection_ReplaceAll(py::wrapper::Windows::Web::Http::Headers::HttpConnectionOptionHeaderValueCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpConnectionOptionHeaderValueCollection", L"ReplaceAll", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<py::pybuf_view<winrt::Windows::Web::Http::Headers::HttpConnectionOptionHeaderValue, false>>(args, 0);

                self->obj.ReplaceAll(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpConnectionOptionHeaderValueCollection_SetAt(py::wrapper::Windows::Web::Http::Headers::HttpConnectionOptionHeaderValueCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpConnectionOptionHeaderValueCollection", L"SetAt", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Web::Http::Headers::HttpConnectionOptionHeaderValue>(args, 1);

                self->obj.SetAt(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpConnectionOptionHeaderValueCollection_ToString(py::wrapper::Windows::Web::Http::Headers::HttpConnectionOptionHeaderValueCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpConnectionOptionHeaderValueCollection", L"ToString", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.ToString());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpConnectionOptionHeaderValueCollection_TryParseAdd(py::wrapper::Windows::Web::Http::Headers::HttpConnectionOptionHeaderValueCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpConnectionOptionHeaderValueCollection", L"TryParseAdd", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.TryParseAdd(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpConnectionOptionHeaderValueCollection_get_Size(py::wrapper::Windows::Web::Http::Headers::HttpConnectionOptionHeaderValueCollection* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.Headers.HttpConnectionOptionHeaderValueCollection", L"Size"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_HttpConnectionOptionHeaderValueCollection(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Web::Http::Headers::HttpConnectionOptionHeaderValueCollection>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_HttpConnectionOptionHeaderValueCollection(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Web::Http::Headers::HttpConnectionOptionHeaderValueCollection>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _str_HttpConnectionOptionHeaderValueCollection(py::wrapper::Windows::Web::Http::Headers::HttpConnectionOptionHeaderValueCollection* self) noexcept
    {
        try
        {
            return py::convert(self->obj.ToString());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _iterator_HttpConnectionOptionHeaderValueCollection(py::wrapper::Windows::Web::Http::Headers::HttpConnectionOptionHeaderValueCollection* self) noexcept
    {
        try
        {
            return py::convert(self->obj.First());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static Py_ssize_t _seq_length_HttpConnectionOptionHeaderValueCollection(py::wrapper::Windows::Web::Http::Headers::HttpConnectionOptionHeaderValueCollection* self) noexcept
    {
        try
        {
            return static_cast<Py_ssize_t>(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _seq_item_HttpConnectionOptionHeaderValueCollection(py::wrapper::Windows::Web::Http::Headers::HttpConnectionOptionHeaderValueCollection* self, Py_ssize_t i) noexcept
    {
        try
        {
            return py::convert(self->obj.GetAt(static_cast<uint32_t>(i)));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _seq_subscript_HttpConnectionOptionHeaderValueCollection(py::wrapper::Windows::Web::Http::Headers::HttpConnectionOptionHeaderValueCollection* self, PyObject* slice) noexcept
    {
        try
        {
            if (PyIndex_Check(slice))
            {
                pyobj_handle index{PyNumber_Index(slice)};

                if (!index)
                {
                    return nullptr;
                }

                auto i = PyNumber_AsSsize_t(index.get(), PyExc_IndexError);

                if (i == -1 && PyErr_Occurred())
                {
                    return nullptr;
                }

                return _seq_item_HttpConnectionOptionHeaderValueCollection(self, i);
            }

            if (!PySlice_Check(slice))
            {
                PyErr_Format(
                    PyExc_TypeError,
                    "indicies must be integers, not '%s'",
                    Py_TYPE(slice)->tp_name);
            }

            Py_ssize_t start, stop, step, length;

            if (PySlice_GetIndicesEx(
                    slice, self->obj.Size(), &start, &stop, &step, &length)
                < 0)
            {
                return nullptr;
            }

            if (step != 1)
            {
                PyErr_SetString(PyExc_NotImplementedError, "slices with step other than 1 are not implemented");
                return nullptr;
            }

            winrt::com_array<winrt::Windows::Web::Http::Headers::HttpConnectionOptionHeaderValue> items(static_cast<uint32_t>(length), empty_instance<winrt::Windows::Web::Http::Headers::HttpConnectionOptionHeaderValue>::get());

            auto count = self->obj.GetMany(static_cast<uint32_t>(start), items);

            if (count != static_cast<uint32_t>(length))
            {
                PyErr_Format(PyExc_RuntimeError, "returned count %d did not match requested length %zd", count, length);
                return nullptr;
            }

            return convert(items);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int _seq_assign_HttpConnectionOptionHeaderValueCollection(py::wrapper::Windows::Web::Http::Headers::HttpConnectionOptionHeaderValueCollection* self, Py_ssize_t i, PyObject* value) noexcept
    {
        try
        {
            if (!value)
            {
                self->obj.RemoveAt(static_cast<uint32_t>(i));
            }
            else
            {
                self->obj.SetAt(static_cast<uint32_t>(i), py::convert_to<winrt::Windows::Web::Http::Headers::HttpConnectionOptionHeaderValue>(value));
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyMethodDef _methods_HttpConnectionOptionHeaderValueCollection[] = {
        { "append", reinterpret_cast<PyCFunction>(HttpConnectionOptionHeaderValueCollection_Append), METH_VARARGS, nullptr },
        { "clear", reinterpret_cast<PyCFunction>(HttpConnectionOptionHeaderValueCollection_Clear), METH_VARARGS, nullptr },
        { "first", reinterpret_cast<PyCFunction>(HttpConnectionOptionHeaderValueCollection_First), METH_VARARGS, nullptr },
        { "get_at", reinterpret_cast<PyCFunction>(HttpConnectionOptionHeaderValueCollection_GetAt), METH_VARARGS, nullptr },
        { "get_many", reinterpret_cast<PyCFunction>(HttpConnectionOptionHeaderValueCollection_GetMany), METH_VARARGS, nullptr },
        { "get_view", reinterpret_cast<PyCFunction>(HttpConnectionOptionHeaderValueCollection_GetView), METH_VARARGS, nullptr },
        { "index_of", reinterpret_cast<PyCFunction>(HttpConnectionOptionHeaderValueCollection_IndexOf), METH_VARARGS, nullptr },
        { "insert_at", reinterpret_cast<PyCFunction>(HttpConnectionOptionHeaderValueCollection_InsertAt), METH_VARARGS, nullptr },
        { "parse_add", reinterpret_cast<PyCFunction>(HttpConnectionOptionHeaderValueCollection_ParseAdd), METH_VARARGS, nullptr },
        { "remove_at", reinterpret_cast<PyCFunction>(HttpConnectionOptionHeaderValueCollection_RemoveAt), METH_VARARGS, nullptr },
        { "remove_at_end", reinterpret_cast<PyCFunction>(HttpConnectionOptionHeaderValueCollection_RemoveAtEnd), METH_VARARGS, nullptr },
        { "replace_all", reinterpret_cast<PyCFunction>(HttpConnectionOptionHeaderValueCollection_ReplaceAll), METH_VARARGS, nullptr },
        { "set_at", reinterpret_cast<PyCFunction>(HttpConnectionOptionHeaderValueCollection_SetAt), METH_VARARGS, nullptr },
        { "to_string", reinterpret_cast<PyCFunction>(HttpConnectionOptionHeaderValueCollection_ToString), METH_VARARGS, nullptr },
        { "try_parse_add", reinterpret_cast<PyCFunction>(HttpConnectionOptionHeaderValueCollection_TryParseAdd), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_HttpConnectionOptionHeaderValueCollection, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_HttpConnectionOptionHeaderValueCollection), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_HttpConnectionOptionHeaderValueCollection[] = {
        { "size", reinterpret_cast<getter>(HttpConnectionOptionHeaderValueCollection_get_Size), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_HttpConnectionOptionHeaderValueCollection[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_HttpConnectionOptionHeaderValueCollection) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_HttpConnectionOptionHeaderValueCollection) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_HttpConnectionOptionHeaderValueCollection) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_HttpConnectionOptionHeaderValueCollection) },
        { Py_tp_str, reinterpret_cast<void*>(_str_HttpConnectionOptionHeaderValueCollection) },
        { Py_tp_iter, reinterpret_cast<void*>(_iterator_HttpConnectionOptionHeaderValueCollection) },
        { Py_sq_length, reinterpret_cast<void*>(_seq_length_HttpConnectionOptionHeaderValueCollection) },
        { Py_sq_item, reinterpret_cast<void*>(_seq_item_HttpConnectionOptionHeaderValueCollection) },
        { Py_mp_subscript, reinterpret_cast<void*>(_seq_subscript_HttpConnectionOptionHeaderValueCollection) },
        { Py_sq_ass_item, reinterpret_cast<void*>(_seq_assign_HttpConnectionOptionHeaderValueCollection) },
        { },
    };

    static PyType_Spec type_spec_HttpConnectionOptionHeaderValueCollection =
    {
        "winrt._winrt_windows_web_http_headers.HttpConnectionOptionHeaderValueCollection",
        sizeof(py::wrapper::Windows::Web::Http::Headers::HttpConnectionOptionHeaderValueCollection),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_HttpConnectionOptionHeaderValueCollection
    };

    // ----- HttpContentCodingHeaderValue class --------------------

    static PyObject* _new_HttpContentCodingHeaderValue(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                winrt::Windows::Web::Http::Headers::HttpContentCodingHeaderValue instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_HttpContentCodingHeaderValue(py::wrapper::Windows::Web::Http::Headers::HttpContentCodingHeaderValue* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* HttpContentCodingHeaderValue_Parse(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpContentCodingHeaderValue", L"Parse", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Web::Http::Headers::HttpContentCodingHeaderValue::Parse(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpContentCodingHeaderValue_ToString(py::wrapper::Windows::Web::Http::Headers::HttpContentCodingHeaderValue* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpContentCodingHeaderValue", L"ToString", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.ToString());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpContentCodingHeaderValue_TryParse(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpContentCodingHeaderValue", L"TryParse", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                winrt::Windows::Web::Http::Headers::HttpContentCodingHeaderValue param1 { nullptr };

                auto return_value = winrt::Windows::Web::Http::Headers::HttpContentCodingHeaderValue::TryParse(param0, param1);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out1.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpContentCodingHeaderValue_get_ContentCoding(py::wrapper::Windows::Web::Http::Headers::HttpContentCodingHeaderValue* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.Headers.HttpContentCodingHeaderValue", L"ContentCoding"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ContentCoding());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_HttpContentCodingHeaderValue(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Web::Http::Headers::HttpContentCodingHeaderValue>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_HttpContentCodingHeaderValue(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Web::Http::Headers::HttpContentCodingHeaderValue>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _str_HttpContentCodingHeaderValue(py::wrapper::Windows::Web::Http::Headers::HttpContentCodingHeaderValue* self) noexcept
    {
        try
        {
            return py::convert(self->obj.ToString());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_HttpContentCodingHeaderValue[] = {
        { "to_string", reinterpret_cast<PyCFunction>(HttpContentCodingHeaderValue_ToString), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_HttpContentCodingHeaderValue, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_HttpContentCodingHeaderValue), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_HttpContentCodingHeaderValue[] = {
        { "content_coding", reinterpret_cast<getter>(HttpContentCodingHeaderValue_get_ContentCoding), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_HttpContentCodingHeaderValue[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_HttpContentCodingHeaderValue) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_HttpContentCodingHeaderValue) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_HttpContentCodingHeaderValue) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_HttpContentCodingHeaderValue) },
        { Py_tp_str, reinterpret_cast<void*>(_str_HttpContentCodingHeaderValue) },
        { },
    };

    static PyType_Spec type_spec_HttpContentCodingHeaderValue =
    {
        "winrt._winrt_windows_web_http_headers.HttpContentCodingHeaderValue",
        sizeof(py::wrapper::Windows::Web::Http::Headers::HttpContentCodingHeaderValue),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_HttpContentCodingHeaderValue
    };

    static PyGetSetDef getset_HttpContentCodingHeaderValue_Static[] = {
        { }
    };

    static PyMethodDef methods_HttpContentCodingHeaderValue_Static[] = {
        { "parse", reinterpret_cast<PyCFunction>(HttpContentCodingHeaderValue_Parse), METH_VARARGS, nullptr },
        { "try_parse", reinterpret_cast<PyCFunction>(HttpContentCodingHeaderValue_TryParse), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_HttpContentCodingHeaderValue_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_HttpContentCodingHeaderValue_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_HttpContentCodingHeaderValue_Static) },
        { }
    };

    static PyType_Spec type_spec_HttpContentCodingHeaderValue_Static =
    {
        "winrt._winrt_windows_web_http_headers.HttpContentCodingHeaderValue_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_HttpContentCodingHeaderValue_Static
    };

    // ----- HttpContentCodingHeaderValueCollection class --------------------

    static PyObject* _new_HttpContentCodingHeaderValueCollection(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Web::Http::Headers::HttpContentCodingHeaderValueCollection>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Web::Http::Headers::HttpContentCodingHeaderValueCollection>::type_name);
        return nullptr;
    }

    static void _dealloc_HttpContentCodingHeaderValueCollection(py::wrapper::Windows::Web::Http::Headers::HttpContentCodingHeaderValueCollection* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* HttpContentCodingHeaderValueCollection_Append(py::wrapper::Windows::Web::Http::Headers::HttpContentCodingHeaderValueCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpContentCodingHeaderValueCollection", L"Append", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Web::Http::Headers::HttpContentCodingHeaderValue>(args, 0);

                self->obj.Append(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpContentCodingHeaderValueCollection_Clear(py::wrapper::Windows::Web::Http::Headers::HttpContentCodingHeaderValueCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpContentCodingHeaderValueCollection", L"Clear", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Clear();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpContentCodingHeaderValueCollection_First(py::wrapper::Windows::Web::Http::Headers::HttpContentCodingHeaderValueCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpContentCodingHeaderValueCollection", L"First", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.First());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpContentCodingHeaderValueCollection_GetAt(py::wrapper::Windows::Web::Http::Headers::HttpContentCodingHeaderValueCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpContentCodingHeaderValueCollection", L"GetAt", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint32_t>(args, 0);

                return py::convert(self->obj.GetAt(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpContentCodingHeaderValueCollection_GetMany(py::wrapper::Windows::Web::Http::Headers::HttpContentCodingHeaderValueCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpContentCodingHeaderValueCollection", L"GetMany", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<winrt::Windows::Web::Http::Headers::HttpContentCodingHeaderValue, true>>(args, 1);

                return py::convert(self->obj.GetMany(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpContentCodingHeaderValueCollection_GetView(py::wrapper::Windows::Web::Http::Headers::HttpContentCodingHeaderValueCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpContentCodingHeaderValueCollection", L"GetView", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetView());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpContentCodingHeaderValueCollection_IndexOf(py::wrapper::Windows::Web::Http::Headers::HttpContentCodingHeaderValueCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpContentCodingHeaderValueCollection", L"IndexOf", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Web::Http::Headers::HttpContentCodingHeaderValue>(args, 0);
                uint32_t param1 {  };

                auto return_value = self->obj.IndexOf(param0, param1);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out1.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpContentCodingHeaderValueCollection_InsertAt(py::wrapper::Windows::Web::Http::Headers::HttpContentCodingHeaderValueCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpContentCodingHeaderValueCollection", L"InsertAt", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Web::Http::Headers::HttpContentCodingHeaderValue>(args, 1);

                self->obj.InsertAt(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpContentCodingHeaderValueCollection_ParseAdd(py::wrapper::Windows::Web::Http::Headers::HttpContentCodingHeaderValueCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpContentCodingHeaderValueCollection", L"ParseAdd", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                self->obj.ParseAdd(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpContentCodingHeaderValueCollection_RemoveAt(py::wrapper::Windows::Web::Http::Headers::HttpContentCodingHeaderValueCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpContentCodingHeaderValueCollection", L"RemoveAt", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint32_t>(args, 0);

                self->obj.RemoveAt(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpContentCodingHeaderValueCollection_RemoveAtEnd(py::wrapper::Windows::Web::Http::Headers::HttpContentCodingHeaderValueCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpContentCodingHeaderValueCollection", L"RemoveAtEnd", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.RemoveAtEnd();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpContentCodingHeaderValueCollection_ReplaceAll(py::wrapper::Windows::Web::Http::Headers::HttpContentCodingHeaderValueCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpContentCodingHeaderValueCollection", L"ReplaceAll", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<py::pybuf_view<winrt::Windows::Web::Http::Headers::HttpContentCodingHeaderValue, false>>(args, 0);

                self->obj.ReplaceAll(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpContentCodingHeaderValueCollection_SetAt(py::wrapper::Windows::Web::Http::Headers::HttpContentCodingHeaderValueCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpContentCodingHeaderValueCollection", L"SetAt", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Web::Http::Headers::HttpContentCodingHeaderValue>(args, 1);

                self->obj.SetAt(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpContentCodingHeaderValueCollection_ToString(py::wrapper::Windows::Web::Http::Headers::HttpContentCodingHeaderValueCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpContentCodingHeaderValueCollection", L"ToString", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.ToString());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpContentCodingHeaderValueCollection_TryParseAdd(py::wrapper::Windows::Web::Http::Headers::HttpContentCodingHeaderValueCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpContentCodingHeaderValueCollection", L"TryParseAdd", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.TryParseAdd(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpContentCodingHeaderValueCollection_get_Size(py::wrapper::Windows::Web::Http::Headers::HttpContentCodingHeaderValueCollection* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.Headers.HttpContentCodingHeaderValueCollection", L"Size"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_HttpContentCodingHeaderValueCollection(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Web::Http::Headers::HttpContentCodingHeaderValueCollection>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_HttpContentCodingHeaderValueCollection(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Web::Http::Headers::HttpContentCodingHeaderValueCollection>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _str_HttpContentCodingHeaderValueCollection(py::wrapper::Windows::Web::Http::Headers::HttpContentCodingHeaderValueCollection* self) noexcept
    {
        try
        {
            return py::convert(self->obj.ToString());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _iterator_HttpContentCodingHeaderValueCollection(py::wrapper::Windows::Web::Http::Headers::HttpContentCodingHeaderValueCollection* self) noexcept
    {
        try
        {
            return py::convert(self->obj.First());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static Py_ssize_t _seq_length_HttpContentCodingHeaderValueCollection(py::wrapper::Windows::Web::Http::Headers::HttpContentCodingHeaderValueCollection* self) noexcept
    {
        try
        {
            return static_cast<Py_ssize_t>(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _seq_item_HttpContentCodingHeaderValueCollection(py::wrapper::Windows::Web::Http::Headers::HttpContentCodingHeaderValueCollection* self, Py_ssize_t i) noexcept
    {
        try
        {
            return py::convert(self->obj.GetAt(static_cast<uint32_t>(i)));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _seq_subscript_HttpContentCodingHeaderValueCollection(py::wrapper::Windows::Web::Http::Headers::HttpContentCodingHeaderValueCollection* self, PyObject* slice) noexcept
    {
        try
        {
            if (PyIndex_Check(slice))
            {
                pyobj_handle index{PyNumber_Index(slice)};

                if (!index)
                {
                    return nullptr;
                }

                auto i = PyNumber_AsSsize_t(index.get(), PyExc_IndexError);

                if (i == -1 && PyErr_Occurred())
                {
                    return nullptr;
                }

                return _seq_item_HttpContentCodingHeaderValueCollection(self, i);
            }

            if (!PySlice_Check(slice))
            {
                PyErr_Format(
                    PyExc_TypeError,
                    "indicies must be integers, not '%s'",
                    Py_TYPE(slice)->tp_name);
            }

            Py_ssize_t start, stop, step, length;

            if (PySlice_GetIndicesEx(
                    slice, self->obj.Size(), &start, &stop, &step, &length)
                < 0)
            {
                return nullptr;
            }

            if (step != 1)
            {
                PyErr_SetString(PyExc_NotImplementedError, "slices with step other than 1 are not implemented");
                return nullptr;
            }

            winrt::com_array<winrt::Windows::Web::Http::Headers::HttpContentCodingHeaderValue> items(static_cast<uint32_t>(length), empty_instance<winrt::Windows::Web::Http::Headers::HttpContentCodingHeaderValue>::get());

            auto count = self->obj.GetMany(static_cast<uint32_t>(start), items);

            if (count != static_cast<uint32_t>(length))
            {
                PyErr_Format(PyExc_RuntimeError, "returned count %d did not match requested length %zd", count, length);
                return nullptr;
            }

            return convert(items);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int _seq_assign_HttpContentCodingHeaderValueCollection(py::wrapper::Windows::Web::Http::Headers::HttpContentCodingHeaderValueCollection* self, Py_ssize_t i, PyObject* value) noexcept
    {
        try
        {
            if (!value)
            {
                self->obj.RemoveAt(static_cast<uint32_t>(i));
            }
            else
            {
                self->obj.SetAt(static_cast<uint32_t>(i), py::convert_to<winrt::Windows::Web::Http::Headers::HttpContentCodingHeaderValue>(value));
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyMethodDef _methods_HttpContentCodingHeaderValueCollection[] = {
        { "append", reinterpret_cast<PyCFunction>(HttpContentCodingHeaderValueCollection_Append), METH_VARARGS, nullptr },
        { "clear", reinterpret_cast<PyCFunction>(HttpContentCodingHeaderValueCollection_Clear), METH_VARARGS, nullptr },
        { "first", reinterpret_cast<PyCFunction>(HttpContentCodingHeaderValueCollection_First), METH_VARARGS, nullptr },
        { "get_at", reinterpret_cast<PyCFunction>(HttpContentCodingHeaderValueCollection_GetAt), METH_VARARGS, nullptr },
        { "get_many", reinterpret_cast<PyCFunction>(HttpContentCodingHeaderValueCollection_GetMany), METH_VARARGS, nullptr },
        { "get_view", reinterpret_cast<PyCFunction>(HttpContentCodingHeaderValueCollection_GetView), METH_VARARGS, nullptr },
        { "index_of", reinterpret_cast<PyCFunction>(HttpContentCodingHeaderValueCollection_IndexOf), METH_VARARGS, nullptr },
        { "insert_at", reinterpret_cast<PyCFunction>(HttpContentCodingHeaderValueCollection_InsertAt), METH_VARARGS, nullptr },
        { "parse_add", reinterpret_cast<PyCFunction>(HttpContentCodingHeaderValueCollection_ParseAdd), METH_VARARGS, nullptr },
        { "remove_at", reinterpret_cast<PyCFunction>(HttpContentCodingHeaderValueCollection_RemoveAt), METH_VARARGS, nullptr },
        { "remove_at_end", reinterpret_cast<PyCFunction>(HttpContentCodingHeaderValueCollection_RemoveAtEnd), METH_VARARGS, nullptr },
        { "replace_all", reinterpret_cast<PyCFunction>(HttpContentCodingHeaderValueCollection_ReplaceAll), METH_VARARGS, nullptr },
        { "set_at", reinterpret_cast<PyCFunction>(HttpContentCodingHeaderValueCollection_SetAt), METH_VARARGS, nullptr },
        { "to_string", reinterpret_cast<PyCFunction>(HttpContentCodingHeaderValueCollection_ToString), METH_VARARGS, nullptr },
        { "try_parse_add", reinterpret_cast<PyCFunction>(HttpContentCodingHeaderValueCollection_TryParseAdd), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_HttpContentCodingHeaderValueCollection, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_HttpContentCodingHeaderValueCollection), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_HttpContentCodingHeaderValueCollection[] = {
        { "size", reinterpret_cast<getter>(HttpContentCodingHeaderValueCollection_get_Size), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_HttpContentCodingHeaderValueCollection[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_HttpContentCodingHeaderValueCollection) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_HttpContentCodingHeaderValueCollection) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_HttpContentCodingHeaderValueCollection) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_HttpContentCodingHeaderValueCollection) },
        { Py_tp_str, reinterpret_cast<void*>(_str_HttpContentCodingHeaderValueCollection) },
        { Py_tp_iter, reinterpret_cast<void*>(_iterator_HttpContentCodingHeaderValueCollection) },
        { Py_sq_length, reinterpret_cast<void*>(_seq_length_HttpContentCodingHeaderValueCollection) },
        { Py_sq_item, reinterpret_cast<void*>(_seq_item_HttpContentCodingHeaderValueCollection) },
        { Py_mp_subscript, reinterpret_cast<void*>(_seq_subscript_HttpContentCodingHeaderValueCollection) },
        { Py_sq_ass_item, reinterpret_cast<void*>(_seq_assign_HttpContentCodingHeaderValueCollection) },
        { },
    };

    static PyType_Spec type_spec_HttpContentCodingHeaderValueCollection =
    {
        "winrt._winrt_windows_web_http_headers.HttpContentCodingHeaderValueCollection",
        sizeof(py::wrapper::Windows::Web::Http::Headers::HttpContentCodingHeaderValueCollection),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_HttpContentCodingHeaderValueCollection
    };

    // ----- HttpContentCodingWithQualityHeaderValue class --------------------

    static PyObject* _new_HttpContentCodingWithQualityHeaderValue(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                winrt::Windows::Web::Http::Headers::HttpContentCodingWithQualityHeaderValue instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<double>(args, 1);

                winrt::Windows::Web::Http::Headers::HttpContentCodingWithQualityHeaderValue instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_HttpContentCodingWithQualityHeaderValue(py::wrapper::Windows::Web::Http::Headers::HttpContentCodingWithQualityHeaderValue* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* HttpContentCodingWithQualityHeaderValue_Parse(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpContentCodingWithQualityHeaderValue", L"Parse", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Web::Http::Headers::HttpContentCodingWithQualityHeaderValue::Parse(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpContentCodingWithQualityHeaderValue_ToString(py::wrapper::Windows::Web::Http::Headers::HttpContentCodingWithQualityHeaderValue* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpContentCodingWithQualityHeaderValue", L"ToString", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.ToString());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpContentCodingWithQualityHeaderValue_TryParse(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpContentCodingWithQualityHeaderValue", L"TryParse", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                winrt::Windows::Web::Http::Headers::HttpContentCodingWithQualityHeaderValue param1 { nullptr };

                auto return_value = winrt::Windows::Web::Http::Headers::HttpContentCodingWithQualityHeaderValue::TryParse(param0, param1);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out1.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpContentCodingWithQualityHeaderValue_get_ContentCoding(py::wrapper::Windows::Web::Http::Headers::HttpContentCodingWithQualityHeaderValue* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.Headers.HttpContentCodingWithQualityHeaderValue", L"ContentCoding"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ContentCoding());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HttpContentCodingWithQualityHeaderValue_get_Quality(py::wrapper::Windows::Web::Http::Headers::HttpContentCodingWithQualityHeaderValue* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.Headers.HttpContentCodingWithQualityHeaderValue", L"Quality"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Quality());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_HttpContentCodingWithQualityHeaderValue(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Web::Http::Headers::HttpContentCodingWithQualityHeaderValue>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_HttpContentCodingWithQualityHeaderValue(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Web::Http::Headers::HttpContentCodingWithQualityHeaderValue>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _str_HttpContentCodingWithQualityHeaderValue(py::wrapper::Windows::Web::Http::Headers::HttpContentCodingWithQualityHeaderValue* self) noexcept
    {
        try
        {
            return py::convert(self->obj.ToString());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_HttpContentCodingWithQualityHeaderValue[] = {
        { "to_string", reinterpret_cast<PyCFunction>(HttpContentCodingWithQualityHeaderValue_ToString), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_HttpContentCodingWithQualityHeaderValue, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_HttpContentCodingWithQualityHeaderValue), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_HttpContentCodingWithQualityHeaderValue[] = {
        { "content_coding", reinterpret_cast<getter>(HttpContentCodingWithQualityHeaderValue_get_ContentCoding), nullptr, nullptr, nullptr },
        { "quality", reinterpret_cast<getter>(HttpContentCodingWithQualityHeaderValue_get_Quality), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_HttpContentCodingWithQualityHeaderValue[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_HttpContentCodingWithQualityHeaderValue) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_HttpContentCodingWithQualityHeaderValue) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_HttpContentCodingWithQualityHeaderValue) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_HttpContentCodingWithQualityHeaderValue) },
        { Py_tp_str, reinterpret_cast<void*>(_str_HttpContentCodingWithQualityHeaderValue) },
        { },
    };

    static PyType_Spec type_spec_HttpContentCodingWithQualityHeaderValue =
    {
        "winrt._winrt_windows_web_http_headers.HttpContentCodingWithQualityHeaderValue",
        sizeof(py::wrapper::Windows::Web::Http::Headers::HttpContentCodingWithQualityHeaderValue),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_HttpContentCodingWithQualityHeaderValue
    };

    static PyGetSetDef getset_HttpContentCodingWithQualityHeaderValue_Static[] = {
        { }
    };

    static PyMethodDef methods_HttpContentCodingWithQualityHeaderValue_Static[] = {
        { "parse", reinterpret_cast<PyCFunction>(HttpContentCodingWithQualityHeaderValue_Parse), METH_VARARGS, nullptr },
        { "try_parse", reinterpret_cast<PyCFunction>(HttpContentCodingWithQualityHeaderValue_TryParse), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_HttpContentCodingWithQualityHeaderValue_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_HttpContentCodingWithQualityHeaderValue_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_HttpContentCodingWithQualityHeaderValue_Static) },
        { }
    };

    static PyType_Spec type_spec_HttpContentCodingWithQualityHeaderValue_Static =
    {
        "winrt._winrt_windows_web_http_headers.HttpContentCodingWithQualityHeaderValue_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_HttpContentCodingWithQualityHeaderValue_Static
    };

    // ----- HttpContentCodingWithQualityHeaderValueCollection class --------------------

    static PyObject* _new_HttpContentCodingWithQualityHeaderValueCollection(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Web::Http::Headers::HttpContentCodingWithQualityHeaderValueCollection>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Web::Http::Headers::HttpContentCodingWithQualityHeaderValueCollection>::type_name);
        return nullptr;
    }

    static void _dealloc_HttpContentCodingWithQualityHeaderValueCollection(py::wrapper::Windows::Web::Http::Headers::HttpContentCodingWithQualityHeaderValueCollection* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* HttpContentCodingWithQualityHeaderValueCollection_Append(py::wrapper::Windows::Web::Http::Headers::HttpContentCodingWithQualityHeaderValueCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpContentCodingWithQualityHeaderValueCollection", L"Append", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Web::Http::Headers::HttpContentCodingWithQualityHeaderValue>(args, 0);

                self->obj.Append(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpContentCodingWithQualityHeaderValueCollection_Clear(py::wrapper::Windows::Web::Http::Headers::HttpContentCodingWithQualityHeaderValueCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpContentCodingWithQualityHeaderValueCollection", L"Clear", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Clear();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpContentCodingWithQualityHeaderValueCollection_First(py::wrapper::Windows::Web::Http::Headers::HttpContentCodingWithQualityHeaderValueCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpContentCodingWithQualityHeaderValueCollection", L"First", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.First());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpContentCodingWithQualityHeaderValueCollection_GetAt(py::wrapper::Windows::Web::Http::Headers::HttpContentCodingWithQualityHeaderValueCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpContentCodingWithQualityHeaderValueCollection", L"GetAt", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint32_t>(args, 0);

                return py::convert(self->obj.GetAt(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpContentCodingWithQualityHeaderValueCollection_GetMany(py::wrapper::Windows::Web::Http::Headers::HttpContentCodingWithQualityHeaderValueCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpContentCodingWithQualityHeaderValueCollection", L"GetMany", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<winrt::Windows::Web::Http::Headers::HttpContentCodingWithQualityHeaderValue, true>>(args, 1);

                return py::convert(self->obj.GetMany(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpContentCodingWithQualityHeaderValueCollection_GetView(py::wrapper::Windows::Web::Http::Headers::HttpContentCodingWithQualityHeaderValueCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpContentCodingWithQualityHeaderValueCollection", L"GetView", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetView());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpContentCodingWithQualityHeaderValueCollection_IndexOf(py::wrapper::Windows::Web::Http::Headers::HttpContentCodingWithQualityHeaderValueCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpContentCodingWithQualityHeaderValueCollection", L"IndexOf", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Web::Http::Headers::HttpContentCodingWithQualityHeaderValue>(args, 0);
                uint32_t param1 {  };

                auto return_value = self->obj.IndexOf(param0, param1);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out1.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpContentCodingWithQualityHeaderValueCollection_InsertAt(py::wrapper::Windows::Web::Http::Headers::HttpContentCodingWithQualityHeaderValueCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpContentCodingWithQualityHeaderValueCollection", L"InsertAt", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Web::Http::Headers::HttpContentCodingWithQualityHeaderValue>(args, 1);

                self->obj.InsertAt(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpContentCodingWithQualityHeaderValueCollection_ParseAdd(py::wrapper::Windows::Web::Http::Headers::HttpContentCodingWithQualityHeaderValueCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpContentCodingWithQualityHeaderValueCollection", L"ParseAdd", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                self->obj.ParseAdd(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpContentCodingWithQualityHeaderValueCollection_RemoveAt(py::wrapper::Windows::Web::Http::Headers::HttpContentCodingWithQualityHeaderValueCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpContentCodingWithQualityHeaderValueCollection", L"RemoveAt", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint32_t>(args, 0);

                self->obj.RemoveAt(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpContentCodingWithQualityHeaderValueCollection_RemoveAtEnd(py::wrapper::Windows::Web::Http::Headers::HttpContentCodingWithQualityHeaderValueCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpContentCodingWithQualityHeaderValueCollection", L"RemoveAtEnd", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.RemoveAtEnd();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpContentCodingWithQualityHeaderValueCollection_ReplaceAll(py::wrapper::Windows::Web::Http::Headers::HttpContentCodingWithQualityHeaderValueCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpContentCodingWithQualityHeaderValueCollection", L"ReplaceAll", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<py::pybuf_view<winrt::Windows::Web::Http::Headers::HttpContentCodingWithQualityHeaderValue, false>>(args, 0);

                self->obj.ReplaceAll(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpContentCodingWithQualityHeaderValueCollection_SetAt(py::wrapper::Windows::Web::Http::Headers::HttpContentCodingWithQualityHeaderValueCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpContentCodingWithQualityHeaderValueCollection", L"SetAt", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Web::Http::Headers::HttpContentCodingWithQualityHeaderValue>(args, 1);

                self->obj.SetAt(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpContentCodingWithQualityHeaderValueCollection_ToString(py::wrapper::Windows::Web::Http::Headers::HttpContentCodingWithQualityHeaderValueCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpContentCodingWithQualityHeaderValueCollection", L"ToString", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.ToString());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpContentCodingWithQualityHeaderValueCollection_TryParseAdd(py::wrapper::Windows::Web::Http::Headers::HttpContentCodingWithQualityHeaderValueCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpContentCodingWithQualityHeaderValueCollection", L"TryParseAdd", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.TryParseAdd(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpContentCodingWithQualityHeaderValueCollection_get_Size(py::wrapper::Windows::Web::Http::Headers::HttpContentCodingWithQualityHeaderValueCollection* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.Headers.HttpContentCodingWithQualityHeaderValueCollection", L"Size"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_HttpContentCodingWithQualityHeaderValueCollection(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Web::Http::Headers::HttpContentCodingWithQualityHeaderValueCollection>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_HttpContentCodingWithQualityHeaderValueCollection(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Web::Http::Headers::HttpContentCodingWithQualityHeaderValueCollection>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _str_HttpContentCodingWithQualityHeaderValueCollection(py::wrapper::Windows::Web::Http::Headers::HttpContentCodingWithQualityHeaderValueCollection* self) noexcept
    {
        try
        {
            return py::convert(self->obj.ToString());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _iterator_HttpContentCodingWithQualityHeaderValueCollection(py::wrapper::Windows::Web::Http::Headers::HttpContentCodingWithQualityHeaderValueCollection* self) noexcept
    {
        try
        {
            return py::convert(self->obj.First());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static Py_ssize_t _seq_length_HttpContentCodingWithQualityHeaderValueCollection(py::wrapper::Windows::Web::Http::Headers::HttpContentCodingWithQualityHeaderValueCollection* self) noexcept
    {
        try
        {
            return static_cast<Py_ssize_t>(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _seq_item_HttpContentCodingWithQualityHeaderValueCollection(py::wrapper::Windows::Web::Http::Headers::HttpContentCodingWithQualityHeaderValueCollection* self, Py_ssize_t i) noexcept
    {
        try
        {
            return py::convert(self->obj.GetAt(static_cast<uint32_t>(i)));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _seq_subscript_HttpContentCodingWithQualityHeaderValueCollection(py::wrapper::Windows::Web::Http::Headers::HttpContentCodingWithQualityHeaderValueCollection* self, PyObject* slice) noexcept
    {
        try
        {
            if (PyIndex_Check(slice))
            {
                pyobj_handle index{PyNumber_Index(slice)};

                if (!index)
                {
                    return nullptr;
                }

                auto i = PyNumber_AsSsize_t(index.get(), PyExc_IndexError);

                if (i == -1 && PyErr_Occurred())
                {
                    return nullptr;
                }

                return _seq_item_HttpContentCodingWithQualityHeaderValueCollection(self, i);
            }

            if (!PySlice_Check(slice))
            {
                PyErr_Format(
                    PyExc_TypeError,
                    "indicies must be integers, not '%s'",
                    Py_TYPE(slice)->tp_name);
            }

            Py_ssize_t start, stop, step, length;

            if (PySlice_GetIndicesEx(
                    slice, self->obj.Size(), &start, &stop, &step, &length)
                < 0)
            {
                return nullptr;
            }

            if (step != 1)
            {
                PyErr_SetString(PyExc_NotImplementedError, "slices with step other than 1 are not implemented");
                return nullptr;
            }

            winrt::com_array<winrt::Windows::Web::Http::Headers::HttpContentCodingWithQualityHeaderValue> items(static_cast<uint32_t>(length), empty_instance<winrt::Windows::Web::Http::Headers::HttpContentCodingWithQualityHeaderValue>::get());

            auto count = self->obj.GetMany(static_cast<uint32_t>(start), items);

            if (count != static_cast<uint32_t>(length))
            {
                PyErr_Format(PyExc_RuntimeError, "returned count %d did not match requested length %zd", count, length);
                return nullptr;
            }

            return convert(items);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int _seq_assign_HttpContentCodingWithQualityHeaderValueCollection(py::wrapper::Windows::Web::Http::Headers::HttpContentCodingWithQualityHeaderValueCollection* self, Py_ssize_t i, PyObject* value) noexcept
    {
        try
        {
            if (!value)
            {
                self->obj.RemoveAt(static_cast<uint32_t>(i));
            }
            else
            {
                self->obj.SetAt(static_cast<uint32_t>(i), py::convert_to<winrt::Windows::Web::Http::Headers::HttpContentCodingWithQualityHeaderValue>(value));
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyMethodDef _methods_HttpContentCodingWithQualityHeaderValueCollection[] = {
        { "append", reinterpret_cast<PyCFunction>(HttpContentCodingWithQualityHeaderValueCollection_Append), METH_VARARGS, nullptr },
        { "clear", reinterpret_cast<PyCFunction>(HttpContentCodingWithQualityHeaderValueCollection_Clear), METH_VARARGS, nullptr },
        { "first", reinterpret_cast<PyCFunction>(HttpContentCodingWithQualityHeaderValueCollection_First), METH_VARARGS, nullptr },
        { "get_at", reinterpret_cast<PyCFunction>(HttpContentCodingWithQualityHeaderValueCollection_GetAt), METH_VARARGS, nullptr },
        { "get_many", reinterpret_cast<PyCFunction>(HttpContentCodingWithQualityHeaderValueCollection_GetMany), METH_VARARGS, nullptr },
        { "get_view", reinterpret_cast<PyCFunction>(HttpContentCodingWithQualityHeaderValueCollection_GetView), METH_VARARGS, nullptr },
        { "index_of", reinterpret_cast<PyCFunction>(HttpContentCodingWithQualityHeaderValueCollection_IndexOf), METH_VARARGS, nullptr },
        { "insert_at", reinterpret_cast<PyCFunction>(HttpContentCodingWithQualityHeaderValueCollection_InsertAt), METH_VARARGS, nullptr },
        { "parse_add", reinterpret_cast<PyCFunction>(HttpContentCodingWithQualityHeaderValueCollection_ParseAdd), METH_VARARGS, nullptr },
        { "remove_at", reinterpret_cast<PyCFunction>(HttpContentCodingWithQualityHeaderValueCollection_RemoveAt), METH_VARARGS, nullptr },
        { "remove_at_end", reinterpret_cast<PyCFunction>(HttpContentCodingWithQualityHeaderValueCollection_RemoveAtEnd), METH_VARARGS, nullptr },
        { "replace_all", reinterpret_cast<PyCFunction>(HttpContentCodingWithQualityHeaderValueCollection_ReplaceAll), METH_VARARGS, nullptr },
        { "set_at", reinterpret_cast<PyCFunction>(HttpContentCodingWithQualityHeaderValueCollection_SetAt), METH_VARARGS, nullptr },
        { "to_string", reinterpret_cast<PyCFunction>(HttpContentCodingWithQualityHeaderValueCollection_ToString), METH_VARARGS, nullptr },
        { "try_parse_add", reinterpret_cast<PyCFunction>(HttpContentCodingWithQualityHeaderValueCollection_TryParseAdd), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_HttpContentCodingWithQualityHeaderValueCollection, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_HttpContentCodingWithQualityHeaderValueCollection), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_HttpContentCodingWithQualityHeaderValueCollection[] = {
        { "size", reinterpret_cast<getter>(HttpContentCodingWithQualityHeaderValueCollection_get_Size), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_HttpContentCodingWithQualityHeaderValueCollection[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_HttpContentCodingWithQualityHeaderValueCollection) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_HttpContentCodingWithQualityHeaderValueCollection) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_HttpContentCodingWithQualityHeaderValueCollection) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_HttpContentCodingWithQualityHeaderValueCollection) },
        { Py_tp_str, reinterpret_cast<void*>(_str_HttpContentCodingWithQualityHeaderValueCollection) },
        { Py_tp_iter, reinterpret_cast<void*>(_iterator_HttpContentCodingWithQualityHeaderValueCollection) },
        { Py_sq_length, reinterpret_cast<void*>(_seq_length_HttpContentCodingWithQualityHeaderValueCollection) },
        { Py_sq_item, reinterpret_cast<void*>(_seq_item_HttpContentCodingWithQualityHeaderValueCollection) },
        { Py_mp_subscript, reinterpret_cast<void*>(_seq_subscript_HttpContentCodingWithQualityHeaderValueCollection) },
        { Py_sq_ass_item, reinterpret_cast<void*>(_seq_assign_HttpContentCodingWithQualityHeaderValueCollection) },
        { },
    };

    static PyType_Spec type_spec_HttpContentCodingWithQualityHeaderValueCollection =
    {
        "winrt._winrt_windows_web_http_headers.HttpContentCodingWithQualityHeaderValueCollection",
        sizeof(py::wrapper::Windows::Web::Http::Headers::HttpContentCodingWithQualityHeaderValueCollection),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_HttpContentCodingWithQualityHeaderValueCollection
    };

    // ----- HttpContentDispositionHeaderValue class --------------------

    static PyObject* _new_HttpContentDispositionHeaderValue(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                winrt::Windows::Web::Http::Headers::HttpContentDispositionHeaderValue instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_HttpContentDispositionHeaderValue(py::wrapper::Windows::Web::Http::Headers::HttpContentDispositionHeaderValue* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* HttpContentDispositionHeaderValue_Parse(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpContentDispositionHeaderValue", L"Parse", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Web::Http::Headers::HttpContentDispositionHeaderValue::Parse(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpContentDispositionHeaderValue_ToString(py::wrapper::Windows::Web::Http::Headers::HttpContentDispositionHeaderValue* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpContentDispositionHeaderValue", L"ToString", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.ToString());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpContentDispositionHeaderValue_TryParse(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpContentDispositionHeaderValue", L"TryParse", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                winrt::Windows::Web::Http::Headers::HttpContentDispositionHeaderValue param1 { nullptr };

                auto return_value = winrt::Windows::Web::Http::Headers::HttpContentDispositionHeaderValue::TryParse(param0, param1);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out1.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpContentDispositionHeaderValue_get_Size(py::wrapper::Windows::Web::Http::Headers::HttpContentDispositionHeaderValue* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.Headers.HttpContentDispositionHeaderValue", L"Size"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int HttpContentDispositionHeaderValue_put_Size(py::wrapper::Windows::Web::Http::Headers::HttpContentDispositionHeaderValue* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.Headers.HttpContentDispositionHeaderValue", L"Size"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<uint64_t>>(arg);

            self->obj.Size(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* HttpContentDispositionHeaderValue_get_Name(py::wrapper::Windows::Web::Http::Headers::HttpContentDispositionHeaderValue* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.Headers.HttpContentDispositionHeaderValue", L"Name"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Name());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int HttpContentDispositionHeaderValue_put_Name(py::wrapper::Windows::Web::Http::Headers::HttpContentDispositionHeaderValue* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.Headers.HttpContentDispositionHeaderValue", L"Name"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Name(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* HttpContentDispositionHeaderValue_get_FileNameStar(py::wrapper::Windows::Web::Http::Headers::HttpContentDispositionHeaderValue* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.Headers.HttpContentDispositionHeaderValue", L"FileNameStar"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.FileNameStar());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int HttpContentDispositionHeaderValue_put_FileNameStar(py::wrapper::Windows::Web::Http::Headers::HttpContentDispositionHeaderValue* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.Headers.HttpContentDispositionHeaderValue", L"FileNameStar"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.FileNameStar(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* HttpContentDispositionHeaderValue_get_FileName(py::wrapper::Windows::Web::Http::Headers::HttpContentDispositionHeaderValue* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.Headers.HttpContentDispositionHeaderValue", L"FileName"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.FileName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int HttpContentDispositionHeaderValue_put_FileName(py::wrapper::Windows::Web::Http::Headers::HttpContentDispositionHeaderValue* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.Headers.HttpContentDispositionHeaderValue", L"FileName"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.FileName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* HttpContentDispositionHeaderValue_get_DispositionType(py::wrapper::Windows::Web::Http::Headers::HttpContentDispositionHeaderValue* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.Headers.HttpContentDispositionHeaderValue", L"DispositionType"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DispositionType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int HttpContentDispositionHeaderValue_put_DispositionType(py::wrapper::Windows::Web::Http::Headers::HttpContentDispositionHeaderValue* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.Headers.HttpContentDispositionHeaderValue", L"DispositionType"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.DispositionType(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* HttpContentDispositionHeaderValue_get_Parameters(py::wrapper::Windows::Web::Http::Headers::HttpContentDispositionHeaderValue* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.Headers.HttpContentDispositionHeaderValue", L"Parameters"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Parameters());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_HttpContentDispositionHeaderValue(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Web::Http::Headers::HttpContentDispositionHeaderValue>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_HttpContentDispositionHeaderValue(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Web::Http::Headers::HttpContentDispositionHeaderValue>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _str_HttpContentDispositionHeaderValue(py::wrapper::Windows::Web::Http::Headers::HttpContentDispositionHeaderValue* self) noexcept
    {
        try
        {
            return py::convert(self->obj.ToString());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_HttpContentDispositionHeaderValue[] = {
        { "to_string", reinterpret_cast<PyCFunction>(HttpContentDispositionHeaderValue_ToString), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_HttpContentDispositionHeaderValue, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_HttpContentDispositionHeaderValue), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_HttpContentDispositionHeaderValue[] = {
        { "size", reinterpret_cast<getter>(HttpContentDispositionHeaderValue_get_Size), reinterpret_cast<setter>(HttpContentDispositionHeaderValue_put_Size), nullptr, nullptr },
        { "name", reinterpret_cast<getter>(HttpContentDispositionHeaderValue_get_Name), reinterpret_cast<setter>(HttpContentDispositionHeaderValue_put_Name), nullptr, nullptr },
        { "file_name_star", reinterpret_cast<getter>(HttpContentDispositionHeaderValue_get_FileNameStar), reinterpret_cast<setter>(HttpContentDispositionHeaderValue_put_FileNameStar), nullptr, nullptr },
        { "file_name", reinterpret_cast<getter>(HttpContentDispositionHeaderValue_get_FileName), reinterpret_cast<setter>(HttpContentDispositionHeaderValue_put_FileName), nullptr, nullptr },
        { "disposition_type", reinterpret_cast<getter>(HttpContentDispositionHeaderValue_get_DispositionType), reinterpret_cast<setter>(HttpContentDispositionHeaderValue_put_DispositionType), nullptr, nullptr },
        { "parameters", reinterpret_cast<getter>(HttpContentDispositionHeaderValue_get_Parameters), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_HttpContentDispositionHeaderValue[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_HttpContentDispositionHeaderValue) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_HttpContentDispositionHeaderValue) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_HttpContentDispositionHeaderValue) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_HttpContentDispositionHeaderValue) },
        { Py_tp_str, reinterpret_cast<void*>(_str_HttpContentDispositionHeaderValue) },
        { },
    };

    static PyType_Spec type_spec_HttpContentDispositionHeaderValue =
    {
        "winrt._winrt_windows_web_http_headers.HttpContentDispositionHeaderValue",
        sizeof(py::wrapper::Windows::Web::Http::Headers::HttpContentDispositionHeaderValue),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_HttpContentDispositionHeaderValue
    };

    static PyGetSetDef getset_HttpContentDispositionHeaderValue_Static[] = {
        { }
    };

    static PyMethodDef methods_HttpContentDispositionHeaderValue_Static[] = {
        { "parse", reinterpret_cast<PyCFunction>(HttpContentDispositionHeaderValue_Parse), METH_VARARGS, nullptr },
        { "try_parse", reinterpret_cast<PyCFunction>(HttpContentDispositionHeaderValue_TryParse), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_HttpContentDispositionHeaderValue_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_HttpContentDispositionHeaderValue_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_HttpContentDispositionHeaderValue_Static) },
        { }
    };

    static PyType_Spec type_spec_HttpContentDispositionHeaderValue_Static =
    {
        "winrt._winrt_windows_web_http_headers.HttpContentDispositionHeaderValue_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_HttpContentDispositionHeaderValue_Static
    };

    // ----- HttpContentHeaderCollection class --------------------

    static PyObject* _new_HttpContentHeaderCollection(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Web::Http::Headers::HttpContentHeaderCollection instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_HttpContentHeaderCollection(py::wrapper::Windows::Web::Http::Headers::HttpContentHeaderCollection* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* HttpContentHeaderCollection_Append(py::wrapper::Windows::Web::Http::Headers::HttpContentHeaderCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpContentHeaderCollection", L"Append", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                self->obj.Append(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpContentHeaderCollection_Clear(py::wrapper::Windows::Web::Http::Headers::HttpContentHeaderCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpContentHeaderCollection", L"Clear", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Clear();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpContentHeaderCollection_First(py::wrapper::Windows::Web::Http::Headers::HttpContentHeaderCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpContentHeaderCollection", L"First", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.First());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpContentHeaderCollection_GetView(py::wrapper::Windows::Web::Http::Headers::HttpContentHeaderCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpContentHeaderCollection", L"GetView", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetView());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpContentHeaderCollection_HasKey(py::wrapper::Windows::Web::Http::Headers::HttpContentHeaderCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpContentHeaderCollection", L"HasKey", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.HasKey(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpContentHeaderCollection_Insert(py::wrapper::Windows::Web::Http::Headers::HttpContentHeaderCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpContentHeaderCollection", L"Insert", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(self->obj.Insert(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpContentHeaderCollection_Lookup(py::wrapper::Windows::Web::Http::Headers::HttpContentHeaderCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpContentHeaderCollection", L"Lookup", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.Lookup(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpContentHeaderCollection_Remove(py::wrapper::Windows::Web::Http::Headers::HttpContentHeaderCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpContentHeaderCollection", L"Remove", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                self->obj.Remove(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpContentHeaderCollection_ToString(py::wrapper::Windows::Web::Http::Headers::HttpContentHeaderCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpContentHeaderCollection", L"ToString", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.ToString());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpContentHeaderCollection_TryAppendWithoutValidation(py::wrapper::Windows::Web::Http::Headers::HttpContentHeaderCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpContentHeaderCollection", L"TryAppendWithoutValidation", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(self->obj.TryAppendWithoutValidation(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpContentHeaderCollection_get_Size(py::wrapper::Windows::Web::Http::Headers::HttpContentHeaderCollection* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.Headers.HttpContentHeaderCollection", L"Size"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HttpContentHeaderCollection_get_LastModified(py::wrapper::Windows::Web::Http::Headers::HttpContentHeaderCollection* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.Headers.HttpContentHeaderCollection", L"LastModified"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.LastModified());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int HttpContentHeaderCollection_put_LastModified(py::wrapper::Windows::Web::Http::Headers::HttpContentHeaderCollection* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.Headers.HttpContentHeaderCollection", L"LastModified"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::DateTime>>(arg);

            self->obj.LastModified(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* HttpContentHeaderCollection_get_Expires(py::wrapper::Windows::Web::Http::Headers::HttpContentHeaderCollection* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.Headers.HttpContentHeaderCollection", L"Expires"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Expires());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int HttpContentHeaderCollection_put_Expires(py::wrapper::Windows::Web::Http::Headers::HttpContentHeaderCollection* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.Headers.HttpContentHeaderCollection", L"Expires"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::DateTime>>(arg);

            self->obj.Expires(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* HttpContentHeaderCollection_get_ContentType(py::wrapper::Windows::Web::Http::Headers::HttpContentHeaderCollection* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.Headers.HttpContentHeaderCollection", L"ContentType"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ContentType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int HttpContentHeaderCollection_put_ContentType(py::wrapper::Windows::Web::Http::Headers::HttpContentHeaderCollection* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.Headers.HttpContentHeaderCollection", L"ContentType"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Web::Http::Headers::HttpMediaTypeHeaderValue>(arg);

            self->obj.ContentType(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* HttpContentHeaderCollection_get_ContentRange(py::wrapper::Windows::Web::Http::Headers::HttpContentHeaderCollection* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.Headers.HttpContentHeaderCollection", L"ContentRange"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ContentRange());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int HttpContentHeaderCollection_put_ContentRange(py::wrapper::Windows::Web::Http::Headers::HttpContentHeaderCollection* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.Headers.HttpContentHeaderCollection", L"ContentRange"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Web::Http::Headers::HttpContentRangeHeaderValue>(arg);

            self->obj.ContentRange(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* HttpContentHeaderCollection_get_ContentMD5(py::wrapper::Windows::Web::Http::Headers::HttpContentHeaderCollection* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.Headers.HttpContentHeaderCollection", L"ContentMD5"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ContentMD5());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int HttpContentHeaderCollection_put_ContentMD5(py::wrapper::Windows::Web::Http::Headers::HttpContentHeaderCollection* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.Headers.HttpContentHeaderCollection", L"ContentMD5"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(arg);

            self->obj.ContentMD5(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* HttpContentHeaderCollection_get_ContentLocation(py::wrapper::Windows::Web::Http::Headers::HttpContentHeaderCollection* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.Headers.HttpContentHeaderCollection", L"ContentLocation"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ContentLocation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int HttpContentHeaderCollection_put_ContentLocation(py::wrapper::Windows::Web::Http::Headers::HttpContentHeaderCollection* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.Headers.HttpContentHeaderCollection", L"ContentLocation"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(arg);

            self->obj.ContentLocation(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* HttpContentHeaderCollection_get_ContentLength(py::wrapper::Windows::Web::Http::Headers::HttpContentHeaderCollection* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.Headers.HttpContentHeaderCollection", L"ContentLength"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ContentLength());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int HttpContentHeaderCollection_put_ContentLength(py::wrapper::Windows::Web::Http::Headers::HttpContentHeaderCollection* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.Headers.HttpContentHeaderCollection", L"ContentLength"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<uint64_t>>(arg);

            self->obj.ContentLength(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* HttpContentHeaderCollection_get_ContentDisposition(py::wrapper::Windows::Web::Http::Headers::HttpContentHeaderCollection* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.Headers.HttpContentHeaderCollection", L"ContentDisposition"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ContentDisposition());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int HttpContentHeaderCollection_put_ContentDisposition(py::wrapper::Windows::Web::Http::Headers::HttpContentHeaderCollection* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.Headers.HttpContentHeaderCollection", L"ContentDisposition"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Web::Http::Headers::HttpContentDispositionHeaderValue>(arg);

            self->obj.ContentDisposition(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* HttpContentHeaderCollection_get_ContentEncoding(py::wrapper::Windows::Web::Http::Headers::HttpContentHeaderCollection* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.Headers.HttpContentHeaderCollection", L"ContentEncoding"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ContentEncoding());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HttpContentHeaderCollection_get_ContentLanguage(py::wrapper::Windows::Web::Http::Headers::HttpContentHeaderCollection* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.Headers.HttpContentHeaderCollection", L"ContentLanguage"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ContentLanguage());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_HttpContentHeaderCollection(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Web::Http::Headers::HttpContentHeaderCollection>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_HttpContentHeaderCollection(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Web::Http::Headers::HttpContentHeaderCollection>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _str_HttpContentHeaderCollection(py::wrapper::Windows::Web::Http::Headers::HttpContentHeaderCollection* self) noexcept
    {
        try
        {
            return py::convert(self->obj.ToString());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _iterator_HttpContentHeaderCollection(py::wrapper::Windows::Web::Http::Headers::HttpContentHeaderCollection* self) noexcept
    {
        try
        {
            py::pyobj_handle iter{py::convert(self->obj.First())};

            if (!iter)
            {
                return nullptr;
            }

            return py::wrap_mapping_iter(iter.get());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int _map_contains_HttpContentHeaderCollection(py::wrapper::Windows::Web::Http::Headers::HttpContentHeaderCollection* self, PyObject* key) noexcept
    {
        try
        {
            return static_cast<int>(self->obj.HasKey(py::convert_to<winrt::hstring>(key)));
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static Py_ssize_t _map_length_HttpContentHeaderCollection(py::wrapper::Windows::Web::Http::Headers::HttpContentHeaderCollection* self) noexcept
    {
        try
        {
            return static_cast<Py_ssize_t>(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _map_subscript_HttpContentHeaderCollection(py::wrapper::Windows::Web::Http::Headers::HttpContentHeaderCollection* self, PyObject* key) noexcept
    {
        try
        {
            auto _key = py::convert_to<winrt::hstring>(key);
            auto value = self->obj.TryLookup(_key);

            if (!value) {
                if constexpr (std::is_base_of_v<winrt::Windows::Foundation::IUnknown, decltype(value)>)
                {
                    if (self->obj.HasKey(_key))
                    {
                        Py_RETURN_NONE;
                    }
                }

                PyErr_SetObject(PyExc_KeyError, key);
                return nullptr;
            }

            return py::convert(value);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int _map_assign_HttpContentHeaderCollection(py::wrapper::Windows::Web::Http::Headers::HttpContentHeaderCollection* self, PyObject* key, PyObject* value) noexcept
    {
        try
        {
            auto _key = py::convert_to<winrt::hstring>(key);

            if (value == nullptr) {
                if (!self->obj.TryRemove(_key)) {
                    PyErr_SetObject(PyExc_KeyError, key);
                    return -1;
                }

                return 0;
            }

            self->obj.Insert(_key, py::convert_to<winrt::hstring>(value));

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyMethodDef _methods_HttpContentHeaderCollection[] = {
        { "append", reinterpret_cast<PyCFunction>(HttpContentHeaderCollection_Append), METH_VARARGS, nullptr },
        { "clear", reinterpret_cast<PyCFunction>(HttpContentHeaderCollection_Clear), METH_VARARGS, nullptr },
        { "first", reinterpret_cast<PyCFunction>(HttpContentHeaderCollection_First), METH_VARARGS, nullptr },
        { "get_view", reinterpret_cast<PyCFunction>(HttpContentHeaderCollection_GetView), METH_VARARGS, nullptr },
        { "has_key", reinterpret_cast<PyCFunction>(HttpContentHeaderCollection_HasKey), METH_VARARGS, nullptr },
        { "insert", reinterpret_cast<PyCFunction>(HttpContentHeaderCollection_Insert), METH_VARARGS, nullptr },
        { "lookup", reinterpret_cast<PyCFunction>(HttpContentHeaderCollection_Lookup), METH_VARARGS, nullptr },
        { "remove", reinterpret_cast<PyCFunction>(HttpContentHeaderCollection_Remove), METH_VARARGS, nullptr },
        { "to_string", reinterpret_cast<PyCFunction>(HttpContentHeaderCollection_ToString), METH_VARARGS, nullptr },
        { "try_append_without_validation", reinterpret_cast<PyCFunction>(HttpContentHeaderCollection_TryAppendWithoutValidation), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_HttpContentHeaderCollection, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_HttpContentHeaderCollection), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_HttpContentHeaderCollection[] = {
        { "size", reinterpret_cast<getter>(HttpContentHeaderCollection_get_Size), nullptr, nullptr, nullptr },
        { "last_modified", reinterpret_cast<getter>(HttpContentHeaderCollection_get_LastModified), reinterpret_cast<setter>(HttpContentHeaderCollection_put_LastModified), nullptr, nullptr },
        { "expires", reinterpret_cast<getter>(HttpContentHeaderCollection_get_Expires), reinterpret_cast<setter>(HttpContentHeaderCollection_put_Expires), nullptr, nullptr },
        { "content_type", reinterpret_cast<getter>(HttpContentHeaderCollection_get_ContentType), reinterpret_cast<setter>(HttpContentHeaderCollection_put_ContentType), nullptr, nullptr },
        { "content_range", reinterpret_cast<getter>(HttpContentHeaderCollection_get_ContentRange), reinterpret_cast<setter>(HttpContentHeaderCollection_put_ContentRange), nullptr, nullptr },
        { "content_m_d5", reinterpret_cast<getter>(HttpContentHeaderCollection_get_ContentMD5), reinterpret_cast<setter>(HttpContentHeaderCollection_put_ContentMD5), nullptr, nullptr },
        { "content_location", reinterpret_cast<getter>(HttpContentHeaderCollection_get_ContentLocation), reinterpret_cast<setter>(HttpContentHeaderCollection_put_ContentLocation), nullptr, nullptr },
        { "content_length", reinterpret_cast<getter>(HttpContentHeaderCollection_get_ContentLength), reinterpret_cast<setter>(HttpContentHeaderCollection_put_ContentLength), nullptr, nullptr },
        { "content_disposition", reinterpret_cast<getter>(HttpContentHeaderCollection_get_ContentDisposition), reinterpret_cast<setter>(HttpContentHeaderCollection_put_ContentDisposition), nullptr, nullptr },
        { "content_encoding", reinterpret_cast<getter>(HttpContentHeaderCollection_get_ContentEncoding), nullptr, nullptr, nullptr },
        { "content_language", reinterpret_cast<getter>(HttpContentHeaderCollection_get_ContentLanguage), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_HttpContentHeaderCollection[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_HttpContentHeaderCollection) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_HttpContentHeaderCollection) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_HttpContentHeaderCollection) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_HttpContentHeaderCollection) },
        { Py_tp_str, reinterpret_cast<void*>(_str_HttpContentHeaderCollection) },
        { Py_tp_iter, reinterpret_cast<void*>(_iterator_HttpContentHeaderCollection) },
        { Py_sq_contains, reinterpret_cast<void*>(_map_contains_HttpContentHeaderCollection) },
        { Py_mp_length, reinterpret_cast<void*>(_map_length_HttpContentHeaderCollection) },
        { Py_mp_subscript, reinterpret_cast<void*>(_map_subscript_HttpContentHeaderCollection) },
        { Py_mp_ass_subscript, reinterpret_cast<void*>(_map_assign_HttpContentHeaderCollection) },
        { },
    };

    static PyType_Spec type_spec_HttpContentHeaderCollection =
    {
        "winrt._winrt_windows_web_http_headers.HttpContentHeaderCollection",
        sizeof(py::wrapper::Windows::Web::Http::Headers::HttpContentHeaderCollection),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_HttpContentHeaderCollection
    };

    // ----- HttpContentRangeHeaderValue class --------------------

    static PyObject* _new_HttpContentRangeHeaderValue(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<uint64_t>(args, 0);

                winrt::Windows::Web::Http::Headers::HttpContentRangeHeaderValue instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<uint64_t>(args, 0);
                auto param1 = py::convert_to<uint64_t>(args, 1);

                winrt::Windows::Web::Http::Headers::HttpContentRangeHeaderValue instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<uint64_t>(args, 0);
                auto param1 = py::convert_to<uint64_t>(args, 1);
                auto param2 = py::convert_to<uint64_t>(args, 2);

                winrt::Windows::Web::Http::Headers::HttpContentRangeHeaderValue instance{ param0, param1, param2 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_HttpContentRangeHeaderValue(py::wrapper::Windows::Web::Http::Headers::HttpContentRangeHeaderValue* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* HttpContentRangeHeaderValue_Parse(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpContentRangeHeaderValue", L"Parse", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Web::Http::Headers::HttpContentRangeHeaderValue::Parse(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpContentRangeHeaderValue_ToString(py::wrapper::Windows::Web::Http::Headers::HttpContentRangeHeaderValue* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpContentRangeHeaderValue", L"ToString", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.ToString());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpContentRangeHeaderValue_TryParse(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpContentRangeHeaderValue", L"TryParse", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                winrt::Windows::Web::Http::Headers::HttpContentRangeHeaderValue param1 { nullptr };

                auto return_value = winrt::Windows::Web::Http::Headers::HttpContentRangeHeaderValue::TryParse(param0, param1);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out1.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpContentRangeHeaderValue_get_Unit(py::wrapper::Windows::Web::Http::Headers::HttpContentRangeHeaderValue* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.Headers.HttpContentRangeHeaderValue", L"Unit"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Unit());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int HttpContentRangeHeaderValue_put_Unit(py::wrapper::Windows::Web::Http::Headers::HttpContentRangeHeaderValue* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.Headers.HttpContentRangeHeaderValue", L"Unit"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Unit(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* HttpContentRangeHeaderValue_get_FirstBytePosition(py::wrapper::Windows::Web::Http::Headers::HttpContentRangeHeaderValue* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.Headers.HttpContentRangeHeaderValue", L"FirstBytePosition"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.FirstBytePosition());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HttpContentRangeHeaderValue_get_LastBytePosition(py::wrapper::Windows::Web::Http::Headers::HttpContentRangeHeaderValue* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.Headers.HttpContentRangeHeaderValue", L"LastBytePosition"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.LastBytePosition());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HttpContentRangeHeaderValue_get_Length(py::wrapper::Windows::Web::Http::Headers::HttpContentRangeHeaderValue* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.Headers.HttpContentRangeHeaderValue", L"Length"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Length());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_HttpContentRangeHeaderValue(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Web::Http::Headers::HttpContentRangeHeaderValue>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_HttpContentRangeHeaderValue(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Web::Http::Headers::HttpContentRangeHeaderValue>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _str_HttpContentRangeHeaderValue(py::wrapper::Windows::Web::Http::Headers::HttpContentRangeHeaderValue* self) noexcept
    {
        try
        {
            return py::convert(self->obj.ToString());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_HttpContentRangeHeaderValue[] = {
        { "to_string", reinterpret_cast<PyCFunction>(HttpContentRangeHeaderValue_ToString), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_HttpContentRangeHeaderValue, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_HttpContentRangeHeaderValue), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_HttpContentRangeHeaderValue[] = {
        { "unit", reinterpret_cast<getter>(HttpContentRangeHeaderValue_get_Unit), reinterpret_cast<setter>(HttpContentRangeHeaderValue_put_Unit), nullptr, nullptr },
        { "first_byte_position", reinterpret_cast<getter>(HttpContentRangeHeaderValue_get_FirstBytePosition), nullptr, nullptr, nullptr },
        { "last_byte_position", reinterpret_cast<getter>(HttpContentRangeHeaderValue_get_LastBytePosition), nullptr, nullptr, nullptr },
        { "length", reinterpret_cast<getter>(HttpContentRangeHeaderValue_get_Length), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_HttpContentRangeHeaderValue[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_HttpContentRangeHeaderValue) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_HttpContentRangeHeaderValue) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_HttpContentRangeHeaderValue) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_HttpContentRangeHeaderValue) },
        { Py_tp_str, reinterpret_cast<void*>(_str_HttpContentRangeHeaderValue) },
        { },
    };

    static PyType_Spec type_spec_HttpContentRangeHeaderValue =
    {
        "winrt._winrt_windows_web_http_headers.HttpContentRangeHeaderValue",
        sizeof(py::wrapper::Windows::Web::Http::Headers::HttpContentRangeHeaderValue),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_HttpContentRangeHeaderValue
    };

    static PyGetSetDef getset_HttpContentRangeHeaderValue_Static[] = {
        { }
    };

    static PyMethodDef methods_HttpContentRangeHeaderValue_Static[] = {
        { "parse", reinterpret_cast<PyCFunction>(HttpContentRangeHeaderValue_Parse), METH_VARARGS, nullptr },
        { "try_parse", reinterpret_cast<PyCFunction>(HttpContentRangeHeaderValue_TryParse), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_HttpContentRangeHeaderValue_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_HttpContentRangeHeaderValue_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_HttpContentRangeHeaderValue_Static) },
        { }
    };

    static PyType_Spec type_spec_HttpContentRangeHeaderValue_Static =
    {
        "winrt._winrt_windows_web_http_headers.HttpContentRangeHeaderValue_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_HttpContentRangeHeaderValue_Static
    };

    // ----- HttpCookiePairHeaderValue class --------------------

    static PyObject* _new_HttpCookiePairHeaderValue(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                winrt::Windows::Web::Http::Headers::HttpCookiePairHeaderValue instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                winrt::Windows::Web::Http::Headers::HttpCookiePairHeaderValue instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_HttpCookiePairHeaderValue(py::wrapper::Windows::Web::Http::Headers::HttpCookiePairHeaderValue* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* HttpCookiePairHeaderValue_Parse(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpCookiePairHeaderValue", L"Parse", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Web::Http::Headers::HttpCookiePairHeaderValue::Parse(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpCookiePairHeaderValue_ToString(py::wrapper::Windows::Web::Http::Headers::HttpCookiePairHeaderValue* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpCookiePairHeaderValue", L"ToString", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.ToString());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpCookiePairHeaderValue_TryParse(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpCookiePairHeaderValue", L"TryParse", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                winrt::Windows::Web::Http::Headers::HttpCookiePairHeaderValue param1 { nullptr };

                auto return_value = winrt::Windows::Web::Http::Headers::HttpCookiePairHeaderValue::TryParse(param0, param1);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out1.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpCookiePairHeaderValue_get_Value(py::wrapper::Windows::Web::Http::Headers::HttpCookiePairHeaderValue* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.Headers.HttpCookiePairHeaderValue", L"Value"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Value());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int HttpCookiePairHeaderValue_put_Value(py::wrapper::Windows::Web::Http::Headers::HttpCookiePairHeaderValue* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.Headers.HttpCookiePairHeaderValue", L"Value"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Value(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* HttpCookiePairHeaderValue_get_Name(py::wrapper::Windows::Web::Http::Headers::HttpCookiePairHeaderValue* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.Headers.HttpCookiePairHeaderValue", L"Name"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Name());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_HttpCookiePairHeaderValue(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Web::Http::Headers::HttpCookiePairHeaderValue>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_HttpCookiePairHeaderValue(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Web::Http::Headers::HttpCookiePairHeaderValue>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _str_HttpCookiePairHeaderValue(py::wrapper::Windows::Web::Http::Headers::HttpCookiePairHeaderValue* self) noexcept
    {
        try
        {
            return py::convert(self->obj.ToString());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_HttpCookiePairHeaderValue[] = {
        { "to_string", reinterpret_cast<PyCFunction>(HttpCookiePairHeaderValue_ToString), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_HttpCookiePairHeaderValue, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_HttpCookiePairHeaderValue), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_HttpCookiePairHeaderValue[] = {
        { "value", reinterpret_cast<getter>(HttpCookiePairHeaderValue_get_Value), reinterpret_cast<setter>(HttpCookiePairHeaderValue_put_Value), nullptr, nullptr },
        { "name", reinterpret_cast<getter>(HttpCookiePairHeaderValue_get_Name), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_HttpCookiePairHeaderValue[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_HttpCookiePairHeaderValue) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_HttpCookiePairHeaderValue) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_HttpCookiePairHeaderValue) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_HttpCookiePairHeaderValue) },
        { Py_tp_str, reinterpret_cast<void*>(_str_HttpCookiePairHeaderValue) },
        { },
    };

    static PyType_Spec type_spec_HttpCookiePairHeaderValue =
    {
        "winrt._winrt_windows_web_http_headers.HttpCookiePairHeaderValue",
        sizeof(py::wrapper::Windows::Web::Http::Headers::HttpCookiePairHeaderValue),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_HttpCookiePairHeaderValue
    };

    static PyGetSetDef getset_HttpCookiePairHeaderValue_Static[] = {
        { }
    };

    static PyMethodDef methods_HttpCookiePairHeaderValue_Static[] = {
        { "parse", reinterpret_cast<PyCFunction>(HttpCookiePairHeaderValue_Parse), METH_VARARGS, nullptr },
        { "try_parse", reinterpret_cast<PyCFunction>(HttpCookiePairHeaderValue_TryParse), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_HttpCookiePairHeaderValue_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_HttpCookiePairHeaderValue_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_HttpCookiePairHeaderValue_Static) },
        { }
    };

    static PyType_Spec type_spec_HttpCookiePairHeaderValue_Static =
    {
        "winrt._winrt_windows_web_http_headers.HttpCookiePairHeaderValue_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_HttpCookiePairHeaderValue_Static
    };

    // ----- HttpCookiePairHeaderValueCollection class --------------------

    static PyObject* _new_HttpCookiePairHeaderValueCollection(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Web::Http::Headers::HttpCookiePairHeaderValueCollection>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Web::Http::Headers::HttpCookiePairHeaderValueCollection>::type_name);
        return nullptr;
    }

    static void _dealloc_HttpCookiePairHeaderValueCollection(py::wrapper::Windows::Web::Http::Headers::HttpCookiePairHeaderValueCollection* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* HttpCookiePairHeaderValueCollection_Append(py::wrapper::Windows::Web::Http::Headers::HttpCookiePairHeaderValueCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpCookiePairHeaderValueCollection", L"Append", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Web::Http::Headers::HttpCookiePairHeaderValue>(args, 0);

                self->obj.Append(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpCookiePairHeaderValueCollection_Clear(py::wrapper::Windows::Web::Http::Headers::HttpCookiePairHeaderValueCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpCookiePairHeaderValueCollection", L"Clear", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Clear();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpCookiePairHeaderValueCollection_First(py::wrapper::Windows::Web::Http::Headers::HttpCookiePairHeaderValueCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpCookiePairHeaderValueCollection", L"First", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.First());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpCookiePairHeaderValueCollection_GetAt(py::wrapper::Windows::Web::Http::Headers::HttpCookiePairHeaderValueCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpCookiePairHeaderValueCollection", L"GetAt", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint32_t>(args, 0);

                return py::convert(self->obj.GetAt(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpCookiePairHeaderValueCollection_GetMany(py::wrapper::Windows::Web::Http::Headers::HttpCookiePairHeaderValueCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpCookiePairHeaderValueCollection", L"GetMany", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<winrt::Windows::Web::Http::Headers::HttpCookiePairHeaderValue, true>>(args, 1);

                return py::convert(self->obj.GetMany(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpCookiePairHeaderValueCollection_GetView(py::wrapper::Windows::Web::Http::Headers::HttpCookiePairHeaderValueCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpCookiePairHeaderValueCollection", L"GetView", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetView());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpCookiePairHeaderValueCollection_IndexOf(py::wrapper::Windows::Web::Http::Headers::HttpCookiePairHeaderValueCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpCookiePairHeaderValueCollection", L"IndexOf", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Web::Http::Headers::HttpCookiePairHeaderValue>(args, 0);
                uint32_t param1 {  };

                auto return_value = self->obj.IndexOf(param0, param1);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out1.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpCookiePairHeaderValueCollection_InsertAt(py::wrapper::Windows::Web::Http::Headers::HttpCookiePairHeaderValueCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpCookiePairHeaderValueCollection", L"InsertAt", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Web::Http::Headers::HttpCookiePairHeaderValue>(args, 1);

                self->obj.InsertAt(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpCookiePairHeaderValueCollection_ParseAdd(py::wrapper::Windows::Web::Http::Headers::HttpCookiePairHeaderValueCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpCookiePairHeaderValueCollection", L"ParseAdd", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                self->obj.ParseAdd(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpCookiePairHeaderValueCollection_RemoveAt(py::wrapper::Windows::Web::Http::Headers::HttpCookiePairHeaderValueCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpCookiePairHeaderValueCollection", L"RemoveAt", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint32_t>(args, 0);

                self->obj.RemoveAt(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpCookiePairHeaderValueCollection_RemoveAtEnd(py::wrapper::Windows::Web::Http::Headers::HttpCookiePairHeaderValueCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpCookiePairHeaderValueCollection", L"RemoveAtEnd", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.RemoveAtEnd();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpCookiePairHeaderValueCollection_ReplaceAll(py::wrapper::Windows::Web::Http::Headers::HttpCookiePairHeaderValueCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpCookiePairHeaderValueCollection", L"ReplaceAll", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<py::pybuf_view<winrt::Windows::Web::Http::Headers::HttpCookiePairHeaderValue, false>>(args, 0);

                self->obj.ReplaceAll(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpCookiePairHeaderValueCollection_SetAt(py::wrapper::Windows::Web::Http::Headers::HttpCookiePairHeaderValueCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpCookiePairHeaderValueCollection", L"SetAt", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Web::Http::Headers::HttpCookiePairHeaderValue>(args, 1);

                self->obj.SetAt(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpCookiePairHeaderValueCollection_ToString(py::wrapper::Windows::Web::Http::Headers::HttpCookiePairHeaderValueCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpCookiePairHeaderValueCollection", L"ToString", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.ToString());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpCookiePairHeaderValueCollection_TryParseAdd(py::wrapper::Windows::Web::Http::Headers::HttpCookiePairHeaderValueCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpCookiePairHeaderValueCollection", L"TryParseAdd", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.TryParseAdd(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpCookiePairHeaderValueCollection_get_Size(py::wrapper::Windows::Web::Http::Headers::HttpCookiePairHeaderValueCollection* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.Headers.HttpCookiePairHeaderValueCollection", L"Size"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_HttpCookiePairHeaderValueCollection(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Web::Http::Headers::HttpCookiePairHeaderValueCollection>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_HttpCookiePairHeaderValueCollection(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Web::Http::Headers::HttpCookiePairHeaderValueCollection>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _str_HttpCookiePairHeaderValueCollection(py::wrapper::Windows::Web::Http::Headers::HttpCookiePairHeaderValueCollection* self) noexcept
    {
        try
        {
            return py::convert(self->obj.ToString());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _iterator_HttpCookiePairHeaderValueCollection(py::wrapper::Windows::Web::Http::Headers::HttpCookiePairHeaderValueCollection* self) noexcept
    {
        try
        {
            return py::convert(self->obj.First());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static Py_ssize_t _seq_length_HttpCookiePairHeaderValueCollection(py::wrapper::Windows::Web::Http::Headers::HttpCookiePairHeaderValueCollection* self) noexcept
    {
        try
        {
            return static_cast<Py_ssize_t>(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _seq_item_HttpCookiePairHeaderValueCollection(py::wrapper::Windows::Web::Http::Headers::HttpCookiePairHeaderValueCollection* self, Py_ssize_t i) noexcept
    {
        try
        {
            return py::convert(self->obj.GetAt(static_cast<uint32_t>(i)));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _seq_subscript_HttpCookiePairHeaderValueCollection(py::wrapper::Windows::Web::Http::Headers::HttpCookiePairHeaderValueCollection* self, PyObject* slice) noexcept
    {
        try
        {
            if (PyIndex_Check(slice))
            {
                pyobj_handle index{PyNumber_Index(slice)};

                if (!index)
                {
                    return nullptr;
                }

                auto i = PyNumber_AsSsize_t(index.get(), PyExc_IndexError);

                if (i == -1 && PyErr_Occurred())
                {
                    return nullptr;
                }

                return _seq_item_HttpCookiePairHeaderValueCollection(self, i);
            }

            if (!PySlice_Check(slice))
            {
                PyErr_Format(
                    PyExc_TypeError,
                    "indicies must be integers, not '%s'",
                    Py_TYPE(slice)->tp_name);
            }

            Py_ssize_t start, stop, step, length;

            if (PySlice_GetIndicesEx(
                    slice, self->obj.Size(), &start, &stop, &step, &length)
                < 0)
            {
                return nullptr;
            }

            if (step != 1)
            {
                PyErr_SetString(PyExc_NotImplementedError, "slices with step other than 1 are not implemented");
                return nullptr;
            }

            winrt::com_array<winrt::Windows::Web::Http::Headers::HttpCookiePairHeaderValue> items(static_cast<uint32_t>(length), empty_instance<winrt::Windows::Web::Http::Headers::HttpCookiePairHeaderValue>::get());

            auto count = self->obj.GetMany(static_cast<uint32_t>(start), items);

            if (count != static_cast<uint32_t>(length))
            {
                PyErr_Format(PyExc_RuntimeError, "returned count %d did not match requested length %zd", count, length);
                return nullptr;
            }

            return convert(items);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int _seq_assign_HttpCookiePairHeaderValueCollection(py::wrapper::Windows::Web::Http::Headers::HttpCookiePairHeaderValueCollection* self, Py_ssize_t i, PyObject* value) noexcept
    {
        try
        {
            if (!value)
            {
                self->obj.RemoveAt(static_cast<uint32_t>(i));
            }
            else
            {
                self->obj.SetAt(static_cast<uint32_t>(i), py::convert_to<winrt::Windows::Web::Http::Headers::HttpCookiePairHeaderValue>(value));
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyMethodDef _methods_HttpCookiePairHeaderValueCollection[] = {
        { "append", reinterpret_cast<PyCFunction>(HttpCookiePairHeaderValueCollection_Append), METH_VARARGS, nullptr },
        { "clear", reinterpret_cast<PyCFunction>(HttpCookiePairHeaderValueCollection_Clear), METH_VARARGS, nullptr },
        { "first", reinterpret_cast<PyCFunction>(HttpCookiePairHeaderValueCollection_First), METH_VARARGS, nullptr },
        { "get_at", reinterpret_cast<PyCFunction>(HttpCookiePairHeaderValueCollection_GetAt), METH_VARARGS, nullptr },
        { "get_many", reinterpret_cast<PyCFunction>(HttpCookiePairHeaderValueCollection_GetMany), METH_VARARGS, nullptr },
        { "get_view", reinterpret_cast<PyCFunction>(HttpCookiePairHeaderValueCollection_GetView), METH_VARARGS, nullptr },
        { "index_of", reinterpret_cast<PyCFunction>(HttpCookiePairHeaderValueCollection_IndexOf), METH_VARARGS, nullptr },
        { "insert_at", reinterpret_cast<PyCFunction>(HttpCookiePairHeaderValueCollection_InsertAt), METH_VARARGS, nullptr },
        { "parse_add", reinterpret_cast<PyCFunction>(HttpCookiePairHeaderValueCollection_ParseAdd), METH_VARARGS, nullptr },
        { "remove_at", reinterpret_cast<PyCFunction>(HttpCookiePairHeaderValueCollection_RemoveAt), METH_VARARGS, nullptr },
        { "remove_at_end", reinterpret_cast<PyCFunction>(HttpCookiePairHeaderValueCollection_RemoveAtEnd), METH_VARARGS, nullptr },
        { "replace_all", reinterpret_cast<PyCFunction>(HttpCookiePairHeaderValueCollection_ReplaceAll), METH_VARARGS, nullptr },
        { "set_at", reinterpret_cast<PyCFunction>(HttpCookiePairHeaderValueCollection_SetAt), METH_VARARGS, nullptr },
        { "to_string", reinterpret_cast<PyCFunction>(HttpCookiePairHeaderValueCollection_ToString), METH_VARARGS, nullptr },
        { "try_parse_add", reinterpret_cast<PyCFunction>(HttpCookiePairHeaderValueCollection_TryParseAdd), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_HttpCookiePairHeaderValueCollection, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_HttpCookiePairHeaderValueCollection), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_HttpCookiePairHeaderValueCollection[] = {
        { "size", reinterpret_cast<getter>(HttpCookiePairHeaderValueCollection_get_Size), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_HttpCookiePairHeaderValueCollection[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_HttpCookiePairHeaderValueCollection) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_HttpCookiePairHeaderValueCollection) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_HttpCookiePairHeaderValueCollection) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_HttpCookiePairHeaderValueCollection) },
        { Py_tp_str, reinterpret_cast<void*>(_str_HttpCookiePairHeaderValueCollection) },
        { Py_tp_iter, reinterpret_cast<void*>(_iterator_HttpCookiePairHeaderValueCollection) },
        { Py_sq_length, reinterpret_cast<void*>(_seq_length_HttpCookiePairHeaderValueCollection) },
        { Py_sq_item, reinterpret_cast<void*>(_seq_item_HttpCookiePairHeaderValueCollection) },
        { Py_mp_subscript, reinterpret_cast<void*>(_seq_subscript_HttpCookiePairHeaderValueCollection) },
        { Py_sq_ass_item, reinterpret_cast<void*>(_seq_assign_HttpCookiePairHeaderValueCollection) },
        { },
    };

    static PyType_Spec type_spec_HttpCookiePairHeaderValueCollection =
    {
        "winrt._winrt_windows_web_http_headers.HttpCookiePairHeaderValueCollection",
        sizeof(py::wrapper::Windows::Web::Http::Headers::HttpCookiePairHeaderValueCollection),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_HttpCookiePairHeaderValueCollection
    };

    // ----- HttpCredentialsHeaderValue class --------------------

    static PyObject* _new_HttpCredentialsHeaderValue(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                winrt::Windows::Web::Http::Headers::HttpCredentialsHeaderValue instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                winrt::Windows::Web::Http::Headers::HttpCredentialsHeaderValue instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_HttpCredentialsHeaderValue(py::wrapper::Windows::Web::Http::Headers::HttpCredentialsHeaderValue* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* HttpCredentialsHeaderValue_Parse(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpCredentialsHeaderValue", L"Parse", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Web::Http::Headers::HttpCredentialsHeaderValue::Parse(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpCredentialsHeaderValue_ToString(py::wrapper::Windows::Web::Http::Headers::HttpCredentialsHeaderValue* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpCredentialsHeaderValue", L"ToString", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.ToString());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpCredentialsHeaderValue_TryParse(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpCredentialsHeaderValue", L"TryParse", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                winrt::Windows::Web::Http::Headers::HttpCredentialsHeaderValue param1 { nullptr };

                auto return_value = winrt::Windows::Web::Http::Headers::HttpCredentialsHeaderValue::TryParse(param0, param1);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out1.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpCredentialsHeaderValue_get_Parameters(py::wrapper::Windows::Web::Http::Headers::HttpCredentialsHeaderValue* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.Headers.HttpCredentialsHeaderValue", L"Parameters"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Parameters());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HttpCredentialsHeaderValue_get_Scheme(py::wrapper::Windows::Web::Http::Headers::HttpCredentialsHeaderValue* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.Headers.HttpCredentialsHeaderValue", L"Scheme"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Scheme());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HttpCredentialsHeaderValue_get_Token(py::wrapper::Windows::Web::Http::Headers::HttpCredentialsHeaderValue* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.Headers.HttpCredentialsHeaderValue", L"Token"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Token());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_HttpCredentialsHeaderValue(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Web::Http::Headers::HttpCredentialsHeaderValue>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_HttpCredentialsHeaderValue(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Web::Http::Headers::HttpCredentialsHeaderValue>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _str_HttpCredentialsHeaderValue(py::wrapper::Windows::Web::Http::Headers::HttpCredentialsHeaderValue* self) noexcept
    {
        try
        {
            return py::convert(self->obj.ToString());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_HttpCredentialsHeaderValue[] = {
        { "to_string", reinterpret_cast<PyCFunction>(HttpCredentialsHeaderValue_ToString), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_HttpCredentialsHeaderValue, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_HttpCredentialsHeaderValue), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_HttpCredentialsHeaderValue[] = {
        { "parameters", reinterpret_cast<getter>(HttpCredentialsHeaderValue_get_Parameters), nullptr, nullptr, nullptr },
        { "scheme", reinterpret_cast<getter>(HttpCredentialsHeaderValue_get_Scheme), nullptr, nullptr, nullptr },
        { "token", reinterpret_cast<getter>(HttpCredentialsHeaderValue_get_Token), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_HttpCredentialsHeaderValue[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_HttpCredentialsHeaderValue) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_HttpCredentialsHeaderValue) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_HttpCredentialsHeaderValue) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_HttpCredentialsHeaderValue) },
        { Py_tp_str, reinterpret_cast<void*>(_str_HttpCredentialsHeaderValue) },
        { },
    };

    static PyType_Spec type_spec_HttpCredentialsHeaderValue =
    {
        "winrt._winrt_windows_web_http_headers.HttpCredentialsHeaderValue",
        sizeof(py::wrapper::Windows::Web::Http::Headers::HttpCredentialsHeaderValue),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_HttpCredentialsHeaderValue
    };

    static PyGetSetDef getset_HttpCredentialsHeaderValue_Static[] = {
        { }
    };

    static PyMethodDef methods_HttpCredentialsHeaderValue_Static[] = {
        { "parse", reinterpret_cast<PyCFunction>(HttpCredentialsHeaderValue_Parse), METH_VARARGS, nullptr },
        { "try_parse", reinterpret_cast<PyCFunction>(HttpCredentialsHeaderValue_TryParse), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_HttpCredentialsHeaderValue_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_HttpCredentialsHeaderValue_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_HttpCredentialsHeaderValue_Static) },
        { }
    };

    static PyType_Spec type_spec_HttpCredentialsHeaderValue_Static =
    {
        "winrt._winrt_windows_web_http_headers.HttpCredentialsHeaderValue_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_HttpCredentialsHeaderValue_Static
    };

    // ----- HttpDateOrDeltaHeaderValue class --------------------

    static PyObject* _new_HttpDateOrDeltaHeaderValue(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Web::Http::Headers::HttpDateOrDeltaHeaderValue>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Web::Http::Headers::HttpDateOrDeltaHeaderValue>::type_name);
        return nullptr;
    }

    static void _dealloc_HttpDateOrDeltaHeaderValue(py::wrapper::Windows::Web::Http::Headers::HttpDateOrDeltaHeaderValue* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* HttpDateOrDeltaHeaderValue_Parse(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpDateOrDeltaHeaderValue", L"Parse", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Web::Http::Headers::HttpDateOrDeltaHeaderValue::Parse(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpDateOrDeltaHeaderValue_ToString(py::wrapper::Windows::Web::Http::Headers::HttpDateOrDeltaHeaderValue* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpDateOrDeltaHeaderValue", L"ToString", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.ToString());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpDateOrDeltaHeaderValue_TryParse(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpDateOrDeltaHeaderValue", L"TryParse", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                winrt::Windows::Web::Http::Headers::HttpDateOrDeltaHeaderValue param1 { nullptr };

                auto return_value = winrt::Windows::Web::Http::Headers::HttpDateOrDeltaHeaderValue::TryParse(param0, param1);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out1.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpDateOrDeltaHeaderValue_get_Date(py::wrapper::Windows::Web::Http::Headers::HttpDateOrDeltaHeaderValue* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.Headers.HttpDateOrDeltaHeaderValue", L"Date"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Date());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HttpDateOrDeltaHeaderValue_get_Delta(py::wrapper::Windows::Web::Http::Headers::HttpDateOrDeltaHeaderValue* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.Headers.HttpDateOrDeltaHeaderValue", L"Delta"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Delta());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_HttpDateOrDeltaHeaderValue(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Web::Http::Headers::HttpDateOrDeltaHeaderValue>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_HttpDateOrDeltaHeaderValue(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Web::Http::Headers::HttpDateOrDeltaHeaderValue>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _str_HttpDateOrDeltaHeaderValue(py::wrapper::Windows::Web::Http::Headers::HttpDateOrDeltaHeaderValue* self) noexcept
    {
        try
        {
            return py::convert(self->obj.ToString());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_HttpDateOrDeltaHeaderValue[] = {
        { "to_string", reinterpret_cast<PyCFunction>(HttpDateOrDeltaHeaderValue_ToString), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_HttpDateOrDeltaHeaderValue, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_HttpDateOrDeltaHeaderValue), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_HttpDateOrDeltaHeaderValue[] = {
        { "date", reinterpret_cast<getter>(HttpDateOrDeltaHeaderValue_get_Date), nullptr, nullptr, nullptr },
        { "delta", reinterpret_cast<getter>(HttpDateOrDeltaHeaderValue_get_Delta), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_HttpDateOrDeltaHeaderValue[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_HttpDateOrDeltaHeaderValue) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_HttpDateOrDeltaHeaderValue) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_HttpDateOrDeltaHeaderValue) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_HttpDateOrDeltaHeaderValue) },
        { Py_tp_str, reinterpret_cast<void*>(_str_HttpDateOrDeltaHeaderValue) },
        { },
    };

    static PyType_Spec type_spec_HttpDateOrDeltaHeaderValue =
    {
        "winrt._winrt_windows_web_http_headers.HttpDateOrDeltaHeaderValue",
        sizeof(py::wrapper::Windows::Web::Http::Headers::HttpDateOrDeltaHeaderValue),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_HttpDateOrDeltaHeaderValue
    };

    static PyGetSetDef getset_HttpDateOrDeltaHeaderValue_Static[] = {
        { }
    };

    static PyMethodDef methods_HttpDateOrDeltaHeaderValue_Static[] = {
        { "parse", reinterpret_cast<PyCFunction>(HttpDateOrDeltaHeaderValue_Parse), METH_VARARGS, nullptr },
        { "try_parse", reinterpret_cast<PyCFunction>(HttpDateOrDeltaHeaderValue_TryParse), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_HttpDateOrDeltaHeaderValue_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_HttpDateOrDeltaHeaderValue_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_HttpDateOrDeltaHeaderValue_Static) },
        { }
    };

    static PyType_Spec type_spec_HttpDateOrDeltaHeaderValue_Static =
    {
        "winrt._winrt_windows_web_http_headers.HttpDateOrDeltaHeaderValue_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_HttpDateOrDeltaHeaderValue_Static
    };

    // ----- HttpExpectationHeaderValue class --------------------

    static PyObject* _new_HttpExpectationHeaderValue(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                winrt::Windows::Web::Http::Headers::HttpExpectationHeaderValue instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                winrt::Windows::Web::Http::Headers::HttpExpectationHeaderValue instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_HttpExpectationHeaderValue(py::wrapper::Windows::Web::Http::Headers::HttpExpectationHeaderValue* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* HttpExpectationHeaderValue_Parse(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpExpectationHeaderValue", L"Parse", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Web::Http::Headers::HttpExpectationHeaderValue::Parse(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpExpectationHeaderValue_ToString(py::wrapper::Windows::Web::Http::Headers::HttpExpectationHeaderValue* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpExpectationHeaderValue", L"ToString", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.ToString());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpExpectationHeaderValue_TryParse(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpExpectationHeaderValue", L"TryParse", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                winrt::Windows::Web::Http::Headers::HttpExpectationHeaderValue param1 { nullptr };

                auto return_value = winrt::Windows::Web::Http::Headers::HttpExpectationHeaderValue::TryParse(param0, param1);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out1.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpExpectationHeaderValue_get_Value(py::wrapper::Windows::Web::Http::Headers::HttpExpectationHeaderValue* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.Headers.HttpExpectationHeaderValue", L"Value"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Value());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int HttpExpectationHeaderValue_put_Value(py::wrapper::Windows::Web::Http::Headers::HttpExpectationHeaderValue* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.Headers.HttpExpectationHeaderValue", L"Value"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Value(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* HttpExpectationHeaderValue_get_Name(py::wrapper::Windows::Web::Http::Headers::HttpExpectationHeaderValue* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.Headers.HttpExpectationHeaderValue", L"Name"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Name());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HttpExpectationHeaderValue_get_Parameters(py::wrapper::Windows::Web::Http::Headers::HttpExpectationHeaderValue* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.Headers.HttpExpectationHeaderValue", L"Parameters"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Parameters());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_HttpExpectationHeaderValue(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Web::Http::Headers::HttpExpectationHeaderValue>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_HttpExpectationHeaderValue(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Web::Http::Headers::HttpExpectationHeaderValue>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _str_HttpExpectationHeaderValue(py::wrapper::Windows::Web::Http::Headers::HttpExpectationHeaderValue* self) noexcept
    {
        try
        {
            return py::convert(self->obj.ToString());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_HttpExpectationHeaderValue[] = {
        { "to_string", reinterpret_cast<PyCFunction>(HttpExpectationHeaderValue_ToString), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_HttpExpectationHeaderValue, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_HttpExpectationHeaderValue), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_HttpExpectationHeaderValue[] = {
        { "value", reinterpret_cast<getter>(HttpExpectationHeaderValue_get_Value), reinterpret_cast<setter>(HttpExpectationHeaderValue_put_Value), nullptr, nullptr },
        { "name", reinterpret_cast<getter>(HttpExpectationHeaderValue_get_Name), nullptr, nullptr, nullptr },
        { "parameters", reinterpret_cast<getter>(HttpExpectationHeaderValue_get_Parameters), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_HttpExpectationHeaderValue[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_HttpExpectationHeaderValue) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_HttpExpectationHeaderValue) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_HttpExpectationHeaderValue) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_HttpExpectationHeaderValue) },
        { Py_tp_str, reinterpret_cast<void*>(_str_HttpExpectationHeaderValue) },
        { },
    };

    static PyType_Spec type_spec_HttpExpectationHeaderValue =
    {
        "winrt._winrt_windows_web_http_headers.HttpExpectationHeaderValue",
        sizeof(py::wrapper::Windows::Web::Http::Headers::HttpExpectationHeaderValue),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_HttpExpectationHeaderValue
    };

    static PyGetSetDef getset_HttpExpectationHeaderValue_Static[] = {
        { }
    };

    static PyMethodDef methods_HttpExpectationHeaderValue_Static[] = {
        { "parse", reinterpret_cast<PyCFunction>(HttpExpectationHeaderValue_Parse), METH_VARARGS, nullptr },
        { "try_parse", reinterpret_cast<PyCFunction>(HttpExpectationHeaderValue_TryParse), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_HttpExpectationHeaderValue_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_HttpExpectationHeaderValue_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_HttpExpectationHeaderValue_Static) },
        { }
    };

    static PyType_Spec type_spec_HttpExpectationHeaderValue_Static =
    {
        "winrt._winrt_windows_web_http_headers.HttpExpectationHeaderValue_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_HttpExpectationHeaderValue_Static
    };

    // ----- HttpExpectationHeaderValueCollection class --------------------

    static PyObject* _new_HttpExpectationHeaderValueCollection(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Web::Http::Headers::HttpExpectationHeaderValueCollection>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Web::Http::Headers::HttpExpectationHeaderValueCollection>::type_name);
        return nullptr;
    }

    static void _dealloc_HttpExpectationHeaderValueCollection(py::wrapper::Windows::Web::Http::Headers::HttpExpectationHeaderValueCollection* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* HttpExpectationHeaderValueCollection_Append(py::wrapper::Windows::Web::Http::Headers::HttpExpectationHeaderValueCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpExpectationHeaderValueCollection", L"Append", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Web::Http::Headers::HttpExpectationHeaderValue>(args, 0);

                self->obj.Append(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpExpectationHeaderValueCollection_Clear(py::wrapper::Windows::Web::Http::Headers::HttpExpectationHeaderValueCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpExpectationHeaderValueCollection", L"Clear", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Clear();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpExpectationHeaderValueCollection_First(py::wrapper::Windows::Web::Http::Headers::HttpExpectationHeaderValueCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpExpectationHeaderValueCollection", L"First", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.First());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpExpectationHeaderValueCollection_GetAt(py::wrapper::Windows::Web::Http::Headers::HttpExpectationHeaderValueCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpExpectationHeaderValueCollection", L"GetAt", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint32_t>(args, 0);

                return py::convert(self->obj.GetAt(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpExpectationHeaderValueCollection_GetMany(py::wrapper::Windows::Web::Http::Headers::HttpExpectationHeaderValueCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpExpectationHeaderValueCollection", L"GetMany", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<winrt::Windows::Web::Http::Headers::HttpExpectationHeaderValue, true>>(args, 1);

                return py::convert(self->obj.GetMany(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpExpectationHeaderValueCollection_GetView(py::wrapper::Windows::Web::Http::Headers::HttpExpectationHeaderValueCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpExpectationHeaderValueCollection", L"GetView", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetView());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpExpectationHeaderValueCollection_IndexOf(py::wrapper::Windows::Web::Http::Headers::HttpExpectationHeaderValueCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpExpectationHeaderValueCollection", L"IndexOf", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Web::Http::Headers::HttpExpectationHeaderValue>(args, 0);
                uint32_t param1 {  };

                auto return_value = self->obj.IndexOf(param0, param1);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out1.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpExpectationHeaderValueCollection_InsertAt(py::wrapper::Windows::Web::Http::Headers::HttpExpectationHeaderValueCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpExpectationHeaderValueCollection", L"InsertAt", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Web::Http::Headers::HttpExpectationHeaderValue>(args, 1);

                self->obj.InsertAt(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpExpectationHeaderValueCollection_ParseAdd(py::wrapper::Windows::Web::Http::Headers::HttpExpectationHeaderValueCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpExpectationHeaderValueCollection", L"ParseAdd", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                self->obj.ParseAdd(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpExpectationHeaderValueCollection_RemoveAt(py::wrapper::Windows::Web::Http::Headers::HttpExpectationHeaderValueCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpExpectationHeaderValueCollection", L"RemoveAt", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint32_t>(args, 0);

                self->obj.RemoveAt(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpExpectationHeaderValueCollection_RemoveAtEnd(py::wrapper::Windows::Web::Http::Headers::HttpExpectationHeaderValueCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpExpectationHeaderValueCollection", L"RemoveAtEnd", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.RemoveAtEnd();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpExpectationHeaderValueCollection_ReplaceAll(py::wrapper::Windows::Web::Http::Headers::HttpExpectationHeaderValueCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpExpectationHeaderValueCollection", L"ReplaceAll", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<py::pybuf_view<winrt::Windows::Web::Http::Headers::HttpExpectationHeaderValue, false>>(args, 0);

                self->obj.ReplaceAll(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpExpectationHeaderValueCollection_SetAt(py::wrapper::Windows::Web::Http::Headers::HttpExpectationHeaderValueCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpExpectationHeaderValueCollection", L"SetAt", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Web::Http::Headers::HttpExpectationHeaderValue>(args, 1);

                self->obj.SetAt(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpExpectationHeaderValueCollection_ToString(py::wrapper::Windows::Web::Http::Headers::HttpExpectationHeaderValueCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpExpectationHeaderValueCollection", L"ToString", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.ToString());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpExpectationHeaderValueCollection_TryParseAdd(py::wrapper::Windows::Web::Http::Headers::HttpExpectationHeaderValueCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpExpectationHeaderValueCollection", L"TryParseAdd", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.TryParseAdd(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpExpectationHeaderValueCollection_get_Size(py::wrapper::Windows::Web::Http::Headers::HttpExpectationHeaderValueCollection* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.Headers.HttpExpectationHeaderValueCollection", L"Size"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_HttpExpectationHeaderValueCollection(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Web::Http::Headers::HttpExpectationHeaderValueCollection>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_HttpExpectationHeaderValueCollection(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Web::Http::Headers::HttpExpectationHeaderValueCollection>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _str_HttpExpectationHeaderValueCollection(py::wrapper::Windows::Web::Http::Headers::HttpExpectationHeaderValueCollection* self) noexcept
    {
        try
        {
            return py::convert(self->obj.ToString());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _iterator_HttpExpectationHeaderValueCollection(py::wrapper::Windows::Web::Http::Headers::HttpExpectationHeaderValueCollection* self) noexcept
    {
        try
        {
            return py::convert(self->obj.First());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static Py_ssize_t _seq_length_HttpExpectationHeaderValueCollection(py::wrapper::Windows::Web::Http::Headers::HttpExpectationHeaderValueCollection* self) noexcept
    {
        try
        {
            return static_cast<Py_ssize_t>(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _seq_item_HttpExpectationHeaderValueCollection(py::wrapper::Windows::Web::Http::Headers::HttpExpectationHeaderValueCollection* self, Py_ssize_t i) noexcept
    {
        try
        {
            return py::convert(self->obj.GetAt(static_cast<uint32_t>(i)));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _seq_subscript_HttpExpectationHeaderValueCollection(py::wrapper::Windows::Web::Http::Headers::HttpExpectationHeaderValueCollection* self, PyObject* slice) noexcept
    {
        try
        {
            if (PyIndex_Check(slice))
            {
                pyobj_handle index{PyNumber_Index(slice)};

                if (!index)
                {
                    return nullptr;
                }

                auto i = PyNumber_AsSsize_t(index.get(), PyExc_IndexError);

                if (i == -1 && PyErr_Occurred())
                {
                    return nullptr;
                }

                return _seq_item_HttpExpectationHeaderValueCollection(self, i);
            }

            if (!PySlice_Check(slice))
            {
                PyErr_Format(
                    PyExc_TypeError,
                    "indicies must be integers, not '%s'",
                    Py_TYPE(slice)->tp_name);
            }

            Py_ssize_t start, stop, step, length;

            if (PySlice_GetIndicesEx(
                    slice, self->obj.Size(), &start, &stop, &step, &length)
                < 0)
            {
                return nullptr;
            }

            if (step != 1)
            {
                PyErr_SetString(PyExc_NotImplementedError, "slices with step other than 1 are not implemented");
                return nullptr;
            }

            winrt::com_array<winrt::Windows::Web::Http::Headers::HttpExpectationHeaderValue> items(static_cast<uint32_t>(length), empty_instance<winrt::Windows::Web::Http::Headers::HttpExpectationHeaderValue>::get());

            auto count = self->obj.GetMany(static_cast<uint32_t>(start), items);

            if (count != static_cast<uint32_t>(length))
            {
                PyErr_Format(PyExc_RuntimeError, "returned count %d did not match requested length %zd", count, length);
                return nullptr;
            }

            return convert(items);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int _seq_assign_HttpExpectationHeaderValueCollection(py::wrapper::Windows::Web::Http::Headers::HttpExpectationHeaderValueCollection* self, Py_ssize_t i, PyObject* value) noexcept
    {
        try
        {
            if (!value)
            {
                self->obj.RemoveAt(static_cast<uint32_t>(i));
            }
            else
            {
                self->obj.SetAt(static_cast<uint32_t>(i), py::convert_to<winrt::Windows::Web::Http::Headers::HttpExpectationHeaderValue>(value));
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyMethodDef _methods_HttpExpectationHeaderValueCollection[] = {
        { "append", reinterpret_cast<PyCFunction>(HttpExpectationHeaderValueCollection_Append), METH_VARARGS, nullptr },
        { "clear", reinterpret_cast<PyCFunction>(HttpExpectationHeaderValueCollection_Clear), METH_VARARGS, nullptr },
        { "first", reinterpret_cast<PyCFunction>(HttpExpectationHeaderValueCollection_First), METH_VARARGS, nullptr },
        { "get_at", reinterpret_cast<PyCFunction>(HttpExpectationHeaderValueCollection_GetAt), METH_VARARGS, nullptr },
        { "get_many", reinterpret_cast<PyCFunction>(HttpExpectationHeaderValueCollection_GetMany), METH_VARARGS, nullptr },
        { "get_view", reinterpret_cast<PyCFunction>(HttpExpectationHeaderValueCollection_GetView), METH_VARARGS, nullptr },
        { "index_of", reinterpret_cast<PyCFunction>(HttpExpectationHeaderValueCollection_IndexOf), METH_VARARGS, nullptr },
        { "insert_at", reinterpret_cast<PyCFunction>(HttpExpectationHeaderValueCollection_InsertAt), METH_VARARGS, nullptr },
        { "parse_add", reinterpret_cast<PyCFunction>(HttpExpectationHeaderValueCollection_ParseAdd), METH_VARARGS, nullptr },
        { "remove_at", reinterpret_cast<PyCFunction>(HttpExpectationHeaderValueCollection_RemoveAt), METH_VARARGS, nullptr },
        { "remove_at_end", reinterpret_cast<PyCFunction>(HttpExpectationHeaderValueCollection_RemoveAtEnd), METH_VARARGS, nullptr },
        { "replace_all", reinterpret_cast<PyCFunction>(HttpExpectationHeaderValueCollection_ReplaceAll), METH_VARARGS, nullptr },
        { "set_at", reinterpret_cast<PyCFunction>(HttpExpectationHeaderValueCollection_SetAt), METH_VARARGS, nullptr },
        { "to_string", reinterpret_cast<PyCFunction>(HttpExpectationHeaderValueCollection_ToString), METH_VARARGS, nullptr },
        { "try_parse_add", reinterpret_cast<PyCFunction>(HttpExpectationHeaderValueCollection_TryParseAdd), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_HttpExpectationHeaderValueCollection, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_HttpExpectationHeaderValueCollection), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_HttpExpectationHeaderValueCollection[] = {
        { "size", reinterpret_cast<getter>(HttpExpectationHeaderValueCollection_get_Size), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_HttpExpectationHeaderValueCollection[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_HttpExpectationHeaderValueCollection) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_HttpExpectationHeaderValueCollection) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_HttpExpectationHeaderValueCollection) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_HttpExpectationHeaderValueCollection) },
        { Py_tp_str, reinterpret_cast<void*>(_str_HttpExpectationHeaderValueCollection) },
        { Py_tp_iter, reinterpret_cast<void*>(_iterator_HttpExpectationHeaderValueCollection) },
        { Py_sq_length, reinterpret_cast<void*>(_seq_length_HttpExpectationHeaderValueCollection) },
        { Py_sq_item, reinterpret_cast<void*>(_seq_item_HttpExpectationHeaderValueCollection) },
        { Py_mp_subscript, reinterpret_cast<void*>(_seq_subscript_HttpExpectationHeaderValueCollection) },
        { Py_sq_ass_item, reinterpret_cast<void*>(_seq_assign_HttpExpectationHeaderValueCollection) },
        { },
    };

    static PyType_Spec type_spec_HttpExpectationHeaderValueCollection =
    {
        "winrt._winrt_windows_web_http_headers.HttpExpectationHeaderValueCollection",
        sizeof(py::wrapper::Windows::Web::Http::Headers::HttpExpectationHeaderValueCollection),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_HttpExpectationHeaderValueCollection
    };

    // ----- HttpLanguageHeaderValueCollection class --------------------

    static PyObject* _new_HttpLanguageHeaderValueCollection(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Web::Http::Headers::HttpLanguageHeaderValueCollection>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Web::Http::Headers::HttpLanguageHeaderValueCollection>::type_name);
        return nullptr;
    }

    static void _dealloc_HttpLanguageHeaderValueCollection(py::wrapper::Windows::Web::Http::Headers::HttpLanguageHeaderValueCollection* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* HttpLanguageHeaderValueCollection_Append(py::wrapper::Windows::Web::Http::Headers::HttpLanguageHeaderValueCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpLanguageHeaderValueCollection", L"Append", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Globalization::Language>(args, 0);

                self->obj.Append(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpLanguageHeaderValueCollection_Clear(py::wrapper::Windows::Web::Http::Headers::HttpLanguageHeaderValueCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpLanguageHeaderValueCollection", L"Clear", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Clear();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpLanguageHeaderValueCollection_First(py::wrapper::Windows::Web::Http::Headers::HttpLanguageHeaderValueCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpLanguageHeaderValueCollection", L"First", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.First());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpLanguageHeaderValueCollection_GetAt(py::wrapper::Windows::Web::Http::Headers::HttpLanguageHeaderValueCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpLanguageHeaderValueCollection", L"GetAt", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint32_t>(args, 0);

                return py::convert(self->obj.GetAt(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpLanguageHeaderValueCollection_GetMany(py::wrapper::Windows::Web::Http::Headers::HttpLanguageHeaderValueCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpLanguageHeaderValueCollection", L"GetMany", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<winrt::Windows::Globalization::Language, true>>(args, 1);

                return py::convert(self->obj.GetMany(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpLanguageHeaderValueCollection_GetView(py::wrapper::Windows::Web::Http::Headers::HttpLanguageHeaderValueCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpLanguageHeaderValueCollection", L"GetView", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetView());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpLanguageHeaderValueCollection_IndexOf(py::wrapper::Windows::Web::Http::Headers::HttpLanguageHeaderValueCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpLanguageHeaderValueCollection", L"IndexOf", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Globalization::Language>(args, 0);
                uint32_t param1 {  };

                auto return_value = self->obj.IndexOf(param0, param1);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out1.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpLanguageHeaderValueCollection_InsertAt(py::wrapper::Windows::Web::Http::Headers::HttpLanguageHeaderValueCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpLanguageHeaderValueCollection", L"InsertAt", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Globalization::Language>(args, 1);

                self->obj.InsertAt(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpLanguageHeaderValueCollection_ParseAdd(py::wrapper::Windows::Web::Http::Headers::HttpLanguageHeaderValueCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpLanguageHeaderValueCollection", L"ParseAdd", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                self->obj.ParseAdd(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpLanguageHeaderValueCollection_RemoveAt(py::wrapper::Windows::Web::Http::Headers::HttpLanguageHeaderValueCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpLanguageHeaderValueCollection", L"RemoveAt", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint32_t>(args, 0);

                self->obj.RemoveAt(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpLanguageHeaderValueCollection_RemoveAtEnd(py::wrapper::Windows::Web::Http::Headers::HttpLanguageHeaderValueCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpLanguageHeaderValueCollection", L"RemoveAtEnd", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.RemoveAtEnd();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpLanguageHeaderValueCollection_ReplaceAll(py::wrapper::Windows::Web::Http::Headers::HttpLanguageHeaderValueCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpLanguageHeaderValueCollection", L"ReplaceAll", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<py::pybuf_view<winrt::Windows::Globalization::Language, false>>(args, 0);

                self->obj.ReplaceAll(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpLanguageHeaderValueCollection_SetAt(py::wrapper::Windows::Web::Http::Headers::HttpLanguageHeaderValueCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpLanguageHeaderValueCollection", L"SetAt", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Globalization::Language>(args, 1);

                self->obj.SetAt(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpLanguageHeaderValueCollection_ToString(py::wrapper::Windows::Web::Http::Headers::HttpLanguageHeaderValueCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpLanguageHeaderValueCollection", L"ToString", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.ToString());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpLanguageHeaderValueCollection_TryParseAdd(py::wrapper::Windows::Web::Http::Headers::HttpLanguageHeaderValueCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpLanguageHeaderValueCollection", L"TryParseAdd", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.TryParseAdd(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpLanguageHeaderValueCollection_get_Size(py::wrapper::Windows::Web::Http::Headers::HttpLanguageHeaderValueCollection* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.Headers.HttpLanguageHeaderValueCollection", L"Size"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_HttpLanguageHeaderValueCollection(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Web::Http::Headers::HttpLanguageHeaderValueCollection>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_HttpLanguageHeaderValueCollection(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Web::Http::Headers::HttpLanguageHeaderValueCollection>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _str_HttpLanguageHeaderValueCollection(py::wrapper::Windows::Web::Http::Headers::HttpLanguageHeaderValueCollection* self) noexcept
    {
        try
        {
            return py::convert(self->obj.ToString());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _iterator_HttpLanguageHeaderValueCollection(py::wrapper::Windows::Web::Http::Headers::HttpLanguageHeaderValueCollection* self) noexcept
    {
        try
        {
            return py::convert(self->obj.First());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static Py_ssize_t _seq_length_HttpLanguageHeaderValueCollection(py::wrapper::Windows::Web::Http::Headers::HttpLanguageHeaderValueCollection* self) noexcept
    {
        try
        {
            return static_cast<Py_ssize_t>(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _seq_item_HttpLanguageHeaderValueCollection(py::wrapper::Windows::Web::Http::Headers::HttpLanguageHeaderValueCollection* self, Py_ssize_t i) noexcept
    {
        try
        {
            return py::convert(self->obj.GetAt(static_cast<uint32_t>(i)));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _seq_subscript_HttpLanguageHeaderValueCollection(py::wrapper::Windows::Web::Http::Headers::HttpLanguageHeaderValueCollection* self, PyObject* slice) noexcept
    {
        try
        {
            if (PyIndex_Check(slice))
            {
                pyobj_handle index{PyNumber_Index(slice)};

                if (!index)
                {
                    return nullptr;
                }

                auto i = PyNumber_AsSsize_t(index.get(), PyExc_IndexError);

                if (i == -1 && PyErr_Occurred())
                {
                    return nullptr;
                }

                return _seq_item_HttpLanguageHeaderValueCollection(self, i);
            }

            if (!PySlice_Check(slice))
            {
                PyErr_Format(
                    PyExc_TypeError,
                    "indicies must be integers, not '%s'",
                    Py_TYPE(slice)->tp_name);
            }

            Py_ssize_t start, stop, step, length;

            if (PySlice_GetIndicesEx(
                    slice, self->obj.Size(), &start, &stop, &step, &length)
                < 0)
            {
                return nullptr;
            }

            if (step != 1)
            {
                PyErr_SetString(PyExc_NotImplementedError, "slices with step other than 1 are not implemented");
                return nullptr;
            }

            winrt::com_array<winrt::Windows::Globalization::Language> items(static_cast<uint32_t>(length), empty_instance<winrt::Windows::Globalization::Language>::get());

            auto count = self->obj.GetMany(static_cast<uint32_t>(start), items);

            if (count != static_cast<uint32_t>(length))
            {
                PyErr_Format(PyExc_RuntimeError, "returned count %d did not match requested length %zd", count, length);
                return nullptr;
            }

            return convert(items);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int _seq_assign_HttpLanguageHeaderValueCollection(py::wrapper::Windows::Web::Http::Headers::HttpLanguageHeaderValueCollection* self, Py_ssize_t i, PyObject* value) noexcept
    {
        try
        {
            if (!value)
            {
                self->obj.RemoveAt(static_cast<uint32_t>(i));
            }
            else
            {
                self->obj.SetAt(static_cast<uint32_t>(i), py::convert_to<winrt::Windows::Globalization::Language>(value));
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyMethodDef _methods_HttpLanguageHeaderValueCollection[] = {
        { "append", reinterpret_cast<PyCFunction>(HttpLanguageHeaderValueCollection_Append), METH_VARARGS, nullptr },
        { "clear", reinterpret_cast<PyCFunction>(HttpLanguageHeaderValueCollection_Clear), METH_VARARGS, nullptr },
        { "first", reinterpret_cast<PyCFunction>(HttpLanguageHeaderValueCollection_First), METH_VARARGS, nullptr },
        { "get_at", reinterpret_cast<PyCFunction>(HttpLanguageHeaderValueCollection_GetAt), METH_VARARGS, nullptr },
        { "get_many", reinterpret_cast<PyCFunction>(HttpLanguageHeaderValueCollection_GetMany), METH_VARARGS, nullptr },
        { "get_view", reinterpret_cast<PyCFunction>(HttpLanguageHeaderValueCollection_GetView), METH_VARARGS, nullptr },
        { "index_of", reinterpret_cast<PyCFunction>(HttpLanguageHeaderValueCollection_IndexOf), METH_VARARGS, nullptr },
        { "insert_at", reinterpret_cast<PyCFunction>(HttpLanguageHeaderValueCollection_InsertAt), METH_VARARGS, nullptr },
        { "parse_add", reinterpret_cast<PyCFunction>(HttpLanguageHeaderValueCollection_ParseAdd), METH_VARARGS, nullptr },
        { "remove_at", reinterpret_cast<PyCFunction>(HttpLanguageHeaderValueCollection_RemoveAt), METH_VARARGS, nullptr },
        { "remove_at_end", reinterpret_cast<PyCFunction>(HttpLanguageHeaderValueCollection_RemoveAtEnd), METH_VARARGS, nullptr },
        { "replace_all", reinterpret_cast<PyCFunction>(HttpLanguageHeaderValueCollection_ReplaceAll), METH_VARARGS, nullptr },
        { "set_at", reinterpret_cast<PyCFunction>(HttpLanguageHeaderValueCollection_SetAt), METH_VARARGS, nullptr },
        { "to_string", reinterpret_cast<PyCFunction>(HttpLanguageHeaderValueCollection_ToString), METH_VARARGS, nullptr },
        { "try_parse_add", reinterpret_cast<PyCFunction>(HttpLanguageHeaderValueCollection_TryParseAdd), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_HttpLanguageHeaderValueCollection, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_HttpLanguageHeaderValueCollection), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_HttpLanguageHeaderValueCollection[] = {
        { "size", reinterpret_cast<getter>(HttpLanguageHeaderValueCollection_get_Size), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_HttpLanguageHeaderValueCollection[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_HttpLanguageHeaderValueCollection) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_HttpLanguageHeaderValueCollection) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_HttpLanguageHeaderValueCollection) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_HttpLanguageHeaderValueCollection) },
        { Py_tp_str, reinterpret_cast<void*>(_str_HttpLanguageHeaderValueCollection) },
        { Py_tp_iter, reinterpret_cast<void*>(_iterator_HttpLanguageHeaderValueCollection) },
        { Py_sq_length, reinterpret_cast<void*>(_seq_length_HttpLanguageHeaderValueCollection) },
        { Py_sq_item, reinterpret_cast<void*>(_seq_item_HttpLanguageHeaderValueCollection) },
        { Py_mp_subscript, reinterpret_cast<void*>(_seq_subscript_HttpLanguageHeaderValueCollection) },
        { Py_sq_ass_item, reinterpret_cast<void*>(_seq_assign_HttpLanguageHeaderValueCollection) },
        { },
    };

    static PyType_Spec type_spec_HttpLanguageHeaderValueCollection =
    {
        "winrt._winrt_windows_web_http_headers.HttpLanguageHeaderValueCollection",
        sizeof(py::wrapper::Windows::Web::Http::Headers::HttpLanguageHeaderValueCollection),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_HttpLanguageHeaderValueCollection
    };

    // ----- HttpLanguageRangeWithQualityHeaderValue class --------------------

    static PyObject* _new_HttpLanguageRangeWithQualityHeaderValue(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                winrt::Windows::Web::Http::Headers::HttpLanguageRangeWithQualityHeaderValue instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<double>(args, 1);

                winrt::Windows::Web::Http::Headers::HttpLanguageRangeWithQualityHeaderValue instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_HttpLanguageRangeWithQualityHeaderValue(py::wrapper::Windows::Web::Http::Headers::HttpLanguageRangeWithQualityHeaderValue* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* HttpLanguageRangeWithQualityHeaderValue_Parse(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpLanguageRangeWithQualityHeaderValue", L"Parse", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Web::Http::Headers::HttpLanguageRangeWithQualityHeaderValue::Parse(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpLanguageRangeWithQualityHeaderValue_ToString(py::wrapper::Windows::Web::Http::Headers::HttpLanguageRangeWithQualityHeaderValue* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpLanguageRangeWithQualityHeaderValue", L"ToString", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.ToString());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpLanguageRangeWithQualityHeaderValue_TryParse(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpLanguageRangeWithQualityHeaderValue", L"TryParse", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                winrt::Windows::Web::Http::Headers::HttpLanguageRangeWithQualityHeaderValue param1 { nullptr };

                auto return_value = winrt::Windows::Web::Http::Headers::HttpLanguageRangeWithQualityHeaderValue::TryParse(param0, param1);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out1.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpLanguageRangeWithQualityHeaderValue_get_LanguageRange(py::wrapper::Windows::Web::Http::Headers::HttpLanguageRangeWithQualityHeaderValue* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.Headers.HttpLanguageRangeWithQualityHeaderValue", L"LanguageRange"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.LanguageRange());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HttpLanguageRangeWithQualityHeaderValue_get_Quality(py::wrapper::Windows::Web::Http::Headers::HttpLanguageRangeWithQualityHeaderValue* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.Headers.HttpLanguageRangeWithQualityHeaderValue", L"Quality"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Quality());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_HttpLanguageRangeWithQualityHeaderValue(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Web::Http::Headers::HttpLanguageRangeWithQualityHeaderValue>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_HttpLanguageRangeWithQualityHeaderValue(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Web::Http::Headers::HttpLanguageRangeWithQualityHeaderValue>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _str_HttpLanguageRangeWithQualityHeaderValue(py::wrapper::Windows::Web::Http::Headers::HttpLanguageRangeWithQualityHeaderValue* self) noexcept
    {
        try
        {
            return py::convert(self->obj.ToString());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_HttpLanguageRangeWithQualityHeaderValue[] = {
        { "to_string", reinterpret_cast<PyCFunction>(HttpLanguageRangeWithQualityHeaderValue_ToString), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_HttpLanguageRangeWithQualityHeaderValue, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_HttpLanguageRangeWithQualityHeaderValue), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_HttpLanguageRangeWithQualityHeaderValue[] = {
        { "language_range", reinterpret_cast<getter>(HttpLanguageRangeWithQualityHeaderValue_get_LanguageRange), nullptr, nullptr, nullptr },
        { "quality", reinterpret_cast<getter>(HttpLanguageRangeWithQualityHeaderValue_get_Quality), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_HttpLanguageRangeWithQualityHeaderValue[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_HttpLanguageRangeWithQualityHeaderValue) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_HttpLanguageRangeWithQualityHeaderValue) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_HttpLanguageRangeWithQualityHeaderValue) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_HttpLanguageRangeWithQualityHeaderValue) },
        { Py_tp_str, reinterpret_cast<void*>(_str_HttpLanguageRangeWithQualityHeaderValue) },
        { },
    };

    static PyType_Spec type_spec_HttpLanguageRangeWithQualityHeaderValue =
    {
        "winrt._winrt_windows_web_http_headers.HttpLanguageRangeWithQualityHeaderValue",
        sizeof(py::wrapper::Windows::Web::Http::Headers::HttpLanguageRangeWithQualityHeaderValue),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_HttpLanguageRangeWithQualityHeaderValue
    };

    static PyGetSetDef getset_HttpLanguageRangeWithQualityHeaderValue_Static[] = {
        { }
    };

    static PyMethodDef methods_HttpLanguageRangeWithQualityHeaderValue_Static[] = {
        { "parse", reinterpret_cast<PyCFunction>(HttpLanguageRangeWithQualityHeaderValue_Parse), METH_VARARGS, nullptr },
        { "try_parse", reinterpret_cast<PyCFunction>(HttpLanguageRangeWithQualityHeaderValue_TryParse), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_HttpLanguageRangeWithQualityHeaderValue_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_HttpLanguageRangeWithQualityHeaderValue_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_HttpLanguageRangeWithQualityHeaderValue_Static) },
        { }
    };

    static PyType_Spec type_spec_HttpLanguageRangeWithQualityHeaderValue_Static =
    {
        "winrt._winrt_windows_web_http_headers.HttpLanguageRangeWithQualityHeaderValue_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_HttpLanguageRangeWithQualityHeaderValue_Static
    };

    // ----- HttpLanguageRangeWithQualityHeaderValueCollection class --------------------

    static PyObject* _new_HttpLanguageRangeWithQualityHeaderValueCollection(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Web::Http::Headers::HttpLanguageRangeWithQualityHeaderValueCollection>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Web::Http::Headers::HttpLanguageRangeWithQualityHeaderValueCollection>::type_name);
        return nullptr;
    }

    static void _dealloc_HttpLanguageRangeWithQualityHeaderValueCollection(py::wrapper::Windows::Web::Http::Headers::HttpLanguageRangeWithQualityHeaderValueCollection* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* HttpLanguageRangeWithQualityHeaderValueCollection_Append(py::wrapper::Windows::Web::Http::Headers::HttpLanguageRangeWithQualityHeaderValueCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpLanguageRangeWithQualityHeaderValueCollection", L"Append", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Web::Http::Headers::HttpLanguageRangeWithQualityHeaderValue>(args, 0);

                self->obj.Append(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpLanguageRangeWithQualityHeaderValueCollection_Clear(py::wrapper::Windows::Web::Http::Headers::HttpLanguageRangeWithQualityHeaderValueCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpLanguageRangeWithQualityHeaderValueCollection", L"Clear", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Clear();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpLanguageRangeWithQualityHeaderValueCollection_First(py::wrapper::Windows::Web::Http::Headers::HttpLanguageRangeWithQualityHeaderValueCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpLanguageRangeWithQualityHeaderValueCollection", L"First", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.First());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpLanguageRangeWithQualityHeaderValueCollection_GetAt(py::wrapper::Windows::Web::Http::Headers::HttpLanguageRangeWithQualityHeaderValueCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpLanguageRangeWithQualityHeaderValueCollection", L"GetAt", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint32_t>(args, 0);

                return py::convert(self->obj.GetAt(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpLanguageRangeWithQualityHeaderValueCollection_GetMany(py::wrapper::Windows::Web::Http::Headers::HttpLanguageRangeWithQualityHeaderValueCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpLanguageRangeWithQualityHeaderValueCollection", L"GetMany", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<winrt::Windows::Web::Http::Headers::HttpLanguageRangeWithQualityHeaderValue, true>>(args, 1);

                return py::convert(self->obj.GetMany(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpLanguageRangeWithQualityHeaderValueCollection_GetView(py::wrapper::Windows::Web::Http::Headers::HttpLanguageRangeWithQualityHeaderValueCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpLanguageRangeWithQualityHeaderValueCollection", L"GetView", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetView());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpLanguageRangeWithQualityHeaderValueCollection_IndexOf(py::wrapper::Windows::Web::Http::Headers::HttpLanguageRangeWithQualityHeaderValueCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpLanguageRangeWithQualityHeaderValueCollection", L"IndexOf", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Web::Http::Headers::HttpLanguageRangeWithQualityHeaderValue>(args, 0);
                uint32_t param1 {  };

                auto return_value = self->obj.IndexOf(param0, param1);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out1.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpLanguageRangeWithQualityHeaderValueCollection_InsertAt(py::wrapper::Windows::Web::Http::Headers::HttpLanguageRangeWithQualityHeaderValueCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpLanguageRangeWithQualityHeaderValueCollection", L"InsertAt", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Web::Http::Headers::HttpLanguageRangeWithQualityHeaderValue>(args, 1);

                self->obj.InsertAt(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpLanguageRangeWithQualityHeaderValueCollection_ParseAdd(py::wrapper::Windows::Web::Http::Headers::HttpLanguageRangeWithQualityHeaderValueCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpLanguageRangeWithQualityHeaderValueCollection", L"ParseAdd", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                self->obj.ParseAdd(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpLanguageRangeWithQualityHeaderValueCollection_RemoveAt(py::wrapper::Windows::Web::Http::Headers::HttpLanguageRangeWithQualityHeaderValueCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpLanguageRangeWithQualityHeaderValueCollection", L"RemoveAt", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint32_t>(args, 0);

                self->obj.RemoveAt(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpLanguageRangeWithQualityHeaderValueCollection_RemoveAtEnd(py::wrapper::Windows::Web::Http::Headers::HttpLanguageRangeWithQualityHeaderValueCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpLanguageRangeWithQualityHeaderValueCollection", L"RemoveAtEnd", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.RemoveAtEnd();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpLanguageRangeWithQualityHeaderValueCollection_ReplaceAll(py::wrapper::Windows::Web::Http::Headers::HttpLanguageRangeWithQualityHeaderValueCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpLanguageRangeWithQualityHeaderValueCollection", L"ReplaceAll", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<py::pybuf_view<winrt::Windows::Web::Http::Headers::HttpLanguageRangeWithQualityHeaderValue, false>>(args, 0);

                self->obj.ReplaceAll(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpLanguageRangeWithQualityHeaderValueCollection_SetAt(py::wrapper::Windows::Web::Http::Headers::HttpLanguageRangeWithQualityHeaderValueCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpLanguageRangeWithQualityHeaderValueCollection", L"SetAt", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Web::Http::Headers::HttpLanguageRangeWithQualityHeaderValue>(args, 1);

                self->obj.SetAt(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpLanguageRangeWithQualityHeaderValueCollection_ToString(py::wrapper::Windows::Web::Http::Headers::HttpLanguageRangeWithQualityHeaderValueCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpLanguageRangeWithQualityHeaderValueCollection", L"ToString", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.ToString());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpLanguageRangeWithQualityHeaderValueCollection_TryParseAdd(py::wrapper::Windows::Web::Http::Headers::HttpLanguageRangeWithQualityHeaderValueCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpLanguageRangeWithQualityHeaderValueCollection", L"TryParseAdd", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.TryParseAdd(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpLanguageRangeWithQualityHeaderValueCollection_get_Size(py::wrapper::Windows::Web::Http::Headers::HttpLanguageRangeWithQualityHeaderValueCollection* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.Headers.HttpLanguageRangeWithQualityHeaderValueCollection", L"Size"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_HttpLanguageRangeWithQualityHeaderValueCollection(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Web::Http::Headers::HttpLanguageRangeWithQualityHeaderValueCollection>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_HttpLanguageRangeWithQualityHeaderValueCollection(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Web::Http::Headers::HttpLanguageRangeWithQualityHeaderValueCollection>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _str_HttpLanguageRangeWithQualityHeaderValueCollection(py::wrapper::Windows::Web::Http::Headers::HttpLanguageRangeWithQualityHeaderValueCollection* self) noexcept
    {
        try
        {
            return py::convert(self->obj.ToString());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _iterator_HttpLanguageRangeWithQualityHeaderValueCollection(py::wrapper::Windows::Web::Http::Headers::HttpLanguageRangeWithQualityHeaderValueCollection* self) noexcept
    {
        try
        {
            return py::convert(self->obj.First());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static Py_ssize_t _seq_length_HttpLanguageRangeWithQualityHeaderValueCollection(py::wrapper::Windows::Web::Http::Headers::HttpLanguageRangeWithQualityHeaderValueCollection* self) noexcept
    {
        try
        {
            return static_cast<Py_ssize_t>(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _seq_item_HttpLanguageRangeWithQualityHeaderValueCollection(py::wrapper::Windows::Web::Http::Headers::HttpLanguageRangeWithQualityHeaderValueCollection* self, Py_ssize_t i) noexcept
    {
        try
        {
            return py::convert(self->obj.GetAt(static_cast<uint32_t>(i)));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _seq_subscript_HttpLanguageRangeWithQualityHeaderValueCollection(py::wrapper::Windows::Web::Http::Headers::HttpLanguageRangeWithQualityHeaderValueCollection* self, PyObject* slice) noexcept
    {
        try
        {
            if (PyIndex_Check(slice))
            {
                pyobj_handle index{PyNumber_Index(slice)};

                if (!index)
                {
                    return nullptr;
                }

                auto i = PyNumber_AsSsize_t(index.get(), PyExc_IndexError);

                if (i == -1 && PyErr_Occurred())
                {
                    return nullptr;
                }

                return _seq_item_HttpLanguageRangeWithQualityHeaderValueCollection(self, i);
            }

            if (!PySlice_Check(slice))
            {
                PyErr_Format(
                    PyExc_TypeError,
                    "indicies must be integers, not '%s'",
                    Py_TYPE(slice)->tp_name);
            }

            Py_ssize_t start, stop, step, length;

            if (PySlice_GetIndicesEx(
                    slice, self->obj.Size(), &start, &stop, &step, &length)
                < 0)
            {
                return nullptr;
            }

            if (step != 1)
            {
                PyErr_SetString(PyExc_NotImplementedError, "slices with step other than 1 are not implemented");
                return nullptr;
            }

            winrt::com_array<winrt::Windows::Web::Http::Headers::HttpLanguageRangeWithQualityHeaderValue> items(static_cast<uint32_t>(length), empty_instance<winrt::Windows::Web::Http::Headers::HttpLanguageRangeWithQualityHeaderValue>::get());

            auto count = self->obj.GetMany(static_cast<uint32_t>(start), items);

            if (count != static_cast<uint32_t>(length))
            {
                PyErr_Format(PyExc_RuntimeError, "returned count %d did not match requested length %zd", count, length);
                return nullptr;
            }

            return convert(items);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int _seq_assign_HttpLanguageRangeWithQualityHeaderValueCollection(py::wrapper::Windows::Web::Http::Headers::HttpLanguageRangeWithQualityHeaderValueCollection* self, Py_ssize_t i, PyObject* value) noexcept
    {
        try
        {
            if (!value)
            {
                self->obj.RemoveAt(static_cast<uint32_t>(i));
            }
            else
            {
                self->obj.SetAt(static_cast<uint32_t>(i), py::convert_to<winrt::Windows::Web::Http::Headers::HttpLanguageRangeWithQualityHeaderValue>(value));
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyMethodDef _methods_HttpLanguageRangeWithQualityHeaderValueCollection[] = {
        { "append", reinterpret_cast<PyCFunction>(HttpLanguageRangeWithQualityHeaderValueCollection_Append), METH_VARARGS, nullptr },
        { "clear", reinterpret_cast<PyCFunction>(HttpLanguageRangeWithQualityHeaderValueCollection_Clear), METH_VARARGS, nullptr },
        { "first", reinterpret_cast<PyCFunction>(HttpLanguageRangeWithQualityHeaderValueCollection_First), METH_VARARGS, nullptr },
        { "get_at", reinterpret_cast<PyCFunction>(HttpLanguageRangeWithQualityHeaderValueCollection_GetAt), METH_VARARGS, nullptr },
        { "get_many", reinterpret_cast<PyCFunction>(HttpLanguageRangeWithQualityHeaderValueCollection_GetMany), METH_VARARGS, nullptr },
        { "get_view", reinterpret_cast<PyCFunction>(HttpLanguageRangeWithQualityHeaderValueCollection_GetView), METH_VARARGS, nullptr },
        { "index_of", reinterpret_cast<PyCFunction>(HttpLanguageRangeWithQualityHeaderValueCollection_IndexOf), METH_VARARGS, nullptr },
        { "insert_at", reinterpret_cast<PyCFunction>(HttpLanguageRangeWithQualityHeaderValueCollection_InsertAt), METH_VARARGS, nullptr },
        { "parse_add", reinterpret_cast<PyCFunction>(HttpLanguageRangeWithQualityHeaderValueCollection_ParseAdd), METH_VARARGS, nullptr },
        { "remove_at", reinterpret_cast<PyCFunction>(HttpLanguageRangeWithQualityHeaderValueCollection_RemoveAt), METH_VARARGS, nullptr },
        { "remove_at_end", reinterpret_cast<PyCFunction>(HttpLanguageRangeWithQualityHeaderValueCollection_RemoveAtEnd), METH_VARARGS, nullptr },
        { "replace_all", reinterpret_cast<PyCFunction>(HttpLanguageRangeWithQualityHeaderValueCollection_ReplaceAll), METH_VARARGS, nullptr },
        { "set_at", reinterpret_cast<PyCFunction>(HttpLanguageRangeWithQualityHeaderValueCollection_SetAt), METH_VARARGS, nullptr },
        { "to_string", reinterpret_cast<PyCFunction>(HttpLanguageRangeWithQualityHeaderValueCollection_ToString), METH_VARARGS, nullptr },
        { "try_parse_add", reinterpret_cast<PyCFunction>(HttpLanguageRangeWithQualityHeaderValueCollection_TryParseAdd), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_HttpLanguageRangeWithQualityHeaderValueCollection, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_HttpLanguageRangeWithQualityHeaderValueCollection), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_HttpLanguageRangeWithQualityHeaderValueCollection[] = {
        { "size", reinterpret_cast<getter>(HttpLanguageRangeWithQualityHeaderValueCollection_get_Size), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_HttpLanguageRangeWithQualityHeaderValueCollection[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_HttpLanguageRangeWithQualityHeaderValueCollection) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_HttpLanguageRangeWithQualityHeaderValueCollection) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_HttpLanguageRangeWithQualityHeaderValueCollection) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_HttpLanguageRangeWithQualityHeaderValueCollection) },
        { Py_tp_str, reinterpret_cast<void*>(_str_HttpLanguageRangeWithQualityHeaderValueCollection) },
        { Py_tp_iter, reinterpret_cast<void*>(_iterator_HttpLanguageRangeWithQualityHeaderValueCollection) },
        { Py_sq_length, reinterpret_cast<void*>(_seq_length_HttpLanguageRangeWithQualityHeaderValueCollection) },
        { Py_sq_item, reinterpret_cast<void*>(_seq_item_HttpLanguageRangeWithQualityHeaderValueCollection) },
        { Py_mp_subscript, reinterpret_cast<void*>(_seq_subscript_HttpLanguageRangeWithQualityHeaderValueCollection) },
        { Py_sq_ass_item, reinterpret_cast<void*>(_seq_assign_HttpLanguageRangeWithQualityHeaderValueCollection) },
        { },
    };

    static PyType_Spec type_spec_HttpLanguageRangeWithQualityHeaderValueCollection =
    {
        "winrt._winrt_windows_web_http_headers.HttpLanguageRangeWithQualityHeaderValueCollection",
        sizeof(py::wrapper::Windows::Web::Http::Headers::HttpLanguageRangeWithQualityHeaderValueCollection),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_HttpLanguageRangeWithQualityHeaderValueCollection
    };

    // ----- HttpMediaTypeHeaderValue class --------------------

    static PyObject* _new_HttpMediaTypeHeaderValue(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                winrt::Windows::Web::Http::Headers::HttpMediaTypeHeaderValue instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_HttpMediaTypeHeaderValue(py::wrapper::Windows::Web::Http::Headers::HttpMediaTypeHeaderValue* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* HttpMediaTypeHeaderValue_Parse(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpMediaTypeHeaderValue", L"Parse", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Web::Http::Headers::HttpMediaTypeHeaderValue::Parse(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpMediaTypeHeaderValue_ToString(py::wrapper::Windows::Web::Http::Headers::HttpMediaTypeHeaderValue* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpMediaTypeHeaderValue", L"ToString", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.ToString());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpMediaTypeHeaderValue_TryParse(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpMediaTypeHeaderValue", L"TryParse", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                winrt::Windows::Web::Http::Headers::HttpMediaTypeHeaderValue param1 { nullptr };

                auto return_value = winrt::Windows::Web::Http::Headers::HttpMediaTypeHeaderValue::TryParse(param0, param1);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out1.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpMediaTypeHeaderValue_get_MediaType(py::wrapper::Windows::Web::Http::Headers::HttpMediaTypeHeaderValue* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.Headers.HttpMediaTypeHeaderValue", L"MediaType"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.MediaType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int HttpMediaTypeHeaderValue_put_MediaType(py::wrapper::Windows::Web::Http::Headers::HttpMediaTypeHeaderValue* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.Headers.HttpMediaTypeHeaderValue", L"MediaType"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.MediaType(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* HttpMediaTypeHeaderValue_get_CharSet(py::wrapper::Windows::Web::Http::Headers::HttpMediaTypeHeaderValue* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.Headers.HttpMediaTypeHeaderValue", L"CharSet"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CharSet());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int HttpMediaTypeHeaderValue_put_CharSet(py::wrapper::Windows::Web::Http::Headers::HttpMediaTypeHeaderValue* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.Headers.HttpMediaTypeHeaderValue", L"CharSet"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.CharSet(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* HttpMediaTypeHeaderValue_get_Parameters(py::wrapper::Windows::Web::Http::Headers::HttpMediaTypeHeaderValue* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.Headers.HttpMediaTypeHeaderValue", L"Parameters"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Parameters());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_HttpMediaTypeHeaderValue(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Web::Http::Headers::HttpMediaTypeHeaderValue>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_HttpMediaTypeHeaderValue(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Web::Http::Headers::HttpMediaTypeHeaderValue>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _str_HttpMediaTypeHeaderValue(py::wrapper::Windows::Web::Http::Headers::HttpMediaTypeHeaderValue* self) noexcept
    {
        try
        {
            return py::convert(self->obj.ToString());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_HttpMediaTypeHeaderValue[] = {
        { "to_string", reinterpret_cast<PyCFunction>(HttpMediaTypeHeaderValue_ToString), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_HttpMediaTypeHeaderValue, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_HttpMediaTypeHeaderValue), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_HttpMediaTypeHeaderValue[] = {
        { "media_type", reinterpret_cast<getter>(HttpMediaTypeHeaderValue_get_MediaType), reinterpret_cast<setter>(HttpMediaTypeHeaderValue_put_MediaType), nullptr, nullptr },
        { "char_set", reinterpret_cast<getter>(HttpMediaTypeHeaderValue_get_CharSet), reinterpret_cast<setter>(HttpMediaTypeHeaderValue_put_CharSet), nullptr, nullptr },
        { "parameters", reinterpret_cast<getter>(HttpMediaTypeHeaderValue_get_Parameters), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_HttpMediaTypeHeaderValue[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_HttpMediaTypeHeaderValue) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_HttpMediaTypeHeaderValue) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_HttpMediaTypeHeaderValue) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_HttpMediaTypeHeaderValue) },
        { Py_tp_str, reinterpret_cast<void*>(_str_HttpMediaTypeHeaderValue) },
        { },
    };

    static PyType_Spec type_spec_HttpMediaTypeHeaderValue =
    {
        "winrt._winrt_windows_web_http_headers.HttpMediaTypeHeaderValue",
        sizeof(py::wrapper::Windows::Web::Http::Headers::HttpMediaTypeHeaderValue),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_HttpMediaTypeHeaderValue
    };

    static PyGetSetDef getset_HttpMediaTypeHeaderValue_Static[] = {
        { }
    };

    static PyMethodDef methods_HttpMediaTypeHeaderValue_Static[] = {
        { "parse", reinterpret_cast<PyCFunction>(HttpMediaTypeHeaderValue_Parse), METH_VARARGS, nullptr },
        { "try_parse", reinterpret_cast<PyCFunction>(HttpMediaTypeHeaderValue_TryParse), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_HttpMediaTypeHeaderValue_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_HttpMediaTypeHeaderValue_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_HttpMediaTypeHeaderValue_Static) },
        { }
    };

    static PyType_Spec type_spec_HttpMediaTypeHeaderValue_Static =
    {
        "winrt._winrt_windows_web_http_headers.HttpMediaTypeHeaderValue_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_HttpMediaTypeHeaderValue_Static
    };

    // ----- HttpMediaTypeWithQualityHeaderValue class --------------------

    static PyObject* _new_HttpMediaTypeWithQualityHeaderValue(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                winrt::Windows::Web::Http::Headers::HttpMediaTypeWithQualityHeaderValue instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<double>(args, 1);

                winrt::Windows::Web::Http::Headers::HttpMediaTypeWithQualityHeaderValue instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_HttpMediaTypeWithQualityHeaderValue(py::wrapper::Windows::Web::Http::Headers::HttpMediaTypeWithQualityHeaderValue* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* HttpMediaTypeWithQualityHeaderValue_Parse(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpMediaTypeWithQualityHeaderValue", L"Parse", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Web::Http::Headers::HttpMediaTypeWithQualityHeaderValue::Parse(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpMediaTypeWithQualityHeaderValue_ToString(py::wrapper::Windows::Web::Http::Headers::HttpMediaTypeWithQualityHeaderValue* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpMediaTypeWithQualityHeaderValue", L"ToString", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.ToString());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpMediaTypeWithQualityHeaderValue_TryParse(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpMediaTypeWithQualityHeaderValue", L"TryParse", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                winrt::Windows::Web::Http::Headers::HttpMediaTypeWithQualityHeaderValue param1 { nullptr };

                auto return_value = winrt::Windows::Web::Http::Headers::HttpMediaTypeWithQualityHeaderValue::TryParse(param0, param1);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out1.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpMediaTypeWithQualityHeaderValue_get_Quality(py::wrapper::Windows::Web::Http::Headers::HttpMediaTypeWithQualityHeaderValue* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.Headers.HttpMediaTypeWithQualityHeaderValue", L"Quality"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Quality());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int HttpMediaTypeWithQualityHeaderValue_put_Quality(py::wrapper::Windows::Web::Http::Headers::HttpMediaTypeWithQualityHeaderValue* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.Headers.HttpMediaTypeWithQualityHeaderValue", L"Quality"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<double>>(arg);

            self->obj.Quality(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* HttpMediaTypeWithQualityHeaderValue_get_MediaType(py::wrapper::Windows::Web::Http::Headers::HttpMediaTypeWithQualityHeaderValue* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.Headers.HttpMediaTypeWithQualityHeaderValue", L"MediaType"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.MediaType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int HttpMediaTypeWithQualityHeaderValue_put_MediaType(py::wrapper::Windows::Web::Http::Headers::HttpMediaTypeWithQualityHeaderValue* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.Headers.HttpMediaTypeWithQualityHeaderValue", L"MediaType"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.MediaType(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* HttpMediaTypeWithQualityHeaderValue_get_CharSet(py::wrapper::Windows::Web::Http::Headers::HttpMediaTypeWithQualityHeaderValue* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.Headers.HttpMediaTypeWithQualityHeaderValue", L"CharSet"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CharSet());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int HttpMediaTypeWithQualityHeaderValue_put_CharSet(py::wrapper::Windows::Web::Http::Headers::HttpMediaTypeWithQualityHeaderValue* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.Headers.HttpMediaTypeWithQualityHeaderValue", L"CharSet"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.CharSet(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* HttpMediaTypeWithQualityHeaderValue_get_Parameters(py::wrapper::Windows::Web::Http::Headers::HttpMediaTypeWithQualityHeaderValue* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.Headers.HttpMediaTypeWithQualityHeaderValue", L"Parameters"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Parameters());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_HttpMediaTypeWithQualityHeaderValue(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Web::Http::Headers::HttpMediaTypeWithQualityHeaderValue>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_HttpMediaTypeWithQualityHeaderValue(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Web::Http::Headers::HttpMediaTypeWithQualityHeaderValue>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _str_HttpMediaTypeWithQualityHeaderValue(py::wrapper::Windows::Web::Http::Headers::HttpMediaTypeWithQualityHeaderValue* self) noexcept
    {
        try
        {
            return py::convert(self->obj.ToString());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_HttpMediaTypeWithQualityHeaderValue[] = {
        { "to_string", reinterpret_cast<PyCFunction>(HttpMediaTypeWithQualityHeaderValue_ToString), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_HttpMediaTypeWithQualityHeaderValue, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_HttpMediaTypeWithQualityHeaderValue), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_HttpMediaTypeWithQualityHeaderValue[] = {
        { "quality", reinterpret_cast<getter>(HttpMediaTypeWithQualityHeaderValue_get_Quality), reinterpret_cast<setter>(HttpMediaTypeWithQualityHeaderValue_put_Quality), nullptr, nullptr },
        { "media_type", reinterpret_cast<getter>(HttpMediaTypeWithQualityHeaderValue_get_MediaType), reinterpret_cast<setter>(HttpMediaTypeWithQualityHeaderValue_put_MediaType), nullptr, nullptr },
        { "char_set", reinterpret_cast<getter>(HttpMediaTypeWithQualityHeaderValue_get_CharSet), reinterpret_cast<setter>(HttpMediaTypeWithQualityHeaderValue_put_CharSet), nullptr, nullptr },
        { "parameters", reinterpret_cast<getter>(HttpMediaTypeWithQualityHeaderValue_get_Parameters), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_HttpMediaTypeWithQualityHeaderValue[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_HttpMediaTypeWithQualityHeaderValue) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_HttpMediaTypeWithQualityHeaderValue) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_HttpMediaTypeWithQualityHeaderValue) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_HttpMediaTypeWithQualityHeaderValue) },
        { Py_tp_str, reinterpret_cast<void*>(_str_HttpMediaTypeWithQualityHeaderValue) },
        { },
    };

    static PyType_Spec type_spec_HttpMediaTypeWithQualityHeaderValue =
    {
        "winrt._winrt_windows_web_http_headers.HttpMediaTypeWithQualityHeaderValue",
        sizeof(py::wrapper::Windows::Web::Http::Headers::HttpMediaTypeWithQualityHeaderValue),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_HttpMediaTypeWithQualityHeaderValue
    };

    static PyGetSetDef getset_HttpMediaTypeWithQualityHeaderValue_Static[] = {
        { }
    };

    static PyMethodDef methods_HttpMediaTypeWithQualityHeaderValue_Static[] = {
        { "parse", reinterpret_cast<PyCFunction>(HttpMediaTypeWithQualityHeaderValue_Parse), METH_VARARGS, nullptr },
        { "try_parse", reinterpret_cast<PyCFunction>(HttpMediaTypeWithQualityHeaderValue_TryParse), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_HttpMediaTypeWithQualityHeaderValue_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_HttpMediaTypeWithQualityHeaderValue_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_HttpMediaTypeWithQualityHeaderValue_Static) },
        { }
    };

    static PyType_Spec type_spec_HttpMediaTypeWithQualityHeaderValue_Static =
    {
        "winrt._winrt_windows_web_http_headers.HttpMediaTypeWithQualityHeaderValue_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_HttpMediaTypeWithQualityHeaderValue_Static
    };

    // ----- HttpMediaTypeWithQualityHeaderValueCollection class --------------------

    static PyObject* _new_HttpMediaTypeWithQualityHeaderValueCollection(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Web::Http::Headers::HttpMediaTypeWithQualityHeaderValueCollection>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Web::Http::Headers::HttpMediaTypeWithQualityHeaderValueCollection>::type_name);
        return nullptr;
    }

    static void _dealloc_HttpMediaTypeWithQualityHeaderValueCollection(py::wrapper::Windows::Web::Http::Headers::HttpMediaTypeWithQualityHeaderValueCollection* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* HttpMediaTypeWithQualityHeaderValueCollection_Append(py::wrapper::Windows::Web::Http::Headers::HttpMediaTypeWithQualityHeaderValueCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpMediaTypeWithQualityHeaderValueCollection", L"Append", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Web::Http::Headers::HttpMediaTypeWithQualityHeaderValue>(args, 0);

                self->obj.Append(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpMediaTypeWithQualityHeaderValueCollection_Clear(py::wrapper::Windows::Web::Http::Headers::HttpMediaTypeWithQualityHeaderValueCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpMediaTypeWithQualityHeaderValueCollection", L"Clear", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Clear();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpMediaTypeWithQualityHeaderValueCollection_First(py::wrapper::Windows::Web::Http::Headers::HttpMediaTypeWithQualityHeaderValueCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpMediaTypeWithQualityHeaderValueCollection", L"First", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.First());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpMediaTypeWithQualityHeaderValueCollection_GetAt(py::wrapper::Windows::Web::Http::Headers::HttpMediaTypeWithQualityHeaderValueCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpMediaTypeWithQualityHeaderValueCollection", L"GetAt", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint32_t>(args, 0);

                return py::convert(self->obj.GetAt(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpMediaTypeWithQualityHeaderValueCollection_GetMany(py::wrapper::Windows::Web::Http::Headers::HttpMediaTypeWithQualityHeaderValueCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpMediaTypeWithQualityHeaderValueCollection", L"GetMany", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<winrt::Windows::Web::Http::Headers::HttpMediaTypeWithQualityHeaderValue, true>>(args, 1);

                return py::convert(self->obj.GetMany(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpMediaTypeWithQualityHeaderValueCollection_GetView(py::wrapper::Windows::Web::Http::Headers::HttpMediaTypeWithQualityHeaderValueCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpMediaTypeWithQualityHeaderValueCollection", L"GetView", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetView());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpMediaTypeWithQualityHeaderValueCollection_IndexOf(py::wrapper::Windows::Web::Http::Headers::HttpMediaTypeWithQualityHeaderValueCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpMediaTypeWithQualityHeaderValueCollection", L"IndexOf", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Web::Http::Headers::HttpMediaTypeWithQualityHeaderValue>(args, 0);
                uint32_t param1 {  };

                auto return_value = self->obj.IndexOf(param0, param1);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out1.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpMediaTypeWithQualityHeaderValueCollection_InsertAt(py::wrapper::Windows::Web::Http::Headers::HttpMediaTypeWithQualityHeaderValueCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpMediaTypeWithQualityHeaderValueCollection", L"InsertAt", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Web::Http::Headers::HttpMediaTypeWithQualityHeaderValue>(args, 1);

                self->obj.InsertAt(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpMediaTypeWithQualityHeaderValueCollection_ParseAdd(py::wrapper::Windows::Web::Http::Headers::HttpMediaTypeWithQualityHeaderValueCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpMediaTypeWithQualityHeaderValueCollection", L"ParseAdd", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                self->obj.ParseAdd(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpMediaTypeWithQualityHeaderValueCollection_RemoveAt(py::wrapper::Windows::Web::Http::Headers::HttpMediaTypeWithQualityHeaderValueCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpMediaTypeWithQualityHeaderValueCollection", L"RemoveAt", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint32_t>(args, 0);

                self->obj.RemoveAt(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpMediaTypeWithQualityHeaderValueCollection_RemoveAtEnd(py::wrapper::Windows::Web::Http::Headers::HttpMediaTypeWithQualityHeaderValueCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpMediaTypeWithQualityHeaderValueCollection", L"RemoveAtEnd", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.RemoveAtEnd();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpMediaTypeWithQualityHeaderValueCollection_ReplaceAll(py::wrapper::Windows::Web::Http::Headers::HttpMediaTypeWithQualityHeaderValueCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpMediaTypeWithQualityHeaderValueCollection", L"ReplaceAll", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<py::pybuf_view<winrt::Windows::Web::Http::Headers::HttpMediaTypeWithQualityHeaderValue, false>>(args, 0);

                self->obj.ReplaceAll(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpMediaTypeWithQualityHeaderValueCollection_SetAt(py::wrapper::Windows::Web::Http::Headers::HttpMediaTypeWithQualityHeaderValueCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpMediaTypeWithQualityHeaderValueCollection", L"SetAt", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Web::Http::Headers::HttpMediaTypeWithQualityHeaderValue>(args, 1);

                self->obj.SetAt(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpMediaTypeWithQualityHeaderValueCollection_ToString(py::wrapper::Windows::Web::Http::Headers::HttpMediaTypeWithQualityHeaderValueCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpMediaTypeWithQualityHeaderValueCollection", L"ToString", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.ToString());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpMediaTypeWithQualityHeaderValueCollection_TryParseAdd(py::wrapper::Windows::Web::Http::Headers::HttpMediaTypeWithQualityHeaderValueCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpMediaTypeWithQualityHeaderValueCollection", L"TryParseAdd", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.TryParseAdd(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpMediaTypeWithQualityHeaderValueCollection_get_Size(py::wrapper::Windows::Web::Http::Headers::HttpMediaTypeWithQualityHeaderValueCollection* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.Headers.HttpMediaTypeWithQualityHeaderValueCollection", L"Size"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_HttpMediaTypeWithQualityHeaderValueCollection(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Web::Http::Headers::HttpMediaTypeWithQualityHeaderValueCollection>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_HttpMediaTypeWithQualityHeaderValueCollection(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Web::Http::Headers::HttpMediaTypeWithQualityHeaderValueCollection>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _str_HttpMediaTypeWithQualityHeaderValueCollection(py::wrapper::Windows::Web::Http::Headers::HttpMediaTypeWithQualityHeaderValueCollection* self) noexcept
    {
        try
        {
            return py::convert(self->obj.ToString());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _iterator_HttpMediaTypeWithQualityHeaderValueCollection(py::wrapper::Windows::Web::Http::Headers::HttpMediaTypeWithQualityHeaderValueCollection* self) noexcept
    {
        try
        {
            return py::convert(self->obj.First());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static Py_ssize_t _seq_length_HttpMediaTypeWithQualityHeaderValueCollection(py::wrapper::Windows::Web::Http::Headers::HttpMediaTypeWithQualityHeaderValueCollection* self) noexcept
    {
        try
        {
            return static_cast<Py_ssize_t>(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _seq_item_HttpMediaTypeWithQualityHeaderValueCollection(py::wrapper::Windows::Web::Http::Headers::HttpMediaTypeWithQualityHeaderValueCollection* self, Py_ssize_t i) noexcept
    {
        try
        {
            return py::convert(self->obj.GetAt(static_cast<uint32_t>(i)));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _seq_subscript_HttpMediaTypeWithQualityHeaderValueCollection(py::wrapper::Windows::Web::Http::Headers::HttpMediaTypeWithQualityHeaderValueCollection* self, PyObject* slice) noexcept
    {
        try
        {
            if (PyIndex_Check(slice))
            {
                pyobj_handle index{PyNumber_Index(slice)};

                if (!index)
                {
                    return nullptr;
                }

                auto i = PyNumber_AsSsize_t(index.get(), PyExc_IndexError);

                if (i == -1 && PyErr_Occurred())
                {
                    return nullptr;
                }

                return _seq_item_HttpMediaTypeWithQualityHeaderValueCollection(self, i);
            }

            if (!PySlice_Check(slice))
            {
                PyErr_Format(
                    PyExc_TypeError,
                    "indicies must be integers, not '%s'",
                    Py_TYPE(slice)->tp_name);
            }

            Py_ssize_t start, stop, step, length;

            if (PySlice_GetIndicesEx(
                    slice, self->obj.Size(), &start, &stop, &step, &length)
                < 0)
            {
                return nullptr;
            }

            if (step != 1)
            {
                PyErr_SetString(PyExc_NotImplementedError, "slices with step other than 1 are not implemented");
                return nullptr;
            }

            winrt::com_array<winrt::Windows::Web::Http::Headers::HttpMediaTypeWithQualityHeaderValue> items(static_cast<uint32_t>(length), empty_instance<winrt::Windows::Web::Http::Headers::HttpMediaTypeWithQualityHeaderValue>::get());

            auto count = self->obj.GetMany(static_cast<uint32_t>(start), items);

            if (count != static_cast<uint32_t>(length))
            {
                PyErr_Format(PyExc_RuntimeError, "returned count %d did not match requested length %zd", count, length);
                return nullptr;
            }

            return convert(items);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int _seq_assign_HttpMediaTypeWithQualityHeaderValueCollection(py::wrapper::Windows::Web::Http::Headers::HttpMediaTypeWithQualityHeaderValueCollection* self, Py_ssize_t i, PyObject* value) noexcept
    {
        try
        {
            if (!value)
            {
                self->obj.RemoveAt(static_cast<uint32_t>(i));
            }
            else
            {
                self->obj.SetAt(static_cast<uint32_t>(i), py::convert_to<winrt::Windows::Web::Http::Headers::HttpMediaTypeWithQualityHeaderValue>(value));
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyMethodDef _methods_HttpMediaTypeWithQualityHeaderValueCollection[] = {
        { "append", reinterpret_cast<PyCFunction>(HttpMediaTypeWithQualityHeaderValueCollection_Append), METH_VARARGS, nullptr },
        { "clear", reinterpret_cast<PyCFunction>(HttpMediaTypeWithQualityHeaderValueCollection_Clear), METH_VARARGS, nullptr },
        { "first", reinterpret_cast<PyCFunction>(HttpMediaTypeWithQualityHeaderValueCollection_First), METH_VARARGS, nullptr },
        { "get_at", reinterpret_cast<PyCFunction>(HttpMediaTypeWithQualityHeaderValueCollection_GetAt), METH_VARARGS, nullptr },
        { "get_many", reinterpret_cast<PyCFunction>(HttpMediaTypeWithQualityHeaderValueCollection_GetMany), METH_VARARGS, nullptr },
        { "get_view", reinterpret_cast<PyCFunction>(HttpMediaTypeWithQualityHeaderValueCollection_GetView), METH_VARARGS, nullptr },
        { "index_of", reinterpret_cast<PyCFunction>(HttpMediaTypeWithQualityHeaderValueCollection_IndexOf), METH_VARARGS, nullptr },
        { "insert_at", reinterpret_cast<PyCFunction>(HttpMediaTypeWithQualityHeaderValueCollection_InsertAt), METH_VARARGS, nullptr },
        { "parse_add", reinterpret_cast<PyCFunction>(HttpMediaTypeWithQualityHeaderValueCollection_ParseAdd), METH_VARARGS, nullptr },
        { "remove_at", reinterpret_cast<PyCFunction>(HttpMediaTypeWithQualityHeaderValueCollection_RemoveAt), METH_VARARGS, nullptr },
        { "remove_at_end", reinterpret_cast<PyCFunction>(HttpMediaTypeWithQualityHeaderValueCollection_RemoveAtEnd), METH_VARARGS, nullptr },
        { "replace_all", reinterpret_cast<PyCFunction>(HttpMediaTypeWithQualityHeaderValueCollection_ReplaceAll), METH_VARARGS, nullptr },
        { "set_at", reinterpret_cast<PyCFunction>(HttpMediaTypeWithQualityHeaderValueCollection_SetAt), METH_VARARGS, nullptr },
        { "to_string", reinterpret_cast<PyCFunction>(HttpMediaTypeWithQualityHeaderValueCollection_ToString), METH_VARARGS, nullptr },
        { "try_parse_add", reinterpret_cast<PyCFunction>(HttpMediaTypeWithQualityHeaderValueCollection_TryParseAdd), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_HttpMediaTypeWithQualityHeaderValueCollection, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_HttpMediaTypeWithQualityHeaderValueCollection), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_HttpMediaTypeWithQualityHeaderValueCollection[] = {
        { "size", reinterpret_cast<getter>(HttpMediaTypeWithQualityHeaderValueCollection_get_Size), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_HttpMediaTypeWithQualityHeaderValueCollection[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_HttpMediaTypeWithQualityHeaderValueCollection) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_HttpMediaTypeWithQualityHeaderValueCollection) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_HttpMediaTypeWithQualityHeaderValueCollection) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_HttpMediaTypeWithQualityHeaderValueCollection) },
        { Py_tp_str, reinterpret_cast<void*>(_str_HttpMediaTypeWithQualityHeaderValueCollection) },
        { Py_tp_iter, reinterpret_cast<void*>(_iterator_HttpMediaTypeWithQualityHeaderValueCollection) },
        { Py_sq_length, reinterpret_cast<void*>(_seq_length_HttpMediaTypeWithQualityHeaderValueCollection) },
        { Py_sq_item, reinterpret_cast<void*>(_seq_item_HttpMediaTypeWithQualityHeaderValueCollection) },
        { Py_mp_subscript, reinterpret_cast<void*>(_seq_subscript_HttpMediaTypeWithQualityHeaderValueCollection) },
        { Py_sq_ass_item, reinterpret_cast<void*>(_seq_assign_HttpMediaTypeWithQualityHeaderValueCollection) },
        { },
    };

    static PyType_Spec type_spec_HttpMediaTypeWithQualityHeaderValueCollection =
    {
        "winrt._winrt_windows_web_http_headers.HttpMediaTypeWithQualityHeaderValueCollection",
        sizeof(py::wrapper::Windows::Web::Http::Headers::HttpMediaTypeWithQualityHeaderValueCollection),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_HttpMediaTypeWithQualityHeaderValueCollection
    };

    // ----- HttpMethodHeaderValueCollection class --------------------

    static PyObject* _new_HttpMethodHeaderValueCollection(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Web::Http::Headers::HttpMethodHeaderValueCollection>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Web::Http::Headers::HttpMethodHeaderValueCollection>::type_name);
        return nullptr;
    }

    static void _dealloc_HttpMethodHeaderValueCollection(py::wrapper::Windows::Web::Http::Headers::HttpMethodHeaderValueCollection* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* HttpMethodHeaderValueCollection_Append(py::wrapper::Windows::Web::Http::Headers::HttpMethodHeaderValueCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpMethodHeaderValueCollection", L"Append", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Web::Http::HttpMethod>(args, 0);

                self->obj.Append(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpMethodHeaderValueCollection_Clear(py::wrapper::Windows::Web::Http::Headers::HttpMethodHeaderValueCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpMethodHeaderValueCollection", L"Clear", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Clear();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpMethodHeaderValueCollection_First(py::wrapper::Windows::Web::Http::Headers::HttpMethodHeaderValueCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpMethodHeaderValueCollection", L"First", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.First());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpMethodHeaderValueCollection_GetAt(py::wrapper::Windows::Web::Http::Headers::HttpMethodHeaderValueCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpMethodHeaderValueCollection", L"GetAt", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint32_t>(args, 0);

                return py::convert(self->obj.GetAt(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpMethodHeaderValueCollection_GetMany(py::wrapper::Windows::Web::Http::Headers::HttpMethodHeaderValueCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpMethodHeaderValueCollection", L"GetMany", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<winrt::Windows::Web::Http::HttpMethod, true>>(args, 1);

                return py::convert(self->obj.GetMany(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpMethodHeaderValueCollection_GetView(py::wrapper::Windows::Web::Http::Headers::HttpMethodHeaderValueCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpMethodHeaderValueCollection", L"GetView", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetView());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpMethodHeaderValueCollection_IndexOf(py::wrapper::Windows::Web::Http::Headers::HttpMethodHeaderValueCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpMethodHeaderValueCollection", L"IndexOf", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Web::Http::HttpMethod>(args, 0);
                uint32_t param1 {  };

                auto return_value = self->obj.IndexOf(param0, param1);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out1.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpMethodHeaderValueCollection_InsertAt(py::wrapper::Windows::Web::Http::Headers::HttpMethodHeaderValueCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpMethodHeaderValueCollection", L"InsertAt", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Web::Http::HttpMethod>(args, 1);

                self->obj.InsertAt(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpMethodHeaderValueCollection_ParseAdd(py::wrapper::Windows::Web::Http::Headers::HttpMethodHeaderValueCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpMethodHeaderValueCollection", L"ParseAdd", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                self->obj.ParseAdd(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpMethodHeaderValueCollection_RemoveAt(py::wrapper::Windows::Web::Http::Headers::HttpMethodHeaderValueCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpMethodHeaderValueCollection", L"RemoveAt", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint32_t>(args, 0);

                self->obj.RemoveAt(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpMethodHeaderValueCollection_RemoveAtEnd(py::wrapper::Windows::Web::Http::Headers::HttpMethodHeaderValueCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpMethodHeaderValueCollection", L"RemoveAtEnd", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.RemoveAtEnd();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpMethodHeaderValueCollection_ReplaceAll(py::wrapper::Windows::Web::Http::Headers::HttpMethodHeaderValueCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpMethodHeaderValueCollection", L"ReplaceAll", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<py::pybuf_view<winrt::Windows::Web::Http::HttpMethod, false>>(args, 0);

                self->obj.ReplaceAll(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpMethodHeaderValueCollection_SetAt(py::wrapper::Windows::Web::Http::Headers::HttpMethodHeaderValueCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpMethodHeaderValueCollection", L"SetAt", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Web::Http::HttpMethod>(args, 1);

                self->obj.SetAt(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpMethodHeaderValueCollection_ToString(py::wrapper::Windows::Web::Http::Headers::HttpMethodHeaderValueCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpMethodHeaderValueCollection", L"ToString", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.ToString());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpMethodHeaderValueCollection_TryParseAdd(py::wrapper::Windows::Web::Http::Headers::HttpMethodHeaderValueCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpMethodHeaderValueCollection", L"TryParseAdd", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.TryParseAdd(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpMethodHeaderValueCollection_get_Size(py::wrapper::Windows::Web::Http::Headers::HttpMethodHeaderValueCollection* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.Headers.HttpMethodHeaderValueCollection", L"Size"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_HttpMethodHeaderValueCollection(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Web::Http::Headers::HttpMethodHeaderValueCollection>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_HttpMethodHeaderValueCollection(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Web::Http::Headers::HttpMethodHeaderValueCollection>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _str_HttpMethodHeaderValueCollection(py::wrapper::Windows::Web::Http::Headers::HttpMethodHeaderValueCollection* self) noexcept
    {
        try
        {
            return py::convert(self->obj.ToString());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _iterator_HttpMethodHeaderValueCollection(py::wrapper::Windows::Web::Http::Headers::HttpMethodHeaderValueCollection* self) noexcept
    {
        try
        {
            return py::convert(self->obj.First());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static Py_ssize_t _seq_length_HttpMethodHeaderValueCollection(py::wrapper::Windows::Web::Http::Headers::HttpMethodHeaderValueCollection* self) noexcept
    {
        try
        {
            return static_cast<Py_ssize_t>(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _seq_item_HttpMethodHeaderValueCollection(py::wrapper::Windows::Web::Http::Headers::HttpMethodHeaderValueCollection* self, Py_ssize_t i) noexcept
    {
        try
        {
            return py::convert(self->obj.GetAt(static_cast<uint32_t>(i)));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _seq_subscript_HttpMethodHeaderValueCollection(py::wrapper::Windows::Web::Http::Headers::HttpMethodHeaderValueCollection* self, PyObject* slice) noexcept
    {
        try
        {
            if (PyIndex_Check(slice))
            {
                pyobj_handle index{PyNumber_Index(slice)};

                if (!index)
                {
                    return nullptr;
                }

                auto i = PyNumber_AsSsize_t(index.get(), PyExc_IndexError);

                if (i == -1 && PyErr_Occurred())
                {
                    return nullptr;
                }

                return _seq_item_HttpMethodHeaderValueCollection(self, i);
            }

            if (!PySlice_Check(slice))
            {
                PyErr_Format(
                    PyExc_TypeError,
                    "indicies must be integers, not '%s'",
                    Py_TYPE(slice)->tp_name);
            }

            Py_ssize_t start, stop, step, length;

            if (PySlice_GetIndicesEx(
                    slice, self->obj.Size(), &start, &stop, &step, &length)
                < 0)
            {
                return nullptr;
            }

            if (step != 1)
            {
                PyErr_SetString(PyExc_NotImplementedError, "slices with step other than 1 are not implemented");
                return nullptr;
            }

            winrt::com_array<winrt::Windows::Web::Http::HttpMethod> items(static_cast<uint32_t>(length), empty_instance<winrt::Windows::Web::Http::HttpMethod>::get());

            auto count = self->obj.GetMany(static_cast<uint32_t>(start), items);

            if (count != static_cast<uint32_t>(length))
            {
                PyErr_Format(PyExc_RuntimeError, "returned count %d did not match requested length %zd", count, length);
                return nullptr;
            }

            return convert(items);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int _seq_assign_HttpMethodHeaderValueCollection(py::wrapper::Windows::Web::Http::Headers::HttpMethodHeaderValueCollection* self, Py_ssize_t i, PyObject* value) noexcept
    {
        try
        {
            if (!value)
            {
                self->obj.RemoveAt(static_cast<uint32_t>(i));
            }
            else
            {
                self->obj.SetAt(static_cast<uint32_t>(i), py::convert_to<winrt::Windows::Web::Http::HttpMethod>(value));
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyMethodDef _methods_HttpMethodHeaderValueCollection[] = {
        { "append", reinterpret_cast<PyCFunction>(HttpMethodHeaderValueCollection_Append), METH_VARARGS, nullptr },
        { "clear", reinterpret_cast<PyCFunction>(HttpMethodHeaderValueCollection_Clear), METH_VARARGS, nullptr },
        { "first", reinterpret_cast<PyCFunction>(HttpMethodHeaderValueCollection_First), METH_VARARGS, nullptr },
        { "get_at", reinterpret_cast<PyCFunction>(HttpMethodHeaderValueCollection_GetAt), METH_VARARGS, nullptr },
        { "get_many", reinterpret_cast<PyCFunction>(HttpMethodHeaderValueCollection_GetMany), METH_VARARGS, nullptr },
        { "get_view", reinterpret_cast<PyCFunction>(HttpMethodHeaderValueCollection_GetView), METH_VARARGS, nullptr },
        { "index_of", reinterpret_cast<PyCFunction>(HttpMethodHeaderValueCollection_IndexOf), METH_VARARGS, nullptr },
        { "insert_at", reinterpret_cast<PyCFunction>(HttpMethodHeaderValueCollection_InsertAt), METH_VARARGS, nullptr },
        { "parse_add", reinterpret_cast<PyCFunction>(HttpMethodHeaderValueCollection_ParseAdd), METH_VARARGS, nullptr },
        { "remove_at", reinterpret_cast<PyCFunction>(HttpMethodHeaderValueCollection_RemoveAt), METH_VARARGS, nullptr },
        { "remove_at_end", reinterpret_cast<PyCFunction>(HttpMethodHeaderValueCollection_RemoveAtEnd), METH_VARARGS, nullptr },
        { "replace_all", reinterpret_cast<PyCFunction>(HttpMethodHeaderValueCollection_ReplaceAll), METH_VARARGS, nullptr },
        { "set_at", reinterpret_cast<PyCFunction>(HttpMethodHeaderValueCollection_SetAt), METH_VARARGS, nullptr },
        { "to_string", reinterpret_cast<PyCFunction>(HttpMethodHeaderValueCollection_ToString), METH_VARARGS, nullptr },
        { "try_parse_add", reinterpret_cast<PyCFunction>(HttpMethodHeaderValueCollection_TryParseAdd), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_HttpMethodHeaderValueCollection, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_HttpMethodHeaderValueCollection), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_HttpMethodHeaderValueCollection[] = {
        { "size", reinterpret_cast<getter>(HttpMethodHeaderValueCollection_get_Size), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_HttpMethodHeaderValueCollection[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_HttpMethodHeaderValueCollection) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_HttpMethodHeaderValueCollection) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_HttpMethodHeaderValueCollection) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_HttpMethodHeaderValueCollection) },
        { Py_tp_str, reinterpret_cast<void*>(_str_HttpMethodHeaderValueCollection) },
        { Py_tp_iter, reinterpret_cast<void*>(_iterator_HttpMethodHeaderValueCollection) },
        { Py_sq_length, reinterpret_cast<void*>(_seq_length_HttpMethodHeaderValueCollection) },
        { Py_sq_item, reinterpret_cast<void*>(_seq_item_HttpMethodHeaderValueCollection) },
        { Py_mp_subscript, reinterpret_cast<void*>(_seq_subscript_HttpMethodHeaderValueCollection) },
        { Py_sq_ass_item, reinterpret_cast<void*>(_seq_assign_HttpMethodHeaderValueCollection) },
        { },
    };

    static PyType_Spec type_spec_HttpMethodHeaderValueCollection =
    {
        "winrt._winrt_windows_web_http_headers.HttpMethodHeaderValueCollection",
        sizeof(py::wrapper::Windows::Web::Http::Headers::HttpMethodHeaderValueCollection),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_HttpMethodHeaderValueCollection
    };

    // ----- HttpNameValueHeaderValue class --------------------

    static PyObject* _new_HttpNameValueHeaderValue(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                winrt::Windows::Web::Http::Headers::HttpNameValueHeaderValue instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                winrt::Windows::Web::Http::Headers::HttpNameValueHeaderValue instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_HttpNameValueHeaderValue(py::wrapper::Windows::Web::Http::Headers::HttpNameValueHeaderValue* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* HttpNameValueHeaderValue_Parse(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpNameValueHeaderValue", L"Parse", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Web::Http::Headers::HttpNameValueHeaderValue::Parse(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpNameValueHeaderValue_ToString(py::wrapper::Windows::Web::Http::Headers::HttpNameValueHeaderValue* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpNameValueHeaderValue", L"ToString", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.ToString());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpNameValueHeaderValue_TryParse(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpNameValueHeaderValue", L"TryParse", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                winrt::Windows::Web::Http::Headers::HttpNameValueHeaderValue param1 { nullptr };

                auto return_value = winrt::Windows::Web::Http::Headers::HttpNameValueHeaderValue::TryParse(param0, param1);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out1.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpNameValueHeaderValue_get_Value(py::wrapper::Windows::Web::Http::Headers::HttpNameValueHeaderValue* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.Headers.HttpNameValueHeaderValue", L"Value"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Value());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int HttpNameValueHeaderValue_put_Value(py::wrapper::Windows::Web::Http::Headers::HttpNameValueHeaderValue* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.Headers.HttpNameValueHeaderValue", L"Value"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Value(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* HttpNameValueHeaderValue_get_Name(py::wrapper::Windows::Web::Http::Headers::HttpNameValueHeaderValue* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.Headers.HttpNameValueHeaderValue", L"Name"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Name());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_HttpNameValueHeaderValue(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Web::Http::Headers::HttpNameValueHeaderValue>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_HttpNameValueHeaderValue(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Web::Http::Headers::HttpNameValueHeaderValue>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _str_HttpNameValueHeaderValue(py::wrapper::Windows::Web::Http::Headers::HttpNameValueHeaderValue* self) noexcept
    {
        try
        {
            return py::convert(self->obj.ToString());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_HttpNameValueHeaderValue[] = {
        { "to_string", reinterpret_cast<PyCFunction>(HttpNameValueHeaderValue_ToString), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_HttpNameValueHeaderValue, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_HttpNameValueHeaderValue), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_HttpNameValueHeaderValue[] = {
        { "value", reinterpret_cast<getter>(HttpNameValueHeaderValue_get_Value), reinterpret_cast<setter>(HttpNameValueHeaderValue_put_Value), nullptr, nullptr },
        { "name", reinterpret_cast<getter>(HttpNameValueHeaderValue_get_Name), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_HttpNameValueHeaderValue[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_HttpNameValueHeaderValue) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_HttpNameValueHeaderValue) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_HttpNameValueHeaderValue) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_HttpNameValueHeaderValue) },
        { Py_tp_str, reinterpret_cast<void*>(_str_HttpNameValueHeaderValue) },
        { },
    };

    static PyType_Spec type_spec_HttpNameValueHeaderValue =
    {
        "winrt._winrt_windows_web_http_headers.HttpNameValueHeaderValue",
        sizeof(py::wrapper::Windows::Web::Http::Headers::HttpNameValueHeaderValue),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_HttpNameValueHeaderValue
    };

    static PyGetSetDef getset_HttpNameValueHeaderValue_Static[] = {
        { }
    };

    static PyMethodDef methods_HttpNameValueHeaderValue_Static[] = {
        { "parse", reinterpret_cast<PyCFunction>(HttpNameValueHeaderValue_Parse), METH_VARARGS, nullptr },
        { "try_parse", reinterpret_cast<PyCFunction>(HttpNameValueHeaderValue_TryParse), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_HttpNameValueHeaderValue_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_HttpNameValueHeaderValue_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_HttpNameValueHeaderValue_Static) },
        { }
    };

    static PyType_Spec type_spec_HttpNameValueHeaderValue_Static =
    {
        "winrt._winrt_windows_web_http_headers.HttpNameValueHeaderValue_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_HttpNameValueHeaderValue_Static
    };

    // ----- HttpProductHeaderValue class --------------------

    static PyObject* _new_HttpProductHeaderValue(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                winrt::Windows::Web::Http::Headers::HttpProductHeaderValue instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                winrt::Windows::Web::Http::Headers::HttpProductHeaderValue instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_HttpProductHeaderValue(py::wrapper::Windows::Web::Http::Headers::HttpProductHeaderValue* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* HttpProductHeaderValue_Parse(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpProductHeaderValue", L"Parse", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Web::Http::Headers::HttpProductHeaderValue::Parse(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpProductHeaderValue_ToString(py::wrapper::Windows::Web::Http::Headers::HttpProductHeaderValue* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpProductHeaderValue", L"ToString", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.ToString());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpProductHeaderValue_TryParse(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpProductHeaderValue", L"TryParse", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                winrt::Windows::Web::Http::Headers::HttpProductHeaderValue param1 { nullptr };

                auto return_value = winrt::Windows::Web::Http::Headers::HttpProductHeaderValue::TryParse(param0, param1);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out1.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpProductHeaderValue_get_Name(py::wrapper::Windows::Web::Http::Headers::HttpProductHeaderValue* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.Headers.HttpProductHeaderValue", L"Name"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Name());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HttpProductHeaderValue_get_Version(py::wrapper::Windows::Web::Http::Headers::HttpProductHeaderValue* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.Headers.HttpProductHeaderValue", L"Version"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Version());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_HttpProductHeaderValue(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Web::Http::Headers::HttpProductHeaderValue>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_HttpProductHeaderValue(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Web::Http::Headers::HttpProductHeaderValue>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _str_HttpProductHeaderValue(py::wrapper::Windows::Web::Http::Headers::HttpProductHeaderValue* self) noexcept
    {
        try
        {
            return py::convert(self->obj.ToString());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_HttpProductHeaderValue[] = {
        { "to_string", reinterpret_cast<PyCFunction>(HttpProductHeaderValue_ToString), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_HttpProductHeaderValue, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_HttpProductHeaderValue), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_HttpProductHeaderValue[] = {
        { "name", reinterpret_cast<getter>(HttpProductHeaderValue_get_Name), nullptr, nullptr, nullptr },
        { "version", reinterpret_cast<getter>(HttpProductHeaderValue_get_Version), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_HttpProductHeaderValue[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_HttpProductHeaderValue) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_HttpProductHeaderValue) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_HttpProductHeaderValue) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_HttpProductHeaderValue) },
        { Py_tp_str, reinterpret_cast<void*>(_str_HttpProductHeaderValue) },
        { },
    };

    static PyType_Spec type_spec_HttpProductHeaderValue =
    {
        "winrt._winrt_windows_web_http_headers.HttpProductHeaderValue",
        sizeof(py::wrapper::Windows::Web::Http::Headers::HttpProductHeaderValue),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_HttpProductHeaderValue
    };

    static PyGetSetDef getset_HttpProductHeaderValue_Static[] = {
        { }
    };

    static PyMethodDef methods_HttpProductHeaderValue_Static[] = {
        { "parse", reinterpret_cast<PyCFunction>(HttpProductHeaderValue_Parse), METH_VARARGS, nullptr },
        { "try_parse", reinterpret_cast<PyCFunction>(HttpProductHeaderValue_TryParse), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_HttpProductHeaderValue_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_HttpProductHeaderValue_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_HttpProductHeaderValue_Static) },
        { }
    };

    static PyType_Spec type_spec_HttpProductHeaderValue_Static =
    {
        "winrt._winrt_windows_web_http_headers.HttpProductHeaderValue_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_HttpProductHeaderValue_Static
    };

    // ----- HttpProductInfoHeaderValue class --------------------

    static PyObject* _new_HttpProductInfoHeaderValue(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                winrt::Windows::Web::Http::Headers::HttpProductInfoHeaderValue instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                winrt::Windows::Web::Http::Headers::HttpProductInfoHeaderValue instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_HttpProductInfoHeaderValue(py::wrapper::Windows::Web::Http::Headers::HttpProductInfoHeaderValue* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* HttpProductInfoHeaderValue_Parse(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpProductInfoHeaderValue", L"Parse", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Web::Http::Headers::HttpProductInfoHeaderValue::Parse(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpProductInfoHeaderValue_ToString(py::wrapper::Windows::Web::Http::Headers::HttpProductInfoHeaderValue* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpProductInfoHeaderValue", L"ToString", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.ToString());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpProductInfoHeaderValue_TryParse(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpProductInfoHeaderValue", L"TryParse", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                winrt::Windows::Web::Http::Headers::HttpProductInfoHeaderValue param1 { nullptr };

                auto return_value = winrt::Windows::Web::Http::Headers::HttpProductInfoHeaderValue::TryParse(param0, param1);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out1.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpProductInfoHeaderValue_get_Comment(py::wrapper::Windows::Web::Http::Headers::HttpProductInfoHeaderValue* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.Headers.HttpProductInfoHeaderValue", L"Comment"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Comment());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HttpProductInfoHeaderValue_get_Product(py::wrapper::Windows::Web::Http::Headers::HttpProductInfoHeaderValue* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.Headers.HttpProductInfoHeaderValue", L"Product"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Product());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_HttpProductInfoHeaderValue(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Web::Http::Headers::HttpProductInfoHeaderValue>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_HttpProductInfoHeaderValue(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Web::Http::Headers::HttpProductInfoHeaderValue>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _str_HttpProductInfoHeaderValue(py::wrapper::Windows::Web::Http::Headers::HttpProductInfoHeaderValue* self) noexcept
    {
        try
        {
            return py::convert(self->obj.ToString());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_HttpProductInfoHeaderValue[] = {
        { "to_string", reinterpret_cast<PyCFunction>(HttpProductInfoHeaderValue_ToString), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_HttpProductInfoHeaderValue, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_HttpProductInfoHeaderValue), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_HttpProductInfoHeaderValue[] = {
        { "comment", reinterpret_cast<getter>(HttpProductInfoHeaderValue_get_Comment), nullptr, nullptr, nullptr },
        { "product", reinterpret_cast<getter>(HttpProductInfoHeaderValue_get_Product), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_HttpProductInfoHeaderValue[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_HttpProductInfoHeaderValue) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_HttpProductInfoHeaderValue) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_HttpProductInfoHeaderValue) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_HttpProductInfoHeaderValue) },
        { Py_tp_str, reinterpret_cast<void*>(_str_HttpProductInfoHeaderValue) },
        { },
    };

    static PyType_Spec type_spec_HttpProductInfoHeaderValue =
    {
        "winrt._winrt_windows_web_http_headers.HttpProductInfoHeaderValue",
        sizeof(py::wrapper::Windows::Web::Http::Headers::HttpProductInfoHeaderValue),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_HttpProductInfoHeaderValue
    };

    static PyGetSetDef getset_HttpProductInfoHeaderValue_Static[] = {
        { }
    };

    static PyMethodDef methods_HttpProductInfoHeaderValue_Static[] = {
        { "parse", reinterpret_cast<PyCFunction>(HttpProductInfoHeaderValue_Parse), METH_VARARGS, nullptr },
        { "try_parse", reinterpret_cast<PyCFunction>(HttpProductInfoHeaderValue_TryParse), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_HttpProductInfoHeaderValue_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_HttpProductInfoHeaderValue_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_HttpProductInfoHeaderValue_Static) },
        { }
    };

    static PyType_Spec type_spec_HttpProductInfoHeaderValue_Static =
    {
        "winrt._winrt_windows_web_http_headers.HttpProductInfoHeaderValue_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_HttpProductInfoHeaderValue_Static
    };

    // ----- HttpProductInfoHeaderValueCollection class --------------------

    static PyObject* _new_HttpProductInfoHeaderValueCollection(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Web::Http::Headers::HttpProductInfoHeaderValueCollection>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Web::Http::Headers::HttpProductInfoHeaderValueCollection>::type_name);
        return nullptr;
    }

    static void _dealloc_HttpProductInfoHeaderValueCollection(py::wrapper::Windows::Web::Http::Headers::HttpProductInfoHeaderValueCollection* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* HttpProductInfoHeaderValueCollection_Append(py::wrapper::Windows::Web::Http::Headers::HttpProductInfoHeaderValueCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpProductInfoHeaderValueCollection", L"Append", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Web::Http::Headers::HttpProductInfoHeaderValue>(args, 0);

                self->obj.Append(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpProductInfoHeaderValueCollection_Clear(py::wrapper::Windows::Web::Http::Headers::HttpProductInfoHeaderValueCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpProductInfoHeaderValueCollection", L"Clear", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Clear();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpProductInfoHeaderValueCollection_First(py::wrapper::Windows::Web::Http::Headers::HttpProductInfoHeaderValueCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpProductInfoHeaderValueCollection", L"First", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.First());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpProductInfoHeaderValueCollection_GetAt(py::wrapper::Windows::Web::Http::Headers::HttpProductInfoHeaderValueCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpProductInfoHeaderValueCollection", L"GetAt", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint32_t>(args, 0);

                return py::convert(self->obj.GetAt(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpProductInfoHeaderValueCollection_GetMany(py::wrapper::Windows::Web::Http::Headers::HttpProductInfoHeaderValueCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpProductInfoHeaderValueCollection", L"GetMany", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<winrt::Windows::Web::Http::Headers::HttpProductInfoHeaderValue, true>>(args, 1);

                return py::convert(self->obj.GetMany(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpProductInfoHeaderValueCollection_GetView(py::wrapper::Windows::Web::Http::Headers::HttpProductInfoHeaderValueCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpProductInfoHeaderValueCollection", L"GetView", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetView());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpProductInfoHeaderValueCollection_IndexOf(py::wrapper::Windows::Web::Http::Headers::HttpProductInfoHeaderValueCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpProductInfoHeaderValueCollection", L"IndexOf", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Web::Http::Headers::HttpProductInfoHeaderValue>(args, 0);
                uint32_t param1 {  };

                auto return_value = self->obj.IndexOf(param0, param1);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out1.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpProductInfoHeaderValueCollection_InsertAt(py::wrapper::Windows::Web::Http::Headers::HttpProductInfoHeaderValueCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpProductInfoHeaderValueCollection", L"InsertAt", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Web::Http::Headers::HttpProductInfoHeaderValue>(args, 1);

                self->obj.InsertAt(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpProductInfoHeaderValueCollection_ParseAdd(py::wrapper::Windows::Web::Http::Headers::HttpProductInfoHeaderValueCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpProductInfoHeaderValueCollection", L"ParseAdd", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                self->obj.ParseAdd(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpProductInfoHeaderValueCollection_RemoveAt(py::wrapper::Windows::Web::Http::Headers::HttpProductInfoHeaderValueCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpProductInfoHeaderValueCollection", L"RemoveAt", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint32_t>(args, 0);

                self->obj.RemoveAt(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpProductInfoHeaderValueCollection_RemoveAtEnd(py::wrapper::Windows::Web::Http::Headers::HttpProductInfoHeaderValueCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpProductInfoHeaderValueCollection", L"RemoveAtEnd", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.RemoveAtEnd();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpProductInfoHeaderValueCollection_ReplaceAll(py::wrapper::Windows::Web::Http::Headers::HttpProductInfoHeaderValueCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpProductInfoHeaderValueCollection", L"ReplaceAll", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<py::pybuf_view<winrt::Windows::Web::Http::Headers::HttpProductInfoHeaderValue, false>>(args, 0);

                self->obj.ReplaceAll(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpProductInfoHeaderValueCollection_SetAt(py::wrapper::Windows::Web::Http::Headers::HttpProductInfoHeaderValueCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpProductInfoHeaderValueCollection", L"SetAt", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Web::Http::Headers::HttpProductInfoHeaderValue>(args, 1);

                self->obj.SetAt(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpProductInfoHeaderValueCollection_ToString(py::wrapper::Windows::Web::Http::Headers::HttpProductInfoHeaderValueCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpProductInfoHeaderValueCollection", L"ToString", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.ToString());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpProductInfoHeaderValueCollection_TryParseAdd(py::wrapper::Windows::Web::Http::Headers::HttpProductInfoHeaderValueCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpProductInfoHeaderValueCollection", L"TryParseAdd", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.TryParseAdd(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpProductInfoHeaderValueCollection_get_Size(py::wrapper::Windows::Web::Http::Headers::HttpProductInfoHeaderValueCollection* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.Headers.HttpProductInfoHeaderValueCollection", L"Size"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_HttpProductInfoHeaderValueCollection(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Web::Http::Headers::HttpProductInfoHeaderValueCollection>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_HttpProductInfoHeaderValueCollection(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Web::Http::Headers::HttpProductInfoHeaderValueCollection>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _str_HttpProductInfoHeaderValueCollection(py::wrapper::Windows::Web::Http::Headers::HttpProductInfoHeaderValueCollection* self) noexcept
    {
        try
        {
            return py::convert(self->obj.ToString());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _iterator_HttpProductInfoHeaderValueCollection(py::wrapper::Windows::Web::Http::Headers::HttpProductInfoHeaderValueCollection* self) noexcept
    {
        try
        {
            return py::convert(self->obj.First());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static Py_ssize_t _seq_length_HttpProductInfoHeaderValueCollection(py::wrapper::Windows::Web::Http::Headers::HttpProductInfoHeaderValueCollection* self) noexcept
    {
        try
        {
            return static_cast<Py_ssize_t>(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _seq_item_HttpProductInfoHeaderValueCollection(py::wrapper::Windows::Web::Http::Headers::HttpProductInfoHeaderValueCollection* self, Py_ssize_t i) noexcept
    {
        try
        {
            return py::convert(self->obj.GetAt(static_cast<uint32_t>(i)));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _seq_subscript_HttpProductInfoHeaderValueCollection(py::wrapper::Windows::Web::Http::Headers::HttpProductInfoHeaderValueCollection* self, PyObject* slice) noexcept
    {
        try
        {
            if (PyIndex_Check(slice))
            {
                pyobj_handle index{PyNumber_Index(slice)};

                if (!index)
                {
                    return nullptr;
                }

                auto i = PyNumber_AsSsize_t(index.get(), PyExc_IndexError);

                if (i == -1 && PyErr_Occurred())
                {
                    return nullptr;
                }

                return _seq_item_HttpProductInfoHeaderValueCollection(self, i);
            }

            if (!PySlice_Check(slice))
            {
                PyErr_Format(
                    PyExc_TypeError,
                    "indicies must be integers, not '%s'",
                    Py_TYPE(slice)->tp_name);
            }

            Py_ssize_t start, stop, step, length;

            if (PySlice_GetIndicesEx(
                    slice, self->obj.Size(), &start, &stop, &step, &length)
                < 0)
            {
                return nullptr;
            }

            if (step != 1)
            {
                PyErr_SetString(PyExc_NotImplementedError, "slices with step other than 1 are not implemented");
                return nullptr;
            }

            winrt::com_array<winrt::Windows::Web::Http::Headers::HttpProductInfoHeaderValue> items(static_cast<uint32_t>(length), empty_instance<winrt::Windows::Web::Http::Headers::HttpProductInfoHeaderValue>::get());

            auto count = self->obj.GetMany(static_cast<uint32_t>(start), items);

            if (count != static_cast<uint32_t>(length))
            {
                PyErr_Format(PyExc_RuntimeError, "returned count %d did not match requested length %zd", count, length);
                return nullptr;
            }

            return convert(items);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int _seq_assign_HttpProductInfoHeaderValueCollection(py::wrapper::Windows::Web::Http::Headers::HttpProductInfoHeaderValueCollection* self, Py_ssize_t i, PyObject* value) noexcept
    {
        try
        {
            if (!value)
            {
                self->obj.RemoveAt(static_cast<uint32_t>(i));
            }
            else
            {
                self->obj.SetAt(static_cast<uint32_t>(i), py::convert_to<winrt::Windows::Web::Http::Headers::HttpProductInfoHeaderValue>(value));
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyMethodDef _methods_HttpProductInfoHeaderValueCollection[] = {
        { "append", reinterpret_cast<PyCFunction>(HttpProductInfoHeaderValueCollection_Append), METH_VARARGS, nullptr },
        { "clear", reinterpret_cast<PyCFunction>(HttpProductInfoHeaderValueCollection_Clear), METH_VARARGS, nullptr },
        { "first", reinterpret_cast<PyCFunction>(HttpProductInfoHeaderValueCollection_First), METH_VARARGS, nullptr },
        { "get_at", reinterpret_cast<PyCFunction>(HttpProductInfoHeaderValueCollection_GetAt), METH_VARARGS, nullptr },
        { "get_many", reinterpret_cast<PyCFunction>(HttpProductInfoHeaderValueCollection_GetMany), METH_VARARGS, nullptr },
        { "get_view", reinterpret_cast<PyCFunction>(HttpProductInfoHeaderValueCollection_GetView), METH_VARARGS, nullptr },
        { "index_of", reinterpret_cast<PyCFunction>(HttpProductInfoHeaderValueCollection_IndexOf), METH_VARARGS, nullptr },
        { "insert_at", reinterpret_cast<PyCFunction>(HttpProductInfoHeaderValueCollection_InsertAt), METH_VARARGS, nullptr },
        { "parse_add", reinterpret_cast<PyCFunction>(HttpProductInfoHeaderValueCollection_ParseAdd), METH_VARARGS, nullptr },
        { "remove_at", reinterpret_cast<PyCFunction>(HttpProductInfoHeaderValueCollection_RemoveAt), METH_VARARGS, nullptr },
        { "remove_at_end", reinterpret_cast<PyCFunction>(HttpProductInfoHeaderValueCollection_RemoveAtEnd), METH_VARARGS, nullptr },
        { "replace_all", reinterpret_cast<PyCFunction>(HttpProductInfoHeaderValueCollection_ReplaceAll), METH_VARARGS, nullptr },
        { "set_at", reinterpret_cast<PyCFunction>(HttpProductInfoHeaderValueCollection_SetAt), METH_VARARGS, nullptr },
        { "to_string", reinterpret_cast<PyCFunction>(HttpProductInfoHeaderValueCollection_ToString), METH_VARARGS, nullptr },
        { "try_parse_add", reinterpret_cast<PyCFunction>(HttpProductInfoHeaderValueCollection_TryParseAdd), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_HttpProductInfoHeaderValueCollection, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_HttpProductInfoHeaderValueCollection), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_HttpProductInfoHeaderValueCollection[] = {
        { "size", reinterpret_cast<getter>(HttpProductInfoHeaderValueCollection_get_Size), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_HttpProductInfoHeaderValueCollection[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_HttpProductInfoHeaderValueCollection) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_HttpProductInfoHeaderValueCollection) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_HttpProductInfoHeaderValueCollection) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_HttpProductInfoHeaderValueCollection) },
        { Py_tp_str, reinterpret_cast<void*>(_str_HttpProductInfoHeaderValueCollection) },
        { Py_tp_iter, reinterpret_cast<void*>(_iterator_HttpProductInfoHeaderValueCollection) },
        { Py_sq_length, reinterpret_cast<void*>(_seq_length_HttpProductInfoHeaderValueCollection) },
        { Py_sq_item, reinterpret_cast<void*>(_seq_item_HttpProductInfoHeaderValueCollection) },
        { Py_mp_subscript, reinterpret_cast<void*>(_seq_subscript_HttpProductInfoHeaderValueCollection) },
        { Py_sq_ass_item, reinterpret_cast<void*>(_seq_assign_HttpProductInfoHeaderValueCollection) },
        { },
    };

    static PyType_Spec type_spec_HttpProductInfoHeaderValueCollection =
    {
        "winrt._winrt_windows_web_http_headers.HttpProductInfoHeaderValueCollection",
        sizeof(py::wrapper::Windows::Web::Http::Headers::HttpProductInfoHeaderValueCollection),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_HttpProductInfoHeaderValueCollection
    };

    // ----- HttpRequestHeaderCollection class --------------------

    static PyObject* _new_HttpRequestHeaderCollection(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Web::Http::Headers::HttpRequestHeaderCollection>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Web::Http::Headers::HttpRequestHeaderCollection>::type_name);
        return nullptr;
    }

    static void _dealloc_HttpRequestHeaderCollection(py::wrapper::Windows::Web::Http::Headers::HttpRequestHeaderCollection* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* HttpRequestHeaderCollection_Append(py::wrapper::Windows::Web::Http::Headers::HttpRequestHeaderCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpRequestHeaderCollection", L"Append", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                self->obj.Append(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpRequestHeaderCollection_Clear(py::wrapper::Windows::Web::Http::Headers::HttpRequestHeaderCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpRequestHeaderCollection", L"Clear", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Clear();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpRequestHeaderCollection_First(py::wrapper::Windows::Web::Http::Headers::HttpRequestHeaderCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpRequestHeaderCollection", L"First", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.First());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpRequestHeaderCollection_GetView(py::wrapper::Windows::Web::Http::Headers::HttpRequestHeaderCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpRequestHeaderCollection", L"GetView", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetView());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpRequestHeaderCollection_HasKey(py::wrapper::Windows::Web::Http::Headers::HttpRequestHeaderCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpRequestHeaderCollection", L"HasKey", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.HasKey(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpRequestHeaderCollection_Insert(py::wrapper::Windows::Web::Http::Headers::HttpRequestHeaderCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpRequestHeaderCollection", L"Insert", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(self->obj.Insert(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpRequestHeaderCollection_Lookup(py::wrapper::Windows::Web::Http::Headers::HttpRequestHeaderCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpRequestHeaderCollection", L"Lookup", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.Lookup(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpRequestHeaderCollection_Remove(py::wrapper::Windows::Web::Http::Headers::HttpRequestHeaderCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpRequestHeaderCollection", L"Remove", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                self->obj.Remove(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpRequestHeaderCollection_ToString(py::wrapper::Windows::Web::Http::Headers::HttpRequestHeaderCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpRequestHeaderCollection", L"ToString", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.ToString());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpRequestHeaderCollection_TryAppendWithoutValidation(py::wrapper::Windows::Web::Http::Headers::HttpRequestHeaderCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpRequestHeaderCollection", L"TryAppendWithoutValidation", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(self->obj.TryAppendWithoutValidation(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpRequestHeaderCollection_get_Size(py::wrapper::Windows::Web::Http::Headers::HttpRequestHeaderCollection* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.Headers.HttpRequestHeaderCollection", L"Size"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HttpRequestHeaderCollection_get_Referer(py::wrapper::Windows::Web::Http::Headers::HttpRequestHeaderCollection* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.Headers.HttpRequestHeaderCollection", L"Referer"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Referer());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int HttpRequestHeaderCollection_put_Referer(py::wrapper::Windows::Web::Http::Headers::HttpRequestHeaderCollection* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.Headers.HttpRequestHeaderCollection", L"Referer"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(arg);

            self->obj.Referer(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* HttpRequestHeaderCollection_get_ProxyAuthorization(py::wrapper::Windows::Web::Http::Headers::HttpRequestHeaderCollection* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.Headers.HttpRequestHeaderCollection", L"ProxyAuthorization"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ProxyAuthorization());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int HttpRequestHeaderCollection_put_ProxyAuthorization(py::wrapper::Windows::Web::Http::Headers::HttpRequestHeaderCollection* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.Headers.HttpRequestHeaderCollection", L"ProxyAuthorization"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Web::Http::Headers::HttpCredentialsHeaderValue>(arg);

            self->obj.ProxyAuthorization(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* HttpRequestHeaderCollection_get_MaxForwards(py::wrapper::Windows::Web::Http::Headers::HttpRequestHeaderCollection* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.Headers.HttpRequestHeaderCollection", L"MaxForwards"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.MaxForwards());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int HttpRequestHeaderCollection_put_MaxForwards(py::wrapper::Windows::Web::Http::Headers::HttpRequestHeaderCollection* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.Headers.HttpRequestHeaderCollection", L"MaxForwards"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<uint32_t>>(arg);

            self->obj.MaxForwards(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* HttpRequestHeaderCollection_get_IfUnmodifiedSince(py::wrapper::Windows::Web::Http::Headers::HttpRequestHeaderCollection* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.Headers.HttpRequestHeaderCollection", L"IfUnmodifiedSince"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IfUnmodifiedSince());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int HttpRequestHeaderCollection_put_IfUnmodifiedSince(py::wrapper::Windows::Web::Http::Headers::HttpRequestHeaderCollection* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.Headers.HttpRequestHeaderCollection", L"IfUnmodifiedSince"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::DateTime>>(arg);

            self->obj.IfUnmodifiedSince(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* HttpRequestHeaderCollection_get_IfModifiedSince(py::wrapper::Windows::Web::Http::Headers::HttpRequestHeaderCollection* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.Headers.HttpRequestHeaderCollection", L"IfModifiedSince"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IfModifiedSince());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int HttpRequestHeaderCollection_put_IfModifiedSince(py::wrapper::Windows::Web::Http::Headers::HttpRequestHeaderCollection* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.Headers.HttpRequestHeaderCollection", L"IfModifiedSince"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::DateTime>>(arg);

            self->obj.IfModifiedSince(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* HttpRequestHeaderCollection_get_Host(py::wrapper::Windows::Web::Http::Headers::HttpRequestHeaderCollection* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.Headers.HttpRequestHeaderCollection", L"Host"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Host());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int HttpRequestHeaderCollection_put_Host(py::wrapper::Windows::Web::Http::Headers::HttpRequestHeaderCollection* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.Headers.HttpRequestHeaderCollection", L"Host"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Networking::HostName>(arg);

            self->obj.Host(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* HttpRequestHeaderCollection_get_From(py::wrapper::Windows::Web::Http::Headers::HttpRequestHeaderCollection* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.Headers.HttpRequestHeaderCollection", L"From"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.From());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int HttpRequestHeaderCollection_put_From(py::wrapper::Windows::Web::Http::Headers::HttpRequestHeaderCollection* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.Headers.HttpRequestHeaderCollection", L"From"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.From(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* HttpRequestHeaderCollection_get_Date(py::wrapper::Windows::Web::Http::Headers::HttpRequestHeaderCollection* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.Headers.HttpRequestHeaderCollection", L"Date"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Date());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int HttpRequestHeaderCollection_put_Date(py::wrapper::Windows::Web::Http::Headers::HttpRequestHeaderCollection* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.Headers.HttpRequestHeaderCollection", L"Date"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::DateTime>>(arg);

            self->obj.Date(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* HttpRequestHeaderCollection_get_Authorization(py::wrapper::Windows::Web::Http::Headers::HttpRequestHeaderCollection* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.Headers.HttpRequestHeaderCollection", L"Authorization"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Authorization());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int HttpRequestHeaderCollection_put_Authorization(py::wrapper::Windows::Web::Http::Headers::HttpRequestHeaderCollection* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.Headers.HttpRequestHeaderCollection", L"Authorization"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Web::Http::Headers::HttpCredentialsHeaderValue>(arg);

            self->obj.Authorization(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* HttpRequestHeaderCollection_get_Accept(py::wrapper::Windows::Web::Http::Headers::HttpRequestHeaderCollection* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.Headers.HttpRequestHeaderCollection", L"Accept"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Accept());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HttpRequestHeaderCollection_get_AcceptEncoding(py::wrapper::Windows::Web::Http::Headers::HttpRequestHeaderCollection* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.Headers.HttpRequestHeaderCollection", L"AcceptEncoding"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.AcceptEncoding());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HttpRequestHeaderCollection_get_AcceptLanguage(py::wrapper::Windows::Web::Http::Headers::HttpRequestHeaderCollection* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.Headers.HttpRequestHeaderCollection", L"AcceptLanguage"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.AcceptLanguage());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HttpRequestHeaderCollection_get_CacheControl(py::wrapper::Windows::Web::Http::Headers::HttpRequestHeaderCollection* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.Headers.HttpRequestHeaderCollection", L"CacheControl"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CacheControl());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HttpRequestHeaderCollection_get_Connection(py::wrapper::Windows::Web::Http::Headers::HttpRequestHeaderCollection* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.Headers.HttpRequestHeaderCollection", L"Connection"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Connection());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HttpRequestHeaderCollection_get_Cookie(py::wrapper::Windows::Web::Http::Headers::HttpRequestHeaderCollection* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.Headers.HttpRequestHeaderCollection", L"Cookie"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Cookie());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HttpRequestHeaderCollection_get_Expect(py::wrapper::Windows::Web::Http::Headers::HttpRequestHeaderCollection* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.Headers.HttpRequestHeaderCollection", L"Expect"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Expect());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HttpRequestHeaderCollection_get_TransferEncoding(py::wrapper::Windows::Web::Http::Headers::HttpRequestHeaderCollection* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.Headers.HttpRequestHeaderCollection", L"TransferEncoding"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.TransferEncoding());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HttpRequestHeaderCollection_get_UserAgent(py::wrapper::Windows::Web::Http::Headers::HttpRequestHeaderCollection* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.Headers.HttpRequestHeaderCollection", L"UserAgent"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.UserAgent());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_HttpRequestHeaderCollection(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Web::Http::Headers::HttpRequestHeaderCollection>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_HttpRequestHeaderCollection(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Web::Http::Headers::HttpRequestHeaderCollection>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _str_HttpRequestHeaderCollection(py::wrapper::Windows::Web::Http::Headers::HttpRequestHeaderCollection* self) noexcept
    {
        try
        {
            return py::convert(self->obj.ToString());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _iterator_HttpRequestHeaderCollection(py::wrapper::Windows::Web::Http::Headers::HttpRequestHeaderCollection* self) noexcept
    {
        try
        {
            py::pyobj_handle iter{py::convert(self->obj.First())};

            if (!iter)
            {
                return nullptr;
            }

            return py::wrap_mapping_iter(iter.get());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int _map_contains_HttpRequestHeaderCollection(py::wrapper::Windows::Web::Http::Headers::HttpRequestHeaderCollection* self, PyObject* key) noexcept
    {
        try
        {
            return static_cast<int>(self->obj.HasKey(py::convert_to<winrt::hstring>(key)));
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static Py_ssize_t _map_length_HttpRequestHeaderCollection(py::wrapper::Windows::Web::Http::Headers::HttpRequestHeaderCollection* self) noexcept
    {
        try
        {
            return static_cast<Py_ssize_t>(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _map_subscript_HttpRequestHeaderCollection(py::wrapper::Windows::Web::Http::Headers::HttpRequestHeaderCollection* self, PyObject* key) noexcept
    {
        try
        {
            auto _key = py::convert_to<winrt::hstring>(key);
            auto value = self->obj.TryLookup(_key);

            if (!value) {
                if constexpr (std::is_base_of_v<winrt::Windows::Foundation::IUnknown, decltype(value)>)
                {
                    if (self->obj.HasKey(_key))
                    {
                        Py_RETURN_NONE;
                    }
                }

                PyErr_SetObject(PyExc_KeyError, key);
                return nullptr;
            }

            return py::convert(value);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int _map_assign_HttpRequestHeaderCollection(py::wrapper::Windows::Web::Http::Headers::HttpRequestHeaderCollection* self, PyObject* key, PyObject* value) noexcept
    {
        try
        {
            auto _key = py::convert_to<winrt::hstring>(key);

            if (value == nullptr) {
                if (!self->obj.TryRemove(_key)) {
                    PyErr_SetObject(PyExc_KeyError, key);
                    return -1;
                }

                return 0;
            }

            self->obj.Insert(_key, py::convert_to<winrt::hstring>(value));

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyMethodDef _methods_HttpRequestHeaderCollection[] = {
        { "append", reinterpret_cast<PyCFunction>(HttpRequestHeaderCollection_Append), METH_VARARGS, nullptr },
        { "clear", reinterpret_cast<PyCFunction>(HttpRequestHeaderCollection_Clear), METH_VARARGS, nullptr },
        { "first", reinterpret_cast<PyCFunction>(HttpRequestHeaderCollection_First), METH_VARARGS, nullptr },
        { "get_view", reinterpret_cast<PyCFunction>(HttpRequestHeaderCollection_GetView), METH_VARARGS, nullptr },
        { "has_key", reinterpret_cast<PyCFunction>(HttpRequestHeaderCollection_HasKey), METH_VARARGS, nullptr },
        { "insert", reinterpret_cast<PyCFunction>(HttpRequestHeaderCollection_Insert), METH_VARARGS, nullptr },
        { "lookup", reinterpret_cast<PyCFunction>(HttpRequestHeaderCollection_Lookup), METH_VARARGS, nullptr },
        { "remove", reinterpret_cast<PyCFunction>(HttpRequestHeaderCollection_Remove), METH_VARARGS, nullptr },
        { "to_string", reinterpret_cast<PyCFunction>(HttpRequestHeaderCollection_ToString), METH_VARARGS, nullptr },
        { "try_append_without_validation", reinterpret_cast<PyCFunction>(HttpRequestHeaderCollection_TryAppendWithoutValidation), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_HttpRequestHeaderCollection, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_HttpRequestHeaderCollection), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_HttpRequestHeaderCollection[] = {
        { "size", reinterpret_cast<getter>(HttpRequestHeaderCollection_get_Size), nullptr, nullptr, nullptr },
        { "referer", reinterpret_cast<getter>(HttpRequestHeaderCollection_get_Referer), reinterpret_cast<setter>(HttpRequestHeaderCollection_put_Referer), nullptr, nullptr },
        { "proxy_authorization", reinterpret_cast<getter>(HttpRequestHeaderCollection_get_ProxyAuthorization), reinterpret_cast<setter>(HttpRequestHeaderCollection_put_ProxyAuthorization), nullptr, nullptr },
        { "max_forwards", reinterpret_cast<getter>(HttpRequestHeaderCollection_get_MaxForwards), reinterpret_cast<setter>(HttpRequestHeaderCollection_put_MaxForwards), nullptr, nullptr },
        { "if_unmodified_since", reinterpret_cast<getter>(HttpRequestHeaderCollection_get_IfUnmodifiedSince), reinterpret_cast<setter>(HttpRequestHeaderCollection_put_IfUnmodifiedSince), nullptr, nullptr },
        { "if_modified_since", reinterpret_cast<getter>(HttpRequestHeaderCollection_get_IfModifiedSince), reinterpret_cast<setter>(HttpRequestHeaderCollection_put_IfModifiedSince), nullptr, nullptr },
        { "host", reinterpret_cast<getter>(HttpRequestHeaderCollection_get_Host), reinterpret_cast<setter>(HttpRequestHeaderCollection_put_Host), nullptr, nullptr },
        { "from_", reinterpret_cast<getter>(HttpRequestHeaderCollection_get_From), reinterpret_cast<setter>(HttpRequestHeaderCollection_put_From), nullptr, nullptr },
        { "date", reinterpret_cast<getter>(HttpRequestHeaderCollection_get_Date), reinterpret_cast<setter>(HttpRequestHeaderCollection_put_Date), nullptr, nullptr },
        { "authorization", reinterpret_cast<getter>(HttpRequestHeaderCollection_get_Authorization), reinterpret_cast<setter>(HttpRequestHeaderCollection_put_Authorization), nullptr, nullptr },
        { "accept", reinterpret_cast<getter>(HttpRequestHeaderCollection_get_Accept), nullptr, nullptr, nullptr },
        { "accept_encoding", reinterpret_cast<getter>(HttpRequestHeaderCollection_get_AcceptEncoding), nullptr, nullptr, nullptr },
        { "accept_language", reinterpret_cast<getter>(HttpRequestHeaderCollection_get_AcceptLanguage), nullptr, nullptr, nullptr },
        { "cache_control", reinterpret_cast<getter>(HttpRequestHeaderCollection_get_CacheControl), nullptr, nullptr, nullptr },
        { "connection", reinterpret_cast<getter>(HttpRequestHeaderCollection_get_Connection), nullptr, nullptr, nullptr },
        { "cookie", reinterpret_cast<getter>(HttpRequestHeaderCollection_get_Cookie), nullptr, nullptr, nullptr },
        { "expect", reinterpret_cast<getter>(HttpRequestHeaderCollection_get_Expect), nullptr, nullptr, nullptr },
        { "transfer_encoding", reinterpret_cast<getter>(HttpRequestHeaderCollection_get_TransferEncoding), nullptr, nullptr, nullptr },
        { "user_agent", reinterpret_cast<getter>(HttpRequestHeaderCollection_get_UserAgent), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_HttpRequestHeaderCollection[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_HttpRequestHeaderCollection) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_HttpRequestHeaderCollection) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_HttpRequestHeaderCollection) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_HttpRequestHeaderCollection) },
        { Py_tp_str, reinterpret_cast<void*>(_str_HttpRequestHeaderCollection) },
        { Py_tp_iter, reinterpret_cast<void*>(_iterator_HttpRequestHeaderCollection) },
        { Py_sq_contains, reinterpret_cast<void*>(_map_contains_HttpRequestHeaderCollection) },
        { Py_mp_length, reinterpret_cast<void*>(_map_length_HttpRequestHeaderCollection) },
        { Py_mp_subscript, reinterpret_cast<void*>(_map_subscript_HttpRequestHeaderCollection) },
        { Py_mp_ass_subscript, reinterpret_cast<void*>(_map_assign_HttpRequestHeaderCollection) },
        { },
    };

    static PyType_Spec type_spec_HttpRequestHeaderCollection =
    {
        "winrt._winrt_windows_web_http_headers.HttpRequestHeaderCollection",
        sizeof(py::wrapper::Windows::Web::Http::Headers::HttpRequestHeaderCollection),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_HttpRequestHeaderCollection
    };

    // ----- HttpResponseHeaderCollection class --------------------

    static PyObject* _new_HttpResponseHeaderCollection(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Web::Http::Headers::HttpResponseHeaderCollection>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Web::Http::Headers::HttpResponseHeaderCollection>::type_name);
        return nullptr;
    }

    static void _dealloc_HttpResponseHeaderCollection(py::wrapper::Windows::Web::Http::Headers::HttpResponseHeaderCollection* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* HttpResponseHeaderCollection_Append(py::wrapper::Windows::Web::Http::Headers::HttpResponseHeaderCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpResponseHeaderCollection", L"Append", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                self->obj.Append(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpResponseHeaderCollection_Clear(py::wrapper::Windows::Web::Http::Headers::HttpResponseHeaderCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpResponseHeaderCollection", L"Clear", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Clear();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpResponseHeaderCollection_First(py::wrapper::Windows::Web::Http::Headers::HttpResponseHeaderCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpResponseHeaderCollection", L"First", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.First());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpResponseHeaderCollection_GetView(py::wrapper::Windows::Web::Http::Headers::HttpResponseHeaderCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpResponseHeaderCollection", L"GetView", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetView());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpResponseHeaderCollection_HasKey(py::wrapper::Windows::Web::Http::Headers::HttpResponseHeaderCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpResponseHeaderCollection", L"HasKey", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.HasKey(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpResponseHeaderCollection_Insert(py::wrapper::Windows::Web::Http::Headers::HttpResponseHeaderCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpResponseHeaderCollection", L"Insert", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(self->obj.Insert(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpResponseHeaderCollection_Lookup(py::wrapper::Windows::Web::Http::Headers::HttpResponseHeaderCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpResponseHeaderCollection", L"Lookup", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.Lookup(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpResponseHeaderCollection_Remove(py::wrapper::Windows::Web::Http::Headers::HttpResponseHeaderCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpResponseHeaderCollection", L"Remove", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                self->obj.Remove(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpResponseHeaderCollection_ToString(py::wrapper::Windows::Web::Http::Headers::HttpResponseHeaderCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpResponseHeaderCollection", L"ToString", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.ToString());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpResponseHeaderCollection_TryAppendWithoutValidation(py::wrapper::Windows::Web::Http::Headers::HttpResponseHeaderCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpResponseHeaderCollection", L"TryAppendWithoutValidation", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(self->obj.TryAppendWithoutValidation(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpResponseHeaderCollection_get_Size(py::wrapper::Windows::Web::Http::Headers::HttpResponseHeaderCollection* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.Headers.HttpResponseHeaderCollection", L"Size"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HttpResponseHeaderCollection_get_RetryAfter(py::wrapper::Windows::Web::Http::Headers::HttpResponseHeaderCollection* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.Headers.HttpResponseHeaderCollection", L"RetryAfter"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.RetryAfter());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int HttpResponseHeaderCollection_put_RetryAfter(py::wrapper::Windows::Web::Http::Headers::HttpResponseHeaderCollection* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.Headers.HttpResponseHeaderCollection", L"RetryAfter"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Web::Http::Headers::HttpDateOrDeltaHeaderValue>(arg);

            self->obj.RetryAfter(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* HttpResponseHeaderCollection_get_Location(py::wrapper::Windows::Web::Http::Headers::HttpResponseHeaderCollection* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.Headers.HttpResponseHeaderCollection", L"Location"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Location());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int HttpResponseHeaderCollection_put_Location(py::wrapper::Windows::Web::Http::Headers::HttpResponseHeaderCollection* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.Headers.HttpResponseHeaderCollection", L"Location"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(arg);

            self->obj.Location(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* HttpResponseHeaderCollection_get_Date(py::wrapper::Windows::Web::Http::Headers::HttpResponseHeaderCollection* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.Headers.HttpResponseHeaderCollection", L"Date"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Date());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int HttpResponseHeaderCollection_put_Date(py::wrapper::Windows::Web::Http::Headers::HttpResponseHeaderCollection* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.Headers.HttpResponseHeaderCollection", L"Date"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::DateTime>>(arg);

            self->obj.Date(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* HttpResponseHeaderCollection_get_Age(py::wrapper::Windows::Web::Http::Headers::HttpResponseHeaderCollection* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.Headers.HttpResponseHeaderCollection", L"Age"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Age());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int HttpResponseHeaderCollection_put_Age(py::wrapper::Windows::Web::Http::Headers::HttpResponseHeaderCollection* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.Headers.HttpResponseHeaderCollection", L"Age"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::TimeSpan>>(arg);

            self->obj.Age(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* HttpResponseHeaderCollection_get_Allow(py::wrapper::Windows::Web::Http::Headers::HttpResponseHeaderCollection* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.Headers.HttpResponseHeaderCollection", L"Allow"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Allow());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HttpResponseHeaderCollection_get_CacheControl(py::wrapper::Windows::Web::Http::Headers::HttpResponseHeaderCollection* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.Headers.HttpResponseHeaderCollection", L"CacheControl"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CacheControl());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HttpResponseHeaderCollection_get_Connection(py::wrapper::Windows::Web::Http::Headers::HttpResponseHeaderCollection* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.Headers.HttpResponseHeaderCollection", L"Connection"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Connection());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HttpResponseHeaderCollection_get_ProxyAuthenticate(py::wrapper::Windows::Web::Http::Headers::HttpResponseHeaderCollection* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.Headers.HttpResponseHeaderCollection", L"ProxyAuthenticate"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ProxyAuthenticate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HttpResponseHeaderCollection_get_TransferEncoding(py::wrapper::Windows::Web::Http::Headers::HttpResponseHeaderCollection* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.Headers.HttpResponseHeaderCollection", L"TransferEncoding"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.TransferEncoding());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HttpResponseHeaderCollection_get_WwwAuthenticate(py::wrapper::Windows::Web::Http::Headers::HttpResponseHeaderCollection* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.Headers.HttpResponseHeaderCollection", L"WwwAuthenticate"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.WwwAuthenticate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_HttpResponseHeaderCollection(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Web::Http::Headers::HttpResponseHeaderCollection>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_HttpResponseHeaderCollection(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Web::Http::Headers::HttpResponseHeaderCollection>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _str_HttpResponseHeaderCollection(py::wrapper::Windows::Web::Http::Headers::HttpResponseHeaderCollection* self) noexcept
    {
        try
        {
            return py::convert(self->obj.ToString());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _iterator_HttpResponseHeaderCollection(py::wrapper::Windows::Web::Http::Headers::HttpResponseHeaderCollection* self) noexcept
    {
        try
        {
            py::pyobj_handle iter{py::convert(self->obj.First())};

            if (!iter)
            {
                return nullptr;
            }

            return py::wrap_mapping_iter(iter.get());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int _map_contains_HttpResponseHeaderCollection(py::wrapper::Windows::Web::Http::Headers::HttpResponseHeaderCollection* self, PyObject* key) noexcept
    {
        try
        {
            return static_cast<int>(self->obj.HasKey(py::convert_to<winrt::hstring>(key)));
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static Py_ssize_t _map_length_HttpResponseHeaderCollection(py::wrapper::Windows::Web::Http::Headers::HttpResponseHeaderCollection* self) noexcept
    {
        try
        {
            return static_cast<Py_ssize_t>(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _map_subscript_HttpResponseHeaderCollection(py::wrapper::Windows::Web::Http::Headers::HttpResponseHeaderCollection* self, PyObject* key) noexcept
    {
        try
        {
            auto _key = py::convert_to<winrt::hstring>(key);
            auto value = self->obj.TryLookup(_key);

            if (!value) {
                if constexpr (std::is_base_of_v<winrt::Windows::Foundation::IUnknown, decltype(value)>)
                {
                    if (self->obj.HasKey(_key))
                    {
                        Py_RETURN_NONE;
                    }
                }

                PyErr_SetObject(PyExc_KeyError, key);
                return nullptr;
            }

            return py::convert(value);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int _map_assign_HttpResponseHeaderCollection(py::wrapper::Windows::Web::Http::Headers::HttpResponseHeaderCollection* self, PyObject* key, PyObject* value) noexcept
    {
        try
        {
            auto _key = py::convert_to<winrt::hstring>(key);

            if (value == nullptr) {
                if (!self->obj.TryRemove(_key)) {
                    PyErr_SetObject(PyExc_KeyError, key);
                    return -1;
                }

                return 0;
            }

            self->obj.Insert(_key, py::convert_to<winrt::hstring>(value));

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyMethodDef _methods_HttpResponseHeaderCollection[] = {
        { "append", reinterpret_cast<PyCFunction>(HttpResponseHeaderCollection_Append), METH_VARARGS, nullptr },
        { "clear", reinterpret_cast<PyCFunction>(HttpResponseHeaderCollection_Clear), METH_VARARGS, nullptr },
        { "first", reinterpret_cast<PyCFunction>(HttpResponseHeaderCollection_First), METH_VARARGS, nullptr },
        { "get_view", reinterpret_cast<PyCFunction>(HttpResponseHeaderCollection_GetView), METH_VARARGS, nullptr },
        { "has_key", reinterpret_cast<PyCFunction>(HttpResponseHeaderCollection_HasKey), METH_VARARGS, nullptr },
        { "insert", reinterpret_cast<PyCFunction>(HttpResponseHeaderCollection_Insert), METH_VARARGS, nullptr },
        { "lookup", reinterpret_cast<PyCFunction>(HttpResponseHeaderCollection_Lookup), METH_VARARGS, nullptr },
        { "remove", reinterpret_cast<PyCFunction>(HttpResponseHeaderCollection_Remove), METH_VARARGS, nullptr },
        { "to_string", reinterpret_cast<PyCFunction>(HttpResponseHeaderCollection_ToString), METH_VARARGS, nullptr },
        { "try_append_without_validation", reinterpret_cast<PyCFunction>(HttpResponseHeaderCollection_TryAppendWithoutValidation), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_HttpResponseHeaderCollection, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_HttpResponseHeaderCollection), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_HttpResponseHeaderCollection[] = {
        { "size", reinterpret_cast<getter>(HttpResponseHeaderCollection_get_Size), nullptr, nullptr, nullptr },
        { "retry_after", reinterpret_cast<getter>(HttpResponseHeaderCollection_get_RetryAfter), reinterpret_cast<setter>(HttpResponseHeaderCollection_put_RetryAfter), nullptr, nullptr },
        { "location", reinterpret_cast<getter>(HttpResponseHeaderCollection_get_Location), reinterpret_cast<setter>(HttpResponseHeaderCollection_put_Location), nullptr, nullptr },
        { "date", reinterpret_cast<getter>(HttpResponseHeaderCollection_get_Date), reinterpret_cast<setter>(HttpResponseHeaderCollection_put_Date), nullptr, nullptr },
        { "age", reinterpret_cast<getter>(HttpResponseHeaderCollection_get_Age), reinterpret_cast<setter>(HttpResponseHeaderCollection_put_Age), nullptr, nullptr },
        { "allow", reinterpret_cast<getter>(HttpResponseHeaderCollection_get_Allow), nullptr, nullptr, nullptr },
        { "cache_control", reinterpret_cast<getter>(HttpResponseHeaderCollection_get_CacheControl), nullptr, nullptr, nullptr },
        { "connection", reinterpret_cast<getter>(HttpResponseHeaderCollection_get_Connection), nullptr, nullptr, nullptr },
        { "proxy_authenticate", reinterpret_cast<getter>(HttpResponseHeaderCollection_get_ProxyAuthenticate), nullptr, nullptr, nullptr },
        { "transfer_encoding", reinterpret_cast<getter>(HttpResponseHeaderCollection_get_TransferEncoding), nullptr, nullptr, nullptr },
        { "www_authenticate", reinterpret_cast<getter>(HttpResponseHeaderCollection_get_WwwAuthenticate), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_HttpResponseHeaderCollection[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_HttpResponseHeaderCollection) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_HttpResponseHeaderCollection) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_HttpResponseHeaderCollection) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_HttpResponseHeaderCollection) },
        { Py_tp_str, reinterpret_cast<void*>(_str_HttpResponseHeaderCollection) },
        { Py_tp_iter, reinterpret_cast<void*>(_iterator_HttpResponseHeaderCollection) },
        { Py_sq_contains, reinterpret_cast<void*>(_map_contains_HttpResponseHeaderCollection) },
        { Py_mp_length, reinterpret_cast<void*>(_map_length_HttpResponseHeaderCollection) },
        { Py_mp_subscript, reinterpret_cast<void*>(_map_subscript_HttpResponseHeaderCollection) },
        { Py_mp_ass_subscript, reinterpret_cast<void*>(_map_assign_HttpResponseHeaderCollection) },
        { },
    };

    static PyType_Spec type_spec_HttpResponseHeaderCollection =
    {
        "winrt._winrt_windows_web_http_headers.HttpResponseHeaderCollection",
        sizeof(py::wrapper::Windows::Web::Http::Headers::HttpResponseHeaderCollection),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_HttpResponseHeaderCollection
    };

    // ----- HttpTransferCodingHeaderValue class --------------------

    static PyObject* _new_HttpTransferCodingHeaderValue(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                winrt::Windows::Web::Http::Headers::HttpTransferCodingHeaderValue instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_HttpTransferCodingHeaderValue(py::wrapper::Windows::Web::Http::Headers::HttpTransferCodingHeaderValue* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* HttpTransferCodingHeaderValue_Parse(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpTransferCodingHeaderValue", L"Parse", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Web::Http::Headers::HttpTransferCodingHeaderValue::Parse(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpTransferCodingHeaderValue_ToString(py::wrapper::Windows::Web::Http::Headers::HttpTransferCodingHeaderValue* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpTransferCodingHeaderValue", L"ToString", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.ToString());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpTransferCodingHeaderValue_TryParse(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpTransferCodingHeaderValue", L"TryParse", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                winrt::Windows::Web::Http::Headers::HttpTransferCodingHeaderValue param1 { nullptr };

                auto return_value = winrt::Windows::Web::Http::Headers::HttpTransferCodingHeaderValue::TryParse(param0, param1);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out1.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpTransferCodingHeaderValue_get_Parameters(py::wrapper::Windows::Web::Http::Headers::HttpTransferCodingHeaderValue* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.Headers.HttpTransferCodingHeaderValue", L"Parameters"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Parameters());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HttpTransferCodingHeaderValue_get_Value(py::wrapper::Windows::Web::Http::Headers::HttpTransferCodingHeaderValue* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.Headers.HttpTransferCodingHeaderValue", L"Value"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Value());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_HttpTransferCodingHeaderValue(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Web::Http::Headers::HttpTransferCodingHeaderValue>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_HttpTransferCodingHeaderValue(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Web::Http::Headers::HttpTransferCodingHeaderValue>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _str_HttpTransferCodingHeaderValue(py::wrapper::Windows::Web::Http::Headers::HttpTransferCodingHeaderValue* self) noexcept
    {
        try
        {
            return py::convert(self->obj.ToString());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_HttpTransferCodingHeaderValue[] = {
        { "to_string", reinterpret_cast<PyCFunction>(HttpTransferCodingHeaderValue_ToString), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_HttpTransferCodingHeaderValue, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_HttpTransferCodingHeaderValue), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_HttpTransferCodingHeaderValue[] = {
        { "parameters", reinterpret_cast<getter>(HttpTransferCodingHeaderValue_get_Parameters), nullptr, nullptr, nullptr },
        { "value", reinterpret_cast<getter>(HttpTransferCodingHeaderValue_get_Value), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_HttpTransferCodingHeaderValue[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_HttpTransferCodingHeaderValue) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_HttpTransferCodingHeaderValue) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_HttpTransferCodingHeaderValue) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_HttpTransferCodingHeaderValue) },
        { Py_tp_str, reinterpret_cast<void*>(_str_HttpTransferCodingHeaderValue) },
        { },
    };

    static PyType_Spec type_spec_HttpTransferCodingHeaderValue =
    {
        "winrt._winrt_windows_web_http_headers.HttpTransferCodingHeaderValue",
        sizeof(py::wrapper::Windows::Web::Http::Headers::HttpTransferCodingHeaderValue),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_HttpTransferCodingHeaderValue
    };

    static PyGetSetDef getset_HttpTransferCodingHeaderValue_Static[] = {
        { }
    };

    static PyMethodDef methods_HttpTransferCodingHeaderValue_Static[] = {
        { "parse", reinterpret_cast<PyCFunction>(HttpTransferCodingHeaderValue_Parse), METH_VARARGS, nullptr },
        { "try_parse", reinterpret_cast<PyCFunction>(HttpTransferCodingHeaderValue_TryParse), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_HttpTransferCodingHeaderValue_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_HttpTransferCodingHeaderValue_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_HttpTransferCodingHeaderValue_Static) },
        { }
    };

    static PyType_Spec type_spec_HttpTransferCodingHeaderValue_Static =
    {
        "winrt._winrt_windows_web_http_headers.HttpTransferCodingHeaderValue_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_HttpTransferCodingHeaderValue_Static
    };

    // ----- HttpTransferCodingHeaderValueCollection class --------------------

    static PyObject* _new_HttpTransferCodingHeaderValueCollection(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Web::Http::Headers::HttpTransferCodingHeaderValueCollection>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Web::Http::Headers::HttpTransferCodingHeaderValueCollection>::type_name);
        return nullptr;
    }

    static void _dealloc_HttpTransferCodingHeaderValueCollection(py::wrapper::Windows::Web::Http::Headers::HttpTransferCodingHeaderValueCollection* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* HttpTransferCodingHeaderValueCollection_Append(py::wrapper::Windows::Web::Http::Headers::HttpTransferCodingHeaderValueCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpTransferCodingHeaderValueCollection", L"Append", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Web::Http::Headers::HttpTransferCodingHeaderValue>(args, 0);

                self->obj.Append(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpTransferCodingHeaderValueCollection_Clear(py::wrapper::Windows::Web::Http::Headers::HttpTransferCodingHeaderValueCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpTransferCodingHeaderValueCollection", L"Clear", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Clear();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpTransferCodingHeaderValueCollection_First(py::wrapper::Windows::Web::Http::Headers::HttpTransferCodingHeaderValueCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpTransferCodingHeaderValueCollection", L"First", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.First());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpTransferCodingHeaderValueCollection_GetAt(py::wrapper::Windows::Web::Http::Headers::HttpTransferCodingHeaderValueCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpTransferCodingHeaderValueCollection", L"GetAt", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint32_t>(args, 0);

                return py::convert(self->obj.GetAt(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpTransferCodingHeaderValueCollection_GetMany(py::wrapper::Windows::Web::Http::Headers::HttpTransferCodingHeaderValueCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpTransferCodingHeaderValueCollection", L"GetMany", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<winrt::Windows::Web::Http::Headers::HttpTransferCodingHeaderValue, true>>(args, 1);

                return py::convert(self->obj.GetMany(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpTransferCodingHeaderValueCollection_GetView(py::wrapper::Windows::Web::Http::Headers::HttpTransferCodingHeaderValueCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpTransferCodingHeaderValueCollection", L"GetView", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetView());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpTransferCodingHeaderValueCollection_IndexOf(py::wrapper::Windows::Web::Http::Headers::HttpTransferCodingHeaderValueCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpTransferCodingHeaderValueCollection", L"IndexOf", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Web::Http::Headers::HttpTransferCodingHeaderValue>(args, 0);
                uint32_t param1 {  };

                auto return_value = self->obj.IndexOf(param0, param1);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out1.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpTransferCodingHeaderValueCollection_InsertAt(py::wrapper::Windows::Web::Http::Headers::HttpTransferCodingHeaderValueCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpTransferCodingHeaderValueCollection", L"InsertAt", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Web::Http::Headers::HttpTransferCodingHeaderValue>(args, 1);

                self->obj.InsertAt(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpTransferCodingHeaderValueCollection_ParseAdd(py::wrapper::Windows::Web::Http::Headers::HttpTransferCodingHeaderValueCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpTransferCodingHeaderValueCollection", L"ParseAdd", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                self->obj.ParseAdd(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpTransferCodingHeaderValueCollection_RemoveAt(py::wrapper::Windows::Web::Http::Headers::HttpTransferCodingHeaderValueCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpTransferCodingHeaderValueCollection", L"RemoveAt", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint32_t>(args, 0);

                self->obj.RemoveAt(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpTransferCodingHeaderValueCollection_RemoveAtEnd(py::wrapper::Windows::Web::Http::Headers::HttpTransferCodingHeaderValueCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpTransferCodingHeaderValueCollection", L"RemoveAtEnd", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.RemoveAtEnd();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpTransferCodingHeaderValueCollection_ReplaceAll(py::wrapper::Windows::Web::Http::Headers::HttpTransferCodingHeaderValueCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpTransferCodingHeaderValueCollection", L"ReplaceAll", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<py::pybuf_view<winrt::Windows::Web::Http::Headers::HttpTransferCodingHeaderValue, false>>(args, 0);

                self->obj.ReplaceAll(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpTransferCodingHeaderValueCollection_SetAt(py::wrapper::Windows::Web::Http::Headers::HttpTransferCodingHeaderValueCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpTransferCodingHeaderValueCollection", L"SetAt", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Web::Http::Headers::HttpTransferCodingHeaderValue>(args, 1);

                self->obj.SetAt(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpTransferCodingHeaderValueCollection_ToString(py::wrapper::Windows::Web::Http::Headers::HttpTransferCodingHeaderValueCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpTransferCodingHeaderValueCollection", L"ToString", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.ToString());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpTransferCodingHeaderValueCollection_TryParseAdd(py::wrapper::Windows::Web::Http::Headers::HttpTransferCodingHeaderValueCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Headers.HttpTransferCodingHeaderValueCollection", L"TryParseAdd", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.TryParseAdd(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpTransferCodingHeaderValueCollection_get_Size(py::wrapper::Windows::Web::Http::Headers::HttpTransferCodingHeaderValueCollection* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.Headers.HttpTransferCodingHeaderValueCollection", L"Size"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_HttpTransferCodingHeaderValueCollection(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Web::Http::Headers::HttpTransferCodingHeaderValueCollection>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_HttpTransferCodingHeaderValueCollection(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Web::Http::Headers::HttpTransferCodingHeaderValueCollection>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _str_HttpTransferCodingHeaderValueCollection(py::wrapper::Windows::Web::Http::Headers::HttpTransferCodingHeaderValueCollection* self) noexcept
    {
        try
        {
            return py::convert(self->obj.ToString());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _iterator_HttpTransferCodingHeaderValueCollection(py::wrapper::Windows::Web::Http::Headers::HttpTransferCodingHeaderValueCollection* self) noexcept
    {
        try
        {
            return py::convert(self->obj.First());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static Py_ssize_t _seq_length_HttpTransferCodingHeaderValueCollection(py::wrapper::Windows::Web::Http::Headers::HttpTransferCodingHeaderValueCollection* self) noexcept
    {
        try
        {
            return static_cast<Py_ssize_t>(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _seq_item_HttpTransferCodingHeaderValueCollection(py::wrapper::Windows::Web::Http::Headers::HttpTransferCodingHeaderValueCollection* self, Py_ssize_t i) noexcept
    {
        try
        {
            return py::convert(self->obj.GetAt(static_cast<uint32_t>(i)));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _seq_subscript_HttpTransferCodingHeaderValueCollection(py::wrapper::Windows::Web::Http::Headers::HttpTransferCodingHeaderValueCollection* self, PyObject* slice) noexcept
    {
        try
        {
            if (PyIndex_Check(slice))
            {
                pyobj_handle index{PyNumber_Index(slice)};

                if (!index)
                {
                    return nullptr;
                }

                auto i = PyNumber_AsSsize_t(index.get(), PyExc_IndexError);

                if (i == -1 && PyErr_Occurred())
                {
                    return nullptr;
                }

                return _seq_item_HttpTransferCodingHeaderValueCollection(self, i);
            }

            if (!PySlice_Check(slice))
            {
                PyErr_Format(
                    PyExc_TypeError,
                    "indicies must be integers, not '%s'",
                    Py_TYPE(slice)->tp_name);
            }

            Py_ssize_t start, stop, step, length;

            if (PySlice_GetIndicesEx(
                    slice, self->obj.Size(), &start, &stop, &step, &length)
                < 0)
            {
                return nullptr;
            }

            if (step != 1)
            {
                PyErr_SetString(PyExc_NotImplementedError, "slices with step other than 1 are not implemented");
                return nullptr;
            }

            winrt::com_array<winrt::Windows::Web::Http::Headers::HttpTransferCodingHeaderValue> items(static_cast<uint32_t>(length), empty_instance<winrt::Windows::Web::Http::Headers::HttpTransferCodingHeaderValue>::get());

            auto count = self->obj.GetMany(static_cast<uint32_t>(start), items);

            if (count != static_cast<uint32_t>(length))
            {
                PyErr_Format(PyExc_RuntimeError, "returned count %d did not match requested length %zd", count, length);
                return nullptr;
            }

            return convert(items);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int _seq_assign_HttpTransferCodingHeaderValueCollection(py::wrapper::Windows::Web::Http::Headers::HttpTransferCodingHeaderValueCollection* self, Py_ssize_t i, PyObject* value) noexcept
    {
        try
        {
            if (!value)
            {
                self->obj.RemoveAt(static_cast<uint32_t>(i));
            }
            else
            {
                self->obj.SetAt(static_cast<uint32_t>(i), py::convert_to<winrt::Windows::Web::Http::Headers::HttpTransferCodingHeaderValue>(value));
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyMethodDef _methods_HttpTransferCodingHeaderValueCollection[] = {
        { "append", reinterpret_cast<PyCFunction>(HttpTransferCodingHeaderValueCollection_Append), METH_VARARGS, nullptr },
        { "clear", reinterpret_cast<PyCFunction>(HttpTransferCodingHeaderValueCollection_Clear), METH_VARARGS, nullptr },
        { "first", reinterpret_cast<PyCFunction>(HttpTransferCodingHeaderValueCollection_First), METH_VARARGS, nullptr },
        { "get_at", reinterpret_cast<PyCFunction>(HttpTransferCodingHeaderValueCollection_GetAt), METH_VARARGS, nullptr },
        { "get_many", reinterpret_cast<PyCFunction>(HttpTransferCodingHeaderValueCollection_GetMany), METH_VARARGS, nullptr },
        { "get_view", reinterpret_cast<PyCFunction>(HttpTransferCodingHeaderValueCollection_GetView), METH_VARARGS, nullptr },
        { "index_of", reinterpret_cast<PyCFunction>(HttpTransferCodingHeaderValueCollection_IndexOf), METH_VARARGS, nullptr },
        { "insert_at", reinterpret_cast<PyCFunction>(HttpTransferCodingHeaderValueCollection_InsertAt), METH_VARARGS, nullptr },
        { "parse_add", reinterpret_cast<PyCFunction>(HttpTransferCodingHeaderValueCollection_ParseAdd), METH_VARARGS, nullptr },
        { "remove_at", reinterpret_cast<PyCFunction>(HttpTransferCodingHeaderValueCollection_RemoveAt), METH_VARARGS, nullptr },
        { "remove_at_end", reinterpret_cast<PyCFunction>(HttpTransferCodingHeaderValueCollection_RemoveAtEnd), METH_VARARGS, nullptr },
        { "replace_all", reinterpret_cast<PyCFunction>(HttpTransferCodingHeaderValueCollection_ReplaceAll), METH_VARARGS, nullptr },
        { "set_at", reinterpret_cast<PyCFunction>(HttpTransferCodingHeaderValueCollection_SetAt), METH_VARARGS, nullptr },
        { "to_string", reinterpret_cast<PyCFunction>(HttpTransferCodingHeaderValueCollection_ToString), METH_VARARGS, nullptr },
        { "try_parse_add", reinterpret_cast<PyCFunction>(HttpTransferCodingHeaderValueCollection_TryParseAdd), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_HttpTransferCodingHeaderValueCollection, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_HttpTransferCodingHeaderValueCollection), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_HttpTransferCodingHeaderValueCollection[] = {
        { "size", reinterpret_cast<getter>(HttpTransferCodingHeaderValueCollection_get_Size), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_HttpTransferCodingHeaderValueCollection[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_HttpTransferCodingHeaderValueCollection) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_HttpTransferCodingHeaderValueCollection) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_HttpTransferCodingHeaderValueCollection) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_HttpTransferCodingHeaderValueCollection) },
        { Py_tp_str, reinterpret_cast<void*>(_str_HttpTransferCodingHeaderValueCollection) },
        { Py_tp_iter, reinterpret_cast<void*>(_iterator_HttpTransferCodingHeaderValueCollection) },
        { Py_sq_length, reinterpret_cast<void*>(_seq_length_HttpTransferCodingHeaderValueCollection) },
        { Py_sq_item, reinterpret_cast<void*>(_seq_item_HttpTransferCodingHeaderValueCollection) },
        { Py_mp_subscript, reinterpret_cast<void*>(_seq_subscript_HttpTransferCodingHeaderValueCollection) },
        { Py_sq_ass_item, reinterpret_cast<void*>(_seq_assign_HttpTransferCodingHeaderValueCollection) },
        { },
    };

    static PyType_Spec type_spec_HttpTransferCodingHeaderValueCollection =
    {
        "winrt._winrt_windows_web_http_headers.HttpTransferCodingHeaderValueCollection",
        sizeof(py::wrapper::Windows::Web::Http::Headers::HttpTransferCodingHeaderValueCollection),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_HttpTransferCodingHeaderValueCollection
    };

    // ----- Windows.Web.Http.Headers Initialization --------------------
    PyDoc_STRVAR(module_doc, "Windows::Web::Http::Headers");


    static PyModuleDef module_def
        = {PyModuleDef_HEAD_INIT,
           "_winrt_windows_web_http_headers",
           module_doc,
           0,
           nullptr,
           nullptr,
           nullptr,
           nullptr,
           nullptr};

} // py::cpp::Windows::Web::Http::Headers

PyMODINIT_FUNC PyInit__winrt_windows_web_http_headers(void) noexcept
{
    using namespace py::cpp::Windows::Web::Http::Headers;

    if (py::import_winrt_runtime() == -1)
    {
        return nullptr;
    }

    py::pyobj_handle module{PyModule_Create(&module_def)};

    if (!module)
    {
        return nullptr;
    }

    auto object_type = py::get_object_type();
    if (!object_type)
    {
        return nullptr;
    }

    py::pyobj_handle object_bases{PyTuple_Pack(1, object_type)};

    if (!object_bases)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_HttpCacheDirectiveHeaderValueCollection, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_HttpChallengeHeaderValue_Static{PyType_FromSpec(&type_spec_HttpChallengeHeaderValue_Static)};
    if (!type_HttpChallengeHeaderValue_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_HttpChallengeHeaderValue, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_HttpChallengeHeaderValue_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_HttpChallengeHeaderValueCollection, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_HttpConnectionOptionHeaderValue_Static{PyType_FromSpec(&type_spec_HttpConnectionOptionHeaderValue_Static)};
    if (!type_HttpConnectionOptionHeaderValue_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_HttpConnectionOptionHeaderValue, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_HttpConnectionOptionHeaderValue_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_HttpConnectionOptionHeaderValueCollection, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_HttpContentCodingHeaderValue_Static{PyType_FromSpec(&type_spec_HttpContentCodingHeaderValue_Static)};
    if (!type_HttpContentCodingHeaderValue_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_HttpContentCodingHeaderValue, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_HttpContentCodingHeaderValue_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_HttpContentCodingHeaderValueCollection, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_HttpContentCodingWithQualityHeaderValue_Static{PyType_FromSpec(&type_spec_HttpContentCodingWithQualityHeaderValue_Static)};
    if (!type_HttpContentCodingWithQualityHeaderValue_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_HttpContentCodingWithQualityHeaderValue, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_HttpContentCodingWithQualityHeaderValue_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_HttpContentCodingWithQualityHeaderValueCollection, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_HttpContentDispositionHeaderValue_Static{PyType_FromSpec(&type_spec_HttpContentDispositionHeaderValue_Static)};
    if (!type_HttpContentDispositionHeaderValue_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_HttpContentDispositionHeaderValue, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_HttpContentDispositionHeaderValue_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_HttpContentHeaderCollection, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_HttpContentRangeHeaderValue_Static{PyType_FromSpec(&type_spec_HttpContentRangeHeaderValue_Static)};
    if (!type_HttpContentRangeHeaderValue_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_HttpContentRangeHeaderValue, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_HttpContentRangeHeaderValue_Static.get())) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_HttpCookiePairHeaderValue_Static{PyType_FromSpec(&type_spec_HttpCookiePairHeaderValue_Static)};
    if (!type_HttpCookiePairHeaderValue_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_HttpCookiePairHeaderValue, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_HttpCookiePairHeaderValue_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_HttpCookiePairHeaderValueCollection, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_HttpCredentialsHeaderValue_Static{PyType_FromSpec(&type_spec_HttpCredentialsHeaderValue_Static)};
    if (!type_HttpCredentialsHeaderValue_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_HttpCredentialsHeaderValue, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_HttpCredentialsHeaderValue_Static.get())) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_HttpDateOrDeltaHeaderValue_Static{PyType_FromSpec(&type_spec_HttpDateOrDeltaHeaderValue_Static)};
    if (!type_HttpDateOrDeltaHeaderValue_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_HttpDateOrDeltaHeaderValue, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_HttpDateOrDeltaHeaderValue_Static.get())) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_HttpExpectationHeaderValue_Static{PyType_FromSpec(&type_spec_HttpExpectationHeaderValue_Static)};
    if (!type_HttpExpectationHeaderValue_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_HttpExpectationHeaderValue, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_HttpExpectationHeaderValue_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_HttpExpectationHeaderValueCollection, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_HttpLanguageHeaderValueCollection, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_HttpLanguageRangeWithQualityHeaderValue_Static{PyType_FromSpec(&type_spec_HttpLanguageRangeWithQualityHeaderValue_Static)};
    if (!type_HttpLanguageRangeWithQualityHeaderValue_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_HttpLanguageRangeWithQualityHeaderValue, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_HttpLanguageRangeWithQualityHeaderValue_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_HttpLanguageRangeWithQualityHeaderValueCollection, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_HttpMediaTypeHeaderValue_Static{PyType_FromSpec(&type_spec_HttpMediaTypeHeaderValue_Static)};
    if (!type_HttpMediaTypeHeaderValue_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_HttpMediaTypeHeaderValue, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_HttpMediaTypeHeaderValue_Static.get())) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_HttpMediaTypeWithQualityHeaderValue_Static{PyType_FromSpec(&type_spec_HttpMediaTypeWithQualityHeaderValue_Static)};
    if (!type_HttpMediaTypeWithQualityHeaderValue_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_HttpMediaTypeWithQualityHeaderValue, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_HttpMediaTypeWithQualityHeaderValue_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_HttpMediaTypeWithQualityHeaderValueCollection, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_HttpMethodHeaderValueCollection, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_HttpNameValueHeaderValue_Static{PyType_FromSpec(&type_spec_HttpNameValueHeaderValue_Static)};
    if (!type_HttpNameValueHeaderValue_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_HttpNameValueHeaderValue, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_HttpNameValueHeaderValue_Static.get())) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_HttpProductHeaderValue_Static{PyType_FromSpec(&type_spec_HttpProductHeaderValue_Static)};
    if (!type_HttpProductHeaderValue_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_HttpProductHeaderValue, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_HttpProductHeaderValue_Static.get())) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_HttpProductInfoHeaderValue_Static{PyType_FromSpec(&type_spec_HttpProductInfoHeaderValue_Static)};
    if (!type_HttpProductInfoHeaderValue_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_HttpProductInfoHeaderValue, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_HttpProductInfoHeaderValue_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_HttpProductInfoHeaderValueCollection, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_HttpRequestHeaderCollection, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_HttpResponseHeaderCollection, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_HttpTransferCodingHeaderValue_Static{PyType_FromSpec(&type_spec_HttpTransferCodingHeaderValue_Static)};
    if (!type_HttpTransferCodingHeaderValue_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_HttpTransferCodingHeaderValue, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_HttpTransferCodingHeaderValue_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_HttpTransferCodingHeaderValueCollection, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }


    return module.detach();
}
